id,title,username,language,date,content
ruVJemNS,VIPTools,Sungmingamerpro13,CSS,Sunday 18th of May 2025 01:04:58 PM CDT,"--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
	assert(parent, ""ERROR: WaitForChild: parent is nil"")
	while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
	return parent[childName]
end

-----------------
--| Variables |--
-----------------

local GamePassService = game:GetService('GamePassService')
local PlayersService = game:GetService('Players')
local LightingService = game:GetService('Lighting') --TODO: Use new data store service once that exists

local GamePassIdObject = WaitForChild(script, 'GamePassId')
local AdminTools = WaitForChild(LightingService, 'VIPTools')

-----------------
--| Functions |--
-----------------

-- Makes copies of all the admin tools and puts them in target
local function CloneAdminTools(target)
	for _, tool in pairs(AdminTools:GetChildren()) do
		local toolClone = tool:Clone()
		toolClone.Parent = target
	end
end

-- When a player with the game pass joins, give them the admin tools
local function OnPlayerAdded(player)
	if GamePassService:PlayerHasPass(player, GamePassIdObject.Value) then
		local starterGear = WaitForChild(player, 'StarterGear')
		CloneAdminTools(starterGear)
		if player.Character then -- They've already loaded and won't get their StarterGear until next spawn
			local backpack = WaitForChild(player, 'Backpack')
			CloneAdminTools(backpack)
		end
	end
end

--------------------
--| Script Logic |--
--------------------

PlayersService.PlayerAdded:connect(OnPlayerAdded)
"
Z2aQDTyF,2025-05-18T20:02:08.753011,powerampache,PHP,Sunday 18th of May 2025 01:02:10 PM CDT,"1.01-80 (80) - DB: 83
luci.sixsixsix.powerampache2.domain.errors.NullSessionException: Session is NULL
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository.authToken(BaseAmpacheRepository.kt:87)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository$authToken$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at android.os.Handler.handleCallback(Handler.java:984)
	at android.os.Handler.dispatchMessage(Handler.java:104)
	at android.os.Looper.loopOnce(Looper.java:238)
	at android.os.Looper.loop(Looper.java:357)
	at android.app.ActivityThread.main(ActivityThread.java:8088)
	at java.lang.reflect.Method.invoke(Native Method)
	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:548)
	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:957)

getPlaylists() - generic exception {""detailMessage"":""Session is NULL"",""stackTrace"":[]}"
BV3h78Ar,GPS Installer,ElliNet13,Lua,Sunday 18th of May 2025 12:15:31 PM CDT,"-- GPS Tower installer by ElliNet13
-- Check if advanced
local isAdvanced = term.isColor()
-- Check for any wireless modem
local hasWirelessModem = false
for _, name in ipairs(peripheral.getNames()) do
    if peripheral.getType(name) == ""modem"" then
        local modem = peripheral.wrap(name)
        if modem.isWireless and modem.isWireless() then
            hasWirelessModem = true
            break
        end
    end
end
-- Try GPS
local x, y, z = gps.locate(2)
local gpsWorking = x ~= nil
-- Final check
local ok = isAdvanced and hasWirelessModem
-- Output
print(""Advanced computer:"", isAdvanced)
print(""Wireless modem:"", hasWirelessModem)
print(""GPS working:"", gpsWorking)
if gpsWorking then
    print(""GPS location: x=""..x.."" y=""..y.."" z=""..z)
end
print(""Computer ready (advanced + modem):"", ok)
-- If not ok, reject
if not ok then
    print(""Sorry, you can not be a GPS tower."")
    return
end
-- Ask for 3 numbers
print(""Enter 3 numbers (X Y Z):"")
local input = read()
local userX, userY, userZ = input:match(""^(%-?%d+)%s+(%-?%d+)%s+(%-?%d+)$"")
userX, userY, userZ = tonumber(userX), tonumber(userY), tonumber(userZ)
if not (userX and userY and userZ) then
    print(""Invalid input. Please enter 3 numbers separated by spaces."")
    return
end
-- Show user input
print(""You entered: x=""..userX.."" y=""..userY.."" z=""..userZ)
-- Full command wrapped in shell.run()
local shellCommand = string.format('shell.run(""bg gps host %d %d %d"")', userX, userY, userZ)
-- Paths to check
local startupPaths = {""startup"", ""startup.lua""}
local startupFound = false
-- Append to existing startup or startup.lua
for _, path in ipairs(startupPaths) do
    if fs.exists(path) then
        local file = fs.open(path, ""a"")
        file.writeLine(shellCommand)
        file.close()
        startupFound = true
    end
end
-- If neither existed, create startup
if not startupFound then
    local file = fs.open(""startup"", ""w"")
    file.writeLine(shellCommand)
    file.close()
end
-- Run it now
shell.run(""bg"", ""gps"", ""host"", tostring(userX), tostring(userY), tostring(userZ))
print(""You have now been added as a GPS tower, thanks!"")"
MWq8svyQ,Global Leaderboard,BlonixOne,Lua,Sunday 18th of May 2025 12:12:19 PM CDT,"--[[
this script is for a l´global leaderboard (for the game 'Rainbow Ladder')
]]

-- get the DataStoreService and create an ordered datastore named ""WinsLeaderboard""
local DataStoreService = game:GetService(""DataStoreService"")
local WinsLeaderboard = DataStoreService:GetOrderedDataStore(""WinsLeaderboard"")

-- updates the in-game leaderboard gui with top players from the datastore
local function updateLeaderboard()
	local success, err = pcall(function()
		-- fetch the top 10 players (sorted in descending order by value)
		local ordered = WinsLeaderboard:GetSortedAsync(false, 11, 1)
		local page = ordered:GetCurrentPage()

		-- get GUI elements
		local FrameGui = workspace.Leaderboard.SurfaceGui.Frame
		local Podiums = FrameGui.Parent.Parent.Podiums

		-- clear previous leaderboard entries (except the ""Info"" frame)
		for _, v in FrameGui:GetChildren() do
			if v.ClassName == ""Frame"" and v.Name ~= ""Info"" then
				v:Destroy()
			end
		end

		-- loop through ranked data from the datastore
		for rank, data in page do
			local player = game.Players:GetPlayerByUserId(tonumber(data.key))
			local wins = data.value
			local isOnLeaderboard = false

			-- check if player is already on the leaderboard to avoid duplicates
			for _, v in FrameGui:GetChildren() do
				if v.ClassName == ""Frame"" and v.Name ~= ""Info"" then
					if v.Username.Text == player.Name then
						isOnLeaderboard = true
						break
					end
				end
			end

			-- if player has a valid score and is not yet shown on leaderboard
			if wins and not isOnLeaderboard then
				local podium

				-- choose podium style based on rank
				if rank == 1 then
					podium = Podiums.First:Clone()
				elseif rank == 2 then
					podium = Podiums.Second:Clone()
				elseif rank == 3 then
					podium = Podiums.Third:Clone()
				else
					podium = Podiums.Normal:Clone()
				end

				-- fill in leaderboard entry details
				podium.Rank.Text = tostring(rank)
				podium.Username.Text = player.Name
				podium.Wins.Text = tostring(wins)
				podium.LayoutOrder = rank
				podium.Parent = FrameGui
			end
		end
	end)

	-- warn if the leaderboard failed to update
	if err then
		warn(""Failed to update leaderboard due to the following error: "" .. err)
	end
end

-- saves a player’s win count to the ordered datastore
local function saveWinsData(player: Player)
	pcall(function()
		WinsLeaderboard:SetAsync(player.UserId, player.leaderstats.Wins.Value)
	end)
end

-- background task: auto-save players' wins every 1 second
task.spawn(function()
	while task.wait(1) do
		for _, player in game.Players:GetPlayers() do
			saveWinsData(player)
		end
	end
end)

-- background task: update the leaderboard display every 20 seconds
task.spawn(function()
	while task.wait(20) do
		updateLeaderboard()
	end
end)
"
AGL4YNH8,Coltivare v.2,Vorakh,Lua,Sunday 18th of May 2025 12:06:36 PM CDT,"
local function farm_avanti()
    --print('Avanti')
    for i = 0, 9 do
        turtle.forward()
        local successo, data = turtle.inspectDown()
        if successo then
            if  data.state.age == 7 then
                turtle.digDown()
                turtle.placeDown()
            end
        elseif turtle.placeDown() then

        end
    end
end

local function gira_sx()
    --print('Gira Sinistra')
    turtle.turnLeft()
    turtle.forward()
    turtle.turnLeft()
end

local function gira_dx()
    --print('Gira Destra')
    turtle.turnRight()
    turtle.forward()
    turtle.turnRight()
end

local function torna_base()
    --print('Torna alla base')
    for i = 1, 10 do
        turtle.forward()
    end
    turtle.turnLeft()
    for i = 1, 9 do
        turtle.forward()
    end
    turtle.turnLeft()
end

-- Funzione che controlla se l'inventario della turtle è pieno
function inventarioPieno()
    for slot = 1, 16 do
        if turtle.getItemCount(slot) == 0 then
            return false -- C'è almeno uno slot vuoto
        end
    end
    return true -- Tutti gli slot sono pieni
end


local function gestione_inventario()
    -- Svuota e ricarica le patate
    for slot = 1, 16 do
        turtle.select(slot)
        turtle.dropDown()
        
    end
    turtle.select(1)
    turtle.suckDown(64)
    
end

local function gestione_carburante()
    -- Da implementrare
end

---------------------------------------
-- Programma turtle coltivazione v.2 --
---------------------------------------
print(""Farm automatica Patate"")

while true do
    gestione_inventario()
    if inventarioPieno() then
        print('Sia la cassa che la Turtle sono piene, fare spazio per riprendere la raccolta')
        print('Turtle in attesa...')
    else
        for i = 1, 9 do
        --print('i:'..i)
        if (i%2) == 1 then
            farm_avanti()
            gira_sx()
        else
            farm_avanti()
            gira_dx()
        end
    end
    torna_base()

    print('Finito un ciclo di Raccolta, in attesa di ricrescita prima di iniziare il successivo')
    end
    sleep(60)
end
"
XLTv7YZN,Untitled,AdeonWriter,Linden Scripting,Sunday 18th of May 2025 11:48:39 AM CDT,"integer IsWholeNumber(float number){
    return TRUE;
    if(number == (float)((integer)number)){
        return TRUE;
    }
    else return FALSE;
}

integer GetNumberFromLetter(string single_letter){
    return SubStringIndex(""ABCDEFGHIJKLMNOPQRSTUVWXYZ"", single_letter)+1;
}

string GetLetterFromNumber(integer single_number){
    single_number--;
    return GetSubString(""ABCDEFGHIJKLMNOPQRSTUVWXYZ"", single_number, single_number);
}

integer Core4Alpha(string s){
    return Core4(
        (float)GetNumberFromLetter(GetSubString(s, 0, 0)),
        (float)GetNumberFromLetter(GetSubString(s, 1, 1)),
        (float)GetNumberFromLetter(GetSubString(s, 2, 2)),
        (float)GetNumberFromLetter(GetSubString(s, 3, 3)) );
}

integer Core4(float a, float b, float c, float d)
{
    integer winner = INT_MAX;
    list potential_cores = [];
    if(d!=0) {
        if(IsWholeNumber(((a-b)*c)/d))
        potential_cores += [ ((a-b)*c)/d ];
    }if(c!=0){
        if(IsWholeNumber(((a-b)/c)))
        potential_cores += [ ((a-b)/c)*d ];
    }if(d!=0) {
        if(IsWholeNumber(((a*b)-c)/d))
        potential_cores += [ ((a*b)-c)/d ];
    }if(c!=0){
        if(IsWholeNumber((a*b)/c))
        potential_cores += [ ((a*b)/c)-d ]; 
    }if(b!=0){
        if(IsWholeNumber(a/b))
        potential_cores += [ ((a/b)*c)-d ];
    }if(b!=0){
        if(IsWholeNumber(a/b))
        potential_cores += [ ((a/b)-c)*d ];
    }
    integer i;
    for(i=0; i<GetListLength(potential_cores); i++){
        if(List2Float(potential_cores, i) == (float)((integer)List2Float(potential_cores, i))){
            if(List2Float(potential_cores, i) < winner){
                if(List2Float(potential_cores, i) > 0){
                    winner = (integer)List2Float(potential_cores, i);
                }
            }
        }
    }
    return winner;
}

string TranslateMessage(list words){
    string output;
    integer length = GetListLength(words);
    integer i;
    for(i=0; i<length; i++){
        string word = List2String(words, i);
        output += GetLetterFromNumber(Core4Alpha(word));
    }
    return output;
}"
RvqcL65i,Mine2,Slinger0001,Lua,Sunday 18th of May 2025 11:23:42 AM CDT,"--[[
    Modular Mining Turtle Program
    Features:
    - Mines a rectangular area (WIDTH x DEPTH)
    - Clears blocks in front and above
    - Tracks position and returns to start
    - Handles fuel needs and movement safely
--]]

-- CONFIGURATION
local WIDTH = 50         -- Number of ""rows"" wide (X)
local DEPTH = 50        -- Number of blocks forward per row (Z)
local MIN_FUEL = 50     -- Minimum fuel buffer

-- STATE TRACKING
local currentRow = 0
local currentDepth = 0
local isFacingForward = true

-- SAFETY: Ensure enough fuel
local function ensureFuel()
    if turtle.getFuelLevel() < MIN_FUEL then
        for i = 1, 16 do
            turtle.select(i)
            if turtle.refuel(1) then
                print(""Refueled using slot "" .. i)
                break
            end
        end
    end
end

-- MOVEMENT WRAPPERS (safe movement)
local function tryForward()
    while not turtle.forward() do
        if turtle.detect() then
            turtle.dig()
        else
            sleep(0.5)
        end
    end
end

local function tryUp()
    while not turtle.up() do
        if turtle.detectUp() then
            turtle.digUp()
        else
            sleep(0.5)
        end
    end
end

local function tryDown()
    while not turtle.down() do
        if turtle.detectDown() then
            turtle.digDown()
        else
            sleep(0.5)
        end
    end
end

-- DIGGING HELPERS
local function clearFront()
    if turtle.detect() then turtle.dig() end
end

local function clearUp()
    if turtle.detectUp() then turtle.digUp() end
end

-- MOVE FORWARD 1 BLOCK SAFELY WITH CLEARING
local function moveAndClearForward()
    clearFront()
    clearUp()
    tryForward()
    currentDepth = currentDepth + (isFacingForward and 1 or -1)
end

-- SHIFT RIGHT TO NEXT ROW
local function shiftRowRight()
    turtle.turnRight()
    clearFront()
    tryForward()
    turtle.turnRight()
    isFacingForward = not isFacingForward
    currentRow = currentRow + 1
end

-- SHIFT LEFT TO NEXT ROW
local function shiftRowLeft()
    turtle.turnLeft()
    clearFront()
    tryForward()
    turtle.turnLeft()
    isFacingForward = not isFacingForward
    currentRow = currentRow + 1
end

-- MAIN DIG LOOP
local function mineArea(width, depth)
    for row = 1, width do
        for step = 1, depth - 1 do
            ensureFuel()
            moveAndClearForward()
        end

        if row < width then
            if isFacingForward then
                shiftRowRight()
            else
                shiftRowLeft()
            end
        end
    end
end

-- RETURN TO START POSITION
local function returnToOrigin()
    -- Face original direction (forward)
    if not isFacingForward then
        turtle.turnLeft()
        turtle.turnLeft()
    end

    -- Back out to 0 depth
    for i = 1, math.abs(currentDepth) do
        tryForward()
    end

    -- Face left to return across rows
    turtle.turnLeft()
    for i = 1, currentRow do
        tryForward()
    end

    -- Face forward again
    turtle.turnRight()
end

-- MAIN
print(""Starting mining operation..."")
ensureFuel()
mineArea(WIDTH, DEPTH)
print(""Mining complete. Returning to start..."")
returnToOrigin()
print(""All done."")
"
5EcARuTD,cf.rel (recursive),John4711,JavaScript,Sunday 18th of May 2025 11:08:48 AM CDT,"var ll=[],a=[],u=new Set(),i=0;
ll=[8412];
async function _1(){
    let x=ll.shift();if(!x) return false;i++;
    fetch(""https://radar.cloudflare.com/charts/BgpRoutesRelsTable/fetch?location=as""+x).then(r=>r.json()).then(d=>{
        i--;
        // console.log (x,d.rels.all.length); // ,d.rels.all.map(v=>v.asn));
        for (var v of d.rels.all) if(!u.has(v.asn)){u.add(v.asn);ll.push(v.asn); delete (v.rel); a.push(v); }
        for (var j=i;j<Math.min(ll.length,10);j++) _1();
        let _asn = a.find(item => item.asn === x); if(_asn) {
            _asn.u=d.rels.upstreams.map(v=>v.asn);
            _asn.p=d.rels.peers.map(v=>v.asn);
            _asn.d=d.rels.downstreams.map(v=>v.asn);
            console.log(_asn);
            }
        return d;
    })
    
};
_1();"
EVjSy2Li,"How to make ""Kenworth K-100"" work on the latest game version",Bartal_69,YAML,Sunday 18th of May 2025 10:40:50 AM CDT,"Go to this path in your Steam folder:
...\Steam\steamapps\workshop\content\227300\1814887717\
...\Steamlibrary\steamapps\workshop\content\227300\1814887717\

In this folder open ""versions.sii"" file via any text editor, e.x. in notepad:

============================================ You will see this ============================================
SiiNunit
{
package_version_info : .universal
{
    package_name: ""universal""
	informational: true
}
package_version_info : .c2c
{
    package_name: ""c2c""
	compatible_versions[]: ""1.36.*""
	compatible_versions[]: ""1.35.*""
}
package_version_info : .137
{
    package_name: ""actros_mp2""
	compatible_versions[]: ""1.37.*""
	compatible_versions[]: ""1.38.*""
}
package_version_info : .139
{
    package_name: ""actros_mp3""
	compatible_versions[]: ""1.39.*""
}
}
=========================================================================================================

==================================== And you need change it, to this ====================================
SiiNunit
{
package_version_info : .universal
{
    package_name: ""actros_mp3""
}
}
=========================================================================================================

After that, restart your game if it was launched before this editing.
And Voila!"
CBiSwnqS,forwarding,STANAANDREY,C++,Sunday 18th of May 2025 10:35:14 AM CDT,"#if defined(_MSC_VER)
#include <__msvc_all_public_headers.hpp>
#elif defined(__GNUC__)
#include <bits/stdc++.h>
#else
#error ""Unsupported compiler""
#endif
using namespace std;

class Integer {
public:
	Integer() {
		pval = new int(0);
		cout << ""Integer()"" << endl;
	}
	Integer(int value) {
		pval = new int(value);
		cout << ""Integer(int)"" << endl;
	}
	Integer(const Integer& other) {
		pval = new int(*other.pval);
		cout << ""Integer(const Integer&)"" << endl;
	}
	Integer(Integer&& other) noexcept {
		pval = other.pval;
		other.pval = nullptr;
		cout << ""Integer(Integer&&)"" << endl;
	}
	int get() const {
		return *pval;
	}
	~Integer() {
		delete pval;
		cout << ""~Integer()"" << endl;
	}
private:
	int* pval = nullptr;
};

class Entity {
public:
	template <typename T1, typename T2>
	Entity(T1&& id, T2&& name) : id(forward<T1>(id)), name(forward<T2>(name)) {
		cout << ""Entity(T1&&, T2&&)"" << endl;
	}

	template <typename T1, typename T2>
	static Entity* create(T1&& id, T2&& name) {
		return new Entity{ forward<T1>(Integer{ id }), name };
	}
private:
	Integer id;
	string name;
};

int main() {
	Entity e1{ Integer{1}, ""Alice"" };
	return 0;
}
"
EFUBcTrw,Monster Hutner: Wilds | Dual Blade build May-2025 | 437+48 effective damage,Nyanderful,JSON,Sunday 18th of May 2025 10:24:07 AM CDT,"{
  ""weapon"": {
    ""name"": ""Tiltkreise"",
    ""type"": ""Dual Blades""
  },
  ""artian"": {
    ""element"": ""Ice"",
    ""infusions"": [
      ""Attack"",
      ""Attack"",
      ""Attack""
    ],
    ""upgrades"": [
      ""Attack"",
      ""Attack"",
      ""Sharpness"",
      ""Sharpness"",
      ""Affinity""
    ]
  },
  ""helm"": ""Rey Sandhelm γ"",
  ""body"": ""Rey Sandmail γ"",
  ""arms"": ""Rey Sandbraces γ"",
  ""waist"": ""Gore Coil β"",
  ""legs"": ""Gore Greaves β"",
  ""charm"": ""Marathon Charm III"",
  ""weaponSlots"": [
    ""Frost/Focus Jewel [3]"",
    ""Rzr Sharp/Handicraft Jwl [3]"",
    ""Critical Jewel III [3]""
  ],
  ""helmSlots"": [
    ""Challenger Jewel [3]""
  ],
  ""bodySlots"": [
    ""Mirewalker Jewel [1]""
  ],
  ""armsSlots"": [
    ""Challenger Jewel [3]"",
    ""Chain Jewel [3]""
  ],
  ""waistSlots"": [
    ""Challenger Jewel [3]"",
    ""Earplugs Jewel [2]""
  ],
  ""legsSlots"": [
    ""Counterattack Jewel [3]"",
    ""Sane Jewel [1]"",
    ""Sane Jewel [1]""
  ],
  ""buffs"": {
    ""Frenzy"": 1
  },
  ""uptime"": {
    ""Latent Power"": 100,
    ""Maximum Might"": 100,
    ""Lord's Soul"": 100,
    ""Frenzy"": 100
  }
}"
ZAFag9ZN,Untitled,xConquerPS,JavaScript,Sunday 18th of May 2025 10:17:10 AM CDT,"const fs = require('node:fs');
const http = require('node:http');

const userDB = 'users.json';
function getAllUsers() {
  return new Promise((resolve, reject) => {
    const read = fs.createReadStream(userDB);
    let users = [];

    read.on('data', (chunk) => { users += chunk; });

    read.on('end', () => {
      try {
        return resolve(JSON.parse(users));
      } catch (err) {
        return reject(err);
      }
    });

    read.on('error', (err) => { return reject(err); });
  });
}
function updateUsers(users) {
  fs.createWriteStream(userDB).write(JSON.stringify(users));
}

function userMgr(request, response, status) {
  switch (status) {
    case 'fetch': {
      return getAllUsers().then((users) => { return response.end(JSON.stringify(users)); });
    }
    case 'create': {
      let userObj = null;
      request.on('data', (chunk) => { userObj = JSON.parse(chunk); });
      request.on('end', () => {
        getAllUsers().then((users) => {
          const userIndex = users.findIndex((user) => { return user.id == userObj.id; });

          if (userIndex == -1) {
            users.push(userObj);
            updateUsers(users);
            response.writeHead(201);
            return response.end(JSON.stringify({ message: 'User created successfully.' }));
          } else {
            response.writeHead(409);
            return response.end(JSON.stringify({ message: 'This user already exists.' }));
          }
        });
      });
      break;
    }
    case 'update': {
      let userObj = null;
      request.on('data', (chunk) => { userObj = JSON.parse(chunk); });

      request.on('end', () => {
        getAllUsers().then((users) => {
          const userIndex = users.findIndex((user) => { return user.id == userObj.id });

          if (userIndex == -1) {
            response.writeHead(409);
            return response.end(JSON.stringify({ message: 'This user is not exists.' }));
          } else {
            users[userIndex] = userObj;
            updateUsers(users);

            response.writeHead(201);
            return response.end(JSON.stringify({ message: 'User updated successfully.', }));
          }
        });
      });
      break;
    }
    case 'delete': {
      let userObj = null;
      request.on('data', (chunk) => { userObj = JSON.parse(chunk); });

      request.on('end', () => {
        getAllUsers().then((users) => {
          const userIndex = users.findIndex((user) => { return user.id == userObj.id });

          if (userIndex == -1) {
            response.writeHead(409);
            return response.end(JSON.stringify({ message: 'This user is not exists.' }));
          } else {
            users = users.filter(user => user.id != userObj.id);
            updateUsers(users);

            response.writeHead(201);
            return response.end(JSON.stringify({ message: 'User deleted successfully.', }));
          }
        });
      });
      break;
    }
  }
}

const server = http
  .createServer((request, response) => {
    //Request handler..
    console.log(request.method, request.url);

    switch (request.method) {
      case 'GET': {
        if (request.url == '/users') return userMgr(request, response, 'fetch');
        break;
      }
      case 'POST': {
        if (request.url == '/users') return userMgr(request, response, 'create');
        break;
      }
      case 'PATCH': {
        if (request.url == '/users') return userMgr(request, response, 'update');
        break;
      }
      case 'DELETE': {
        if (request.url == '/users') return userMgr(request, response, 'delete');
        break;
      }
      default: {
        response.writeHead(404);
        response.write('Invalid request.');
        break;
      }
    }
    response.end();
  })
  .listen(4006);"
GJdgL9d3,Untitled,PaffcioStudio,Lua,Sunday 18th of May 2025 10:15:00 AM CDT,"

// FOLDER: /
Ścieżka: /src/__init__.py
Rozmiar: 0,03 KB
Zawartość:
# Plik inicjalizujący moduł src

Ścieżka: app.py:
Zawartość:
# Główny plik aplikacji IDE
#/app.py

import sys
from PyQt6.QtWidgets import QApplication
from PyQt6.QtCore import QLocale
from src.ui import IDEWindow

if __name__ == '__main__':
    app = QApplication(sys.argv)
    QLocale.setDefault(QLocale(QLocale.Language.Polish, QLocale.Country.Poland))
    main_window = IDEWindow()
    main_window.show()
    sys.exit(app.exec())

Ścieżka: /src/config.py
Rozmiar: 7,52 KB
Zawartość:
# Konfiguracja i stałe aplikacji
#/src/config.py

import os
import re
from PyQt6.QtGui import QTextCharFormat, QColor, QFont

APP_DIR = os.path.dirname(os.path.abspath(os.path.dirname(__file__)))
DATA_DIR = os.path.join(APP_DIR, 'userdata')
PROJECTS_DIR = os.path.join(APP_DIR, 'projects')
SETTINGS_FILE = os.path.join(DATA_DIR, 'settings.json')
RECENTS_FILE = os.path.join(DATA_DIR, 'recents.json')
os.makedirs(DATA_DIR, exist_ok=True)
os.makedirs(PROJECTS_DIR, exist_ok=True)

FORMAT_DEFAULT = QTextCharFormat()
FORMAT_KEYWORD = QTextCharFormat()
FORMAT_KEYWORD.setForeground(QColor(""#000080"")) # Navy
FORMAT_STRING = QTextCharFormat()
FORMAT_STRING.setForeground(QColor(""#008000"")) # Green
FORMAT_COMMENT = QTextCharFormat()
FORMAT_COMMENT.setForeground(QColor(""#808080"")) # Gray
FORMAT_COMMENT.setFontItalic(True)
FORMAT_FUNCTION = QTextCharFormat()
FORMAT_FUNCTION.setForeground(QColor(""#0000FF"")) # Blue
FORMAT_CLASS = QTextCharFormat()
FORMAT_CLASS.setForeground(QColor(""#A52A2A"")) # Brown
FORMAT_CLASS.setFontWeight(QFont.Weight.Bold)
FORMAT_NUMBERS = QTextCharFormat()
FORMAT_NUMBERS.setForeground(QColor(""#FF0000"")) # Red
FORMAT_OPERATOR = QTextCharFormat()
FORMAT_OPERATOR.setForeground(QColor(""#A62929"")) # Dark Red
FORMAT_BUILTIN = QTextCharFormat()
FORMAT_BUILTIN.setForeground(QColor(""#008080"")) # Teal
FORMAT_SECTION = QTextCharFormat() # Dla sekcji w INI
FORMAT_SECTION.setForeground(QColor(""#800080"")) # Purple
FORMAT_SECTION.setFontWeight(QFont.Weight.Bold)
FORMAT_PROPERTY = QTextCharFormat() # Dla kluczy/właściwości w INI/JSON
FORMAT_PROPERTY.setForeground(QColor(""#B8860B"")) # DarkGoldenrod

HIGHLIGHTING_RULES = {
    'python': {
        'keywords': ['and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else',
                     'except', 'False', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'None',
                     'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'True', 'try', 'while', 'with', 'yield'],
        'builtins': ['print', 'len', 'range', 'list', 'dict', 'tuple', 'set', 'str', 'int', 'float', 'bool', 'open', 'isinstance'],
        'patterns': [
            (r'\b[A-Za-z_][A-Za-z0-9_]*\s*\(', FORMAT_FUNCTION),
            (r'\bclass\s+([A-Za-z_][A-Za-z0-9_]*)\b', FORMAT_CLASS),
            (r'\b\d+(\.\d*)?\b', FORMAT_NUMBERS),
            (r'[+\-*/=<>!&|]', FORMAT_OPERATOR),
            (r'"".*?""', FORMAT_STRING),
            (r""'.*?'"", FORMAT_STRING),
            (r'#.*', FORMAT_COMMENT),
        ]
    },
    'javascript': {
        'keywords': ['abstract', 'arguments', 'await', 'boolean', 'break', 'byte', 'case', 'catch', 'char', 'class', 'const', 'continue',
                     'debugger', 'default', 'delete', 'do', 'double', 'else', 'enum', 'eval', 'export', 'extends', 'false', 'final',
                     'finally', 'float', 'for', 'function', 'goto', 'if', 'implements', 'import', 'in', 'instanceof', 'int', 'interface',
                     'let', 'long', 'native', 'new', 'null', 'package', 'private', 'protected', 'public', 'return', 'short', 'static',
                     'super', 'switch', 'synchronized', 'this', 'throw', 'throws', 'transient', 'true', 'try', 'typeof', 'var', 'void',
                     'volatile', 'while', 'with', 'yield'],
         'builtins': ['console', 'log', 'warn', 'error', 'info', 'Math', 'Date', 'Array', 'Object', 'String', 'Number', 'Boolean', 'RegExp', 'JSON', 'Promise', 'setTimeout', 'setInterval'],
        'patterns': [
            (r'\b[A-Za-z_][A-Za-z0-9_]*\s*\(', FORMAT_FUNCTION),
             (r'\bclass\s+([A-Za-z_][A-ZaZ0-9_]*)\b', FORMAT_CLASS),
            (r'\b\d+(\.\d*)?\b', FORMAT_NUMBERS),
            (r'[+\-*/=<>!&|]', FORMAT_OPERATOR),
            (r'"".*?""', FORMAT_STRING),
            (r""'.*?'"", FORMAT_STRING),
            (r'//.*', FORMAT_COMMENT),
        ]
    },
     'html': {
        'keywords': [],
        'builtins': [],
        'patterns': [
            (r'<[^>]+>', FORMAT_KEYWORD),
            (r'[a-zA-Z0-9_-]+\s*=', FORMAT_OPERATOR),
            (r'"".*?""', FORMAT_STRING),
            (r""'.*?'"", FORMAT_STRING),
             (r'&[a-zA-Z0-9]+;', FORMAT_BUILTIN),
            (r'<!--.*?-->', FORMAT_COMMENT, re.DOTALL),
        ]
    },
    'css': {
        'keywords': [],
        'builtins': [],
        'patterns': [
            (r'\.[a-zA-Z0-9_-]+', FORMAT_CLASS),
            (r'#[a-zA-Z0-9_-]+', FORMAT_BUILTIN),
            (r'[a-zA-Z0-9_-]+\s*:', FORMAT_KEYWORD),
            (r';', FORMAT_OPERATOR),
            (r'\{|\}', FORMAT_OPERATOR),
             (r'\(|\)', FORMAT_OPERATOR),
            (r'\b\d+(\.\d*)?(px|em|%|vh|vw|rem|pt|cm|mm)?\b', FORMAT_NUMBERS),
             (r'#[0-9a-fA-F]{3,6}', FORMAT_NUMBERS),
            (r'"".*?""', FORMAT_STRING),
            (r""'.*?'"", FORMAT_STRING),
        ]
    },
    'c++': {
         'keywords': ['alignas', 'alignof', 'and', 'and_eq', 'asm', 'atomic_cancel', 'atomic_commit', 'atomic_noexcept', 'auto',
                     'bitand', 'bitor', 'bool', 'break', 'case', 'catch', 'char', 'char8_t', 'char16_t', 'char32_t', 'class',
                     'compl', 'concept', 'const', 'consteval', 'constexpr', 'constinit', 'const_cast', 'continue', 'co_await',
                     'co_return', 'decltype', 'default', 'delete', 'do', 'double', 'dynamic_cast', 'else', 'enum',
                     'explicit', 'export', 'extern', 'false', 'float', 'for', 'friend', 'goto', 'if', 'inline', 'int', 'long',
                     'mutable', 'namespace', 'new', 'noexcept', 'not', 'not_eq', 'nullptr', 'operator', 'or', 'or_eq', 'private',
                     'protected', 'public', 'reflexpr', 'register', 'reinterpret_cast', 'requires', 'return', 'short', 'signed',
                     'sizeof', 'static', 'static_assert', 'static_cast', 'struct', 'switch', 'synchronized', 'template',
                     'this', 'thread_local', 'throw', 'true', 'try', 'typedef', 'typeid', 'typename', 'union', 'unsigned',
                     'using', 'virtual', 'void', 'volatile', 'wchar_t', 'while', 'xor', 'xor_eq'],
         'builtins': ['cout', 'cin', 'endl', 'string', 'vector', 'map', 'set', 'array', 'queue', 'stack', 'pair', 'algorithm', 'iostream', 'fstream', 'sstream', 'cmath', 'cstdlib', 'cstdio', 'ctime'],
         'patterns': [
             (r'\b[A-Za-z_][A-ZaZ0-9_]*\s*\(', FORMAT_FUNCTION),
             (r'\bclass\s+([A-Za-z_][A-ZaZ0-9_]*)\b', FORMAT_CLASS),
             (r'\bstruct\s+([A-Za-z_][A-ZaZ0-9_]*)\b', FORMAT_CLASS),
             (r'\b\d+(\.\d*)?\b', FORMAT_NUMBERS),
             (r'[+\-*/=<>!&|%^~?:]', FORMAT_OPERATOR),
             (r'"".*?""', FORMAT_STRING),
             (r""'.*?'"", FORMAT_STRING),
             (r'//.*', FORMAT_COMMENT),
         ]
    },
    'ini': {
        'keywords': [],
        'builtins': [],
        'patterns': [
            (r'^\[.*?\]', FORMAT_SECTION),
            (r'^[a-zA-Z0-9_-]+\s*=', FORMAT_PROPERTY),
            (r';.*', FORMAT_COMMENT),
            (r'#.*', FORMAT_COMMENT),
            (r'[+\-*/=<>!&|]', FORMAT_OPERATOR),
             (r'=\s*"".*?""', FORMAT_STRING),
             (r""=\s*'.*?'"", FORMAT_STRING),
             (r'=\s*[^;#""\'].*', FORMAT_STRING),
        ]
    },
    'json': {
        'keywords': ['true', 'false', 'null'],
        'builtins': [],
        'patterns': [
            (r'""(?:[^""\\]|\\.)*""\s*:', FORMAT_PROPERTY),
            (r'"".*?""', FORMAT_STRING),
            (r'\b-?\d+(\.\d+)?([eE][+-]?\d+)?\b', FORMAT_NUMBERS),
            (r'\{|\}|\[|\]|:|,', FORMAT_OPERATOR),
        ]
    }
}


Ścieżka: /src/console.py
Rozmiar: 23,59 KB
Zawartość:
# Zarządzanie konsolą i chatem AI
# /src/console.py

import os
import sys
import shlex
import json
import requests
import platform
import markdown2
from PyQt6.QtCore import QProcess, QProcessEnvironment, pyqtSignal, QObject, QTimer, QThread, pyqtSlot
from PyQt6.QtGui import QTextCharFormat, QColor, QFont
from PyQt6.QtWidgets import QPlainTextEdit, QLineEdit, QVBoxLayout, QWidget, QPushButton, QComboBox, QHBoxLayout, QTabWidget, QApplication, QTextEdit

class ConsoleManager(QObject):
    output_received = pyqtSignal(str, bool)  # tekst, is_error
    status_updated = pyqtSignal(str)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.process = QProcess(self)
        self.process.readyReadStandardOutput.connect(self._handle_stdout)
        self.process.readyReadStandardError.connect(self._handle_stderr)
        self.process.finished.connect(self._handle_process_finished)
        
    def run_command(self, command_text, working_dir, python_path="""", node_path=""""):
        if self.process.state() != QProcess.ProcessState.NotRunning:
            self.output_received.emit(""Inny proces już działa. Zakończ go najpierw."", True)
            self.status_updated.emit(""Błąd: Inny proces aktywny."")
            return
        
        try:
            command = shlex.split(command_text)
        except ValueError as e:
            self.output_received.emit(f""Błąd parsowania komendy: {e}"", True)
            self.status_updated.emit(""Błąd parsowania komendy."")
            return
            
        if not command:
            self.output_received.emit(""Błąd: Pusta komenda."", True)
            self.status_updated.emit(""Błąd: Pusta komenda."")
            return
            
        command_str = shlex.join(command)
        self.output_received.emit(f""Uruchamianie: {command_str}\nw katalogu: {working_dir}\n---"", False)
        self.status_updated.emit(""Proces uruchomiony..."")
        
        try:
            self.process.setWorkingDirectory(working_dir)
            env = QProcessEnvironment.systemEnvironment()
            current_path = env.value(""PATH"", """")
            paths_to_prepend = []
            
            if python_path and os.path.exists(python_path):
                py_dir = os.path.dirname(python_path)
                current_path_dirs = [os.path.normcase(p) for p in current_path.split(os.pathsep) if p]
                if os.path.normcase(py_dir) not in current_path_dirs:
                    paths_to_prepend.append(py_dir)
            if node_path and os.path.exists(node_path):
                node_dir = os.path.dirname(node_path)
                if os.path.normcase(node_dir) not in current_path_dirs:
                    paths_to_prepend.append(node_dir)
                    
            if paths_to_prepend:
                new_path = os.pathsep.join(paths_to_prepend) + (os.pathsep + current_path if current_path else """")
                env.insert(""PATH"", new_path)
                
            self.process.setProcessEnvironment(env)
            
            # Poprawka dla Windows: odpal komendy przez cmd.exe
            if platform.system() == ""Windows"":
                self.process.start(""cmd.exe"", [""/c"", command_text])
            else:
                program = command[0]
                arguments = command[1:]
                self.process.start(program, arguments)
                
            if not self.process.waitForStarted(1000):
                error = self.process.errorString()
                self.output_received.emit(f""Nie udało się uruchomić '{command_text}': {error}"", True)
                self.status_updated.emit(f""Błąd uruchamiania: {command_text}"")
        except Exception as e:
            self.output_received.emit(f""Błąd podczas uruchamiania: {e}"", True)
            self.status_updated.emit(""Błąd uruchamiania."")
            
    def _handle_stdout(self):
        while self.process.bytesAvailable():
            data = self.process.readAllStandardOutput()
            try:
                text = bytes(data).decode('utf-8')
            except UnicodeDecodeError:
                text = bytes(data).decode('utf-8', errors='replace')
            self.output_received.emit(text, False)
            
    def _handle_stderr(self):
        while self.process.bytesAvailable():
            data = self.process.readAllStandardError()
            try:
                text = bytes(data).decode('utf-8')
            except UnicodeDecodeError:
                text = bytes(data).decode('utf-8', errors='replace')
            self.output_received.emit(text, True)
            
    def _handle_process_finished(self, exit_code, exit_status):
        self._handle_stdout()
        self._handle_stderr()
        self.output_received.emit(""\n--- Zakończono proces ---"", False)
        if exit_status == QProcess.ExitStatus.NormalExit and exit_code == 0:
            self.output_received.emit(f""Kod wyjścia: {exit_code}"", False)
            self.status_updated.emit(""Proces zakończony pomyślnie."")
        else:
            self.output_received.emit(f""Proces zakończony z błędem (kod: {exit_code})."", True)
            self.status_updated.emit(f""Błąd procesu. Kod wyjścia: {exit_code}"")

class AIWorker(QThread):
    result = pyqtSignal(str, bool)
    status = pyqtSignal(str)
    def __init__(self, ai_manager, message, file_content=None):
        super().__init__()
        self.ai_manager = ai_manager
        self.message = message
        self.file_content = file_content
    def run(self):
        try:
            # Dołącz plik do prompta jeśli jest
            if self.file_content:
                prompt = f""[Kontekst pliku poniżej]\n\n{self.file_content}\n\n[Twoja wiadomość]\n{self.message}""
            else:
                prompt = self.message
            response, is_error = self.ai_manager._send_message_internal(prompt)
            self.result.emit(response, is_error)
            self.status.emit(""Otrzymano odpowiedź od AI."")
        except Exception as e:
            self.result.emit(f""Błąd komunikacji z AI: {e}"", True)
            self.status.emit(""Błąd komunikacji z AI."")

class AIChatManager(QObject):
    output_received = pyqtSignal(str, bool)  # tekst, is_error
    status_updated = pyqtSignal(str)
    models_updated = pyqtSignal(list)  # lista modeli

    def __init__(self, settings, parent=None):
        super().__init__(parent)
        self.settings = settings
        self.api_key = settings.get(""api_key"", """")
        self.gemini_api_key = settings.get(""gemini_api_key"", """")
        self.mistral_api_key = settings.get(""mistral_api_key"", """")
        self.provider = settings.get(""ai_provider"", ""grok"")
        self.base_url = self._get_base_url(self.provider)
        self.current_model = settings.get(""ai_model"", ""grok-3"")
        self.conversation_history = []
        self.mistral_available = self._check_mistral_import()
        self._fetch_models()

    def _check_mistral_import(self):
        try:
            import mistralai
            # Sprawdź wersję
            from pkg_resources import get_distribution
            version = get_distribution(""mistralai"").version
            if version.startswith(""0.""):
                self.output_received.emit(""Zła wersja mistralai! Potrzebujesz 1.0.0+, masz "" + version, True)
                self.status_updated.emit(""Zła wersja biblioteki mistralai!"")
                return False
            return True
        except ImportError:
            self.output_received.emit(""Biblioteka mistralai nie jest zainstalowana! Zainstaluj: pip install mistralai"", True)
            return False

    def update_settings(self, settings):
        self.settings = settings
        self.api_key = settings.get(""api_key"", """")
        self.gemini_api_key = settings.get(""gemini_api_key"", """")
        self.mistral_api_key = settings.get(""mistral_api_key"", """")
        self.provider = settings.get(""ai_provider"", ""grok"")
        self.base_url = self._get_base_url(self.provider)
        self.current_model = settings.get(""ai_model"", ""grok-3"")
        self.mistral_available = self._check_mistral_import()
        self._fetch_models()

    def _get_base_url(self, provider):
        if provider == ""grok"":
            return ""https://api.x.ai/v1""
        elif provider == ""gemini"":
            return ""https://generativelanguage.googleapis.com/v1beta""
        elif provider == ""mistral"":
            return ""https://api.mistral.ai/v1""
        return """"

    def _fetch_models(self):
        self.models_updated.emit([])
        if self.provider == ""grok"":
            try:
                headers = {""Authorization"": f""Bearer {self.api_key}""}
                response = requests.get(f""{self.base_url}/models"", headers=headers)
                response.raise_for_status()
                models_data = response.json()
                models = [model[""id""] for model in models_data.get(""data"", []) if model.get(""id"")]
                if models:
                    self.models_updated.emit(models)
                    self.current_model = models[0] if models else ""grok-3""
                    self.status_updated.emit(""Pobrano listę modeli AI (Grok)."")
                else:
                    self.output_received.emit(""Brak dostępnych modeli w API Grok."", True)
                    self.status_updated.emit(""Błąd: Brak modeli AI Grok."")
            except Exception as e:
                self.output_received.emit(f""Błąd pobierania modeli Grok: {e}"", True)
                self.status_updated.emit(""Błąd pobierania modeli Grok."")
        elif self.provider == ""gemini"":
            try:
                models = [
                    ""gemini-1.5-flash-latest"",
                    ""gemini-1.5-pro-latest"",
                    ""gemini-2.0-flash-thinking-exp-1219"",
                    ""gemini-2.5-flash-preview-04-17""
                ]
                self.models_updated.emit(models)
                self.current_model = models[0]
                self.status_updated.emit(""Dostępne modele Gemini."")
            except Exception as e:
                self.output_received.emit(f""Błąd pobierania modeli Gemini: {e}"", True)
                self.status_updated.emit(""Błąd pobierania modeli Gemini."")
        elif self.provider == ""mistral"":
            if not self.mistral_available:
                self.models_updated.emit([])
                self.status_updated.emit(""Biblioteka mistralai nie jest zainstalowana!"")
                return
            try:
                from mistralai import Mistral
                client = Mistral(api_key=self.mistral_api_key)
                models_data = client.models.list()
                # Poprawka: models_data może być listą Model lub mieć atrybut .data
                if hasattr(models_data, 'data'):
                    models = [m.id for m in models_data.data]
                else:
                    models = [m.id for m in models_data]
                self.models_updated.emit(models)
                if models:
                    self.current_model = models[0]
                    self.status_updated.emit(f""Pobrano modele Mistral: {', '.join(models)}"")
                else:
                    self.output_received.emit(""Brak dostępnych modeli w API Mistral."", True)
                    self.status_updated.emit(""Brak modeli Mistral."")
            except Exception as e:
                self.output_received.emit(f""Błąd pobierania modeli Mistral: {e}"", True)
                self.status_updated.emit(""Błąd pobierania modeli Mistral."")

    def set_model(self, model):
        self.current_model = model
        self.status_updated.emit(f""Zmieniono model na: {model}"")

    def set_provider(self, provider):
        self.provider = provider
        self.base_url = self._get_base_url(self.provider)
        self.mistral_available = self._check_mistral_import()
        self._fetch_models()

    def send_message(self, message, file_content=None):
        if not message.strip():
            self.output_received.emit(""Wiadomość nie może być pusta."", True)
            return
        self.conversation_history.append({""role"": ""user"", ""content"": message})
        self.output_received.emit(f""Użytkownik: {message}"", False)
        # Uruchom AIWorker w tle
        self.worker = AIWorker(self, message, file_content)
        self.worker.result.connect(self._handle_ai_result)
        self.worker.status.connect(self.status_updated)
        self.worker.start()

    def _handle_ai_result(self, text, is_error):
        if not is_error:
            self.conversation_history.append({""role"": ""assistant"", ""content"": text})
        self.output_received.emit(f""AI: {text}"", is_error)

    def _send_message_internal(self, prompt):
        # To jest wywoływane w wątku!
        try:
            if self.provider == ""grok"":
                headers = {
                    ""Authorization"": f""Bearer {self.api_key}"",
                    ""Content-Type"": ""application/json""
                }
                payload = {
                    ""model"": self.current_model,
                    ""messages"": self.conversation_history[:-1] + [{""role"": ""user"", ""content"": prompt}],
                    ""max_tokens"": 2048,
                    ""stream"": False
                }
                response = requests.post(f""{self.base_url}/chat/completions"", headers=headers, json=payload)
                response.raise_for_status()
                response_data = response.json()
                assistant_message = response_data[""choices""][0][""message""][""content""]
                return assistant_message, False
            elif self.provider == ""gemini"":
                headers = {""Content-Type"": ""application/json""}
                params = {""key"": self.gemini_api_key}
                payload = {
                    ""contents"": [
                        {""role"": ""user"", ""parts"": [{""text"": prompt}]}
                    ]
                }
                url = f""{self.base_url}/models/{self.current_model}:generateContent""
                response = requests.post(url, headers=headers, params=params, json=payload)
                response.raise_for_status()
                response_data = response.json()
                try:
                    assistant_message = response_data[""candidates""][0][""content""][""parts""][0][""text""]
                except Exception:
                    assistant_message = str(response_data)
                return assistant_message, False
            elif self.provider == ""mistral"":
                if not self.mistral_available:
                    return (""Biblioteka mistralai nie jest zainstalowana! Zainstaluj: pip install mistralai"", True)
                from mistralai import Mistral, UserMessage, AssistantMessage
                client = Mistral(api_key=self.mistral_api_key)
                messages = [
                    UserMessage(content=msg[""content""]) if msg[""role""] == ""user""
                    else AssistantMessage(content=msg[""content""])
                    for msg in self.conversation_history[:-1]
                ]
                messages.append(UserMessage(content=prompt))
                response = client.chat.complete(
                    model=self.current_model,
                    messages=messages,
                    max_tokens=2048
                )
                assistant_message = response.choices[0].message.content
                return assistant_message, False
            else:
                return (""Nieobsługiwany provider AI."", True)
        except Exception as e:
            return (f""Błąd komunikacji z API: {e}"", True)

    def clear_conversation(self):
        self.conversation_history = []
        self.output_received.emit(""Historia rozmowy wyczyszczona."", False)
        self.status_updated.emit(""Wyczyszczono rozmowę."")

class ConsoleWidget(QWidget):
    def __init__(self, console_manager, ai_chat_manager, parent=None):
        super().__init__(parent)
        self.console_manager = console_manager
        self.ai_chat_manager = ai_chat_manager
        self.current_file_path = None  # Dodane: ścieżka do otwartego pliku
        self._setup_ui()
        self._setup_connections()

    def set_current_file(self, file_path):
        self.current_file_path = file_path

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        self.tab_widget = QTabWidget()
        layout.addWidget(self.tab_widget)
        self.console_tab = QWidget()
        console_layout = QVBoxLayout(self.console_tab)
        console_layout.setContentsMargins(0, 0, 0, 0)
        self.console = QPlainTextEdit()
        self.console.setReadOnly(True)
        self.console.setFont(QFont(""Courier New"", 10))
        console_layout.addWidget(self.console, 1)
        self.console_input = QLineEdit()
        self.console_input.setPlaceholderText(""Wpisz polecenie..."")
        console_layout.addWidget(self.console_input, 0)
        console_buttons_layout = QHBoxLayout()
        console_buttons_layout.addStretch(1)
        self.clear_console_button = QPushButton(""Wyczyść konsolę"")
        console_buttons_layout.addWidget(self.clear_console_button)
        self.copy_console_button = QPushButton(""Skopiuj"")
        console_buttons_layout.addWidget(self.copy_console_button)
        console_layout.addLayout(console_buttons_layout)
        self.tab_widget.addTab(self.console_tab, ""Konsola"")
        # Zakładka Chat AI
        self.ai_tab = QWidget()
        ai_layout = QVBoxLayout(self.ai_tab)
        ai_layout.setContentsMargins(0, 0, 0, 0)
        # ZAMIANA: QTextEdit zamiast QPlainTextEdit
        self.ai_chat = QTextEdit()
        self.ai_chat.setReadOnly(True)
        self.ai_chat.setFont(QFont(""Courier New"", 10))
        ai_layout.addWidget(self.ai_chat, 1)
        ai_input_layout = QHBoxLayout()
        # Dodaj wybór providera AI
        self.ai_provider_combo = QComboBox()
        self.ai_provider_combo.addItems([""grok"", ""gemini"", ""mistral""])
        self.ai_provider_combo.setCurrentText(self.ai_chat_manager.provider)
        # Blokada wyboru Mistral jeśli nie ma biblioteki
        try:
            import mistralai
            mistral_ok = True
        except ImportError:
            mistral_ok = False
        idx = self.ai_provider_combo.findText(""mistral"")
        if idx != -1:
            self.ai_provider_combo.model().item(idx).setEnabled(mistral_ok)
            if not mistral_ok and self.ai_provider_combo.currentText() == ""mistral"":
                self.ai_provider_combo.setCurrentText(""grok"")
        ai_input_layout.addWidget(self.ai_provider_combo)
        self.ai_model_combo = QComboBox()
        self.ai_model_combo.setPlaceholderText(""Wybierz model..."")
        ai_input_layout.addWidget(self.ai_model_combo)
        self.ai_input = QLineEdit()
        self.ai_input.setPlaceholderText(""Wpisz wiadomość do AI..."")
        ai_input_layout.addWidget(self.ai_input)
        self.ai_send_button = QPushButton(""Wyślij"")
        ai_input_layout.addWidget(self.ai_send_button)
        self.ai_clear_button = QPushButton(""Wyczyść"")
        ai_input_layout.addWidget(self.ai_clear_button)
        ai_layout.addLayout(ai_input_layout)
        self.tab_widget.addTab(self.ai_tab, ""Chat AI"")

    def _setup_connections(self):
        self.console_manager.output_received.connect(self._append_console_output)
        self.console_input.returnPressed.connect(self._run_console_command)
        self.clear_console_button.clicked.connect(self.console.clear)
        self.copy_console_button.clicked.connect(self._copy_console)
        self.ai_chat_manager.output_received.connect(self._append_ai_output)
        self.ai_chat_manager.models_updated.connect(self._update_model_combo)
        self.ai_input.returnPressed.connect(self._send_ai_message)
        self.ai_send_button.clicked.connect(self._send_ai_message)
        self.ai_clear_button.clicked.connect(self.ai_chat_manager.clear_conversation)
        self.ai_model_combo.currentTextChanged.connect(self.ai_chat_manager.set_model)
        # Nowe: zmiana providera AI z poziomu UI
        self.ai_provider_combo.currentTextChanged.connect(self._on_provider_changed)

    def _on_provider_changed(self, provider):
        self.ai_chat_manager.set_provider(provider)
        # Po zmianie providera, pobierz modele tylko dla niego
        # (AIChatManager sam wywołuje _fetch_models, a sygnał models_updated odświeża model_combo)

    def _append_console_output(self, text, is_error):
        cursor = self.console.textCursor()
        cursor.movePosition(cursor.MoveOperation.End)
        fmt = QTextCharFormat()
        if is_error:
            fmt.setForeground(QColor(""#DC143C""))
        cursor.setCharFormat(fmt)
        text_to_insert = text + ('\n' if text and not text.endswith('\n') else '')
        cursor.insertText(text_to_insert)
        self.console.setTextCursor(cursor)
        self.console.ensureCursorVisible()

    def _append_ai_output(self, text, is_error):
        # Jeśli to błąd, wyświetl na czerwono bez HTML
        if is_error:
            cursor = self.ai_chat.textCursor()
            cursor.movePosition(cursor.MoveOperation.End)
            fmt = QTextCharFormat()
            fmt.setForeground(QColor(""#DC143C""))
            cursor.setCharFormat(fmt)
            text_to_insert = text + ('\n' if text and not text.endswith('\n') else '')
            cursor.insertText(text_to_insert)
            self.ai_chat.setTextCursor(cursor)
            self.ai_chat.ensureCursorVisible()
            return
        # Zamiana Markdown na HTML
        html = markdown2.markdown(text, extras=[""fenced-code-blocks"", ""tables"", ""strike"", ""cuddled-lists"", ""code-friendly""]) 
        # Dodanie stylu dla bloków kodu i przycisku kopiowania
        html = html.replace('<code>', '<code style=""background:#f6f8fa; border-radius:4px; padding:2px 4px;"">')
        html = html.replace('<pre><code', '<div style=""position:relative;""><button onclick=\'navigator.clipboard.writeText(this.nextElementSibling.innerText)\' style=\'position:absolute;top:4px;right:4px;z-index:2;font-size:10px;padding:2px 6px;\'>Kopiuj kod</button><pre style=""background:#f6f8fa;border-radius:6px;padding:8px 12px;overflow:auto;""><code')
        html = html.replace('</code></pre>', '</code></pre></div>')
        self.ai_chat.moveCursor(self.ai_chat.textCursor().End)
        self.ai_chat.insertHtml(html + ""<br>"")
        self.ai_chat.ensureCursorVisible()

    def _copy_console(self):
        console_text = self.console.toPlainText()
        if console_text:
            QApplication.clipboard().setText(console_text)

    def _run_console_command(self):
        command = self.console_input.text().strip()
        if command:
            self.console_input.clear()
            self.console_manager.run_command(command, os.getcwd())

    def _send_ai_message(self):
        message = self.ai_input.text().strip()
        if message:
            self.ai_input.clear()
            file_content = None
            if self.current_file_path:
                try:
                    with open(self.current_file_path, 'r', encoding='utf-8') as f:
                        file_content = f.read()
                except Exception:
                    file_content = None
            self.ai_chat_manager.send_message(message, file_content=file_content)

    def _update_model_combo(self, models):
        self.ai_model_combo.clear()
        if models:
            self.ai_model_combo.addItems(models)
            if self.ai_chat_manager.current_model in models:
                self.ai_model_combo.setCurrentText(self.ai_chat_manager.current_model)

Ścieżka: /src/dialogs.py
Rozmiar: 12,94 KB
Zawartość:
# Dialogi dla IDE – tworzenie projektów, plików, zmiana nazw, ustawienia
# /src/dialogs.py

import os
import re
import sys
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
from PyQt6.QtWidgets import (
    QDialog, QFormLayout, QLineEdit, QDialogButtonBox, QHBoxLayout,
    QPushButton, QComboBox, QFileDialog, QLabel, QSpinBox, QVBoxLayout,
    QTableWidget, QTableWidgetItem, QHeaderView, QMessageBox
)
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QFont

class NewProjectDialog(QDialog):
    def __init__(self, projects_dir, parent=None):
        super().__init__(parent)
        self.setWindowTitle(""Nowy projekt"")
        self.projects_dir = projects_dir
        self.setModal(True)
        layout = QFormLayout(self)
        self.name_edit = QLineEdit()
        layout.addRow(""Nazwa projektu:"", self.name_edit)
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setText(""Utwórz"")
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addRow(self.button_box)
        self.name_edit.textChanged.connect(self._validate_name)
        self.name_edit.textChanged.emit(self.name_edit.text())

    def _validate_name(self, name):
        name = name.strip()
        is_empty = not name
        is_valid_chars = re.fullmatch(r'[a-zA-Z0-9_-]+', name) is not None or name == """"
        full_path = os.path.join(self.projects_dir, name)
        dir_exists = os.path.exists(full_path)
        enable_ok = not is_empty and is_valid_chars and not dir_exists
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setEnabled(enable_ok)
        if is_empty:
            self.name_edit.setToolTip(""Nazwa projektu nie może być pusta."")
        elif not is_valid_chars:
            self.name_edit.setToolTip(""Nazwa projektu może zawierać tylko litery, cyfry, podkreślenia i myślniki."")
        elif dir_exists:
            self.name_edit.setToolTip(f""Projekt o nazwie '{name}' już istnieje w:\n{self.projects_dir}"")
        else:
            self.name_edit.setToolTip(f""Katalog projektu zostanie utworzony w:\n{full_path}"")
        if not enable_ok and not is_empty:
            self.name_edit.setStyleSheet(""background-color: #ffe0e0;"")
        else:
            self.name_edit.setStyleSheet("""")

    def get_project_name(self):
        return self.name_edit.text().strip()

    def get_project_path(self):
        return os.path.join(self.projects_dir, self.get_project_name())

class NewItemDialog(QDialog):
    def __init__(self, parent_dir, is_folder=False, parent=None):
        super().__init__(parent)
        self.setWindowTitle(""Nowy folder"" if is_folder else ""Nowy plik"")
        self.parent_dir = parent_dir
        self.is_folder = is_folder
        self.setModal(True)
        layout = QFormLayout(self)
        self.item_type_label = ""Nazwa folderu:"" if is_folder else ""Nazwa pliku:""
        self.name_edit = QLineEdit()
        layout.addRow(self.item_type_label, self.name_edit)
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addRow(self.button_box)
        self.name_edit.textChanged.connect(self._validate_name)
        self.name_edit.textChanged.emit(self.name_edit.text())

    def _validate_name(self, name):
        name = name.strip()
        is_empty = not name
        illegal_chars_pattern = r'[<>:""/\\|?*\x00-\x1F]'
        is_valid_chars = re.search(illegal_chars_pattern, name) is None
        full_path = os.path.join(self.parent_dir, name)
        item_exists = os.path.exists(full_path)
        enable_create = not is_empty and is_valid_chars and not item_exists
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setEnabled(enable_create)
        if is_empty:
            self.name_edit.setToolTip(f""{self.item_type_label} nie może być pusta."")
        elif not is_valid_chars:
            self.name_edit.setToolTip(""Nazwa zawiera niedozwolone znaki."")
        elif item_exists:
            self.name_edit.setToolTip(f""Element o nazwie '{name}' już istnieje w:\n{self.parent_dir}"")
        else:
            self.name_edit.setToolTip("""")
        if not enable_create and not is_empty:
            self.name_edit.setStyleSheet(""background-color: #ffe0e0;"")
        else:
            self.name_edit.setStyleSheet("""")

    def get_item_name(self):
        return self.name_edit.text().strip()

class RenameItemDialog(QDialog):
    def __init__(self, current_path, parent=None):
        super().__init__(parent)
        self.current_path = current_path
        self.is_folder = os.path.isdir(current_path)
        old_name = os.path.basename(current_path)
        self.setWindowTitle(""Zmień nazwę"")
        layout = QFormLayout(self)
        self.label = QLabel(f""Nowa nazwa dla '{old_name}':"")
        self.line_edit = QLineEdit(old_name)
        layout.addRow(self.label, self.line_edit)
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addRow(self.button_box)
        self.line_edit.textChanged.connect(self._validate_name)
        self._validate_name(self.line_edit.text())

    def _validate_name(self, name):
        name = name.strip()
        is_empty = not name
        illegal_chars_pattern = r'[<>:""/\\|?*\x00-\x1F]'
        is_valid_chars = re.search(illegal_chars_pattern, name) is None
        old_name = os.path.basename(self.current_path)
        is_same_name = name == old_name
        parent_dir = os.path.dirname(self.current_path)
        new_full_path = os.path.join(parent_dir, name)
        item_exists_at_new_path = os.path.exists(new_full_path)
        enable_ok = not is_empty and is_valid_chars and (is_same_name or not item_exists_at_new_path)
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setEnabled(enable_ok)

    def get_new_name(self):
        return self.line_edit.text().strip()

class SettingsDialog(QDialog):
    def __init__(self, current_settings, parent=None):
        super().__init__(parent)
        self.setWindowTitle(""Ustawienia IDE"")
        self.current_settings = current_settings.copy()
        self.setMinimumWidth(400)
        self.setModal(True)
        self._setup_ui()

    def _setup_ui(self):
        layout = QFormLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(10)

        self.theme_combo = QComboBox()
        self.theme_combo.addItems([""light"", ""dark""])
        self.theme_combo.setCurrentText(self.current_settings.get(""theme"", ""light""))
        layout.addRow(""Motyw:"", self.theme_combo)

        self.python_path_input = QLineEdit()
        self.python_path_input.setText(self.current_settings.get(""python_path"", """"))
        self.python_browse_button = QPushButton(""Przeglądaj..."")
        self.python_browse_button.clicked.connect(self._browse_python_path)
        python_layout = QHBoxLayout()
        python_layout.addWidget(self.python_path_input)
        python_layout.addWidget(self.python_browse_button)
        layout.addRow(""Ścieżka Python:"", python_layout)

        self.node_path_input = QLineEdit()
        self.node_path_input.setText(self.current_settings.get(""node_path"", """"))
        self.node_browse_button = QPushButton(""Przeglądaj..."")
        self.node_browse_button.clicked.connect(self._browse_node_path)
        node_layout = QHBoxLayout()
        node_layout.addWidget(self.node_path_input)
        node_layout.addWidget(self.node_browse_button)
        layout.addRow(""Ścieżka Node.js:"", node_layout)

        # Nowy wybór dostawcy AI
        self.ai_provider_combo = QComboBox()
        self.ai_provider_combo.addItems([""grok"", ""gemini"", ""mistral""])
        self.ai_provider_combo.setCurrentText(self.current_settings.get(""ai_provider"", ""grok""))
        layout.addRow(""Dostawca AI:"", self.ai_provider_combo)

        # Klucz API xAI
        self.api_key_input = QLineEdit()
        self.api_key_input.setText(self.current_settings.get(""api_key"", """"))
        self.api_key_input.setEchoMode(QLineEdit.EchoMode.Password)
        layout.addRow(""Klucz API xAI:"", self.api_key_input)
        # Klucz API Gemini
        self.gemini_api_key_input = QLineEdit()
        self.gemini_api_key_input.setText(self.current_settings.get(""gemini_api_key"", """"))
        self.gemini_api_key_input.setEchoMode(QLineEdit.EchoMode.Password)
        layout.addRow(""Klucz API Gemini:"", self.gemini_api_key_input)
        # Klucz API Mistral
        self.mistral_api_key_input = QLineEdit()
        self.mistral_api_key_input.setText(self.current_settings.get(""mistral_api_key"", """"))
        self.mistral_api_key_input.setEchoMode(QLineEdit.EchoMode.Password)
        layout.addRow(""Klucz API Mistral:"", self.mistral_api_key_input)

        # Model AI – dynamicznie aktualizowany przez AIChatManager
        self.ai_model_combo = QComboBox()
        self.ai_model_combo.addItems([self.current_settings.get(""ai_model"", ""grok-3"")])
        self.ai_model_combo.setCurrentText(self.current_settings.get(""ai_model"", ""grok-3""))
        layout.addRow(""Model AI:"", self.ai_model_combo)

        self.font_size_combo = QComboBox()
        self.font_size_combo.addItems([str(i) for i in range(8, 21)])
        self.font_size_combo.setCurrentText(str(self.current_settings.get(""editor_font_size"", 10)))
        layout.addRow(""Rozmiar czcionki edytora:"", self.font_size_combo)

        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addRow(self.button_box)

        # Zmiana widoczności kluczy API w zależności od dostawcy
        self.ai_provider_combo.currentTextChanged.connect(self._update_api_key_visibility)
        self._update_api_key_visibility(self.ai_provider_combo.currentText())
        # Blokada wyboru Mistral jeśli nie ma biblioteki
        self._block_mistral_if_missing()

    def _block_mistral_if_missing(self):
        try:
            import mistralai
            mistral_ok = True
        except ImportError:
            mistral_ok = False
        idx = self.ai_provider_combo.findText(""mistral"")
        if idx != -1:
            self.ai_provider_combo.model().item(idx).setEnabled(mistral_ok)
            if not mistral_ok and self.ai_provider_combo.currentText() == ""mistral"":
                self.ai_provider_combo.setCurrentText(""grok"")

    def _update_api_key_visibility(self, provider):
        self.api_key_input.setEnabled(provider == ""grok"")
        self.gemini_api_key_input.setEnabled(provider == ""gemini"")
        self.mistral_api_key_input.setEnabled(provider == ""mistral"")

    def _browse_python_path(self):
        # Wybierz Pythona, jakbyś wybierał psa na spacer 🐶
        file_path, _ = QFileDialog.getOpenFileName(
            self, ""Wybierz plik wykonywalny Pythona"", """",
            ""Pliki wykonywalne (*.exe);;Wszystkie pliki (*)""
        )
        if file_path:
            self.python_path_input.setText(file_path)

    def _browse_node_path(self):
        # Node.js – dla fanów async chaosu 😜
        file_path, _ = QFileDialog.getOpenFileName(
            self, ""Wybierz plik wykonywalny Node.js"", """",
            ""Pliki wykonywalne (*.exe);;Wszystkie pliki (*)""
        )
        if file_path:
            self.node_path_input.setText(file_path)

    def get_settings(self):
        # Zwraca ustawienia jak pizzę – wszystko, czego chciałeś 🍕
        api_key = self.api_key_input.text()
        gemini_api_key = self.gemini_api_key_input.text()
        mistral_api_key = self.mistral_api_key_input.text()
        # Jeśli przez przypadek pole zostało nadpisane funkcją, wymuś string
        if not isinstance(api_key, str):
            api_key = str(api_key)
        if not isinstance(gemini_api_key, str):
            gemini_api_key = str(gemini_api_key)
        if not isinstance(mistral_api_key, str):
            mistral_api_key = str(mistral_api_key)
        return {
            ""theme"": self.theme_combo.currentText(),
            ""python_path"": self.python_path_input.text().strip(),
            ""node_path"": self.node_path_input.text().strip(),
            ""ai_provider"": self.ai_provider_combo.currentText(),
            ""api_key"": api_key.strip(),
            ""gemini_api_key"": gemini_api_key.strip(),
            ""mistral_api_key"": mistral_api_key.strip(),
            ""ai_model"": self.ai_model_combo.currentText(),
            ""editor_font_size"": int(self.font_size_combo.currentText())
        }

Ścieżka: /src/filesystem.py
Rozmiar: 2,23 KB
Zawartość:
# Model systemu plików
#/src/filesystem.py

import os
from PyQt6.QtGui import QFileSystemModel
from PyQt6.QtCore import Qt
try:
    import qtawesome as qta
except ImportError:
    qta = None

class CustomFileSystemModel(QFileSystemModel):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.icon_map = {
            '.py': 'fa5s.file-code',
            '.js': 'fa5s.file-code',
            '.json': 'fa5s.file-code',
            '.html': 'fa5s.file-code',
            '.css': 'fa5s.file-code',
            '.ini': 'fa5s.file-alt',
            '.txt': 'fa5s.file-alt',
            '.md': 'fa5s.file-alt',
            '.c': 'fa5s.file-code',
            '.cpp': 'fa5s.file-code',
            '.h': 'fa5s.file-code',
            '.hpp': 'fa5s.file-code',
        }
        self.folder_icon_name = 'fa5s.folder'
        self.default_file_icon_name = 'fa5s.file'
        self._has_qtawesome = qta is not None

    def rename(self, index, new_name):
        if not index.isValid():
            return False
        old_path = self.filePath(index)
        new_path = os.path.join(os.path.dirname(old_path), new_name)
        try:
            os.rename(old_path, new_path)
            self.refresh()
            return True
        except Exception as e:
            print(f""Błąd zmiany nazwy: {e}"")
            return False

    def data(self, index, role=Qt.ItemDataRole.DisplayRole):
        if not index.isValid():
            return None
        if role == Qt.ItemDataRole.DecorationRole:
            file_info = self.fileInfo(index)
            if file_info.isDir():
                return qta.icon(self.folder_icon_name) if self._has_qtawesome else super().data(index, role)
            elif file_info.isFile():
                extension = file_info.suffix().lower()
                dotted_extension = '.' + extension
                if dotted_extension in self.icon_map and self._has_qtawesome:
                    return qta.icon(self.icon_map[dotted_extension])
                return qta.icon(self.default_file_icon_name) if self._has_qtawesome else super().data(index, role)
        return super().data(index, role)

    def refresh(self, *args):
        self.setRootPath(self.rootPath())

Ścieżka: /src/highlighter.py
Rozmiar: 3,31 KB
Zawartość:
# Kolorowanie składni dla edytora
#/src/highlighter.py

import re
from PyQt6.QtGui import QSyntaxHighlighter, QTextDocument
from src.config import FORMAT_DEFAULT, FORMAT_COMMENT, HIGHLIGHTING_RULES

class CodeSyntaxHighlighter(QSyntaxHighlighter):
    def __init__(self, parent: QTextDocument, language: str):
        super().__init__(parent)
        self._language = language.lower()
        self._rules = []
        lang_config = HIGHLIGHTING_RULES.get(self._language, {})
        keywords = lang_config.get('keywords', [])
        builtins = lang_config.get('builtins', [])
        patterns = lang_config.get('patterns', [])
        for keyword in keywords:
            pattern = r'\b' + re.escape(keyword) + r'\b'
            self._rules.append((re.compile(pattern), lang_config.get('keyword_format', FORMAT_DEFAULT)))
        for builtin in builtins:
            pattern = r'\b' + re.escape(builtin) + r'\b'
            self._rules.append((re.compile(pattern), lang_config.get('builtin_format', FORMAT_DEFAULT)))
        for pattern_str, format, *flags in patterns:
            try:
                pattern = re.compile(pattern_str, *flags)
                self._rules.append((pattern, format))
            except re.error as e:
                print(f""Błąd regex '{pattern_str}' dla {self._language}: {e}"")

    def highlightBlock(self, text: str):
        self.setFormat(0, len(text), FORMAT_DEFAULT)
        self.setCurrentBlockState(0)
        block_comment_delimiters = []
        if self._language in ['javascript', 'css', 'c++']:
            block_comment_delimiters.append((""/*"", ""*/"", FORMAT_COMMENT))
        comment_start_in_prev_block = (self.previousBlockState() == 1)
        if comment_start_in_prev_block:
            end_delimiter_index = text.find(""*/"")
            if end_delimiter_index >= 0:
                self.setFormat(0, end_delimiter_index + 2, FORMAT_COMMENT)
                self.setCurrentBlockState(0)
                start_pos = end_delimiter_index + 2
            else:
                self.setFormat(0, len(text), FORMAT_COMMENT)
                self.setCurrentBlockState(1)
                return
        else:
            start_pos = 0
        start_delimiter = ""/*""
        end_delimiter = ""*/""
        startIndex = text.find(start_delimiter, start_pos)
        while startIndex >= 0:
            endIndex = text.find(end_delimiter, startIndex)
            if endIndex >= 0:
                length = endIndex - startIndex + len(end_delimiter)
                self.setFormat(startIndex, startIndex + length, FORMAT_COMMENT)
                startIndex = text.find(start_delimiter, startIndex + length)
            else:
                self.setFormat(startIndex, len(text) - startIndex, FORMAT_COMMENT)
                self.setCurrentBlockState(1)
                break
        for pattern, format in self._rules:
            if format == FORMAT_COMMENT and (pattern.pattern.startswith(re.escape('/*')) or pattern.pattern.startswith(re.escape('<!--'))):
                continue
            if format == FORMAT_COMMENT and pattern.pattern.startswith('//') and self.currentBlockState() == 1:
                continue
            for match in pattern.finditer(text):
                start, end = match.span()
                self.setFormat(start, end, format)

                

Ścieżka: /src/models.py
Rozmiar: 1,48 KB
Zawartość:
# Modele danych aplikacji
#/src/models.py

import os
import json
from src.config import SETTINGS_FILE, RECENTS_FILE

class AppState:
    def __init__(self):
        self.settings = {
            ""theme"": ""light"",
            ""python_path"": """",
            ""node_path"": """",
            ""show_tree"": True,
            ""show_console"": True,
            ""editor_font_size"": 10
        }
        self.recents = {""last_project_dir"": None, ""open_files"": []}

    def load(self):
        try:
            if os.path.exists(SETTINGS_FILE):
                with open(SETTINGS_FILE, 'r', encoding='utf-8') as f:
                    self.settings.update(json.load(f))
            if os.path.exists(RECENTS_FILE):
                with open(RECENTS_FILE, 'r', encoding='utf-8') as f:
                    self.recents.update(json.load(f))
        except Exception as e:
            print(f""Błąd wczytywania stanu: {e}"")

    def save(self, open_files, project_dir):
        try:
            self.recents[""open_files""] = list(open_files)
            if project_dir and os.path.isdir(project_dir):
                self.recents[""last_project_dir""] = os.path.normpath(project_dir)
            with open(SETTINGS_FILE, 'w', encoding='utf-8') as f:
                json.dump(self.settings, f, indent=4)
            with open(RECENTS_FILE, 'w', encoding='utf-8') as f:
                json.dump(self.recents, f, indent=4)
        except Exception as e:
            print(f""Błąd zapisu stanu: {e}"")

Ścieżka: /src/package_manager.py
Rozmiar: 41,10 KB
Zawartość:
import os
import re
import requests
import zipfile
import tarfile
import json
import shutil
import subprocess
import py7zr
from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QProgressBar, QTableWidget, QTableWidgetItem, QHeaderView, QPushButton, QApplication, QHBoxLayout, QWidget
from PyQt6.QtCore import QThread, pyqtSignal, Qt
from PyQt6.QtGui import QColor, QIcon
from src.theme import get_dark_package_manager_stylesheet, get_light_package_manager_stylesheet

# Ustaw katalog do przechowywania pakietów, tworząc go, jeśli nie istnieje
PACKAGES_DIR = os.path.abspath(""packages"")
os.makedirs(PACKAGES_DIR, exist_ok=True)

class DownloadWorker(QThread):
    """"""Klasa wątku do obsługi pobierania i instalacji pakietów w tle.""""""
    progress = pyqtSignal(int)  # Sygnał wysyłający postęp operacji (0-100)
    finished = pyqtSignal(str)  # Sygnał wysyłający komunikat o pomyślnym zakończeniu
    error = pyqtSignal(str)     # Sygnał wysyłający komunikat o błędzie

    def __init__(self, func, package_name):
        """"""
        Inicjalizuje wątek.
        :param func: Funkcja do wykonania w wątku (np. instalacja).
        :param package_name: Nazwa pakietu do wyświetlania w komunikatach.
        """"""
        super().__init__()
        self.func = func
        self.package_name = package_name

    def run(self):
        """"""Główna pętla wątku, wykonująca przekazaną funkcję.""""""
        try:
            self.func(progress_callback=self.progress.emit)
            self.finished.emit(f""Operacja dla {self.package_name} zakończona pomyślnie."")
        except Exception as e:
            self.error.emit(f""Błąd podczas operacji dla {self.package_name}: {str(e)}"")

class PackageManager:
    """"""Klasa zarządzająca pakietami (pobieranie, instalacja, odinstalowanie).""""""
    def __init__(self, parent=None):
        """"""
        Inicjalizuje menadżera pakietów.
        :param parent: Obiekt nadrzędny (opcjonalne, dla kontekstu ścieżki).
        """"""
        self.parent = parent
        base_dir = os.path.dirname(__file__) if '__file__' in locals() else os.getcwd()
        self.settings_path = os.path.abspath(os.path.join(base_dir, "".."", ""userdata"", ""settings.json""))
        os.makedirs(os.path.dirname(self.settings_path), exist_ok=True)

    def _download_file(self, url, dest_path, progress_callback=None):
        """"""
        Pobiera plik z podanego URL do wskazanej ścieżki.
        :param url: Adres URL pliku.
        :param dest_path: Ścieżka docelowa zapisu pliku.
        :param progress_callback: Funkcja callback do raportowania postępu.
        """"""
        try:
            response = requests.get(url, stream=True, timeout=15)
            response.raise_for_status()
            total = int(response.headers.get('content-length', 0))
            downloaded = 0
            with open(dest_path, ""wb"") as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
                        downloaded += len(chunk)
                        if total > 0 and progress_callback:
                            percent = int(downloaded * 100 / total)
                            progress_callback(percent)
            if progress_callback:
                progress_callback(100)
        except requests.exceptions.Timeout:
            raise RuntimeError(f""Upłynął czas oczekiwania na odpowiedź serwera podczas pobierania z {url}"")
        except requests.RequestException as e:
            raise RuntimeError(f""Błąd podczas pobierania pliku z {url}: {str(e)}"")

    def _extract_archive(self, file_path, extract_to):
        """"""
        Rozpakowuje archiwum (ZIP, TAR.GZ lub 7Z) do wskazanego katalogu.
        :param file_path: Ścieżka do pliku archiwum.
        :param extract_to: Ścieżka do katalogu docelowego rozpakowania.
        """"""
        os.makedirs(extract_to, exist_ok=True)
        try:
            if file_path.lower().endswith("".zip""):
                with zipfile.ZipFile(file_path, 'r') as zip_ref:
                    for member in zip_ref.namelist():
                        fname = member.split('/', 1)[1] if '/' in member else member
                        if fname:
                            target_path = os.path.join(extract_to, fname)
                            if member.endswith('/'):
                                os.makedirs(target_path, exist_ok=True)
                            else:
                                os.makedirs(os.path.dirname(target_path), exist_ok=True)
                                with open(target_path, 'wb') as f:
                                    f.write(zip_ref.read(member))
            elif file_path.lower().endswith(("".tar.gz"", "".tgz"")):
                with tarfile.open(file_path, 'r:gz') as tar_ref:
                    tar_ref.extractall(extract_to)
            elif file_path.lower().endswith("".7z""):
                with py7zr.SevenZipFile(file_path, mode='r') as z:
                    z.extractall(extract_to)
            else:
                raise ValueError(f""Nieobsługiwany format archiwum: {file_path}"")
        except (zipfile.BadZipFile, tarfile.TarError, py7zr.Py7zrError) as e:
            raise RuntimeError(f""Błąd podczas rozpakowywania archiwum {os.path.basename(file_path)}: {str(e)}"")
        except Exception as e:
            raise RuntimeError(f""Nieoczekiwany błąd podczas rozpakowywania: {str(e)}"")

    def _get_local_version(self, package):
        """"""
        Pobiera lokalnie zainstalowaną wersję pakietu.
        :param package: Nazwa pakietu.
        :return: Wersja lub None.
        """"""
        exe_path = self._get_setting(f""{package.lower()}_path"")
        if not exe_path or not os.path.exists(exe_path):
            return None
        try:
            if package == ""Python"":
                result = subprocess.run([exe_path, ""--version""], capture_output=True, text=True, check=True, encoding='utf-8')
                return result.stdout.strip().split()[-1]
            elif package == ""Node.js"":
                result = subprocess.run([exe_path, ""--version""], capture_output=True, text=True, check=True, encoding='utf-8')
                return result.stdout.strip().lstrip('v')
            elif package == ""Go"":
                result = subprocess.run([exe_path, ""version""], capture_output=True, text=True, check=True, encoding='utf-8')
                return result.stdout.strip().split()[2].lstrip('go')
            elif package == ""Java"":
                result = subprocess.run([exe_path, ""-version""], capture_output=True, text=True, check=True, encoding='utf-8')
                return result.stdout.strip().split()[2].strip('""')
            elif package == ""Ruby"":
                result = subprocess.run([exe_path, ""--version""], capture_output=True, text=True, check=True, encoding='utf-8')
                return result.stdout.strip().split()[1]
            elif package == ""Rust"":
                result = subprocess.run([exe_path, ""--version""], capture_output=True, text=True, check=True, encoding='utf-8')
                return result.stdout.strip().split()[1]
            elif package == ""Git"":
                result = subprocess.run([exe_path, ""--version""], capture_output=True, text=True, check=True, encoding='utf-8')
                return result.stdout.strip().split()[-1]
            elif package == ""Docker"":
                result = subprocess.run([exe_path, ""--version""], capture_output=True, text=True, check=True, encoding='utf-8')
                return result.stdout.strip().split()[2].rstrip(',')
        except (subprocess.CalledProcessError, FileNotFoundError, OSError):
            return None
        return None

    def _get_latest_version(self, package):
        """"""
        Pobiera najnowszą wersję pakietu ze źródeł zewnętrznych.
        :param package: Nazwa pakietu.
        :return: Wersja lub None.
        """"""
        try:
            if package == ""Python"":
                url = ""https://www.python.org/ftp/python/index-windows.json""
                response = requests.get(url, timeout=10)
                response.raise_for_status()
                data = response.json()
                versions = [v for v in data[""versions""] if v.get(""url"", """").endswith("".zip"") and ""64"" in v.get(""id"", """") and v.get(""sort-version"", """").replace(""."", """").isdigit()]
                if not versions:
                    return None
                return sorted(versions, key=lambda v: list(map(int, v[""sort-version""].split("".""))), reverse=True)[0][""sort-version""]
            elif package == ""Node.js"":
                shasums_url = ""https://nodejs.org/dist/latest/SHASUMS256.txt""
                response = requests.get(shasums_url, timeout=10)
                response.raise_for_status()
                pattern = r""^[a-f0-9]{64}\s+(node-v([\d.]+)-win-x64\.zip)$""
                for line in response.text.splitlines():
                    match = re.match(pattern, line, re.MULTILINE)
                    if match:
                        return match.group(2)
                return None
            elif package == ""Go"":
                url = ""https://go.dev/dl/""
                response = requests.get(url, timeout=10)
                response.raise_for_status()
                pattern = r""go(\d+\.\d+\.\d+)\.windows-amd64\.zip""
                match = re.search(pattern, response.text)
                return match.group(1) if match else None
            elif package == ""Java"":
                url = ""https://jdk.java.net/21/""
                response = requests.get(url, timeout=10)
                response.raise_for_status()
                pattern = r""openjdk-(\d+)_windows-x64_bin\.zip""
                match = re.search(pattern, response.text)
                return match.group(1) if match else None
            elif package == ""Ruby"":
                url = ""https://rubyinstaller.org/downloads/""
                response = requests.get(url, timeout=10)
                response.raise_for_status()
                pattern = r""rubyinstaller-(\d+\.\d+\.\d+-\d+)-x64\.7z""
                match = re.search(pattern, response.text)
                return match.group(1) if match else None
            elif package == ""Rust"":
                url = ""https://static.rust-lang.org/dist/channel-rust-stable.toml""
                response = requests.get(url, timeout=10)
                response.raise_for_status()
                pattern = r""version = \""(\d+\.\d+\.\d+)\""""
                match = re.search(pattern, response.text)
                return match.group(1) if match else None
            elif package == ""Git"":
                url = ""https://git-scm.com/download/win""
                response = requests.get(url, timeout=10)
                response.raise_for_status()
                pattern = r""Git-(\d+\.\d+\.\d+)-64-bit\.exe""
                match = re.search(pattern, response.text)
                return match.group(1) if match else None
            elif package == ""Docker"":
                url = ""https://desktop.docker.com/win/stable/amd64/Docker%20Desktop%20Installer.exe""
                response = requests.head(url, timeout=10)
                response.raise_for_status()
                return ""latest""  # Docker Desktop nie publikuje wersji wprost
        except requests.RequestException:
            return None
        return None

    def _is_installed(self, package):
        """"""
        Sprawdza, czy pakiet jest zainstalowany.
        :param package: Nazwa pakietu.
        :return: True, jeśli zainstalowany, inaczej False.
        """"""
        if package == ""Python"":
            return os.path.exists(os.path.join(PACKAGES_DIR, ""python"", ""python.exe""))
        elif package == ""Node.js"":
            return os.path.exists(os.path.join(PACKAGES_DIR, ""node.js"", ""node.exe""))
        elif package == ""Go"":
            return os.path.exists(os.path.join(PACKAGES_DIR, ""go"", ""bin"", ""go.exe""))
        elif package == ""Java"":
            return os.path.exists(os.path.join(PACKAGES_DIR, ""java"", ""bin"", ""java.exe""))
        elif package == ""Ruby"":
            return os.path.exists(os.path.join(PACKAGES_DIR, ""ruby"", ""bin"", ""ruby.exe""))
        elif package == ""Rust"":
            return os.path.exists(os.path.join(PACKAGES_DIR, ""rust"", ""bin"", ""cargo.exe""))
        elif package == ""Git"":
            return os.path.exists(os.path.join(PACKAGES_DIR, ""git"", ""bin"", ""git.exe""))
        elif package == ""Docker"":
            return os.path.exists(os.path.join(PACKAGES_DIR, ""docker"", ""Docker"", ""Docker Desktop.exe""))
        return False

    def install_latest_python(self, progress_callback=None):
        """"""
        Instaluje najnowszą wersję Pythona.
        :param progress_callback: Funkcja callback dla postępu.
        """"""
        try:
            url_index = ""https://www.python.org/ftp/python/index-windows.json""
            response = requests.get(url_index, timeout=10)
            response.raise_for_status()
            data = response.json()
            versions = [v for v in data[""versions""] if v.get(""url"", """").endswith("".zip"") and ""64"" in v.get(""id"", """") and v.get(""sort-version"", """").replace(""."", """").isdigit()]
            if not versions:
                raise RuntimeError(""Nie znaleziono stabilnej wersji 64-bitowej Pythona z plikiem ZIP."")
            latest = sorted(versions, key=lambda v: list(map(int, v[""sort-version""].split("".""))), reverse=True)[0]
            download_url = latest[""url""]
            version = latest[""sort-version""]
            filename = f""python-{version}-amd64.zip""
            python_dir = os.path.join(PACKAGES_DIR, ""python"")
            zip_path = os.path.join(PACKAGES_DIR, filename)
            if os.path.exists(python_dir):
                shutil.rmtree(python_dir)
            os.makedirs(python_dir, exist_ok=True)
            if progress_callback: progress_callback(1)
            self._download_file(download_url, zip_path, progress_callback)
            if progress_callback: progress_callback(95)
            self._extract_archive(zip_path, python_dir)
            if progress_callback: progress_callback(98)
            os.remove(zip_path)
            python_exe_path = os.path.join(python_dir, ""python.exe"")
            if not os.path.exists(python_exe_path):
                raise RuntimeError(""Nie znaleziono pliku python.exe po rozpakowaniu."")
            self._update_settings(""python_path"", python_exe_path)
            self._update_settings(""python_version"", version)
            if progress_callback: progress_callback(100)
        except Exception as e:
            raise RuntimeError(f""Instalacja pakietu Python nieudana: {str(e)}"")

    def install_latest_nodejs(self, progress_callback=None):
        """"""
        Instaluje najnowszą wersję Node.js.
        :param progress_callback: Funkcja callback dla postępu.
        """"""
        try:
            shasums_url = ""https://nodejs.org/dist/latest/SHASUMS256.txt""
            response = requests.get(shasums_url, timeout=10)
            response.raise_for_status()
            pattern = r""^[a-f0-9]{64}\s+(node-v([\d.]+)-win-x64\.zip)$""
            filename = None
            version = None
            for line in response.text.splitlines():
                match = re.match(pattern, line, re.MULTILINE)
                if match:
                    filename = match.group(1)
                    version = match.group(2)
                    break
            if not filename or not version:
                raise RuntimeError(""Nie znaleziono archiwum Node.js dla Windows x64 w pliku SHASUMS256.txt."")
            base_url = ""https://nodejs.org/dist/latest/""
            download_url = f""{base_url}{filename}""
            zip_path = os.path.join(PACKAGES_DIR, filename)
            node_dir = os.path.join(PACKAGES_DIR, ""node.js"")
            if os.path.exists(node_dir):
                shutil.rmtree(node_dir)
            os.makedirs(node_dir, exist_ok=True)
            if progress_callback: progress_callback(1)
            self._download_file(download_url, zip_path, progress_callback)
            if progress_callback: progress_callback(95)
            self._extract_archive(zip_path, node_dir)
            if progress_callback: progress_callback(98)
            os.remove(zip_path)
            node_exe_path = os.path.join(node_dir, ""node.exe"")
            if not os.path.exists(node_exe_path):
                raise RuntimeError(""Nie znaleziono pliku node.exe po rozpakowaniu."")
            self._update_settings(""node_path"", node_exe_path)
            self._update_settings(""node_version"", version)
            if progress_callback: progress_callback(100)
        except Exception as e:
            raise RuntimeError(f""Instalacja pakietu Node.js nieudana: {str(e)}"")

    def install_latest_go(self, progress_callback=None):
        """"""
        Instaluje najnowszą wersję Go.
        :param progress_callback: Funkcja callback dla postępu.
        """"""
        try:
            url = ""https://go.dev/dl/""
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            pattern = r""go(\d+\.\d+\.\d+)\.windows-amd64\.zip""
            match = re.search(pattern, response.text)
            if not match:
                raise RuntimeError(""Nie znaleziono wersji Go dla Windows x64"")
            version = match.group(1)
            filename = f""go{version}.windows-amd64.zip""
            download_url = f""{url}{filename}""
            zip_path = os.path.join(PACKAGES_DIR, filename)
            go_dir = os.path.join(PACKAGES_DIR, ""go"")
            if os.path.exists(go_dir):
                shutil.rmtree(go_dir)
            os.makedirs(go_dir, exist_ok=True)
            if progress_callback: progress_callback(1)
            self._download_file(download_url, zip_path, progress_callback)
            if progress_callback: progress_callback(95)
            self._extract_archive(zip_path, go_dir)
            if progress_callback: progress_callback(98)
            os.remove(zip_path)
            go_exe_path = os.path.join(go_dir, ""bin"", ""go.exe"")
            if not os.path.exists(go_exe_path):
                raise RuntimeError(""Nie znaleziono pliku go.exe po rozpakowaniu."")
            self._update_settings(""go_path"", go_exe_path)
            self._update_settings(""go_version"", version)
            if progress_callback: progress_callback(100)
        except Exception as e:
            raise RuntimeError(f""Instalacja pakietu Go nieudana: {str(e)}"")

    def install_latest_java(self, progress_callback=None):
        """"""
        Instaluje najnowszą wersję OpenJDK.
        :param progress_callback: Funkcja callback dla postępu.
        """"""
        try:
            url = ""https://jdk.java.net/21/""
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            pattern = r""openjdk-(\d+)_windows-x64_bin\.zip""
            match = re.search(pattern, response.text)
            if not match:
                raise RuntimeError(""Nie znaleziono OpenJDK dla Windows x64"")
            version = match.group(1)
            filename = f""openjdk-{version}_windows-x64_bin.zip""
            download_url = f""https://download.java.net/java/GA/jdk{version}/{filename}""
            zip_path = os.path.join(PACKAGES_DIR, filename)
            java_dir = os.path.join(PACKAGES_DIR, ""java"")
            if os.path.exists(java_dir):
                shutil.rmtree(java_dir)
            os.makedirs(java_dir, exist_ok=True)
            if progress_callback: progress_callback(1)
            self._download_file(download_url, zip_path, progress_callback)
            if progress_callback: progress_callback(95)
            self._extract_archive(zip_path, java_dir)
            if progress_callback: progress_callback(98)
            os.remove(zip_path)
            java_exe_path = os.path.join(java_dir, ""bin"", ""java.exe"")
            if not os.path.exists(java_exe_path):
                raise RuntimeError(""Nie znaleziono pliku java.exe po rozpakowaniu."")
            self._update_settings(""java_path"", java_exe_path)
            self._update_settings(""java_version"", version)
            if progress_callback: progress_callback(100)
        except Exception as e:
            raise RuntimeError(f""Instalacja pakietu Java nieudana: {str(e)}"")

    def install_latest_ruby(self, progress_callback=None):
        """"""
        Instaluje najnowszą wersję Ruby.
        :param progress_callback: Funkcja callback dla postępu.
        """"""
        try:
            url = ""https://rubyinstaller.org/downloads/""
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            pattern = r""rubyinstaller-(\d+\.\d+\.\d+-\d+)-x64\.7z""
            match = re.search(pattern, response.text)
            if not match:
                raise RuntimeError(""Nie znaleziono Ruby dla Windows x64"")
            version = match.group(1)
            filename = f""rubyinstaller-{version}-x64.7z""
            download_url = f""https://github.com/oneclick/rubyinstaller2/releases/download/RubyInstaller-{version}/{filename}""
            archive_path = os.path.join(PACKAGES_DIR, filename)
            ruby_dir = os.path.join(PACKAGES_DIR, ""ruby"")
            if os.path.exists(ruby_dir):
                shutil.rmtree(ruby_dir)
            os.makedirs(ruby_dir, exist_ok=True)
            if progress_callback: progress_callback(1)
            self._download_file(download_url, archive_path, progress_callback)
            if progress_callback: progress_callback(95)
            self._extract_archive(archive_path, ruby_dir)
            if progress_callback: progress_callback(98)
            os.remove(archive_path)
            ruby_exe_path = os.path.join(ruby_dir, ""bin"", ""ruby.exe"")
            if not os.path.exists(ruby_exe_path):
                raise RuntimeError(""Nie znaleziono pliku ruby.exe po rozpakowaniu."")
            self._update_settings(""ruby_path"", ruby_exe_path)
            self._update_settings(""ruby_version"", version)
            if progress_callback: progress_callback(100)
        except Exception as e:
            raise RuntimeError(f""Instalacja pakietu Ruby nieudana: {str(e)}"")

    def install_latest_rust(self, progress_callback=None):
        """"""
        Instaluje najnowszą wersję Rust.
        :param progress_callback: Funkcja callback dla postępu.
        """"""
        try:
            url = ""https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-msvc/rustup-init.exe""
            exe_path = os.path.join(PACKAGES_DIR, ""rustup-init.exe"")
            rust_dir = os.path.join(PACKAGES_DIR, ""rust"")
            os.makedirs(rust_dir, exist_ok=True)
            if progress_callback: progress_callback(1)
            self._download_file(url, exe_path, progress_callback)
            if progress_callback: progress_callback(95)
            subprocess.run([exe_path, ""--default-toolchain"", ""stable"", ""--profile"", ""minimal"", ""-y"", f""--target-dir={rust_dir}""], check=True)
            if progress_callback: progress_callback(98)
            os.remove(exe_path)
            cargo_exe_path = os.path.join(rust_dir, ""bin"", ""cargo.exe"")
            if not os.path.exists(cargo_exe_path):
                raise RuntimeError(""Nie znaleziono pliku cargo.exe po instalacji."")
            version = subprocess.run([cargo_exe_path, ""--version""], capture_output=True, text=True).stdout.strip().split()[1]
            self._update_settings(""rust_path"", cargo_exe_path)
            self._update_settings(""rust_version"", version)
            if progress_callback: progress_callback(100)
        except Exception as e:
            raise RuntimeError(f""Instalacja pakietu Rust nieudana: {str(e)}"")

    def install_latest_git(self, progress_callback=None):
        """"""
        Instaluje najnowszą wersję Git.
        :param progress_callback: Funkcja callback dla postępu.
        """"""
        try:
            url = ""https://git-scm.com/download/win""
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            pattern = r""Git-(\d+\.\d+\.\d+)-64-bit\.exe""
            match = re.search(pattern, response.text)
            if not match:
                raise RuntimeError(""Nie znaleziono Git dla Windows x64"")
            version = match.group(1)
            filename = f""Git-{version}-64-bit.exe""
            download_url = f""https://github.com/git-for-windows/git/releases/download/v{version}.windows.1/{filename}""
            exe_path = os.path.join(PACKAGES_DIR, filename)
            git_dir = os.path.join(PACKAGES_DIR, ""git"")
            os.makedirs(git_dir, exist_ok=True)
            if progress_callback: progress_callback(1)
            self._download_file(download_url, exe_path, progress_callback)
            if progress_callback: progress_callback(95)
            subprocess.run([exe_path, ""/VERYSILENT"", f""/DIR={git_dir}""], check=True)
            if progress_callback: progress_callback(98)
            os.remove(exe_path)
            git_exe_path = os.path.join(git_dir, ""bin"", ""git.exe"")
            if not os.path.exists(git_exe_path):
                raise RuntimeError(""Nie znaleziono pliku git.exe po instalacji."")
            self._update_settings(""git_path"", git_exe_path)
            self._update_settings(""git_version"", version)
            if progress_callback: progress_callback(100)
        except Exception as e:
            raise RuntimeError(f""Instalacja pakietu Git nieudana: {str(e)}"")

    def install_latest_docker(self, progress_callback=None):
        """"""
        Instaluje najnowszą wersję Docker Desktop.
        :param progress_callback: Funkcja callback dla postępu.
        """"""
        try:
            url = ""https://desktop.docker.com/win/stable/amd64/Docker%20Desktop%20Installer.exe""
            exe_path = os.path.join(PACKAGES_DIR, ""DockerDesktopInstaller.exe"")
            docker_dir = os.path.join(PACKAGES_DIR, ""docker"")
            os.makedirs(docker_dir, exist_ok=True)
            if progress_callback: progress_callback(1)
            self._download_file(url, exe_path, progress_callback)
            if progress_callback: progress_callback(95)
            subprocess.run([exe_path, ""install"", ""--quiet"", f""--install-dir={docker_dir}""], check=True)
            if progress_callback: progress_callback(98)
            os.remove(exe_path)
            docker_exe_path = os.path.join(docker_dir, ""Docker"", ""Docker Desktop.exe"")
            if not os.path.exists(docker_exe_path):
                raise RuntimeError(""Nie znaleziono pliku Docker Desktop po instalacji."")
            version = subprocess.run([docker_exe_path, ""--version""], capture_output=True, text=True).stdout.strip().split()[2].rstrip(',')
            self._update_settings(""docker_path"", docker_exe_path)
            self._update_settings(""docker_version"", version)
            if progress_callback: progress_callback(100)
        except Exception as e:
            raise RuntimeError(f""Instalacja pakietu Docker nieudana: {str(e)}"")

    def uninstall_package(self, package):
        """"""
        Odinstalowuje pakiet, usuwając jego katalog i wpisy w ustawieniach.
        :param package: Nazwa pakietu.
        """"""
        try:
            folder = os.path.join(PACKAGES_DIR, package.lower())
            if os.path.exists(folder):
                shutil.rmtree(folder)
            self._remove_setting(f""{package.lower()}_path"")
            self._remove_setting(f""{package.lower()}_version"")
        except Exception as e:
            raise RuntimeError(f""Odinstalowanie pakietu {package} nieudane: {str(e)}"")

    def _update_settings(self, key, value):
        """"""
        Zapisuje ustawienie w pliku settings.json.
        :param key: Klucz ustawienia.
        :param value: Wartość ustawienia.
        """"""
        settings = {}
        try:
            if os.path.exists(self.settings_path):
                with open(self.settings_path, ""r"", encoding=""utf-8"") as f:
                    settings = json.load(f)
        except (json.JSONDecodeError, IOError):
            settings = {}
        settings[key] = value
        try:
            with open(self.settings_path, ""w"", encoding=""utf-8"") as f:
                json.dump(settings, f, indent=4)
        except IOError as e:
            raise RuntimeError(f""Błąd zapisu ustawień do pliku {os.path.basename(self.settings_path)}: {str(e)}"")

    def _remove_setting(self, key):
        """"""
        Usuwa ustawienie z pliku settings.json.
        :param key: Klucz ustawienia do usunięcia.
        """"""
        settings = {}
        try:
            if os.path.exists(self.settings_path):
                with open(self.settings_path, ""r"", encoding=""utf-8"") as f:
                    settings = json.load(f)
                if key in settings:
                    del settings[key]
                    with open(self.settings_path, ""w"", encoding=""utf-8"") as f:
                        json.dump(settings, f, indent=4)
        except (json.JSONDecodeError, IOError):
            pass
        except Exception as e:
            raise RuntimeError(f""Błąd usuwania ustawienia '{key}' z pliku {os.path.basename(self.settings_path)}: {str(e)}"")

    def _get_setting(self, key):
        """"""
        Pobiera wartość ustawienia z pliku settings.json.
        :param key: Klucz ustawienia.
        :return: Wartość ustawienia lub None.
        """"""
        try:
            if os.path.exists(self.settings_path):
                with open(self.settings_path, ""r"", encoding=""utf-8"") as f:
                    settings = json.load(f)
                return settings.get(key)
            return None
        except (json.JSONDecodeError, IOError):
            return None
        except Exception:
            return None

class PackageManagerDialog(QDialog):
    """"""Okno dialogowe menadżera pakietów.""""""
    def __init__(self, project_dir, settings, parent=None):
        """"""Inicjalizuje okno dialogowe.""""""
        super().__init__(parent)
        self.project_dir = project_dir
        self.settings = settings

        self.setWindowTitle(""Menadżer Pakietów"")
        self.setModal(True)
        self.resize(800, 500)

        self.pkg_manager = PackageManager(self)
        self.worker = None

        self.setup_ui()
        self.apply_styles()
        self.populate_table()

    def setup_ui(self):
        """"""Konfiguruje interfejs użytkownika.""""""
        layout = QVBoxLayout(self)
        self.status_label = QLabel(""Status: Gotowy"")
        layout.addWidget(self.status_label)
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        layout.addWidget(self.progress_bar)
        self.table = QTableWidget(0, 5)
        self.table.setHorizontalHeaderLabels([""Nazwa Pakietu"", ""Opis"", ""Wersja"", ""Status"", ""Akcje""])
        header = self.table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        header.setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        header.setSectionResizeMode(2, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(3, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(4, QHeaderView.ResizeMode.ResizeToContents)
        self.table.setSelectionMode(QTableWidget.SelectionMode.NoSelection)
        layout.addWidget(self.table)

    def apply_styles(self):
        """"""Zastosuj style CSS zgodnie z motywem aplikacji.""""""
        # Pobierz motyw z ustawień lub domyślnie 'light'
        theme = 'light'
        if self.parent and hasattr(self.parent, 'settings'):
            theme = getattr(self.parent, 'settings', {}).get('theme', 'light')
        elif hasattr(self.parent, 'theme'):
            theme = getattr(self.parent, 'theme', 'light')
        if theme == 'dark':
            self.setStyleSheet(get_dark_package_manager_stylesheet())
        else:
            self.setStyleSheet(get_light_package_manager_stylesheet())

    def populate_table(self):
        """"""Wypełnia tabelę informacjami o dostępnych pakietach.""""""
        packages = [
            {
                ""name"": ""Python"",
                ""desc"": ""Język programowania Python (64-bit)"",
                ""size"": ""~30 MB"",
                ""install_func"": self.download_python,
                ""uninstall_func"": lambda: self.uninstall_package(""Python""),
            },
            {
                ""name"": ""Node.js"",
                ""desc"": ""Środowisko uruchomieniowe JavaScript (64-bit)"",
                ""size"": ""~25 MB"",
                ""install_func"": self.download_node,
                ""uninstall_func"": lambda: self.uninstall_package(""Node.js""),
            },
            {
                ""name"": ""Go"",
                ""desc"": ""Język programowania Go (64-bit)"",
                ""size"": ""~100 MB"",
                ""install_func"": self.download_go,
                ""uninstall_func"": lambda: self.uninstall_package(""Go""),
            },
            {
                ""name"": ""Java"",
                ""desc"": ""Java Development Kit (OpenJDK, 64-bit)"",
                ""size"": ""~200 MB"",
                ""install_func"": self.download_java,
                ""uninstall_func"": lambda: self.uninstall_package(""Java""),
            },
            {
                ""name"": ""Ruby"",
                ""desc"": ""Język programowania Ruby (64-bit)"",
                ""size"": ""~50 MB"",
                ""install_func"": self.download_ruby,
                ""uninstall_func"": lambda: self.uninstall_package(""Ruby""),
            },
            {
                ""name"": ""Rust"",
                ""desc"": ""Język programowania Rust (64-bit)"",
                ""size"": ""~150 MB"",
                ""install_func"": self.download_rust,
                ""uninstall_func"": lambda: self.uninstall_package(""Rust""),
            },
            {
                ""name"": ""Git"",
                ""desc"": ""System kontroli wersji Git (64-bit)"",
                ""size"": ""~50 MB"",
                ""install_func"": self.download_git,
                ""uninstall_func"": lambda: self.uninstall_package(""Git""),
            },
            {
                ""name"": ""Docker"",
                ""desc"": ""Platforma do konteneryzacji Docker Desktop (64-bit)"",
                ""size"": ""~500 MB"",
                ""install_func"": self.download_docker,
                ""uninstall_func"": lambda: self.uninstall_package(""Docker""),
            },
        ]
        self.table.setRowCount(len(packages))
        for row, pkginfo in enumerate(packages):
            name = pkginfo[""name""]
            local_version = self.pkg_manager._get_local_version(name) or ""Brak""
            latest_version = self.pkg_manager._get_latest_version(name) or ""Brak informacji""
            version_text = local_version
            is_installed = self.pkg_manager._is_installed(name)
            status = ""Niezainstalowany""
            status_color = QColor(""#ff4444"")
            if is_installed:
                status = ""Zainstalowano""
                status_color = QColor(""#44ff44"")
                update_available = False
                if latest_version != ""Brak informacji"" and local_version != ""Brak"":
                    try:
                        local_parts = list(map(int, local_version.split('.')))
                        latest_parts = list(map(int, latest_version.split('.')))
                        max_len = max(len(local_parts), len(latest_parts))
                        local_parts += [0] * (max_len - len(local_parts))
                        latest_parts += [0] * (max_len - len(latest_parts))
                        if latest_parts > local_parts:
                            update_available = True
                    except ValueError:
                        if latest_version > local_version:
                            update_available = True
                if update_available:
                    status = ""Dostępna aktualizacja""
                    status_color = QColor(""#ffff44"")
                    version_text = f""{local_version} (Najnowsza: {latest_version})""
            self.table.setItem(row, 0, QTableWidgetItem(name))
            self.table.setItem(row, 1, QTableWidgetItem(pkginfo[""desc""]))
            self.table.setItem(row, 2, QTableWidgetItem(version_text))
            status_item = QTableWidgetItem(status)
            status_item.setForeground(status_color)
            status_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            self.table.setItem(row, 3, status_item)
            action_layout = QHBoxLayout()
            action_layout.setContentsMargins(0, 0, 0, 0)
            action_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
            if is_installed:
                uninstall_btn = QPushButton(""Odinstaluj"")
                uninstall_btn.clicked.connect(pkginfo[""uninstall_func""])
                action_layout.addWidget(uninstall_btn)
                if update_available:
                    update_btn = QPushButton(""Aktualizuj"")
                    update_btn.clicked.connect(pkginfo[""install_func""])
                    action_layout.addWidget(update_btn)
            else:
                install_btn = QPushButton(""Zainstaluj"")
                install_btn.clicked.connect(pkginfo[""install_func""])
                action_layout.addWidget(install_btn)
            action_widget = QWidget()
            action_widget.setLayout(action_layout)
            self.table.setCellWidget(row, 4, action_widget)

    def download_python(self):
        """"""Rozpoczyna instalację Pythona.""""""
        self.start_operation(self.pkg_manager.install_latest_python, ""Python"", ""instalacji"")

    def download_node(self):
        """"""Rozpoczyna instalację Node.js.""""""
        self.start_operation(self.pkg_manager.install_latest_nodejs, ""Node.js"", ""instalacji"")

    def download_go(self):
        """"""Rozpoczyna instalację Go.""""""
        self.start_operation(self.pkg_manager.install_latest_go, ""Go"", ""instalacji"")

    def download_java(self):
        """"""Rozpoczyna instalację Java.""""""
        self.start_operation(self.pkg_manager.install_latest_java, ""Java"", ""instalacji"")

    def download_ruby(self):
        """"""Rozpoczyna instalację Ruby.""""""
        self.start_operation(self.pkg_manager.install_latest_ruby, ""Ruby"", ""instalacji"")

    def download_rust(self):
        """"""Rozpoczyna instalację Rust.""""""
        self.start_operation(self.pkg_manager.install_latest_rust, ""Rust"", ""instalacji"")

    def download_git(self):
        """"""Rozpoczyna instalację Git.""""""
        self.start_operation(self.pkg_manager.install_latest_git, ""Git"", ""instalacji"")

    def download_docker(self):
        """"""Rozpoczyna instalację Docker.""""""
        self.start_operation(self.pkg_manager.install_latest_docker, ""Docker"", ""instalacji"")

    def uninstall_package(self, package_name):
        """"""Rozpoczyna odinstalowanie pakietu.""""""
        self.start_operation(lambda progress_callback=None: self.pkg_manager.uninstall_package(package_name), package_name, ""odinstalowania"")

    def start_operation(self, func, package_name, operation_type):
        """"""
        Rozpoczyna operację na pakiecie w osobnym wątku.
        :param func: Funkcja do wykonania.
        :param package_name: Nazwa pakietu.
        :param operation_type: Typ operacji.
        """"""
        self.set_actions_enabled(False)
        self.status_label.setText(f""Rozpoczęto operację {operation_type} pakietu {package_name}..."")
        self.progress_bar.setValue(0)
        self.progress_bar.setVisible(True)
        self.worker = DownloadWorker(func, package_name)
        self.worker.progress.connect(self.update_progress)
        self.worker.finished.connect(self.on_operation_finished)
        self.worker.error.connect(self.on_operation_error)
        self.worker.start()

    def update_progress(self, value):
        """"""Aktualizuje pasek postępu.""""""
        self.progress_bar.setValue(value)
        QApplication.processEvents()

    def on_operation_finished(self, message):
        """"""Obsługuje zakończenie operacji.""""""
        self.status_label.setText(message)
        self.progress_bar.setValue(100)
        self.progress_bar.setVisible(False)
        self.populate_table()
        self.set_actions_enabled(True)

    def on_operation_error(self, message):
        """"""Obsługuje błąd operacji.""""""
        self.status_label.setText(f""Błąd: {message}"")
        self.progress_bar.setVisible(False)
        self.populate_table()
        self.set_actions_enabled(True)

    def set_actions_enabled(self, enabled):
        """"""Włącza/wyłącza przyciski akcji.""""""
        for row in range(self.table.rowCount()):
            widget = self.table.cellWidget(row, 4)
            if widget:
                for btn in widget.findChildren(QPushButton):
                    btn.setEnabled(enabled)

if __name__ == '__main__':
    import sys
    userdata_dir_test = os.path.abspath(os.path.join(os.path.dirname(__file__), "".."", ""userdata""))
    os.makedirs(userdata_dir_test, exist_ok=True)
    settings_path_test = os.path.join(userdata_dir_test, ""settings.json"")
    if not os.path.exists(settings_path_test):
        with open(settings_path_test, ""w"") as f:
            json.dump({}, f)
    app = QApplication(sys.argv)
    dialog = PackageManagerDialog()
    dialog.exec()
    sys.exit(app.exec())

Ścieżka: /src/process.py
Rozmiar: 4,36 KB
Zawartość:
# Zarządzanie procesami zewnętrznymi
#/src/process.py

import os
import platform
import shlex
from PyQt6.QtCore import QProcess, QProcessEnvironment

class ProcessManager:
    def __init__(self, parent):
        self.process = QProcess(parent)
        self.process.readyReadStandardOutput.connect(self._handle_stdout)
        self.process.readyReadStandardError.connect(self._handle_stderr)
        self.process.finished.connect(self._handle_finished)
        self.console_output_callback = None
        self.status_bar_callback = None

    def set_callbacks(self, console_output, status_bar):
        self.console_output_callback = console_output
        self.status_bar_callback = status_bar

    def run_command(self, command, working_dir, python_path=None, node_path=None):
        if self.process.state() != QProcess.ProcessState.NotRunning:
            self._append_output(""Inny proces już działa. Zakończ go najpierw."", is_error=True)
            return
        command_str = shlex.join(command)
        self._append_output(f""Uruchamianie: {command_str}\nw katalogu: {working_dir}\n---"")
        self._update_status(""Proces uruchomiony..."")
        try:
            program = command[0]
            arguments = command[1:]
            self.process.setWorkingDirectory(working_dir)
            env = QProcessEnvironment.systemEnvironment()
            current_path = env.value(""PATH"", """")
            paths_to_prepend = []
            if python_path and os.path.exists(python_path):
                py_dir = os.path.dirname(python_path)
                if os.path.normcase(py_dir) not in [os.path.normcase(p) for p in current_path.split(os.pathsep)]:
                    paths_to_prepend.append(py_dir)
            if node_path and os.path.exists(node_path):
                node_dir = os.path.dirname(node_path)
                if os.path.normcase(node_dir) not in [os.path.normcase(p) for p in current_path.split(os.pathsep)]:
                    paths_to_prepend.append(node_dir)
            if paths_to_prepend:
                new_path = os.pathsep.join(paths_to_prepend) + (os.pathsep + current_path if current_path else """")
                env.insert(""PATH"", new_path)
                if platform.system() == ""Windows"":
                    env.insert(""Path"", new_path)
            self.process.setProcessEnvironment(env)
            self.process.start(program, arguments)
            if not self.process.waitForStarted(1000):
                error = self.process.errorString()
                self._append_output(f""Nie udało się uruchomić '{program}': {error}"", is_error=True)
                self._update_status(f""Błąd uruchamiania: {program}"")
        except Exception as e:
            self._append_output(f""Błąd podczas uruchamiania: {e}"", is_error=True)
            self._update_status(""Błąd uruchamiania."")

    def _append_output(self, text, is_error=False):
        if self.console_output_callback:
            self.console_output_callback(text, is_error)

    def _update_status(self, message):
        if self.status_bar_callback:
            self.status_bar_callback(message)

    def _handle_stdout(self):
        while self.process.bytesAvailable():
            data = self.process.readAllStandardOutput()
            try:
                text = bytes(data).decode('utf-8')
            except UnicodeDecodeError:
                text = bytes(data).decode('utf-8', errors='replace')
            self._append_output(text)

    def _handle_stderr(self):
        while self.process.bytesAvailable():
            data = self.process.readAllStandardError()
            try:
                text = bytes(data).decode('utf-8')
            except UnicodeDecodeError:
                text = bytes(data).decode('utf-8', errors='replace')
            self._append_output(text, is_error=True)

    def _handle_finished(self, exit_code, exit_status):
        self._handle_stdout()
        self._handle_stderr()
        self._append_output(""\n--- Zakończono proces ---"")
        if exit_status == QProcess.ExitStatus.NormalExit:
            self._append_output(f""Kod wyjścia: {exit_code}"")
            self._update_status(f""Zakończono. Kod wyjścia: {exit_code}"")
        else:
            self._append_output(f""Awaria procesu z kodem: {exit_code}"", is_error=True)
            self._update_status(f""Awaria procesu. Kod wyjścia: {exit_code}"")

Ścieżka: /src/theme.py
Rozmiar: 12,98 KB
Zawartość:
# Zarządzanie motywami aplikacji – zajebiście stylowe! 😎
# /src/theme.py

from PyQt6.QtWidgets import QMainWindow, QApplication
from PyQt6.QtGui import QPalette, QColor

def get_dark_theme_stylesheet():
    return """"""
        QMainWindow, QWidget { background-color: #2E2E2E; color: #D3D3D3; }
        QMenuBar { background-color: #3C3C3C; color: #D3D3D3; }
        QMenuBar::item:selected { background-color: #505050; }
        QMenu { background-color: #3C3C3C; color: #D3D3D3; border: 1px solid #505050; }
        QMenu::item:selected { background-color: #505050; }
        QToolBar { background-color: #3C3C3C; color: #D3D3D3; spacing: 5px; padding: 2px; }
        QToolButton { background-color: transparent; border: 1px solid transparent; padding: 3px; border-radius: 4px; }
        QToolButton:hover { border: 1px solid #505050; background-color: #454545; }
        QToolButton:pressed { background-color: #404040; }
        QPushButton { background-color: #505050; color: #D3D3D3; border: 1px solid #606060; padding: 4px 8px; border-radius: 4px; }
        QPushButton:hover { background-color: #606060; }
        QStatusBar { background-color: #3C3C3C; color: #D3D3D3; }
        QSplitter::handle { background-color: #505050; }
        QTreeView { background-color: #1E1E1E; color: #D3D3D3; border: 1px solid #3C3C3C; alternate-background-color: #252525; }
        QTreeView::item:selected { background-color: #007acc; color: white; }
        QTabWidget::pane { border: 1px solid #3C3C3C; background-color: #1E1E1E; }
        QTabBar::tab { 
            background: #3C3C3C; 
            color: #D3D3D3; 
            border: 1px solid #3C3C3C; 
            border-bottom-color: #1E1E1E; 
            border-top-left-radius: 4px; 
            border-top-right-radius: 4px; 
            padding: 6px 12px; 
            margin-right: 2px; 
        }
        QTabBar::tab:selected { 
            background: #1E1E1E; 
            border-bottom-color: #1E1E1E; 
            color: #FFFFFF; 
        }
        QTabBar::tab:hover { 
            background: #454545; 
        }
        QPlainTextEdit { 
            background-color: #1E1E1E; 
            color: #D3D3D3; 
            border: none; 
            selection-background-color: #007acc; 
            selection-color: white; 
        }
        QPlainTextEdit[readOnly=""true""] { 
            background-color: #1E1E1E; 
            color: #CCCCCC; 
        }
        QLineEdit { 
            background-color: #3C3C3C; 
            color: #D3D3D3; 
            border: 1px solid #505050; 
            padding: 4px; 
            selection-background-color: #007acc; 
            selection-color: white; 
            border-radius: 3px; 
        }
        QComboBox { 
            background-color: #3C3C3C; 
            color: #D3D3D3; 
            border: 1px solid #505050; 
            padding: 4px; 
            border-radius: 3px; 
        }
        QComboBox::drop-down { 
            border: none; 
        }
        QComboBox::down-arrow { 
            image: url(:/icons/down_arrow_dark.png); 
        }
        QDialog { 
            background-color: #2E2E2E; 
            color: #D3D3D3; 
        }
        QLabel { 
            color: #D3D3D3; 
        }
        QDialogButtonBox QPushButton { 
            background-color: #505050; 
            color: #D3D3D3; 
            border: 1px solid #606060; 
            padding: 5px 10px; 
            border-radius: 4px; 
        }
        QSpinBox { 
            background-color: #3C3C3C; 
            color: #D3D3D3; 
            border: 1px solid #505050; 
            padding: 4px; 
            selection-background-color: #007acc; 
            selection-color: white; 
            border-radius: 3px; 
        }
    """"""

def get_light_theme_stylesheet():
    return """"""
        QMainWindow, QWidget { background-color: #F5F5F5; color: #222222; }
        QMenuBar { background-color: #E0E0E0; color: #222222; }
        QMenuBar::item:selected { background-color: #B0B0B0; }
        QMenu { background-color: #FFFFFF; color: #222222; border: 1px solid #CCCCCC; }
        QMenu::item:selected { background-color: #B0B0B0; }
        QToolBar { background-color: #E0E0E0; color: #222222; spacing: 5px; padding: 2px; }
        QToolButton { background-color: transparent; border: 1px solid transparent; padding: 3px; border-radius: 4px; }
        QToolButton:hover { border: 1px solid #CCCCCC; background-color: #F0F0F0; }
        QToolButton:pressed { background-color: #DDDDDD; }
        QPushButton { background-color: #E0E0E0; color: #222222; border: 1px solid #CCCCCC; padding: 4px 8px; border-radius: 4px; }
        QPushButton:hover { background-color: #CCCCCC; }
        QStatusBar { background-color: #E0E0E0; color: #222222; }
        QSplitter::handle { background-color: #CCCCCC; }
        QTreeView { background-color: #FFFFFF; color: #222222; border: 1px solid #CCCCCC; alternate-background-color: #F0F0F0; }
        QTreeView::item:selected { background-color: #007acc; color: white; }
        QTabWidget::pane { border: 1px solid #CCCCCC; background-color: #FFFFFF; }
        QTabBar::tab { 
            background: #E0E0E0; 
            color: #222222; 
            border: 1px solid #CCCCCC; 
            border-bottom-color: #FFFFFF; 
            border-top-left-radius: 4px; 
            border-top-right-radius: 4px; 
            padding: 6px 12px; 
            margin-right: 2px; 
        }
        QTabBar::tab:selected { 
            background: #FFFFFF; 
            border-bottom-color: #FFFFFF; 
            color: #000000; 
        }
        QTabBar::tab:hover { 
            background: #F0F0F0; 
        }
        QPlainTextEdit { 
            background-color: #FFFFFF; 
            color: #222222; 
            border: none; 
            selection-background-color: #007acc; 
            selection-color: white; 
        }
        QPlainTextEdit[readOnly=""true""] { 
            background-color: #F5F5F5; 
            color: #444444; 
        }
        QLineEdit { 
            background-color: #FFFFFF; 
            color: #222222; 
            border: 1px solid #CCCCCC; 
            padding: 4px; 
            selection-background-color: #007acc; 
            selection-color: white; 
            border-radius: 3px; 
        }
        QComboBox { 
            background-color: #FFFFFF; 
            color: #222222; 
            border: 1px solid #CCCCCC; 
            padding: 4px; 
            border-radius: 3px; 
        }
        QComboBox::drop-down { 
            border: none; 
        }
        QComboBox::down-arrow { 
            image: url(:/icons/down_arrow_light.png); 
        }
        QDialog { 
            background-color: #f5f5f5; 
            color: #222222; 
        }
        QLabel { 
            color: #222222; 
        }
        QDialogButtonBox QPushButton { 
            background-color: #e0e0e0; 
            color: #222222; 
            border: 1px solid #cccccc; 
            padding: 5px 10px; 
            border-radius: 4px; 
        }
        QSpinBox { 
            background-color: #FFFFFF; 
            color: #222222; 
            border: 1px solid #CCCCCC; 
            padding: 4px; 
            selection-background-color: #007acc; 
            selection-color: white; 
            border-radius: 3px; 
        }
    """"""

def get_dark_package_manager_stylesheet():
    return """"""
        QDialog {
            background-color: #23272e;
            color: #e0e0e0;
            font-family: 'Segoe UI', sans-serif;
        }
        QTableWidget {
            background-color: #2c313a;
            color: #e0e0e0;
            gridline-color: #444a56;
            border: 1px solid #444a56;
            selection-background-color: #3a3f4b;
            selection-color: #e0e0e0;
        }
        QTableWidget::item {
            padding: 5px;
        }
        QHeaderView::section {
            background-color: #23272e;
            color: #e0e0e0;
            padding: 5px;
            border: none;
            font-weight: bold;
        }
        QPushButton {
            background-color: #3a3f4b;
            color: #e0e0e0;
            border: 1px solid #444a56;
            padding: 5px 10px;
            border-radius: 4px;
        }
        QPushButton:hover {
            background-color: #444a56;
            border-color: #5a6272;
        }
        QPushButton:pressed {
            background-color: #23272e;
        }
        QPushButton:disabled {
            background-color: #2c313a;
            color: #888888;
            border-color: #444a56;
        }
        QProgressBar {
            background-color: #23272e;
            border: 1px solid #444a56;
            border-radius: 4px;
            text-align: center;
            color: #e0e0e0;
        }
        QProgressBar::chunk {
            background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #4CAF50, stop:1 #81C784);
            border-radius: 4px;
        }
        QLabel {
            color: #e0e0e0;
            font-size: 14px;
            margin-bottom: 5px;
        }
        QWidget#actionWidget {
            background-color: transparent;
        }
    """"""

def get_light_package_manager_stylesheet():
    return """"""
        QDialog {
            background-color: #f5f5f5;
            color: #222222;
            font-family: 'Segoe UI', sans-serif;
        }
        QTableWidget {
            background-color: #ffffff;
            color: #222222;
            gridline-color: #cccccc;
            border: 1px solid #cccccc;
            selection-background-color: #b0d6fb;
            selection-color: #222222;
        }
        QTableWidget::item {
            padding: 5px;
        }
        QHeaderView::section {
            background-color: #e0e0e0;
            color: #222222;
            padding: 5px;
            border: none;
            font-weight: bold;
        }
        QPushButton {
            background-color: #e0e0e0;
            color: #222222;
            border: 1px solid #cccccc;
            padding: 5px 10px;
            border-radius: 4px;
        }
        QPushButton:hover {
            background-color: #cccccc;
            border-color: #999999;
        }
        QPushButton:pressed {
            background-color: #bbbbbb;
        }
        QPushButton:disabled {
            background-color: #dddddd;
            color: #aaaaaa;
            border-color: #cccccc;
        }
        QProgressBar {
            background-color: #e0e0e0;
            border: 1px solid #cccccc;
            border-radius: 4px;
            text-align: center;
            color: #222222;
        }
        QProgressBar::chunk {
            background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #4CAF50, stop:1 #81C784);
            border-radius: 4px;
        }
        QLabel {
            color: #222222;
            font-size: 14px;
            margin-bottom: 5px;
        }
        QWidget#actionWidget {
            background-color: transparent;
        }
    """"""

def apply_theme(window: QMainWindow, theme_name: str):
    # Nakładamy motyw jak farbę na płótno, Paffcio! 🎨
    app = QApplication.instance()
    palette = QPalette()

    if theme_name == ""dark"":
        # Ciemny motyw – jak Twój humor po debugowaniu w nocy 😜
        palette.setColor(QPalette.ColorRole.Window, QColor(""#2E2E2E""))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(""#D3D3D3""))
        palette.setColor(QPalette.ColorRole.Base, QColor(""#1E1E1E""))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(""#252525""))
        palette.setColor(QPalette.ColorRole.Text, QColor(""#D3D3D3""))
        palette.setColor(QPalette.ColorRole.Button, QColor(""#505050""))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(""#D3D3D3""))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(""#007acc""))
        palette.setColor(QPalette.ColorRole.HighlightedText, QColor(""#FFFFFF""))
        stylesheet = get_dark_theme_stylesheet()
    else:
        # Jasny motyw – dla tych, co kodzą przy kawie w słońcu ☕
        palette.setColor(QPalette.ColorRole.Window, QColor(""#F5F5F5""))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(""#222222""))
        palette.setColor(QPalette.ColorRole.Base, QColor(""#FFFFFF""))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(""#F0F0F0""))
        palette.setColor(QPalette.ColorRole.Text, QColor(""#222222""))
        palette.setColor(QPalette.ColorRole.Button, QColor(""#E0E0E0""))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(""#222222""))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(""#007acc""))
        palette.setColor(QPalette.ColorRole.HighlightedText, QColor(""#FFFFFF""))
        stylesheet = get_light_theme_stylesheet()

    app.setPalette(palette)
    app.setStyleSheet(stylesheet)
    window.statusBar().showMessage(f""Zmieniono motyw na: {theme_name.capitalize()}"")

Ścieżka: /src/ui.py
Rozmiar: 69,99 KB
Zawartość:
import sys
import os
import json
import subprocess
import re
import platform
import shutil
import shlex
from src.console import ConsoleWidget, ConsoleManager, AIChatManager
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QSplitter, QTreeView, QTabWidget, QPlainTextEdit,
    QPushButton, QLineEdit, QFileDialog, QMenuBar, QToolBar, QStatusBar,
    QMessageBox, QMenu, QStyleFactory, QDialog, QFormLayout,
    QLabel, QDialogButtonBox, QComboBox, QToolButton,
    QInputDialog, QSpinBox, QSizePolicy, QAbstractItemView,
    QFrame
)
from PyQt6.QtGui import (
    QIcon, QAction, QKeySequence, QTextCharFormat, QFont,
    QSyntaxHighlighter, QTextDocument, QColor, QFileSystemModel,
    QDesktopServices, QPalette
)
from PyQt6.QtCore import (
    QDir, Qt, QProcess, QSettings, QFileInfo, QThread, pyqtSignal, QTimer, QSize,
    QStandardPaths, QUrl, QLocale, QCoreApplication, QProcessEnvironment
)
try:
    import qtawesome as qta
except ImportError:
    qta = None
    print(""Zainstaluj qtawesome ('pip install qtawesome') dla lepszych ikon."", file=sys.stderr)

try:
    from src.dialogs import NewProjectDialog, NewItemDialog, RenameItemDialog, SettingsDialog
    from src.package_manager import PackageManagerDialog
except ImportError:
    import sys, os
    sys.path.insert(0, os.path.join(os.path.dirname(__file__)))
    from dialogs import NewProjectDialog, NewItemDialog, RenameItemDialog, SettingsDialog
    from package_manager import PackageManagerDialog
from src.utils import load_package_json, get_file_language
from src.config import HIGHLIGHTING_RULES
from src.theme import apply_theme

# USTAWIENIE ROOT_DIR
ROOT_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
DATA_DIR = os.path.join(ROOT_DIR, 'userdata')
PROJECTS_DIR = os.path.join(ROOT_DIR, 'projects')
SETTINGS_FILE = os.path.join(DATA_DIR, 'settings.json')
RECENTS_FILE = os.path.join(DATA_DIR, 'recents.json')
os.makedirs(DATA_DIR, exist_ok=True)
os.makedirs(PROJECTS_DIR, exist_ok=True)

# Formatowanie podświetlania składni
FORMAT_DEFAULT = QTextCharFormat()
FORMAT_KEYWORD = QTextCharFormat()
FORMAT_KEYWORD.setForeground(QColor(""#000080""))  # Navy
FORMAT_STRING = QTextCharFormat()
FORMAT_STRING.setForeground(QColor(""#008000""))  # Green
FORMAT_COMMENT = QTextCharFormat()
FORMAT_COMMENT.setForeground(QColor(""#808080""))  # Gray
FORMAT_COMMENT.setFontItalic(True)
FORMAT_FUNCTION = QTextCharFormat()
FORMAT_FUNCTION.setForeground(QColor(""#0000FF""))  # Blue
FORMAT_CLASS = QTextCharFormat()
FORMAT_CLASS.setForeground(QColor(""#A52A2A""))  # Brown
FORMAT_CLASS.setFontWeight(QFont.Weight.Bold)
FORMAT_NUMBERS = QTextCharFormat()
FORMAT_NUMBERS.setForeground(QColor(""#FF0000""))  # Red
FORMAT_OPERATOR = QTextCharFormat()
FORMAT_OPERATOR.setForeground(QColor(""#A62929""))  # Dark Red
FORMAT_BUILTIN = QTextCharFormat()
FORMAT_BUILTIN.setForeground(QColor(""#008080""))  # Teal
FORMAT_SECTION = QTextCharFormat()
FORMAT_SECTION.setForeground(QColor(""#800080""))  # Purple
FORMAT_SECTION.setFontWeight(QFont.Weight.Bold)
FORMAT_PROPERTY = QTextCharFormat()
FORMAT_PROPERTY.setForeground(QColor(""#B8860B""))  # DarkGoldenrod

class CodeSyntaxHighlighter(QSyntaxHighlighter):
    def __init__(self, parent: QTextDocument, language: str):
        super().__init__(parent)
        self._language = language.lower()
        self._rules = []
        lang_config = HIGHLIGHTING_RULES.get(self._language, {})
        keywords = lang_config.get('keywords', [])
        builtins = lang_config.get('builtins', [])
        patterns = lang_config.get('patterns', [])
        keyword_format = FORMAT_KEYWORD
        for keyword in keywords:
            pattern = r'\b' + re.escape(keyword) + r'\b'
            self._rules.append((re.compile(pattern), keyword_format))
        builtin_format = FORMAT_BUILTIN
        for builtin in builtins:
            pattern = r'\b' + re.escape(builtin) + r'\b'
            self._rules.append((re.compile(pattern), builtin_format))
        for pattern_str, format, *flags in patterns:
            try:
                pattern = re.compile(pattern_str, *flags)
                self._rules.append((pattern, format))
            except re.error as e:
                print(f""Błąd kompilacji regex '{pattern_str}' dla języka {self._language}: {e}"", file=sys.stderr)

    def highlightBlock(self, text: str):
        self.setFormat(0, len(text), FORMAT_DEFAULT)
        self.setCurrentBlockState(0)
        block_comment_delimiters = []
        if self._language in ['javascript', 'css', 'c++']:
            block_comment_delimiters.append((""/*"", ""*/"", FORMAT_COMMENT))
        if self._language == 'html':
            pass  # HTML comments handled by regex
        comment_start_in_prev_block = (self.previousBlockState() == 1)
        if comment_start_in_prev_block:
            end_delimiter_index = text.find(""*/"")
            if end_delimiter_index >= 0:
                self.setFormat(0, end_delimiter_index + 2, FORMAT_COMMENT)
                self.setCurrentBlockState(0)
                start_pos = end_delimiter_index + 2
            else:
                self.setFormat(0, len(text), FORMAT_COMMENT)
                self.setCurrentBlockState(1)
                return
        else:
            start_pos = 0
        start_delimiter = ""/*""
        end_delimiter = ""*/""
        startIndex = text.find(start_delimiter, start_pos)
        while startIndex >= 0:
            endIndex = text.find(end_delimiter, startIndex)
            if endIndex >= 0:
                length = endIndex - startIndex + len(end_delimiter)
                self.setFormat(startIndex, startIndex + length, FORMAT_COMMENT)
                startIndex = text.find(start_delimiter, startIndex + length)
            else:
                self.setFormat(startIndex, len(text) - startIndex, FORMAT_COMMENT)
                self.setCurrentBlockState(1)
                break
        for pattern, format in self._rules:
            if format == FORMAT_COMMENT and (pattern.pattern.startswith(re.escape('/*')) or pattern.pattern.startswith(re.escape('<!--'))):
                continue
            if format == FORMAT_COMMENT and pattern.pattern.startswith('//') and self.currentBlockState() == 1:
                continue
            for match in pattern.finditer(text):
                start, end = match.span()
                self.setFormat(start, end, format)

class CustomFileSystemModel(QFileSystemModel):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.icon_map = {
            '.py': 'fa5s.file-code',
            '.js': 'fa5s.file-code',
            '.json': 'fa5s.file-code',
            '.html': 'fa5s.file-code',
            '.css': 'fa5s.file-code',
            '.ini': 'fa5s.file-alt',
            '.txt': 'fa5s.file-alt',
            '.md': 'fa5s.file-alt',
            '.c': 'fa5s.file-code',
            '.cpp': 'fa5s.file-code',
            '.h': 'fa5s.file-code',
            '.hpp': 'fa5s.file-code',
        }
        self.folder_icon_name = 'fa5s.folder'
        self.default_file_icon_name = 'fa5s.file'
        self._has_qtawesome = qta is not None

    def rename(self, index, new_name):
        if not index.isValid():
            return False
        old_path = self.filePath(index)
        new_path = os.path.join(os.path.dirname(old_path), new_name)
        try:
            os.rename(old_path, new_path)
            self.refresh()
            return True
        except Exception as e:
            print(f""Błąd podczas zmiany nazwy: {e}"", file=sys.stderr)
            return False

    def data(self, index, role=Qt.ItemDataRole.DisplayRole):
        if not index.isValid():
            return None
        if role == Qt.ItemDataRole.DecorationRole:
            file_info = self.fileInfo(index)
            if file_info.isDir():
                return qta.icon(self.folder_icon_name) if self._has_qtawesome else super().data(index, role)
            elif file_info.isFile():
                extension = file_info.suffix().lower()
                dotted_extension = '.' + extension
                if dotted_extension in self.icon_map and self._has_qtawesome:
                    return qta.icon(self.icon_map[dotted_extension])
                return qta.icon(self.default_file_icon_name) if self._has_qtawesome else super().data(index, role)
        return super().data(index, role)

    def refresh(self, *args):
        self.setRootPath(self.rootPath())

class IDEWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.settings = {
            ""theme"": ""light"",
            ""python_path"": """",
            ""node_path"": """",
            ""show_tree"": True,
            ""show_console"": True,
            ""editor_font_size"": 10,
            ""api_key"": os.getenv(""XAI_API_KEY"", """"),
            ""gemini_api_key"": """",
            ""mistral_api_key"": """",
            ""ai_model"": ""grok-3"",
            ""ai_provider"": ""grok""
        }
        self.recents = {""last_project_dir"": None, ""open_files"": []}
        self._load_app_state()
        self.setWindowTitle(""Proste IDE - Bez nazwy"")
        self.setGeometry(100, 100, 1200, 800)
        self.setWindowIcon(qta.icon('fa5s.code') if qta else QIcon.fromTheme(""applications-development""))
        self.current_project_dir = self.recents.get(""last_project_dir"")
        self.open_files = {}
        self.base_editor_font = QFont(""Courier New"", 10)
        self._setup_ui()
        self._setup_menu()
        self._setup_toolbar()
        self._setup_status_bar()
        self._setup_connections()
        self._apply_theme(self.settings.get(""theme"", ""light""))
        self._apply_editor_font_size()
        self.node_scripts = {}
        QTimer.singleShot(10, self._initial_setup)

    def _setup_ui(self):
        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(0, 0, 0, 0)
        self.main_splitter = QSplitter(Qt.Orientation.Horizontal)
        main_layout.addWidget(self.main_splitter)
        self.project_model = CustomFileSystemModel()
        self.project_model.setFilter(QDir.Filter.AllDirs | QDir.Filter.Files | QDir.Filter.NoDotAndDotDot)
        self.project_tree = QTreeView()
        self.project_tree.setModel(self.project_model)
        self.project_tree.setHeaderHidden(True)
        self.project_tree.hideColumn(1)
        self.project_tree.hideColumn(2)
        self.project_tree.hideColumn(3)
        self.project_tree.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.main_splitter.addWidget(self.project_tree)
        self.right_splitter = QSplitter(Qt.Orientation.Vertical)
        self.main_splitter.addWidget(self.right_splitter)
        self.tab_widget = QTabWidget()
        self.tab_widget.setTabsClosable(True)
        self.tab_widget.setMovable(True)
        self.right_splitter.addWidget(self.tab_widget)
        self.console_manager = ConsoleManager(self)
        self.ai_chat_manager = AIChatManager(self.settings, self)
        self.console_widget = ConsoleWidget(self.console_manager, self.ai_chat_manager)
        self.right_splitter.addWidget(self.console_widget)
        self.main_splitter.setSizes([200, 800])
        self.right_splitter.setSizes([600, 200])
        self.setCentralWidget(central_widget)
        self.action_toggle_tree = QAction(""Pokaż/Ukryj drzewko"", self)
        self.action_toggle_tree.setCheckable(True)
        self.action_toggle_tree.setChecked(True)
        self.action_toggle_tree.triggered.connect(self._toggle_tree_panel)
        self.action_toggle_console = QAction(""Pokaż/Ukryj konsolę i chat ai"", self)
        self.action_toggle_console.setCheckable(True)
        self.action_toggle_console.setChecked(True)
        self.action_toggle_console.triggered.connect(self._toggle_console_panel)
        self._apply_view_settings()

    def _apply_view_settings(self):
        """"""Stosuje ustawienia widoczności paneli z ustawień.""""""
        show_tree = self.settings.get(""show_tree"", True)
        show_console = self.settings.get(""show_console"", True)
        self.main_splitter.widget(0).setVisible(show_tree)
        self.right_splitter.widget(1).setVisible(show_console)
        self.action_toggle_tree.setChecked(show_tree)
        self.action_toggle_console.setChecked(show_console)

    def _toggle_tree_panel(self, checked):
        self.main_splitter.widget(0).setVisible(checked)
        self.settings[""show_tree""] = checked
        self._save_app_state()

    def _toggle_console_panel(self, checked):
        self.right_splitter.widget(1).setVisible(checked)
        self.settings[""show_console""] = checked
        self._save_app_state()

    def _setup_menu(self):
        menu_bar = self.menuBar()
        file_menu = menu_bar.addMenu(""&Plik"")
        self.action_new_project = QAction(qta.icon('fa5s.folder-plus') if qta else QIcon(), ""&Nowy projekt..."", self)
        self.action_new_project.triggered.connect(self._new_project)
        file_menu.addAction(self.action_new_project)
        self.action_open_folder = QAction(qta.icon('fa5s.folder-open') if qta else QIcon(), ""Otwórz &folder projektu..."", self)
        self.action_open_folder.triggered.connect(lambda: self._open_project_folder())
        file_menu.addAction(self.action_open_folder)
        self.action_open_file = QAction(qta.icon('fa5s.file-code') if qta else QIcon(), ""Otwórz &plik..."", self)
        self.action_open_file.triggered.connect(self._open_file_dialog)
        file_menu.addAction(self.action_open_file)
        file_menu.addSeparator()
        self.recent_files_menu = QMenu(""Ostatnio otwierane"", self)
        file_menu.addMenu(self.recent_files_menu)
        file_menu.addSeparator()
        self.action_save = QAction(qta.icon('fa5s.save') if qta else QIcon(), ""&Zapisz"", self)
        self.action_save.setShortcut(QKeySequence.StandardKey.Save)
        self.action_save.triggered.connect(self._save_current_file)
        file_menu.addAction(self.action_save)
        self.action_save_as = QAction(qta.icon('fa5s.file-export') if qta else QIcon(), ""Zapisz &jako..."", self)
        self.action_save_as.setShortcut(QKeySequence.StandardKey.SaveAs)
        self.action_save_as.triggered.connect(self._save_current_file_as)
        file_menu.addAction(self.action_save_as)
        self.action_save_all = QAction(qta.icon('fa5s.save') if qta else QIcon(), ""Zapisz wszys&tko"", self)
        self.action_save_all.setShortcut(QKeySequence(""Ctrl+Shift+S""))
        self.action_save_all.triggered.connect(self._save_all_files)
        file_menu.addAction(self.action_save_all)
        file_menu.addSeparator()
        self.action_close_file = QAction(qta.icon('fa5s.window-close') if qta else QIcon(), ""Zamknij ak&tualny plik"", self)
        self.action_close_file.triggered.connect(self._close_current_tab)
        file_menu.addAction(self.action_close_file)
        file_menu.addSeparator()
        self.action_exit = QAction(qta.icon('fa5s.door-open') if qta else QIcon(), ""&Zakończ"", self)
        self.action_exit.setShortcut(QKeySequence.StandardKey.Quit)
        self.action_exit.triggered.connect(self.close)
        file_menu.addAction(self.action_exit)
        edit_menu = menu_bar.addMenu(""&Edycja"")
        view_menu = menu_bar.addMenu(""&Widok"")
        self.action_toggle_tree = QAction(qta.icon('fa5s.sitemap') if qta else QIcon(), ""Pokaż &drzewko plików"", self)
        self.action_toggle_tree.setCheckable(True)
        self.action_toggle_tree.setChecked(self.settings.get(""show_tree"", True))
        self.action_toggle_tree.triggered.connect(self._toggle_tree_panel)
        view_menu.addAction(self.action_toggle_tree)
        self.action_toggle_console = QAction(qta.icon('fa5s.terminal') if qta else QIcon(), ""Pokaż &konsolę i chat ai"", self)
        self.action_toggle_console.setCheckable(True)
        self.action_toggle_console.setChecked(self.settings.get(""show_console"", True))
        self.action_toggle_console.triggered.connect(self._toggle_console_panel)
        view_menu.addAction(self.action_toggle_console)
        search_menu = menu_bar.addMenu(""&Wyszukaj"")
        self.action_find = QAction(qta.icon('fa5s.search') if qta else QIcon(), ""&Znajdź..."", self)
        self.action_find.setShortcut(QKeySequence.StandardKey.Find)
        self.action_find.triggered.connect(self._show_find_bar)
        search_menu.addAction(self.action_find)
        run_menu = menu_bar.addMenu(""&Uruchom"")
        self.action_run_file = QAction(qta.icon('fa5s.play') if qta else QIcon(), ""&Uruchom aktualny plik"", self)
        self.action_run_file.setShortcut(QKeySequence(""F5""))
        self.action_run_file.triggered.connect(self._run_current_file)
        run_menu.addAction(self.action_run_file)
        tools_menu = menu_bar.addMenu(""&Narzędzia"")
        self.action_settings = QAction(qta.icon('fa5s.cog') if qta else QIcon(), ""&Ustawienia..."", self)
        self.action_settings.triggered.connect(self._show_settings_dialog)
        tools_menu.addAction(self.action_settings)
        self.action_package_manager = QAction(qta.icon('fa5s.box-open') if qta else QIcon(), ""Menadżer pakietów"", self)
        self.action_package_manager.triggered.connect(self._show_package_manager)
        tools_menu.addAction(self.action_package_manager)
        help_menu = menu_bar.addMenu(""&Pomoc"")
        self.action_about = QAction(qta.icon('fa5s.info-circle') if qta else QIcon(), ""&O programie..."", self)
        self.action_about.triggered.connect(self._show_about_dialog)
        help_menu.addAction(self.action_about)

    def _setup_toolbar(self):
        toolbar = self.addToolBar(""Główne narzędzia"")
        toolbar.setMovable(False)
        toolbar.setIconSize(QSize(16, 16))
        toolbar.addAction(self.action_new_project)
        toolbar.addAction(self.action_open_folder)
        toolbar.addAction(self.action_open_file)
        toolbar.addSeparator()
        toolbar.addAction(self.action_save)
        toolbar.addAction(self.action_save_all)
        toolbar.addSeparator()
        self.run_toolbutton = QToolButton(self)
        self.run_toolbutton.setDefaultAction(self.action_run_file)
        self.run_toolbutton.setPopupMode(QToolButton.ToolButtonPopupMode.MenuButtonPopup)
        toolbar.addWidget(self.run_toolbutton)
        toolbar.addSeparator()
        self.search_input = QLineEdit(self)
        self.search_input.setPlaceholderText(""Szukaj w pliku..."")
        self.search_input.setClearButtonEnabled(True)
        self.search_input.returnPressed.connect(lambda: self._find_text(self.search_input.text(), 'next'))
        self.find_next_button = QPushButton(""Znajdź dalej"")
        self.find_next_button.clicked.connect(lambda: self._find_text(self.search_input.text(), 'next'))
        self.find_prev_button = QPushButton(""Znajdź poprzedni"")
        self.find_prev_button.clicked.connect(lambda: self._find_text(self.search_input.text(), 'previous'))
        toolbar.addWidget(self.search_input)
        toolbar.addWidget(self.find_next_button)
        toolbar.addWidget(self.find_prev_button)
        self.search_input.setVisible(False)
        self.find_next_button.setVisible(False)
        self.find_prev_button.setVisible(False)

    def _setup_status_bar(self):
        self.statusBar().showMessage(""Gotowy."")

    def _setup_connections(self):
        self.project_tree.doubleClicked.connect(self._handle_tree_item_double_click)
        self.tab_widget.tabCloseRequested.connect(self._close_tab_by_index)
        self.tab_widget.currentChanged.connect(self._handle_tab_change)
        self.project_tree.customContextMenuRequested.connect(self._show_project_tree_context_menu)

    def _initial_setup(self):
        initial_dir = self.recents.get(""last_project_dir"")
        if not initial_dir or not os.path.isdir(initial_dir):
            initial_dir = PROJECTS_DIR
            os.makedirs(PROJECTS_DIR, exist_ok=True)
        if os.path.isdir(initial_dir):
            self._open_project_folder(initial_dir)
        else:
            self.statusBar().showMessage(""Brak domyślnego katalogu projektu. Otwórz folder ręcznie lub utwórz nowy."")
            self.project_model.setRootPath("""")
            self.current_project_dir = None
            self._update_run_button_menu()
        recent_files = self.recents.get(""open_files"", [])
        QTimer.singleShot(200, lambda: self._reopen_files(recent_files))
        self._update_recent_files_menu()

    def _load_app_state(self):
        try:
            if os.path.exists(SETTINGS_FILE):
                with open(SETTINGS_FILE, 'r', encoding='utf-8') as f:
                    loaded_settings = json.load(f)
                    self.settings.update({
                        ""theme"": loaded_settings.get(""theme"", ""light""),
                        ""python_path"": loaded_settings.get(""python_path"", """"),
                        ""node_path"": loaded_settings.get(""node_path"", """"),
                        ""show_tree"": loaded_settings.get(""show_tree"", True),
                        ""show_console"": loaded_settings.get(""show_console"", True),
                        ""editor_font_size"": loaded_settings.get(""editor_font_size"", 10),
                        ""api_key"": loaded_settings.get(""api_key"", os.getenv(""XAI_API_KEY"", """")),
                        ""gemini_api_key"": loaded_settings.get(""gemini_api_key"", """"),
                        ""mistral_api_key"": loaded_settings.get(""mistral_api_key"", """"),
                        ""ai_model"": loaded_settings.get(""ai_model"", ""grok-3""),
                        ""ai_provider"": loaded_settings.get(""ai_provider"", ""grok"")
                    })
            if os.path.exists(RECENTS_FILE):
                with open(RECENTS_FILE, 'r', encoding='utf-8') as f:
                    loaded_recents = json.load(f)
                    self.recents.update({
                        ""last_project_dir"": loaded_recents.get(""last_project_dir""),
                        ""open_files"": loaded_recents.get(""open_files"", [])
                    })
        except (json.JSONDecodeError, Exception) as e:
            print(f""Błąd podczas wczytywania stanu aplikacji: {e}"", file=sys.stderr)

    def _save_app_state(self):
        try:
            self.recents[""open_files""] = list(self.open_files.keys())
            if self.current_project_dir and os.path.isdir(self.current_project_dir):
                self.recents[""last_project_dir""] = os.path.normpath(self.current_project_dir)
            else:
                self.recents[""last_project_dir""] = None
            with open(SETTINGS_FILE, 'w', encoding='utf-8') as f:
                json.dump(self.settings, f, indent=4)
            with open(RECENTS_FILE, 'w', encoding='utf-8') as f:
                normalized_open_files = [os.path.normpath(p) for p in self.recents[""open_files""]]
                unique_open_files = []
                for p in normalized_open_files:
                    if p not in unique_open_files:
                        unique_open_files.append(p)
                self.recents[""open_files""] = unique_open_files[:20]
                json.dump(self.recents, f, indent=4)
        except Exception as e:
            print(f""Błąd podczas zapisu stanu aplikacji: {e}"", file=sys.stderr)

    def closeEvent(self, event):
        unsaved_files = [path for path, editor in self.open_files.items() if editor.document().isModified()]
        if unsaved_files:
            msg_box = QMessageBox(self)
            msg_box.setIcon(QMessageBox.Icon.Warning)
            msg_box.setWindowTitle(""Niezapisane zmiany"")
            msg_box.setText(f""Masz niezapisane zmiany w {len(unsaved_files)} plikach.\nCzy chcesz zapisać przed zamknięciem?"")
            msg_box.setStandardButtons(QMessageBox.StandardButton.Save | QMessageBox.StandardButton.Discard | QMessageBox.StandardButton.Cancel)
            msg_box.setDefaultButton(QMessageBox.StandardButton.Save)
            reply = msg_box.exec()
            if reply == QMessageBox.StandardButton.Save:
                if self._save_all_files():
                    self._save_app_state()
                    event.accept()
                else:
                    event.ignore()
            elif reply == QMessageBox.StandardButton.Discard:
                for i in range(self.tab_widget.count() - 1, -1, -1):
                    widget = self.tab_widget.widget(i)
                    if hasattr(widget, 'document'):
                        widget.document().setModified(False)
                    self._close_tab_by_index(i)
                self._save_app_state()
                event.accept()
            else:
                event.ignore()
        else:
            self._save_app_state()
            event.accept()

    def _new_project(self):
        dialog = NewProjectDialog(PROJECTS_DIR, self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            project_name = dialog.get_project_name()
            project_path = dialog.get_project_path()
            try:
                if os.path.exists(project_path):
                    QMessageBox.warning(self, ""Projekt już istnieje"", f""Projekt o nazwie '{project_name}' już istnieje."")
                    return
                os.makedirs(project_path)
                self.statusBar().showMessage(f""Utworzono nowy projekt: {project_name}"")
                self._open_project_folder(project_path)
            except OSError as e:
                QMessageBox.critical(self, ""Błąd tworzenia projektu"", f""Nie można utworzyć katalogu projektu:\n{e}"")
                self.statusBar().showMessage(""Błąd tworzenia projektu."")

    def _open_project_folder(self, path=None):
        if path is None:
            start_path = self.current_project_dir if self.current_project_dir else PROJECTS_DIR
            dialog_path = QFileDialog.getExistingDirectory(self, ""Otwórz folder projektu"", start_path)
            if not dialog_path:
                return
            path = dialog_path
        path = os.path.normpath(path)
        if not os.path.isdir(path):
            QMessageBox.critical(self, ""Błąd"", f""Wybrana ścieżka nie jest katalogiem lub nie istnieje:\n{path}"")
            self.statusBar().showMessage(f""Błąd: Nie można otworzyć folderu: {path}"")
            return
        if self.current_project_dir and self.current_project_dir != path:
            unsaved_files_count = sum(1 for editor in self.open_files.values() if editor.document().isModified())
            if unsaved_files_count > 0:
                reply = QMessageBox.question(self, ""Niezapisane zmiany"",
                                            f""Obecny projekt ma {unsaved_files_count} niezapisanych plików.\n""
                                            ""Czy chcesz zapisać zmiany przed otwarciem nowego folderu?"",
                                            QMessageBox.StandardButton.Save | QMessageBox.StandardButton.Discard | QMessageBox.StandardButton.Cancel)
                if reply == QMessageBox.StandardButton.Cancel:
                    self.statusBar().showMessage(""Otwieranie folderu anulowane."")
                    return
                if reply == QMessageBox.StandardButton.Save:
                    if not self._save_all_files():
                        self.statusBar().showMessage(""Otwieranie folderu anulowane (błąd zapisu)."")
                        return
            self._close_all_files()
        self.current_project_dir = path
        self.project_model.setRootPath(path)
        root_index = self.project_model.index(path)
        if not root_index.isValid():
            QMessageBox.critical(self, ""Błąd"", f""Nie można ustawić katalogu głównego drzewka dla ścieżki:\n{path}"")
            self.statusBar().showMessage(f""Błąd ustawienia katalogu głównego: {path}"")
            self.project_tree.setRootIndex(self.project_model.index(""""))
            self.current_project_dir = None
            self.recents[""open_files""] = [p for p in self.recents[""open_files""] if not os.path.normpath(p).startswith(os.path.normpath(path) + os.sep)]
            self._update_recent_files_menu()
            self._save_app_state()
            self._update_run_button_menu()
            return
        self.project_tree.setRootIndex(root_index)
        self.setWindowTitle(f""Proste IDE - {os.path.basename(path)}"")
        self.statusBar().showMessage(f""Otwarto folder: {path}"")
        self._check_package_json(path)
        self.recents[""last_project_dir""] = path
        self._save_app_state()

    def _close_all_files(self):
        for file_path in list(self.open_files.keys()):
            editor_widget = self.open_files.get(file_path)
            if editor_widget:
                tab_index = self.tab_widget.indexOf(editor_widget)
                if tab_index != -1:
                    if hasattr(editor_widget, 'document'):
                        editor_widget.document().setModified(False)
                    self.tab_widget.removeTab(tab_index)
                    if file_path in self.open_files:
                        del self.open_files[file_path]
        self.recents[""open_files""] = []
        self._update_recent_files_menu()

    def _open_file_dialog(self):
        start_path = self.current_project_dir if self.current_project_dir else PROJECTS_DIR
        file_path, _ = QFileDialog.getOpenFileName(self, ""Otwórz plik"", start_path, ""Wszystkie pliki (*);;Pliki Pythona (*.py);;Pliki JavaScript (*.js);;Pliki HTML (*.html);;Pliki CSS (*.css);;Pliki C++ (*.c *.cpp *.h *.hpp);;Pliki INI (*.ini);;Pliki JSON (*.json)"")
        if file_path:
            self._open_file(file_path)

    def _open_file(self, file_path):
        file_path = os.path.normpath(file_path)
        if not os.path.exists(file_path) or not os.path.isfile(file_path):
            self.statusBar().showMessage(f""Błąd: Plik nie istnieje lub nie jest plikiem: {file_path}"")
            if file_path in self.recents[""open_files""]:
                self.recents[""open_files""].remove(file_path)
                self._update_recent_files_menu()
                self._save_app_state()
            return
        if file_path in self.open_files:
            index = -1
            for i in range(self.tab_widget.count()):
                widget = self.tab_widget.widget(i)
                if self.open_files.get(file_path) is widget:
                    index = i
                    break
            if index != -1:
                self.tab_widget.setCurrentIndex(index)
                self.statusBar().showMessage(f""Plik {os.path.basename(file_path)} jest już otwarty."")
                if file_path in self.recents[""open_files""]:
                    self.recents[""open_files""].remove(file_path)
                    self.recents[""open_files""].insert(0, file_path)
                    self._update_recent_files_menu()
                    self._save_app_state()
                return
        try:
            content = """"
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
            except UnicodeDecodeError:
                try:
                    with open(file_path, 'r', encoding='latin-1') as f:
                        content = f.read()
                except Exception:
                    with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                        content = f.read()
        except Exception as e:
            QMessageBox.critical(self, ""Błąd otwarcia pliku"", f""Nie można odczytać pliku {os.path.basename(file_path)}:\n{e}"")
            self.statusBar().showMessage(f""Błąd otwarcia pliku: {os.path.basename(file_path)}"")
            return
        editor = QPlainTextEdit()
        editor.setPlainText(content)
        editor.setFont(self.base_editor_font)
        editor.document().setModified(False)
        editor.document().modificationChanged.connect(self._handle_modification_changed)
        language = self._get_language_from_path(file_path)
        highlighter = CodeSyntaxHighlighter(editor.document(), language)
        setattr(editor.document(), '_syntax_highlighter', highlighter)
        tab_index = self.tab_widget.addTab(editor, os.path.basename(file_path))
        self.tab_widget.setCurrentIndex(tab_index)
        self.open_files[file_path] = editor
        self.statusBar().showMessage(f""Otwarto plik: {file_path}"")
        if file_path in self.recents[""open_files""]:
            self.recents[""open_files""].remove(file_path)
        self.recents[""open_files""].insert(0, file_path)
        self._update_recent_files_menu()
        self._save_app_state()

    def _reopen_files(self, file_list):
        files_to_reopen = list(file_list)
        valid_files = [f for f in files_to_reopen if os.path.exists(f) and os.path.isfile(f)]
        self.recents[""open_files""] = valid_files
        self._update_recent_files_menu()
        for file_path in valid_files:
            QTimer.singleShot(0, lambda path=file_path: self._open_file(path))
        invalid_files = [f for f in files_to_reopen if f not in valid_files]
        if invalid_files:
            msg = ""Nie można ponownie otworzyć następujących plików (nie znaleziono):\n"" + ""\n"".join(invalid_files)
            QMessageBox.warning(self, ""Błąd otwarcia plików"", msg)

    def _update_recent_files_menu(self):
        self.recent_files_menu.clear()
        recent_items_to_show = list(self.recents.get(""open_files"", []))[:15]
        if not recent_items_to_show:
            self.recent_files_menu.addAction(""Brak ostatnio otwieranych plików"").setEnabled(False)
            return
        actions_to_add = []
        cleaned_recent_files = []
        for file_path in recent_items_to_show:
            if os.path.exists(file_path) and os.path.isfile(file_path):
                cleaned_recent_files.append(file_path)
                menu_text = os.path.basename(file_path)
                action = QAction(menu_text, self)
                action.setData(file_path)
                action.triggered.connect(lambda checked, path=file_path: self._open_file(path))
                actions_to_add.append(action)
        all_existing_recent_files = [p for p in self.recents.get(""open_files"", []) if os.path.exists(p) and os.path.isfile(p)]
        unique_recent_files = []
        for p in all_existing_recent_files:
            if p not in unique_recent_files:
                unique_recent_files.append(p)
        self.recents[""open_files""] = unique_recent_files[:20]
        for action in actions_to_add:
            self.recent_files_menu.addAction(action)
        self._save_app_state()

    def _show_project_tree_context_menu(self, point):
        index = self.project_tree.indexAt(point)
        menu = QMenu(self)
        if index.isValid():
            file_path = self.project_model.filePath(index)
            file_info = self.project_model.fileInfo(index)
            if file_info.isFile():
                open_action = QAction(""Otwórz"", self)
                open_action.triggered.connect(lambda: self._open_file(file_path))
                menu.addAction(open_action)
            # Dodaj opcję ""Otwórz jako projekt"" dla folderów
            if file_info.isDir():
                open_as_project_action = QAction(""Otwórz jako projekt"", self)
                open_as_project_action.triggered.connect(lambda: self._open_project_folder(file_path))
                menu.addAction(open_as_project_action)
            new_file_action = QAction(""Nowy plik"", self)
            new_file_action.triggered.connect(lambda: self._create_new_item(index, is_folder=False))
            menu.addAction(new_file_action)
            new_folder_action =QAction(""Nowy folder"", self)
            new_folder_action.triggered.connect(lambda: self._create_new_item(index, is_folder=True))
            menu.addAction(new_folder_action)
            rename_action = QAction(""Zmień nazwę"", self)
            rename_action.triggered.connect(lambda: self._rename_item(index))
            menu.addAction(rename_action)
            delete_action = QAction(""Usuń"", self)
            delete_action.triggered.connect(lambda: self._delete_item(index))
            menu.addAction(delete_action)
            if file_info.isFile():
                duplicate_action = QAction(""Duplikuj"", self)
                duplicate_action.triggered.connect(lambda: self._duplicate_file(index))
                menu.addAction(duplicate_action)
        else:
            new_file_action = QAction(""Nowy plik"", self)
            new_file_action.triggered.connect(lambda: self._create_new_item(None, is_folder=False))
            menu.addAction(new_file_action)
            new_folder_action = QAction(""Nowy folder"", self)
            new_folder_action.triggered.connect(lambda: self._create_new_item(None, is_folder=True))
            menu.addAction(new_folder_action)
        menu.exec(self.project_tree.mapToGlobal(point))

    def _create_new_item(self, index, is_folder=False):
        parent_dir = self.current_project_dir
        if index and index.isValid():
            file_path = self.project_model.filePath(index)
            if self.project_model.fileInfo(index).isDir():
                parent_dir = file_path
            else:
                parent_dir = os.path.dirname(file_path)
        dialog = NewItemDialog(parent_dir, is_folder, self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            item_name = dialog.get_item_name()
            full_path = os.path.join(parent_dir, item_name)
            try:
                if is_folder:
                    os.makedirs(full_path, exist_ok=True)
                else:
                    with open(full_path, 'w', encoding='utf-8') as f:
                        f.write('')
                self.statusBar().showMessage(f""Utworzono: {item_name}"")
                parent_index = self.project_model.index(parent_dir)
                if parent_index.isValid():
                    self.project_model.refresh(parent_index)
            except OSError as e:
                QMessageBox.critical(self, ""Błąd tworzenia"", f""Nie można utworzyć {item_name}:\n{e}"")
                self.statusBar().showMessage(""Błąd tworzenia."")

    def _rename_item(self, index):
        if not index.isValid():
            return
        current_path = self.project_model.filePath(index)
        dialog = RenameItemDialog(current_path, self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            new_name = dialog.get_new_name()
            if self.project_model.rename(index, new_name):
                self.statusBar().showMessage(f""Zmieniono nazwę na: {new_name}"")
            else:
                QMessageBox.critical(self, ""Błąd zmiany nazwy"", f""Nie można zmienić nazwy na '{new_name}'."")
                self.statusBar().showMessage(""Błąd zmiany nazwy."")

    def _delete_item(self, index):
        if not index.isValid():
            return
        file_path = self.project_model.filePath(index)
        file_info = self.project_model.fileInfo(index)
        item_name = file_info.fileName()
        is_dir = file_info.isDir()
        open_files_to_close = []
        if is_dir:
            for open_file_path in self.open_files:
                if os.path.normpath(open_file_path).startswith(os.path.normpath(file_path) + os.sep):
                    open_files_to_close.append(open_file_path)
        else:
            if file_path in self.open_files:
                open_files_to_close.append(file_path)
        if open_files_to_close:
            reply_close = QMessageBox.question(self, ""Otwarte pliki"",
                                              f""Element '{item_name}' zawiera {len(open_files_to_close)} otwartych plików.\n""
                                              f""Czy chcesz zamknąć te pliki, aby kontynuować usuwanie '{item_name}'?"",
                                              QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
            if reply_close == QMessageBox.StandardButton.No:
                self.statusBar().showMessage(f""Usuwanie '{item_name}' anulowane."")
                return
            unsaved_open_files = [p for p in open_files_to_close if self.open_files.get(p) and self.open_files[p].document().isModified()]
            if unsaved_open_files:
                save_reply = QMessageBox.question(self, ""Niezapisane zmiany"",
                                                 f""Niektóre z plików ({len(unsaved_open_files)}) mają niezapisane zmiany. Czy chcesz je zapisać przed zamknięciem i usunięciem?"",
                                                 QMessageBox.StandardButton.Save | QMessageBox.StandardButton.Discard | QMessageBox.StandardButton.Cancel)
                if save_reply == QMessageBox.StandardButton.Cancel:
                    self.statusBar().showMessage(""Usuwanie anulowane (niezapisane zmiany)."")
                    return
                if save_reply == QMessageBox.StandardButton.Save:
                    save_success = True
                    for file_path_to_save in unsaved_open_files:
                        editor = self.open_files.get(file_path_to_save)
                        if editor and not self._save_file(editor, file_path_to_save):
                            save_success = False
                            break
                    if not save_success:
                        self.statusBar().showMessage(""Usuwanie anulowane (błąd zapisu otwartych plików)."")
                        return
            for file_path_to_close in reversed(open_files_to_close):
                editor_widget = self.open_files.get(file_path_to_close)
                if editor_widget:
                    tab_index = self.tab_widget.indexOf(editor_widget)
                    if tab_index != -1:
                        if hasattr(editor_widget, 'document'):
                            editor_widget.document().setModified(False)
                        self.tab_widget.removeTab(tab_index)
                        del self.open_files[file_path_to_close]
                        editor_widget.deleteLater()
            self.recents[""open_files""] = [p for p in self.recents[""open_files""] if p not in open_files_to_close]
            self._update_recent_files_menu()
            self._save_app_state()
        item_type = ""folder"" if is_dir else ""plik""
        reply = QMessageBox.question(self, f""Usuń {item_type}"",
                                    f""Czy na pewno chcesz usunąć {item_type} '{item_name}'?\n""
                                    ""Ta operacja jest nieodwracalna!"",
                                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        if reply == QMessageBox.StandardButton.Yes:
            success = self.project_model.remove(index)
            if success:
                self.statusBar().showMessage(f""Usunięto {item_type}: {item_name}"")
            else:
                QMessageBox.critical(self, f""Błąd usuwania {item_type}"", f""Nie można usunąć {item_type} '{item_name}'."")
                self.statusBar().showMessage(f""Błąd usuwania {item_type}."")

    def _duplicate_file(self, index):
        if not index.isValid():
            return
        file_path = self.project_model.filePath(index)
        file_info = self.project_model.fileInfo(index)
        if not file_info.isFile():
            self.statusBar().showMessage(""Można duplikować tylko pliki."")
            return
        parent_dir = os.path.dirname(file_path)
        old_name = os.path.basename(file_path)
        name, ext = os.path.splitext(old_name)
        suggested_name = f""{name}_kopia{ext}""
        counter = 1
        while os.path.exists(os.path.join(parent_dir, suggested_name)):
            counter += 1
            suggested_name = f""{name}_kopia{counter}{ext}""
        new_name, ok = QInputDialog.getText(self, ""Duplikuj plik"", f""Podaj nazwę dla kopii '{old_name}':"",
                                           QLineEdit.EchoMode.Normal, suggested_name)
        if ok and new_name:
            new_name = new_name.strip()
            if not new_name or re.search(r'[<>:""/\\|?*\x00-\x1F]', new_name) is not None:
                QMessageBox.warning(self, ""Nieprawidłowa nazwa"", ""Podana nazwa jest pusta lub zawiera niedozwolone znaki."")
                self.statusBar().showMessage(""Duplikowanie anulowane (nieprawidłowa nazwa)."")
                return
            new_path = os.path.join(parent_dir, new_name)
            if os.path.exists(new_path):
                QMessageBox.warning(self, ""Element już istnieje"", f""Element o nazwie '{new_name}' już istnieje."")
                self.statusBar().showMessage(""Duplikowanie anulowane (element już istnieje)."")
                return
            try:
                os.makedirs(os.path.dirname(new_path), exist_ok=True)
                shutil.copy2(file_path, new_path)
                self.statusBar().showMessage(f""Utworzono kopię: {new_name}"")
                parent_index = self.project_model.index(parent_dir)
                if parent_index.isValid():
                    self.project_model.refresh(parent_index)
                else:
                    root_path = self.project_model.rootPath()
                    if root_path and os.path.isdir(root_path):
                        self.project_model.refresh(self.project_model.index(root_path))
            except OSError as e:
                QMessageBox.critical(self, ""Błąd duplikowania"", f""Nie można zduplikować pliku '{old_name}':\n{e}"")
                self.statusBar().showMessage(""Błąd duplikowania pliku."")

    def _close_tab_by_index(self, index):
        if index == -1:
            return
        widget = self.tab_widget.widget(index)
        if widget is None:
            return
        file_path_before_save = None
        for path, editor_widget in list(self.open_files.items()):
            if editor_widget is widget:
                file_path_before_save = path
                break
        if hasattr(widget, 'document') and widget.document().isModified():
            msg_box = QMessageBox(self)
            msg_box.setIcon(QMessageBox.Icon.Warning)
            msg_box.setWindowTitle(""Niezapisane zmiany"")
            tab_text = self.tab_widget.tabText(index).rstrip('*')
            display_name = os.path.basename(file_path_before_save) if file_path_before_save else tab_text
            msg_box.setText(f""Plik '{display_name}' ma niezapisane zmiany.\nCzy chcesz zapisać przed zamknięciem?"")
            msg_box.setStandardButtons(QMessageBox.StandardButton.Save | QMessageBox.StandardButton.Discard | QMessageBox.StandardButton.Cancel)
            msg_box.setDefaultButton(QMessageBox.StandardButton.Save)
            reply = msg_box.exec()
            if reply == QMessageBox.StandardButton.Save:
                needs_save_as = (file_path_before_save is None or
                                 not os.path.exists(file_path_before_save) or
                                 not QFileInfo(file_path_before_save).isFile())
                if needs_save_as:
                    original_index = self.tab_widget.currentIndex()
                    self.tab_widget.setCurrentIndex(index)
                    save_success = self._save_current_file_as()
                    if original_index != -1 and original_index < self.tab_widget.count():
                        self.tab_widget.setCurrentIndex(original_index)
                    if not save_success:
                        self.statusBar().showMessage(f""Zamknięcie anulowane (błąd zapisu '{display_name}')."")
                        return
                else:
                    if not self._save_file(widget, file_path_before_save):
                        self.statusBar().showMessage(f""Zamknięcie anulowane (błąd zapisu '{display_name}')."")
                        return
            elif reply == QMessageBox.StandardButton.Cancel:
                self.statusBar().showMessage(f""Zamknięcie '{tab_text}' anulowane."")
                return
        if file_path_before_save in self.open_files:
            del self.open_files[file_path_before_save]
            if file_path_before_save in self.recents[""open_files""]:
                self.recents[""open_files""].remove(file_path_before_save)
                self._update_recent_files_menu()
        self.tab_widget.removeTab(index)
        widget.deleteLater()
        if file_path_before_save:
            self.statusBar().showMessage(f""Zamknięto plik: {os.path.basename(file_path_before_save)}"")
        else:
            self.statusBar().showMessage(""Zamknięto plik."")
        self._save_app_state()

    def _close_current_tab(self):
        current_index = self.tab_widget.currentIndex()
        if current_index != -1:
            self._close_tab_by_index(current_index)

    def _save_current_file(self):
        current_widget = self.tab_widget.currentWidget()
        if not isinstance(current_widget, QPlainTextEdit):
            self.statusBar().showMessage(""Brak aktywnego pliku do zapisu."")
            return False
        file_path = None
        for path, editor_widget in list(self.open_files.items()):
            if editor_widget is current_widget:
                file_path = path
                break
        is_existing_valid_file = file_path and os.path.exists(file_path) and QFileInfo(file_path).isFile()
        if is_existing_valid_file:
            return self._save_file(current_widget, file_path)
        else:
            return self._save_current_file_as()

    def _save_current_file_as(self):
        current_widget = self.tab_widget.currentWidget()
        if not isinstance(current_widget, QPlainTextEdit):
            self.statusBar().showMessage(""Brak aktywnego pliku do zapisu."")
            return False
        old_file_path = None
        for path, editor_widget in list(self.open_files.items()):
            if editor_widget is current_widget:
                old_file_path = path
                break
        suggested_name = ""bez_nazwy.txt""
        current_tab_index = self.tab_widget.indexOf(current_widget)
        if current_tab_index != -1:
            original_tab_text = self.tab_widget.tabText(current_tab_index).rstrip('*')
            if original_tab_text and original_tab_text != ""Nowy plik"":
                suggested_name = original_tab_text
            elif current_widget.document().toPlainText().strip():
                first_line = current_widget.document().toPlainText().strip().split('\n')[0].strip()
                if first_line:
                    suggested_name = re.sub(r'[\\/:*?""<>|]', '_', first_line)
                    suggested_name = suggested_name[:50].strip()
                    if not suggested_name:
                        suggested_name = ""bez_nazwy""
                    if '.' not in os.path.basename(suggested_name):
                        suggested_name += "".txt""
                else:
                    suggested_name = ""bez_nazwy.txt""
        start_path = self.current_project_dir if self.current_project_dir else PROJECTS_DIR
        if old_file_path and os.path.dirname(old_file_path):
            start_path = os.path.dirname(old_file_path)
        elif os.path.isdir(start_path):
            pass
        else:
            start_path = os.path.expanduser(""~"")
        file_filters = ""Wszystkie pliki (*);;Pliki Pythona (*.py);;Pliki JavaScript (*.js);;Pliki HTML (*.html);;Pliki CSS (*.css);;Pliki C++ (*.c *.cpp *.h *.hpp);;Pliki INI (*.ini);;Pliki JSON (*.json)""
        new_file_path, _ = QFileDialog.getSaveFileName(self, ""Zapisz plik jako..."", os.path.join(start_path, suggested_name), file_filters)
        if not new_file_path:
            self.statusBar().showMessage(""Zapisywanie anulowane."")
            return False
        new_file_path = os.path.normpath(new_file_path)
        if old_file_path and old_file_path != new_file_path:
            if old_file_path in self.open_files:
                del self.open_files[old_file_path]
            if old_file_path in self.recents[""open_files""]:
                self.recents[""open_files""].remove(old_file_path)
                self._update_recent_files_menu()
        self.open_files[new_file_path] = current_widget
        current_tab_index = self.tab_widget.indexOf(current_widget)
        if current_tab_index != -1:
            self.tab_widget.setTabText(current_tab_index, os.path.basename(new_file_path))
        if new_file_path in self.recents[""open_files""]:
            self.recents[""open_files""].remove(new_file_path)
        self.recents[""open_files""].insert(0, new_file_path)
        self._update_recent_files_menu()
        language = self._get_language_from_path(new_file_path)
        old_highlighter = getattr(current_widget.document(), '_syntax_highlighter', None)
        if old_highlighter:
            old_highlighter.setDocument(None)
        new_highlighter = CodeSyntaxHighlighter(current_widget.document(), language)
        setattr(current_widget.document(), '_syntax_highlighter', new_highlighter)
        return self._save_file(current_widget, new_file_path)

    def _save_file(self, editor_widget, file_path):
        if not file_path:
            print(""Error: _save_file called with empty path."", file=sys.stderr)
            self.statusBar().showMessage(""Błąd wewnętrzny: próba zapisu bez ścieżki."")
            return False
        try:
            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(editor_widget.toPlainText())
            editor_widget.document().setModified(False)
            self.statusBar().showMessage(f""Plik zapisano pomyślnie: {os.path.basename(file_path)}"")
            tab_index = self.tab_widget.indexOf(editor_widget)
            if tab_index != -1:
                current_tab_text = self.tab_widget.tabText(tab_index).rstrip('*')
                self.tab_widget.setTabText(tab_index, current_tab_text)
            file_info = QFileInfo(file_path)
            dir_path = file_info.dir().path()
            root_path = self.project_model.rootPath()
            if root_path and dir_path.startswith(root_path):
                dir_index = self.project_model.index(dir_path)
                if dir_index.isValid():
                    self.project_model.refresh(dir_index)
                file_index = self.project_model.index(file_path)
                if file_index.isValid():
                    self.project_model.dataChanged.emit(file_index, file_index, [Qt.ItemDataRole.DisplayRole, Qt.ItemDataRole.DecorationRole])
            if file_path in self.recents[""open_files""]:
                self.recents[""open_files""].remove(file_path)
            self.recents[""open_files""].insert(0, file_path)
            self._update_recent_files_menu()
            self._save_app_state()
            return True
        except Exception as e:
            QMessageBox.critical(self, ""Błąd zapisu pliku"", f""Nie można zapisać pliku {os.path.basename(file_path)}:\n{e}"")
            self.statusBar().showMessage(f""Błąd zapisu pliku: {os.path.basename(file_path)}"")
            return False

    def _save_all_files(self):
        unsaved_files = [path for path, editor in self.open_files.items() if editor.document().isModified()]
        if not unsaved_files:
            self.statusBar().showMessage(""Brak zmodyfikowanych plików do zapisu."")
            return True
        self.statusBar().showMessage(f""Zapisywanie wszystkich zmodyfikowanych plików ({len(unsaved_files)})..."")
        total_saved = 0
        total_failed = 0
        files_to_save = list(unsaved_files)
        for file_path in files_to_save:
            editor_widget = self.open_files.get(file_path)
            if editor_widget is None or self.tab_widget.indexOf(editor_widget) == -1:
                print(f""Warning: Skipping save for {file_path} - editor widget not found or invalid."", file=sys.stderr)
                continue
            if not editor_widget.document().isModified():
                continue
            needs_save_as = (file_path is None or
                             not os.path.exists(file_path) or
                             not QFileInfo(file_path).isFile())
            save_success = False
            if needs_save_as:
                tab_index = self.tab_widget.indexOf(editor_widget)
                if tab_index != -1:
                    original_index = self.tab_widget.currentIndex()
                    self.tab_widget.setCurrentIndex(tab_index)
                    save_success = self._save_current_file_as()
                    if original_index != -1 and original_index < self.tab_widget.count():
                        self.tab_widget.setCurrentIndex(original_index)
                else:
                    print(f""Error: Cannot save '{os.path.basename(file_path if file_path else 'Nowy plik')}' (Save As needed) - widget not found in tabs."", file=sys.stderr)
                    total_failed += 1
                    continue
            else:
                save_success = self._save_file(editor_widget, file_path)
            if save_success:
                total_saved += 1
            else:
                total_failed += 1
        if total_saved > 0 and total_failed == 0:
            self.statusBar().showMessage(f""Zapisano pomyślnie wszystkie {total_saved} pliki."")
            return True
        elif total_saved > 0 and total_failed > 0:
            self.statusBar().showMessage(f""Zapisano {total_saved} plików, {total_failed} plików nie udało się zapisać."")
            QMessageBox.warning(self, ""Błąd zapisu wszystkich plików"", f""Nie udało się zapisać {total_failed} plików."")
            return False
        elif total_saved == 0 and total_failed > 0:
            self.statusBar().showMessage(f""Nie udało się zapisać żadnego z {total_failed} plików."")
            QMessageBox.critical(self, ""Błąd zapisu wszystkich plików"", f""Nie udało się zapisać żadnego z plików."")
            return False
        else:
            self.statusBar().showMessage(""Brak zmodyfikowanych plików do zapisu."")
            return True

    def _handle_modification_changed(self, modified):
        editor_document = self.sender()
        if not isinstance(editor_document, QTextDocument):
            return
        editor = None
        for editor_widget in self.open_files.values():
            if editor_widget.document() is editor_document:
                editor = editor_widget
                break
        if editor is None:
            return
        index = self.tab_widget.indexOf(editor)
        if index != -1:
            tab_text = self.tab_widget.tabText(index)
            if modified and not tab_text.endswith('*'):
                self.tab_widget.setTabText(index, tab_text + '*')
            elif not modified and tab_text.endswith('*'):
                self.tab_widget.setTabText(index, tab_text.rstrip('*'))

    def _handle_tab_change(self, index):
        self._hide_find_bar()
        if index != -1:
            widget = self.tab_widget.widget(index)
            if isinstance(widget, QPlainTextEdit):
                file_path = next((path for path, ed in self.open_files.items() if ed is widget), None)
                if file_path:
                    self.statusBar().showMessage(f""Edytujesz: {os.path.basename(file_path)}"")
                else:
                    self.statusBar().showMessage(""Edytujesz: Nowy plik"")
        else:
            self.statusBar().showMessage(""Gotowy."")

    def _find_text(self, text, direction='next'):
        editor = self.tab_widget.currentWidget()
        if not isinstance(editor, QPlainTextEdit):
            self.statusBar().showMessage(""Brak aktywnego edytora do wyszukiwania."")
            return
        if not text:
            self.statusBar().showMessage(""Wpisz tekst do wyszukiwania."")
            return
        flags = QTextDocument.FindFlag(0)
        if direction == 'previous':
            flags |= QTextDocument.FindFlag.FindBackward
        found = editor.find(text, flags)
        if found:
            self.statusBar().showMessage(f""Znaleziono '{text}'."")
        else:
            self.statusBar().showMessage(f""Nie znaleziono '{text}'. Zawijanie..."")
            cursor = editor.textCursor()
            original_position = cursor.position()
            cursor.clearSelection()
            cursor.movePosition(cursor.MoveOperation.Start if direction == 'next' else cursor.MoveOperation.End)
            editor.setTextCursor(cursor)
            found_wrapped = editor.find(text, flags)
            if found_wrapped:
                self.statusBar().showMessage(f""Znaleziono '{text}' po zawinięciu."")
            else:
                self.statusBar().showMessage(f""Nie znaleziono '{text}' w całym pliku."")
                cursor.clearSelection()
                cursor.setPosition(original_position)
                editor.setTextCursor(cursor)

    def _show_find_bar(self):
        if self.search_input.isVisible():
            self._hide_find_bar()
            return
        self.search_input.setVisible(True)
        self.find_next_button.setVisible(True)
        self.find_prev_button.setVisible(True)
        self.search_input.setFocus()

    def _hide_find_bar(self):
        if self.search_input.isVisible():
            self.search_input.setVisible(False)
            self.find_next_button.setVisible(False)
            self.find_prev_button.setVisible(False)
            self.search_input.clear()

    def _run_current_file(self):
        current_widget = self.tab_widget.currentWidget()
        if not isinstance(current_widget, QPlainTextEdit):
            self.console_widget.console.appendPlainText(""Brak aktywnego pliku do uruchomienia."")
            self.statusBar().showMessage(""Błąd: Żaden plik nie jest otwarty."")
            return
        file_path = next((path for path, editor_widget in self.open_files.items() if editor_widget is current_widget), None)
        if not file_path or not os.path.exists(file_path) or not os.path.isfile(file_path):
            self.console_widget.console.appendPlainText(""Ścieżka aktywnego pliku jest nieprawidłowa lub plik nie istnieje."")
            self.statusBar().showMessage(""Błąd: Plik nie istnieje."")
            return
        if current_widget.document().isModified():
            if not self._save_file(current_widget, file_path):
                self.console_widget.console.appendPlainText(""Nie udało się zapisać pliku przed uruchomieniem."")
                self.statusBar().showMessage(""Błąd: Nie zapisano pliku."")
                return
        language = self._get_language_from_path(file_path)
        working_dir = os.path.dirname(file_path) or self.current_project_dir or os.getcwd()
        command = None
        if language == ""python"":
            python_path = self.settings.get(""python_path"", ""python"")
            if not python_path:
                self.console_widget.console.appendPlainText(""Błąd uruchamiania! Zainstaluj dodatek Python poprzez Menadżer Pakietów"")
                self.statusBar().showMessage(""Błąd: Brak interpretera Python."")
                return
            command = f'""{python_path}"" ""{file_path}""'
        elif language == ""javascript"":
            node_path = self.settings.get(""node_path"", ""node"")
            command = f'""{node_path}"" ""{file_path}""'
        elif language in [""c"", ""cpp""]:
            output_exe = os.path.splitext(file_path)[0] + ("".exe"" if platform.system() == ""Windows"" else """")
            compile_command = f'g++ ""{file_path}"" -o ""{output_exe}""'
            self.console_widget.console.appendPlainText(f""Kompilowanie: {compile_command}"")
            self.console_manager.run_command(compile_command, working_dir)
            # Czekaj na zakończenie kompilacji (może wymagać osobnego procesu)
            # Zakładam, że proces jest synchroniczny dla uproszczenia
            # Jeśli kompilacja się udała, uruchom program
            self.console_manager.run_command(f'""{output_exe}""', working_dir)
            return
        else:
            self.console_widget.console.appendPlainText(f""Uruchamianie nieobsługiwane dla języka: {language}"")
            self.statusBar().showMessage(f""Błąd: Nie można uruchomić pliku {os.path.basename(file_path)}."")
            return
        if command:
            self.console_widget.console.appendPlainText(f""Uruchamianie: {command}"")
            self.console_manager.run_command(command, working_dir, self.settings.get(""python_path"", """"), self.settings.get(""node_path"", """"))
            self.statusBar().showMessage(f""Uruchamianie: {os.path.basename(file_path)}"")

    def _get_language_from_path(self, file_path):
        return get_file_language(file_path)

    def _apply_theme(self, theme_name):
        apply_theme(self, theme_name)
        self.settings[""theme""] = theme_name
        self._save_app_state()
        self.statusBar().showMessage(f""Zastosowano motyw: {theme_name}"")

    def _apply_editor_font_size(self):
        font_size = self.settings.get(""editor_font_size"", 10)
        self.base_editor_font.setPointSize(font_size)
        for editor in self.open_files.values():
            editor.setFont(self.base_editor_font)

    def _show_settings_dialog(self):
        dialog = SettingsDialog(self.settings, self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            new_settings = dialog.get_settings()
            self.settings.update(new_settings)
            self._apply_theme(self.settings[""theme""])
            self._apply_editor_font_size()
            self.ai_chat_manager.update_settings(self.settings)
            self._save_app_state()
            self.statusBar().showMessage(""Zapisano ustawienia."")

    def _show_package_manager(self):
        if not self.current_project_dir:
            QMessageBox.warning(self, ""Brak projektu"", ""Otwórz lub utwórz projekt, aby zarządzać pakietami."")
            return
        dialog = PackageManagerDialog(self.current_project_dir, self)
        dialog.exec()
        # Po zamknięciu menadżera pakietów wczytaj ponownie ustawienia z pliku settings.json
        try:
            if os.path.exists(SETTINGS_FILE):
                with open(SETTINGS_FILE, 'r', encoding='utf-8') as f:
                    loaded_settings = json.load(f)
                    # Automatyczne wyszukiwanie python.exe jeśli nie ma ścieżki lub jest pusta
                    python_path = loaded_settings.get(""python_path"", """")
                    if not python_path:
                        import glob
                        python_candidates = glob.glob(os.path.join(ROOT_DIR, ""packages"", ""python"", ""**"", ""python.exe""), recursive=True)
                        if python_candidates:
                            python_path = python_candidates[0]
                            loaded_settings[""python_path""] = python_path
                            # Zapisz poprawioną ścieżkę do settings.json
                            with open(SETTINGS_FILE, 'w', encoding='utf-8') as fw:
                                json.dump(loaded_settings, fw, indent=4)
                    self.settings.update({
                        ""python_path"": python_path or self.settings.get(""python_path"", """"),
                        ""node_path"": loaded_settings.get(""node_path"", self.settings.get(""node_path"", """")),
                        ""theme"": loaded_settings.get(""theme"", self.settings.get(""theme"", ""light"")),
                        ""editor_font_size"": loaded_settings.get(""editor_font_size"", self.settings.get(""editor_font_size"", 10)),
                        ""show_tree"": loaded_settings.get(""show_tree"", self.settings.get(""show_tree"", True)),
                        ""show_console"": loaded_settings.get(""show_console"", self.settings.get(""show_console"", True)),
                        ""api_key"": loaded_settings.get(""api_key"", self.settings.get(""api_key"", """")),
                        ""gemini_api_key"": loaded_settings.get(""gemini_api_key"", self.settings.get(""gemini_api_key"", """")),
                        ""mistral_api_key"": loaded_settings.get(""mistral_api_key"", self.settings.get(""mistral_api_key"", """")),
                        ""ai_model"": loaded_settings.get(""ai_model"", self.settings.get(""ai_model"", ""grok-3"")),
                        ""ai_provider"": loaded_settings.get(""ai_provider"", self.settings.get(""ai_provider"", ""grok"")),
                    })
            self._apply_theme(self.settings.get(""theme"", ""light""))
            self._apply_editor_font_size()
        except Exception as e:
            print(f""Błąd podczas ponownego wczytywania ustawień po menadżerze pakietów: {e}"", file=sys.stderr)

    def _show_about_dialog(self):
        QMessageBox.about(
            self,
            ""O programie"",
            ""Proste IDE\nWersja 1.0\nStworzone dla zajebistych kodersów, którzy nie lubią komplikacji.\n© 2025 Paffcio & xAI""
        )

    def _check_package_json(self, project_dir):
        self.node_scripts.clear()
        package_json_path = os.path.join(project_dir, ""package.json"")
        if os.path.exists(package_json_path):
            package_data = load_package_json(package_json_path)
            scripts = package_data.get(""scripts"", {})
            self.node_scripts.update(scripts)
        self._update_run_button_menu()

    def _update_run_button_menu(self):
        menu = QMenu(self)
        menu.addAction(self.action_run_file)
        if self.node_scripts and self.current_project_dir:
            node_menu = menu.addMenu(""Uruchom skrypt Node.js"")
            node_path = self.settings.get(""node_path"", ""node"")
            for script_name in self.node_scripts:
                action = QAction(script_name, self)
                command = f'""{node_path}"" run {script_name}'
                action.triggered.connect(
                    lambda checked, cmd=command: self.process.start(cmd, working_dir=self.current_project_dir)
                )
                node_menu.addAction(action)
        self.run_toolbutton.setMenu(menu)

    def _handle_tree_item_double_click(self, index):
        if not index.isValid():
            return
        file_path = self.project_model.filePath(index)
        file_info = self.project_model.fileInfo(index)
        if file_info.isFile():
            self._open_file(file_path)

if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = IDEWindow()
    window.show()
    sys.exit(app.exec())

Ścieżka: /src/utils.py
Rozmiar: 1,71 KB
Zawartość:
import os
import json
import re
import sys


def load_package_json(folder_path):
    """"""Parsuje package.json i zwraca skrypty npm.""""""
    if not folder_path or not os.path.isdir(folder_path):
        return {}
    package_json_path = os.path.join(folder_path, 'package.json')
    scripts = {}
    if os.path.exists(package_json_path):
        try:
            with open(package_json_path, 'r', encoding='utf-8') as f:
                package_data = json.load(f)
            scripts = package_data.get('scripts', {})
            if not isinstance(scripts, dict):
                scripts = {}
        except (json.JSONDecodeError, Exception) as e:
            print(f""Błąd parsowania package.json: {e}"", file=sys.stderr)
            return {}
    return scripts


def get_file_language(file_path):
    """"""Określa język programowania na podstawie rozszerzenia pliku.""""""
    extension = os.path.splitext(file_path)[1].lower()
    language_map = {
        '.py': 'python',
        '.pyw': 'python',
        '.js': 'javascript',
        '.ts': 'javascript',
        '.html': 'html',
        '.htm': 'html',
        '.css': 'css',
        '.c': 'c',
        '.cpp': 'cpp',
        '.cc': 'cpp',
        '.h': 'cpp',
        '.hpp': 'cpp',
        '.json': 'json',
        '.ini': 'ini',
        '.bat': 'batch',
        '.sh': 'bash',
        '.ps1': 'powershell',
        '.rb': 'ruby',
        '.java': 'java',
        '.go': 'go',
        '.rs': 'rust',
        '.php': 'php',
        '.xml': 'xml',
        '.md': 'markdown',
        '.txt': 'text',
    }
    return language_map.get(extension, 'text')  # Domyślnie 'text' dla nieznanych

__all__ = ['load_package_json', 'get_file_language']


// SKRYPT ZAKOŃCZONY: 18-05-2025 17:13:29
// RAPORT: Przetworzono 12 plików tekstowych, 0 nietekstowych, pominięto 1.
"
Dd5Vjjxy,2025-05-18T09:35:45.284786,powerampache,PHP,Sunday 18th of May 2025 09:35:45 AM CDT,"1.01-80-play (80) - DB: 83
luci.sixsixsix.powerampache2.domain.errors.NullSessionException: Session is NULL
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository.authToken(BaseAmpacheRepository.kt:87)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository$authToken$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at android.os.Handler.handleCallback(Handler.java:959)
	at android.os.Handler.dispatchMessage(Handler.java:100)
	at android.os.Looper.loopOnce(Looper.java:257)
	at android.os.Looper.loop(Looper.java:342)
	at android.app.ActivityThread.main(ActivityThread.java:9579)
	at java.lang.reflect.Method.invoke(Native Method)
	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:619)
	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:929)

scrobble() - generic exception {""detailMessage"":""Session is NULL"",""stackTrace"":[]}"
pyZr5xaW,2025-05-18T16:05:53.963542,powerampache,PHP,Sunday 18th of May 2025 09:05:55 AM CDT,"1.01-80 (80) - DB: 83
retrofit2.HttpException: HTTP 404 { ""exception"" : ""failed to connect to /192.168.88.7 (port 80) from /10.21.14.164 (port 49382) after 15000ms"" }
	at retrofit2.KotlinExtensions$await$2$2.onResponse(KotlinExtensions.kt:53)
	at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:164)
	at okhttp3.internal.connection.RealCall$AsyncCall.run(RealCall.kt:529)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1137)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:637)
	at java.lang.Thread.run(Thread.java:1012)

authorize() - cannot load data HttpException {""code"":404,""message"":""{ \""exception\"" : \""failed to connect to /192.168.88.7 (port 80) from /10.21.14.164 (port 49382) after 15000ms\"" }"",""detailMessage"":""HTTP 404 { \""exception\"" : \""failed to connect to /192.168.88.7 (port 80) from /10.21.14.164 (port 49382) after 15000ms\"" }"",""stackTrace"":[]}"
TPxTdcDT,Melody,Fraeric123,Lua,Sunday 18th of May 2025 08:35:00 AM CDT,"local computer = require(""computer"")

melody = {
  {660, 0.1}, {660, 0.1}, {0, 0.1}, {660, 0.1},
  {0, 0.1}, {510, 0.1}, {660, 0.1}, {0, 0.1},
  {770, 0.1}, {0, 0.3}, {380, 0.1}, {0, 0.3},

  {510, 0.1}, {0, 0.1}, {380, 0.1}, {0, 0.1},
  {320, 0.1}, {0, 0.2}, {440, 0.1}, {0, 0.1},
  {480, 0.1}, {0, 0.1}, {450, 0.1}, {0, 0.1},
  {430, 0.1}, {0, 0.1}, {380, 0.1}, {660, 0.1},
  {760, 0.1}, {860, 0.1}, {0, 0.1},

  {700, 0.1}, {800, 0.1}, {660, 0.1}, {0, 0.1},
  {520, 0.1}, {580, 0.1}, {480, 0.1}, {0, 0.2},

  {510, 0.1}, {0, 0.1}, {380, 0.1}, {0, 0.1},
  {320, 0.1}, {0, 0.2}, {440, 0.1}, {0, 0.1},
  {480, 0.1}, {0, 0.1}, {450, 0.1}, {0, 0.1},
  {430, 0.1}, {0, 0.1}, {380, 0.1}, {660, 0.1},
  {760, 0.1}, {860, 0.1}, {0, 0.1},

  {700, 0.1}, {800, 0.1}, {660, 0.1}, {0, 0.1},
  {520, 0.1}, {580, 0.1}, {480, 0.1}, {0, 0.2}
}


function music()
	for _, note in ipairs(melody) do
		print(note[1], note[2])
	    if note[1] == 0 then os.sleep(note[2]) else computer.beep(note[1], note[2]) end
	end
	music()
end

music()"
EzYx6RGL,Untitled,PaffcioStudio,Lua,Sunday 18th of May 2025 08:25:03 AM CDT,"import os
import sys
import threading
import traceback
import time
import re
import platform
import json
import subprocess
import tempfile
import shutil # Added for recursive directory deletion
from datetime import datetime

# Conditional imports for AI APIs
try:
    import google.generativeai as genai
    HAS_GEMINI = True
except ImportError:
    print(""Warning: google-generativeai not found. Gemini API support disabled."")
    HAS_GEMINI = False
    class MockGeminiModel: # Mock class to prevent errors if genai is missing
        def __init__(self, model_name): self.model_name = model_name
        def start_chat(self, history): return MockChatSession()
    class MockChatSession:
        def send_message(self, message, stream=True):
            class MockChunk: text = ""Mock Gemini Response (API not available)""
            return [MockChunk()]
    genai = type('genai', (object,), {'GenerativeModel': MockGeminiModel, 'configure': lambda *args, **kwargs: None})()

try:
    from mistralai.client import MistralClient
    from mistralai.models.chat_models import ChatMessage
    HAS_MISTRAL = True
except ImportError:
    print(""Warning: mistralai not found. Mistral API support disabled."")
    HAS_MISTRAL = False
    class MockMistralClient: # Mock class to prevent errors if mistralai is missing
        def __init__(self, api_key): pass
        def chat(self, model, messages, stream=True):
            class MockChunk:
                choices = [type('MockChoice', (object,), {'delta': type('MockDelta', (object,), {'content': ""Mock Mistral Response (API not available)""})()})()]
            return [MockChunk()]
    ChatMessage = lambda role, content: {'role': role, 'content': content} # Mock ChatMessage
    MistralClient = MockMistralClient

from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QPushButton, QListWidget, QLineEdit, QLabel, QMessageBox,
    QTextEdit, QScrollArea, QSizePolicy,
    QDialog, QDialogButtonBox, QComboBox, QFileDialog,
    QTabWidget, QSplitter, QTreeView,
    QMenu, QStatusBar, QToolBar, QToolButton, QSystemTrayIcon,
    QSpinBox, QCheckBox, QInputDialog, QAbstractItemView
)

from PyQt6.QtGui import (
    QIcon, QFontMetrics, QFont, QTextOption, QColor,
    QGuiApplication, QClipboard, QPalette, QBrush,
    QTextCursor, QAction, QDesktopServices, QTextCharFormat,
    QSyntaxHighlighter, QTextDocument, QFileSystemModel, QPainter, QTextFormat
)

from PyQt6.QtCore import (
    Qt, QThread, pyqtSignal, QSize, QMutex, QTimer, QObject,
    QRect, QFileInfo, QDir, QStandardPaths, QUrl, QModelIndex
)

from PyQt6.QtPrintSupport import QPrintDialog, QPrinter
# Importy Pygments do kolorowania składni

from pygments import highlight
from pygments.lexers import get_lexer_by_name, guess_lexer, ClassNotFound
from pygments.formatters import HtmlFormatter
from pygments.util import ClassNotFound as PygmentsClassNotFound
# --- Constants ---

SETTINGS_FILE = ""./editor_settings.json""
# List of models the application should attempt to use.
# Structure: (API_TYPE, MODEL_IDENTIFIER, DISPLAY_NAME)
# API_TYPE can be ""gemini"" or ""mistral""
# MODEL_IDENTIFIER is the string used by the respective API library
# DISPLAY_NAME is what's shown to the user
AVAILABLE_MODELS_CONFIG = [
    (""gemini"", ""gemini-1.5-flash-latest"", ""Gemini 1.5 Flash (Latest)""),
    (""gemini"", ""gemini-1.5-pro-latest"", ""Gemini 1.5 Pro (Latest)""),
    (""gemini"", ""gemini-2.0-flash-thinking-exp-1219"", ""Gemini 2.0 Flash (Experimental)""),
    (""gemini"", ""gemini-2.5-flash-preview-04-17"", ""Gemini 2.5 Flash (Preview)""),
    (""mistral"", ""codestral-latest"", ""Codestral (Latest)""),  # Example Codestral model
    (""mistral"", ""mistral-large-latest"", ""Mistral Large (Latest)""),
    (""mistral"", ""mistral-medium"", ""Mistral Medium""),
    (""mistral"", ""mistral-small"", ""Mistral Small""),
    (""mistral"", ""mistral-tiny"", ""Mistral Tiny""),
]


# Determine which models are actually available based on installed libraries
ACTIVE_MODELS_CONFIG = []
for api_type, identifier, name in AVAILABLE_MODELS_CONFIG:
    if api_type == ""gemini"" and HAS_GEMINI:
        ACTIVE_MODELS_CONFIG.append((api_type, identifier, name))
    elif api_type == ""mistral"" and HAS_MISTRAL:
        ACTIVE_MODELS_CONFIG.append((api_type, identifier, name))

if not ACTIVE_MODELS_CONFIG:
    # QMessageBox.critical(None, ""Błąd API"", ""Brak dostępnych API. Proszę zainstalować google-generativeai lub mistralai."")
    print(""Warning: No AI APIs available. AI features will be disabled."")
    # Fallback to a dummy entry if no APIs are available, to prevent crashes
    ACTIVE_MODELS_CONFIG = [(""none"", ""none"", ""Brak dostępnych modeli"")]


DEFAULT_MODEL_CONFIG = ACTIVE_MODELS_CONFIG[0] if ACTIVE_MODELS_CONFIG else (""none"", ""none"", ""Brak"") # Use the first active model as default

RECENT_FILES_MAX = 10
DEFAULT_FONT_SIZE = 12
DEFAULT_THEME = ""dark""
GEMINI_API_KEY_FILE = ""./.api_key"" # Keep original Google key file

# --- Syntax Highlighter Classes ---
# (PythonHighlighter, CSSHighlighter, HTMLHighlighter, JSHighlighter, GMLHighlighter - copied from your code)
# ... (Paste your Syntax Highlighter classes here) ...
class PythonHighlighter(QSyntaxHighlighter):
    def __init__(self, document):
        super().__init__(document)
        self.highlight_rules = []

        keywords = [
            'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del',
            'elif', 'else', 'except', 'False', 'finally', 'for', 'from', 'global',
            'if', 'import', 'in', 'is', 'lambda', 'None', 'nonlocal', 'not', 'or',
            'pass', 'raise', 'return', 'True', 'try', 'while', 'with', 'yield'
        ]
        keyword_format = QTextCharFormat()
        keyword_format.setForeground(QColor(""#569CD6""))  # Blue
        keyword_format.setFontWeight(QFont.Weight.Bold)
        self.highlight_rules.extend([(r'\b%s\b' % kw, keyword_format) for kw in keywords])

        string_format = QTextCharFormat()
        string_format.setForeground(QColor(""#CE9178""))  # Orange
        self.highlight_rules.append((r'""[^""\\]*(\\.[^""\\]*)*""', string_format))
        self.highlight_rules.append((r""'[^'\\]*(\\.[^'\\]*)*'"", string_format))

        function_format = QTextCharFormat()
        function_format.setForeground(QColor(""#DCDCAA""))  # Light yellow
        self.highlight_rules.append((r'\b[A-Za-z_][A-Za-z0-9_]*\s*(?=\()', function_format))

        number_format = QTextCharFormat()
        number_format.setForeground(QColor(""#B5CEA8""))  # Green
        self.highlight_rules.append((r'\b[0-9]+\b', number_format))

        comment_format = QTextCharFormat()
        comment_format.setForeground(QColor(""#6A9955""))  # Green
        comment_format.setFontItalic(True)
        self.highlight_rules.append((r'#[^\n]*', comment_format))

    def highlightBlock(self, text):
        for pattern, format in self.highlight_rules:
            expression = re.compile(pattern)
            matches = expression.finditer(text)
            for match in matches:
                start = match.start()
                length = match.end() - start
                self.setFormat(start, length, format)

class CSSHighlighter(QSyntaxHighlighter):
    def __init__(self, document):
        super().__init__(document)
        self.highlight_rules = []

        keywords = ['color', 'font', 'margin', 'padding', 'display', 'position', 'transition']
        keyword_format = QTextCharFormat()
        keyword_format.setForeground(QColor(""#ff6ac1""))  # Pinkish
        keyword_format.setFontWeight(QFont.Weight.Bold)
        self.highlight_rules.extend([(r'\b%s\b' % kw, keyword_format) for kw in keywords])

        value_format = QTextCharFormat()
        value_format.setForeground(QColor(""#ce9178""))  # Orange
        self.highlight_rules.append((r'#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})', value_format))
        self.highlight_rules.append((r'rgb[a]?\([^)]+\)', value_format))

        selector_format = QTextCharFormat()
        selector_format.setForeground(QColor(""#dcdcAA""))  # Light yellow
        self.highlight_rules.append((r'^\s*[^{]+(?={)', selector_format))

        comment_format = QTextCharFormat()
        comment_format.setForeground(QColor(""#6A9955""))  # Green
        comment_format.setFontItalic(True)
        self.highlight_rules.append((r'/\*.*?\*/', comment_format), re.DOTALL)

    def highlightBlock(self, text):
        for pattern, format in self.highlight_rules:
            expression = re.compile(pattern)
            for match in expression.finditer(text):
                start = match.start()
                length = match.end() - start
                self.setFormat(start, length, format)

class HTMLHighlighter(QSyntaxHighlighter):
    def __init__(self, document):
        super().__init__(document)
        self.highlight_rules = []

        tag_format = QTextCharFormat()
        tag_format.setForeground(QColor(""#569CD6""))  # Blue
        self.highlight_rules.append((r'</?[\w-]+>', tag_format))

        attr_format = QTextCharFormat()
        attr_format.setForeground(QColor(""#9cdcfe""))  # Light blue
        self.highlight_rules.append((r'[\w-]+(?=\s*=)', attr_format))

        value_format = QTextCharFormat()
        value_format.setForeground(QColor(""#ce9178""))  # Orange
        self.highlight_rules.append((r'=""[^""]*""', value_format))

        comment_format = QTextCharFormat()
        comment_format.setForeground(QColor(""#6A9955""))  # Green
        comment_format.setFontItalic(True)
        self.highlight_rules.append((r'<!--[\s\S]*?-->', comment_format))

    def highlightBlock(self, text):
        for pattern, format in self.highlight_rules:
            expression = re.compile(pattern)
            for match in expression.finditer(text):
                start = match.start()
                length = match.end() - start
                self.setFormat(start, length, format)

class JSHighlighter(QSyntaxHighlighter):
    def __init__(self, document):
        super().__init__(document)
        self.highlight_rules = []

        keywords = ['var', 'let', 'const', 'function', 'if', 'else', 'return', 'for', 'while']
        keyword_format = QTextCharFormat()
        keyword_format.setForeground(QColor(""#c586c0""))  # Purple
        keyword_format.setFontWeight(QFont.Weight.Bold)
        self.highlight_rules.extend([(r'\b%s\b' % kw, keyword_format) for kw in keywords])

        string_format = QTextCharFormat()
        string_format.setForeground(QColor(""#ce9178""))  # Orange
        self.highlight_rules.append((r'""[^""\\]*(\\.[^""\\]*)*""', string_format))
        self.highlight_rules.append((r""'[^'\\]*(\\.[^'\\]*)*'"", string_format))

        function_format = QTextCharFormat()
        function_format.setForeground(QColor(""#dcdcaa""))  # Light yellow
        self.highlight_rules.append((r'\b[A-Za-z_][A-Za-z0-9_]*\s*(?=\()', function_format))

        comment_format = QTextCharFormat()
        comment_format.setForeground(QColor(""#6A9955""))  # Green
        comment_format.setFontItalic(True)
        self.highlight_rules.append((r'//[^\n]*', comment_format))
        self.highlight_rules.append((r'/\*[\s\S]*?\*/', comment_format), re.DOTALL)

    def highlightBlock(self, text):
        for pattern, format in self.highlight_rules:
            expression = re.compile(pattern)
            for match in expression.finditer(text):
                start = match.start()
                length = match.end() - start
                self.setFormat(start, length, format)

class GMLHighlighter(QSyntaxHighlighter):
    def __init__(self, document):
        super().__init__(document)
        self.highlight_rules = []

        keywords = ['if', 'else', 'switch', 'case', 'break', 'return', 'var', 'with', 'while']
        keyword_format = QTextCharFormat()
        keyword_format.setForeground(QColor(""#c586c0""))  # Purple
        keyword_format.setFontWeight(QFont.Weight.Bold)
        self.highlight_rules.extend([(r'\b%s\b' % kw, keyword_format) for kw in keywords])

        var_format = QTextCharFormat()
        var_format.setForeground(QColor(""#4ec9b0""))  # Teal
        self.highlight_rules.append((r'_[a-zA-Z][a-zA-Z0-9]*', var_format))

        func_format = QTextCharFormat()
        func_format.setForeground(QColor(""#dcdcaa""))  # Light yellow
        gml_funcs = ['instance_create', 'ds_list_add', 'draw_text']
        self.highlight_rules.extend([(r'\b%s\b(?=\()', func_format) for func in gml_funcs])

        string_format = QTextCharFormat()
        string_format.setForeground(QColor(""#ce9178""))  # Orange
        self.highlight_rules.append((r'""[^""\\]*(\\.[^""\\]*)*""', string_format))

        comment_format = QTextCharFormat()
        comment_format.setForeground(QColor(""#6A9955""))  # Green
        comment_format.setFontItalic(True)
        self.highlight_rules.append((r'//[^\n]*', comment_format))
        self.highlight_rules.append((r'/\*[\s\S]*?\*/', comment_format), re.DOTALL)


    def highlightBlock(self, text):
        for pattern, format in self.highlight_rules:
            expression = re.compile(pattern)
            for match in expression.finditer(text):
                start = match.start()
                length = match.end() - start
                self.setFormat(start, length, format)
# --- End of Syntax Highlighter Classes ---

# --- API Key Loading ---

def load_gemini_api_key(filepath=GEMINI_API_KEY_FILE):
    """"""Reads Gemini API key from a file.""""""
    if not os.path.exists(filepath):
        # Don't show critical error if file is just missing, allow user to configure in settings
        print(f""Gemini API key file not found: {filepath}. Please add key in settings."")
        return None
    try:
        with open(filepath, ""r"") as f:
            key = f.read().strip()
            if not key:
                print(f""Gemini API key file is empty: {filepath}. Please add key in settings."")
                return None
            return key
    except Exception as e:
        print(f""Error reading Gemini API key file: {filepath}\nError: {e}"")
        # QMessageBox.warning(None, ""Błąd odczytu klucza API"", f""Nie można odczytać pliku klucza API Google Gemini: {filepath}\nBłąd: {e}"")
        return None

# Load Gemini key initially, but allow overriding/setting in settings
GEMINI_API_KEY_GLOBAL = load_gemini_api_key()

# --- Configure APIs (Initial) ---
# This configuration should happen *after* loading settings in the main window,
# where the Mistral key from settings is also available.
# The current global configuration is okay for checking HAS_GEMINI but actual
# worker instances need potentially updated keys from settings.

# --- Settings Persistence ---

def load_settings():
    """"""Loads settings from a JSON file.""""""
    # Determine default model based on active APIs
    default_model_config = ACTIVE_MODELS_CONFIG[0] if ACTIVE_MODELS_CONFIG else (""none"", ""none"", ""Brak"")
    default_api_type = default_model_config[0]
    default_model_identifier = default_model_config[1]

    default_settings = {
        ""api_type"": default_api_type, # New field to store active API type
        ""model_identifier"": default_model_identifier, # New field to store model identifier
        ""mistral_api_key"": None, # New field for Mistral key
        ""recent_files"": [],
        ""font_size"": DEFAULT_FONT_SIZE,
        ""theme"": DEFAULT_THEME,
        ""workspace"": """",
        ""show_sidebar"": True,
        ""show_statusbar"": True,
        ""show_toolbar"": True
    }

    try:
        if os.path.exists(SETTINGS_FILE):
            with open(SETTINGS_FILE, 'r') as f:
                settings = json.load(f)
                # Handle potential old format or missing new fields
                if ""api_type"" not in settings or ""model_identifier"" not in settings:
                    # Attempt to migrate from old ""model_name"" if it exists
                    old_model_name = settings.get(""model_name"", """")
                    found_match = False
                    for api_type, identifier, name in ACTIVE_MODELS_CONFIG:
                        if identifier == old_model_name or name == old_model_name: # Check both identifier and display name from old settings
                             settings[""api_type""] = api_type
                             settings[""model_identifier""] = identifier
                             found_match = True
                             break
                    if not found_match:
                        # Fallback to default if old name not found or no old name
                        settings[""api_type""] = default_api_type
                        settings[""model_identifier""] = default_model_identifier
                    if ""model_name"" in settings:
                         del settings[""model_name""] # Remove old field

                # Add defaults for any other missing keys (including new mistral_api_key)
                for key in default_settings:
                    if key not in settings:
                        settings[key] = default_settings[key]

                # Validate loaded model against active configurations
                is_active = any(s[0] == settings.get(""api_type"") and s[1] == settings.get(""model_identifier"") for s in ACTIVE_MODELS_CONFIG)
                if not is_active:
                     print(f""Warning: Loaded model config ({settings.get('api_type')}, {settings.get('model_identifier')}) is not active. Falling back to default."")
                     settings[""api_type""] = default_api_type
                     settings[""model_identifier""] = default_model_identifier


                return settings
        return default_settings
    except Exception as e:
        print(f""Błąd ładowania ustawień: {e}. Używam ustawień domyślnych."")
        return default_settings

def save_settings(settings: dict):
    """"""Saves settings to a JSON file.""""""
    try:
        with open(SETTINGS_FILE, 'w') as f:
            json.dump(settings, f, indent=4)
    except Exception as e:
        print(f""Błąd zapisywania ustawień: {e}"")

# --- API Formatting Helper ---
def format_chat_history(messages: list, api_type: str) -> list:
    """"""Formats chat history for different API types.""""""
    formatted_history = []
    for role, content, metadata in messages:
        # Skip assistant placeholder messages and internal error/empty messages
        if not (role == ""assistant"" and metadata is not None and metadata.get(""type"") in [""placeholder"", ""error"", ""empty_response""]):
            if api_type == ""gemini"":
                 # Gemini uses ""user"" and ""model"" roles
                 formatted_history.append({
                     ""role"": ""user"" if role == ""user"" else ""model"",
                     ""parts"": [content] # Gemini uses 'parts' with content
                 })
            elif api_type == ""mistral"":
                 # Mistral uses ""user"" and ""assistant"" roles
                 formatted_history.append(ChatMessage(role='user' if role == 'user' else 'assistant', content=content))
            # Add other API types here if needed
    return formatted_history

# --- API Worker Threads ---

class GeminiWorker(QThread):
    response_chunk = pyqtSignal(str)
    response_complete = pyqtSignal()
    error = pyqtSignal(str)

    def __init__(self, api_key: str, user_message: str, chat_history: list, model_identifier: str, parent=None):
        super().__init__(parent)
        self.api_key = api_key
        self.user_message = user_message
        self.chat_history = chat_history # Raw history from main window
        self.model_identifier = model_identifier
        self._is_running = True
        self._mutex = QMutex()
        print(f""GeminiWorker created for model: {model_identifier}"")


    def stop(self):
        self._mutex.lock()
        try:
            self._is_running = False
        finally:
            self._mutex.unlock()

    def run(self):
        if not self.api_key:
            self.error.emit(""Klucz API Google Gemini nie został skonfigurowany."")
            return
        if not self.user_message.strip():
            self.error.emit(""Proszę podać niepustą wiadomość tekstową."")
            return

        try:
            # Format history for Gemini API
            api_history = format_chat_history(self.chat_history, ""gemini"")

            try:
                 # Attempt to get the model instance
                 genai.configure(api_key=self.api_key) # Ensure API key is used in this thread
                 model_instance = genai.GenerativeModel(self.model_identifier)

                 # Start chat with history
                 chat = model_instance.start_chat(history=api_history)

                 # Send message and get stream
                 response_stream = chat.send_message(self.user_message, stream=True)

            except Exception as api_err:
                error_str = str(api_err)
                if ""BlockedPromptException"" in error_str or (""FinishReason"" in error_str and ""SAFETY"" in error_str):
                     self.error.emit(f""Odpowiedź zablokowana przez filtry bezpieczeństwa."")
                elif ""Candidate.content is empty"" in error_str:
                     self.error.emit(f""Otrzymano pustą treść z API (możliwe, że zablokowana lub niepowodzenie)."")
                elif ""returned an invalid response"" in error_str or ""Could not find model"" in error_str or ""Invalid model name"" in error_str:
                     self.error.emit(f""API Gemini zwróciło nieprawidłową odpowiedź lub model '{self.model_identifier}' nie znaleziono. Proszę sprawdzić ustawienia modelu i klucz API.\nSzczegóły: {api_err}"")
                elif ""AUTHENTICATION_ERROR"" in error_str or ""Invalid API key"" in error_str:
                     self.error.emit(f""Błąd autoryzacji API Gemini. Proszę sprawdzić klucz API w ustawieniach."")
                else:
                    error_details = f""{type(api_err).__name__}: {api_err}""
                    if hasattr(api_err, 'status_code'):
                         error_details += f"" (Status: {api_err.status_code})""
                    self.error.emit(f""Wywołanie API Gemini nie powiodło się:\n{error_details}"")
                return

            try:
                full_response_text = """"
                # Process the response stream chunk by chunk
                for chunk in response_stream:
                    self._mutex.lock()
                    is_running = self._is_running
                    self._mutex.unlock()

                    if not is_running:
                        break

                    if not chunk.candidates:
                         continue

                    try:
                        # Concatenate text parts from the chunk
                        # Safely access candidates and content
                        text_parts = [part.text for candidate in chunk.candidates for part in candidate.content.parts if part.text]
                        current_chunk = """".join(text_parts)
                    except (AttributeError, IndexError) as e:
                         print(f""Warning: Could not access chunk text: {e}"")
                         current_chunk = """" # Handle cases where structure isn't as expected

                    if current_chunk:
                        full_response_text += current_chunk
                        self.response_chunk.emit(current_chunk)

                self._mutex.lock()
                stopped_manually = not self._is_running
                self._mutex.unlock()

                if not stopped_manually:
                    self.response_complete.emit()

            except Exception as stream_err:
                 self._mutex.lock()
                 was_stopped = not self._is_running
                 self._mutex.unlock()

                 if not was_stopped:
                     error_details = f""{type(stream_err).__name__}: {stream_err}""
                     self.error.emit(f""Błąd podczas strumieniowania odpowiedzi z API Gemini:\n{error_details}"")

        except Exception as e:
            error_details = f""{type(e).__name__}: {e}""
            self.error.emit(f""Wystąpił nieoczekiwany błąd w wątku roboczym Gemini:\n{error_details}\n{traceback.format_exc()}"")


class MistralWorker(QThread):
    response_chunk = pyqtSignal(str)
    response_complete = pyqtSignal()
    error = pyqtSignal(str)

    def __init__(self, api_key: str, user_message: str, chat_history: list, model_identifier: str, parent=None):
        super().__init__(parent)
        self.api_key = api_key
        self.user_message = user_message
        self.chat_history = chat_history # Raw history from main window
        self.model_identifier = model_identifier
        self._is_running = True
        self._mutex = QMutex()
        print(f""MistralWorker created for model: {model_identifier}"")

    def stop(self):
        self._mutex.lock()
        try:
            self._is_running = False
        finally:
            self._mutex.unlock()

    def run(self):
        if not self.api_key:
            self.error.emit(""Klucz API Mistral nie został skonfigurowany w ustawieniach."")
            return
        if not self.user_message.strip():
            self.error.emit(""Proszę podać niepustą wiadomość tekstową."")
            return

        try:
            # Format history for Mistral API
            # Mistral API expects a list of ChatMessage objects or dicts {'role': '...', 'content': '...'}
            # The last message is the current user message, others are history
            api_messages = format_chat_history(self.chat_history, ""mistral"")
            api_messages.append(ChatMessage(role='user', content=self.user_message))


            try:
                 client = MistralClient(api_key=self.api_key)

                 response_stream = client.chat(
                     model=self.model_identifier,
                     messages=api_messages,
                     stream=True
                 )

            except Exception as api_err:
                error_str = str(api_err)
                # Add more specific error handling for Mistral API if needed
                if ""authentication_error"" in error_str.lower():
                     self.error.emit(f""Błąd autoryzacji API Mistral. Proszę sprawdzić klucz API w ustawieniach."")
                elif ""model_not_found"" in error_str.lower():
                     self.error.emit(f""Model Mistral '{self.model_identifier}' nie znaleziono lub jest niedostępny dla tego klucza API."")
                else:
                    error_details = f""{type(api_err).__name__}: {api_err}""
                    self.error.emit(f""Wywołanie API Mistral nie powiodło się:\n{error_details}"")
                return


            try:
                full_response_text = """"
                # Process the response stream chunk by chunk
                for chunk in response_stream:
                    self._mutex.lock()
                    is_running = self._is_running
                    self._mutex.unlock()

                    if not is_running:
                        break

                    # Mistral stream chunk structure: chunk.choices[0].delta.content
                    current_chunk = """"
                    if chunk.choices and chunk.choices[0].delta and chunk.choices[0].delta.content:
                        current_chunk = chunk.choices[0].delta.content

                    if current_chunk:
                        full_response_text += current_chunk
                        self.response_chunk.emit(current_chunk)

                self._mutex.lock()
                stopped_manually = not self._is_running
                self._mutex.unlock()

                if not stopped_manually:
                    self.response_complete.emit()

            except Exception as stream_err:
                 self._mutex.lock()
                 was_stopped = not self._is_running
                 self._mutex.unlock()

                 if not was_stopped:
                     error_details = f""{type(stream_err).__name__}: {stream_err}""
                     self.error.emit(f""Błąd podczas strumieniowania odpowiedzi z API Mistral:\n{error_details}"")

        except Exception as e:
            error_details = f""{type(e).__name__}: {e}""
            self.error.emit(f""Wystąpił nieoczekiwany błąd w wątku roboczym Mistral:\n{error_details}\n{traceback.format_exc()}"")


# --- Pygments Helper for Syntax Highlighting ---
# (highlight_code_html and related CSS - copied from your code)
# ... (Paste your Pygments helper functions and CSS here) ...
PYGMENTS_STYLE_NAME = 'dracula'
try:
    PYGMENTS_CSS = HtmlFormatter(style=PYGMENTS_STYLE_NAME, full=False, cssclass='highlight').get_style_defs('.highlight')
except ClassNotFound:
    print(f""Ostrzeżenie: Styl Pygments '{PYGMENTS_STYLE_NAME}' nie znaleziono. Używam 'default'."")
    PYGMENTS_STYLE_NAME = 'default'
    PYGMENTS_CSS = HtmlFormatter(style=PYGMENTS_STYLE_NAME, full=False, cssclass='highlight').get_style_defs('.highlight')

CUSTOM_CODE_CSS = f""""""
.highlight {{
    padding: 0 !important;
    margin: 0 !important;
}}
.highlight pre {{
    margin: 0 !important;
    padding: 0 !important;
    border: none !important;
    white-space: pre-wrap;
    word-wrap: break-word;
}}
""""""
FINAL_CODE_CSS = PYGMENTS_CSS + CUSTOM_CODE_CSS

def highlight_code_html(code, language=''):
    try:
        if language:
            lexer = get_lexer_by_name(language, stripall=True)
        else:
            lexer = guess_lexer(code)
        if lexer.name == 'text':
            raise PygmentsClassNotFound # Don't use 'text' lexer
    except (PygmentsClassNotFound, ValueError):
        try:
            # Fallback to a generic lexer or plain text
            lexer = get_lexer_by_name('text', stripall=True)
        except PygmentsClassNotFound:
             # This fallback should theoretically always work, but as a safeguard:
             return f""<pre><code>{code}</code></pre>""


    formatter = HtmlFormatter(style=PYGMENTS_STYLE_NAME, full=False, cssclass='highlight')
    return highlight(code, lexer, formatter)

# --- Custom Widgets for Chat Messages ---
# (CodeDisplayTextEdit, MessageWidget - copied from your code)
# ... (Paste your CodeDisplayTextEdit and MessageWidget classes here) ...
class CodeDisplayTextEdit(QTextEdit):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setReadOnly(True)
        self.setAcceptRichText(True)
        self.setWordWrapMode(QTextOption.WrapMode.NoWrap) # Code blocks shouldn't wrap standardly
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
        self.setMinimumHeight(QFontMetrics(self.font()).lineSpacing() * 3 + 16)
        self.setFrameStyle(QTextEdit.Shape.Box | QTextEdit.Shadow.Plain)
        self.document().setDocumentMargin(0)
        self.setContentsMargins(0,0,0,0)

        self.setStyleSheet(f""""""
            QTextEdit {{
                background-color: #2d2d2d; /* Dark background for code */
                color: #ffffff; /* White text */
                border: 1px solid #4a4a4a;
                border-radius: 5px;
                padding: 8px;
                font-family: ""Consolas"", ""Courier New"", monospace;
                font-size: 9pt; /* Smaller font for code blocks */
            }}
            {FINAL_CODE_CSS} /* Pygments CSS for syntax highlighting */
        """""")

    def setHtml(self, html: str):
        super().setHtml(html)
        self.document().adjustSize()
        doc_height = self.document().size().height()
        buffer = 5
        self.setFixedHeight(int(doc_height) + buffer)

class MessageWidget(QWidget):
    def __init__(self, role: str, content: str, metadata: dict = None, parent=None):
        super().__init__(parent)
        self.role = role
        self.content = content
        self.metadata = metadata
        self.is_placeholder = (role == ""assistant"" and metadata is not None and metadata.get(""type"") == ""placeholder"")
        self.segments = []

        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(0, 5, 0, 5)
        self.layout.setSpacing(3)

        bubble_widget = QWidget()
        self.content_layout = QVBoxLayout(bubble_widget)
        self.content_layout.setContentsMargins(12, 8, 12, 8)
        self.content_layout.setSpacing(6)

        user_color = ""#dcf8c6""
        assistant_color = ""#e0e0e0""

        bubble_style = f""""""
            QWidget {{
                background-color: {'{user_color}' if role == 'user' else '{assistant_color}'};
                border-radius: 15px;
                padding: 0px;
                border: 1px solid #e0e0e0;
            }}
        """"""
        if self.is_placeholder:
            bubble_style = """"""
                QWidget {
                    background-color: #f0f0f0;
                    border-radius: 15px;
                    padding: 0px;
                    border: 1px dashed #cccccc;
                }
            """"""
        bubble_widget.setStyleSheet(bubble_style)
        bubble_widget.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Minimum)

        outer_layout = QHBoxLayout()
        outer_layout.setContentsMargins(0, 0, 0, 0)
        outer_layout.setSpacing(0)

        screen_geometry = QGuiApplication.primaryScreen().availableGeometry()
        max_bubble_width = int(screen_geometry.width() * 0.75)
        bubble_widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Minimum)
        bubble_widget.setMinimumWidth(1)

        spacer_left = QWidget()
        spacer_right = QWidget()
        spacer_left.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
        spacer_right.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)

        if role == 'user':
            outer_layout.addWidget(spacer_left)
            outer_layout.addWidget(bubble_widget, 1)
            outer_layout.addWidget(spacer_right, 0)
        else:
            outer_layout.addWidget(spacer_left, 0)
            outer_layout.addWidget(bubble_widget, 1)
            outer_layout.addWidget(spacer_right)

        self.layout.addLayout(outer_layout)

        if self.is_placeholder:
            placeholder_label = QLabel(content)
            placeholder_label.setStyleSheet(""QLabel { color: #505050; font-style: italic; padding: 10px; }"")
            placeholder_label.setWordWrap(True)
            placeholder_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self.content_layout.addWidget(placeholder_label)
            self.placeholder_label = placeholder_label
            placeholder_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
            placeholder_label.setMinimumWidth(1)
        else:
            self.display_content(content, self.content_layout)

        self.content_layout.addStretch(1)

    def display_content(self, content, layout):
        block_pattern = re.compile(r'(^|\n)(`{3,})(\w*)\n(.*?)\n\2(?:\n|$)', re.DOTALL)
        last_end = 0

        for match in block_pattern.finditer(content):
            text_before = content[last_end:match.start()].strip()
            if text_before:
                self.add_text_segment(text_before, layout)

            code = match.group(4)
            language = match.group(3).strip()

            code_area = CodeDisplayTextEdit()
            highlighted_html = highlight_code_html(code, language)
            code_area.setHtml(highlighted_html)
            layout.addWidget(code_area)
            self.segments.append(code_area)

            copy_button = QPushButton(""Kopiuj kod"")
            copy_button.setIcon(QIcon.fromTheme(""edit-copy"", QIcon("":/icons/copy.png"")))
            copy_button.setFixedSize(100, 25)
            copy_button.setStyleSheet(""""""
                QPushButton {
                    background-color: #3c3c3c;
                    color: #ffffff;
                    border: 1px solid #5a5a5a;
                    border-radius: 4px;
                    padding: 2px 8px;
                    font-size: 9pt;
                }
                QPushButton:hover {
                    background-color: #4a4a4a;
                    border-color: #6a6a6a;
                }
                QPushButton:pressed {
                    background-color: #2a2a2a;
                    border-color: #5a5a5a;
                }
            """""")

            clipboard = QApplication.clipboard()
            if clipboard:
                copy_button.clicked.connect(lambda checked=False, code_widget=code_area: self.copy_code_to_clipboard(code_widget))
            else:
                copy_button.setEnabled(False)

            btn_layout = QHBoxLayout()
            btn_layout.addStretch()
            btn_layout.addWidget(copy_button)
            btn_layout.setContentsMargins(0, 0, 0, 0)
            btn_layout.setSpacing(0)
            layout.addLayout(btn_layout)

            last_end = match.end()

        remaining_text = content[last_end:].strip()
        if remaining_text:
            self.add_text_segment(remaining_text, layout)

    def add_text_segment(self, text: str, layout: QVBoxLayout):
        if not text:
            return

        text_edit = QTextEdit()
        text_edit.setReadOnly(True)
        text_edit.setFrameStyle(QTextEdit.Shape.NoFrame)
        text_edit.setContentsMargins(0, 0, 0, 0)
        text_edit.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        text_edit.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        text_edit.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
        text_edit.setWordWrapMode(QTextOption.WrapMode.WrapAtWordBoundaryOrAnywhere)
        text_edit.setAcceptRichText(True)

        text_edit.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        text_edit.customContextMenuRequested.connect(lambda pos, te=text_edit: self.show_context_menu(pos, te))

        text_edit.setStyleSheet(f""""""
            QTextEdit {{
                background-color: transparent;
                border: none;
                padding: 0;
                font-size: 10pt;
                color: {'#333333' if self.role == 'user' else '#ffffff'};
            }}
        """""")

        html_text = text.replace('&', '&').replace('<', '<').replace('>', '>')
        html_text = re.sub(r'\*\*(.*?)\*\*', r'<b>\1</b>', html_text)
        inline_code_style = ""font-family: Consolas, 'Courier New', monospace; background-color: #f0f0f0; padding: 1px 3px; border-radius: 3px; font-size: 9pt;""
        html_text = re.sub(r'`([^`]+)`', rf'<span style=""{inline_code_style}"">\1</span>', html_text)
        html_text = html_text.replace('\n', '<br>')

        text_edit.setHtml(html_text)
        self.segments.append(text_edit)

        text_edit.document().adjustSize()
        doc_size = text_edit.document().size()
        buffer = 5
        text_edit.setFixedHeight(int(doc_size.height()) + buffer)

        layout.addWidget(text_edit)

    def show_context_menu(self, position, text_edit):
        menu = QMenu(text_edit)

        copy_action = menu.addAction(""Kopiuj"")
        copy_action.setIcon(QIcon.fromTheme(""edit-copy""))
        copy_action.triggered.connect(text_edit.copy)

        menu.addSeparator()

        select_all_action = menu.addAction(""Zaznacz wszystko"")
        select_all_action.setIcon(QIcon.fromTheme(""edit-select-all""))
        select_all_action.setShortcut(""Ctrl+A"")
        select_all_action.triggered.connect(text_edit.selectAll)

        menu.exec(text_edit.viewport().mapToGlobal(position))

    def copy_code_to_clipboard(self, code_widget: CodeDisplayTextEdit):
        clipboard = QApplication.clipboard()
        if clipboard:
            code_text = code_widget.toPlainText()
            clipboard.setText(code_text)

            sender_button = self.sender()
            if sender_button:
                original_text = sender_button.text()
                sender_button.setText(""Skopiowano!"")
                QTimer.singleShot(1500, lambda: sender_button.setText(original_text))

    def update_placeholder_text(self, text):
        if self.is_placeholder and hasattr(self, 'placeholder_label'):
            display_text = text.strip()
            if len(display_text) > 200:
                display_text = ""..."" + display_text[-200:]
            display_text = ""⚙️ Przetwarzam... "" + display_text
            self.placeholder_label.setText(display_text)

    def apply_theme_colors(self, background: QColor, foreground: QColor, bubble_user: QColor, bubble_assistant: QColor):
        bubble_widget = self.findChild(QWidget)
        if bubble_widget and not self.is_placeholder:
            bubble_style = f""""""
                QWidget {{
                    background-color: {'{bubble_user.name()}' if self.role == 'user' else '{bubble_assistant.name()}'};
                    border-radius: 15px;
                    padding: 0px;
                    border: 1px solid #e0e0e0;
                }}
            """"""
            bubble_widget.setStyleSheet(bubble_style)
            bubble_widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)

        for segment in self.segments:
            if isinstance(segment, QTextEdit) and not isinstance(segment, CodeDisplayTextEdit):
                segment.setStyleSheet(f""""""
                    QTextEdit {{
                        background-color: transparent;
                        border: none;
                        padding: 0;
                        font-size: 10pt;
                        color: {'{foreground.name()}' if self.role == 'assistant' else '#333333'};
                    }}
                """""")
# --- End of Custom Widgets ---


# --- Code Editor Widget ---
# (CodeEditor - copied and slightly modified for theme colors and line numbers)
# ... (Paste your CodeEditor class here) ...
class CodeEditor(QTextEdit):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFont(QFont(""Consolas"", DEFAULT_FONT_SIZE))
        self.setLineWrapMode(QTextEdit.LineWrapMode.NoWrap)
        self.highlighter = PythonHighlighter(self.document()) # Default highlighter

        self.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.customContextMenuRequested.connect(self.show_context_menu)

        self.line_number_area = QWidget(self)
        self.line_number_area.setFixedWidth(40)
        self.line_number_area.setStyleSheet(""background-color: #252526; color: #858585;"")
        self.update_line_number_area_width()

        self.document().blockCountChanged.connect(self.update_line_number_area_width)
        self.verticalScrollBar().valueChanged.connect(lambda: self.line_number_area.update())
        self.textChanged.connect(lambda: self.line_number_area.update())
        self.cursorPositionChanged.connect(lambda: self.update_line_number_area(self.viewport().rect(), 0))
        self.cursorPositionChanged.connect(self.highlight_current_line)

        self.setTabStopDistance(QFontMetrics(self.font()).horizontalAdvance(' ') * 4)

        self.current_line_format = QTextCharFormat()
        self.current_line_format.setBackground(QColor(""#2d2d2d""))

    def delete(self):
        cursor = self.textCursor()
        if cursor.hasSelection():
            cursor.removeSelectedText()
        else:
            cursor.deleteChar()
        self.setTextCursor(cursor)

    def show_context_menu(self, position):
        # This context menu is now set up by the main window's setup_editor_context_menu
        # which provides more actions. This local one is potentially redundant or simplified.
        # For now, let's keep the main window's setup, and this method could be empty or removed.
        # Or, it could call the main window's method. Let's update the main window setup.
        pass # The main window will handle this connection instead


    def update_line_number_area_width(self):
        digits = len(str(max(1, self.document().blockCount())))
        space = 10 + self.fontMetrics().horizontalAdvance('9') * digits
        self.line_number_area.setFixedWidth(space)
        self.setViewportMargins(self.line_number_area.width(), 0, 0, 0)

    def update_line_number_area(self, rect, dy):
        if dy != 0:
            self.line_number_area.scroll(0, dy)
        else:
            self.line_number_area.update(0, rect.y(), self.line_number_area.width(), rect.height())

        if rect.contains(self.viewport().rect()):
            self.update_line_number_area_width()

    def resizeEvent(self, event):
        super().resizeEvent(event)
        cr = self.contentsRect()
        self.line_number_area.setGeometry(QRect(cr.left(), cr.top(), self.line_number_area.width(), cr.height()))

    def line_number_area_paint_event(self, event):
        painter = QPainter(self.line_number_area)
        if not painter.isActive():
            painter.begin(self.line_number_area)

        bg_color = self.palette().color(QPalette.ColorRole.Base)
        painter.fillRect(event.rect(), bg_color)

        doc = self.document()
        block = doc.begin()
        block_number = 0
        scroll_offset = self.verticalScrollBar().value()

        top = block.layout().boundingRect().top() + scroll_offset
        bottom = top + block.layout().boundingRect().height()

        while block.isValid() and top <= event.rect().bottom():
            if block.isVisible() and bottom >= event.rect().top():
                number = str(block_number + 1)
                # Use line number area's stylesheet color for text
                # Accessing stylesheet color directly is tricky, fallback to palette or fixed color
                # Let's use the foreground color set in set_theme_colors
                painter.setPen(self.line_number_area.palette().color(QPalette.ColorRole.WindowText))


                painter.drawText(0, int(top), self.line_number_area.width() - 5, self.fontMetrics().height(),
                                 Qt.AlignmentFlag.AlignRight, number)

            block = block.next()
            if block.isValid():
                top = bottom
                # Recalculate block height each time
                bottom = top + self.blockBoundingRect(block).height() # Use blockBoundingRect for accurate height
                block_number += 1
            else:
                break

    def highlight_current_line(self):
        extra_selections = []

        if not self.isReadOnly():
            selection = QTextEdit.ExtraSelection()
            selection.format = self.current_line_format
            selection.format.setProperty(QTextFormat.Property.FullWidthSelection, True)
            selection.cursor = self.textCursor()
            selection.cursor.clearSelection()
            extra_selections.append(selection)

        self.setExtraSelections(extra_selections)

    def set_font_size(self, size: int):
        font = self.font()
        font.setPointSize(size)
        self.setFont(font)
        self.setTabStopDistance(QFontMetrics(self.font()).horizontalAdvance(' ') * 4)
        self.update_line_number_area_width()
        self.line_number_area.update()

    def set_theme_colors(self, background: QColor, foreground: QColor, line_number_bg: QColor, line_number_fg: QColor, current_line_bg: QColor):
        palette = self.palette()
        palette.setColor(QPalette.ColorRole.Base, background)
        palette.setColor(QPalette.ColorRole.Text, foreground)
        self.setPalette(palette)

        # Update line number area palette and stylesheet for immediate effect
        linenum_palette = self.line_number_area.palette()
        linenum_palette.setColor(QPalette.ColorRole.Window, line_number_bg) # Window role for background
        linenum_palette.setColor(QPalette.ColorRole.WindowText, line_number_fg) # WindowText for foreground
        self.line_number_area.setPalette(linenum_palette)
        self.line_number_area.setStyleSheet(f""QWidget {{ background-color: {line_number_bg.name()}; color: {line_number_fg.name()}; }}"")


        self.current_line_format.setBackground(current_line_bg)
        self.highlight_current_line()

    def paintEvent(self, event):
        # Custom paint event to draw the line number area *before* the main editor content
        # Note: QWidget's paintEvent is not automatically called by QTextEdit's paintEvent
        # We need to manually trigger the line number area repaint or rely on its own update signals.
        # The current setup relies on signals connected in __init__.
        # We can skip the manual paintEvent call here and let the signals handle it.
        super().paintEvent(event)
# --- End of Code Editor Widget ---


# --- Settings Dialog ---

class SettingsDialog(QDialog):
    def __init__(self, active_models_config: list, current_settings: dict, parent=None):
        super().__init__(parent)
        self.setWindowTitle(""Ustawienia"")
        self.setMinimumWidth(400)
        self.setModal(True)

        self.active_models_config = active_models_config
        self.current_settings = current_settings

        self.layout = QVBoxLayout(self)

        # Model selection
        model_label = QLabel(""Model AI:"")
        self.layout.addWidget(model_label)

        self.model_combo = QComboBox()
        # Populate with display names, but store API type and identifier as user data
        for api_type, identifier, display_name in self.active_models_config:
            self.model_combo.addItem(display_name, userData=(api_type, identifier))

        # Set the current model in the combobox
        try:
            current_api_type = self.current_settings.get(""api_type"")
            current_identifier = self.current_settings.get(""model_identifier"")
            # Find the index for the current model config
            for i in range(self.model_combo.count()):
                 api_type, identifier = self.model_combo.itemData(i)
                 if api_type == current_api_type and identifier == current_identifier:
                      self.model_combo.setCurrentIndex(i)
                      break
            else: # If current model not found, select the first available
                if self.model_combo.count() > 0:
                    self.model_combo.setCurrentIndex(0)
        except Exception as e:
            print(f""Error setting initial model in settings dialog: {e}"")
            if self.model_combo.count() > 0: self.model_combo.setCurrentIndex(0)


        self.layout.addWidget(self.model_combo)

        # API Key Inputs (conditional based on available APIs)
        if HAS_GEMINI:
            # Gemini key is usually from file, but could add an input here too if needed
            pass # Keep Gemini key from file for now

        if HAS_MISTRAL:
            mistral_key_label = QLabel(""Klucz API Mistral:"")
            self.layout.addWidget(mistral_key_label)
            self.mistral_key_input = QLineEdit()
            self.mistral_key_input.setPlaceholderText(""Wprowadź klucz API Mistral"")
            self.mistral_key_input.setText(self.current_settings.get(""mistral_api_key"", """"))
            self.layout.addWidget(self.mistral_key_input)


        # Theme selection
        theme_label = QLabel(""Motyw:"")
        self.layout.addWidget(theme_label)

        self.theme_combo = QComboBox()
        self.theme_combo.addItems([""ciemny"", ""jasny""])
        self.theme_combo.setCurrentText(""ciemny"" if self.current_settings.get(""theme"", DEFAULT_THEME) == ""dark"" else ""jasny"")
        self.layout.addWidget(self.theme_combo)

        # Font size
        font_label = QLabel(""Rozmiar czcionki:"")
        self.layout.addWidget(font_label)

        self.font_spin = QSpinBox()
        self.font_spin.setRange(8, 24)
        self.font_spin.setValue(self.current_settings.get(""font_size"", DEFAULT_FONT_SIZE))
        self.layout.addWidget(self.font_spin)

        # UI elements visibility
        self.sidebar_check = QCheckBox(""Pokaż pasek boczny"")
        self.sidebar_check.setChecked(self.current_settings.get(""show_sidebar"", True))
        self.layout.addWidget(self.sidebar_check)

        self.toolbar_check = QCheckBox(""Pokaż pasek narzędzi"")
        self.toolbar_check.setChecked(self.current_settings.get(""show_toolbar"", True))
        self.layout.addWidget(self.toolbar_check)

        self.statusbar_check = QCheckBox(""Pokaż pasek stanu"")
        self.statusbar_check.setChecked(self.current_settings.get(""show_statusbar"", True))
        self.layout.addWidget(self.statusbar_check)

        self.layout.addStretch(1)

        # Standard OK/Cancel buttons
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        ok_button = self.button_box.button(QDialogButtonBox.StandardButton.Ok)
        if ok_button: ok_button.setText(""Zapisz"")
        cancel_button = self.button_box.button(QDialogButtonBox.StandardButton.Cancel)
        if cancel_button: cancel_button.setText(""Anuluj"")
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        self.layout.addWidget(self.button_box)

    def get_selected_model_config(self) -> tuple:
        """"""Returns (api_type, model_identifier) of the selected model.""""""
        return self.model_combo.currentData()

    def get_mistral_api_key(self) -> str:
        """"""Returns the Mistral API key from the input field, or None if Mistral is not supported.""""""
        if HAS_MISTRAL:
             return self.mistral_key_input.text().strip() or None
        return None


    def get_selected_theme(self) -> str:
        return ""dark"" if self.theme_combo.currentText() == ""ciemny"" else ""light""

    def get_font_size(self) -> int:
        return self.font_spin.value()

    def get_ui_visibility(self) -> dict:
        return {
            ""show_sidebar"": self.sidebar_check.isChecked(),
            ""show_toolbar"": self.toolbar_check.isChecked(),
            ""show_statusbar"": self.statusbar_check.isChecked()
        }

# --- File Explorer ---

class FileExplorer(QTreeView):
    # Signal emitted when one or more files are selected for opening (e.g., by double-click or context menu)
    # Emits a list of file paths (only files, not directories)
    openFilesRequested = pyqtSignal(list)
    # Signal emitted when one or more items are selected for deletion
    # Emits a list of file/directory paths
    deleteItemsRequested = pyqtSignal(list)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.model = QFileSystemModel() # Store model as instance variable
        self.setModel(self.model)

        home_dir = QStandardPaths.standardLocations(QStandardPaths.StandardLocation.HomeLocation)[0]
        self.model.setRootPath(home_dir)
        self.setRootIndex(self.model.index(home_dir))

        self.setAnimated(False)
        self.setIndentation(15)
        self.setSortingEnabled(True)

        # Set default sorting: Folders first, then by name, case-insensitive is often preferred
        self.model.setFilter(QDir.Filter.AllEntries | QDir.Filter.NoDotAndDotDot | QDir.Filter.Hidden) # Hide . and .., also hidden files/folders
        # self.model.setSortingFlags(QDir.SortFlag.DirsFirst | QDir.SortFlag.Name | QDir.SortFlag.IgnoreCase | QDir.SortFlag.LocaleAware)
        # The above line caused the error. QFileSystemModel handles DirsFirst internally when sorting by name.
        # We can rely on the default sorting behavior combined with sortByColumn.
        self.sortByColumn(0, Qt.SortOrder.AscendingOrder) # Sort by Name column (0) ascending

        # Hide columns we don't need
        for i in range(1, self.model.columnCount()):
            self.hideColumn(i)

        # Selection mode: Allows multi-selection with Ctrl/Shift
        self.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        # Selection behavior: Select entire rows
        self.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)

        # Connect double-click
        # Disconnect the default activated behavior that changes root
        try:
             self.activated.disconnect(self.on_item_activated)
        except TypeError: # Handle case where it's not connected yet or connected elsewhere
             pass
        # Connect double-click to toggle expansion for directories and open for files
        self.doubleClicked.connect(self.on_item_double_clicked)


        self.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.customContextMenuRequested.connect(self.show_context_menu)

        # Internal clipboard for copy/cut operations
        self._clipboard_paths = []
        self._is_cut_operation = False

    def on_item_activated(self, index: QModelIndex):
        """"""Handles item activation (e.g., single-click or Enter key).""""""
        # Keep single-click behavior minimal or just selection
        if not index.isValid():
             return
        # Default single-click is usually just selection, which is fine.
        # The original on_item_activated changed the root on double-click, which is now handled by on_item_double_clicked.
        # We can leave this method empty or connect it to something else if needed.
        pass

    def on_item_double_clicked(self, index: QModelIndex):
        """"""Handles item double-click.""""""
        if not index.isValid():
            return

        file_path = self.model.filePath(index)
        file_info = QFileInfo(file_path)

        if file_info.isDir():
            # Toggle directory expansion instead of changing root
            self.setExpanded(index, not self.isExpanded(index))
        else:
            # If it's a file, emit signal to main window to open it
            self.openFilesRequested.emit([file_path]) # Emit a list even for a single file


    def get_selected_paths(self) -> list:
        """"""Returns a list of unique file/directory paths for all selected items.""""""
        paths = set() # Use a set to ensure uniqueness
        # Iterate through selected indexes, but only take the first column's index for each row
        # to avoid duplicates if multiple columns were visible
        for index in self.selectedIndexes():
             if index.column() == 0: # Only process the name column index
                 paths.add(self.model.filePath(index))
        return list(paths)

    def show_context_menu(self, position):
        menu = QMenu()
        index = self.indexAt(position) # Get index at click position
        clipboard = QApplication.clipboard() # Get global clipboard

        # --- Actions based on the clicked item ---
        if index.isValid():
            file_path = self.model.filePath(index)
            file_info = QFileInfo(file_path)
            selected_paths = self.get_selected_paths() # Get all selected items

            # --- Actions for the item at the click position ---

            # New File/Folder actions (only if clicked item is a directory)
            if file_info.isDir():
                new_file_action = menu.addAction(QIcon.fromTheme(""document-new""), ""Nowy plik w tym folderze"")
                new_file_action.triggered.connect(lambda: self.create_new_file(file_path))

                new_folder_action = menu.addAction(QIcon.fromTheme(""folder-new""), ""Nowy folder w tym folderze"")
                new_folder_action.triggered.connect(lambda: self.create_new_folder(file_path))

                menu.addSeparator()

            # Open action (for both files and directories)
            open_action = menu.addAction(QIcon.fromTheme(""document-open""), ""Otwórz"")
            if file_info.isDir():
                 # For directories, this could either expand/collapse or change root.
                 # Let's make it change root via context menu for explicit navigation.
                 open_action.triggered.connect(lambda: self.setRootIndex(index))
                 # Alternative: open_action.triggered.connect(lambda: self.setExpanded(index, not self.isExpanded(index)))
            else:
                 # For files, emit the open signal to the main window
                 open_action.triggered.connect(lambda: self.openFilesRequested.emit([file_path]))

            # Copy/Cut actions for the clicked item
            copy_action = menu.addAction(QIcon.fromTheme(""edit-copy""), ""Kopiuj"")
            copy_action.triggered.connect(lambda: self.copy_items([file_path]))

            cut_action = menu.addAction(QIcon.fromTheme(""edit-cut""), ""Wytnij"")
            cut_action.triggered.connect(lambda: self.cut_items([file_path]))


            # Paste actions (conditional based on clipboard and clicked item type)
            if self._clipboard_paths: # Only show paste options if clipboard is not empty
                 if file_info.isDir():
                      # Paste into the clicked directory
                      paste_into_action = menu.addAction(QIcon.fromTheme(""edit-paste""), ""Wklej do folderu"")
                      paste_into_action.triggered.connect(lambda: self.paste_items(file_path)) # Paste into this folder
                      # Paste alongside the clicked directory (in its parent)
                      parent_dir = self.model.filePath(index.parent())
                      if parent_dir: # Cannot paste alongside the root of the model
                         paste_alongside_action = menu.addAction(QIcon.fromTheme(""edit-paste""), ""Wklej obok"")
                         paste_alongside_action.triggered.connect(lambda: self.paste_items(parent_dir)) # Paste into parent folder
                 else: # Clicked item is a file
                      # Paste alongside the clicked file (in its parent)
                      parent_dir = self.model.filePath(index.parent())
                      if parent_dir: # Cannot paste alongside the root of the model
                         paste_alongside_action = menu.addAction(QIcon.fromTheme(""edit-paste""), ""Wklej obok"")
                         paste_alongside_action.triggered.connect(lambda: self.paste_items(parent_dir)) # Paste into parent folder


            # Rename action for the clicked item
            rename_action = menu.addAction(QIcon.fromTheme(""edit-rename""), ""Zmień nazwę"")
            rename_action.triggered.connect(lambda: self.edit(index)) # QTreeView.edit starts renaming

            # Delete action for the clicked item
            delete_action = menu.addAction(QIcon.fromTheme(""edit-delete""), ""Usuń"")
            delete_action.triggered.connect(lambda: self.deleteItemsRequested.emit([file_path])) # Emit list for consistency

            menu.addSeparator()

            show_in_explorer_action = menu.addAction(QIcon.fromTheme(""system-file-manager""), ""Pokaż w menedżerze plików"")
            show_in_explorer_action.triggered.connect(lambda: self.show_in_explorer(file_path))

        else:
            # --- Actions for empty space ---
            root_path = self.model.filePath(self.rootIndex()) # Target actions to the current root directory

            new_file_action = menu.addAction(QIcon.fromTheme(""document-new""), ""Nowy plik"")
            new_file_action.triggered.connect(lambda: self.create_new_file(root_path))

            new_folder_action = menu.addAction(QIcon.fromTheme(""folder-new""), ""Nowy folder"")
            new_folder_action.triggered.connect(lambda: self.create_new_folder(root_path))

            menu.addSeparator()

            # Paste action for empty space (paste into the current root directory)
            if self._clipboard_paths:
                 paste_action = menu.addAction(QIcon.fromTheme(""edit-paste""), f""Wklej elementy ({len(self._clipboard_paths)})"")
                 paste_action.triggered.connect(lambda: self.paste_items(root_path))


            select_all_action = menu.addAction(QIcon.fromTheme(""edit-select-all""), ""Zaznacz wszystko"")
            select_all_action.triggered.connect(self.selectAll)


        # --- Actions for multiple selected items (if applicable, add them regardless of clicked item if multi-selected) ---
        # Check if *multiple* items are selected (excluding the single item already handled above)
        all_selected_paths = self.get_selected_paths()
        if len(all_selected_paths) > 1:
             # Avoid adding separator if one was just added
             if not menu.actions()[-1].isSeparator():
                  menu.addSeparator()

             # Filter out directories for ""Open Selected Files""
             selected_files = [p for p in all_selected_paths if QFileInfo(p).isFile()]
             if selected_files:
                  open_selected_action = menu.addAction(QIcon.fromTheme(""document-open-folder""), f""Otwórz zaznaczone pliki ({len(selected_files)})"")
                  open_selected_action.triggered.connect(lambda: self.openFilesRequested.emit(selected_files))

             # Copy/Cut for multiple selected items
             copy_selected_action = menu.addAction(QIcon.fromTheme(""edit-copy""), f""Kopiuj zaznaczone elementy ({len(all_selected_paths)})"")
             copy_selected_action.triggered.connect(lambda: self.copy_items(all_selected_paths))

             cut_selected_action = menu.addAction(QIcon.fromTheme(""edit-cut""), f""Wytnij zaznaczone elementy ({len(all_selected_paths)})"")
             cut_selected_action.triggered.connect(lambda: self.cut_items(all_selected_paths))

             # Delete action for all selected items (files and folders)
             delete_selected_action = menu.addAction(QIcon.fromTheme(""edit-delete""), f""Usuń zaznaczone elementy ({len(all_selected_paths)})"")
             delete_selected_action.triggered.connect(lambda: self.deleteItemsRequested.emit(all_selected_paths)) # Emit list for consistency


        menu.exec(self.viewport().mapToGlobal(position))

    def create_new_file(self, dir_path):
        name, ok = QInputDialog.getText(self, ""Nowy plik"", ""Nazwa pliku:"", QLineEdit.EchoMode.Normal, ""nowy_plik.txt"")
        if ok and name:
            file_path = os.path.join(dir_path, name)
            try:
                if os.path.exists(file_path):
                    QMessageBox.warning(self, ""Błąd"", f""Plik już istnieje: {file_path}"")
                    return
                # Create the file manually
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write('') # Create an empty file
                print(f""Utworzono plik: {file_path}"")
                # Refresh the model to show the new file
                self.model.refresh(self.model.index(dir_path))
                # Optional: Select and start renaming the new file
                new_index = self.model.index(file_path)
                if new_index.isValid():
                    self.setCurrentIndex(new_index)
                    self.edit(new_index)
                self.parent().update_status_bar_message(f""Utworzono nowy plik: {os.path.basename(file_path)}"")

            except Exception as e:
                QMessageBox.warning(self, ""Błąd"", f""Nie można utworzyć pliku '{name}':\n{e}"")
                self.parent().update_status_bar_message(f""Błąd tworzenia pliku: {e}"")


    def create_new_folder(self, dir_path):
        name, ok = QInputDialog.getText(self, ""Nowy folder"", ""Nazwa folderu:"", QLineEdit.EchoMode.Normal, ""Nowy folder"")
        if ok and name:
            folder_path = os.path.join(dir_path, name)
            try:
                if os.path.exists(folder_path):
                    QMessageBox.warning(self, ""Błąd"", f""Folder już istnieje: {folder_path}"")
                    return
                # Use the model's method which handles refreshing and selection/editing
                index = self.model.index(dir_path)
                if index.isValid():
                    new_index = self.model.mkdir(index, name)
                    if new_index.isValid():
                        # Optional: Expand parent and select/rename new folder
                        self.setExpanded(index, True)
                        self.setCurrentIndex(new_index)
                        self.edit(new_index)
                        if self.parent() and hasattr(self.parent(), 'update_status_bar_message'):
                            self.parent().update_status_bar_message(f""Utworzono nowy folder: {os.path.basename(folder_path)}"")
                        else:
                            print(f""Folder {folder_path} utworzony, ale brak metody 'update_status_bar_message'!"")
                    else:
                        QMessageBox.warning(self, ""Błąd"", f""Nie można utworzyć folderu '{name}'. Sprawdź uprawnienia."")
                        if self.parent() and hasattr(self.parent(), 'update_status_bar_message'):
                            self.parent().update_status_bar_message(f""Błąd tworzenia folderu: {name}"")
                else:
                    # Fallback if dir_path cannot be found in the model (less likely for valid paths)
                    os.mkdir(folder_path)
                    self.model.refresh(self.model.index(dir_path))  # Manual refresh
                    new_index = self.model.index(folder_path)
                    if new_index.isValid():
                        self.setExpanded(self.model.index(dir_path), True)
                        self.setCurrentIndex(new_index)
                        self.edit(new_index)
                        if self.parent() and hasattr(self.parent(), 'update_status_bar_message'):
                            self.parent().update_status_bar_message(f""Utworzono nowy folder: {os.path.basename(folder_path)}"")
                    else:
                        QMessageBox.warning(self, ""Błąd"", f""Nie można utworzyć folderu '{name}'. Sprawdź uprawnienia."")
                        if self.parent() and hasattr(self.parent(), 'update_status_bar_message'):
                            self.parent().update_status_bar_message(f""Błąd tworzenia folderu: {name}"")
            except Exception as e:
                QMessageBox.warning(self, ""Błąd"", f""Nie można utworzyć folderu '{name}':\n{e}"")
                if self.parent() and hasattr(self.parent(), 'update_status_bar_message'):
                    self.parent().update_status_bar_message(f""Błąd tworzenia folderu: {e}"")



    def delete_items(self, file_paths: list):
        """"""Initiates deletion of a list of files/directories.""""""
        if not file_paths:
            return

        # Get confirmation for multiple items
        if len(file_paths) > 1:
            items_list = ""\n"".join([os.path.basename(p) for p in file_paths])
            reply = QMessageBox.question(self, ""Usuń zaznaczone"",
                                         f""Czy na pewno chcesz usunąć następujące elementy?\n\n{items_list}\n\nTa operacja jest nieodwracalna."",
                                         QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        else:
            # Confirmation for single item (reusing logic from show_context_menu)
            item_name = os.path.basename(file_paths[0])
            reply = QMessageBox.question(self, ""Usuń"", f""Czy na pewno chcesz usunąć '{item_name}'?"",
                                         QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)

        if reply == QMessageBox.StandardButton.Yes:
            deleted_count = 0
            error_messages = []
            parent_dirs_to_refresh = set()

            for file_path in file_paths:
                parent_dirs_to_refresh.add(os.path.dirname(file_path))
                try:
                    index = self.model.index(file_path)
                    if index.isValid():
                        # QFileSystemModel.remove handles both files and non-empty directories recursively
                        # on supported platforms (like Windows, macOS). On Linux, it might be just rmdir for empty dirs.
                        # Let's prioritize the model's method first as it might be more integrated.
                        # For robustness, we can keep the shutil fallback.
                        # NOTE: model.remove returns True on success, False on failure, doesn't raise exceptions.
                        if self.model.remove(index.row(), 1, index.parent()):
                             print(f""Usunięto element (model): {file_path}"")
                             deleted_count += 1
                        else:
                             # model.remove failed, try recursive deletion with shutil/os
                             print(f""Model nie usunął '{file_path}', próbuję shutil/os..."")
                             if os.path.isdir(file_path):
                                  shutil.rmtree(file_path)
                                  print(f""Usunięto katalog (shutil): {file_path}"")
                                  deleted_count += 1
                             elif os.path.exists(file_path):
                                  os.remove(file_path)
                                  print(f""Usunięto plik (os.remove): {file_path}"")
                                  deleted_count += 1
                             else:
                                  # Should not happen if index was valid initially
                                  error_messages.append(f""Nie znaleziono: {file_path}"")
                    else:
                        error_messages.append(f""Nieprawidłowa ścieżka lub element niedostępny: {file_path}"")
                except Exception as e:
                    error_messages.append(f""Nie można usunąć '{os.path.basename(file_path)}': {e}"")
                    print(f""Błąd usuwania '{file_path}': {traceback.format_exc()}"") # Log error

            # Refresh parent directories that were affected
            for parent_dir in parent_dirs_to_refresh:
                 if os.path.exists(parent_dir): # Ensure parent still exists
                     self.model.refresh(self.model.index(parent_dir))

            if error_messages:
                 QMessageBox.warning(self, ""Błąd usuwania"", ""Wystąpiły błędy podczas usuwania niektórych elementów:\n\n"" + ""\n"".join(error_messages))
                 self.parent().update_status_bar_message(f""Wystąpiły błędy podczas usuwania ({len(error_messages)} błędów)"")
            elif deleted_count > 0:
                 self.parent().update_status_bar_message(f""Pomyślnie usunięto {deleted_count} elementów."")


    def copy_items(self, paths_to_copy: list):
         """"""Stores paths for copy operation in the internal clipboard.""""""
         if not paths_to_copy:
              return
         self._clipboard_paths = paths_to_copy
         self._is_cut_operation = False
         self.parent().update_status_bar_message(f""Skopiowano {len(paths_to_copy)} elementów."")
         print(f""Skopiowano: {self._clipboard_paths}"") # Debug print


    def cut_items(self, paths_to_cut: list):
         """"""Stores paths for cut operation in the internal clipboard.""""""
         if not paths_to_cut:
              return
         self._clipboard_paths = paths_to_cut
         self._is_cut_operation = True
         self.parent().update_status_bar_message(f""Wycięto {len(paths_to_cut)} elementów."")
         print(f""Wycięto: {self._clipboard_paths}"") # Debug print


    def paste_items(self, destination_dir: str):
         """"""Pastes items from the internal clipboard into the destination directory.""""""
         if not self._clipboard_paths:
              self.parent().update_status_bar_message(""Schowek jest pusty."")
              return

         if not os.path.isdir(destination_dir):
              QMessageBox.warning(self, ""Błąd wklejania"", f""Docelowa ścieżka nie jest katalogiem: {destination_dir}"")
              self.parent().update_status_bar_message(f""Błąd wklejania: {destination_dir} nie jest katalogiem."")
              return

         if not os.access(destination_dir, os.W_OK):
              QMessageBox.warning(self, ""Błąd wklejania"", f""Brak uprawnień zapisu w katalogu docelowym: {destination_dir}"")
              self.parent().update_status_bar_message(f""Błąd wklejania: Brak uprawnień w {destination_dir}."")
              return

         operation = ""Przenoszenie"" if self._is_cut_operation else ""Kopiowanie""
         self.parent().update_status_bar_message(f""{operation} {len(self._clipboard_paths)} elementów do '{os.path.basename(destination_dir)}'..."")

         success_count = 0
         error_messages = []
         parent_dirs_to_refresh = {destination_dir} # Always refresh destination

         for src_path in self._clipboard_paths:
              if not os.path.exists(src_path):
                   error_messages.append(f""Źródło nie istnieje: {os.path.basename(src_path)}"")
                   continue

              item_name = os.path.basename(src_path)
              dest_path = os.path.join(destination_dir, item_name)

              # Prevent pasting an item into itself or its sub-directory during a move
              if self._is_cut_operation and src_path == dest_path:
                   error_messages.append(f""Nie można przenieść '{item_name}' w to samo miejsce."")
                   continue
              if self._is_cut_operation and os.path.commonpath([src_path, dest_path]) == src_path and os.path.isdir(src_path):
                  error_messages.append(f""Nie można przenieść '{item_name}' do jego podkatalogu."")
                  continue

              # Handle potential overwrite (simple overwrite for now)
              if os.path.exists(dest_path):
                   # Ask for confirmation? For simplicity, let's overwrite or skip for now.
                   # A more complex dialog could be added here.
                   # For this example, let's just overwrite.
                   if os.path.isdir(dest_path):
                       try: shutil.rmtree(dest_path)
                       except Exception as e: error_messages.append(f""Nie można nadpisać katalogu '{item_name}': {e}""); continue
                   else:
                        try: os.remove(dest_path)
                        except Exception as e: error_messages.append(f""Nie można nadpisać pliku '{item_name}': {e}""); continue


              try:
                   if self._is_cut_operation:
                        # Move the item
                        shutil.move(src_path, dest_path)
                        success_count += 1
                        parent_dirs_to_refresh.add(os.path.dirname(src_path)) # Also refresh source's parent on move
                   else:
                        # Copy the item (recursive for directories)
                        if os.path.isdir(src_path):
                             shutil.copytree(src_path, dest_path)
                        else:
                             shutil.copy2(src_path, dest_path) # copy2 preserves metadata
                        success_count += 1

              except Exception as e:
                   error_messages.append(f""Błąd {operation.lower()} '{item_name}': {e}"")
                   print(f""Błąd {operation.lower()} '{src_path}' do '{dest_path}': {traceback.format_exc()}"") # Log error


         # Refresh affected directories
         for refresh_dir in parent_dirs_to_refresh:
              if os.path.exists(refresh_dir):
                   self.model.refresh(self.model.index(refresh_dir))

         if self._is_cut_operation and success_count > 0:
              # Clear clipboard only if it was a cut operation and at least one item was successfully moved
              self._clipboard_paths = []
              self._is_cut_operation = False

         if error_messages:
              QMessageBox.warning(self, f""Błąd {operation.lower()}enia"", f""Wystąpiły błędy podczas {operation.lower()}enia:\n\n"" + ""\n"".join(error_messages))
              self.parent().update_status_bar_message(f""Wystąpiły błędy podczas {operation.lower()}enia ({len(error_messages)} błędów)"")
         elif success_count > 0:
              self.parent().update_status_bar_message(f""Pomyślnie {operation.lower()}ono {success_count} elementów."")
         else:
              # This case happens if clipboard was empty or all items failed
              if not self._clipboard_paths: # If clipboard was empty initially
                 pass # Message already handled at the start
              else: # All items failed
                 self.parent().update_status_bar_message(f""Nie udało się {operation.lower()}ić żadnych elementów."")

    def show_in_explorer(self, file_path):
        """"""Opens the file or folder in the native file explorer.""""""
        if sys.platform == ""win32"":
            try:
                 # Use explorer.exe /select, to select the file/folder
                 subprocess.Popen(['explorer.exe', '/select,', os.path.normpath(file_path)])
                 self.parent().update_status_bar_message(f""Otworzono w eksploratorze: {os.path.basename(file_path)}"")
            except FileNotFoundError:
                 QMessageBox.warning(self, ""Błąd"", ""Nie znaleziono 'explorer.exe'."")
                 self.parent().update_status_bar_message(""Błąd: Nie znaleziono explorer.exe."")
            except Exception as e:
                 QMessageBox.warning(self, ""Błąd"", f""Nie można otworzyć menedżera plików:\n{e}"")
                 self.parent().update_status_bar_message(f""Błąd otwarcia w menedżerze: {e}"")
        elif sys.platform == ""darwin"":  # macOS
            try:
                 # Use 'open -R' to reveal file in Finder, or 'open' for folder
                 subprocess.Popen(['open', '-R', file_path])
                 self.parent().update_status_bar_message(f""Otworzono w Finderze: {os.path.basename(file_path)}"")
            except FileNotFoundError:
                 QMessageBox.warning(self, ""Błąd"", ""Nie znaleziono 'open'."")
                 self.parent().update_status_bar_message(""Błąd: Nie znaleziono open."")
            except Exception as e:
                 QMessageBox.warning(self, ""Błąd"", f""Nie można otworzyć Findera:\n{e}"")
                 self.parent().update_status_bar_message(f""Błąd otwarcia w Finderze: {e}"")
        else:  # Linux
            try:
                # Use xdg-open which should open the containing folder
                # For a file, xdg-open opens the file. To open the folder containing the file:
                target_path = os.path.dirname(file_path) if os.path.isfile(file_path) else file_path
                subprocess.Popen(['xdg-open', target_path])
                self.parent().update_status_bar_message(f""Otworzono w menedżerze plików: {os.path.basename(target_path)}"")
            except FileNotFoundError:
                QMessageBox.warning(self, ""Błąd"", ""Nie znaleziono 'xdg-open'. Nie można otworzyć lokalizacji pliku."")
                self.parent().update_status_bar_message(""Błąd: Nie znaleziono xdg-open."")
            except Exception as e:
                 QMessageBox.warning(self, ""Błąd"", f""Nie można otworzyć lokalizacji pliku:\n{e}"")
                 self.parent().update_status_bar_message(f""Błąd otwarcia w menedżerze: {e}"")

    # Open file logic is now handled by the main window via signal
    # The file explorer's open_file method is effectively replaced by on_item_activated
    # which emits openFilesRequested.


# --- Main Application Window ---

class CodeEditorWindow(QMainWindow):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(""Edytor Kodu AI"")
        self.setGeometry(100, 100, 1200, 800)

        # Load settings
        self.settings = load_settings()
        self.current_api_type = self.settings.get(""api_type"", DEFAULT_MODEL_CONFIG[0])
        self.current_model_identifier = self.settings.get(""model_identifier"", DEFAULT_MODEL_CONFIG[1])
        self.mistral_api_key = self.settings.get(""mistral_api_key"") # Load Mistral key
        # Gemini key is loaded globally GEMINI_API_KEY_GLOBAL

        self.recent_files = self.settings[""recent_files""]
        self.font_size = self.settings[""font_size""]
        self.theme = self.settings[""theme""]
        self.workspace = self.settings[""workspace""]
        self.show_sidebar = self.settings[""show_sidebar""]
        self.show_toolbar = self.settings[""show_toolbar""]
        self.show_statusbar = self.settings[""show_statusbar""]

        # Initialize UI
        self.init_ui()

        # Store references to menu actions for toggling visibility checks (Fix AttributeError)
        self.action_toggle_sidebar = self.findChild(QAction, ""Przełącz Pasek Boczny"")
        self.action_toggle_toolbar = self.findChild(QAction, ""Przełącz Pasek Narzędzi"")
        self.action_toggle_statusbar = self.findChild(QAction, ""Przełącz Pasek Stanu"")


        # Chat History State
        # Stored as list of (role, content, metadata) tuples
        self.chat_history = []

        # Threading Setup for API calls
        self.worker = None
        self.worker_thread = None
        self._is_processing = False

        # State for streaming response
        self.current_placeholder_widget = None
        self.current_response_content = """"

        # Setup status bar message timer
        self._status_timer = QTimer(self)
        self._status_timer.setSingleShot(True)
        self._status_timer.timeout.connect(self.clear_status_bar_message)

        # Open workspace if set and exists
        if self.workspace and os.path.exists(self.workspace) and os.path.isdir(self.workspace):
            self.file_explorer.setRootIndex(self.file_explorer.model.index(self.workspace))
            self.update_status_bar_message(f""Obszar roboczy: {self.workspace}"")
        else:
            # If workspace is not set or invalid, set root to home directory
            home_dir = QStandardPaths.standardLocations(QStandardPaths.StandardLocation.HomeLocation)[0]
            self.file_explorer.model.setRootPath(home_dir)
            self.file_explorer.setRootIndex(self.file_explorer.model.index(home_dir))
            self.workspace = home_dir  # Update settings to reflect actual root
            self.settings[""workspace""] = self.workspace
            save_settings(self.settings)  # Save updated workspace
            self.update_status_bar_message(f""Ustawiono domyślny obszar roboczy: {self.workspace}"")


        # Add welcome message
        # Find the display name for the initial model
        initial_model_name = next((name for api_type, identifier, name in ACTIVE_MODELS_CONFIG if api_type == self.current_api_type and identifier == self.current_model_identifier), self.current_model_identifier)

        self.add_message(""assistant"", f""Witaj w edytorze kodu AI! Aktualnie działam na modelu '{initial_model_name}'. Jak mogę Ci dziś pomóc?"")

    def init_ui(self):
        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        self.main_splitter = QSplitter(Qt.Orientation.Horizontal)

        self.sidebar = QWidget()
        sidebar_layout = QVBoxLayout(self.sidebar)
        sidebar_layout.setContentsMargins(0, 0, 0, 0)
        sidebar_layout.setSpacing(0)

        # FileExplorer initialization (this is where the error occurred)
        # The fix is inside the FileExplorer class itself
        self.file_explorer = FileExplorer(self)
        sidebar_layout.addWidget(self.file_explorer)
        # Connect signals from FileExplorer
        self.file_explorer.openFilesRequested.connect(self.open_files)
        self.file_explorer.deleteItemsRequested.connect(self.file_explorer.delete_items) # Connect to file_explorer's delete method


        self.right_panel = QSplitter(Qt.Orientation.Vertical)

        self.tabs = QTabWidget()
        self.tabs.setTabsClosable(True)
        self.tabs.tabCloseRequested.connect(self.close_tab)
        self.tabs.currentChanged.connect(self.update_status_bar)

        self.chat_container = QWidget()
        chat_layout = QVBoxLayout(self.chat_container)
        chat_layout.setContentsMargins(0, 0, 0, 0)
        chat_layout.setSpacing(0)

        self.chat_scroll = QScrollArea()
        self.chat_scroll.setWidgetResizable(True)
        self.chat_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)

        self.chat_widget = QWidget()
        self.chat_widget.setObjectName(""chat_widget"")
        self.chat_layout = QVBoxLayout(self.chat_widget)
        self.chat_layout.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignHCenter)
        self.chat_layout.setSpacing(10)
        self.chat_layout.addStretch(1)

        self.chat_scroll.setWidget(self.chat_widget)
        chat_layout.addWidget(self.chat_scroll)

        self.chat_input = QLineEdit()
        self.chat_input.setPlaceholderText(""Wpisz wiadomość tutaj..."")
        self.chat_input.returnPressed.connect(self.send_message)

        self.send_button = QPushButton(""Wyślij"")
        self.send_button.clicked.connect(self.send_message)

        input_layout = QHBoxLayout()
        input_layout.addWidget(self.chat_input, 1)
        input_layout.addWidget(self.send_button)
        chat_layout.addLayout(input_layout)

        self.main_splitter.addWidget(self.sidebar)
        self.right_panel.addWidget(self.tabs)
        self.right_panel.addWidget(self.chat_container)
        self.right_panel.setStretchFactor(0, 3)
        self.right_panel.setStretchFactor(1, 1)
        self.main_splitter.addWidget(self.right_panel)

        main_layout = QVBoxLayout(central_widget)
        main_layout.addWidget(self.main_splitter)

        self.create_menu_bar()
        self.create_tool_bar()
        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)
        self.update_status_bar()

        self.apply_font_size(self.font_size)
        self.apply_theme(self.theme)

        self.sidebar.setVisible(self.show_sidebar)
        self.toolbar.setVisible(self.show_toolbar)
        self.status_bar.setVisible(self.show_statusbar)

        self.main_splitter.setSizes([200, 800])
        self.right_panel.setSizes([600, 200])

    def create_menu_bar(self):
        menubar = self.menuBar()

        # File menu
        file_menu = menubar.addMenu(""📄 Plik"")

        new_action = QAction(QIcon.fromTheme(""document-new""), ""Nowy"", self)
        new_action.setShortcut(""Ctrl+N"")
        new_action.setShortcutContext(Qt.ShortcutContext.WindowShortcut)
        new_action.triggered.connect(self.new_file)
        file_menu.addAction(new_action)

        open_action = QAction(QIcon.fromTheme(""document-open""), ""Otwórz..."", self)
        open_action.setShortcut(""Ctrl+O"")
        open_action.setShortcutContext(Qt.ShortcutContext.WindowShortcut)
        open_action.triggered.connect(self.open_file_dialog)
        file_menu.addAction(open_action)

        save_action = QAction(QIcon.fromTheme(""document-save""), ""Zapisz"", self)
        save_action.setObjectName(""action_save"") # Add object name for potential lookup
        save_action.setShortcut(""Ctrl+S"")
        save_action.setShortcutContext(Qt.ShortcutContext.WindowShortcut) # Ensure Ctrl+S works even when editor has focus
        save_action.triggered.connect(self.save_file)
        file_menu.addAction(save_action)

        save_as_action = QAction(""Zapisz jako..."", self)
        save_as_action.setShortcut(""Ctrl+Shift+S"")
        save_as_action.setShortcutContext(Qt.ShortcutContext.WindowShortcut)
        save_as_action.triggered.connect(self.save_file_as)
        file_menu.addAction(save_as_action)

        file_menu.addSeparator()

        open_workspace_action = QAction(QIcon.fromTheme(""folder-open""), ""Otwórz Obszar Roboczy..."", self)
        open_workspace_action.triggered.connect(self.open_workspace)
        file_menu.addAction(open_workspace_action)

        self.recent_files_menu = file_menu.addMenu(""Ostatnie pliki"")
        self.update_recent_files_menu()

        file_menu.addSeparator()

        exit_action = QAction(""Wyjście"", self)
        exit_action.setShortcut(""Ctrl+Q"")
        exit_action.setShortcutContext(Qt.ShortcutContext.WindowShortcut)
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)

        # Edit menu
        edit_menu = menubar.addMenu(""✏️ Edycja"")

        undo_action = QAction(QIcon.fromTheme(""edit-undo""), ""Cofnij"", self)
        undo_action.setShortcut(""Ctrl+Z"")
        undo_action.setShortcutContext(Qt.ShortcutContext.WidgetWithChildrenShortcut) # Standard editor shortcut
        undo_action.triggered.connect(self.undo)
        edit_menu.addAction(undo_action)

        redo_action = QAction(QIcon.fromTheme(""edit-redo""), ""Ponów"", self)
        redo_action.setShortcut(""Ctrl+Y"")
        redo_action.setShortcutContext(Qt.ShortcutContext.WidgetWithChildrenShortcut) # Standard editor shortcut
        redo_action.triggered.connect(self.redo)
        edit_menu.addAction(redo_action)

        edit_menu.addSeparator()

        cut_action = QAction(QIcon.fromTheme(""edit-cut""), ""Wytnij"", self)
        cut_action.setShortcut(""Ctrl+X"")
        cut_action.setShortcutContext(Qt.ShortcutContext.WidgetWithChildrenShortcut) # Standard editor shortcut
        cut_action.triggered.connect(self.cut)
        edit_menu.addAction(cut_action)

        copy_action = QAction(QIcon.fromTheme(""edit-copy""), ""Kopiuj"", self)
        copy_action.setShortcut(""Ctrl+C"")
        copy_action.setShortcutContext(Qt.ShortcutContext.WidgetWithChildrenShortcut) # Standard editor shortcut
        copy_action.triggered.connect(self.copy)
        edit_menu.addAction(copy_action)

        paste_action = QAction(QIcon.fromTheme(""edit-paste""), ""Wklej"", self)
        paste_action.setShortcut(""Ctrl+V"")
        paste_action.setShortcutContext(Qt.ShortcutContext.WidgetWithChildrenShortcut) # Standard editor shortcut
        paste_action.triggered.connect(self.paste)
        edit_menu.addAction(paste_action)

        edit_menu.addSeparator()

        find_action = QAction(QIcon.fromTheme(""edit-find""), ""Znajdź..."", self)
        find_action.setShortcut(""Ctrl+F"")
        find_action.setShortcutContext(Qt.ShortcutContext.WindowShortcut) # Find can often be window-wide
        find_action.triggered.connect(self.find)
        edit_menu.addAction(find_action)

        replace_action = QAction(QIcon.fromTheme(""edit-find-replace""), ""Zamień..."", self)
        replace_action.setShortcut(""Ctrl+H"")
        replace_action.setShortcutContext(Qt.ShortcutContext.WindowShortcut)
        replace_action.triggered.connect(self.replace)
        edit_menu.addAction(replace_action)

        # View menu
        view_menu = menubar.addMenu(""🖼️ Widok"")

        # Store references to toggle actions (Fix AttributeError)
        self.action_toggle_sidebar = QAction(""Przełącz Pasek Boczny"", self)
        self.action_toggle_sidebar.setObjectName(""Przełącz Pasek Boczny"") # Set object name for findChild if needed elsewhere
        self.action_toggle_sidebar.setShortcut(""Ctrl+B"")
        self.action_toggle_sidebar.setCheckable(True)
        self.action_toggle_sidebar.setChecked(self.show_sidebar)
        self.action_toggle_sidebar.triggered.connect(self.toggle_sidebar)
        view_menu.addAction(self.action_toggle_sidebar)

        self.action_toggle_toolbar = QAction(""Przełącz Pasek Narzędzi"", self)
        self.action_toggle_toolbar.setObjectName(""Przełącz Pasek Narzędzi"")
        self.action_toggle_toolbar.setCheckable(True)
        self.action_toggle_toolbar.setChecked(self.show_toolbar)
        self.action_toggle_toolbar.triggered.connect(self.toggle_toolbar)
        view_menu.addAction(self.action_toggle_toolbar)

        self.action_toggle_statusbar = QAction(""Przełącz Pasek Stanu"", self)
        self.action_toggle_statusbar.setObjectName(""Przełącz Pasek Stanu"")
        self.action_toggle_statusbar.setCheckable(True)
        self.action_toggle_statusbar.setChecked(self.show_statusbar)
        self.action_toggle_statusbar.triggered.connect(self.toggle_statusbar)
        view_menu.addAction(self.action_toggle_statusbar)

        view_menu.addSeparator()

        dark_theme_action = QAction(""Ciemny Motyw"", self)
        dark_theme_action.triggered.connect(lambda: self.apply_theme(""dark""))
        view_menu.addAction(dark_theme_action)

        light_theme_action = QAction(""Jasny Motyw"", self)
        light_theme_action.triggered.connect(lambda: self.apply_theme(""light""))
        view_menu.addAction(light_theme_action)

        # Tools menu
        tools_menu = menubar.addMenu(""🛠️ Narzędzia"")

        run_code_action = QAction(QIcon.fromTheme(""system-run""), ""Uruchom kod"", self)
        run_code_action.setShortcut(""Ctrl+R"")
        run_code_action.setShortcutContext(Qt.ShortcutContext.WindowShortcut) # Run code is window-wide
        run_code_action.triggered.connect(self.run_code)
        tools_menu.addAction(run_code_action)

        settings_action = QAction(QIcon.fromTheme(""preferences-system""), ""Ustawienia..."", self)
        settings_action.triggered.connect(self.show_settings_dialog)
        tools_menu.addAction(settings_action)

        # Help menu
        help_menu = menubar.addMenu(""❓ Pomoc"")

        about_action = QAction(""O programie"", self)
        about_action.triggered.connect(self.show_about)
        help_menu.addAction(about_action)


    def create_tool_bar(self):
        self.toolbar = QToolBar(""Główny Pasek Narzędzi"")
        self.addToolBar(Qt.ToolBarArea.TopToolBarArea, self.toolbar)
        self.toolbar.setObjectName(""main_toolbar"") # Add object name for styling

        # Add actions (use the same actions created in the menu bar if possible, or recreate)
        # Recreating ensures they have icons regardless of theme availability
        self.toolbar.addAction(QAction(QIcon.fromTheme(""document-new""), ""Nowy"", self, triggered=self.new_file))
        self.toolbar.addAction(QAction(QIcon.fromTheme(""document-open""), ""Otwórz"", self, triggered=self.open_file_dialog))
        # Connect the toolbar save action to the same slot and set shortcut context
        save_toolbar_action = QAction(QIcon.fromTheme(""document-save""), ""Zapisz"", self, triggered=self.save_file)
        save_toolbar_action.setShortcut(""Ctrl+S"") # Redundant but good practice
        save_toolbar_action.setShortcutContext(Qt.ShortcutContext.WindowShortcut)
        self.toolbar.addAction(save_toolbar_action)

        self.toolbar.addSeparator()

        undo_action = QAction(QIcon.fromTheme(""edit-undo""), ""Cofnij"", self, triggered=self.undo)
        undo_action.setShortcut(""Ctrl+Z"")
        undo_action.setShortcutContext(Qt.ShortcutContext.WidgetWithChildrenShortcut)
        self.toolbar.addAction(undo_action)

        redo_action = QAction(QIcon.fromTheme(""edit-redo""), ""Ponów"", self, triggered=self.redo)
        redo_action.setShortcut(""Ctrl+Y"")
        redo_action.setShortcutContext(Qt.ShortcutContext.WidgetWithChildrenShortcut)
        self.toolbar.addAction(redo_action)

        self.toolbar.addSeparator()

        cut_action = QAction(QIcon.fromTheme(""edit-cut""), ""Wytnij"", self, triggered=self.cut)
        cut_action.setShortcut(""Ctrl+X"")
        cut_action.setShortcutContext(Qt.ShortcutContext.WidgetWithChildrenShortcut)
        self.toolbar.addAction(cut_action)

        copy_action = QAction(QIcon.fromTheme(""edit-copy""), ""Kopiuj"", self, triggered=self.copy)
        copy_action.setShortcut(""Ctrl+C"")
        copy_action.setShortcutContext(Qt.ShortcutContext.WidgetWithChildrenShortcut)
        self.toolbar.addAction(copy_action)

        paste_action = QAction(QIcon.fromTheme(""edit-paste""), ""Wklej"", self, triggered=self.paste)
        paste_action.setShortcut(""Ctrl+V"")
        paste_action.setShortcutContext(Qt.ShortcutContext.WidgetWithChildrenShortcut)
        self.toolbar.addAction(paste_action)

        self.toolbar.addSeparator()

        find_action = QAction(QIcon.fromTheme(""edit-find""), ""Znajdź"", self, triggered=self.find)
        find_action.setShortcut(""Ctrl+F"")
        find_action.setShortcutContext(Qt.ShortcutContext.WindowShortcut)
        self.toolbar.addAction(find_action)

        self.toolbar.addSeparator()

        run_code_action = QAction(QIcon.fromTheme(""system-run""), ""➡️ Uruchom kod"", self, triggered=self.run_code)
        run_code_action.setShortcut(""Ctrl+R"")
        run_code_action.setShortcutContext(Qt.ShortcutContext.WindowShortcut)
        self.toolbar.addAction(run_code_action)

    def apply_theme(self, theme_name):
        self.theme = theme_name
        self.settings[""theme""] = theme_name
        save_settings(self.settings)

        if theme_name == ""dark"":
            main_bg = QColor(""#252526"")
            main_fg = QColor(""#ffffff"")
            menu_bg = QColor(""#252526"")
            menu_fg = QColor(""#ffffff"")
            menu_selected_bg = QColor(""#2d2d30"")
            menu_border = QColor(""#454545"")
            tab_pane_border = QColor(""#454545"")
            tab_pane_bg = QColor(""#1e1e1e"")
            tab_bg = QColor(""#2d2d2d"")
            tab_fg = QColor(""#ffffff"")
            tab_selected_bg = QColor(""#1e1e1e"")
            statusbar_bg = QColor(""#252526"")
            statusbar_fg = QColor(""#ffffff"")
            toolbar_bg = QColor(""#252526"")
            toolbar_fg = QColor(""#ffffff"")
            splitter_handle_bg = QColor(""#252526"")
            lineedit_bg = QColor(""#333333"")
            lineedit_fg = QColor(""#ffffff"")
            lineedit_border = QColor(""#454545"")
            button_bg = QColor(""#3c3c3c"")
            button_fg = QColor(""#ffffff"")
            button_border = QColor(""#5a5a5a"")
            button_hover_bg = QColor(""#4a4a4a"")
            button_pressed_bg = QColor(""#2a2a2a"")
            editor_bg = QColor(""#1e1e1e"")
            editor_fg = QColor(""#d4d4d4"")
            linenum_area_bg = QColor(""#252526"")
            linenum_fg = QColor(""#858585"")
            current_line_bg = QColor(""#2d2d2d"")
            chat_bg = QColor(""#1e1e1e"")
            chat_input_bg = QColor(""#333333"")
            chat_input_fg = QColor(""#ffffff"")
            bubble_user = QColor(""#3a3a3a"")
            bubble_assistant = QColor(""#2d2d2d"")
            bubble_border = QColor(""#454545"")

        else: # light theme
            main_bg = QColor(""#f5f5f5"")
            main_fg = QColor(""#333333"")
            menu_bg = QColor(""#f5f5f5"")
            menu_fg = QColor(""#333333"")
            menu_selected_bg = QColor(""#e5e5e5"")
            menu_border = QColor(""#cccccc"")
            tab_pane_border = QColor(""#cccccc"")
            tab_pane_bg = QColor(""#ffffff"")
            tab_bg = QColor(""#e5e5e5"")
            tab_fg = QColor(""#333333"")
            tab_selected_bg = QColor(""#ffffff"")
            statusbar_bg = QColor(""#f5f5f5"")
            statusbar_fg = QColor(""#333333"")
            toolbar_bg = QColor(""#f5f5f5"")
            toolbar_fg = QColor(""#333333"")
            splitter_handle_bg = QColor(""#f5f5f5"")
            lineedit_bg = QColor(""#ffffff"")
            lineedit_fg = QColor(""#000000"")
            lineedit_border = QColor(""#cccccc"")
            button_bg = QColor(""#e1e1e1"")
            button_fg = QColor(""#000000"")
            button_border = QColor(""#cccccc"")
            button_hover_bg = QColor(""#d1d1d1"")
            button_pressed_bg = QColor(""#c1c1c1"")
            editor_bg = QColor(""#ffffff"")
            editor_fg = QColor(""#000000"")
            linenum_area_bg = QColor(""#eeeeee"")
            linenum_fg = QColor(""#666666"")
            current_line_bg = QColor(""#f0f0f0"")
            chat_bg = QColor(""#ffffff"")
            chat_input_bg = QColor(""#ffffff"")
            chat_input_fg = QColor(""#000000"")
            bubble_user = QColor(""#dcf8c6"")
            bubble_assistant = QColor(""#ffffff"")
            bubble_border = QColor(""#e0e0e0"")

        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, main_bg)
        palette.setColor(QPalette.ColorRole.WindowText, main_fg)
        palette.setColor(QPalette.ColorRole.Base, editor_bg) # Used by QTextEdit background
        palette.setColor(QPalette.ColorRole.Text, editor_fg) # Used by QTextEdit text color
        palette.setColor(QPalette.ColorRole.Button, button_bg)
        palette.setColor(QPalette.ColorRole.ButtonText, button_fg)
        palette.setColor(QPalette.ColorRole.Highlight, QColor(""#0078d4""))
        palette.setColor(QPalette.ColorRole.HighlightedText, QColor(""#ffffff""))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(""#ffffe1"")) # Tooltip background
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(""#000000"")) # Tooltip text


        # Set palette for the application
        QApplication.setPalette(palette)

        # Apply specific stylesheets
        self.setStyleSheet(f""""""
            QMainWindow {{
                background-color: {main_bg.name()};
                color: {main_fg.name()};
            }}
            QMenuBar {{
                background-color: {menu_bg.name()};
                color: {menu_fg.name()};
            }}
            QMenuBar::item {{
                background-color: transparent;
                padding: 5px 10px;
                color: {menu_fg.name()};
            }}
            QMenuBar::item:selected {{
                background-color: {menu_selected_bg.name()};
            }}
            QMenu {{
                background-color: {menu_bg.name()};
                border: 1px solid {menu_border.name()};
                color: {menu_fg.name()};
            }}
            QMenu::item:selected {{
                background-color: {menu_selected_bg.name()};
            }}
            QTabWidget::pane {{
                border: 1px solid {tab_pane_border.name()};
                background: {tab_pane_bg.name()};
            }}
            QTabBar::tab {{
                background: {tab_bg.name()};
                color: {tab_fg.name()};
                padding: 5px;
                border: 1px solid {tab_pane_border.name()};
                border-bottom: none;
                min-width: 80px;
            }}
             QTabBar::tab:top, QTabBar::tab:bottom {{
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
             }}
             QTabBar::tab:left, QTabBar::tab:right {{
                border-top-left-radius: 4px;
                border-bottom-left-radius: 4px;
             }}
            QTabBar::tab:hover {{
                background: {tab_selected_bg.name()};
            }}
            QTabBar::tab:selected {{
                background: {tab_selected_bg.name()};
                border-bottom: 1px solid {tab_selected_bg.name()};
            }}
            QStatusBar {{
                background: {statusbar_bg.name()};
                color: {statusbar_fg.name()};
                border-top: 1px solid {menu_border.name()};
            }}
            QToolBar {{
                background: {toolbar_bg.name()};
                border: none;
                padding: 2px;
                spacing: 5px;
            }}
             QToolButton {{
                padding: 4px;
                border: 1px solid transparent; /* subtle border for hover */
                border-radius: 3px;
             }}
             QToolButton:hover {{
                background-color: {button_hover_bg.name()};
                border-color: {button_border.name()};
             }}
             QToolButton:pressed {{
                background-color: {button_pressed_bg.name()};
                border-color: {button_border.darker(150).name()};
             }}
            QSplitter::handle {{
                background: {splitter_handle_bg.name()};
            }}
            QSplitter::handle:hover {{
                background: {button_hover_bg.name()};
            }}
            QLineEdit {{
                background-color: {lineedit_bg.name()};
                color: {lineedit_fg.name()};
                border: 1px solid {lineedit_border.name()};
                padding: 4px;
                border-radius: 4px;
            }}
            QPushButton {{
                background-color: {button_bg.name()};
                color: {button_fg.name()};
                border: 1px solid {button_border.name()};
                border-radius: 4px;
                padding: 5px 10px;
            }}
            QPushButton:hover {{
                background-color: {button_hover_bg.name()};
                border-color: {button_border.darker(120).name()};
            }}
            QPushButton:pressed {{
                background-color: {button_pressed_bg.name()};
                border-color: {button_border.darker(150).name()};
            }}
            QScrollArea {{
                border: none;
            }}
            #chat_widget {{
                background-color: {chat_bg.name()};
            }}
             QTreeView {{
                background-color: {main_bg.name()};
                color: {main_fg.name()};
                border: 1px solid {tab_pane_border.name()}; /* Add border for separation */
                selection-background-color: {palette.color(QPalette.ColorRole.Highlight).name()};
                selection-color: {palette.color(QPalette.ColorRole.HighlightedText).name()};
            }}
            QTreeView::item:hover {{
                background-color: {menu_selected_bg.name()}; /* Subtle hover effect */
            }}

        """""")

        # Apply theme colors to CodeEditor instances
        for i in range(self.tabs.count()):
            editor = self.tabs.widget(i)
            if isinstance(editor, CodeEditor):
                editor.set_theme_colors(editor_bg, editor_fg, linenum_area_bg, linenum_fg, current_line_bg)

        # Apply theme colors to MessageWidget instances
        for i in range(self.chat_layout.count()):
            item = self.chat_layout.itemAt(i)
            if item and item.widget() and isinstance(item.widget(), MessageWidget):
                message_widget = item.widget()
                message_widget.apply_theme_colors(chat_bg, main_fg, bubble_user, bubble_assistant)

        self.apply_font_size(self.font_size)

    def update_status_bar_message(self, message: str, timeout_ms: int = 3000):
        """"""Displays a temporary message in the status bar.""""""
        if self.statusBar() and self.show_statusbar:
            self.statusBar().showMessage(message, timeout_ms)
            # The timeout handling by showMessage is often sufficient, but a dedicated timer
            # can be used for more complex clearing logic if needed.
            # self._status_timer.stop()
            # self._status_timer.start(timeout_ms)

    def clear_status_bar_message(self):
         """"""Clears the temporary status bar message.""""""
         if self.statusBar() and self.show_statusbar:
              self.statusBar().clearMessage()
              self.update_status_bar() # Restore default status message (line/col)


    def apply_font_size(self, size: int):
        self.font_size = size
        self.settings[""font_size""] = size
        save_settings(self.settings)

        for i in range(self.tabs.count()):
            editor = self.tabs.widget(i)
            if isinstance(editor, CodeEditor):
                editor.set_font_size(size)

        font = self.chat_input.font()
        font.setPointSize(size)
        self.chat_input.setFont(font)
        # Note: MessageWidget text font size is largely controlled by internal stylesheets (10pt, 9pt).

    def update_status_bar(self):
        # Ensure status bar object exists before trying to use it
        if self.statusBar() and self.show_statusbar:
            # If there's a temporary message, don't overwrite it immediately
            if not self.statusBar().currentMessage():
                editor = self.get_current_editor()
                if editor:
                    cursor = editor.textCursor()
                    line = cursor.blockNumber() + 1
                    col = cursor.columnNumber() + 1
                    modified_status = ""*"" if editor.document().isModified() else """"
                    file_name = os.path.basename(getattr(editor, 'file_path', 'Bez tytułu'))
                    self.statusBar().showMessage(f""Plik: {file_name}{modified_status} | Linia: {line}, Kolumna: {col}"")
                else:
                    current_tab_index = self.tabs.currentIndex()
                    if current_tab_index != -1:
                        tab_title = self.tabs.tabText(current_tab_index)
                        self.statusBar().showMessage(f""Gotowy - {tab_title}"")
                    else:
                        self.statusBar().showMessage(""Gotowy"")
        elif self.statusBar(): # Status bar exists but is hidden
             self.statusBar().clearMessage() # Clear any lingering message


    def get_current_editor(self):
        current_widget = self.tabs.currentWidget()
        if current_widget and isinstance(current_widget, CodeEditor):
            return current_widget
        return None

    def setup_editor_context_menu(self, editor):
        """"""Sets up a custom context menu for the CodeEditor instance.""""""
        # Disconnect any default context menu connection first if it existed
        try:
             editor.customContextMenuRequested.disconnect()
        except:
             pass # Ignore if not connected

        editor.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        editor.customContextMenuRequested.connect(lambda pos: self.show_editor_context_menu(pos, editor)) # Pass editor explicitly


    def show_editor_context_menu(self, position, editor):
        """"""Shows a custom context menu for the CodeEditor.""""""
        menu = QMenu(editor)

        undo_action = menu.addAction(""Cofnij"")
        undo_action.setIcon(QIcon.fromTheme(""edit-undo""))
        undo_action.setShortcut(""Ctrl+Z"")
        undo_action.triggered.connect(editor.undo)
        undo_action.setEnabled(editor.document().isUndoAvailable())

        redo_action = menu.addAction(""Ponów"")
        redo_action.setIcon(QIcon.fromTheme(""edit-redo""))
        redo_action.setShortcut(""Ctrl+Y"")
        redo_action.triggered.connect(editor.redo)
        redo_action.setEnabled(editor.document().isRedoAvailable())

        menu.addSeparator()

        cut_action = menu.addAction(""Wytnij"")
        cut_action.setIcon(QIcon.fromTheme(""edit-cut""))
        cut_action.setShortcut(""Ctrl+X"")
        cut_action.triggered.connect(editor.cut)
        cut_action.setEnabled(editor.textCursor().hasSelection())

        copy_action = menu.addAction(""Kopiuj"")
        copy_action.setIcon(QIcon.fromTheme(""edit-copy""))
        copy_action.setShortcut(""Ctrl+C"")
        copy_action.triggered.connect(editor.copy)
        copy_action.setEnabled(editor.textCursor().hasSelection())

        paste_action = menu.addAction(""Wklej"")
        paste_action.setIcon(QIcon.fromTheme(""edit-paste""))
        paste_action.setShortcut(""Ctrl+V"")
        paste_action.triggered.connect(editor.paste)
        clipboard = QApplication.clipboard()
        paste_action.setEnabled(bool(clipboard.text()))

        delete_action = menu.addAction(""Usuń"")
        delete_action.setIcon(QIcon.fromTheme(""edit-delete""))
        delete_action.triggered.connect(lambda: editor.textCursor().removeSelectedText())
        delete_action.setEnabled(editor.textCursor().hasSelection())

        menu.addSeparator()

        select_all_action = menu.addAction(""Zaznacz wszystko"")
        select_all_action.setIcon(QIcon.fromTheme(""edit-select-all""))
        select_all_action.setShortcut(""Ctrl+A"")
        select_all_action.triggered.connect(editor.selectAll)

        menu.exec(editor.viewport().mapToGlobal(position))

    def new_file(self):
        editor = CodeEditor()
        editor.document().contentsChanged.connect(self.update_status_bar)
        editor.cursorPositionChanged.connect(self.update_status_bar)
        editor.document().setModified(False) # New file starts as unmodified

        self.setup_editor_context_menu(editor) # Setup the context menu

        tab_title = ""Bez tytułu""
        # Store file_path as None initially for unsaved files
        editor.file_path = None
        editor.setObjectName(""editor_tab"") # Add object name for styling

        self.tabs.addTab(editor, tab_title)
        self.tabs.setCurrentWidget(editor)

        self.apply_font_size(self.font_size)
        # Re-apply theme to ensure new editor gets correct colors
        self.apply_theme(self.theme)

        self.update_recent_files(None) # Add placeholder for untitled file (or just update menu)
        self.update_status_bar()
        self.update_status_bar_message(""Utworzono nowy plik 'Bez tytułu'."")


    def open_file_dialog(self):
        start_dir = self.workspace if self.workspace and os.path.exists(self.workspace) else QStandardPaths.standardLocations(QStandardPaths.StandardLocation.HomeLocation)[0]

        file_path, _ = QFileDialog.getOpenFileName(self, ""Otwórz plik"", start_dir,
            ""Wszystkie pliki (*);;""
            ""Pliki Pythona (*.py);;""
            ""Pliki tekstowe (*.txt);;""
            ""Pliki CSS (*.css);;""
            ""Pliki HTML (*.html *.htm);;""
            ""Pliki JavaScript (*.js);;""
            ""Pliki GML (*.gml);;""
            ""Pliki JSON (*.json);;""
            ""Pliki Markdown (*.md);;""
            ""Pliki konfiguracyjne (*.ini *.cfg)"")
        if file_path:
            self.open_file(file_path)

    def open_file(self, file_path):
        """"""Opens a single file in a new tab.""""""
        if not file_path or not os.path.exists(file_path):
             QMessageBox.warning(self, ""Błąd"", f""Plik nie znaleziono:\n{file_path}"")
             self.update_status_bar_message(f""Błąd: Plik nie znaleziono ({os.path.basename(file_path)})"")
             return False

        # Check if the file is already open in a tab
        for i in range(self.tabs.count()):
            editor = self.tabs.widget(i)
            if isinstance(editor, CodeEditor) and hasattr(editor, 'file_path') and editor.file_path == file_path:
                self.tabs.setCurrentIndex(i)
                self.update_status_bar_message(f""Przełączono na plik: {os.path.basename(file_path)}"")
                return True

        # If not already open, open the file
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            editor = CodeEditor()
            editor.setPlainText(content)

            editor.document().contentsChanged.connect(self.update_status_bar)
            editor.cursorPositionChanged.connect(self.update_status_bar)
            editor.document().setModified(False) # Newly opened file is not modified

            self.setup_editor_context_menu(editor)

            file_name = os.path.basename(file_path)
            tab_title = file_name

            # Set syntax highlighting based on file extension
            # Get the actual CodeEditor highlighter object
            highlighter = None
            file_extension = os.path.splitext(file_path)[1].lower()
            if file_extension == '.py':
                highlighter = PythonHighlighter(editor.document())
            elif file_extension == '.css':
                highlighter = CSSHighlighter(editor.document())
            elif file_extension in ['.html', '.htm']:
                highlighter = HTMLHighlighter(editor.document())
            elif file_extension == '.js':
                highlighter = JSHighlighter(editor.document())
            elif file_extension == '.gml':
                highlighter = GMLHighlighter(editor.document())
            # Add more extensions/highlighters as needed

            editor.highlighter = highlighter # Assign the created highlighter (can be None)
            if highlighter:
                highlighter.rehighlight()


            editor.file_path = file_path
            editor.setObjectName(""editor_tab"") # Add object name for styling

            self.tabs.addTab(editor, tab_title)
            self.tabs.setCurrentWidget(editor)

            self.update_recent_files(file_path) # Update recent files list

            self.apply_font_size(self.font_size)
            self.apply_theme(self.theme) # Re-apply theme to ensure new editor has correct colors

            self.update_status_bar()
            self.update_status_bar_message(f""Otworzono plik: {os.path.basename(file_path)}"")
            return True
        except Exception as e:
            QMessageBox.warning(self, ""Błąd"", f""Nie można otworzyć pliku '{file_path}':\n{e}"")
            self.update_status_bar_message(f""Błąd otwierania pliku: {e}"")
            return False

    def open_files(self, file_paths: list):
        """"""Opens a list of files.""""""
        if not file_paths:
             return

        for file_path in file_paths:
            # Call the single open_file method for each file in the list
            self.open_file(file_path)


    def save_file(self):
        editor = self.get_current_editor()
        if not editor:
            self.update_status_bar_message(""Brak aktywnego edytora do zapisania."")
            return False # No active editor

        # If editor has a file_path, save to it
        if hasattr(editor, 'file_path') and editor.file_path and os.path.exists(os.path.dirname(editor.file_path) if os.path.dirname(editor.file_path) else '.'):
             # Check if the directory exists, or if it's a new file in the current directory
             file_path = editor.file_path
        else:
            # If no file_path (new file) or path is invalid, use Save As
            return self.save_file_as()

        # Perform the save operation
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(editor.toPlainText())

            editor.document().setModified(False)
            self.update_status_bar()
            self.update_recent_files(file_path)
            self.update_status_bar_message(f""Zapisano plik: {os.path.basename(file_path)}"")
            return True
        except Exception as e:
            QMessageBox.warning(self, ""Błąd"", f""Nie można zapisać pliku '{file_path}':\n{e}"")
            self.update_status_bar_message(f""Błąd zapisywania pliku: {e}"")
            return False

    def save_file_as(self):
        editor = self.get_current_editor()
        if not editor:
            self.update_status_bar_message(""Brak aktywnego edytora do zapisania."")
            return False

        initial_dir = self.workspace if self.workspace and os.path.exists(self.workspace) else QStandardPaths.standardLocations(QStandardPaths.StandardLocation.HomeLocation)[0]
        if hasattr(editor, 'file_path') and editor.file_path and os.path.dirname(editor.file_path):
            initial_dir = os.path.dirname(editor.file_path)

        file_path, _ = QFileDialog.getSaveFileName(self, ""Zapisz plik jako"", initial_dir, ""All Files (*);;Python Files (*.py);;Text Files (*.txt)"")

        if not file_path:
            self.update_status_bar_message(""Zapisywanie anulowane."")
            return False

        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(editor.toPlainText())

            file_name = os.path.basename(file_path)
            index = self.tabs.indexOf(editor)
            self.tabs.setTabText(index, file_name)

            editor.file_path = file_path
            editor.document().setModified(False)
            self.update_status_bar()
            self.update_recent_files(file_path)

            # Update syntax highlighting if extension changed
            highlighter = None
            file_extension = os.path.splitext(file_path)[1].lower()
            if file_extension == '.py':
                highlighter = PythonHighlighter(editor.document())
            elif file_extension == '.css':
                highlighter = CSSHighlighter(editor.document())
            elif file_extension in ['.html', '.htm']:
                highlighter = HTMLHighlighter(editor.document())
            elif file_extension == '.js':
                highlighter = JSHighlighter(editor.document())
            elif file_extension == '.gml':
                highlighter = GMLHighlighter(editor.document())
            # Add more extensions/highlighters as needed
            editor.highlighter = highlighter # Assign the new highlighter
            editor.document().clearFormats() # Clear old highlighting before applying new one
            if highlighter:
                 highlighter.rehighlight()


            self.update_status_bar_message(f""Zapisano plik jako: {os.path.basename(file_path)}"")
            return True
        except Exception as e:
            QMessageBox.warning(self, ""Błąd"", f""Nie można zapisać pliku '{file_path}':\n{e}"")
            self.update_status_bar_message(f""Błąd zapisywania pliku jako: {e}"")
            return False

    def close_tab(self, index):
        editor = self.tabs.widget(index)
        if editor:
            if isinstance(editor, CodeEditor) and editor.document().isModified():
                file_name = os.path.basename(getattr(editor, 'file_path', 'Bez tytułu'))
                reply = QMessageBox.question(self, ""Zapisz zmiany"", f""Czy chcesz zapisać zmiany w '{file_name}' przed zamknięciem?"",
                                             QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No | QMessageBox.StandardButton.Cancel)
                if reply == QMessageBox.StandardButton.Yes:
                    # Need to save the tab before closing. If save fails/cancelled, stop closing.
                    # Temporarily set this tab as current to make save_file work on it.
                    original_index = self.tabs.currentIndex()
                    self.tabs.setCurrentIndex(index)
                    save_success = self.save_file()
                    self.tabs.setCurrentIndex(original_index) # Restore original index
                    if not save_success:
                        return # Stop closing if save failed/cancelled
                elif reply == QMessageBox.StandardButton.Cancel:
                    return # User cancelled closing
                # If reply is No or Yes (and save succeeded), continue closing

            tab_name = self.tabs.tabText(index) # Get name *before* removing tab
            self.tabs.removeTab(index)
            editor.deleteLater()
            self.update_status_bar() # Update status bar as current tab might change
            self.update_status_bar_message(f""Zamknięto zakładkę: {tab_name}"")

    def update_recent_files(self, file_path):
        """"""Updates the list of recent files and the menu.""""""
        # Note: None is passed for untitled files, which shouldn't be added to recent.
        if file_path and isinstance(file_path, str) and os.path.exists(file_path):
            # Normalize path for consistency
            file_path = os.path.normpath(file_path)
            # Remove if already exists to move it to the top
            if file_path in self.recent_files:
                self.recent_files.remove(file_path)

            # Add to the beginning
            self.recent_files.insert(0, file_path)

            # Trim the list if it exceeds max size
            if len(self.recent_files) > RECENT_FILES_MAX:
                self.recent_files = self.recent_files[:RECENT_FILES_MAX]

            # Save the updated list
            self.settings[""recent_files""] = self.recent_files
            save_settings(self.settings)

        # Always update the menu after potentially changing the list
        self.update_recent_files_menu()


    def update_recent_files_menu(self, menu: QMenu = None):
        """"""Updates the 'Ostatnie pliki' menu.""""""
        # Find the menu if not passed
        if menu is None:
             # Iterate through the menu bar actions to find the ""Plik"" menu
             for file_action in self.menuBar().actions():
                 if file_action.text() == ""📄 Plik"" and file_action.menu():
                     # Iterate through the ""Plik"" menu actions to find the ""Ostatnie pliki"" submenu
                     for sub_action in file_action.menu().actions():
                         # Use object name or text for lookup
                         # Ensure the action has a menu before accessing it
                         if sub_action.text() == ""Ostatnie pliki"" and sub_action.menu():
                             menu = sub_action.menu()
                             break
                 if menu: break # Stop searching once found

        if not menu: # Menu not found, cannot update
            print(""Warning: Recent files menu not found."")
            return

        menu.clear()
        # Filter out non-existent files from the stored list before updating the menu
        valid_recent_files = [f for f in self.recent_files if os.path.exists(f)]

        if not valid_recent_files:
            menu.setEnabled(False)
            # Add a dummy action
            disabled_action = QAction(""Brak ostatnio otwieranych plików"", self)
            disabled_action.setEnabled(False)
            menu.addAction(disabled_action)
        else:
            menu.setEnabled(True)
            # Use the filtered list to populate the menu
            for file_path in valid_recent_files:
                 action = QAction(os.path.basename(file_path), self)
                 # Store the file path in the action's data
                 action.setData(file_path)
                 action.triggered.connect(self.open_recent_file)
                 menu.addAction(action)

            # Update settings with the cleaned list
            if valid_recent_files != self.recent_files:
                 self.recent_files = valid_recent_files
                 self.settings[""recent_files""] = self.recent_files
                 save_settings(self.settings)


    def open_recent_file(self):
        action = self.sender()
        if action:
            file_path = action.data()
            if file_path and isinstance(file_path, str) and os.path.exists(file_path):
                self.open_file(file_path)
            else:
                QMessageBox.warning(self, ""Błąd"", f""Ostatni plik nie znaleziono:\n{file_path}"")
                self.update_status_bar_message(f""Błąd: Ostatni plik nie znaleziono ({os.path.basename(file_path)})"")
                # Remove invalid file from recent list
                if file_path in self.recent_files:
                    self.recent_files.remove(file_path)
                    self.settings[""recent_files""] = self.recent_files
                    save_settings(self.settings)
                    self.update_recent_files_menu()


    def open_workspace(self):
        start_dir = self.workspace if self.workspace and os.path.exists(self.workspace) else QStandardPaths.standardLocations(QStandardPaths.StandardLocation.HomeLocation)[0]

        dir_path = QFileDialog.getExistingDirectory(self, ""Otwórz Obszar Roboczy"", start_dir)
        if dir_path:
            self.workspace = dir_path
            self.file_explorer.model.setRootPath(dir_path)
            self.file_explorer.setRootIndex(self.file_explorer.model.index(dir_path))
            self.settings[""workspace""] = dir_path
            save_settings(self.settings)
            self.update_status_bar_message(f""Zmieniono obszar roboczy na: {dir_path}"")

    # Standard editor actions (delegated to current editor)
    def undo(self):
        editor = self.get_current_editor()
        if editor:
             editor.undo()
             self.update_status_bar_message(""Cofnięto ostatnią operację."")


    def redo(self):
        editor = self.get_current_editor()
        if editor:
             editor.redo()
             self.update_status_bar_message(""Ponowiono ostatnią operację."")


    def cut(self):
        editor = self.get_current_editor()
        if editor:
             editor.cut()
             self.update_status_bar_message(""Wycięto zaznaczenie."")


    def copy(self):
        editor = self.get_current_editor()
        if editor:
             editor.copy()
             self.update_status_bar_message(""Skopiowano zaznaczenie."")


    def paste(self):
        editor = self.get_current_editor()
        if editor:
             editor.paste()
             self.update_status_bar_message(""Wklejono zawartość schowka."")


    # Basic find/replace (delegated)
    def find(self):
        editor = self.get_current_editor()
        if editor:
            text, ok = QInputDialog.getText(self, ""Znajdź"", ""Szukaj:"")
            if ok and text:
                cursor = editor.textCursor()
                # Find from current position first
                if not editor.find(text):
                     # If not found from current position, try from the beginning
                     cursor.movePosition(QTextCursor.MoveOperation.Start)
                     editor.setTextCursor(cursor)
                     if not editor.find(text):
                         QMessageBox.information(self, ""Znajdź"", f""'{text}' nie znaleziono."")
                         self.update_status_bar_message(f""Nie znaleziono '{text}'."")
                     else:
                         self.update_status_bar_message(f""Znaleziono pierwsze wystąpienie '{text}'."")
                else:
                     self.update_status_bar_message(f""Znaleziono następne wystąpienie '{text}'."")


    def replace(self):
        editor = self.get_current_editor()
        if editor:
            find_text, ok1 = QInputDialog.getText(self, ""Zamień"", ""Szukaj:"")
            if ok1 and find_text:
                replace_text, ok2 = QInputDialog.getText(self, ""Zamień"", ""Zamień na:"")
                if ok2:
                    # Simple text replacement (replaces all occurrences)
                    text = editor.toPlainText()
                    # Count occurrences before replacing
                    occurrences = text.count(find_text)
                    if occurrences > 0:
                        new_text = text.replace(find_text, replace_text)
                        editor.setPlainText(new_text)
                        editor.document().setModified(True)
                        self.update_status_bar()
                        self.update_status_bar_message(f""Zamieniono {occurrences} wystąpień '{find_text}'."")
                    else:
                         QMessageBox.information(self, ""Zamień"", f""'{find_text}' nie znaleziono."")
                         self.update_status_bar_message(f""Nie znaleziono '{find_text}' do zamiany."")


    # Code execution
    def run_code(self):
        editor = self.get_current_editor()
        if editor:
            code = editor.toPlainText()
            if not code.strip():
                self.add_message(""assistant"", ""Brak kodu do uruchomienia."")
                self.update_status_bar_message(""Brak kodu do uruchomienia."")
                return

            # Add user message to chat history
            self.add_message(""user"", f""Proszę uruchomić ten kod:\n```\n{code}\n```"")

            try:
                # Use a temporary file with a .py extension to allow python interpreter to identify it
                # Ensure the temp directory exists and has write permissions
                temp_dir = tempfile.gettempdir()
                if not os.access(temp_dir, os.W_OK):
                    QMessageBox.warning(self, ""Błąd"", f""Brak uprawnień zapisu w katalogu tymczasowym: {temp_dir}"")
                    self.add_message(""assistant"", f""Błąd: Brak uprawnień zapisu w katalogu tymczasowym."")
                    self.update_status_bar_message(""Błąd: Brak uprawnień zapisu w katalogu tymczasowym."")
                    return

                # Ensure the temp file has a .py extension for the interpreter
                temp_file = tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False, encoding='utf-8', dir=temp_dir)
                temp_file_path = temp_file.name
                temp_file.write(code)
                temp_file.close()


                self.add_message(""assistant"", ""⚙️ Uruchamiam kod..."", {""type"": ""placeholder""})
                self.update_status_bar_message(f""Uruchamiam kod ({os.path.basename(getattr(editor, 'file_path', 'Bez tytułu'))})"")


                # Run the code in a separate process
                # Using sys.executable ensures we use the same Python interpreter running the app
                process = subprocess.Popen([sys.executable, temp_file_path],
                                          stdout=subprocess.PIPE,
                                          stderr=subprocess.PIPE,
                                          text=True, # Decode output as text
                                          encoding='utf-8',
                                          cwd=os.path.dirname(temp_file_path)) # Set working directory


                stdout = """"
                stderr = """"
                try:
                    # Use a slightly longer timeout, maybe 30 seconds?
                    # Or make it configurable. Let's stick to 10 for now.
                    timeout_seconds = 10
                    stdout, stderr = process.communicate(timeout=timeout_seconds)
                    process.wait() # Ensure process is truly finished
                except subprocess.TimeoutExpired:
                    process.kill() # Kill the process if it times out
                    process.wait() # Wait for it to be killed
                    stderr = f""Czas wykonania kodu minął po {timeout_seconds} sekundach. Proces został przerwany.\n{stderr}""
                    self.update_status_bar_message(f""Wykonanie kodu przekroczyło limit czasu ({timeout_seconds}s)."")

                except Exception as proc_err:
                     stderr = f""Błąd wewnętrzny podczas uruchamiania procesu: {proc_err}\n{stderr}""
                     self.update_status_bar_message(f""Błąd wewnętrzny uruchamiania kodu: {proc_err}"")


                # Clean up the temporary file
                try:
                    os.unlink(temp_file_path)
                except OSError as e:
                    print(f""Błąd usuwania pliku tymczasowego {temp_file_path}: {e}"")
                    # Decide if this should be a user-visible error, probably not critical

                # Remove the placeholder message
                self.remove_last_message_widget()

                # Display the output and errors in the chat
                output_message = """"
                if stdout:
                    output_message += f""Wyjście:\n```text\n{stdout.strip()}\n```\n"" # Use 'text' for plain output highlighting
                if stderr:
                    output_message += f""Błędy:\n```text\n{stderr.strip()}\n```\n""

                if output_message:
                    self.add_message(""assistant"", f""Wykonanie kodu zakończone:\n{output_message}"")
                    self.update_status_bar_message(""Wykonanie kodu zakończone."")
                else:
                    self.add_message(""assistant"", ""Kod wykonano bez wyjścia i błędów."")
                    self.update_status_bar_message(""Kod wykonano bez wyjścia/błędów."")

            except FileNotFoundError:
                self.remove_last_message_widget()
                self.add_message(""assistant"", f""Błąd: Interpreter Pythona '{sys.executable}' nie znaleziono."")
                self.update_status_bar_message(f""Błąd: Interpreter Pythona nie znaleziono."")
            except Exception as e:
                self.remove_last_message_widget()
                self.add_message(""assistant"", f""Błąd wykonania kodu: {str(e)}"")
                print(f""Błąd uruchamiania kodu: {traceback.format_exc()}"")
                self.update_status_bar_message(f""Błąd wykonania kodu: {e}"")

    # Visibility toggles (Fixed AttributeErrors by using stored action references)
    def toggle_sidebar(self):
        self.show_sidebar = not self.show_sidebar
        self.sidebar.setVisible(self.show_sidebar)
        self.settings[""show_sidebar""] = self.show_sidebar
        save_settings(self.settings)
        if self.action_toggle_sidebar: # Check if reference exists
            self.action_toggle_sidebar.setChecked(self.show_sidebar)
        self.update_status_bar_message(f""Pasek boczny: {'widoczny' if self.show_sidebar else 'ukryty'}"")

    def toggle_toolbar(self):
        self.show_toolbar = not self.show_toolbar
        self.toolbar.setVisible(self.show_toolbar)
        self.settings[""show_toolbar""] = self.show_toolbar
        save_settings(self.settings)
        if self.action_toggle_toolbar: # Check if reference exists
            self.action_toggle_toolbar.setChecked(self.show_toolbar)
        self.update_status_bar_message(f""Pasek narzędzi: {'widoczny' if self.show_toolbar else 'ukryty'}"")

    def toggle_statusbar(self):
        self.show_statusbar = not self.show_statusbar
        if self.statusBar():
            self.statusBar().setVisible(self.show_statusbar)
        self.settings[""show_statusbar""] = self.show_statusbar
        save_settings(self.settings)
        if self.action_toggle_statusbar: # Check if reference exists
            self.action_toggle_statusbar.setChecked(self.show_statusbar)
        # Status bar message won't appear if status bar is now hidden
        if self.show_statusbar:
            self.update_status_bar_message(f""Pasek stanu: {'widoczny' if self.show_statusbar else 'ukryty'}"")


    def show_settings_dialog(self):
        # Pass active model configurations and current settings
        dialog = SettingsDialog(ACTIVE_MODELS_CONFIG, self.settings, self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            # Update model and API type
            selected_api_type, selected_identifier = dialog.get_selected_model_config()

            model_changed = (selected_api_type != self.current_api_type or selected_identifier != self.current_model_identifier)

            self.current_api_type = selected_api_type
            self.current_model_identifier = selected_identifier
            self.settings[""api_type""] = self.current_api_type
            self.settings[""model_identifier""] = self.current_model_identifier

            # Update Mistral key
            if HAS_MISTRAL:
                new_mistral_key = dialog.get_mistral_api_key()
                key_changed = (new_mistral_key != self.mistral_api_key)
                self.mistral_api_key = new_mistral_key
                self.settings[""mistral_api_key""] = self.mistral_api_key
            else:
                 key_changed = False # Key couldn't change if Mistral isn't supported

            save_settings(self.settings)

            # Inform user about settings changes
            status_messages = []
            if model_changed:
                display_name = next((name for api_type, identifier, name in ACTIVE_MODELS_CONFIG if api_type == self.current_api_type and identifier == self.current_model_identifier), self.current_model_identifier)
                status_messages.append(f""Model AI zmieniono na '{display_name}'."")
            if key_changed:
                 status_messages.append(f""Ustawienia klucza API Mistral zaktualizowane."")

            new_theme = dialog.get_selected_theme()
            if new_theme != self.theme:
                self.apply_theme(new_theme)
                status_messages.append(f""Motyw zmieniono na '{new_theme}'."")


            new_font_size = dialog.get_font_size()
            if new_font_size != self.font_size:
                self.apply_font_size(new_font_size)
                status_messages.append(f""Rozmiar czcionki zmieniono na {new_font_size}."")


            ui_visibility = dialog.get_ui_visibility()
            if ui_visibility[""show_sidebar""] != self.show_sidebar:
                self.toggle_sidebar() # This call updates settings and status bar message internally
            if ui_visibility[""show_toolbar""] != self.show_toolbar:
                self.toggle_toolbar() # This call updates settings and status bar message internally
            if ui_visibility[""show_statusbar""] != self.show_statusbar:
                self.toggle_statusbar() # This call updates settings and status bar message internally


            if status_messages:
                 self.update_status_bar_message(""Ustawienia zaktualizowane: "" + ""; "".join(status_messages), 5000)
            else:
                 self.update_status_bar_message(""Ustawienia zapisano."")


    def show_about(self):
        QMessageBox.about(self, ""Informacje o Edytorze Kodu AI"",
                          ""<h2>Edytor Kodu AI</h2>""
                          ""<p>Prosty edytor kodu z integracją czatu AI.</p>""
                          ""<p>Wykorzystuje API Google Gemini i Mistral do pomocy AI.</p>""
                          ""<p>Wersja 1.1</p>""
                          ""<p>Stworzony przy użyciu PyQt6, google-generativeai i mistralai</p>"")
        self.update_status_bar_message(""Wyświetlono informacje o programie."")


    # --- Chat Message Handling ---
    def add_message(self, role: str, content: str, metadata: dict = None):
        # Add message to internal history (excluding placeholders, errors, empty)
        if metadata is None or metadata.get(""type"") not in [""placeholder"", ""error"", ""empty_response""]:
            # Store clean history for API calls
            self.chat_history.append((role, content, metadata))
            # Limit history size
            HISTORY_LIMIT = 20 # Keep a reasonable history size
            if len(self.chat_history) > HISTORY_LIMIT:
                self.chat_history = self.chat_history[len(self.chat_history) - HISTORY_LIMIT:]

        message_widget = MessageWidget(role, content, metadata=metadata, parent=self.chat_widget)

        # Apply current theme colors
        if self.theme == ""dark"":
            bubble_user_color = QColor(""#3a3a3a"")
            bubble_assistant_color = QColor(""#2d2d2d"")
            main_fg_color = QColor(""#ffffff"")
        else: # light theme
            bubble_user_color = QColor(""#dcf8c6"")
            bubble_assistant_color = QColor(""#ffffff"")
            main_fg_color = QColor(""#333333"")

        message_widget.apply_theme_colors(self.chat_widget.palette().color(QPalette.ColorRole.Window), main_fg_color, bubble_user_color, bubble_assistant_color)

        # Add the widget to the chat layout, keeping the stretch item at the end
        # Find the stretch item
        stretch_item = None
        if self.chat_layout.count() > 0:
             last_item = self.chat_layout.itemAt(self.chat_layout.count() - 1)
             if last_item and last_item.spacerItem():
                  stretch_item = self.chat_layout.takeAt(self.chat_layout.count() - 1)

        self.chat_layout.addWidget(message_widget)

        # Re-add the stretch item if found
        if stretch_item:
             self.chat_layout.addItem(stretch_item)
        elif self.chat_layout.count() == 1: # If this is the very first message and no stretch was added yet
             self.chat_layout.addStretch(1)


        if message_widget.is_placeholder:
            self.current_placeholder_widget = message_widget

        QTimer.singleShot(50, self.scroll_chat_to_bottom)

    def remove_last_message_widget(self):
        if self.chat_layout.count() > 1: # Need at least 1 widget + 1 stretch
            widget_to_remove = None
            # Find the last widget item before the stretch
            for i in reversed(range(self.chat_layout.count())):
                item = self.chat_layout.itemAt(i)
                if item and item.widget():
                    widget_to_remove = item.widget()
                    break

            if widget_to_remove:
                self.chat_layout.removeWidget(widget_to_remove)
                widget_to_remove.deleteLater()

            self.current_placeholder_widget = None

    def scroll_chat_to_bottom(self):
        self.chat_scroll.verticalScrollBar().setValue(self.chat_scroll.verticalScrollBar().maximum())

    def send_message(self):
        if self._is_processing:
            return

        msg = self.chat_input.text().strip()
        if not msg:
            return

        self._is_processing = True
        self.add_message(""user"", msg, None)

        self.chat_input.clear()
        self.chat_input.setPlaceholderText(""Czekam na odpowiedź..."")
        self.send_button.setEnabled(False)
        self.chat_input.setEnabled(False)
        self.update_status_bar_message(""Wysyłam zapytanie do modelu AI..."")


        # Stop any running worker thread
        if self.worker_thread and self.worker_thread.isRunning():
            print(""Stopping existing worker thread..."")
            self.worker.stop()
            if not self.worker_thread.wait(1000): # Wait up to 1 second
                print(""Worker thread did not stop cleanly, terminating."")
                self.worker_thread.terminate()
                self.worker_thread.wait()
            print(""Worker thread stopped."")

        # Determine which worker to use based on selected API type
        api_type = self.current_api_type
        model_identifier = self.current_model_identifier
        worker = None

        if api_type == ""gemini"" and HAS_GEMINI:
            api_key = GEMINI_API_KEY_GLOBAL # Use the globally loaded Gemini key
            if not api_key:
                 self.handle_error(""Klucz API Google Gemini nie znaleziono. Ustaw go w pliku .api_key lub w ustawieniach."")
                 self._is_processing = False # Reset state
                 self.send_button.setEnabled(True)
                 self.chat_input.setEnabled(True)
                 self.chat_input.setPlaceholderText(""Wpisz wiadomość tutaj..."")
                 return
            worker = GeminiWorker(api_key, msg, list(self.chat_history), model_identifier)

        elif api_type == ""mistral"" and HAS_MISTRAL:
            api_key = self.mistral_api_key # Use the key from settings
            if not api_key:
                 self.handle_error(""Klucz API Mistral nie ustawiono w ustawieniach."")
                 self._is_processing = False # Reset state
                 self.send_button.setEnabled(True)
                 self.chat_input.setEnabled(True)
                 self.chat_input.setPlaceholderText(""Wpisz wiadomość tutaj..."")
                 return
            worker = MistralWorker(api_key, msg, list(self.chat_history), model_identifier)
        else:
            # Check if the selected model type is ""none"" (fallback when no APIs are installed)
            if api_type == ""none"":
                 self.handle_error(""Brak dostępnych modeli AI. Proszę zainstalować obsługiwane biblioteki API."")
            else:
                 self.handle_error(f""Wybrany model '{model_identifier}' (API '{api_type}') nie jest obsługiwany lub brakuje zainstalowanych bibliotek."")

            self._is_processing = False # Reset state
            self.send_button.setEnabled(True)
            self.chat_input.setEnabled(True)
            self.chat_input.setPlaceholderText(""Wpisz wiadomość tutaj..."")
            return


        self.worker = worker # Store the current worker
        self.worker_thread = QThread()
        self.worker.moveToThread(self.worker_thread)

        self.worker.response_chunk.connect(self.handle_response_chunk)
        self.worker.response_complete.connect(self.handle_response_complete)
        self.worker.error.connect(self.handle_error)

        self.worker_thread.started.connect(self.worker.run)
        self.worker.finished.connect(self.worker_thread.quit)
        self.worker.finished.connect(self.worker.deleteLater)
        self.worker_thread.finished.connect(self.worker_thread.deleteLater)

        self.current_response_content = """"
        display_name = next((name for t, i, name in ACTIVE_MODELS_CONFIG if t == api_type and i == model_identifier), model_identifier)
        self.add_message(""assistant"", f""⚙️ Przetwarzam z użyciem '{display_name}'..."", {""type"": ""placeholder""})

        self.worker_thread.start()

    def handle_response_chunk(self, chunk: str):
        self.current_response_content += chunk
        if self.current_placeholder_widget:
            self.current_placeholder_widget.update_placeholder_text(self.current_response_content)
        self.scroll_chat_to_bottom()

    def handle_response_complete(self):
        if self.current_placeholder_widget:
            self.remove_last_message_widget()

        final_content = self.current_response_content.strip()
        if final_content:
            self.add_message(""assistant"", self.current_response_content, None)
        else:
            self.add_message(""assistant"", ""Otrzymano pustą odpowiedź od modelu."", {""type"": ""empty_response""})

        self.current_response_content = """"
        self.send_button.setEnabled(True)
        self.chat_input.setEnabled(True)
        self.chat_input.setPlaceholderText(""Wpisz wiadomość tutaj..."")
        self.chat_input.setFocus()
        self._is_processing = False
        self.scroll_chat_to_bottom()
        self.update_status_bar_message(""Odpowiedź AI zakończona."")


    def handle_error(self, error_message: str):
        if self.current_placeholder_widget:
            self.remove_last_message_widget()

        error_styled_message = f""<span style='color: #cc0000; font-weight: bold;'>Błąd API:</span> {error_message}""
        self.add_message(""assistant"", error_styled_message, {""type"": ""error""})

        self.send_button.setEnabled(True)
        self.chat_input.setEnabled(True)
        self.chat_input.setPlaceholderText(""Wpisz wiadomość tutaj..."")
        self.chat_input.setFocus()
        self._is_processing = False
        self.current_response_content = """"
        self.scroll_chat_to_bottom()
        self.update_status_bar_message(f""Błąd API: {error_message[:50]}..."") # Truncate message for status bar

    def closeEvent(self, event):
        # Stop the worker thread
        if self.worker_thread and self.worker_thread.isRunning():
            self.worker.stop()
            if not self.worker_thread.wait(3000): # Wait up to 3 seconds
                print(""Worker thread did not finish after stop signal, terminating."")
                self.worker_thread.terminate()
                self.worker_thread.wait()

        # Check for unsaved files
        unsaved_tabs = []
        for i in range(self.tabs.count()):
            editor = self.tabs.widget(i)
            if isinstance(editor, CodeEditor) and editor.document().isModified():
                 unsaved_tabs.append(i)

        if unsaved_tabs:
            # Ask about saving all unsaved tabs
            reply = QMessageBox.question(self, ""Zapisz zmiany"", f""Masz niezapisane zmiany w {len(unsaved_tabs)} plikach.\nCzy chcesz zapisać zmiany przed wyjściem?"",
                                         QMessageBox.StandardButton.SaveAll | QMessageBox.StandardButton.Discard | QMessageBox.StandardButton.Cancel)

            if reply == QMessageBox.StandardButton.Cancel:
                event.ignore() # Stop closing
                self.update_status_bar_message(""Zamykanie anulowane."")
                return
            elif reply == QMessageBox.StandardButton.SaveAll:
                save_success = True
                # Iterate over unsaved tabs and try to save each one
                for index in unsaved_tabs:
                     editor = self.tabs.widget(index) # Get the editor again, index might change if tabs are closed during save
                     if editor and isinstance(editor, CodeEditor) and editor.document().isModified():
                          # Temporarily switch to the tab to make save_file work correctly
                          original_index = self.tabs.currentIndex()
                          self.tabs.setCurrentIndex(index)
                          current_save_success = self.save_file() # This updates status bar
                          self.tabs.setCurrentIndex(original_index) # Restore original index

                          if not current_save_success:
                               save_success = False
                               # If any save fails/cancelled, stop the whole process
                               event.ignore()
                               self.update_status_bar_message(""Zamykanie przerwane z powodu błędu zapisu."")
                               return # Stop the loop and closing process

                if save_success:
                     event.accept() # Continue closing if all saves succeeded
                else:
                     # This path should ideally not be reached due to the 'return' above,
                     # but as a safeguard:
                     event.ignore()
                     self.update_status_bar_message(""Zamykanie przerwane z powodu błędu zapisu."") # Redundant but safe
                     return

            elif reply == QMessageBox.StandardButton.Discard:
                # Discard changes and close all tabs
                # We need to close tabs in reverse order to avoid index issues
                for i in reversed(unsaved_tabs):
                    self.tabs.removeTab(i) # Remove tab without saving check

                event.accept() # Continue closing
                self.update_status_bar_message(""Zamknięto pliki bez zapisywania zmian."")


        else:
             # No unsaved tabs, just accept the close event
             event.accept()


# --- Main Application Entry Point ---

if __name__ == ""__main__"":
    # Enable High DPI scaling
    QGuiApplication.setHighDpiScaleFactorRoundingPolicy(Qt.HighDpiScaleFactorRoundingPolicy.PassThrough)

    app = QApplication(sys.argv)
    app.setApplicationName(""Edytor Kodu AI"")
    app.setOrganizationName(""YourOrganization"")

    # Initialize icon theme if available
    # QIcon.setThemeName(""breeze-dark"") # Example theme, requires icon theme installed

    try:
        main_window = CodeEditorWindow()
        main_window.show()
        sys.exit(app.exec())
    except Exception as app_error:
        print(f""Wystąpił nieoczekiwany błąd podczas uruchamiania aplikacji:\n{app_error}"")
        traceback.print_exc()
        # Ensure message box is shown even if app failed to initialize fully
        try:
            QMessageBox.critical(None, ""Błąd uruchomienia aplikacji"", f""Wystąpił nieoczekiwany błąd podczas uruchomienia aplikacji:\n{app_error}\n\nSprawdź konsolę, aby uzyskać szczegóły."")
        except Exception as mb_error:
            print(f""Could not show error message box: {mb_error}"")
        sys.exit(1)"
8Cc1kZ6s,String Pureness,Andonoff,Python,Sunday 18th of May 2025 08:18:49 AM CDT,"number_of_strings = int(input())

for current_string in range(number_of_strings):
    current_string = input()

    if "","" in current_string \
        or ""."" in current_string \
        or ""_"" in current_string:

        print(f""{current_string} is not pure!"")
    else:
        print(f""{current_string} is pure."")"
JNPQVS4h,Download Test,Fraeric123,Lua,Sunday 18th of May 2025 07:55:15 AM CDT,"local args = {...}

-- Kontrola, jestli byl zadán alespoň 1 argument (např. URL)
if not args[1] then
  print(""Použití: download <url> [soubor]"")
  os.exit(1)
end

local url = args[1]
local outputFile = args[2] or ""downloaded.lua""  -- Volitelný název výstupního souboru

local component = require(""component"")
local internet = component.internet

print(""Stahuji z: "" .. url)

local response = internet.request(url)
local isGood, err = pcall(function()
  local file, err = io.open(outputFile, ""w"")
  if not file then error(err) end
  for chunk in response do
    file:write(chunk)
  end
  file:close()
end)

if isGood then
  print(""Uloženo jako: "" .. outputFile)
else
  io.stderr:write(""Chyba při stahování:\n"")
  io.stderr:write(err .. ""\n"")
  os.exit(1)
end
"
EmqTyqh0,geometric-acceptance,Aurox_,C,Sunday 18th of May 2025 07:49:39 AM CDT,"#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

#define ARG_NUM 4

double ran_cos(void);

int main(int argc, char *argv[ARG_NUM]) {
    double r, d, cos_theta, cos_theta_crit, ratio, expected_ratio;
    int n;
    unsigned int counts, i;
    srand(time(NULL));

    if (argc != ARG_NUM) {
        fprintf(stderr, ""Usage: %s <number of points> <radius> <distance>\n"", argv[0]);
        return 1;
    }

    n = atoi(argv[1]);
    r = atof(argv[2]);
    d = atof(argv[3]);

    if (n <= 0) {
        fprintf(stderr, ""Number of points must be a positive integer.\n"");
        return 1;
    }
    if (r <= 0 || d <= 0) {
        fprintf(stderr, ""Radius and distance must be positive numbers.\n"");
        return 1;
    }

    
    cos_theta_crit = d / sqrt(r * r + d * d);
    printf(""Critical cos(theta): %f\n"", cos_theta_crit);

    for (i = 0, counts = 0; i < n; i++) {
        cos_theta = ran_cos();
        if (cos_theta > cos_theta_crit) {
            counts++;
        }
    }
    ratio = ((float)counts) / n;
    expected_ratio = 0.5 * (1 - cos_theta_crit);

    printf(""Total points: %d\nTotal hits: %d\nRatio: %.6f\nExpected ratio: %.6f\n"", n, counts, ratio, expected_ratio);

    return 0;
}

double ran_cos(void) {
    return 1 - 2 * ((double)rand() / RAND_MAX);
}"
8nbWa7Zf,OnOffSwitch,Fraeric123,Lua,Sunday 18th of May 2025 07:02:35 AM CDT,"local component = require(""component"")
local sides = require(""sides"")
local term = require(""term"")

local outputSide = sides.top
local rsAddress = nil

for address, ctype in component.list(""redstone"") do
   	rsAddress = address
	break
end    

if rsAddress == nil then
    print(""No redstone IO"")
    exit()
end

local rs = component.proxy(rsAddress)

function zapnout()
    term.clear()
    rs.setOutput(outputSide, 15)
    print(""Redstone zapnut."")
    os.sleep(0.5)
    menu()
end

function vypnout()
    term.clear()
    rs.setOutput(outputSide, 0)
    print(""Redstone vypnut."")
    os.sleep(0.5)
    menu()
end

function menu()
    term.clear()
	print(""Redstone ovládání"")
	print(""1 - Zapnout"")
	print(""2 - Vypnout"")
    
    local input = io.read()
    if input == ""1"" then
        zapnout()
    elseif input == ""2"" then
        vypnout()
    else
        print(""Neplatná volba."")
    end
end

menu()
"
zdrYj8qh,Untitled,rubiin,JavaScript,Sunday 18th of May 2025 06:21:37 AM CDT,"15-6000, 1 week-4500"
anHBQg0A,dataNone,TestGuy1,JSON,Sunday 18th of May 2025 06:00:20 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: '49259a9c69f046de10664ef08f6d0b0eff3052f5e84c0c30badcfa059768d0ddb10686c0dadc538f4c9256a7f381f3d5983bc27ebe40fff5b0ca2d1e936e816092108aabc2aca9c1396eb781c4c1fe7f03a2758734488daec3f1779be9924770c9c682dd90b9926c28c97bef31a291844a5c7289d5a1d82ad3d64407f02e61ec',
  otherdata: [
    '841c202f1ae3fbbb38440cba44c3f6ec',
    '0920f6ae77b7641af8e2745b0ce39704',
    '37d398cfce77d70f5a45b1289f4715e5',
    '3fccfa629fc1f0a66dd7ef74e50a4920',
    '765472ca44f1587a357a7b2494f50520',
    '0a91abdb9fc3f954e317a2d20662c924',
    '509d664e553b431f850d5295b781b2fa',
    '76562617e06b7202b4a45a771eedb901'
  ]
}"
4jjBfU6y,Untitled,rgruber,JavaScript,Sunday 18th of May 2025 05:38:10 AM CDT,"// https://rapiddns.io/subdomain/krone.at?full=1
[...document.getElementById(""table"").tBodies[0].childNodes].map(v=>v.innerText).filter(Boolean).map(v=>v.split(""\t"")).filter(v=>v[3]!='AAAA')"
7N49mCds,Untitled,PaffcioStudio,Lua,Sunday 18th of May 2025 05:10:00 AM CDT,"import sys
import os
import json
import subprocess
import re
import platform
import shutil # Do kopiowania plików
import shlex # Do bezpiecznego formatowania komend
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QSplitter, QTreeView, QTabWidget, QPlainTextEdit,
    QPushButton, QLineEdit, QFileDialog, QMenuBar, QToolBar, QStatusBar,
    QMessageBox, QMenu, QStyleFactory, QDialog, QFormLayout,
    QLabel, QDialogButtonBox, QComboBox, QToolButton,
    QInputDialog, QSpinBox, QSizePolicy, QAbstractItemView,
    QFrame # Dodano do okna ustawień
)
from PyQt6.QtGui import (
    QIcon, QAction, QKeySequence, QTextCharFormat, QFont,
    QSyntaxHighlighter, QTextDocument, QColor, QFileSystemModel,
    QDesktopServices, # Do otwierania plików w domyślnych aplikacjach
    QPalette # Do motywów
)
from PyQt6.QtCore import (
    QDir, Qt, QProcess, QSettings, QFileInfo, QThread, pyqtSignal, QTimer, QSize,
    QStandardPaths, QUrl, QLocale, QCoreApplication, QProcessEnvironment
)
try:
    import qtawesome as qta
except ImportError:
    qta = None
    print(""Zainstaluj qtawesome ('pip install qtawesome') dla lepszych ikon."", file=sys.stderr)
APP_DIR = os.path.dirname(os.path.abspath(__file__))
DATA_DIR = os.path.join(APP_DIR, 'data')
PROJECTS_DIR = os.path.join(APP_DIR, 'projects')
SETTINGS_FILE = os.path.join(DATA_DIR, 'settings.json')
RECENTS_FILE = os.path.join(DATA_DIR, 'recents.json')
os.makedirs(DATA_DIR, exist_ok=True)
os.makedirs(PROJECTS_DIR, exist_ok=True)
FORMAT_DEFAULT = QTextCharFormat()
FORMAT_KEYWORD = QTextCharFormat()
FORMAT_KEYWORD.setForeground(QColor(""#000080"")) # Navy
FORMAT_STRING = QTextCharFormat()
FORMAT_STRING.setForeground(QColor(""#008000"")) # Green
FORMAT_COMMENT = QTextCharFormat()
FORMAT_COMMENT.setForeground(QColor(""#808080"")) # Gray
FORMAT_COMMENT.setFontItalic(True)
FORMAT_FUNCTION = QTextCharFormat()
FORMAT_FUNCTION.setForeground(QColor(""#0000FF"")) # Blue
FORMAT_CLASS = QTextCharFormat()
FORMAT_CLASS.setForeground(QColor(""#A52A2A"")) # Brown
FORMAT_CLASS.setFontWeight(QFont.Weight.Bold)
FORMAT_NUMBERS = QTextCharFormat()
FORMAT_NUMBERS.setForeground(QColor(""#FF0000"")) # Red
FORMAT_OPERATOR = QTextCharFormat()
FORMAT_OPERATOR.setForeground(QColor(""#A62929"")) # Dark Red
FORMAT_BUILTIN = QTextCharFormat()
FORMAT_BUILTIN.setForeground(QColor(""#008080"")) # Teal
FORMAT_SECTION = QTextCharFormat() # Dla sekcji w INI
FORMAT_SECTION.setForeground(QColor(""#800080"")) # Purple
FORMAT_SECTION.setFontWeight(QFont.Weight.Bold)
FORMAT_PROPERTY = QTextCharFormat() # Dla kluczy/właściwości w INI/JSON
FORMAT_PROPERTY.setForeground(QColor(""#B8860B"")) # DarkGoldenrod
HIGHLIGHTING_RULES = {
    'python': {
        'keywords': ['and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else',
                     'except', 'False', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'None',
                     'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'True', 'try', 'while', 'with', 'yield'],
        'builtins': ['print', 'len', 'range', 'list', 'dict', 'tuple', 'set', 'str', 'int', 'float', 'bool', 'open', 'isinstance'],
        'patterns': [
            (r'\b[A-Za-z_][A-Za-z0-9_]*\s*\(', FORMAT_FUNCTION), # Funkcje (proste wykrycie, litera/podkreślnik na początku)
            (r'\bclass\s+([A-Za-z_][A-Za-z0-9_]*)\b', FORMAT_CLASS), # Klasy
            (r'\b\d+(\.\d*)?\b', FORMAT_NUMBERS), # Liczby
            (r'[+\-*/=<>!&|]', FORMAT_OPERATOR), # Operatory
            (r'"".*?""', FORMAT_STRING), # Stringi w cudzysłowach podwójnych
            (r""'.*?'"", FORMAT_STRING), # Stringi w cudzysłowach pojedynczych
            (r'#.*', FORMAT_COMMENT), # Komentarze liniowe
        ]
    },
    'javascript': {
        'keywords': ['abstract', 'arguments', 'await', 'boolean', 'break', 'byte', 'case', 'catch', 'char', 'class', 'const', 'continue',
                     'debugger', 'default', 'delete', 'do', 'double', 'else', 'enum', 'eval', 'export', 'extends', 'false', 'final',
                     'finally', 'float', 'for', 'function', 'goto', 'if', 'implements', 'import', 'in', 'instanceof', 'int', 'interface',
                     'let', 'long', 'native', 'new', 'null', 'package', 'private', 'protected', 'public', 'return', 'short', 'static',
                     'super', 'switch', 'synchronized', 'this', 'throw', 'throws', 'transient', 'true', 'try', 'typeof', 'var', 'void',
                     'volatile', 'while', 'with', 'yield'],
         'builtins': ['console', 'log', 'warn', 'error', 'info', 'Math', 'Date', 'Array', 'Object', 'String', 'Number', 'Boolean', 'RegExp', 'JSON', 'Promise', 'setTimeout', 'setInterval'], # Przykładowe
        'patterns': [
            (r'\b[A-Za-z_][A-Za-z0-9_]*\s*\(', FORMAT_FUNCTION), # Funkcje (proste wykrycie)
             (r'\bclass\s+([A-Za-z_][A-Za-z0-9_]*)\b', FORMAT_CLASS), # Klasy
            (r'\b\d+(\.\d*)?\b', FORMAT_NUMBERS), # Liczby
            (r'[+\-*/=<>!&|]', FORMAT_OPERATOR), # Operatory
            (r'"".*?""', FORMAT_STRING), # Stringi w cudzysłowach podwójnych
            (r""'.*?'"", FORMAT_STRING), # Stringi w cudzysłowach pojedynczych
            (r'//.*', FORMAT_COMMENT), # Komentarze liniowe
        ]
    },
     'html': {
        'keywords': [], # HTML nie ma tradycyjnych słów kluczowych w ten sposób
        'builtins': [], # Encje HTML można potraktować jako builtins
        'patterns': [
            (r'<[^>]+>', FORMAT_KEYWORD), # Tagi HTML (uproszczone, bez atrybutów)
            (r'[a-zA-Z0-9_-]+\s*=', FORMAT_OPERATOR), # Znaki '=' w atrybutach
            (r'"".*?""', FORMAT_STRING), # Wartości atrybutów
            (r""'.*?'"", FORMAT_STRING), # Wartości atrybutów
             (r'&[a-zA-Z0-9]+;', FORMAT_BUILTIN), # Encje HTML
            (r'<!--.*?-->', FORMAT_COMMENT, re.DOTALL), # Komentarze (z re.DOTALL, aby objęły wiele linii)
        ]
    },
    'css': {
        'keywords': [],
        'builtins': [], # Selektory ID
        'patterns': [
            (r'\.[a-zA-Z0-9_-]+', FORMAT_CLASS), # Selektory klas
            (r'#[a-zA-Z0-9_-]+', FORMAT_BUILTIN), # Selektory ID
            (r'[a-zA-Z0-9_-]+\s*:', FORMAT_KEYWORD), # Właściwości CSS
            (r';', FORMAT_OPERATOR), # Średniki
            (r'\{|\}', FORMAT_OPERATOR), # Nawiasy klamrowe
             (r'\(|\)', FORMAT_OPERATOR), # Nawiasy okrągłe (np. w rgb())
            (r'\b\d+(\.\d*)?(px|em|%|vh|vw|rem|pt|cm|mm)?\b', FORMAT_NUMBERS), # Liczby z jednostkami
             (r'#[0-9a-fA-F]{3,6}', FORMAT_NUMBERS), # Kolory HEX
            (r'"".*?""', FORMAT_STRING), # Wartości stringów
            (r""'.*?'"", FORMAT_STRING), # Wartości stringów
        ]
    },
    'c++': {
         'keywords': ['alignas', 'alignof', 'and', 'and_eq', 'asm', 'atomic_cancel', 'atomic_commit', 'atomic_noexcept', 'auto',
                     'bitand', 'bitor', 'bool', 'break', 'case', 'catch', 'char', 'char8_t', 'char16_t', 'char32_t', 'class',
                     'compl', 'concept', 'const', 'consteval', 'constexpr', 'constinit', 'const_cast', 'continue', 'co_await',
                     'co_return', 'decltype', 'default', 'delete', 'do', 'double', 'dynamic_cast', 'else', 'enum',
                     'explicit', 'export', 'extern', 'false', 'float', 'for', 'friend', 'goto', 'if', 'inline', 'int', 'long',
                     'mutable', 'namespace', 'new', 'noexcept', 'not', 'not_eq', 'nullptr', 'operator', 'or', 'or_eq', 'private',
                     'protected', 'public', 'reflexpr', 'register', 'reinterpret_cast', 'requires', 'return', 'short', 'signed',
                     'sizeof', 'static', 'static_assert', 'static_cast', 'struct', 'switch', 'synchronized', 'template',
                     'this', 'thread_local', 'throw', 'true', 'try', 'typedef', 'typeid', 'typename', 'union', 'unsigned',
                     'using', 'virtual', 'void', 'volatile', 'wchar_t', 'while', 'xor', 'xor_eq'],
         'builtins': ['cout', 'cin', 'endl', 'string', 'vector', 'map', 'set', 'array', 'queue', 'stack', 'pair', 'algorithm', 'iostream', 'fstream', 'sstream', 'cmath', 'cstdlib', 'cstdio', 'ctime'], # Przykładowe popularne
         'patterns': [
             (r'\b[A-Za-z_][A-Za-z0-9_]*\s*\(', FORMAT_FUNCTION), # Funkcje (proste wykrycie)
             (r'\bclass\s+([A-Za-z_][A-Za-z0-9_]*)\b', FORMAT_CLASS), # Klasy
             (r'\bstruct\s+([A-Za-z_][A-Za-z0-9_]*)\b', FORMAT_CLASS), # Struktury
             (r'\b\d+(\.\d*)?\b', FORMAT_NUMBERS), # Liczby
             (r'[+\-*/=<>!&|%^~?:]', FORMAT_OPERATOR), # Operatory
             (r'"".*?""', FORMAT_STRING), # Stringi w cudzysłowach podwójnych
             (r""'.*?'"", FORMAT_STRING), # Stringi w cudzysłowach pojedynczych (pojedyncze znaki)
             (r'//.*', FORMAT_COMMENT), # Komentarze liniowe
         ]
    },
    'ini': { # Nowe reguły dla INI
        'keywords': [], # Brak tradycyjnych słów kluczowych
        'builtins': [], # Brak typowych builtins
        'patterns': [
            (r'^\[.*?\]', FORMAT_SECTION), # Sekcje [section]
            (r'^[a-zA-Z0-9_-]+\s*=', FORMAT_PROPERTY), # Klucze property=
            (r';.*', FORMAT_COMMENT), # Komentarze po średniku
            (r'#.*', FORMAT_COMMENT), # Komentarze po krzyżyku
            (r'[+\-*/=<>!&|]', FORMAT_OPERATOR), # Operatory (np. =)
             (r'=\s*"".*?""', FORMAT_STRING), # ""value""
             (r""=\s*'.*?'"", FORMAT_STRING), # 'value'
             (r'=\s*[^;#""\'].*', FORMAT_STRING), # value without quotes or comments/sections
        ]
    },
    'json': { # Nowe reguły dla JSON
        'keywords': ['true', 'false', 'null'], # Literały JSON
        'builtins': [], # Brak typowych builtins
        'patterns': [
            (r'""(?:[^""\\]|\\.)*""\s*:', FORMAT_PROPERTY), # Klucze w cudzysłowach z następującym ':'
            (r'"".*?""', FORMAT_STRING), # Wartości stringów (muszą być po kluczach, żeby nie nadpisać klucza)
            (r'\b-?\d+(\.\d+)?([eE][+-]?\d+)?\b', FORMAT_NUMBERS), # Liczby
            (r'\{|\}|\[|\]|:|,', FORMAT_OPERATOR), # Nawiasy, dwukropek, przecinek
        ]
    }
}
class CodeSyntaxHighlighter(QSyntaxHighlighter):
    def __init__(self, parent: QTextDocument, language: str):
        super().__init__(parent)
        self._language = language.lower()
        self._rules = []
        lang_config = HIGHLIGHTING_RULES.get(self._language, {})
        keywords = lang_config.get('keywords', [])
        builtins = lang_config.get('builtins', [])
        patterns = lang_config.get('patterns', [])
        keyword_format = FORMAT_KEYWORD
        for keyword in keywords:
            pattern = r'\b' + re.escape(keyword) + r'\b' # Użyj re.escape dla słów kluczowych
            self._rules.append((re.compile(pattern), keyword_format))
        builtin_format = FORMAT_BUILTIN
        for builtin in builtins:
            pattern = r'\b' + re.escape(builtin) + r'\b'
            self._rules.append((re.compile(pattern), builtin_format))
        for pattern_str, format, *flags in patterns: # Opcjonalne flagi regex np. re.DOTALL
             try:
                 pattern = re.compile(pattern_str, *flags)
                 self._rules.append((pattern, format))
             except re.error as e:
                 print(f""Błąd kompilacji regex '{pattern_str}' dla języka {self._language}: {e}"", file=sys.stderr)
    def highlightBlock(self, text: str):
        """"""Główna metoda kolorująca blok tekstu (linię).""""""
        self.setFormat(0, len(text), FORMAT_DEFAULT)
        self.setCurrentBlockState(0) # Domyślny stan dla tego bloku
        block_comment_delimiters = []
        if self._language in ['javascript', 'css', 'c++']:
             block_comment_delimiters.append((""/*"", ""*/"", FORMAT_COMMENT))
        if self._language == 'html':
             pass # Rely on regex pattern for HTML comments
        comment_start_in_prev_block = (self.previousBlockState() == 1) # State 1 means inside /* ... */
        if comment_start_in_prev_block:
             end_delimiter_index = text.find(""*/"")
             if end_delimiter_index >= 0:
                  self.setFormat(0, end_delimiter_index + 2, FORMAT_COMMENT)
                  self.setCurrentBlockState(0) # Reset state
                  start_pos = end_delimiter_index + 2
             else:
                  self.setFormat(0, len(text), FORMAT_COMMENT)
                  self.setCurrentBlockState(1) # Keep state as inside comment
                  return # Entire line is a comment, no need to parse further
        else:
             start_pos = 0
        start_delimiter = ""/*""
        end_delimiter = ""*/""
        startIndex = text.find(start_delimiter, start_pos)
        while startIndex >= 0:
            endIndex = text.find(end_delimiter, startIndex)
            if endIndex >= 0:
                length = endIndex - startIndex + len(end_delimiter)
                self.setFormat(startIndex, startIndex + length, FORMAT_COMMENT)
                startIndex = text.find(start_delimiter, startIndex + length)
            else:
                self.setFormat(startIndex, len(text) - startIndex, FORMAT_COMMENT)
                self.setCurrentBlockState(1) # Set state to inside block comment
                break # No more pairs starting in this line
        for pattern, format in self._rules:
             if format == FORMAT_COMMENT and (pattern.pattern.startswith(re.escape('/*')) or pattern.pattern.startswith(re.escape('<!--'))):
                  continue
             if format == FORMAT_COMMENT and pattern.pattern.startswith('//') and self.currentBlockState() == 1:
                  continue
             for match in pattern.finditer(text):
                start, end = match.span()
                self.setFormat(start, end, format)
class CustomFileSystemModel(QFileSystemModel):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.icon_map = {
            '.py': 'fa5s.file-code',
            '.js': 'fa5s.file-code',
            '.json': 'fa5s.file-code',  # JSON też jako plik kodu
            '.html': 'fa5s.file-code',
            '.css': 'fa5s.file-code',
            '.ini': 'fa5s.file-alt',  # Plik konfiguracji
            '.txt': 'fa5s.file-alt',
            '.md': 'fa5s.file-alt',
            '.c': 'fa5s.file-code',
            '.cpp': 'fa5s.file-code',
            '.h': 'fa5s.file-code',
            '.hpp': 'fa5s.file-code',
        }
        self.folder_icon_name = 'fa5s.folder'
        self.default_file_icon_name = 'fa5s.file'
        self._has_qtawesome = qta is not None
    def rename(self, index, new_name):
        """"""Zmienia nazwę pliku lub folderu reprezentowanego przez podany index.""""""
        if not index.isValid():
            return False
        old_path = self.filePath(index)
        new_path = os.path.join(os.path.dirname(old_path), new_name)
        try:
            os.rename(old_path, new_path)
            self.refresh()  # Możliwe, że trzeba wymusić odświeżenie modelu
            return True
        except Exception as e:
            print(f""Błąd podczas zmiany nazwy: {e}"")
            return False
    def data(self, index, role=Qt.ItemDataRole.DisplayRole):
        if not index.isValid():
            return None
        if role == Qt.ItemDataRole.DecorationRole:
            file_info = self.fileInfo(index)
            if file_info.isDir():
                if self._has_qtawesome:
                    return qta.icon(self.folder_icon_name)
                else:
                    return super().data(index, role)
            elif file_info.isFile():
                extension = file_info.suffix().lower()
                dotted_extension = '.' + extension
                if dotted_extension in self.icon_map and self._has_qtawesome:
                    return qta.icon(self.icon_map[dotted_extension])
                else:
                    if self._has_qtawesome:
                        return qta.icon(self.default_file_icon_name)
                    else:
                        return super().data(index, role)
        return super().data(index, role)
    def refresh(self, *args):
        self.setRootPath(self.rootPath())
class NewProjectDialog(QDialog):
    def __init__(self, projects_dir, parent=None):
        super().__init__(parent)
        self.setWindowTitle(""Nowy projekt"")
        self.projects_dir = projects_dir
        self.setModal(True)
        layout = QFormLayout(self)
        self.name_edit = QLineEdit()
        layout.addRow(""Nazwa projektu:"", self.name_edit)
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setText(""Utwórz"")  # Zmieniamy tekst przycisku
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addRow(self.button_box)
        self.name_edit.textChanged.connect(self._validate_name)
        self.name_edit.textChanged.emit(self.name_edit.text())  # Wywołaj walidację od razu
    def _validate_name(self, name):
        """"""Sprawdza poprawność nazwy projektu.""""""
        name = name.strip()
        is_empty = not name
        is_valid_chars = re.fullmatch(r'[a-zA-Z0-9_-]+', name) is not None or name == """"
        full_path = os.path.join(self.projects_dir, name)
        dir_exists = os.path.exists(full_path)
        enable_ok = not is_empty and is_valid_chars and not dir_exists
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setEnabled(enable_ok)
        if is_empty:
            self.name_edit.setToolTip(""Nazwa projektu nie może być pusta."")
        elif not is_valid_chars:
            self.name_edit.setToolTip(""Nazwa projektu może zawierać tylko litery, cyfry, podkreślenia i myślniki."")
        elif dir_exists:
            self.name_edit.setToolTip(f""Projekt o nazwie '{name}' już istnieje w:\n{self.projects_dir}"")
        else:
            self.name_edit.setToolTip(f""Katalog projektu zostanie utworzony w:\n{full_path}"")
        if not enable_ok and not is_empty:
            self.name_edit.setStyleSheet(""background-color: #ffe0e0;"")  # Jasnoczerwony
        else:
            self.name_edit.setStyleSheet("""")
    def get_project_name(self):
        return self.name_edit.text().strip()
    def get_project_path(self):
        return os.path.join(self.projects_dir, self.get_project_name())
class NewItemDialog(QDialog):
    def __init__(self, parent_dir, is_folder=False, parent=None):
        super().__init__(parent)
        self.setWindowTitle(""Nowy folder"" if is_folder else ""Nowy plik"")
        self.parent_dir = parent_dir
        self.is_folder = is_folder
        self.setModal(True)
        layout = QFormLayout(self)
        self.item_type_label = ""Nazwa folderu:"" if is_folder else ""Nazwa pliku:""
        self.name_edit = QLineEdit()
        layout.addRow(self.item_type_label, self.name_edit)
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addRow(self.button_box)
        self.name_edit.textChanged.connect(self._validate_name)
        self.name_edit.textChanged.emit(self.name_edit.text()) # Initial validation
    def _validate_name(self, name):
        """"""Sprawdza poprawność nazwy pliku/folderu.""""""
        name = name.strip()
        is_empty = not name
        illegal_chars_pattern = r'[<>:""/\\|?*\x00-\x1F]'
        is_valid_chars = re.search(illegal_chars_pattern, name) is None
        full_path = os.path.join(self.parent_dir, name)
        item_exists = os.path.exists(full_path)
        enable_create = not is_empty and is_valid_chars and not item_exists
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setEnabled(enable_create)
        if is_empty:
             self.name_edit.setToolTip(f""{self.item_type_label} nie może być pusta."")
        elif not is_valid_chars:
             self.name_edit.setToolTip(""Nazwa zawiera niedozwolone znaki."")
        elif item_exists:
             self.name_edit.setToolTip(f""Element o nazwie '{name}' już istnieje w:\n{self.parent_dir}"")
        else:
             self.name_edit.setToolTip("""")
        if not enable_create and not is_empty:
             self.name_edit.setStyleSheet(""background-color: #ffe0e0;"")
        else:
             self.name_edit.setStyleSheet("""")
    def get_item_name(self):
        return self.name_edit.text().strip()
class RenameItemDialog(QDialog):
    def __init__(self, current_path, parent=None):
        super().__init__(parent)
        self.current_path = current_path
        self.is_folder = os.path.isdir(current_path)
        old_name = os.path.basename(current_path)
        self.setWindowTitle(""Zmień nazwę"")
        layout = QVBoxLayout(self)
        self.label = QLabel(f""Nowa nazwa dla '{old_name}':"", self)
        layout.addWidget(self.label)
        self.line_edit = QLineEdit(old_name, self)
        layout.addWidget(self.line_edit)
        self.button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel, self)
        layout.addWidget(self.button_box)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        self.line_edit.textChanged.connect(self._validate_name)
        self._validate_name(self.line_edit.text())  # Od razu sprawdź
    def _validate_name(self, name):
        name = name.strip()
        is_empty = not name
        illegal_chars_pattern = r'[<>:""/\\|?*\x00-\x1F]'
        is_valid_chars = re.search(illegal_chars_pattern, name) is None
        old_name = os.path.basename(self.current_path)
        is_same_name = name == old_name
        parent_dir = os.path.dirname(self.current_path)
        new_full_path = os.path.join(parent_dir, name)
        item_exists_at_new_path = os.path.exists(new_full_path)
        enable_ok = not is_empty and is_valid_chars and (is_same_name or not item_exists_at_new_path)
        self.button_box.button(QDialogButtonBox.Ok).setEnabled(enable_ok)
    def get_new_name(self):
        return self.line_edit.text().strip()
class SettingsDialog(QDialog):
    def __init__(self, settings, parent=None):
        super().__init__(parent)
        self.setWindowTitle(""Ustawienia"")
        self._settings = settings # Pracujemy na kopii
        self.setModal(True)
        layout = QFormLayout(self)
        self.theme_combo = QComboBox()
        self.theme_combo.addItems([""light"", ""dark""])
        self.theme_combo.setCurrentText(self._settings.get(""theme"", ""light""))
        layout.addRow(""Motyw:"", self.theme_combo)
        self.python_path_edit = QLineEdit(self._settings.get(""python_path"", """"))
        self.python_path_button = QPushButton(""Przeglądaj..."")
        python_path_layout = QHBoxLayout()
        python_path_layout.addWidget(self.python_path_edit)
        python_path_layout.addWidget(self.python_path_button)
        layout.addRow(""Ścieżka Python:"", python_path_layout)
        self.python_path_button.clicked.connect(lambda: self._browse_file(self.python_path_edit))
        self.node_path_edit = QLineEdit(self._settings.get(""node_path"", """"))
        self.node_path_button = QPushButton(""Przeglądaj..."")
        node_path_layout = QHBoxLayout()
        node_path_layout.addWidget(self.node_path_edit)
        node_path_layout.addWidget(self.node_path_button)
        layout.addRow(""Ścieżka Node.js:"", node_path_layout)
        self.node_path_button.clicked.connect(lambda: self._browse_file(self.node_path_edit))
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addRow(self.button_box)
    def _browse_file(self, line_edit):
        """"""Otwiera dialog wyboru pliku dla pola QLineEdit.""""""
        start_dir = os.path.dirname(line_edit.text()) if os.path.dirname(line_edit.text()) else os.path.expanduser(""~"")
        if platform.system() == ""Windows"":
             filter_str = ""Wykonywalne pliki (*.exe *.bat *.cmd);;Wszystkie pliki (*)""
        else:
             filter_str = ""Wszystkie pliki (*)"" # Na Linux/macOS pliki wykonywalne nie mają konkretnego rozszerzenia
        file_path, _ = QFileDialog.getOpenFileName(self, ""Wybierz plik"", start_dir, filter_str)
        if file_path:
            line_edit.setText(os.path.normpath(file_path)) # Znormalizuj ścieżkę przed ustawieniem
    def get_settings(self):
        self._settings[""theme""] = self.theme_combo.currentText()
        self._settings[""python_path""] = self.python_path_edit.text().strip()
        self._settings[""node_path""] = self.node_path_edit.text().strip()
        return self._settings
    def layout(self):
        return super().layout()
class IDEWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.settings = {} # Słownik na ustawienia aplikacji
        self.recents = {""last_project_dir"": None, ""open_files"": []} # Słownik na historię
        self._load_app_state() # Wczytaj stan aplikacji (ustawienia i historię)
        self.setWindowTitle(""Proste IDE - Bez nazwy"")
        self.setGeometry(100, 100, 1200, 800)
        if qta:
             self.setWindowIcon(qta.icon('fa5s.code'))
        else:
             self.setWindowIcon(QIcon.fromTheme(""applications-development"")) # Przykładowa ikona systemowa
        self.current_project_dir = self.recents.get(""last_project_dir"")
        self.open_files = {} # {ścieżka_pliku: edytor_widget}
        self.base_editor_font = QFont(""Courier New"", 10) # Ustaw domyślną czcionkę początkową
        self._setup_ui()
        self._setup_menu()
        self._setup_toolbar()
        self._setup_status_bar()
        self._setup_connections()
        self._apply_theme(self.settings.get(""theme"", ""light""))
        self._apply_editor_font_size() # Zastosuj rozmiar czcionki do wszystkich otwartych edytorów (choć na start puste)
        self.process = QProcess(self) # Proces do uruchamiania kodu
        self.process.readyReadStandardOutput.connect(self._handle_stdout)
        self.process.readyReadStandardError.connect(self._handle_stderr)
        self.process.finished.connect(self._handle_process_finished)
        self.node_scripts = {} # Słownik na skrypty z package.json
        QTimer.singleShot(10, self._initial_setup)
    def _setup_ui(self):
        """"""Konfiguracja głównych elementów interfejsu.""""""
        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(0, 0, 0, 0)
        self.main_splitter = QSplitter(Qt.Orientation.Horizontal)
        main_layout.addWidget(self.main_splitter)
        self.project_model = CustomFileSystemModel()  # Użyj niestandardowego modelu z ikonami
        self.project_model.setFilter(QDir.Filter.AllDirs | QDir.Filter.Files | QDir.Filter.NoDotAndDotDot)
        self.project_tree = QTreeView()
        self.project_tree.setModel(self.project_model)
        self.project_tree.setHeaderHidden(True)
        self.project_tree.hideColumn(1)
        self.project_tree.hideColumn(2)
        self.project_tree.hideColumn(3)
        self.project_tree.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.main_splitter.addWidget(self.project_tree)
        self.right_splitter = QSplitter(Qt.Orientation.Vertical)
        self.main_splitter.addWidget(self.right_splitter)
        self.tab_widget = QTabWidget()
        self.tab_widget.setTabsClosable(True)
        self.tab_widget.setMovable(True)
        self.right_splitter.addWidget(self.tab_widget)
        self.console_widget = QWidget()
        self.console_layout = QVBoxLayout(self.console_widget)
        self.console_layout.setContentsMargins(0, 0, 0, 0)
        self.console = QPlainTextEdit()
        self.console.setReadOnly(True)
        self.console.setFont(self.base_editor_font)
        self.console_layout.addWidget(self.console, 1) # Rozciągnij pole konsoli
        self.console_input = QLineEdit()
        self.console_input.setPlaceholderText(""Wpisz polecenie..."")
        self.console_layout.addWidget(self.console_input, 0) # Nie rozciągaj pola wprowadzania
        self.console_buttons_layout = QHBoxLayout()
        self.console_buttons_layout.setContentsMargins(0, 0, 0, 0)
        self.console_buttons_layout.addStretch(1)
        self.clear_console_button = QPushButton(""Wyczyść konsolę"")
        self.console_buttons_layout.addWidget(self.clear_console_button)
        self.copy_console_button = QPushButton(""Skopiuj"")
        self.console_buttons_layout.addWidget(self.copy_console_button)
        self.console_layout.addLayout(self.console_buttons_layout)
        self.right_splitter.addWidget(self.console_widget)
        self.main_splitter.setSizes([200, 800])
        self.right_splitter.setSizes([600, 200])
        self.setCentralWidget(central_widget)
        self.action_toggle_tree = QAction(""Pokaż/Ukryj drzewko"", self)
        self.action_toggle_tree.setCheckable(True)
        self.action_toggle_tree.setChecked(True)
        self.action_toggle_tree.triggered.connect(self._toggle_tree_panel)
        self.action_toggle_console = QAction(""Pokaż/Ukryj konsolę"", self)
        self.action_toggle_console.setCheckable(True)
        self.action_toggle_console.setChecked(True)
        self.action_toggle_console.triggered.connect(self._toggle_console_panel)
        self._apply_view_settings()
    def _toggle_tree_panel(self, checked):
        self.main_splitter.widget(0).setVisible(checked)
    def _toggle_console_panel(self, checked):
        self.right_splitter.widget(1).setVisible(checked)
    def _setup_menu(self):
        """"""Konfiguracja paska menu.""""""
        menu_bar = self.menuBar()
        file_menu = menu_bar.addMenu(""&Plik"") # & dodaje skrót klawiszowy Alt+P
        self.action_new_project = QAction(qta.icon('fa5s.folder-plus') if qta else QIcon(), ""&Nowy projekt..."", self)
        self.action_new_project.triggered.connect(self._new_project)
        file_menu.addAction(self.action_new_project)
        self.action_open_folder = QAction(qta.icon('fa5s.folder-open') if qta else QIcon(), ""Otwórz &folder projektu..."", self)
        self.action_open_folder.triggered.connect(self._open_project_folder) # Użyj bezpośredniego połączenia
        file_menu.addAction(self.action_open_folder)
        self.action_open_file = QAction(qta.icon('fa5s.file-code') if qta else QIcon(), ""Otwórz &plik..."", self)
        self.action_open_file.triggered.connect(self._open_file_dialog)
        file_menu.addAction(self.action_open_file)
        file_menu.addSeparator()
        self.recent_files_menu = QMenu(""Ostatnio otwierane"", self)
        file_menu.addMenu(self.recent_files_menu)
        file_menu.addSeparator()
        self.action_save = QAction(qta.icon('fa5s.save') if qta else QIcon(), ""&Zapisz"", self)
        self.action_save.setShortcut(QKeySequence.StandardKey.Save)
        self.action_save.triggered.connect(self._save_current_file)
        file_menu.addAction(self.action_save)
        self.action_save_as = QAction(qta.icon('fa5s.file-export') if qta else QIcon(), ""Zapisz &jako..."", self)
        self.action_save_as.setShortcut(QKeySequence.StandardKey.SaveAs)
        self.action_save_as.triggered.connect(self._save_current_file_as)
        file_menu.addAction(self.action_save_as)
        self.action_save_all = QAction(qta.icon('fa5s.save') if qta else QIcon(), ""Zapisz wszys&tko"", self)
        self.action_save_all.setShortcut(QKeySequence(""Ctrl+Shift+S"")) # Standardowy skrót
        self.action_save_all.triggered.connect(self._save_all_files)
        file_menu.addAction(self.action_save_all)
        file_menu.addSeparator()
        self.action_close_file = QAction(qta.icon('fa5s.window-close') if qta else QIcon(), ""Zamknij ak&tualny plik"", self)
        self.action_close_file.triggered.connect(self._close_current_tab)
        file_menu.addAction(self.action_close_file)
        file_menu.addSeparator()
        self.action_exit = QAction(qta.icon('fa5s.door-open') if qta else QIcon(), ""&Zakończ"", self)
        self.action_exit.setShortcut(QKeySequence.StandardKey.Quit)
        self.action_exit.triggered.connect(self.close)
        file_menu.addAction(self.action_exit)
        edit_menu = menu_bar.addMenu(""&Edycja"")
        view_menu = menu_bar.addMenu(""&Widok"")
        self.action_toggle_tree = QAction(qta.icon('fa5s.sitemap') if qta else QIcon(), ""Pokaż &drzewko plików"", self)
        self.action_toggle_tree.setCheckable(True)
        self.action_toggle_tree.setChecked(self.settings.get(""show_tree"", True)) # Ustaw stan z ustawień
        self.action_toggle_tree.triggered.connect(self._toggle_tree_view)
        view_menu.addAction(self.action_toggle_tree)
        self.action_toggle_console = QAction(qta.icon('fa5s.terminal') if qta else QIcon(), ""Pokaż &konsolę"", self)
        self.action_toggle_console.setCheckable(True)
        self.action_toggle_console.setChecked(self.settings.get(""show_console"", True)) # Ustaw stan z ustawień
        self.action_toggle_console.triggered.connect(self._toggle_console)
        view_menu.addAction(self.action_toggle_console)
        search_menu = menu_bar.addMenu(""&Wyszukaj"")
        self.action_find = QAction(qta.icon('fa5s.search') if qta else QIcon(), ""&Znajdź..."", self)
        self.action_find.setShortcut(QKeySequence.StandardKey.Find)
        self.action_find.triggered.connect(self._show_find_bar)
        search_menu.addAction(self.action_find)
        run_menu = menu_bar.addMenu(""&Uruchom"")
        self.action_run_file = QAction(qta.icon('fa5s.play') if qta else QIcon(), ""&Uruchom aktualny plik"", self)
        self.action_run_file.setShortcut(QKeySequence(""F5"")) # Przykładowy skrót
        self.action_run_file.triggered.connect(self._run_current_file)
        run_menu.addAction(self.action_run_file)
        tools_menu = menu_bar.addMenu(""&Narzędzia"")
        self.action_settings = QAction(qta.icon('fa5s.cog') if qta else QIcon(), ""&Ustawienia..."", self)
        self.action_settings.triggered.connect(self._show_settings_dialog)
        tools_menu.addAction(self.action_settings)
        help_menu = menu_bar.addMenu(""&Pomoc"")
        self.action_about = QAction(qta.icon('fa5s.info-circle') if qta else QIcon(), ""&O programie..."", self)
        self.action_about.triggered.connect(self._show_about_dialog)
        help_menu.addAction(self.action_about)
    def _setup_toolbar(self):
        """"""Konfiguracja paska narzędzi.""""""
        toolbar = self.addToolBar(""Główne narzędzia"")
        toolbar.setMovable(False) # Nie można go przesuwać
        toolbar.setIconSize(QSize(16, 16)) # Rozmiar ikon
        toolbar.addAction(self.action_new_project) # Nowy projekt
        toolbar.addAction(self.action_open_folder) # Otwórz folder
        toolbar.addAction(self.action_open_file) # Otwórz plik
        toolbar.addSeparator()
        toolbar.addAction(self.action_save) # Zapisz
        toolbar.addAction(self.action_save_all) # Zapisz wszystko
        toolbar.addSeparator()
        self.run_toolbutton = QToolButton(self)
        self.run_toolbutton.setDefaultAction(self.action_run_file)
        self.run_toolbutton.setPopupMode(QToolButton.ToolButtonPopupMode.MenuButtonPopup)
        toolbar.addWidget(self.run_toolbutton) # Dodaj QToolButton do toolbara
        toolbar.addSeparator()
        self.search_input = QLineEdit(self)
        self.search_input.setPlaceholderText(""Szukaj w pliku..."")
        self.search_input.setClearButtonEnabled(True) # Przycisk czyszczenia
        self.search_input.returnPressed.connect(lambda: self._find_text(self.search_input.text(), 'next')) # Szukaj po wciśnięciu Enter
        self.find_next_button = QPushButton(""Znajdź dalej"")
        self.find_next_button.clicked.connect(lambda: self._find_text(self.search_input.text(), 'next'))
        self.find_prev_button = QPushButton(""Znajdź poprzedni"")
        self.find_prev_button.clicked.connect(lambda: self._find_text(self.search_input.text(), 'previous'))
        toolbar.addWidget(self.search_input)
        toolbar.addWidget(self.find_next_button)
        toolbar.addWidget(self.find_prev_button)
        self.search_input.setVisible(False)
        self.find_next_button.setVisible(False)
        self.find_prev_button.setVisible(False)
    def _setup_status_bar(self):
        """"""Konfiguracja paska stanu.""""""
        self.statusBar().showMessage(""Gotowy."")
    def _setup_connections(self):
        """"""Połączenie sygnałów ze slotami.""""""
        self.project_tree.doubleClicked.connect(self._handle_tree_item_double_click)
        self.tab_widget.tabCloseRequested.connect(self._close_tab_by_index)
        self.tab_widget.currentChanged.connect(self._handle_tab_change)
        self.project_tree.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu) # Upewnij się, że policy jest ustawione
        self.project_tree.customContextMenuRequested.connect(self._show_project_tree_context_menu)
        self.clear_console_button.clicked.connect(self.console.clear)
        self.copy_console_button.clicked.connect(self._copy_console)
        self.console_input.returnPressed.connect(self._run_console_command)
    def _initial_setup(self):
        """"""Wstępna konfiguracja po uruchomieniu, w tym ładowanie ostatniego stanu.""""""
        initial_dir = self.recents.get(""last_project_dir"")
        if not initial_dir or not os.path.isdir(initial_dir):
             initial_dir = PROJECTS_DIR # Użyj domyślnego katalogu projects
             os.makedirs(PROJECTS_DIR, exist_ok=True)
        if os.path.isdir(initial_dir):
             self._open_project_folder(initial_dir)
        else:
             self.statusBar().showMessage(f""Brak domyślnego katalogu projektu. Otwórz folder ręcznie lub utwórz nowy."")
             self.project_model.setRootPath("""") # Brak roota w drzewku
             self.current_project_dir = None # Resetuj current_project_dir
             self._update_run_button_menu()
        recent_files = self.recents.get(""open_files"", [])
        QTimer.singleShot(200, lambda: self._reopen_files(recent_files)) # Krótsze opóźnienie
        self._update_recent_files_menu() # Uaktualnij menu ostatnio otwieranych
    def _load_app_state(self):
        """"""Wczytuje ustawienia i historię z plików JSON.""""""
        try:
            if os.path.exists(SETTINGS_FILE):
                with open(SETTINGS_FILE, 'r', encoding='utf-8') as f:
                    loaded_settings = json.load(f)
                    self.settings = {
                        ""theme"": loaded_settings.get(""theme"", ""light""),
                        ""python_path"": loaded_settings.get(""python_path"", """"),
                        ""node_path"": loaded_settings.get(""node_path"", """"),
                        ""show_tree"": loaded_settings.get(""show_tree"", True),
                        ""show_console"": loaded_settings.get(""show_console"", True),
                        ""editor_font_size"": loaded_settings.get(""editor_font_size"", 10)
                    }
            else:
                self.settings = {
                    ""theme"": ""light"",
                    ""python_path"": """",
                    ""node_path"": """",
                    ""show_tree"": True,
                    ""show_console"": True,
                    ""editor_font_size"": 10
                }
            if os.path.exists(RECENTS_FILE):
                 with open(RECENTS_FILE, 'r', encoding='utf-8') as f:
                     loaded_recents = json.load(f)
                     self.recents = {
                         ""last_project_dir"": loaded_recents.get(""last_project_dir""),
                         ""open_files"": loaded_recents.get(""open_files"", [])
                     }
            else:
                 self.recents = {""last_project_dir"": None, ""open_files"": []}
        except (json.JSONDecodeError, Exception) as e:
            print(f""Błąd podczas wczytywania stanu aplikacji: {e}"", file=sys.stderr)
            self.settings = {
                ""theme"": ""light"",
                ""python_path"": """",
                ""node_path"": """",
                ""show_tree"": True,
                ""show_console"": True,
                ""editor_font_size"": 10
            }
            self.recents = {""last_project_dir"": None, ""open_files"": []}
    def _save_app_state(self):
        """"""Zapisuje ustawienia i historię do plików JSON.""""""
        try:
            self.recents[""open_files""] = list(self.open_files.keys())
            if self.current_project_dir and os.path.isdir(self.current_project_dir):
                 self.recents[""last_project_dir""] = os.path.normpath(self.current_project_dir) # Znormalizuj przed zapisem
            else:
                 self.recents[""last_project_dir""] = None # Nie zapisuj jeśli nie ma folderu
            with open(SETTINGS_FILE, 'w', encoding='utf-8') as f:
                json.dump(self.settings, f, indent=4)
            with open(RECENTS_FILE, 'w', encoding='utf-8') as f:
                 normalized_open_files = [os.path.normpath(p) for p in self.recents[""open_files""]]
                 unique_open_files = []
                 for p in normalized_open_files:
                     if p not in unique_open_files:
                         unique_open_files.append(p)
                 self.recents[""open_files""] = unique_open_files[:20] # Ostatnie 20 unikalnych
                 json.dump(self.recents, f, indent=4)
        except Exception as e:
            print(f""Błąd podczas zapisu stanu aplikacji: {e}"", file=sys.stderr)
    def closeEvent(self, event):
        """"""Obsługa zdarzenia zamykania okna.""""""
        unsaved_files = [path for path, editor in self.open_files.items() if editor.document().isModified()]
        if unsaved_files:
            msg_box = QMessageBox(self)
            msg_box.setIcon(QMessageBox.Icon.Warning)
            msg_box.setWindowTitle(""Niezapisane zmiany"")
            msg_box.setText(f""Masz niezapisane zmiany w {len(unsaved_files)} plikach.\nCzy chcesz zapisać przed zamknięciem?"")
            msg_box.setStandardButtons(QMessageBox.StandardButton.Save | QMessageBox.StandardButton.Discard | QMessageBox.StandardButton.Cancel)
            msg_box.setDefaultButton(QMessageBox.StandardButton.Save)
            reply = msg_box.exec()
            if reply == QMessageBox.StandardButton.Save:
                if self._save_all_files():
                     self._save_app_state() # Zapisz stan po pomyślnym zapisie plików
                     event.accept() # Akceptuj zamknięcie
                else:
                     event.ignore() # Nie zamykaj, jeśli zapis się nie udał
            elif reply == QMessageBox.StandardButton.Discard:
                for i in range(self.tab_widget.count() - 1, -1, -1):
                     widget = self.tab_widget.widget(i)
                     if hasattr(widget, 'document'):
                          widget.document().setModified(False)
                     self._close_tab_by_index(i) # Ta metoda usunie z open_files i recents
                self._save_app_state() # Zapisz stan (lista otwartych plików będzie aktualna)
                event.accept() # Akceptuj zamknięcie
            else:
                event.ignore() # Ignoruj zamknięcie
        else:
            self._save_app_state() # Zapisz stan, bo nie ma niezapisanych plików
            event.accept() # Akceptuj zamknięcie
    def _new_project(self):
        """"""Tworzy nowy katalog projektu.""""""
        dialog = NewProjectDialog(PROJECTS_DIR, self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            project_name = dialog.get_project_name()
            project_path = dialog.get_project_path()
            try:
                if os.path.exists(project_path):
                    QMessageBox.warning(self, ""Projekt już istnieje"", f""Projekt o nazwie '{project_name}' już istnieje."")
                    return
                os.makedirs(project_path)
                self.statusBar().showMessage(f""Utworzono nowy projekt: {project_name}"")
                self._open_project_folder(project_path)
            except OSError as e:
                QMessageBox.critical(self, ""Błąd tworzenia projektu"", f""Nie można utworzyć katalogu projektu:\n{e}"")
                self.statusBar().showMessage(""Błąd tworzenia projektu."")
            except Exception as e:
                 QMessageBox.critical(self, ""Nieoczekiwany błąd"", f""Wystąpił nieoczekiwany błąd:\n{e}"")
                 self.statusBar().showMessage(""Nieoczekiwany błąd."")
    def _open_project_folder(self, path=None):
        """"""Otwiera okno dialogowe wyboru folderu projektu lub otwiera wskazany folder.""""""
        if path is None:
            start_path = self.current_project_dir if self.current_project_dir else PROJECTS_DIR
            dialog_path = QFileDialog.getExistingDirectory(self, ""Otwórz folder projektu"", start_path)
            if not dialog_path:
                return
            path = dialog_path
        path = os.path.normpath(path)
        if not os.path.isdir(path):
            QMessageBox.critical(self, ""Błąd"", f""Wybrana ścieżka nie jest katalogiem lub nie istnieje:\n{path}"")
            self.statusBar().showMessage(f""Błąd: Nie można otworzyć folderu: {path}"")
            return
        if self.current_project_dir and self.current_project_dir != path:
             unsaved_files_count = sum(1 for editor in self.open_files.values() if editor.document().isModified())
             if unsaved_files_count > 0:
                  reply = QMessageBox.question(self, ""Niezapisane zmiany"",
                                               f""Obecny projekt ma {unsaved_files_count} niezapisanych plików.\n""
                                               ""Czy chcesz zapisać zmiany przed otwarciem nowego folderu?"",
                                               QMessageBox.StandardButton.Save | QMessageBox.StandardButton.Discard | QMessageBox.StandardButton.Cancel)
                  if reply == QMessageBox.StandardButton.Cancel:
                       self.statusBar().showMessage(""Otwieranie folderu anulowane."")
                       return # Anuluj operację
                  if reply == QMessageBox.StandardButton.Save:
                       if not self._save_all_files(): # Ta metoda obsłuży Save As dla nowych plików
                            self.statusBar().showMessage(""Otwieranie folderu anulowane (błąd zapisu)."")
                            return # Anuluj operację
             self._close_all_files() # Ta metoda już nie pyta o zapis
        self.current_project_dir = path
        self.project_model.setRootPath(path)
        root_index = self.project_model.index(path)
        if not root_index.isValid():
             QMessageBox.critical(self, ""Błąd"", f""Nie można ustawić katalogu głównego drzewka dla ścieżki:\n{path}\n""
                                                 ""Sprawdź uprawnienia lub czy ścieżka jest dostępna dla systemu plików."")
             self.statusBar().showMessage(f""Błąd ustawienia katalogu głównego: {path}"")
             self.project_tree.setRootIndex(self.project_model.index("""")) # Wyczyść roota
             self.current_project_dir = None # Resetuj current_project_dir
             self.recents[""open_files""] = [p for p in self.recents[""open_files""] if not os.path.normpath(p).startswith(os.path.normpath(path) + os.sep)]
             self._update_recent_files_menu()
             self._save_app_state() # Zapisz zaktualizowany stan
             self._update_run_button_menu() # Uaktualnij menu uruchamiania (brak projektu)
             return
        self.project_tree.setRootIndex(root_index)
        self.setWindowTitle(f""Proste IDE - {os.path.basename(path)}"")
        self.statusBar().showMessage(f""Otwarto folder: {path}"")
        self._check_package_json(path)
        self.recents[""last_project_dir""] = path
        self._save_app_state() # Zapisz, żeby zapamiętać ostatni folder
    def _close_all_files(self):
         """"""Zamyka wszystkie otwarte zakładki edytora bez pytania o zapis.""""""
         for file_path in list(self.open_files.keys()):
              editor_widget = self.open_files.get(file_path)
              if editor_widget:
                   tab_index = self.tab_widget.indexOf(editor_widget)
                   if tab_index != -1:
                        if hasattr(editor_widget, 'document'):
                            editor_widget.document().setModified(False)
                        self.tab_widget.removeTab(tab_index)
                        if file_path in self.open_files:
                             del self.open_files[file_path]
         self.recents[""open_files""] = [] # Wyczyść listę otwartych plików
         self._update_recent_files_menu() # Uaktualnij menu
    def _open_file_dialog(self):
        """"""Otwiera okno dialogowe wyboru pliku i otwiera go w edytorze.""""""
        start_path = self.current_project_dir if self.current_project_dir else PROJECTS_DIR
        file_path, _ = QFileDialog.getOpenFileName(self, ""Otwórz plik"", start_path, ""Wszystkie pliki (*);;Pliki Pythona (*.py);;Pliki JavaScript (*.js);;Pliki HTML (*.html);;Pliki CSS (*.css);;Pliki C++ (*.c *.cpp *.h *.hpp);;Pliki INI (*.ini);;Pliki JSON (*.json)"")
        if file_path:
            self._open_file(file_path)
    def _open_file(self, file_path):
        """"""Otwiera wskazany plik w nowej zakładce edytora.""""""
        file_path = os.path.normpath(file_path)
        if not os.path.exists(file_path) or not os.path.isfile(file_path):
            self.statusBar().showMessage(f""Błąd: Plik nie istnieje lub nie jest plikiem: {file_path}"")
            if file_path in self.recents[""open_files""]:
                 self.recents[""open_files""].remove(file_path)
                 self._update_recent_files_menu() # Uaktualnij menu
                 self._save_app_state() # Zapisz stan
            return
        if file_path in self.open_files:
            index = -1
            for i in range(self.tab_widget.count()):
                 widget = self.tab_widget.widget(i)
                 if self.open_files.get(file_path) is widget:
                      index = i
                      break
            if index != -1:
                self.tab_widget.setCurrentIndex(index)
                self.statusBar().showMessage(f""Plik {os.path.basename(file_path)} jest już otwarty."")
                if file_path in self.recents[""open_files""]:
                     self.recents[""open_files""].remove(file_path)
                     self.recents[""open_files""].insert(0, file_path)
                     self._update_recent_files_menu()
                     self._save_app_state()
                return
            else:
                print(f""Warning: File {file_path} found in open_files but not in tab widget."", file=sys.stderr)
        try:
            content = """"
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
            except UnicodeDecodeError:
                 try:
                      with open(file_path, 'r', encoding='latin-1') as f:
                          content = f.read()
                 except Exception:
                      with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                          content = f.read()
        except Exception as e:
            QMessageBox.critical(self, ""Błąd otwarcia pliku"", f""Nie można odczytać pliku {os.path.basename(file_path)}:\n{e}"")
            self.statusBar().showMessage(f""Błąd otwarcia pliku: {os.path.basename(file_path)}"")
            return
        editor = QPlainTextEdit()
        editor.setPlainText(content)
        editor.setFont(self.base_editor_font)
        editor.document().setModified(False) # Nowo otwarty plik nie jest zmodyfikowany
        editor.document().modificationChanged.connect(self._handle_modification_changed)
        language = self._get_language_from_path(file_path)
        highlighter = CodeSyntaxHighlighter(editor.document(), language) # Przypisz highlighter do dokumentu edytora
        setattr(editor.document(), '_syntax_highlighter', highlighter)
        tab_index = self.tab_widget.addTab(editor, os.path.basename(file_path))
        self.tab_widget.setCurrentIndex(tab_index)
        self.open_files[file_path] = editor # Zapisz odwołanie do edytora
        self.statusBar().showMessage(f""Otwarto plik: {file_path}"")
        if file_path in self.recents[""open_files""]:
            self.recents[""open_files""].remove(file_path) # Usuń stary wpis, żeby był na górze
        self.recents[""open_files""].insert(0, file_path) # Dodaj na początek
        self._update_recent_files_menu() # Uaktualnij menu
        self._save_app_state() # Zapisz stan
    def _reopen_files(self, file_list):
        """"""Ponownie otwiera listę plików po uruchomieniu programu.""""""
        files_to_reopen = list(file_list) # Tworzymy kopię
        valid_files = [f for f in files_to_reopen if os.path.exists(f) and os.path.isfile(f)]
        self.recents[""open_files""] = valid_files
        self._update_recent_files_menu() # Uaktualnij menu
        for file_path in valid_files:
            QTimer.singleShot(0, lambda path=file_path: self._open_file(path))
        invalid_files = [f for f in files_to_reopen if f not in valid_files]
        if invalid_files:
            msg = ""Nie można ponownie otworzyć następujących plików (nie znaleziono):\n"" + ""\n"".join(invalid_files)
            QMessageBox.warning(self, ""Błąd otwarcia plików"", msg)
    def _update_recent_files_menu(self):
        """"""Uaktualnia listę plików w menu 'Ostatnio otwierane'.""""""
        self.recent_files_menu.clear()
        recent_items_to_show = list(self.recents.get(""open_files"", []))[:15] # Pokaż max 15 (praca na kopii)
        if not recent_items_to_show:
            self.recent_files_menu.addAction(""Brak ostatnio otwieranych plików"").setEnabled(False)
            return
        actions_to_add = []
        cleaned_recent_files = [] # Zbuduj nową listę poprawnych ścieżek
        for file_path in recent_items_to_show:
            if os.path.exists(file_path) and os.path.isfile(file_path):
                 cleaned_recent_files.append(file_path) # Dodaj do listy czystej
                 menu_text = os.path.basename(file_path) # Pokaż tylko nazwę pliku
                 action = QAction(menu_text, self)
                 action.setData(file_path) # Zapisz pełną ścieżkę w danych akcji
                 action.triggered.connect(lambda checked, path=file_path: self._open_file(path))
                 actions_to_add.append(action)
        all_existing_recent_files = [p for p in self.recents.get(""open_files"", []) if os.path.exists(p) and os.path.isfile(p)]
        unique_recent_files = []
        for p in all_existing_recent_files:
            if p not in unique_recent_files:
                unique_recent_files.append(p)
        self.recents[""open_files""] = unique_recent_files[:20]
        self.recent_files_menu.clear() # Wyczyść ponownie
        if not self.recents[""open_files""]:
             self.recent_files_menu.addAction(""Brak ostatnio otwieranych plików"").setEnabled(False)
        else:
             for file_path in self.recents[""open_files""]:
                  menu_text = os.path.basename(file_path)
                  action = QAction(menu_text, self)
                  action.setData(file_path)
                  action.triggered.connect(lambda checked, path=file_path: self._open_file(path))
                  self.recent_files_menu.addAction(action)
    def _get_language_from_path(self, file_path):
         """"""Zwraca nazwę języka na podstawie rozszerzenia pliku.""""""
         if not file_path:
              return 'plaintext'
         file_info = QFileInfo(file_path)
         extension = file_info.suffix().lower()
         if extension == 'py':
             return 'python'
         elif extension == 'js':
             return 'javascript'
         elif extension == 'html':
             return 'html'
         elif extension == 'css':
             return 'css'
         elif extension in ['c', 'cpp', 'h', 'hpp']:
             return 'c++'
         elif extension == 'ini':
             return 'ini'
         elif extension == 'json':
             return 'json'
         else:
             return 'plaintext' # Bez kolorowania
    def _handle_tree_item_double_click(self, index):
        """"""Obsługa podwójnego kliknięcia w drzewku projektu.""""""
        file_path = self.project_model.filePath(index)
        if os.path.isfile(file_path):
            self._open_file(file_path)
        elif os.path.isdir(file_path):
             if self.project_tree.isExpanded(index):
                 self.project_tree.collapse(index)
             else:
                 self.project_tree.expand(index)
    def _show_project_tree_context_menu(self, point):
        """"""Wyświetla menu kontekstowe dla drzewka projektu.""""""
        index = self.project_tree.indexAt(point)
        menu = QMenu(self)
        create_file_action = QAction(qta.icon('fa5s.file-medical') if qta else QIcon(), ""Nowy plik..."", self)
        create_folder_action = QAction(qta.icon('fa5s.folder-plus') if qta else QIcon(), ""Nowy folder..."", self)
        select_all_action = QAction(""Zaznacz wszystko"", self)
        select_all_action.triggered.connect(self.project_tree.selectAll)
        if index.isValid():
            file_path = self.project_model.filePath(index)
            file_info = self.project_model.fileInfo(index)
            is_root_model = self.project_model.rootPath() == file_path
            if not is_root_model: # Nie usuwaj/zmieniaj nazwy roota projektu
                 rename_action = QAction(qta.icon('fa5s.edit') if qta else QIcon(), ""Zmień nazwę..."", self)
                 delete_action = QAction(qta.icon('fa5s.trash') if qta else QIcon(), ""Usuń"", self)
                 rename_action.triggered.connect(lambda: self._rename_item(index))
                 delete_action.triggered.connect(lambda: self._delete_item(index))
                 if file_info.isDir():
                     menu.addAction(create_file_action) # Nowy plik w folderze
                     menu.addAction(create_folder_action) # Nowy folder w folderze
                     menu.addSeparator()
                     menu.addAction(rename_action)
                     menu.addAction(delete_action)
                     menu.addSeparator()
                     open_in_os_action = QAction(qta.icon('fa5s.external-link-alt') if qta else QIcon(), ""Otwórz w eksploratorze"", self) # Windows
                     if platform.system() == ""Darwin"": open_in_os_action.setText(""Otwórz w Finderze"") # macOS
                     elif platform.system() == ""Linux"": open_in_os_action.setText(""Otwórz w menedżerze plików"") # Linux
                     open_in_os_action.triggered.connect(lambda: QDesktopServices.openUrl(QUrl.fromLocalFile(file_path)))
                     menu.addAction(open_in_os_action)
                     create_file_action.triggered.connect(lambda: self._create_new_item(file_path, is_folder=False))
                     create_folder_action.triggered.connect(lambda: self._create_new_item(file_path, is_folder=True))
                 elif file_info.isFile():
                     open_action = QAction(qta.icon('fa5s.file') if qta else QIcon(), ""Otwórz"", self) # Mimo podwójnego kliknięcia
                     open_action.triggered.connect(lambda: self._open_file(file_path))
                     duplicate_action = QAction(qta.icon('fa5s.copy') if qta else QIcon(), ""Duplikuj"", self)
                     duplicate_action.triggered.connect(lambda: self._duplicate_file(index))
                     copy_path_action = QAction(qta.icon('fa5s.link') if qta else QIcon(), ""Kopiuj ścieżkę"", self)
                     copy_path_action.triggered.connect(lambda: QApplication.clipboard().setText(file_path))
                     menu.addAction(open_action)
                     menu.addSeparator()
                     menu.addAction(rename_action)
                     menu.addAction(delete_action)
                     menu.addAction(duplicate_action)
                     menu.addSeparator()
                     menu.addAction(copy_path_action)
                     menu.addSeparator()
                     open_containing_folder_action = QAction(qta.icon('fa5s.folder-open') if qta else QIcon(), ""Pokaż w eksploratorze"", self) # Windows
                     if platform.system() == ""Darwin"": open_containing_folder_action.setText(""Pokaż w Finderze"") # macOS
                     elif platform.system() == ""Linux"": open_containing_folder_action.setText(""Pokaż w menedżerze plików"") # Linux
                     open_containing_folder_action.triggered.connect(lambda: QDesktopServices.openUrl(QUrl.fromLocalFile(os.path.dirname(file_path))))
                     menu.addAction(open_containing_folder_action)
            else: # Kliknięto na root folderu projektu
                 menu.addAction(create_file_action) # Nowy plik w roocie
                 menu.addAction(create_folder_action) # Nowy folder w roocie
                 menu.addSeparator()
                 open_in_os_action = QAction(qta.icon('fa5s.external-link-alt') if qta else QIcon(), ""Otwórz w eksploratorze"", self) # Windows
                 if platform.system() == ""Darwin"": open_in_os_action.setText(""Otwórz w Finderze"") # macOS
                 elif platform.system() == ""Linux"": open_in_os_action.setText(""Otwórz w menedżerze plików"") # Linux
                 open_in_os_action.triggered.connect(lambda: QDesktopServices.openUrl(QUrl.fromLocalFile(file_path)))
                 menu.addAction(open_in_os_action)
                 create_file_action.triggered.connect(lambda: self._create_new_item(file_path, is_folder=False))
                 create_folder_action.triggered.connect(lambda: self._create_new_item(file_path, is_folder=True))
        else: # Kliknięto na puste miejsce w drzewku
            if self.current_project_dir and os.path.isdir(self.current_project_dir):
                menu.addAction(create_file_action) # Nowy plik w roocie projektu
                menu.addAction(create_folder_action) # Nowy folder w roocie projektu
                create_file_action.triggered.connect(lambda: self._create_new_item(self.current_project_dir, is_folder=False))
                create_folder_action.triggered.connect(lambda: self._create_new_item(self.current_project_dir, is_folder=True))
                menu.addSeparator()
            menu.addAction(select_all_action)
        if menu.actions(): # Pokaż menu tylko jeśli są jakieś akcje
            menu.exec(self.project_tree.mapToGlobal(point))
    def _create_new_item(self, parent_dir, is_folder):
         """"""Tworzy nowy plik lub folder w podanym katalogu nadrzędnym.""""""
         if not os.path.isdir(parent_dir):
              QMessageBox.warning(self, ""Błąd tworzenia"", f""Katalog nadrzędny nie istnieje lub nie jest katalogiem:\n{parent_dir}"")
              self.statusBar().showMessage(""Błąd tworzenia nowego elementu."")
              return
         dialog = NewItemDialog(parent_dir, is_folder, self)
         if dialog.exec() == QDialog.DialogCode.Accepted:
             item_name = dialog.get_item_name()
             if not item_name: return # Powinno być obsłużone w dialogu, ale zabezpieczenie
             full_path = os.path.join(parent_dir, item_name)
             parent_index = self.project_model.index(parent_dir)
             if not parent_index.isValid():
                  try:
                       if is_folder:
                           os.makedirs(full_path)
                           self.statusBar().showMessage(f""Utworzono folder: {item_name}"")
                       else:
                           with open(full_path, 'w') as f: pass # Utwórz pusty plik
                           self.statusBar().showMessage(f""Utworzono plik: {item_name}"")
                       root_path = self.project_model.rootPath()
                       if root_path and os.path.isdir(root_path):
                            self.project_model.refresh(self.project_model.index(root_path))
                  except OSError as e:
                       QMessageBox.critical(self, ""Błąd tworzenia"", f""Nie można utworzyć {'folderu' if is_folder else 'pliku'}:\n{e}"")
                       self.statusBar().showMessage(f""Błąd tworzenia {'folderu' if is_folder else 'pliku'}."")
                  except Exception as e:
                      QMessageBox.critical(self, ""Nieoczekiwany błąd"", f""Wystąpił nieoczekiwany błąd:\n{e}"")
                      self.statusBar().showMessage(""Nieoczekiwany błąd."")
                  return
             success = False
             if is_folder:
                 new_index = self.project_model.mkdir(parent_index, item_name)
                 if new_index.isValid():
                      self.statusBar().showMessage(f""Utworzono folder: {item_name}"")
                      success = True
                      self.project_tree.expand(new_index) # Rozwiń folder, żeby było widać nowy element
             else:
                  try:
                       with open(full_path, 'w') as f: pass # Utwórz pusty plik
                       self.statusBar().showMessage(f""Utworzono plik: {item_name}"")
                       self.project_model.refresh(parent_index)
                       success = True
                  except OSError as e:
                       QMessageBox.critical(self, ""Błąd tworzenia"", f""Nie można utworzyć pliku:\n{e}"")
                       self.statusBar().showMessage(""Błąd tworzenia pliku."")
                  except Exception as e:
                      QMessageBox.critical(self, ""Nieoczekiwany błąd"", f""Wystąpił nieoczekiwany błąd:\n{e}"")
                      self.statusBar().showMessage(""Nieoczekiwany błąd."")
    def _rename_item(self, index):
         """"""Zmienia nazwę pliku lub folderu.""""""
         if not index.isValid(): return
         old_path = self.project_model.filePath(index)
         old_name = os.path.basename(old_path)
         parent_dir = os.path.dirname(old_path)
         if old_path == self.project_model.rootPath() or old_path == self.project_model.filePath(self.project_model.index("""")):
              QMessageBox.warning(self, ""Błąd zmiany nazwy"", ""Nie można zmienić nazwy katalogu głównego."")
              self.statusBar().showMessage(""Nie można zmienić nazwy katalogu głównego."")
              return
         dialog = RenameItemDialog(old_path, self)
         if dialog.exec() == QDialog.DialogCode.Accepted:
             new_name = dialog.get_new_name()
             if not new_name or new_name == old_name:
                  self.statusBar().showMessage(""Zmiana nazwy anulowana lub nowa nazwa jest taka sama."")
                  return # Brak zmiany lub pusta nazwa (powinno być obsłużone w dialogu)
             new_path = os.path.join(parent_dir, new_name)
             open_files_to_close = []
             if os.path.isfile(old_path):
                  if old_path in self.open_files:
                       open_files_to_close.append(old_path)
             elif os.path.isdir(old_path):
                  normalized_folder_path = os.path.normpath(old_path) + os.sep
                  for open_file_path in self.open_files.keys():
                       if os.path.normpath(open_file_path).startswith(normalized_folder_path):
                            open_files_to_close.append(open_file_path)
             if open_files_to_close:
                  open_file_names = [os.path.basename(p) for p in open_files_to_close]
                  msg = f""{{'Plik' if os.path.isfile(old_path) else 'Folder'}} '{old_name}' zawiera otwarte pliki, które zostaną zamknięte i ponownie otwarte po zmianie nazwy:\\n"" + ""\\n"".join(open_file_names)
                  reply = QMessageBox.question(self, ""Zamknij pliki"", msg + ""\n\nCzy chcesz kontynuować?"",
                                               QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
                  if reply == QMessageBox.StandardButton.No:
                       self.statusBar().showMessage(""Zmiana nazwy anulowana."")
                       return # Anuluj operację
                  unsaved_open_files = [p for p in open_files_to_close if self.open_files.get(p) and self.open_files[p].document().isModified()]
                  if unsaved_open_files:
                       save_reply = QMessageBox.question(self, ""Niezapisane zmiany"",
                                                         f""Niektóre z plików ({len(unsaved_open_files)}) mają niezapisane zmiany. Czy chcesz je zapisać przed zamknięciem i zmianą nazwy?"",
                                                         QMessageBox.StandardButton.Save | QMessageBox.StandardButton.Discard | QMessageBox.StandardButton.Cancel)
                       if save_reply == QMessageBox.StandardButton.Cancel:
                            self.statusBar().showMessage(""Zmiana nazwy anulowana (niezapisane zmiany)."")
                            return # Anuluj operację
                       if save_reply == QMessageBox.StandardButton.Save:
                            save_success = True
                            for file_path_to_save in unsaved_open_files:
                                 editor = self.open_files.get(file_path_to_save)
                                 if editor and not self._save_file(editor, file_path_to_save): # _save_file handles Save As if needed
                                      save_success = False
                                      break
                            if not save_success:
                                 self.statusBar().showMessage(""Zmiana nazwy anulowana (błąd zapisu otwartych plików)."")
                                 return # Anuluj operację
                  for file_path_to_close in reversed(open_files_to_close):
                       editor_widget = self.open_files.get(file_path_to_close)
                       if editor_widget:
                            tab_index = self.tab_widget.indexOf(editor_widget)
                            if tab_index != -1:
                                 if hasattr(editor_widget, 'document'):
                                      editor_widget.document().setModified(False)
                                 self.tab_widget.removeTab(tab_index)
                                 del self.open_files[file_path_to_close]
                                 editor_widget.deleteLater()
                  self.recents[""open_files""] = [p for p in self.recents[""open_files""] if p not in open_files_to_close]
                  self._update_recent_files_menu()
                  self._save_app_state() # Zapisz stan po zamknięciu plików
             success = self.project_model.rename(index, new_name)
             if success:
                 self.statusBar().showMessage(f""Zmieniono nazwę na: {new_name}"")
                 if open_files_to_close:
                      parent_index_after_rename = self.project_model.index(parent_dir)
                      if parent_index_after_rename.isValid():
                           self.project_model.refresh(parent_index_after_rename)
                      for old_file_path in open_files_to_close:
                           relative_path = os.path.relpath(old_file_path, old_path)
                           new_file_path = os.path.join(new_path, relative_path)
                           if os.path.exists(new_file_path) and os.path.isfile(new_file_path):
                                self._open_file(new_file_path) # Otworzy plik pod nową ścieżką
             else:
                  QMessageBox.critical(self, ""Błąd zmiany nazwy"", f""Nie można zmienić nazwy '{old_name}' na '{new_name}'.\n""
                                                                   ""Sprawdź, czy element o tej nazwie już nie istnieje lub czy masz uprawnienia."")
                  self.statusBar().showMessage(""Błąd zmiany nazwy."")
    def _delete_item(self, index):
        """"""Usuwa plik lub folder.""""""
        if not index.isValid(): return
        file_path = self.project_model.filePath(index)
        item_name = os.path.basename(file_path)
        is_dir = self.project_model.fileInfo(index).isDir()
        if file_path == self.project_model.rootPath() or file_path == self.project_model.filePath(self.project_model.index("""")):
             QMessageBox.warning(self, ""Błąd usuwania"", ""Nie można usunąć katalogu głównego."")
             self.statusBar().showMessage(""Nie można usunąć katalogu głównego."")
             return
        open_files_to_close = []
        if is_dir:
             normalized_folder_path = os.path.normpath(file_path) + os.sep
             for open_file_path in self.open_files.keys():
                  if os.path.normpath(open_file_path).startswith(normalized_folder_path):
                       open_files_to_close.append(open_file_path)
        elif file_path in self.open_files:
             open_files_to_close.append(file_path)
        if open_files_to_close:
             open_file_names = [os.path.basename(p) for p in open_files_to_close]
             msg = f""Nie można usunąć {{'folderu' if is_dir else 'pliku'}} '{item_name}', ponieważ zawiera on otwarte pliki, które muszą zostać zamknięte:\\n"" + ""\\n"".join(open_file_names)
             QMessageBox.warning(self, ""Element jest używany"", msg)
             reply_close = QMessageBox.question(self, ""Zamknij pliki"",
                                                f""Czy chcesz zamknąć te pliki, aby kontynuować usuwanie '{item_name}'?"",
                                                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
             if reply_close == QMessageBox.StandardButton.No:
                  self.statusBar().showMessage(f""Usuwanie '{item_name}' anulowane."")
                  return # Anuluj operację
             unsaved_open_files = [p for p in open_files_to_close if self.open_files.get(p) and self.open_files[p].document().isModified()]
             if unsaved_open_files:
                  save_reply = QMessageBox.question(self, ""Niezapisane zmiany"",
                                                    f""Niektóre z plików ({len(unsaved_open_files)}) mają niezapisane zmiany. Czy chcesz je zapisać przed zamknięciem i usunięciem?"",
                                                    QMessageBox.StandardButton.Save | QMessageBox.StandardButton.Discard | QMessageBox.StandardButton.Cancel)
                  if save_reply == QMessageBox.StandardButton.Cancel:
                       self.statusBar().showMessage(""Usuwanie anulowane (niezapisane zmiany)."")
                       return # Anuluj operację
                  if save_reply == QMessageBox.StandardButton.Save:
                       save_success = True
                       for file_path_to_save in unsaved_open_files:
                            editor = self.open_files.get(file_path_to_save)
                            if editor and not self._save_file(editor, file_path_to_save): # _save_file handles Save As if needed
                                 save_success = False
                                 break
                       if not save_success:
                            self.statusBar().showMessage(""Usuwanie anulowane (błąd zapisu otwartych plików)."")
                            return # Anuluj operację
             for file_path_to_close in reversed(open_files_to_close):
                  editor_widget = self.open_files.get(file_path_to_close)
                  if editor_widget:
                       tab_index = self.tab_widget.indexOf(editor_widget)
                       if tab_index != -1:
                            if hasattr(editor_widget, 'document'):
                                editor_widget.document().setModified(False)
                            self.tab_widget.removeTab(tab_index)
                            del self.open_files[file_path_to_close]
                            editor_widget.deleteLater()
             self.recents[""open_files""] = [p for p in self.recents[""open_files""] if p not in open_files_to_close]
             self._update_recent_files_menu()
             self._save_app_state() # Zapisz stan po zamknięciu plików
        item_type = ""folder"" if is_dir else ""plik""
        reply = QMessageBox.question(self, f""Usuń {item_type}"",
                                     f""Czy na pewno chcesz usunąć {item_type} '{item_name}'?\\n""
                                     ""Ta operacja jest nieodwracalna!"", # Dodaj ostrzeżenie
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        if reply == QMessageBox.StandardButton.Yes:
            success = self.project_model.remove(index)
            if success:
                self.statusBar().showMessage(f""Usunięto {item_type}: {item_name}"")
            else:
                 QMessageBox.critical(self, f""Błąd usuwania {item_type}"", f""Nie można usunąć {item_type} '{item_name}'.\\n""
                                                                            ""Sprawdź, czy masz uprawnienia lub czy element nie jest używany przez inny program."")
                 self.statusBar().showMessage(f""Błąd usuwania {item_type}."")
    def _duplicate_file(self, index):
         """"""Duplikuje plik.""""""
         if not index.isValid(): return
         file_path = self.project_model.filePath(index)
         file_info = self.project_model.fileInfo(index)
         if not file_info.isFile():
              self.statusBar().showMessage(""Można duplikować tylko pliki."")
              return
         parent_dir = os.path.dirname(file_path)
         old_name = os.path.basename(file_path)
         name, ext = os.path.splitext(old_name)
         suggested_name = f""{name}_kopia{ext}""
         counter = 1
         while os.path.exists(os.path.join(parent_dir, suggested_name)):
              counter += 1
              suggested_name = f""{name}_kopia{counter}{ext}""
         new_name, ok = QInputDialog.getText(self, ""Duplikuj plik"", f""Podaj nazwę dla kopii '{old_name}':"",
                                            QLineEdit.EchoMode.Normal, suggested_name)
         if ok and new_name:
             new_name = new_name.strip()
             if not new_name or re.search(r'[<>:""/\\|?*\x00-\x1F]', new_name) is not None:
                 QMessageBox.warning(self, ""Nieprawidłowa nazwa"", ""Podana nazwa jest pusta lub zawiera niedozwolone znaki."")
                 self.statusBar().showMessage(""Duplikowanie anulowane (nieprawidłowa nazwa)."")
                 return
             new_path = os.path.join(parent_dir, new_name)
             if os.path.exists(new_path):
                  QMessageBox.warning(self, ""Element już istnieje"", f""Element o nazwie '{new_name}' już istnieje."")
                  self.statusBar().showMessage(""Duplikowanie anulowane (element już istnieje)."")
                  return
             try:
                 os.makedirs(os.path.dirname(new_path), exist_ok=True)
                 shutil.copy2(file_path, new_path) # copy2 zachowuje metadane
                 self.statusBar().showMessage(f""Utworzono kopię: {new_name}"")
                 parent_index = self.project_model.index(parent_dir)
                 if parent_index.isValid():
                      self.project_model.refresh(parent_index)
                 else:
                      root_path = self.project_model.rootPath()
                      if root_path and os.path.isdir(root_path):
                           self.project_model.refresh(self.project_model.index(root_path))
             except OSError as e:
                  QMessageBox.critical(self, ""Błąd duplikowania"", f""Nie można zduplikować pliku '{old_name}':\n{e}"")
                  self.statusBar().showMessage(""Błąd duplikowania pliku."")
             except Exception as e:
                 QMessageBox.critical(self, ""Nieoczekiwany błąd"", f""Wystąpił nieoczekiwany błąd:\n{e}"")
                 self.statusBar().showMessage(""Nieoczekiwany błąd."")
    def _close_tab_by_index(self, index):
        """"""Zamyka zakładkę o podanym indeksie, pytając o zapisanie zmian.""""""
        if index == -1: # Brak otwartych zakładek
            return
        widget = self.tab_widget.widget(index)
        if widget is None: # Zabezpieczenie
            return
        file_path_before_save = None
        for path, editor_widget in list(self.open_files.items()):
            if editor_widget is widget:
                file_path_before_save = path
                break
        if hasattr(widget, 'document') and widget.document().isModified():
            msg_box = QMessageBox(self)
            msg_box.setIcon(QMessageBox.Icon.Warning)
            msg_box.setWindowTitle(""Niezapisane zmiany"")
            tab_text = self.tab_widget.tabText(index).rstrip('*')
            display_name = os.path.basename(file_path_before_save) if file_path_before_save else tab_text
            msg_box.setText(f""Plik '{display_name}' ma niezapisane zmiany.\nCzy chcesz zapisać przed zamknięciem?"")
            msg_box.setStandardButtons(QMessageBox.StandardButton.Save | QMessageBox.StandardButton.Discard | QMessageBox.StandardButton.Cancel)
            msg_box.setDefaultButton(QMessageBox.StandardButton.Save)
            reply = msg_box.exec()
            if reply == QMessageBox.StandardButton.Save:
                needs_save_as = (file_path_before_save is None or
                                 not os.path.exists(file_path_before_save) or
                                 not QFileInfo(file_path_before_save).isFile())
                if needs_save_as:
                    original_index = self.tab_widget.currentIndex()
                    self.tab_widget.setCurrentIndex(index)
                    save_success = self._save_current_file_as() # This handles saving and updating open_files/recents for the NEW path
                    if original_index != -1 and original_index < self.tab_widget.count():
                         self.tab_widget.setCurrentIndex(original_index)
                    else: # If the original tab was closed during Save As (e.g. saving an existing file to itself)
                         pass # Keep the new tab active
                    if not save_success:
                         self.statusBar().showMessage(f""Zamknięcie anulowane (błąd zapisu '{display_name}')."")
                         return # Anulowano lub błąd zapisu ""jako"", nie zamykaj zakładki
                else: # It's an existing file with a valid path
                     if not self._save_file(widget, file_path_before_save): # Spróbuj zapisać, jeśli się nie uda, nie zamykaj
                         self.statusBar().showMessage(f""Zamknięcie anulowane (błąd zapisu '{display_name}')."")
                         return # Anulowano lub błąd zapisu
            elif reply == QMessageBox.StandardButton.Cancel:
                self.statusBar().showMessage(f""Zamknięcie '{tab_text}' anulowane."")
                return # Anuluj zamknięcie
        if file_path_before_save in self.open_files:
             del self.open_files[file_path_before_save]
             if file_path_before_save in self.recents[""open_files""]:
                 self.recents[""open_files""].remove(file_path_before_save)
                 self._update_recent_files_menu() # Uaktualnij menu
        self.tab_widget.removeTab(index)
        widget.deleteLater() # Usuń widget z pamięci
        if file_path_before_save:
            self.statusBar().showMessage(f""Zamknięto plik: {os.path.basename(file_path_before_save)}"")
        else:
             self.statusBar().showMessage(""Zamknięto plik."")
        self._save_app_state()
    def _close_current_tab(self):
        """"""Zamyka aktualnie aktywną zakładkę.""""""
        current_index = self.tab_widget.currentIndex()
        if current_index != -1:
            self._close_tab_by_index(current_index)
    def _save_current_file(self):
        """"""Zapisuje aktualnie aktywny plik. Jeśli nowy, wywołuje Save As.""""""
        current_widget = self.tab_widget.currentWidget()
        if not isinstance(current_widget, QPlainTextEdit):
            self.statusBar().showMessage(""Brak aktywnego pliku do zapisu."")
            return False
        file_path = None
        for path, editor_widget in list(self.open_files.items()):
            if editor_widget is current_widget:
                file_path = path
                break
        is_existing_valid_file = file_path and os.path.exists(file_path) and QFileInfo(file_path).isFile()
        if is_existing_valid_file:
             return self._save_file(current_widget, file_path)
        else:
             return self._save_current_file_as()
    def _save_current_file_as(self):
        """"""Zapisuje zawartość aktywnego edytora z nową nazwą.""""""
        current_widget = self.tab_widget.currentWidget()
        if not isinstance(current_widget, QPlainTextEdit):
            self.statusBar().showMessage(""Brak aktywnego pliku do zapisu."")
            return False
        old_file_path = None
        for path, editor_widget in list(self.open_files.items()): # Iterate over a copy
            if editor_widget is current_widget:
                old_file_path = path
                break
        suggested_name = ""bez_nazwy.txt""
        current_tab_index = self.tab_widget.indexOf(current_widget)
        if current_tab_index != -1:
             original_tab_text = self.tab_widget.tabText(current_tab_index).rstrip('*')
             if original_tab_text and original_tab_text != ""Nowy plik"":
                  suggested_name = original_tab_text
             elif current_widget.document().toPlainText().strip():
                  first_line = current_widget.document().toPlainText().strip().split('\n')[0].strip()
                  if first_line:
                       suggested_name = re.sub(r'[\\/:*?""<>|]', '_', first_line) # Remove illegal chars
                       suggested_name = suggested_name[:50].strip() # Limit length
                       if not suggested_name:
                           suggested_name = ""bez_nazwy""
                       if '.' not in os.path.basename(suggested_name):
                            suggested_name += "".txt""
                  else:
                       suggested_name = ""bez_nazwy.txt"" # Fallback if content is just whitespace
        start_path = self.current_project_dir if self.current_project_dir else PROJECTS_DIR
        if old_file_path and os.path.dirname(old_file_path):
             start_path = os.path.dirname(old_file_path) # Use directory of old file if available
        elif os.path.isdir(start_path):
             pass # Use project dir if available
        else:
             start_path = os.path.expanduser(""~"")
        file_filters = ""Wszystkie pliki (*);;Pliki Pythona (*.py);;Pliki JavaScript (*.js);;Pliki HTML (*.html);;Pliki CSS (*.css);;Pliki C++ (*.c *.cpp *.h *.hpp);;Pliki INI (*.ini);;Pliki JSON (*.json)""
        new_file_path, _ = QFileDialog.getSaveFileName(self, ""Zapisz plik jako..."", os.path.join(start_path, suggested_name), file_filters)
        if not new_file_path:
            self.statusBar().showMessage(""Zapisywanie anulowane."")
            return False # Cancelled
        new_file_path = os.path.normpath(new_file_path)
        if old_file_path and old_file_path != new_file_path:
             if old_file_path in self.open_files:
                  del self.open_files[old_file_path]
             if old_file_path in self.recents[""open_files""]:
                 self.recents[""open_files""].remove(old_file_path)
                 self._update_recent_files_menu()
        self.open_files[new_file_path] = current_widget
        current_tab_index = self.tab_widget.indexOf(current_widget)
        if current_tab_index != -1:
             self.tab_widget.setTabText(current_tab_index, os.path.basename(new_file_path))
        if new_file_path in self.recents[""open_files""]: # Remove if already exists to move to front
             self.recents[""open_files""].remove(new_file_path)
        self.recents[""open_files""].insert(0, new_file_path)
        self._update_recent_files_menu() # Update the menu
        language = self._get_language_from_path(new_file_path)
        old_highlighter = getattr(current_widget.document(), '_syntax_highlighter', None)
        if old_highlighter:
             old_highlighter.setDocument(None) # Detach
        new_highlighter = CodeSyntaxHighlighter(current_widget.document(), language)
        setattr(current_widget.document(), '_syntax_highlighter', new_highlighter)
        return self._save_file(current_widget, new_file_path)
    def _save_file(self, editor_widget, file_path):
        """"""Zapisuje zawartość wskazanego edytora do wskazanego pliku.""""""
        if not file_path:
             print(""Error: _save_file called with empty path."", file=sys.stderr)
             self.statusBar().showMessage(""Błąd wewnętrzny: próba zapisu bez ścieżki."")
             return False
        try:
            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(editor_widget.toPlainText())
            editor_widget.document().setModified(False) # Mark document as unmodified
            self.statusBar().showMessage(f""Plik zapisano pomyślnie: {os.path.basename(file_path)}"")
            tab_index = self.tab_widget.indexOf(editor_widget)
            if tab_index != -1:
                 current_tab_text = self.tab_widget.tabText(tab_index).rstrip('*')
                 self.tab_widget.setTabText(tab_index, current_tab_text)
            file_info = QFileInfo(file_path)
            dir_path = file_info.dir().path()
            root_path = self.project_model.rootPath()
            if root_path and dir_path.startswith(root_path):
                 dir_index = self.project_model.index(dir_path)
                 if dir_index.isValid():
                      self.project_model.refresh(dir_index)
                 file_index = self.project_model.index(file_path)
                 if file_index.isValid():
                      self.project_model.dataChanged.emit(file_index, file_index, [Qt.ItemDataRole.DisplayRole, Qt.ItemDataRole.DecorationRole]) # Trigger a view update
            if file_path in self.recents[""open_files""]:
                 self.recents[""open_files""].remove(file_path)
            self.recents[""open_files""].insert(0, file_path)
            self._update_recent_files_menu()
            self._save_app_state() # Save state after successful save
            return True # Save succeeded
        except Exception as e:
            QMessageBox.critical(self, ""Błąd zapisu pliku"", f""Nie można zapisać pliku {os.path.basename(file_path)}:\n{e}"")
            self.statusBar().showMessage(f""Błąd zapisu pliku: {os.path.basename(file_path)}"")
            return False # Save failed
    def _save_all_files(self):
        """"""Zapisuje wszystkie otwarte i zmodyfikowane pliki.""""""
        unsaved_files = [path for path, editor in self.open_files.items() if editor.document().isModified()]
        if not unsaved_files:
             self.statusBar().showMessage(""Brak zmodyfikowanych plików do zapisu."")
             return True # Nothing to save, counts as success
        self.statusBar().showMessage(f""Zapisywanie wszystkich zmodyfikowanych plików ({len(unsaved_files)})..."")
        total_saved = 0
        total_failed = 0
        files_to_save = list(unsaved_files)
        for file_path in files_to_save:
             editor_widget = self.open_files.get(file_path)
             if editor_widget is None or self.tab_widget.indexOf(editor_widget) == -1:
                  print(f""Warning: Skipping save for {file_path} - editor widget not found or invalid."", file=sys.stderr)
                  continue # Go to the next file
             if not editor_widget.document().isModified():
                  continue # Already saved
             needs_save_as = (file_path is None or
                              not os.path.exists(file_path) or
                              not QFileInfo(file_path).isFile())
             save_success = False
             if needs_save_as:
                  tab_index = self.tab_widget.indexOf(editor_widget)
                  if tab_index != -1:
                       original_index = self.tab_widget.currentIndex()
                       self.tab_widget.setCurrentIndex(tab_index)
                       save_success = self._save_current_file_as()
                       if original_index != -1 and original_index < self.tab_widget.count():
                           self.tab_widget.setCurrentIndex(original_index)
                  else:
                       print(f""Error: Cannot save '{os.path.basename(file_path if file_path else 'Nowy plik')}' (Save As needed) - widget not found in tabs."", file=sys.stderr)
                       total_failed += 1
                       continue # Skip this file, couldn't save it via Save As mechanism
             else:
                  save_success = self._save_file(editor_widget, file_path) # This updates modified state and status bar
             if save_success:
                  total_saved += 1
             else:
                  total_failed += 1
        if total_saved > 0 and total_failed == 0:
             self.statusBar().showMessage(f""Zapisano pomyślnie wszystkie {total_saved} pliki."")
             return True
        elif total_saved > 0 and total_failed > 0:
             self.statusBar().showMessage(f""Zapisano {total_saved} plików, {total_failed} plików nie udało się zapisać."")
             QMessageBox.warning(self, ""Błąd zapisu wszystkich plików"", f""Nie udało się zapisać {total_failed} plików. Sprawdź konsolę lub logi błędów."")
             return False
        elif total_saved == 0 and total_failed > 0:
             self.statusBar().showMessage(f""Nie udało się zapisać żadnego z {total_failed} plików."")
             QMessageBox.critical(self, ""Błąd zapisu wszystkich plików"", f""Nie udało się zapisać żadnego z plików. Sprawdź konsolę lub logi błędów."")
             return False
        else: # total_saved == 0 and total_failed == 0 (already handled by initial check, but good fallback)
             self.statusBar().showMessage(""Brak zmodyfikowanych plików do zapisu."")
             return True
    def _handle_modification_changed(self, modified):
        """"""Obsługa zmiany stanu modyfikacji dokumentu w aktywnym edytorze.""""""
        editor_document = self.sender() # Dokument, który wywołał sygnał
        if not isinstance(editor_document, QTextDocument): return
        editor = None
        for editor_widget in self.open_files.values():
             if editor_widget.document() is editor_document:
                  editor = editor_widget
                  break
        if editor is None:
             return
        index = self.tab_widget.indexOf(editor)
        if index != -1:
            tab_text = self.tab_widget.tabText(index)
            if modified and not tab_text.endswith('*'):
                self.tab_widget.setTabText(index, tab_text + '*')
            elif not modified and tab_text.endswith('*'):
                self.tab_widget.setTabText(index, tab_text.rstrip('*'))
    def _handle_tab_change(self, index):
         """"""Obsługa zmiany aktywnej zakładki.""""""
         self._hide_find_bar()
         if index != -1:
             widget = self.tab_widget.widget(index)
             if isinstance(widget, QPlainTextEdit):
                  file_path = next((path for path, ed in self.open_files.items() if ed is widget), None)
                  if file_path:
                       self.statusBar().showMessage(f""Edytujesz: {os.path.basename(file_path)}"")
                  else:
                       self.statusBar().showMessage(""Edytujesz: Nowy plik"")
         else:
             self.statusBar().showMessage(""Gotowy."") # Reset status bar
    def _find_next(self):
         """"""Znajduje kolejne wystąpienie tekstu z pola wyszukiwania.""""""
         text_to_find = self.search_input.text()
         self._find_text(text_to_find, 'next')
    def _find_previous(self):
         """"""Znajduje poprzednie wystąpienie tekstu z pola wyszukiwania.""""""
         text_to_find = self.search_input.text()
         self._find_text(text_to_find, 'previous')
    def _find_text(self, text, direction='next'):
        """"""Szuka tekstu w aktualnym edytorze.""""""
        editor = self.tab_widget.currentWidget()
        if not isinstance(editor, QPlainTextEdit):
            self.statusBar().showMessage(""Brak aktywnego edytora do wyszukiwania."")
            return
        if not text:
             self.statusBar().showMessage(""Wpisz tekst do wyszukania."")
             return
        flags = QTextDocument.FindFlag(0) # Default: case-sensitive in Qt find
        if direction == 'previous':
             flags |= QTextDocument.FindFlag.FindBackward
        found = editor.find(text, flags)
        if found:
            self.statusBar().showMessage(f""Znaleziono '{text}'."")
        else:
            self.statusBar().showMessage(f""Nie znaleziono '{text}'. Zawijanie..."")
            cursor = editor.textCursor()
            original_position = cursor.position() # Remember position before wrapping search
            cursor.clearSelection() # Clear selection before moving cursor position programmatically
            cursor.movePosition(cursor.MoveOperation.Start if direction == 'next' else cursor.MoveOperation.End)
            editor.setTextCursor(cursor)
            found_wrapped = editor.find(text, flags)
            if found_wrapped:
                self.statusBar().showMessage(f""Znaleziono '{text}' po zawinięciu."")
            else:
                 self.statusBar().showMessage(f""Nie znaleziono '{text}' w całym pliku."")
                 cursor.clearSelection()
                 cursor.setPosition(original_position)
                 editor.setTextCursor(cursor)
    def _show_find_bar(self):
        """"""Pokazuje pasek wyszukiwania.""""""
        if self.search_input.isVisible():
             self._hide_find_bar()
             return
        self.search_input.setVisible(True)
        self.find_next_button.setVisible(True)
        self.find_prev_button.setVisible(True)
        self.search_input.setFocus() # Ustaw kursor w polu wyszukiwania
    def _hide_find_bar(self):
        """"""Ukrywa pasek wyszukiwania.""""""
        if self.search_input.isVisible(): # Check if visible before hiding
            self.search_input.setVisible(False)
            self.find_next_button.setVisible(False)
            self.find_prev_button.setVisible(False)
            self.search_input.clear() # Wyczyść pole wyszukiwania
    def _show_settings_dialog(self):
        """"""Wyświetla okno dialogowe ustawień.""""""
        temp_settings = self.settings.copy()
        dialog = SettingsDialog(temp_settings, self) # Pass the copy
        font_size_label = QLabel(""Rozmiar czcionki edytora:"")
        font_size_spinbox = QSpinBox()
        font_size_spinbox.setRange(6, 72) # Typical font sizes
        font_size_spinbox.setValue(temp_settings.get(""editor_font_size"", 10))
        dialog_layout = dialog.layout()
        button_box_row_index = dialog_layout.rowCount() - 1
        dialog_layout.insertRow(button_box_row_index, font_size_label, font_size_spinbox)
        setattr(dialog, 'editor_font_size_spinbox', font_size_spinbox)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            updated_settings = dialog.get_settings()
            updated_settings[""editor_font_size""] = font_size_spinbox.value()
            self.settings = updated_settings
            self._apply_theme(self.settings.get(""theme"", ""light"")) # Apply theme
            self._apply_editor_font_size() # Apply new font size
            self._apply_view_settings() # Apply view settings (tree/console visibility)
            self._save_app_state() # Save updated settings and state
            self.statusBar().showMessage(""Ustawienia zapisane."")
        else:
            self.statusBar().showMessage(""Zmiany w ustawieniach anulowane."")
    def _show_about_dialog(self):
        """"""Wyświetla okno informacyjne 'O programie'.""""""
        QMessageBox.about(self, ""O programie"",
                          ""<h2>Proste IDE</h2>""
                          ""<p>Prosty edytor kodu napisany w Pythonie z użyciem biblioteki PyQt6.</p>""
                          ""<p>Wersja: 1.0</p>""
                          ""<p>Autor: [Twoje imię lub nazwa]</p>""
                          ""<p>Dostępne funkcje:</p>""
                          ""<ul>""
                          ""<li>Przeglądanie plików i folderów</li>""
                          ""<li>Otwieranie i edycja plików tekstowych/kodów</li>""
                          ""<li>Kolorowanie składni (Python, JavaScript, HTML, CSS, C++, INI, JSON)</li>""
                          ""<li>Uruchamianie plików Python/JavaScript (z konfigurowalnymi ścieżkami)</li>""
                          ""<li>Uruchamianie skryptów npm (po otwarciu folderu z package.json)</li>""
                          ""<li>**Wprowadzanie poleceń w konsoli**</li>"" # Dodano
                          ""<li>Zapisywanie plików (Zapisz, Zapisz jako, Zapisz wszystko)</li>""
                          ""<li>Historia ostatnio otwieranych plików/folderów</li>""
                          ""<li>Proste wyszukiwanie tekstu</li>""
                          ""<li>Podstawowe motywy (Jasny/Ciemny)</li>""
                          ""<li>Ukrywanie/pokazywanie paneli (Drzewko, Konsola)</li>""
                          ""<li>Zmiana rozmiaru czcionki edytora</li>""
                          ""<li>Operacje na plikach/folderach (Nowy, Zmień nazwę, Usuń, Duplikuj)</li>""
                          ""</ul>""
                          ""<p>Użyte technologie: PyQt6, Python, opcjonalnie qtawesome.</p>"")
    def _update_run_button_menu(self):
        """"""Uaktualnia menu przypisane do QToolButton 'Uruchom'.""""""
        menu = QMenu(self)
        menu.addAction(self.action_run_file)
        if self.node_scripts:
             menu.addSeparator()
             menu.addSection(""Skrypty npm:"")
             sorted_scripts = sorted(self.node_scripts.keys())
             for script_name in sorted_scripts:
                action = QAction(script_name, self)
                action.triggered.connect(lambda checked, name=script_name: self._run_npm_script(name))
                menu.addAction(action)
        else:
             no_scripts_action = QAction(""Brak skryptów npm (package.json)"", self)
             no_scripts_action.setEnabled(False) # Wyłącz akcję
             menu.addAction(no_scripts_action)
        self.run_toolbutton.setMenu(menu)
    def _run_current_file(self):
        """"""Uruchamia aktualnie otwarty plik.""""""
        current_widget = self.tab_widget.currentWidget()
        if not isinstance(current_widget, QPlainTextEdit):
            self._append_console_output(""Brak aktywnego pliku do uruchomienia."", is_error=True)
            return
        file_path = next((path for path, editor_widget in self.open_files.items() if editor_widget is current_widget), None)
        if not file_path or not os.path.exists(file_path) or not os.path.isfile(file_path):
             self._append_console_output(""Ścieżka aktywnego pliku jest nieprawidłowa lub plik nie istnieje."", is_error=True)
             return
        if current_widget.document().isModified():
             self._append_console_output(""Zapisywanie pliku przed uruchomieniem..."")
             if not self._save_file(current_widget, file_path):
                 self._append_console_output(""Zapisywanie nie powiodło się. Anulowano uruchomienie."", is_error=True)
                 return
        language = self._get_language_from_path(file_path)
        command = []
        working_dir = os.path.dirname(file_path) # Directory of the file
        python_path = self.settings.get(""python_path"")
        node_path = self.settings.get(""node_path"")
        if language == 'python':
            interpreter = python_path if python_path and os.path.exists(python_path) else ""python""
            command = [interpreter, ""-u"", file_path]
        elif language == 'javascript':
            interpreter = node_path if node_path and os.path.exists(node_path) else ""node""
            command = [interpreter, file_path]
        elif language in ['html', 'css']:
             self._append_console_output(f""Otwieranie pliku {os.path.basename(file_path)} w domyślnej przeglądarce..."")
             try:
                  QDesktopServices.openUrl(QUrl.fromLocalFile(file_path))
                  self.statusBar().showMessage(f""Otwarto plik w przeglądarce: {os.path.basename(file_path)}"")
             except Exception as e:
                  self._append_console_output(f""Błąd podczas otwierania pliku w przeglądarce: {e}"", is_error=True)
                  self.statusBar().showMessage(""Błąd otwierania w przeglądarce."")
             return # Do not run as a process
        else:
            self._append_console_output(f""Nieznany typ pliku do uruchomienia: {language}"", is_error=True)
            return
        if command:
             self._run_command(command, working_dir)
    def _check_package_json(self, folder_path):
        """"""Checks if package.json exists in the folder and parses scripts.""""""
        if not folder_path or not os.path.isdir(folder_path):
             self.node_scripts = {} # Clear any previous scripts
             self._update_run_button_menu() # Update run menu button
             return
        package_json_path = os.path.join(folder_path, 'package.json')
        self.node_scripts = {} # Clear previous scripts
        if os.path.exists(package_json_path):
            try:
                with open(package_json_path, 'r', encoding='utf-8') as f:
                    package_data = json.load(f)
                scripts = package_data.get('scripts', {})
                if isinstance(scripts, dict) and scripts:
                    self.node_scripts = scripts
                    self._append_console_output(f""Znaleziono {len(scripts)} skryptów w package.json w {os.path.basename(folder_path)}."")
                else:
                     self._append_console_output(f""Znaleziono package.json w {os.path.basename(folder_path)}, ale brak skryptów w sekcji 'scripts'."")
            except (FileNotFoundError, json.JSONDecodeError, Exception) as e:
                self._append_console_output(f""Błąd podczas parsowania package.json w {os.path.basename(folder_path)}:\n{e}"", is_error=True)
                self.node_scripts = {} # Ensure scripts are empty on error
        else:
             pass # Silence is golden
        self._update_run_button_menu() # After checking package.json, update the run menu button
    def _run_npm_script(self, script_name):
        """"""Runs the specified npm script.""""""
        if not self.current_project_dir or not os.path.isdir(self.current_project_dir):
            self._append_console_output(""Brak otwartego folderu projektu do uruchomienia skryptu npm."", is_error=True)
            return
        if script_name not in self.node_scripts:
            self._append_console_output(f""Skrypt '{script_name}' nie znaleziono w package.json otwartego projektu."", is_error=True)
            return
        node_path = self.settings.get(""node_path"")
        npm_command = ""npm"" # Default command
        if node_path and os.path.exists(node_path):
             node_dir = os.path.dirname(node_path)
             npm_candidates = [os.path.join(node_dir, 'npm')]
             if platform.system() == ""Windows"":
                  npm_candidates.append(os.path.join(node_dir, 'npm.cmd'))
             found_npm = None
             for candidate in npm_candidates:
                  if os.path.isfile(candidate) and os.access(candidate, os.X_OK):
                       found_npm = candidate
                       break
             if found_npm:
                  npm_command = found_npm
             else:
                  self._append_console_output(f""Ostrzeżenie: Nie znaleziono 'npm' (lub nie jest wykonywalne) obok skonfigurowanej ścieżki node '{node_path}'. Polegam na systemowym PATH."", is_error=True)
        command = [npm_command, ""run"", script_name]
        working_dir = self.current_project_dir # Npm scripts are run in the project directory
        self._run_command(command, working_dir)
    def _run_console_command(self):
        """"""Uruchamia komendę wpisaną w polu tekstowym konsoli.""""""
        command_text = self.console_input.text().strip()
        if not command_text:
            return # Nic nie wpisano
        self.console_input.clear() # Wyczyść pole wprowadzania
        self._append_console_output(f""> {command_text}"") # Wyświetl wpisaną komendę w konsoli
        try:
            command = shlex.split(command_text)
        except ValueError as e:
             self._append_console_output(f""Błąd parsowania komendy: {e}"", is_error=True)
             self.statusBar().showMessage(""Błąd parsowania komendy."")
             return
        if not command:
             self._append_console_output(""Błąd: Pusta komenda po parsowaniu."", is_error=True)
             self.statusBar().showMessage(""Błąd: Pusta komenda."")
             return
        working_dir = self.current_project_dir if self.current_project_dir and os.path.isdir(self.current_project_dir) else os.getcwd()
        self._run_command(command, working_dir)
    def _run_command(self, command, working_dir):
        """"""Uruchamia podaną komendę w QProcess.""""""
        if self.process.state() != QProcess.ProcessState.NotRunning:
            self._append_console_output(""Inny proces jest już uruchomiony. Zakończ go, aby uruchomić nowy."", is_error=True)
            self._append_console_output(""Możesz zatrzymać proces używając przycisku stop lub wpisując polecenie 'stop' w konsoli (jeśli obsługiwane przez program)."")
            return
        command_str = shlex.join(command) # Better command formatting
        self._append_console_output(f""Uruchamianie: {command_str}\nw katalogu: {working_dir}\n---"")
        self.statusBar().showMessage(""Proces uruchomiony..."")
        try:
            if not command:
                 self._append_console_output(""Komenda do uruchomienia jest pusta."", is_error=True)
                 self.statusBar().showMessage(""Błąd: Pusta komenda."")
                 return
            program = command[0]
            arguments = command[1:]
            self.process.setWorkingDirectory(working_dir)
            process_environment = QProcessEnvironment.systemEnvironment()
            current_path = process_environment.value(""PATH"", """") # Get system PATH
            paths_to_prepend = []
            py_path = self.settings.get(""python_path"")
            if py_path and os.path.exists(py_path):
                 py_dir = os.path.dirname(py_path)
                 current_path_dirs = [os.path.normcase(p) for p in current_path.split(os.pathsep) if p]
                 if os.path.normcase(py_dir) not in current_path_dirs:
                      paths_to_prepend.append(py_dir)
            node_path = self.settings.get(""node_path"")
            if node_path and os.path.exists(node_path):
                 node_dir = os.path.dirname(node_path)
                 if os.path.normcase(node_dir) not in current_path_dirs:
                     paths_to_prepend.append(node_dir)
            if paths_to_prepend:
                 new_path = os.pathsep.join(paths_to_prepend) + (os.pathsep + current_path if current_path else """")
            else:
                 new_path = current_path # No new paths to add
            process_environment.insert(""PATH"", new_path) # Overwrite or add PATH
            if platform.system() == ""Windows"" and process_environment.value(""Path"") is not None:
                 if process_environment.value(""Path"") != current_path: # Avoid unnecessary update
                      process_environment.insert(""Path"", new_path)
            self.process.setProcessEnvironment(process_environment)
            self.process.start(program, arguments)
            if not self.process.waitForStarted(1000):
                 error_string = self.process.errorString()
                 self._append_console_output(f""Nie udało się uruchomić procesu '{program}': {error_string}"", is_error=True)
                 self.statusBar().showMessage(f""Błąd uruchamiania: {program}"")
                 return # Process didn't start, exit
        except Exception as e:
            self._append_console_output(f""Wystąpił nieoczekiwany błąd podczas próby uruchomienia:\n{e}"", is_error=True)
            self.statusBar().showMessage(""Błąd podczas uruchamiania."")
    def _append_console_output(self, text, is_error=False):
        """"""Adds text to the console, optionally formatting as an error.""""""
        cursor = self.console.textCursor()
        cursor.movePosition(cursor.MoveOperation.End)
        original_fmt = cursor.charFormat()
        fmt = QTextCharFormat()
        if is_error:
            fmt.setForeground(QColor(""#DC143C"")) # Crimson
        cursor.setCharFormat(fmt)
        text_to_insert = text
        if text and not text.endswith('\n'):
             text_to_insert += '\n'
        cursor.insertText(text_to_insert)
        cursor.setCharFormat(original_fmt)
        self.console.ensureCursorVisible()
    def _handle_stdout(self):
        """"""Reads standard output of the process and displays it in the console.""""""
        while self.process.bytesAvailable(): # Correct usage
            data = self.process.readAllStandardOutput()
            try:
                 text = bytes(data).decode('utf-8')
            except UnicodeDecodeError:
                 try:
                     text = bytes(data).decode('latin-1')
                 except Exception:
                     text = bytes(data).decode('utf-8', errors='replace') # Replace unknown characters
            self._append_console_output(text)
    def _handle_stderr(self):
        """"""Reads standard error of the process and displays it in the console (in red).""""""
        while self.process.bytesAvailable(): # Correct usage
            data = self.process.readAllStandardError()
            try:
                 text = bytes(data).decode('utf-8')
            except UnicodeDecodeError:
                 try:
                     text = bytes(data).decode('latin-1')
                 except Exception:
                     text = bytes(data).decode('utf-8', errors='replace') # Replace unknown characters
            self._append_console_output(text, is_error=True)
    def _handle_process_finished(self, exitCode, exitStatus):
        """"""Handles the process finishing.""""""
        self._handle_stdout()
        self._handle_stderr()
        self._append_console_output(""\n--- Zakończono proces ---"") # Add a clear separator
        if exitStatus == QProcess.ExitStatus.NormalExit:
            self._append_console_output(f""Proces zakończył się z kodem wyjścia: {exitCode}"")
            self.statusBar().showMessage(f""Proces zakończył się. Kod wyjścia: {exitCode}"")
        else:
            self._append_console_output(f""Proces zakończył się awaryjnie z kodem wyjścia: {exitCode}"", is_error=True)
            self.statusBar().showMessage(f""Proces zakończył się awaryjnie. Kod wyjścia: {exitCode}"")
        if self.settings.get(""show_console"", True):
             self._show_console_panel() # Ensure console is visible and correctly sized
    def _copy_console(self):
         """"""Copies the entire content of the console to the clipboard.""""""
         clipboard = QApplication.clipboard()
         clipboard.setText(self.console.toPlainText())
         self.statusBar().showMessage(""Zawartość konsoli skopiowana do schowka."")
    def _toggle_tree_view(self, checked):
         """"""Shows/hides the file tree panel.""""""
         self.main_splitter.widget(0).setVisible(checked)
         self.settings[""show_tree""] = checked # Save state
         self._save_app_state() # Save settings change
         self._apply_view_settings() # Re-apply sizes to ensure panels aren't too small/large
    def _toggle_console(self, checked):
         """"""Shows/hides the console panel.""""""
         self.right_splitter.widget(1).setVisible(checked)
         self.settings[""show_console""] = checked # Save state
         self._save_app_state() # Save settings change
         if checked:
              self._show_console_panel() # Use method that sets sizes
    def _show_console_panel(self):
        """"""Ensures the console panel is visible and has a reasonable size.""""""
        self.right_splitter.widget(1).setVisible(True)
        self.action_toggle_console.setChecked(True)
        sizes = self.right_splitter.sizes()
        if len(sizes) == 2:
            total_height = sum(sizes)
            min_console_height = 100
            min_editor_height = 100
            if sizes[1] < min_console_height or (sizes[1] < 10 and self.settings.get(""show_console"", True)):
                 if total_height > min_console_height + min_editor_height:
                      self.right_splitter.setSizes([total_height - min_console_height, min_console_height])
                 elif total_height > 200: # Ensure some minimal height if window is small
                      self.right_splitter.setSizes([total_height // 2, total_height // 2]) # Split equally
    def _apply_view_settings(self):
        """"""Apply panel visibility settings after loading.""""""
        show_tree = self.settings.get(""show_tree"", True)
        show_console = self.settings.get(""show_console"", True)
        self.main_splitter.widget(0).setVisible(show_tree)
        self.action_toggle_tree.setChecked(show_tree)
        self.right_splitter.widget(1).setVisible(show_console)
        self.action_toggle_console.setChecked(show_console)
        main_sizes = self.main_splitter.sizes()
        if len(main_sizes) == 2:
             total_width = sum(main_sizes)
             min_tree_width = 150 # Minimal reasonable width for the tree view
             min_right_panel_width = 200 # Minimal width for the editor/console side
             if main_sizes[0] < min_tree_width or (main_sizes[0] < 10 and show_tree):
                  if total_width > min_tree_width + min_right_panel_width:
                       self.main_splitter.setSizes([min_tree_width, total_width - min_tree_width])
                  elif total_width > 300: # Ensure some minimal width if window is small
                       self.main_splitter.setSizes([total_width // 3, 2 * total_width // 3]) # Split approx 1/3, 2/3
        right_sizes = self.right_splitter.sizes()
        if len(right_sizes) == 2:
             total_height = sum(right_sizes)
             min_console_height = 100
             min_editor_height = 100 # Minimal height for the editor area
             if right_sizes[1] < min_console_height or (right_sizes[1] < 10 and show_console):
                   if total_height > min_console_height + min_editor_height:
                       self.right_splitter.setSizes([total_height - min_console_height, min_console_height])
                   elif total_height > 200: # Ensure some minimal height if window is small
                       self.right_splitter.setSizes([total_height // 2, total_height // 2]) # Split equally
             elif right_sizes[0] < min_editor_height and show_console and total_height > min_console_height + min_editor_height:
                   self.right_splitter.setSizes([min_editor_height, total_height - min_editor_height])
    def _apply_editor_font_size(self):
        """"""Apply the editor font size to all open editors and the console.""""""
        font_size = self.settings.get(""editor_font_size"", 10)
        new_font = QFont(""Courier New"", font_size) # Use Courier New, change size
        self.base_editor_font = new_font # Update the base font
        self.console.setFont(new_font)
        self.console_input.setFont(new_font)
        for editor_widget in self.open_files.values():
            editor_widget.setFont(new_font)
            if hasattr(editor_widget.document(), '_syntax_highlighter'):
                 editor_widget.document().rehighlight()
    def _apply_theme(self, theme_name):
        """"""Applies the selected color theme.""""""
        if theme_name == ""dark"":
            self.setStyleSheet(""""""
                QMainWindow, QWidget {
                    background-color: #2E2E2E;
                    color: #D3D3D3;
                }
                QMenuBar {
                    background-color: #3C3C3C;
                    color: #D3D3D3;
                }
                QMenuBar::item:selected {
                    background-color: #505050;
                }
                QMenu {
                    background-color: #3C3C3C;
                    color: #D3D3D3;
                    border: 1px solid #505050;
                }
                QMenu::item:selected {
                    background-color: #505050;
                }
                QToolBar {
                    background-color: #3C3C3C;
                    color: #D3D3D3;
                    spacing: 5px;
                    padding: 2px;
                }
                QToolButton { /* Buttons on toolbar */
                    background-color: transparent;
                    border: 1px solid transparent;
                    padding: 3px;
                    border-radius: 4px; /* Slight rounding */
                }
                QToolButton:hover {
                    border: 1px solid #505050;
                    background-color: #454545;
                }
                 QToolButton:pressed {
                     background-color: #404040;
                 }
                QPushButton { /* Standard buttons (e.g., Run, Find) */
                    background-color: #505050;
                    color: #D3D3D3;
                    border: 1px solid #606060;
                    padding: 4px 8px;
                    border-radius: 4px;
                }
                QPushButton:hover {
                    background-color: #606060;
                }
                QPushButton:pressed {
                    background-color: #404040;
                }
                QStatusBar {
                    background-color: #3C3C3C;
                    color: #D3D3D3;
                }
                QSplitter::handle {
                    background-color: #505050;
                }
                QSplitter::handle:horizontal {
                    width: 5px;
                }
                QSplitter::handle:vertical {
                    height: 5px;
                }
                QTreeView {
                    background-color: #1E1E1E;
                    color: #D3D3D3;
                    border: 1px solid #3C3C3C;
                    alternate-background-color: #252525; /* Alternating row colors */
                }
                QTreeView::item:selected {
                    background-color: #007acc; /* Selection color (VS Code blue) */
                    color: white;
                }
                QTreeView::branch:selected {
                     background-color: #007acc; /* Selection color for branch indicator */
                }
                QTabWidget::pane { /* Frame around tab content area */
                    border: 1px solid #3C3C3C;
                    background-color: #1E1E1E;
                }
                QTabWidget::tab-bar:top {
                    left: 5px; /* Leave some space on the left */
                }
                QTabBar::tab {
                    background: #3C3C3C;
                    color: #D3D3D3;
                    border: 1px solid #3C3C3C;
                    border-bottom-color: #1E1E1E; /* Blend bottom border with pane background */
                    border-top-left-radius: 4px;
                    border-top-right-radius: 4px;
                    padding: 4px 8px;
                    margin-right: 1px;
                }
                QTabBar::tab:selected {
                    background: #1E1E1E; /* Match pane background for selected tab */
                    border-bottom-color: #1E1E1E;
                }
                QTabBar::tab:hover {
                    background: #454545; /* Hover effect */
                }
                /* Optional: Style for close button */
                /* QTabBar::close-button { image: url(:/path/to/close_icon_dark.png); } */
                QPlainTextEdit { /* Code Editor */
                    background-color: #1E1E1E;
                    color: #D3D3D3;
                    border: none; /* Border is on QTabWidget::pane */
                    selection-background-color: #007acc; /* Selection color */
                    selection-color: white;
                }
                 QPlainTextEdit[readOnly=""true""] { /* Console */
                     background-color: #1E1E1E; /* Same as editor background */
                     color: #CCCCCC; /* Console text color */
                      selection-background-color: #007acc;
                      selection-color: white;
                 }
                QLineEdit { /* Search bar, input fields in settings */
                    background-color: #3C3C3C;
                    color: #D3D3D3;
                    border: 1px solid #505050;
                    padding: 2px;
                     selection-background-color: #007acc;
                     selection-color: white;
                     border-radius: 3px; /* Slight rounding */
                }
                 QComboBox { /* ComboBox in settings */
                    background-color: #3C3C3C;
                    color: #D3D3D3;
                    border: 1px solid #505050;
                    padding: 2px;
                     border-radius: 3px;
                 }
                 QComboBox::drop-down {
                    border: 0px; /* Remove default arrow */
                 }
                  QComboBox QAbstractItemView { /* Dropdown list of ComboBox */
                     background-color: #3C3C3C;
                     color: #D3D3D3;
                     selection-background-color: #007acc;
                     border: 1px solid #505050;
                 }
                 QDialog { /* Settings dialog window */
                     background-color: #2E2E2E;
                     color: #D3D3D3;
                 }
                  QLabel { /* Labels in dialogs */
                      color: #D3D3D3;
                  }
                  QDialogButtonBox QPushButton { /* Buttons in dialogs */
                      background-color: #505050;
                      color: #D3D3D3;
                      border: 1px solid #606060;
                      padding: 5px 10px;
                      border-radius: 4px;
                  }
                   QDialogButtonBox QPushButton:hover {
                      background-color: #606060;
                   }
                    QDialogButtonBox QPushButton:pressed {
                       background-color: #404040;
                   }
                   QSpinBox { /* Spinbox in settings */
                       background-color: #3C3C3C;
                       color: #D3D3D3;
                       border: 1px solid #505050;
                       padding: 2px;
                        selection-background-color: #007acc;
                        selection-color: white;
                         border-radius: 3px;
                   }
                   QFrame { /* Frames like the one in SettingsDialog */
                       border: none;
                   }
                /* Style for the console input field */
                QLineEdit[placeholderText=""Wpisz polecenie...""] {
                    background-color: #3C3C3C;
                    color: #D3D3D3;
                    border: 1px solid #505050;
                    padding: 2px;
                    margin: 0px; /* Remove default margins */
                    border-radius: 0px; /* No rounding for console input */
                }
            """""")
        elif theme_name == ""light"":
             self.setStyleSheet("""")
        self.statusBar().showMessage(f""Zmieniono motyw na: {theme_name.capitalize()}"")
if __name__ == '__main__':
    app = QApplication(sys.argv)
    QLocale.setDefault(QLocale(QLocale.Language.Polish, QLocale.Country.Poland))
    main_window = IDEWindow()
    main_window.show()
    sys.exit(app.exec())"
7PQjX7Sp,VIP Chat Tag,Cakey3101,Lua,Sunday 18th of May 2025 04:59:11 AM CDT,"local TextChatService = game:GetService(""TextChatService"")
local MarketPlaceService = game:GetService(""MarketplaceService"")
local Players = game:GetService(""Players"")

TextChatService.OnIncomingMessage = function(Messsage: TextChatMessage)
	local Properties = Instance.new(""TextChatMessageProperties"")
	
	if Messsage.TextSource then
		local Player = Players:GetPlayerByUserId(Messsage.TextSource.UserId)
		
		if MarketPlaceService:UserOwnsGamePassAsync(Player.UserId, 1221054409) then
			Properties.PrefixText = ""<font color='#ffff00'>[👑 VIP]</font> ""..Messsage.PrefixText 
		end
	end
	
	return Properties
end"
XNCZuUTL,2025-05-18T11:50:43.669800,powerampache,PHP,Sunday 18th of May 2025 04:50:44 AM CDT,"1.00-70 (70) - DB: 83
luci.sixsixsix.powerampache2.domain.errors.MusicException: {""errorAction"":""share_create"",""errorCode"":""4703"",""errorMessage"":""Enable: share"",""errorType"":""system""}
	at luci.sixsixsix.powerampache2.data.AlbumsRepositoryImpl$getAlbumShareLink$2.invokeSuspend(AlbumsRepositoryImpl.kt:440)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at android.os.Handler.handleCallback(Handler.java:991)
	at android.os.Handler.dispatchMessage(Handler.java:102)
	at android.os.Looper.loopOnce(Looper.java:232)
	at android.os.Looper.loop(Looper.java:317)
	at android.app.ActivityThread.main(ActivityThread.java:8934)
	at java.lang.reflect.Method.invoke(Native Method)
	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:591)
	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:911)

getPlaylistShareLink() - {""errorAction"":""share_create"",""errorCode"":""4703"",""errorMessage"":""Enable: share"",""errorType"":""system""}"
n1TMmCce,Player,GigaOrts,C#,Sunday 18th of May 2025 04:19:32 AM CDT,"using UnityEngine;

namespace Scripts28785
{
    public class Player : MonoBehaviour
    {
        private const string Horizontal = ""Horizontal"";
        private const string Vertical = ""Vertical"";
        private const string RunMultiplier = ""RunMultiplier"";
        private const string Run = ""Run"";
        private readonly float _defaultSpeed = 1f;

        private Rigidbody2D _body2D;
        private Animator _animator;
        public float _speed = 3f;
        private Camera _camera;
        private Vector3 _faceDirection;

        private void Awake()
        {
            _body2D = GetComponent<Rigidbody2D>();
            _animator = GetComponent<Animator>();
        }

        private void Start()
        {
            _camera = Camera.main;
        }
    
        private void Update()  
        {  
            RotateCharacter();  
        }  

        private void RotateCharacter()  
        {   
            Vector3 mousePosition = Input.mousePosition;  
 
            Vector3 worldMousePosition = _camera.ScreenToWorldPoint(mousePosition);  
         
            _faceDirection = worldMousePosition - transform.position;  

            if (_faceDirection.x < 0)  
            {  
                transform.rotation = Quaternion.Euler(0, 180,0); 
            }  
            else  
            {  
                transform.rotation = Quaternion.Euler(0, 0,0);
            }  
        }  
    
        private void FixedUpdate()
        {
            Vector2 velocity = new Vector2(
                Input.GetAxisRaw(Horizontal),
                Input.GetAxisRaw(Vertical));

            bool isRunning = velocity.magnitude > 0;
            _animator.SetBool(Run, isRunning);

            if ((_faceDirection.x < 0 && velocity.x > 0) ||
                (_faceDirection.x > 0 && velocity.x < 0) && isRunning)
            {
                _animator.SetFloat(RunMultiplier, -_defaultSpeed);
            }
            else
            {
                _animator.SetFloat(RunMultiplier, _defaultSpeed);
            }
        
            _body2D.velocity = velocity.normalized * _speed;
        }
    }
}
"
3gvg9fFV,Untitled,rqwfea,Python,Sunday 18th of May 2025 04:08:35 AM CDT,"1.4:https://getfile.dokpub.com/yandex/get/https://disk.yandex.ru/d/7TU1K3P70ri6yQ
"
XbuEdXbr,15 отрезки максимальный A,nq1s788,Python,Sunday 18th of May 2025 03:44:43 AM CDT,"#4872 https://kpolyakov.spb.ru/school/ege/gen.php?action=viewAllEgeNo&egeId=15&cat68=on
answ = 0
p = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20}
q = {5, 10, 15, 20, 25, 30, 35, 40, 45, 50}
for x in range(-1000, 1000):
    if ((1) <= (x in p)) and ((x in q) <= (not (1))):
        answ += 1
print(answ)"
J3XkcKrE,15 множества наименьшее A,nq1s788,Python,Sunday 18th of May 2025 03:43:28 AM CDT,"#4879 https://kpolyakov.spb.ru/school/ege/gen.php?action=viewAllEgeNo&egeId=15&cat68=on
answ = 0
p = {1, 2, 4, 8}
q = {1, 2, 3, 4, 5, 6}
for x in range(-1000, 1000):
    if ((not (0)) <= (not((x in p) or (x in q)))) == 0:
        answ += 1
print(answ)"
Uj5Ck5my,26 коробки дп,nq1s788,Python,Sunday 18th of May 2025 03:00:54 AM CDT,"data = open('26.txt').readlines()
n, k, Q = map(int, data[0].split())
a = []
for e in data[1:]:
    a.append(tuple(map(int, e.split())))
a.sort()
inf = 10000000
mx_s = a[-1][0]
dp = [[inf for j in range(Q + 1)] for i in range(mx_s + 1)]
cur_a = -1
mn = inf
for i in range(1, mx_s + 1):
    if cur_a != n - 1 and a[cur_a + 1][0] == i:
        cur_a += 1
    if cur_a != -1:
        mn = min(mn, a[cur_a][1])
        dp[i][1] = mn
for q in range(2, Q + 1):
    cur_a = -1
    mn = inf
    for i in range(1, mx_s + 1):
        if cur_a != n - 1 and a[cur_a + 1][0] == i:
            cur_a += 1
        if a[cur_a][0] == i and i - k >= 1:
            mn = min(dp[i - k][q - 1] + a[cur_a][1], mn)
            dp[i][q] = mn
        else:
            dp[i][q] = mn
print(dp[mx_s][Q])"
Xgywy4uu,STYFF,Yobanzda,Lua,Sunday 18th of May 2025 12:35:20 AM CDT,FBHJGBIJ90VADS7T
2y3VmdQd,bottom dialog bottom sheet flutter,muhaiminurabir,Dart,Sunday 18th of May 2025 12:00:10 AM CDT,"  void _showBottomView() {
    showModalBottomSheet(
      context: context,
      backgroundColor: Colors.white,
      useSafeArea: true,
      isDismissible: false,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(24),
          topRight: Radius.circular(24),
        ),
      ),
      builder: (ctx) {
        return StatefulBuilder(
          builder: (
            BuildContext context,
            void Function(void Function()) changeState,
          ) {
            return Container(
              margin: const EdgeInsets.fromLTRB(16, 20, 16, 12),
              child: Column(
                children: [
                  Icon(
                    Icons.verified_user,
                    size: 50,
                    color: ProjectColors.primaryColor,
                  ),
                  ElevatedButton(
                    style: ButtonStyle(
                      backgroundColor: WidgetStateProperty.all(
                        ProjectColors.primaryColor,
                      ),
                      padding: WidgetStateProperty.all(EdgeInsets.all(8)),
                      shape: WidgetStatePropertyAll(
                        RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(10),
                        ),
                      ),
                    ),
                    onPressed: () {
                      Navigator.of(context).pop();
                      Navigator.pushReplacementNamed(
                        context,
                        guestHomePage,
                        arguments: 3,
                      );
                    },
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      spacing: 6,
                      children: [
                        SvgPicture.asset(
                          ""assets/images/ic_login.svg"",
                          height: 24,
                          width: 24,
                          colorFilter: ColorFilter.mode(
                            ProjectColors.white,
                            BlendMode.srcIn,
                          ),
                        ),
                        Text(
                          CustomStrings.login,
                          style: GoogleFonts.poppins(
                            fontWeight: FontWeight.w500,
                            fontSize: 16,
                            color: ProjectColors.white,
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            );
          },
        );
      },
    );
  }
"
aMvLQXDz,cipher wheel scad,j0h,C,Saturday 17th of May 2025 10:55:37 PM CDT,"// Parameters
ring_thickness = 10;    // Thickness of the ring (radial)
ring_height = 5;       // Height of the ring
letter_count = 26;
angle_step = 360 / letter_count;
font_size = 6;
font_name = ""Liberation Sans"";  // Change if needed
text_depth = 1.0;  // How deep the engraving goes

module ring_with_letters(ring_radius) {
    difference() {
        // Base ring
        cylinder(h = ring_height, r = ring_radius + ring_thickness / 2, $fn = 200);
        //r = ring_radius + ring_thickness / 2;
        //echo (""outer "", r);
        cylinder(h = ring_height + 1, r = ring_radius - ring_thickness / 2, $fn = 200);
        //r = ring_radius - ring_thickness / 2;
        //echo (""inner "", r);
        // Engraved letters (subtracted)
        for (i = [0 : letter_count - 1]) {
            angle = i * angle_step;
            letter = chr(65 + i);  // 65 = 'A'

            rotate([0, 0, angle])
            translate([ring_radius, 0, ring_height - text_depth])  // Start near top
            rotate([0, 0, 0])
            linear_extrude(height = text_depth)
                text(letter, size = font_size, font = font_name, halign = ""center"", valign = ""bottom"");
        }
    }
}

// Example usage
ring_with_letters(50);
ring_with_letters(39.9);
"
uTThUC8X,vtables,Jhynjhiruu,C,Saturday 17th of May 2025 09:55:15 PM CDT,"uim vtable

1  = x_GetAppInstance(uim, retAppInst)
2  = ?
3  = framenumber?(uim, retNum)
4  = framenumber?(uim, ..., ...)
5  = ret 0
6  = x_GetCurrentTime(uim, ..., ..., ..., ...)
7  = x_CreateLock(uim, ..., retLock)
8  = x_CreateStream(uim, ..., ..., pathname, extension, retID)
9  = x_RemoveStream(uim, ..., ...)
10 = x_OpenStream(uim, id, ..., ...)
11 = ret -2
12 = x_GetPalette(uim, retPalette)
13 = new_interactor(uim, ...,  ..., retInteractor)
14 = ?x_GetRequestHeaders
15 = ret -2
16 = ret -2
17 = ret -2
18 = ret -2
19 = ret -2

hm vtable

0  = destroy?(hm)
1  = x_LoadComponent(hm, ???)
2  = x_UnloadComponent(hm, which)
3  = x_FindHandlerInfo(hm, ..., ..., ..., ..., ...)
4  = ?
5  = ?
6  = foreach?(hm, ...)
7  = get_supported_mime_types(hm, retList)
8  = ?
9  = get_all_option_enums(hm, ..., ..., ..., ...)
10 = set_all_option_enums(hm, ..., ..., ...)

__different_cm vtable

0  = get_cm(cm, retCM)
1  = x_GetServices(cm, ..., ...)
2  = get_sm(cm, retSM)
3  = ?
4  = ?
5  = ?
6  = ?
7  = x_GetBucketPool(cm, ...)
8  = ?
9  = x_GetCurrentTime(cm, ..., ..., ..., ...)
10 = x_CreateLock(cm, ..., retLock)
11 = x_CreateStream(cm, ..., ..., ..., pathname, retID)
12 = x_RemoveStream(cm, ..., ...)
13 = x_OpenStream(cm, id, ..., ...)
14 = ret -2
15 = ret -2
16 = ret -2
17 = ret -2
18 = ret -2
19 = ret -2
20 = x_GetPalette(cm, retPalette)
21 = x_CreateInteractor(cm, ..., ..., retInteractor)
22 = ret
23 = ret
24 = x_GetRequestHeaders

pm vtable

0  = x_DelPropertyManager(pm)
1  = x_Get(pm, ???...)
2  = x_Set(pm, ???...)

vm vtable

0  = x_DelViewManager(vm)
1  = x_NewViewForTarget(vm, ..., ...)
2  = bind_view?(vm, t, ...)
3  = unbind_view?(vm, t)
4  = destroy_view?(vm, t, ...)
5  = get_target_data?(vm, t, ...)
6  = ret -3
7  = ret -3
8  = ret -3
9  = ret -3
10 = ?
11 = x_SetViewFocus(vm, t, ...)
12 = x_SetViewInteraction(vm, t, ...)
13 = ret -3
14 = x_SetViewSize(vm, t, size)
15 = ?
16 = ?(vm, t, targetName, ..., ..., ..., ..., ...)
17 = ?(vm, t, ..., ..., ..., ..., ..., ...)
18 = ?(vm, t, ..., ..., ..., ..., ..., ...)
19 = ?(vm, t, ..., ..., ..., ..., ..., ...)
20 = ?(vm, t, ..., ..., ..., ...)
21 = ?(vm, t, ..., ..., ..., ...)
22 = ?(vm, t, ...)
23 = ?(vm, t, ...)
24 = ?(vm, t, ...)
25 = ?(vm, t, ...)
26 = ret -3
27 = ret -3
28 = ret -3
29 = ret -3
30 = ret -3
31 = ?(vm, t)
32 = ?(vm, t)
33 = ?(vm, t, ...)

cm vtable

1  = x_DelContentManager(cm)
2  = x_LoadComponent(cm, ???...)
3  = x_UnloadComponent(cm, ..., ...)
4  = ?
5  = ?
6  = x_GetProperty(cm, ???...)
7  = x_SetProperty(cm, ???...)
8  = ret 1
9  = ?
10 = x_AbortRequest(cm, ...)
11 = ?
12 = target_something?(cm, ???...)
13 = ?(cm, ..., ..., ...)
14 = ?(cm, ...)
15 = ?(cm, ..., ...)
16 = ?(cm, ...)
17 = x_Close(cm, ...)
18 = x_ShowHide(cm, ..., ...)
19 = x_Focus(cm, ..., ...)
20 = x_SetOrigin(cm, ..., ...)
21 = x_GetDesiredSize(cm, ..., ..., ...)
22 = x_SetSize(cm, ..., ...)
23 = x_Scroll(cm, ..., ...)
24 = x_Find(cm, ..., ..., ...)
25 = x_Info(cm, ..., ..., ...)
26 = x_SaveAs(cm, ..., ..., ...)
27 = x_Print(cm, ..., ...)
28 = x_LoadMissing(cm, ...)
29 = x_Reset(cm, ...)
30 = x_Resume(cm, ...)
31 = x_Suspend(cm, ...)
32 = x_Edit(cm, ..., ...)
33 = x_CanPerform(cm, ..., ..., ...)
34 = x_GetFormEltValue(cm, ..., ..., ..., ..., ...)
35 = x_SetFormEltValue(cm, ..., ..., ..., ..., ...)
36 = x_AddFormEltAction(cm, ..., ..., ..., ..., ..., ..., ...)
37 = x_RemoveFormEltAction(cm, ..., ..., ..., ..., ..., ..., ...)
38 = x_AddLinkAction(cm, ..., ..., ..., ..., ..., ...)
39 = x_RemoveLinkAction(cm, ..., ..., ..., ..., ..., ...)
40 = x_AddScriptAction(cm, ..., ..., ..., ..., ...)
41 = x_RemoveScriptAction(cm, ..., ..., ..., ..., ...)
42 = x_OnEvent(cm, ..., ...)"
vZeS3zX0,Feli Add cat,Talithacelin,Python,Saturday 17th of May 2025 09:45:37 PM CDT,"add_cat.blade.php
@extends('base.base')
@section('content')
<head>
<link href=""https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css""
rel=""stylesheet"">
<style>
html,
body {
margin: 0;
padding: 0;
width: 100%;
overflow-x: hidden;
background-color: #f4f4f4;
}
.category-container {
margin-left: 235px; /* match your .sidebar width exactly */
padding: 20px;
/* background-color: #f4f4f4; */
overflow-x: hidden;
box-sizing: border-box;
max-width: calc(100vw - 250px);
}
.category-header h2 {
font-size: 25px;
margin-left: 20px;
margin-top: 10px;
font-weight: 800;
margin-bottom: 45px;
}
.add-cat-form {
min-width: 200px;
padding: 15px;
background-color: #fff;
border-radius: 16px;
box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
text-align: left;
margin-left: 20px;
}
.form-group {
margin-bottom: 20px;
}
.form-group label {
font-weight: bold;
display: block;
margin-bottom: 6px;
margin-left: 40px;
margin-top: 15px;
font-size: 20px;
}
input,
select,
textarea {
width: 90%;
padding: 5px;
border: 1px solid #ccc;
border-radius: 5px;
font-size: 15px;
padding-left: 8px;
margin-left: 40px;
}
.form-buttons {
display: flex;
justify-content: center;
gap: 12px;
margin-top: 30px;
/* text-align: center; */
}
.form-buttons .btn {
width: 120px;
}
.btn {
padding: 10px 24px;
border-radius: 10px;
border: none;
cursor: pointer;
font-weight: bold;
text-align: center;
}
/* utk btton save */
.save {
background: #b38cf8;
color: white;
}
/* utk btton cancel */
.cancel {
background: #999;
color: white;
}
/* utk btton close di popup */
.close {
background: #999;
color: white;
}
.form-buttons .cancel a, .save a, .close a {
color: rgb(255, 255, 255);
text-decoration: none;
}
.form-buttons .cancel:hover a, .save:hover a, .close:hover a {
color: rgb(0, 0, 0);
text-decoration: none;
}
/* Popup Styling */
.popup-overlay {
display: none;
position: fixed;
top: 0; left: 0;
width: 100vw;
height: 100vh;
background: rgba(0,0,0,0.5);
justify-content: center;
align-items: center;
z-index: 999;
}
.popup-content {
background: white;
padding: 24px;
border-radius: 12px;
max-width: 400px;
box-shadow: 0 8px 20px rgba(0,0,0,0.2);
text-align: center;
}
.popup-content h2 {
margin-top: 0;
}
/* .close-btn {
margin-top: 16px;
padding: 8px 16px;
background: #a78bfa;
border: none;
color: white;
border-radius: 8px;
cursor: pointer;
text-decoration: none;
}
.close-btn:hover {
background: #844ae8;
text-decoration: none;
} */
</style>
</head>
<div class=""category-container"">
<div class=""category-header"">
<h2>Add New Category</h2>
</div>
<div class=""add-cat-form"">
<div class=""form-group"">
<label>Name</label>
<input type=""text"" placeholder=""Maximum 35 characters"" />
</div>
<div class=""form-group"">
<label>Description</label>
<textarea rows=""6"" placeholder=""Enter the Category's Description"" ></textarea>
</div>
<!-- Buttons -->
{{-- <div class=""form-buttons"">
<button class=""btn btn-secondary"">Cancel</button>
<button class=""btn save"">Save</button>
</div> --}}
<div class=""form-buttons"">
<button class=""btn cancel"">
<a href=""{{ route('category') }}"">Cancel</a>
</button>
<button class=""btn save"" onclick=""showPopup('popup1')"">
<a href=""#"">Save</a>
</button>
</div>
</div>
</div>
<!-- Popup -->
<div class=""popup-overlay"" id=""popup1"">
<div class=""popup-content"">
<h2>Science Fiction</h2>
<p>Detail Category:</p>
<p>Cerita yang berlatar belakang teknologi dan sains. Genre ini seringkali didasarkan pada
prinsip-prinsip ilmiah yang ada atau dihipotesiskan, namun dengan sentuhan imajinatif dan fiksi.
</p>
<div class=""form-buttons"">
<button class=""btn close"">
<a href=""{{ route('category') }}"">Close</a>
</button>
</div>
</div>
</div>
<script>
function showPopup(popupId) {
document.getElementById(popupId).style.display = 'flex';
}
function closePopup(popupId) {
document.getElementById(popupId).style.display = 'none';
}
</script>
<!-- Bootstrap Icons CDN -->
<link rel=""stylesheet"" href=""https://cdn.jsdelivr.net/npm/bootstrapicons@1.10.5/font/bootstrap-icons.css"">
@endsection
category_books.blade.php
@extends('base.base')
@section('content')
<head>
<link href=""https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css""
rel=""stylesheet"">
<style>
html,
body {
margin: 0;
padding: 0;
width: 100%;
overflow-x: hidden;
background-color: #f4f4f4;
}
.category-container {
margin-left: 235px; /* match your .sidebar width exactly */
padding: 20px;
background-color: #f4f4f4;
overflow-x: hidden;
box-sizing: border-box;
max-width: calc(100vw - 250px);
}
.category-header h2 {
font-size: 25px;
margin-left: 20px;
margin-top: 10px;
font-weight: 800;
}
.custom-container {
border: 2px solid #c7b3ff;
border-radius: 10px;
padding: 20px;
margin-left: 20px;
}
.action-link {
color: #8e44ad;
text-decoration: none;
}
.action-link:hover {
text-decoration: underline;
}
.icon-eye {
margin-right: 5px;
}
.search-add {
margin-left: 20px;
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 15px;
}
.search-bar {
position: relative;
width: 550px;
margin-left: 0px;
margin-bottom: 10px;
}
.search-bar input {
width: 100%;
padding: 4px 50px 4px 15px;
border: 1px solid #ccc;
border-radius: 8px;
}
.search-bar i {
position: absolute;
right: 10px;
top: 50%;
transform: translateY(-50%);
color: #888;
}
.form-buttons .btn {
width: 120px;
}
.btn {
padding: 10px 24px;
border-radius: 10px;
border: none;
cursor: pointer;
font-weight: bold;
text-align: center;
}
/* utk btton cancel */
.back {
background: #999;
color: white;
}
.form-buttons .back a{
color: rgb(255, 255, 255);
text-decoration: none;
}
.form-buttons .back:hover a{
color: rgb(0, 0, 0);
text-decoration: none;
}
.edit i{
margin-left: 10px;
}
.edit {
margin-right: 10px;
}
</style>
</head>
<div class=""category-container"">
<div class=""category-header"">
<h2>Books in “Arts and Photography”</h2>
</div>
<div class=""search-add"">
<div class=""search-bar"">
<input type=""text"" placeholder=""Search by ID or title or author"">
<i class=""fa-solid fa-magnifying-glass""></i>
</div>
<div class=""form-buttons"">
<button class=""btn back"">
<a href=""{{ route('category') }}"">Back</a>
</button>
</div>
</div>
<div class=""custom-container bg-white"">
<table class=""table"">
<thead>
<tr>
<th>ID</th>
<th>Title</th>
<th>Author</th>
<th>Price</th>
<th>Stock</th>
</tr>
</thead>
<tbody>
<tr>
<td>PF001</td>
<td>Belajar Website Pemula</td>
<td>Celin Celin</td>
<td>Rp. 500.000</td>
<td>100</td>
</tr>
<tr>
<td>PF001</td>
<td>Belajar Website Pemula</td>
<td>Celin Celin</td>
<td>Rp. 500.000</td>
<td>100</td>
</tr>
<tr>
<td>PF001</td>
<td>Belajar Website Pemula</td>
<td>Celin Celin</td>
<td>Rp. 500.000</td>
<td>100</td>
</tr>
<tr>
<td>PF001</td>
<td>Belajar Website Pemula</td>
<td>Celin Celin</td>
<td>Rp. 500.000</td>
<td>100</td>
</tr>
</tbody>
</table>
</div>
</div>
<!-- Bootstrap Icons CDN -->
<link rel=""stylesheet"" href=""https://cdn.jsdelivr.net/npm/bootstrapicons@1.10.5/font/bootstrap-icons.css"">
@endsection
category.blade.php
@extends('base.base')
@section('content')
<head>
<link href=""https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css""
rel=""stylesheet"">
<style>
html,
body {
margin: 0;
padding: 0;
width: 100%;
overflow-x: hidden;
background-color: #f4f4f4;
}
.category-container {
margin-left: 235px; /* match your .sidebar width exactly */
padding: 20px;
background-color: #f4f4f4;
overflow-x: hidden;
box-sizing: border-box;
max-width: calc(100vw - 250px);
}
.category-header h2 {
font-size: 25px;
margin-left: 20px;
margin-top: 10px;
font-weight: 800;
}
.custom-container {
border: 2px solid #c7b3ff;
border-radius: 10px;
padding: 20px;
margin-left: 20px;
}
.action-link {
color: #8e44ad;
text-decoration: none;
}
.action-link:hover {
text-decoration: underline;
}
.icon-eye {
margin-right: 5px;
}
.search-add {
margin-left: 20px;
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 15px;
}
.search-bar {
position: relative;
width: 550px;
margin-left: 0px;
margin-bottom: 10px;
}
.search-bar input {
width: 100%;
padding: 4px 50px 4px 15px;
border: 1px solid #ccc;
border-radius: 8px;
}
.search-bar i {
position: absolute;
right: 10px;
top: 50%;
transform: translateY(-50%);
color: #888;
}
.add-btn {
background-color: #b18dfc;
color: white;
border: none;
border-radius: 8px;
padding: 10px 20px;
font-weight: bold;
cursor: pointer;
margin-right: 10px;
}
.add-btn:hover {
background-color: #996bfa;
}
.add-btn i {
margin-right: 5px;
}
.edit i{
margin-left: 10px;
}
.edit {
margin-right: 10px;
}
</style>
</head>
<div class=""category-container"">
<div class=""category-header"">
<h2>Category List</h2>
</div>
<div class=""search-add"">
<div class=""search-bar"">
<input type=""text"" placeholder=""Search by ID or title or author"">
<i class=""fa-solid fa-magnifying-glass""></i>
</div>
<a href=""{{ route('add-category') }}"">
<button class=""add-btn"">
<i class=""bi bi-plus-lg""></i> Add New Category
</button>
</a>
</div>
<div class=""custom-container bg-white"">
<table class=""table"">
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Total Books</th>
<th>Action</th>
</tr>
</thead>
<tbody>
@foreach ($category as $cat)
<tr>
<td>{{ $cat['id'] }}</td>
<td>{{ $cat['nama_category'] }}</td>
<td>{{ $cat['total_books'] }}</td>
<td>
<a href=""{{ route('category-books') }}"" class=""action-link viewAll""><i class=""bi bi-eye
icon-eye""></i>View All Books</a>
<a href=""{{ route('edit-category') }}"" class=""text-primary edit""><i class=""fa-solid fapen""></i>Edit</a>
<a href=""{{ route('category', ['delete_id' => $cat['id']]) }}"" onclick=""return
confirm('Yakin ingin menghapus?')"" class=""text-danger delete""><i class=""fa-solid fatrash""></i>Delete</a>
</td>
</tr>
@endforeach
</tbody>
</table>
</div>
</div>
<!-- Bootstrap Icons CDN -->
<link rel=""stylesheet"" href=""https://cdn.jsdelivr.net/npm/bootstrapicons@1.10.5/font/bootstrap-icons.css"">
@endsection
edit_cat.blade.php
@extends('base.base')
@section('content')
<head>
<link href=""https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css""
rel=""stylesheet"">
<style>
html,
body {
margin: 0;
padding: 0;
width: 100%;
overflow-x: hidden;
background-color: #f4f4f4;
}
.category-container {
margin-left: 235px; /* match your .sidebar width exactly */
padding: 20px;
/* background-color: #f4f4f4; */
overflow-x: hidden;
box-sizing: border-box;
max-width: calc(100vw - 250px);
}
.category-header h2 {
font-size: 25px;
margin-left: 20px;
margin-top: 10px;
font-weight: 800;
margin-bottom: 45px;
}
.add-cat-form {
min-width: 200px;
padding: 15px;
background-color: #fff;
border-radius: 16px;
box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
text-align: left;
margin-left: 20px;
}
.form-group {
margin-bottom: 20px;
}
.form-group label {
font-weight: bold;
display: block;
margin-bottom: 6px;
margin-left: 40px;
margin-top: 15px;
font-size: 20px;
}
input,
select,
textarea {
width: 90%;
padding: 5px;
border: 1px solid #ccc;
border-radius: 5px;
font-size: 15px;
padding-left: 8px;
margin-left: 40px;
}
.form-buttons {
display: flex;
justify-content: center;
gap: 12px;
margin-top: 30px;
/* text-align: center; */
}
.form-buttons .btn {
width: 120px;
}
.btn {
padding: 10px 24px;
border-radius: 10px;
border: none;
cursor: pointer;
font-weight: bold;
text-align: center;
}
/* utk btton save */
.save {
background: #b38cf8;
color: white;
}
/* utk btton cancel */
.cancel {
background: #999;
color: white;
}
.form-buttons .cancel a, .save a {
color: rgb(255, 255, 255);
text-decoration: none;
}
.form-buttons .cancel:hover a, .save:hover a {
color: rgb(0, 0, 0);
text-decoration: none;
}
</style>
</head>
<div class=""category-container"">
<div class=""category-header"">
<h2>Edit Category</h2>
</div>
<div class=""add-cat-form"">
<div class=""form-group"">
<label>Name</label>
<input type=""text"" placeholder=""Maximum 35 characters"" />
</div>
<div class=""form-group"">
<label>Description</label>
<textarea rows=""6"" placeholder=""Enter the Category's Description"" ></textarea>
</div>
<div class=""form-buttons"">
<button class=""btn cancel"">
<a href=""{{ route('category') }}"">Cancel</a>
</button>
<button class=""btn save"">
<a href=""{{ route('category') }}"">Save</a>
</button>
</div>
</div>
</div>
<!-- Bootstrap Icons CDN -->
<link rel=""stylesheet"" href=""https://cdn.jsdelivr.net/npm/bootstrapicons@1.10.5/font/bootstrap-icons.css"">
@endsection
Routing: web.php
Route::get('/category', [StoreController::class, 'show_category'])
->name('category');
Route::get('/categorybooks', [StoreController::class, 'show_category_books'])
->name('category-books');
Route::get('/add-category', [StoreController::class, 'show_add_category'])
->name('add-category');
Route::get('/edit-category', [StoreController::class, 'show_edit_category'])
->name('edit-category');
Controller: StoreController
public function show_category_books(){
return view('category.category_books',[
'title' => 'Category Books'
]);
}
public function show_add_category(){
return view('category.add_cat',[
'title' => 'Add Category'
]);
}
public function show_edit_category(){
return view('category.edit_cat',[
'title' => 'Edit Category'
]);
}
public function show_category(Request $request)
{
$category = [
['id' => 1, 'nama_category' => 'Arts & Photography', 'total_books' => 10],
['id' => 2, 'nama_category' => 'Non-Fiksi', 'total_books' => 5],
['id' => 3, 'nama_category' => 'Biografi', 'total_books' => 7],
];
// Kalau ada request ID untuk dihapus
if ($request->has('delete_id')) {
$deleteId = $request->input('delete_id');
// Filter data yang tidak sesuai dengan ID yang dihapus
$category = array_filter($category, function ($cat) use ($deleteId) {
return $cat['id'] != $deleteId;
});
// Reset index array
$category = array_values($category);
}
return view('category.category', compact('category'));
}"
T4bt7jhd,⛏️Hole Digging Inc,new2479,Lua,Saturday 17th of May 2025 09:32:45 PM CDT,"--https://www.youtube.com/@WinPo1R              pls sub 
--discord :      https://discord.gg/mdnJJYbjCh


loadstring(game:HttpGet(""https://raw.githubusercontent.com/powin273/script/refs/heads/main/Hole_Digging_Inc.lua"", true))()

"
10sdx8FG,2025-05-18T03:50:02.051284,powerampache,PHP,Saturday 17th of May 2025 08:50:02 PM CDT,"1.01-80 (80) - DB: 83
luci.sixsixsix.powerampache2.domain.errors.NullSessionException: Session is NULL
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository.authToken(BaseAmpacheRepository.kt:87)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository$authToken$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at android.os.Handler.handleCallback(Handler.java:984)
	at android.os.Handler.dispatchMessage(Handler.java:104)
	at android.os.Looper.loopOnce(Looper.java:238)
	at android.os.Looper.loop(Looper.java:357)
	at android.app.ActivityThread.main(ActivityThread.java:8088)
	at java.lang.reflect.Method.invoke(Native Method)
	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:548)
	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:957)

getAlbumsStats() - generic exception {""detailMessage"":""Session is NULL"",""stackTrace"":[]}"
5bfnD8tv,2025-05-18T03:50:02.053717,powerampache,PHP,Saturday 17th of May 2025 08:50:02 PM CDT,"1.01-80 (80) - DB: 83
luci.sixsixsix.powerampache2.domain.errors.NullSessionException: Session is NULL
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository.authToken(BaseAmpacheRepository.kt:87)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository$authToken$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at android.os.Handler.handleCallback(Handler.java:984)
	at android.os.Handler.dispatchMessage(Handler.java:104)
	at android.os.Looper.loopOnce(Looper.java:238)
	at android.os.Looper.loop(Looper.java:357)
	at android.app.ActivityThread.main(ActivityThread.java:8088)
	at java.lang.reflect.Method.invoke(Native Method)
	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:548)
	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:957)

getAlbumsStats() - generic exception {""detailMessage"":""Session is NULL"",""stackTrace"":[]}"
LiLV67xr,2025-05-18T03:50:02.047663,powerampache,PHP,Saturday 17th of May 2025 08:50:02 PM CDT,"1.01-80 (80) - DB: 83
luci.sixsixsix.powerampache2.domain.errors.NullSessionException: Session is NULL
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository.authToken(BaseAmpacheRepository.kt:87)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository$authToken$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at android.os.Handler.handleCallback(Handler.java:984)
	at android.os.Handler.dispatchMessage(Handler.java:104)
	at android.os.Looper.loopOnce(Looper.java:238)
	at android.os.Looper.loop(Looper.java:357)
	at android.app.ActivityThread.main(ActivityThread.java:8088)
	at java.lang.reflect.Method.invoke(Native Method)
	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:548)
	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:957)

getGenres() - generic exception {""detailMessage"":""Session is NULL"",""stackTrace"":[]}"
Nny2yATf,2025-05-18T03:50:02.052804,powerampache,PHP,Saturday 17th of May 2025 08:50:02 PM CDT,"1.01-80 (80) - DB: 83
luci.sixsixsix.powerampache2.domain.errors.NullSessionException: Session is NULL
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository.authToken(BaseAmpacheRepository.kt:87)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository$authToken$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at android.os.Handler.handleCallback(Handler.java:984)
	at android.os.Handler.dispatchMessage(Handler.java:104)
	at android.os.Looper.loopOnce(Looper.java:238)
	at android.os.Looper.loop(Looper.java:357)
	at android.app.ActivityThread.main(ActivityThread.java:8088)
	at java.lang.reflect.Method.invoke(Native Method)
	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:548)
	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:957)

getAlbumsStats() - generic exception {""detailMessage"":""Session is NULL"",""stackTrace"":[]}"
P46Vmjht,2025-05-18T03:50:01.934284,powerampache,PHP,Saturday 17th of May 2025 08:50:02 PM CDT,"1.01-80 (80) - DB: 83
luci.sixsixsix.powerampache2.domain.errors.NullSessionException: Session is NULL
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository.authToken(BaseAmpacheRepository.kt:87)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository$authToken$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:811)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:715)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:702)

"
4mrDHAEr,"Internal error on command:""T2""",creach,JSON,Saturday 17th of May 2025 08:26:02 PM CDT,"Stats 3238.1: gcodein=0  mcu: mcu_awake=0.002 mcu_task_avg=0.000010 mcu_task_stddev=0.000009 bytes_write=7544 bytes_read=36639 bytes_retransmit=0 bytes_invalid=0 send_seq=622 receive_seq=622 retransmit_seq=0 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=71997915 host: mcu_awake=0.001 mcu_task_avg=0.000015 mcu_task_stddev=0.000029 bytes_write=1830 bytes_read=7805 bytes_retransmit=0 bytes_invalid=0 send_seq=278 receive_seq=278 retransmit_seq=0 srtt=0.000 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=49999908 adj=50001243 expander: mcu_awake=0.002 mcu_task_avg=0.000015 mcu_task_stddev=0.000011 bytes_write=1750 bytes_read=15025 bytes_retransmit=9 bytes_invalid=0 send_seq=261 receive_seq=261 retransmit_seq=2 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=48019259 adj=48020210 tr: mcu_awake=0.001 mcu_task_avg=0.000006 mcu_task_stddev=0.000004 bytes_write=6411 bytes_read=21745 bytes_retransmit=9 bytes_invalid=0 send_seq=597 receive_seq=597 retransmit_seq=2 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=12000393 adj=12000733 skr: temp=32.4 RPI: temp=44.0  chamber: temp=30.3 MCU: temp=30.3 heater_bed: target=0 temp=34.2 pwm=0.000 sysload=0.13 cputime=14.922 memavail=666224 print_time=3243.522 buffer_time=0.245 print_stall=0 extruder: target=210 temp=210.7 pwm=0.284
TMC 'stepper_tr_fil_driver' reports GSTAT:      00000001 reset=1(Reset)
TMC 'stepper_tr_fil_driver' reports GSTAT:      00000000
Stats 3239.1: gcodein=0  mcu: mcu_awake=0.002 mcu_task_avg=0.000010 mcu_task_stddev=0.000009 bytes_write=8106 bytes_read=37258 bytes_retransmit=0 bytes_invalid=0 send_seq=658 receive_seq=658 retransmit_seq=0 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=71997915 host: mcu_awake=0.001 mcu_task_avg=0.000015 mcu_task_stddev=0.000029 bytes_write=1836 bytes_read=7821 bytes_retransmit=0 bytes_invalid=0 send_seq=279 receive_seq=279 retransmit_seq=0 srtt=0.000 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=49999908 adj=50001256 expander: mcu_awake=0.002 mcu_task_avg=0.000015 mcu_task_stddev=0.000011 bytes_write=1756 bytes_read=15086 bytes_retransmit=9 bytes_invalid=0 send_seq=262 receive_seq=262 retransmit_seq=2 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=48019260 adj=48020457 tr: mcu_awake=0.001 mcu_task_avg=0.000006 mcu_task_stddev=0.000004 bytes_write=7151 bytes_read=22517 bytes_retransmit=9 bytes_invalid=0 send_seq=646 receive_seq=646 retransmit_seq=2 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=12000393 adj=12000734 skr: temp=32.1 RPI: temp=44.5  chamber: temp=30.3 MCU: temp=30.3 heater_bed: target=0 temp=34.3 pwm=0.000 sysload=0.13 cputime=15.136 memavail=666224 print_time=3243.522 buffer_time=0.000 print_stall=0 extruder: target=210 temp=210.6 pwm=0.343
Stats 3240.1: gcodein=0  mcu: mcu_awake=0.002 mcu_task_avg=0.000010 mcu_task_stddev=0.000009 bytes_write=8392 bytes_read=37582 bytes_retransmit=0 bytes_invalid=0 send_seq=682 receive_seq=681 retransmit_seq=0 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=71997916 host: mcu_awake=0.001 mcu_task_avg=0.000011 mcu_task_stddev=0.000020 bytes_write=1842 bytes_read=7850 bytes_retransmit=0 bytes_invalid=0 send_seq=280 receive_seq=280 retransmit_seq=0 srtt=0.000 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=49999911 adj=50001281 expander: mcu_awake=0.002 mcu_task_avg=0.000015 mcu_task_stddev=0.000011 bytes_write=1762 bytes_read=15147 bytes_retransmit=9 bytes_invalid=0 send_seq=263 receive_seq=263 retransmit_seq=2 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=48019260 adj=48020498 tr: mcu_awake=0.001 mcu_task_avg=0.000006 mcu_task_stddev=0.000004 bytes_write=7621 bytes_read=23033 bytes_retransmit=9 bytes_invalid=0 send_seq=685 receive_seq=685 retransmit_seq=2 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=12000393 adj=12000735 skr: temp=32.0 RPI: temp=43.5  chamber: temp=30.3 MCU: temp=30.3 heater_bed: target=0 temp=34.2 pwm=0.000 sysload=0.13 cputime=15.266 memavail=666224 print_time=3243.522 buffer_time=0.000 print_stall=0 extruder: target=210 temp=210.5 pwm=0.343
Stats 3241.1: gcodein=0  mcu: mcu_awake=0.002 mcu_task_avg=0.000010 mcu_task_stddev=0.000009 bytes_write=8675 bytes_read=37890 bytes_retransmit=0 bytes_invalid=0 send_seq=704 receive_seq=704 retransmit_seq=0 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=71997918 host: mcu_awake=0.001 mcu_task_avg=0.000011 mcu_task_stddev=0.000020 bytes_write=1848 bytes_read=7866 bytes_retransmit=0 bytes_invalid=0 send_seq=281 receive_seq=281 retransmit_seq=0 srtt=0.000 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=49999916 adj=50001325 expander: mcu_awake=0.002 mcu_task_avg=0.000015 mcu_task_stddev=0.000011 bytes_write=1768 bytes_read=15237 bytes_retransmit=9 bytes_invalid=0 send_seq=264 receive_seq=264 retransmit_seq=2 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=48019261 adj=48020531 tr: mcu_awake=0.004 mcu_task_avg=0.000006 mcu_task_stddev=0.000005 bytes_write=8067 bytes_read=23539 bytes_retransmit=9 bytes_invalid=0 send_seq=722 receive_seq=722 retransmit_seq=2 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=12000393 adj=12000740 skr: temp=32.1 RPI: temp=43.5  chamber: temp=30.2 MCU: temp=30.2 heater_bed: target=0 temp=34.3 pwm=0.000 sysload=0.13 cputime=15.399 memavail=666224 print_time=3243.522 buffer_time=0.000 print_stall=0 extruder: target=210 temp=210.4 pwm=0.332
Stats 3242.1: gcodein=0  mcu: mcu_awake=0.002 mcu_task_avg=0.000010 mcu_task_stddev=0.000009 bytes_write=8993 bytes_read=38189 bytes_retransmit=0 bytes_invalid=0 send_seq=728 receive_seq=728 retransmit_seq=0 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=71997924 host: mcu_awake=0.001 mcu_task_avg=0.000011 mcu_task_stddev=0.000020 bytes_write=1854 bytes_read=7882 bytes_retransmit=0 bytes_invalid=0 send_seq=282 receive_seq=282 retransmit_seq=0 srtt=0.000 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=49999920 adj=50001400 expander: mcu_awake=0.002 mcu_task_avg=0.000015 mcu_task_stddev=0.000011 bytes_write=1774 bytes_read=15298 bytes_retransmit=9 bytes_invalid=0 send_seq=265 receive_seq=265 retransmit_seq=2 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=48019263 adj=48020554 tr: mcu_awake=0.004 mcu_task_avg=0.000006 mcu_task_stddev=0.000005 bytes_write=8549 bytes_read=24060 bytes_retransmit=9 bytes_invalid=0 send_seq=762 receive_seq=762 retransmit_seq=2 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=12000393 adj=12000731 skr: temp=32.1 RPI: temp=42.9  chamber: temp=30.3 MCU: temp=30.3 heater_bed: target=0 temp=34.1 pwm=0.000 sysload=0.13 cputime=15.537 memavail=666224 print_time=3243.522 buffer_time=0.000 print_stall=0 extruder: target=210 temp=210.4 pwm=0.316
Stats 3243.1: gcodein=0  mcu: mcu_awake=0.007 mcu_task_avg=0.000011 mcu_task_stddev=0.000009 bytes_write=9289 bytes_read=38528 bytes_retransmit=0 bytes_invalid=0 send_seq=751 receive_seq=751 retransmit_seq=0 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=71997925 host: mcu_awake=0.001 mcu_task_avg=0.000011 mcu_task_stddev=0.000020 bytes_write=1860 bytes_read=7898 bytes_retransmit=0 bytes_invalid=0 send_seq=283 receive_seq=283 retransmit_seq=0 srtt=0.000 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=49999921 adj=50001385 expander: mcu_awake=0.002 mcu_task_avg=0.000015 mcu_task_stddev=0.000011 bytes_write=1780 bytes_read=15359 bytes_retransmit=9 bytes_invalid=0 send_seq=266 receive_seq=266 retransmit_seq=2 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=48019264 adj=48020555 tr: mcu_awake=0.004 mcu_task_avg=0.000006 mcu_task_stddev=0.000005 bytes_write=9007 bytes_read=24571 bytes_retransmit=9 bytes_invalid=0 send_seq=800 receive_seq=800 retransmit_seq=2 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=12000394 adj=12000723 skr: temp=32.1 RPI: temp=43.5  chamber: temp=30.3 MCU: temp=30.3 heater_bed: target=0 temp=34.2 pwm=0.000 sysload=0.20 cputime=15.669 memavail=666224 print_time=3243.522 buffer_time=0.000 print_stall=0 extruder: target=210 temp=210.2 pwm=0.407
Stats 3244.1: gcodein=0  mcu: mcu_awake=0.007 mcu_task_avg=0.000011 mcu_task_stddev=0.000009 bytes_write=9574 bytes_read=38836 bytes_retransmit=0 bytes_invalid=0 send_seq=774 receive_seq=774 retransmit_seq=0 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=71997924 host: mcu_awake=0.001 mcu_task_avg=0.000011 mcu_task_stddev=0.000020 bytes_write=1866 bytes_read=7914 bytes_retransmit=0 bytes_invalid=0 send_seq=284 receive_seq=284 retransmit_seq=0 srtt=0.000 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=49999921 adj=50001372 expander: mcu_awake=0.002 mcu_task_avg=0.000015 mcu_task_stddev=0.000011 bytes_write=1786 bytes_read=15435 bytes_retransmit=9 bytes_invalid=0 send_seq=267 receive_seq=267 retransmit_seq=2 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=48019262 adj=48020576 tr: mcu_awake=0.004 mcu_task_avg=0.000006 mcu_task_stddev=0.000005 bytes_write=9465 bytes_read=25068 bytes_retransmit=9 bytes_invalid=0 send_seq=838 receive_seq=838 retransmit_seq=2 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=12000394 adj=12000731 skr: temp=32.0 RPI: temp=44.0  chamber: temp=30.3 MCU: temp=30.3 heater_bed: target=0 temp=34.2 pwm=0.000 sysload=0.20 cputime=15.794 memavail=665504 print_time=3243.522 buffer_time=0.000 print_stall=0 extruder: target=210 temp=210.2 pwm=0.302
Stats 3245.1: gcodein=0  mcu: mcu_awake=0.007 mcu_task_avg=0.000011 mcu_task_stddev=0.000009 bytes_write=9848 bytes_read=39130 bytes_retransmit=0 bytes_invalid=0 send_seq=797 receive_seq=797 retransmit_seq=0 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=71997924 host: mcu_awake=0.001 mcu_task_avg=0.000015 mcu_task_stddev=0.000029 bytes_write=1872 bytes_read=7943 bytes_retransmit=0 bytes_invalid=0 send_seq=285 receive_seq=285 retransmit_seq=0 srtt=0.000 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=49999922 adj=50001385 expander: mcu_awake=0.002 mcu_task_avg=0.000015 mcu_task_stddev=0.000011 bytes_write=1792 bytes_read=15496 bytes_retransmit=9 bytes_invalid=0 send_seq=268 receive_seq=268 retransmit_seq=2 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=48019258 adj=48020571 tr: mcu_awake=0.004 mcu_task_avg=0.000006 mcu_task_stddev=0.000005 bytes_write=9935 bytes_read=25584 bytes_retransmit=9 bytes_invalid=0 send_seq=877 receive_seq=877 retransmit_seq=2 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=12000395 adj=12000747 skr: temp=32.0 RPI: temp=44.0  chamber: temp=30.4 MCU: temp=30.2 heater_bed: target=0 temp=34.3 pwm=0.000 sysload=0.20 cputime=15.926 memavail=665504 print_time=3243.522 buffer_time=0.000 print_stall=0 extruder: target=210 temp=210.2 pwm=0.302
Stats 3246.1: gcodein=0  mcu: mcu_awake=0.007 mcu_task_avg=0.000011 mcu_task_stddev=0.000009 bytes_write=10133 bytes_read=39454 bytes_retransmit=0 bytes_invalid=0 send_seq=820 receive_seq=820 retransmit_seq=0 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=71997923 host: mcu_awake=0.001 mcu_task_avg=0.000015 mcu_task_stddev=0.000029 bytes_write=1878 bytes_read=7959 bytes_retransmit=0 bytes_invalid=0 send_seq=286 receive_seq=286 retransmit_seq=0 srtt=0.000 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=49999931 adj=50001407 expander: mcu_awake=0.002 mcu_task_avg=0.000015 mcu_task_stddev=0.000011 bytes_write=1798 bytes_read=15571 bytes_retransmit=9 bytes_invalid=0 send_seq=269 receive_seq=269 retransmit_seq=2 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=48019253 adj=48020539 tr: mcu_awake=0.006 mcu_task_avg=0.000006 mcu_task_stddev=0.000005 bytes_write=10393 bytes_read=26109 bytes_retransmit=9 bytes_invalid=0 send_seq=915 receive_seq=915 retransmit_seq=2 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=12000395 adj=12000763 skr: temp=32.0 RPI: temp=43.5  chamber: temp=30.3 MCU: temp=30.3 heater_bed: target=0 temp=34.1 pwm=0.000 sysload=0.20 cputime=16.059 memavail=665504 print_time=3243.522 buffer_time=0.000 print_stall=0 extruder: target=210 temp=210.1 pwm=0.357
Stats 3247.1: gcodein=0  mcu: mcu_awake=0.007 mcu_task_avg=0.000011 mcu_task_stddev=0.000009 bytes_write=10440 bytes_read=39762 bytes_retransmit=0 bytes_invalid=0 send_seq=843 receive_seq=843 retransmit_seq=0 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=71997921 host: mcu_awake=0.001 mcu_task_avg=0.000015 mcu_task_stddev=0.000029 bytes_write=1884 bytes_read=7975 bytes_retransmit=0 bytes_invalid=0 send_seq=287 receive_seq=287 retransmit_seq=0 srtt=0.000 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=49999932 adj=50001531 expander: mcu_awake=0.002 mcu_task_avg=0.000015 mcu_task_stddev=0.000011 bytes_write=1804 bytes_read=15647 bytes_retransmit=9 bytes_invalid=0 send_seq=270 receive_seq=270 retransmit_seq=2 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=48019246 adj=48020480 tr: mcu_awake=0.006 mcu_task_avg=0.000006 mcu_task_stddev=0.000005 bytes_write=10863 bytes_read=26625 bytes_retransmit=9 bytes_invalid=0 send_seq=954 receive_seq=954 retransmit_seq=2 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=12000395 adj=12000755 skr: temp=32.0 RPI: temp=43.5  chamber: temp=30.4 MCU: temp=30.3 heater_bed: target=0 temp=34.1 pwm=0.000 sysload=0.20 cputime=16.187 memavail=665504 print_time=3243.522 buffer_time=0.000 print_stall=0 extruder: target=210 temp=210.1 pwm=0.327
Stats 3248.1: gcodein=0  mcu: mcu_awake=0.006 mcu_task_avg=0.000011 mcu_task_stddev=0.000009 bytes_write=10736 bytes_read=40071 bytes_retransmit=0 bytes_invalid=0 send_seq=866 receive_seq=866 retransmit_seq=0 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=71997921 host: mcu_awake=0.001 mcu_task_avg=0.000015 mcu_task_stddev=0.000029 bytes_write=1890 bytes_read=7991 bytes_retransmit=0 bytes_invalid=0 send_seq=288 receive_seq=288 retransmit_seq=0 srtt=0.000 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=49999930 adj=50001532 expander: mcu_awake=0.002 mcu_task_avg=0.000015 mcu_task_stddev=0.000011 bytes_write=1810 bytes_read=15708 bytes_retransmit=9 bytes_invalid=0 send_seq=271 receive_seq=271 retransmit_seq=2 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=48019242 adj=48020442 tr: mcu_awake=0.006 mcu_task_avg=0.000006 mcu_task_stddev=0.000005 bytes_write=11321 bytes_read=27122 bytes_retransmit=9 bytes_invalid=0 send_seq=992 receive_seq=992 retransmit_seq=2 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0 freq=12000394 adj=12000751 skr: temp=32.1 RPI: temp=44.0  chamber: temp=30.3 MCU: temp=30.3 heater_bed: target=0 temp=34.0 pwm=0.000 sysload=0.26 cputime=16.317 memavail=665504 print_time=3243.522 buffer_time=0.000 print_stall=0 extruder: target=210 temp=210.2 pwm=0.323
Internal error on command:""T2""
Traceback (most recent call last):
  File ""/home/pi/klipper/klippy/gcode.py"", line 212, in _process_commands
    handler(gcmd)
  File ""/home/pi/klipper/klippy/extras/trad_rack.py"", line 404, in <lambda>
    lambda params: self.cmd_SELECT_TOOL(
  File ""/home/pi/klipper/klippy/extras/trad_rack.py"", line 1042, in cmd_SELECT_TOOL
    self.cmd_TR_LOAD_TOOLHEAD(
  File ""/home/pi/klipper/klippy/extras/trad_rack.py"", line 577, in cmd_TR_LOAD_TOOLHEAD
    self._load_toolhead(
  File ""/home/pi/klipper/klippy/extras/trad_rack.py"", line 1300, in _load_toolhead
    self._unload_toolhead()
  File ""/home/pi/klipper/klippy/extras/trad_rack.py"", line 1776, in _unload_toolhead
    hmove.homing_move(
  File ""/home/pi/klipper/klippy/extras/homing.py"", line 145, in homing_move
    self.toolhead.set_position(haltpos)
  File ""/home/pi/klipper/klippy/extras/trad_rack.py"", line 2419, in set_position
    super(TradRackToolHead, self).set_position(newpos, homing_axes)
  File ""/home/pi/klipper/klippy/toolhead.py"", line 467, in set_position
    self.kin.set_position(newpos, homing_axes)
  File ""/home/pi/klipper/klippy/extras/trad_rack.py"", line 2474, in set_position
    if i in homing_axes:
TypeError: 'in <string>' requires string as left operand, not int
Transition to shutdown state: Internal error on command:""T2""
Dumping gcode input 0 blocks
Dumping 20 requests for client 547915014048
Received 3077.534497: b'{""id"": 548115250960, ""method"": ""objects/subscribe"", ""params"": {""objects"": {""webhooks"": null, ""print_stats"": null, ""toolhead"": null, ""temperature_sensor skr"": null, ""temperature_sensor RPI"": null, ""temperature_sensor chamber"": null, ""temperature_sensor TradRack MCU"": null, ""heater_bed"": null, ""extruder"": null, ""gcode"": null, ""configfile"": null, ""mcu"": null, ""mcu host"": null, ""mcu expander"": null, ""mcu tr"": null, ""gcode_move"": null, ""save_variables"": null, ""idle_timeout"": null, ""servo nozzle_servo"": null, ""heaters"": null, ""temperature_host RPI"": null, ""virtual_sdcard"": null, ""pause_resume"": null, ""display_status"": null, ""gcode_macro CANCEL_PRINT"": null, ""gcode_macro PAUSE"": null, ""gcode_macro RESUME"": null, ""gcode_macro SET_PAUSE_NEXT_LAYER"": null, ""gcode_macro SET_PAUSE_AT_LAYER"": null, ""gcode_macro SET_PRINT_STATS_INFO"": null, ""gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL"": null, ""gcode_macro _CLIENT_EXTRUDE"": null, ""gcode_macro _CLIENT_RETRACT"": null, ""gcode_macro _CLIENT_LINEAR_MOVE"": null, ""gcode_macro TEST_SPEED"": null, ""gcode_macro PRINT_START"": null, ""gcode_macro NozzleClean"": null, ""gcode_macro SET_ACTIVE_SPOOL"": null, ""gcode_macro CLEAR_ACTIVE_SPOOL"": null, ""gcode_macro PRIME_LINE"": null, ""gcode_macro PRINT_END"": null, ""gcode_macro LOAD_FILAMENT"": null, ""gcode_macro UNLOAD_FILAMENT"": null, ""gcode_macro CONDITIONAL_HOMING"": null, ""gcode_macro PARKBC"": null, ""gcode_macro PARK_PRESENT"": null, ""gcode_macro DUMP_VARIABLES"": null, ""exclude_object"": null, ""gcode_macro _CLIENT_VARIABLE"": null, ""bed_screws"": null, ""neopixel Sides"": null, ""gcode_macro STATUS_HOMING"": null, ""gcode_macro STATUS_HEATING_BED"": null, ""gcode_macro STATUS_PRINTING"": null, ""gcode_macro STATUS_HEATING_NOZZLE"": null, ""gcode_macro STATUS_IDLE"": null, ""gcode_macro LED_RED_BLUE"": null, ""gcode_macro FULL_ON"": null, ""gcode_macro LED_CYAN"": null, ""gcode_macro LED_RED"": null, ""gcode_macro LED_25_PERCENT"": null, ""gcode_macro LED_CYAN_RED_SPLIT"": null, ""gcode_macro PartyTime"": null, ""heater_fan hotend_fan"": null, ""fan"": null, ""fan_generic GDStime"": null, ""output_pin mosfet2"": null, ""output_pin mosfet3"": null, ""neopixel expanderPixel"": null, ""stepper_enable"": null, ""tmc2209 stepper_x"": null, ""tmc2209 stepper_y"": null, ""tmc2209 stepper_z"": null, ""tmc2209 extruder"": null, ""gcode_macro BLOBIFIER"": null, ""gcode_macro BLOBIFIER_PARK"": null, ""gcode_macro BLOBIFIER_KICK"": null, ""gcode_macro TradRack_Home"": null, ""gcode_macro UNLOAD_TOOLHEAD"": null, ""gcode_macro LOAD_T0"": null, ""gcode_macro LOAD_T1"": null, ""gcode_macro LOAD_T2"": null, ""gcode_macro LOAD_T3"": null, ""gcode_macro LOAD_T4"": null, ""gcode_macro LOAD_T5"": null, ""gcode_macro LOAD_T6"": null, ""gcode_macro LOAD_T7"": null, ""gcode_macro LOAD_T8"": null, ""gcode_macro LOAD_T9"": null, ""gcode_macro LOAD_T10"": null, ""gcode_macro LOAD_T11"": null, ""gcode_macro LOAD_T12"": null, ""gcode_macro LOAD_T13"": null, ""gcode_macro LOAD_T14"": null, ""gcode_macro LOAD_T15"": null, ""gcode_macro LOAD_T16"": null, ""gcode_macro LOAD_T17"": null, ""gcode_macro LOAD_T18"": null, ""gcode_macro LOAD_T19"": null, ""gcode_macro LOAD_TOOLHEAD_LANE_0"": null, ""filament_motion_sensor tradmotionsensor"": null, ""query_endstops"": null, ""motion_report"": null, ""servo tr_servo"": null, ""trad_rack"": null, ""tmc2209 stepper_tr_selector"": null, ""tmc2209 stepper_tr_fil_driver"": null, ""gcode_macro ACTIVATE_EXTRUDER"": null, ""controller_fan TradRack"": null, ""gcode_macro TR_Variables"": null, ""gcode_macro Shape_Tip"": null, ""gcode_macro Set_Slicer_Unload_Preset"": null, ""gcode_macro Slicer_Unload"": null, ""gcode_macro _Wait_for_Toolchange_Temp"": null, ""gcode_macro Home_and_Wipe_Nozzle"": null, ""gcode_macro Save_Pressure_Advance"": null, ""gcode_macro Restore_Pressure_Advance"": null, ""gcode_macro HELLO_WORLD"": null, ""gcode_macro TEST_PARAM"": null, ""gcode_macro SHOW_TR_STATE"": null, ""gcode_macro TR_SENSOR_STATUS"": null, ""gcode_macro TEMP_SHIFT_CALIBRATION"": null, ""gcode_macro INIT_TRAD_RACK"": null, ""gcode_macro SELECT_AND_LOAD_FILAMENT"": null, ""gcode_macro TEMP_SHIFT_TEST"": null, ""gcode_macro RELAIS_ON"": null, ""gcode_macro RELAIS_OFF"": null, ""gcode_macro RELAIS_TOGGLE"": null, ""gcode_macro RELAIS_STATE"": null, ""gcode_macro RELAIS_QUERY"": null, ""gcode_macro MOVE_TO_CENTER_SAFE"": null, ""firmware_retraction"": null, ""system_stats"": null, ""manual_probe"": null}, ""response_template"": {""method"": ""process_status_update""}}}'
Received 3077.641023: b'{""id"": 548115250672, ""method"": ""objects/query"", ""params"": {""objects"": {""extruder"": [""can_extrude""]}}}'
Received 3094.520508: b'{""id"": 548115250816, ""method"": ""gcode/script"", ""params"": {""script"": ""T2""}}'
Received 3102.023914: b'{""id"": 548115250624, ""method"": ""objects/query"", ""params"": {""objects"": {""print_stats"": [""state"", ""message"", ""filename"", ""total_duration"", ""print_duration"", ""filament_used"", ""info""], ""display_status"": [""message"", ""progress""], ""toolhead"": [""position""], ""system_stats"": [""sysload"", ""memavail""], ""filament_motion_sensor tradmotionsensor"": [""filament_detected""], ""output_pin mosfet2"": [""value""], ""output_pin mosfet3"": [""value""], ""neopixel Sides"": [""color_data""], ""neopixel expanderPixel"": [""color_data""], ""status"": [""update_available""], ""heater_bed"": [""target"", ""temperature"", ""power""], ""extruder"": [""target"", ""temperature"", ""power""], ""mcu"": [""last_stats""], ""mcu host"": [""last_stats""], ""mcu expander"": [""last_stats""], ""mcu tr"": [""last_stats""], ""temperature_sensor skr"": [""temperature""], ""temperature_sensor RPI"": [""temperature""], ""heater_fan hotend_fan"": [""speed""], ""temperature_sensor chamber"": [""temperature""], ""fan_generic GDStime"": [""speed""], ""controller_fan TradRack"": [""speed""], ""temperature_sensor TradRack MCU"": [""temperature""], ""gcode_move"": [""speed_factor""], ""fan"": [""speed""], ""q"": [""u""]}}}'
Received 3102.158742: b'{""id"": 548115250192, ""method"": ""info"", ""params"": {}}'
Received 3102.167847: b'{""id"": 548115249040, ""method"": ""objects/query"", ""params"": {""objects"": {""print_stats"": [""state"", ""message"", ""filename"", ""total_duration"", ""print_duration"", ""filament_used"", ""info""], ""display_status"": [""message"", ""progress""], ""toolhead"": [""position""], ""system_stats"": [""sysload"", ""memavail""], ""filament_motion_sensor tradmotionsensor"": [""filament_detected""], ""output_pin mosfet2"": [""value""], ""output_pin mosfet3"": [""value""], ""neopixel Sides"": [""color_data""], ""neopixel expanderPixel"": [""color_data""], ""status"": [""update_available""], ""heater_bed"": [""target"", ""temperature"", ""power""], ""extruder"": [""target"", ""temperature"", ""power""], ""mcu"": [""last_stats""], ""mcu host"": [""last_stats""], ""mcu expander"": [""last_stats""], ""mcu tr"": [""last_stats""], ""temperature_sensor skr"": [""temperature""], ""temperature_sensor RPI"": [""temperature""], ""heater_fan hotend_fan"": [""speed""], ""temperature_sensor chamber"": [""temperature""], ""fan_generic GDStime"": [""speed""], ""controller_fan TradRack"": [""speed""], ""temperature_sensor TradRack MCU"": [""temperature""], ""gcode_move"": [""speed_factor""], ""fan"": [""speed""], ""q"": [""u""]}}}'
Received 3122.937552: b'{""id"": 548115250048, ""method"": ""gcode/script"", ""params"": {""script"": ""TR_LOCATE_SELECTOR""}}'
Received 3132.023113: b'{""id"": 548115250864, ""method"": ""objects/query"", ""params"": {""objects"": {""print_stats"": [""state"", ""message"", ""filename"", ""total_duration"", ""print_duration"", ""filament_used"", ""info""], ""display_status"": [""message"", ""progress""], ""toolhead"": [""position""], ""system_stats"": [""sysload"", ""memavail""], ""filament_motion_sensor tradmotionsensor"": [""filament_detected""], ""output_pin mosfet2"": [""value""], ""output_pin mosfet3"": [""value""], ""neopixel Sides"": [""color_data""], ""neopixel expanderPixel"": [""color_data""], ""status"": [""update_available""], ""heater_bed"": [""target"", ""temperature"", ""power""], ""extruder"": [""target"", ""temperature"", ""power""], ""mcu"": [""last_stats""], ""mcu host"": [""last_stats""], ""mcu expander"": [""last_stats""], ""mcu tr"": [""last_stats""], ""temperature_sensor skr"": [""temperature""], ""temperature_sensor RPI"": [""temperature""], ""heater_fan hotend_fan"": [""speed""], ""temperature_sensor chamber"": [""temperature""], ""fan_generic GDStime"": [""speed""], ""controller_fan TradRack"": [""speed""], ""temperature_sensor TradRack MCU"": [""temperature""], ""gcode_move"": [""speed_factor""], ""fan"": [""speed""], ""q"": [""u""]}}}'
Received 3132.257836: b'{""id"": 548115250576, ""method"": ""info"", ""params"": {}}'
Received 3132.268510: b'{""id"": 548115250048, ""method"": ""objects/query"", ""params"": {""objects"": {""print_stats"": [""state"", ""message"", ""filename"", ""total_duration"", ""print_duration"", ""filament_used"", ""info""], ""display_status"": [""message"", ""progress""], ""toolhead"": [""position""], ""system_stats"": [""sysload"", ""memavail""], ""filament_motion_sensor tradmotionsensor"": [""filament_detected""], ""output_pin mosfet2"": [""value""], ""output_pin mosfet3"": [""value""], ""neopixel Sides"": [""color_data""], ""neopixel expanderPixel"": [""color_data""], ""status"": [""update_available""], ""heater_bed"": [""target"", ""temperature"", ""power""], ""extruder"": [""target"", ""temperature"", ""power""], ""mcu"": [""last_stats""], ""mcu host"": [""last_stats""], ""mcu expander"": [""last_stats""], ""mcu tr"": [""last_stats""], ""temperature_sensor skr"": [""temperature""], ""temperature_sensor RPI"": [""temperature""], ""heater_fan hotend_fan"": [""speed""], ""temperature_sensor chamber"": [""temperature""], ""fan_generic GDStime"": [""speed""], ""controller_fan TradRack"": [""speed""], ""temperature_sensor TradRack MCU"": [""temperature""], ""gcode_move"": [""speed_factor""], ""fan"": [""speed""], ""q"": [""u""]}}}'
Received 3136.337315: b'{""id"": 548115249088, ""method"": ""gcode/script"", ""params"": {""script"": ""T2""}}'
Received 3162.024790: b'{""id"": 548115249424, ""method"": ""objects/query"", ""params"": {""objects"": {""print_stats"": [""state"", ""message"", ""filename"", ""total_duration"", ""print_duration"", ""filament_used"", ""info""], ""display_status"": [""message"", ""progress""], ""toolhead"": [""position""], ""system_stats"": [""sysload"", ""memavail""], ""filament_motion_sensor tradmotionsensor"": [""filament_detected""], ""output_pin mosfet2"": [""value""], ""output_pin mosfet3"": [""value""], ""neopixel Sides"": [""color_data""], ""neopixel expanderPixel"": [""color_data""], ""status"": [""update_available""], ""heater_bed"": [""target"", ""temperature"", ""power""], ""extruder"": [""target"", ""temperature"", ""power""], ""mcu"": [""last_stats""], ""mcu host"": [""last_stats""], ""mcu expander"": [""last_stats""], ""mcu tr"": [""last_stats""], ""temperature_sensor skr"": [""temperature""], ""temperature_sensor RPI"": [""temperature""], ""heater_fan hotend_fan"": [""speed""], ""temperature_sensor chamber"": [""temperature""], ""fan_generic GDStime"": [""speed""], ""controller_fan TradRack"": [""speed""], ""temperature_sensor TradRack MCU"": [""temperature""], ""gcode_move"": [""speed_factor""], ""fan"": [""speed""], ""q"": [""u""]}}}'
Received 3162.105634: b'{""id"": 548115250576, ""method"": ""info"", ""params"": {}}'
Received 3162.115726: b'{""id"": 548115248608, ""method"": ""objects/query"", ""params"": {""objects"": {""print_stats"": [""state"", ""message"", ""filename"", ""total_duration"", ""print_duration"", ""filament_used"", ""info""], ""display_status"": [""message"", ""progress""], ""toolhead"": [""position""], ""system_stats"": [""sysload"", ""memavail""], ""filament_motion_sensor tradmotionsensor"": [""filament_detected""], ""output_pin mosfet2"": [""value""], ""output_pin mosfet3"": [""value""], ""neopixel Sides"": [""color_data""], ""neopixel expanderPixel"": [""color_data""], ""status"": [""update_available""], ""heater_bed"": [""target"", ""temperature"", ""power""], ""extruder"": [""target"", ""temperature"", ""power""], ""mcu"": [""last_stats""], ""mcu host"": [""last_stats""], ""mcu expander"": [""last_stats""], ""mcu tr"": [""last_stats""], ""temperature_sensor skr"": [""temperature""], ""temperature_sensor RPI"": [""temperature""], ""heater_fan hotend_fan"": [""speed""], ""temperature_sensor chamber"": [""temperature""], ""fan_generic GDStime"": [""speed""], ""controller_fan TradRack"": [""speed""], ""temperature_sensor TradRack MCU"": [""temperature""], ""gcode_move"": [""speed_factor""], ""fan"": [""speed""], ""q"": [""u""]}}}'
Received 3192.023920: b'{""id"": 548115250912, ""method"": ""objects/query"", ""params"": {""objects"": {""print_stats"": [""state"", ""message"", ""filename"", ""total_duration"", ""print_duration"", ""filament_used"", ""info""], ""display_status"": [""message"", ""progress""], ""toolhead"": [""position""], ""system_stats"": [""sysload"", ""memavail""], ""filament_motion_sensor tradmotionsensor"": [""filament_detected""], ""output_pin mosfet2"": [""value""], ""output_pin mosfet3"": [""value""], ""neopixel Sides"": [""color_data""], ""neopixel expanderPixel"": [""color_data""], ""status"": [""update_available""], ""heater_bed"": [""target"", ""temperature"", ""power""], ""extruder"": [""target"", ""temperature"", ""power""], ""mcu"": [""last_stats""], ""mcu host"": [""last_stats""], ""mcu expander"": [""last_stats""], ""mcu tr"": [""last_stats""], ""temperature_sensor skr"": [""temperature""], ""temperature_sensor RPI"": [""temperature""], ""heater_fan hotend_fan"": [""speed""], ""temperature_sensor chamber"": [""temperature""], ""fan_generic GDStime"": [""speed""], ""controller_fan TradRack"": [""speed""], ""temperature_sensor TradRack MCU"": [""temperature""], ""gcode_move"": [""speed_factor""], ""fan"": [""speed""], ""q"": [""u""]}}}'
Received 3192.203740: b'{""id"": 548115250528, ""method"": ""info"", ""params"": {}}'
Received 3192.213844: b'{""id"": 548115248416, ""method"": ""objects/query"", ""params"": {""objects"": {""print_stats"": [""state"", ""message"", ""filename"", ""total_duration"", ""print_duration"", ""filament_used"", ""info""], ""display_status"": [""message"", ""progress""], ""toolhead"": [""position""], ""system_stats"": [""sysload"", ""memavail""], ""filament_motion_sensor tradmotionsensor"": [""filament_detected""], ""output_pin mosfet2"": [""value""], ""output_pin mosfet3"": [""value""], ""neopixel Sides"": [""color_data""], ""neopixel expanderPixel"": [""color_data""], ""status"": [""update_available""], ""heater_bed"": [""target"", ""temperature"", ""power""], ""extruder"": [""target"", ""temperature"", ""power""], ""mcu"": [""last_stats""], ""mcu host"": [""last_stats""], ""mcu expander"": [""last_stats""], ""mcu tr"": [""last_stats""], ""temperature_sensor skr"": [""temperature""], ""temperature_sensor RPI"": [""temperature""], ""heater_fan hotend_fan"": [""speed""], ""temperature_sensor chamber"": [""temperature""], ""fan_generic GDStime"": [""speed""], ""controller_fan TradRack"": [""speed""], ""temperature_sensor TradRack MCU"": [""temperature""], ""gcode_move"": [""speed_factor""], ""fan"": [""speed""], ""q"": [""u""]}}}'
Received 3222.027942: b'{""id"": 548115250048, ""method"": ""objects/query"", ""params"": {""objects"": {""print_stats"": [""state"", ""message"", ""filename"", ""total_duration"", ""print_duration"", ""filament_used"", ""info""], ""display_status"": [""message"", ""progress""], ""toolhead"": [""position""], ""system_stats"": [""sysload"", ""memavail""], ""filament_motion_sensor tradmotionsensor"": [""filament_detected""], ""output_pin mosfet2"": [""value""], ""output_pin mosfet3"": [""value""], ""neopixel Sides"": [""color_data""], ""neopixel expanderPixel"": [""color_data""], ""status"": [""update_available""], ""heater_bed"": [""target"", ""temperature"", ""power""], ""extruder"": [""target"", ""temperature"", ""power""], ""mcu"": [""last_stats""], ""mcu host"": [""last_stats""], ""mcu expander"": [""last_stats""], ""mcu tr"": [""last_stats""], ""temperature_sensor skr"": [""temperature""], ""temperature_sensor RPI"": [""temperature""], ""heater_fan hotend_fan"": [""speed""], ""temperature_sensor chamber"": [""temperature""], ""fan_generic GDStime"": [""speed""], ""controller_fan TradRack"": [""speed""], ""temperature_sensor TradRack MCU"": [""temperature""], ""gcode_move"": [""speed_factor""], ""fan"": [""speed""], ""q"": [""u""]}}}'
Received 3222.296015: b'{""id"": 548115248032, ""method"": ""info"", ""params"": {}}'
Received 3222.306501: b'{""id"": 548115248320, ""method"": ""objects/query"", ""params"": {""objects"": {""print_stats"": [""state"", ""message"", ""filename"", ""total_duration"", ""print_duration"", ""filament_used"", ""info""], ""display_status"": [""message"", ""progress""], ""toolhead"": [""position""], ""system_stats"": [""sysload"", ""memavail""], ""filament_motion_sensor tradmotionsensor"": [""filament_detected""], ""output_pin mosfet2"": [""value""], ""output_pin mosfet3"": [""value""], ""neopixel Sides"": [""color_data""], ""neopixel expanderPixel"": [""color_data""], ""status"": [""update_available""], ""heater_bed"": [""target"", ""temperature"", ""power""], ""extruder"": [""target"", ""temperature"", ""power""], ""mcu"": [""last_stats""], ""mcu host"": [""last_stats""], ""mcu expander"": [""last_stats""], ""mcu tr"": [""last_stats""], ""temperature_sensor skr"": [""temperature""], ""temperature_sensor RPI"": [""temperature""], ""heater_fan hotend_fan"": [""speed""], ""temperature_sensor chamber"": [""temperature""], ""fan_generic GDStime"": [""speed""], ""controller_fan TradRack"": [""speed""], ""temperature_sensor TradRack MCU"": [""temperature""], ""gcode_move"": [""speed_factor""], ""fan"": [""speed""], ""q"": [""u""]}}}'
gcode state: absolute_coord=True absolute_extrude=True base_position=[0.0, 0.0, 0.0, 0.0] last_position=[0.0, 0.0, 0.0, 0.0] homing_position=[0.0, 0.0, 0.0, 0.0] speed_factor=0.016666666666666666 extrude_factor=1.0 speed=25.0
Reactor garbage collection: (3238.482288868, 0.0, 0.0)
Internal error on command:""T2""
Once the underlying issue is corrected, use the
""FIRMWARE_RESTART"" command to reset the firmware, reload the
config, and restart the host software.
Printer is shutdown

Internal error on command:""T2""
Internal Error on WebRequest: gcode/script
Traceback (most recent call last):
  File ""/home/pi/klipper/klippy/webhooks.py"", line 268, in _process_request
    func(web_request)
  File ""/home/pi/klipper/klippy/webhooks.py"", line 448, in _handle_script
    self.gcode.run_script(web_request.get_str('script'))
  File ""/home/pi/klipper/klippy/gcode.py"", line 230, in run_script
    self._process_commands(script.split('\n'), need_ack=False)
  File ""/home/pi/klipper/klippy/gcode.py"", line 212, in _process_commands
    handler(gcmd)
  File ""/home/pi/klipper/klippy/extras/trad_rack.py"", line 404, in <lambda>
    lambda params: self.cmd_SELECT_TOOL(
  File ""/home/pi/klipper/klippy/extras/trad_rack.py"", line 1042, in cmd_SELECT_TOOL
    self.cmd_TR_LOAD_TOOLHEAD(
  File ""/home/pi/klipper/klippy/extras/trad_rack.py"", line 577, in cmd_TR_LOAD_TOOLHEAD
    self._load_toolhead(
  File ""/home/pi/klipper/klippy/extras/trad_rack.py"", line 1300, in _load_toolhead
    self._unload_toolhead()
  File ""/home/pi/klipper/klippy/extras/trad_rack.py"", line 1776, in _unload_toolhead
    hmove.homing_move(
  File ""/home/pi/klipper/klippy/extras/homing.py"", line 145, in homing_move
    self.toolhead.set_position(haltpos)
  File ""/home/pi/klipper/klippy/extras/trad_rack.py"", line 2419, in set_position
    super(TradRackToolHead, self).set_position(newpos, homing_axes)
  File ""/home/pi/klipper/klippy/toolhead.py"", line 467, in set_position
    self.kin.set_position(newpos, homing_axes)
  File ""/home/pi/klipper/klippy/extras/trad_rack.py"", line 2474, in set_position
    if i in homing_axes:
TypeError: 'in <string>' requires string as left operand, not int
MCU 'expander' shutdown: Command request
clocksync state: mcu_freq=48000000 last_clock=155801508624 clock_est=(3220.017 154433498765 48019240.225) min_half_rtt=0.000198 min_rtt_time=3237.674 time_avg=3220.017(819.235) clock_avg=154433498765.075(39339053688.820) pred_variance=100903975.427 clock_adj=(9.228 48020433.000)
Dumping serial stats: bytes_write=1822 bytes_read=15781 bytes_retransmit=9 bytes_invalid=0 send_seq=273 receive_seq=273 retransmit_seq=2 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0"
EDUgKY2b,Untitled,lacqueried,CSS,Saturday 17th of May 2025 08:21:48 PM CDT,"li.blurb {
  border: 1px solid;
border-color: BORDER HEX COLOR;
}
li.relationships a.tag {
  background: BG HEX COLOR;
  color: #ffffff; delete this line if you're using a light color or the ao3 defaults
}

li.blurb .tags {
  max-height: 10em;
  overflow-y: auto;
}

li {
  margin: 0px;
}

.tags li {
  padding: 0 .4em .4em 0;
}

.blurb .relationships {
  background: none;
  font-style: italic;
}

ul.tags {
  padding-right: .1em;
}

ul.tags li.warnings:first-child:before {
  color: #111;
  content: ""Archive Warnings: "";
  font-weight: bold;
}

ul.tags li.warnings,
ul.tags li.relationships,
ul.tags li.characters,
ul.tags li.freeforms {
  float: left !important;
}

li.warnings + li.characters:before {
  color: #111;
  content: ""Characters: "";
  font-weight: bold;
}

li.relationships + li.characters:before {
  color: #111;
  content: ""Characters: "";
  font-weight: bold;
}

li.warnings + li.relationships:before {
  color: #111;
  content: ""Relationships: "";
  font-weight: bold;
}

li.characters + li.freeforms:before {
  color: #111;
  content: ""Freeform: "";
  font-weight: bold;
}

li.warnings + li.relationships,
li.relationships + li.characters,
li.characters + li.freeforms,
li.warnings + li.characters,
li.warnings + li.freeforms,
li.relationships + li.freeforms {
  clear: left;
  padding: none;
}

.listbox .index {
  background: transparent;
  box-shadow: none;
}

.listbox,
fieldset fieldset.listbox {
  background: transparent;
  border: none;
  box-shadow: none;
}"
52QfmzT0,LagBot V1.1,Myros27,Lua,Saturday 17th of May 2025 08:08:37 PM CDT,"--[[
    LagBot Turtle Script v1.1
    Monitors server TPS via a direct redstone signal and provides alerts.
    Also reports the redstone signal (TPS value) on command.

    Changes:
    - (v1.0) Initial concept with peripheral assumption.
    - (v1.1) Adapted to read TPS from a direct redstone signal using the redstone API.
             Removed TPS_METER_PERIPHERAL_NAME.
             Added TPS_INPUT_SIDE configuration.
             Power reporting now reports the direct redstone (TPS) input.
]]

--#region Configuration
local CHAT_BOX_PERIPHERAL_NAME = ""chatBox""
local TPS_INPUT_SIDE = ""front"" -- CHANGE THIS to the side the turtle is facing the TPS meter block
                              -- Valid sides: ""top"", ""bottom"", ""left"", ""right"", ""front"", ""back""

local COMMAND_PREFIX = ""@lag""
local CHAT_BOT_NAME = ""LagBot""
local CHAT_BOT_BRACKETS = ""[]""
local CHAT_BOT_BRACKET_COLOR = ""&c"" -- Red color for brackets

-- TPS alert thresholds (triggers if Redstone Signal strength <= value)
-- Assuming 0-15 Redstone signal directly maps to a scaled TPS value.
-- For example, if 15 RS = 20 TPS, then 11 RS ~ 15 TPS, 7 RS ~ 10 TPS, 3 RS ~ 5 TPS.
-- You'll need to adjust these based on how your TPS meter block scales its output.
local DEFAULT_TPS_ALERT_THRESHOLDS = {3, 2, 1} -- Example: Alert if RS signal <= 3 (e.g. ~5 TPS)
local TPS_RECOVERY_THRESHOLD_RS = 7 -- Example: Recover if RS signal > 7 (e.g. >10 TPS)
                                     -- This is the REDSTONE SIGNAL value for recovery.

local TPS_CHECK_INTERVAL_SECONDS = 5
local TPS_REPORT_INTERVAL_SECONDS = 2 -- Renamed from POWER_REPORT for clarity

local DEBUG_MODE = false
local DEBUG_LOG_FILE = ""lagbot.log""
--#endregion

--#region Peripherals
local chatBox = peripheral.find(CHAT_BOX_PERIPHERAL_NAME)
-- No tpsMeter peripheral needed anymore
--#endregion

--#region Debug Logger
local function logDebug(message)
    if not DEBUG_MODE then return end
    local logMessage = string.format(""[%s] %s\n"", os.date(""%Y-%m-%d %H:%M:%S""), message)
    local file, err = fs.open(DEBUG_LOG_FILE, ""a"")
    if file then
        file.write(logMessage)
        file.close()
    else
        print(""DEBUG LOG ERROR: Could not open "" .. DEBUG_LOG_FILE .. "": "" .. (err or ""unknown error""))
    end
end
--#endregion

--#region State Variables
logDebug(""Script initializing state variables..."")
local currentTpsAlertThresholdsRS = {} -- Stores Redstone Signal thresholds
for _, v in ipairs(DEFAULT_TPS_ALERT_THRESHOLDS) do table.insert(currentTpsAlertThresholdsRS, v) end
table.sort(currentTpsAlertThresholdsRS, function(a,b) return a > b end) -- Ensure sorted descending

local isMuted = false
local lastNotifiedTpsLevelRS = 16 -- Stores the RS threshold that last triggered (initially > 15)
local tpsCheckTimerId = nil
local isReportingTps = false -- Renamed from isReportingPower
local tpsReportTimerId = nil -- Renamed from powerReportTimerId
logDebug(""State variables initialized. Muted: "" .. tostring(isMuted))
--#endregion

--#region Minecraft JSON Text Component Colors
local COLORS = {
    BLACK = ""black"", DARK_BLUE = ""dark_blue"", DARK_GREEN = ""dark_green"", DARK_AQUA = ""dark_aqua"",
    DARK_RED = ""dark_red"", DARK_PURPLE = ""dark_purple"", GOLD = ""gold"", GRAY = ""gray"",
    DARK_GRAY = ""dark_gray"", BLUE = ""blue"", GREEN = ""green"", AQUA = ""aqua"", RED = ""red"",
    LIGHT_PURPLE = ""light_purple"", YELLOW = ""yellow"", WHITE = ""white"", RESET = ""reset""
}
--#endregion

--#region Helper Functions
local function sendFormattedChat(messageComponents, recipientUsername)
    logDebug(""Attempting to send formatted chat. Recipient: "" .. (recipientUsername or ""ALL""))
    if not chatBox then
        local plainText = """"
        for _, comp in ipairs(messageComponents) do plainText = plainText .. (comp.text or """") end
        local noChatMsg = ""["" .. CHAT_BOT_NAME .. ""-NoChatBox"" .. (recipientUsername and ("" to "" .. recipientUsername) or """") .. ""] "" .. plainText
        print(noChatMsg)
        logDebug(""ChatBox not found. Printed to console: "" .. noChatMsg)
        return
    end

    local jsonMessage = textutils.serialiseJSON(messageComponents)
    if not jsonMessage then
        local fallbackMsg = ""Error: Could not serialize message for formatted sending.""
        logDebug(""JSON Serialization Error. Fallback: "" .. fallbackMsg .. "" Data: "" .. textutils.serialize(messageComponents, {max_depth=2}))
        if recipientUsername then
            chatBox.sendMessageToPlayer(fallbackMsg, recipientUsername, CHAT_BOT_NAME, CHAT_BOT_BRACKETS, CHAT_BOT_BRACKET_COLOR)
        else
            chatBox.sendMessage(fallbackMsg, CHAT_BOT_NAME, CHAT_BOT_BRACKETS, CHAT_BOT_BRACKET_COLOR)
        end
        return
    end

    local success, err
    if recipientUsername then
        success, err = chatBox.sendFormattedMessageToPlayer(jsonMessage, recipientUsername, CHAT_BOT_NAME, CHAT_BOT_BRACKETS, CHAT_BOT_BRACKET_COLOR)
    else
        success, err = chatBox.sendFormattedMessage(jsonMessage, CHAT_BOT_NAME, CHAT_BOT_BRACKETS, CHAT_BOT_BRACKET_COLOR)
    end

    if not success then
        logDebug(""Error sending formatted message: "" .. (err or ""Unknown error"") .. "". Attempting fallback to plain text."")
        local plainText = """"
        for _, comp in ipairs(messageComponents) do plainText = plainText .. (comp.text or """") end
        if recipientUsername then
            chatBox.sendMessageToPlayer(plainText, recipientUsername, CHAT_BOT_NAME, CHAT_BOT_BRACKETS, CHAT_BOT_BRACKET_COLOR)
        else
            chatBox.sendMessage(plainText, CHAT_BOT_NAME, CHAT_BOT_BRACKETS, CHAT_BOT_BRACKET_COLOR)
        end
    else
        logDebug(""Formatted message sent successfully."")
    end
    os.sleep(0.3)
end

local function announce(messageComponents)
    sendFormattedChat(messageComponents)
end

local function getCurrentRedstoneTps()
    local success, value = pcall(redstone.getAnalogInput, TPS_INPUT_SIDE)
    if success and type(value) == ""number"" then
        logDebug(""Read Redstone TPS from "" .. TPS_INPUT_SIDE .. "": "" .. value)
        return value
    else
        logDebug(""Failed to read Redstone TPS from "" .. TPS_INPUT_SIDE .. "". Error/Value: "" .. tostring(value))
        return nil
    end
end

local function checkTpsAndAlert()
    logDebug(""Checking Redstone TPS..."")
    local currentRSTps = getCurrentRedstoneTps()

    if currentRSTps == nil then
        logDebug(""Could not retrieve Redstone TPS for alert check."")
        return
    end

    -- Optional: Convert Redstone signal (0-15) to actual TPS (0-20) for display
    -- Example scaling: actualTPS = currentRSTps * (20/15)
    local displayTPS = string.format(""%d RS"", currentRSTps) -- Default to showing Redstone Signal
    -- If you want to show estimated actual TPS:
    -- local estimatedActualTps = currentRSTps * (20/15)
    -- displayTPS = string.format(""%.1f TPS (RS: %d)"", estimatedActualTps, currentRSTps)


    logDebug(string.format(""Current Redstone TPS: %d, Last Notified RS Level: %s, Muted: %s"", currentRSTps, tostring(lastNotifiedTpsLevelRS), tostring(isMuted)))

    if not isMuted then
        local alertTriggeredThisCheck = false
        for _, thresholdRS in ipairs(currentTpsAlertThresholdsRS) do -- Assumes sorted descending
            if currentRSTps <= thresholdRS then
                if thresholdRS < lastNotifiedTpsLevelRS then
                    announce({
                        {text=""WARNING: Server health indicator dropped to "", color=COLORS.YELLOW},
                        {text=displayTPS, color=COLORS.RED, bold=true},
                        {text="" (Alert Level: <="" .. thresholdRS .. "" RS)"", color=COLORS.YELLOW}
                    })
                    lastNotifiedTpsLevelRS = thresholdRS
                    alertTriggeredThisCheck = true
                    logDebug(""Alert sent for RS TPS <= "" .. thresholdRS .. "". New lastNotifiedTpsLevelRS: "" .. lastNotifiedTpsLevelRS)
                    break
                else
                    logDebug(""RS TPS is "" .. currentRSTps .. "", which is <= threshold "" .. thresholdRS .. "", but lastNotifiedTpsLevelRS ("" .. lastNotifiedTpsLevelRS .. "") is not higher. No new alert."")
                    break
                end
            end
        end

        if not alertTriggeredThisCheck and currentRSTps > TPS_RECOVERY_THRESHOLD_RS and lastNotifiedTpsLevelRS <= TPS_RECOVERY_THRESHOLD_RS then
            announce({
                {text=""RECOVERY: Server health indicator is now "", color=COLORS.GREEN},
                {text=displayTPS, color=COLORS.AQUA, bold=true},
                {text="" (Above recovery RS threshold of "" .. TPS_RECOVERY_THRESHOLD_RS .. "")"", color=COLORS.GREEN}
            })
            lastNotifiedTpsLevelRS = 16
            logDebug(""Recovery message sent. RS TPS: "" .. currentRSTps .. "". lastNotifiedTpsLevelRS reset."")
        end
    else
        logDebug(""Alerts are muted. No TPS alert action taken."")
    end
end

local function reportCurrentTps() -- Renamed from reportPowerLevel
    if not isReportingTps then return end
    logDebug(""Reporting current Redstone TPS..."")

    local currentRSTps = getCurrentRedstoneTps()
    if currentRSTps ~= nil then
        -- Optional: Convert to display actual TPS as well
        -- local estimatedActualTps = currentRSTps * (20/15)
        -- local displayTPS = string.format(""%.1f TPS (Redstone Signal: %d)"", estimatedActualTps, currentRSTps)
        local displayTPS = string.format(""%d"", currentRSTps) -- Default: just show RS value

        announce({{text=""Current Health Indicator (Redstone Signal): "", color=COLORS.GRAY}, {text=displayTPS, color=COLORS.YELLOW}})
    else
        logDebug(""Failed to get Redstone TPS for reporting."")
        announce({{text=""Error reading health indicator (Redstone Signal)."", color=COLORS.RED}})
        isReportingTps = false -- Stop trying
        if tpsReportTimerId then os.cancelTimer(tpsReportTimerId); tpsReportTimerId = nil; end
        return
    end

    if isReportingTps then
        tpsReportTimerId = os.startTimer(TPS_REPORT_INTERVAL_SECONDS)
        logDebug(""TPS report timer restarted. ID: "" .. (tpsReportTimerId or ""nil""))
    else
        logDebug(""TPS reporting was stopped, not restarting timer."")
    end
end

local function startTpsCheckTimer()
    if tpsCheckTimerId then os.cancelTimer(tpsCheckTimerId) end
    tpsCheckTimerId = os.startTimer(TPS_CHECK_INTERVAL_SECONDS)
    logDebug(""TPS check timer started/restarted. ID: "" .. tpsCheckTimerId)
end

local function startTpsReportTimer() -- Renamed from startPowerReportTimer
    if not isReportingTps then return end
    if tpsReportTimerId then os.cancelTimer(tpsReportTimerId) end
    reportCurrentTps() -- Report immediately, then start timer
end
--#endregion

--#region Command Handlers
local commandHandlers = {}

commandHandlers.help = function(username, _)
    logDebug(""Executing command: help, User: "" .. username)
    announce({{text = ""--- LagBot Commands ("".. COMMAND_PREFIX .. "") ---"", color = COLORS.GOLD, bold = true}})
    announce({{text = COMMAND_PREFIX .. "" help"", color = COLORS.AQUA}, {text = "" - Shows this help message."", color = COLORS.GRAY}})
    announce({{text = COMMAND_PREFIX .. "" status"", color = COLORS.AQUA}, {text = "" - Shows current TPS (Redstone Signal) and bot status."", color = COLORS.GRAY}})
    announce({{text = COMMAND_PREFIX .. "" mute"", color = COLORS.AQUA}, {text = "" - Toggles TPS alert announcements."", color = COLORS.GRAY}})
    announce({{text = COMMAND_PREFIX .. "" setalerts <rs1> [rs2...]"", color = COLORS.AQUA}, {text = "" - Sets Redstone Signal alert thresholds (0-15)."", color = COLORS.GRAY}})
    announce({{text = COMMAND_PREFIX .. "" startreport"", color = COLORS.AQUA}, {text = "" - Starts reporting Redstone Signal every "" ..TPS_REPORT_INTERVAL_SECONDS.. ""s."", color = COLORS.GRAY}})
    announce({{text = COMMAND_PREFIX .. "" stopreport"", color = COLORS.AQUA}, {text = "" - Stops reporting Redstone Signal."", color = COLORS.GRAY}})
end

commandHandlers.status = function(username, _)
    logDebug(""Executing command: status, User: "" .. username)
    local currentRSTps = getCurrentRedstoneTps()
    if currentRSTps ~= nil then
        -- Optional: Convert to display actual TPS as well
        -- local estimatedActualTps = currentRSTps * (20/15)
        -- local displayTPS = string.format(""%.1f TPS (Redstone Signal: %d)"", estimatedActualTps, currentRSTps)
        local displayTPS = string.format(""%d"", currentRSTps) -- Default: just show RS value
        announce({{text=""Current Health Indicator (Redstone Signal): "", color=COLORS.GREEN}, {text=displayTPS, color=COLORS.AQUA}})
    else
        announce({{text=""Could not retrieve current health indicator (Redstone Signal)."", color=COLORS.RED}})
    end
    announce({{text=""Alerts Muted: "", color=COLORS.GRAY}, {text=tostring(isMuted), color=(isMuted and COLORS.YELLOW or COLORS.GREEN)}})
    local thresholdsStr = """"
    for i, t in ipairs(currentTpsAlertThresholdsRS) do thresholdsStr = thresholdsStr .. t .. (i < #currentTpsAlertThresholdsRS and "", "" or """") end
    announce({{text=""Current Alert Thresholds (Redstone Signal <=): "", color=COLORS.GRAY}, {text=thresholdsStr, color=COLORS.YELLOW}})
    announce({{text=""Reporting Redstone Signal: "", color=COLORS.GRAY}, {text=tostring(isReportingTps), color=(isReportingTps and COLORS.GREEN or COLORS.YELLOW)}})
end

commandHandlers.mute = function(username, _)
    logDebug(""Executing command: mute, User: "" .. username)
    isMuted = not isMuted
    if isMuted then
        announce({{text=""Health alerts are now "", color=COLORS.YELLOW}, {text=""MUTED"", bold=true, color=COLORS.RED}, {text="" by "" .. username .. ""."", color=COLORS.YELLOW}})
    else
        announce({{text=""Health alerts are now "", color=COLORS.GREEN}, {text=""UNMUTED"", bold=true, color=COLORS.AQUA}, {text="" by "" .. username .. ""."", color=COLORS.GREEN}})
        lastNotifiedTpsLevelRS = 16
        checkTpsAndAlert()
    end
    logDebug(""Mute status changed to: "" .. tostring(isMuted))
end

commandHandlers.setalerts = function(username, args)
    logDebug(""Executing command: setalerts, User: "" .. username .. "", Args: "" .. textutils.serialize(args))
    if #args == 0 then
        announce({{text=""Usage: "" .. COMMAND_PREFIX .. "" setalerts <rs_value1> [rs_value2...]"", color=COLORS.YELLOW}})
        announce({{text=""Values are Redstone Signal strength (0-15). Example: "" .. COMMAND_PREFIX .. "" setalerts 3 2 1"", color=COLORS.YELLOW}})
        return
    end

    local newThresholdsRS = {}
    for _, arg_val in ipairs(args) do
        local num = tonumber(arg_val)
        if num and num >= 0 and num <= 15 then -- Redstone signal is 0-15
            table.insert(newThresholdsRS, math.floor(num))
        else
            announce({{text=""Invalid threshold value: '"", color=COLORS.RED}, {text=tostring(arg_val), color=COLORS.YELLOW}, {text=""'. Must be a number between 0 and 15."", color=COLORS.RED}})
            return
        end
    end

    if #newThresholdsRS == 0 then
        announce({{text=""No valid thresholds provided."", color=COLORS.RED}})
        return
    end

    table.sort(newThresholdsRS, function(a,b) return a > b end)
    currentTpsAlertThresholdsRS = newThresholdsRS
    lastNotifiedTpsLevelRS = 16

    local thresholdsStr = """"
    for i, t in ipairs(currentTpsAlertThresholdsRS) do thresholdsStr = thresholdsStr .. t .. (i < #currentTpsAlertThresholdsRS and "", "" or """") end

    announce({{text=""Redstone Signal alert thresholds set to: "", color=COLORS.GREEN}, {text=thresholdsStr, color=COLORS.AQUA}, {text="" by "" .. username .. ""."", color=COLORS.GREEN}})
    logDebug(""Alert thresholds updated: "" .. thresholdsStr)
    checkTpsAndAlert()
end

commandHandlers.startreport = function(username, _) -- Renamed from startpower
    logDebug(""Executing command: startreport, User: "" .. username)
    if isReportingTps then
        announce({{text=""Redstone Signal reporting is already active."", color=COLORS.YELLOW}})
        return
    end
    isReportingTps = true
    announce({{text=""Starting Redstone Signal reporting every ""..TPS_REPORT_INTERVAL_SECONDS..""s (requested by "" .. username .. "")."", color=COLORS.GREEN}})
    startTpsReportTimer()
end

commandHandlers.stopreport = function(username, _) -- Renamed from stoppower
    logDebug(""Executing command: stopreport, User: "" .. username)
    if not isReportingTps then
        announce({{text=""Redstone Signal reporting is not currently active."", color=COLORS.YELLOW}})
        return
    end
    isReportingTps = false
    if tpsReportTimerId then
        os.cancelTimer(tpsReportTimerId)
        tpsReportTimerId = nil
        logDebug(""TPS report timer cancelled."")
    end
    announce({{text=""Stopped Redstone Signal reporting (requested by "" .. username .. "")."", color=COLORS.GREEN}})
end
--#endregion

--#region Main Loop
local function run()
    term.clear(); term.setCursorPos(1,1)

    if DEBUG_MODE then
        local file, err = fs.open(DEBUG_LOG_FILE, ""w"")
        if file then
            file.write(string.format(""[%s] LagBot Script Initializing - DEBUG MODE ENABLED (v1.1)\n"", os.date(""%Y-%m-%d %H:%M:%S"")))
            file.write(""======================================================================\n"")
            file.close()
        else print(""DEBUG LOG ERROR: Could not clear/initialize "" .. DEBUG_LOG_FILE .. "": "" .. (err or ""unknown error"")) end
    end
    logDebug(""Script run() started."")

    if not chatBox then
        logDebug(""WARNING: Chat Box peripheral ('"" .. CHAT_BOX_PERIPHERAL_NAME .. ""') not found!"")
        print(""WARNING: Chat Box ('"" .. CHAT_BOX_PERIPHERAL_NAME .. ""') not found! Chat features disabled/printed to console."")
    end

    -- Validate TPS_INPUT_SIDE
    local validSides = redstone.getSides()
    local sideIsValid = false
    for _, side in ipairs(validSides) do if side == TPS_INPUT_SIDE then sideIsValid = true; break; end end
    if not sideIsValid then
        logDebug(""CRITICAL: Invalid TPS_INPUT_SIDE ('"" .. TPS_INPUT_SIDE .. ""') configured! Core functionality disabled."")
        print(""CRITICAL: Invalid TPS_INPUT_SIDE ('"" .. TPS_INPUT_SIDE .. ""')! Check config. LagBot functionality disabled."")
        if chatBox then announce({{text=CHAT_BOT_NAME .. "" starting with CRITICAL ERROR: Invalid TPS_INPUT_SIDE!"", color=COLORS.RED, bold=true}}) end
        return -- Stop script if side is invalid, as it can't function
    end
    logDebug(""TPS_INPUT_SIDE ('"" .. TPS_INPUT_SIDE .. ""') is valid."")


    logDebug(""Announcing online status."")
    print(CHAT_BOT_NAME .. "" script started. Type '"" .. COMMAND_PREFIX .. "" help' in chat or '@all'."")
    if chatBox then
        announce({{text = CHAT_BOT_NAME .. "" online."", color = COLORS.GREEN, bold = true}, {text = "" Monitoring server health via Redstone Signal on side: "" .. TPS_INPUT_SIDE, color = COLORS.GRAY}})
        announce({{text = ""Type '"", color = COLORS.GRAY}, {text = COMMAND_PREFIX .. "" help"", color = COLORS.AQUA}, {text = ""' or '@all' for commands."", color = COLORS.GRAY}})
    end

    checkTpsAndAlert()
    startTpsCheckTimer()

    while true do
        local eventData = {os.pullEvent()}
        local eventType = eventData[1]

        -- Optimized: If it's a redstone event and it's for our TPS_INPUT_SIDE, check TPS immediately.
        if eventType == ""redstone"" then
            logDebug(""Redstone event received."")
            -- The redstone event itself doesn't give the side or new value in CC:Tweaked by default.
            -- We just use it as a trigger to re-check.
            checkTpsAndAlert()
        end

        logDebug(""Event pulled: "" .. eventType .. "" - Data: "" .. textutils.serialize(eventData, {compact = true, max_depth = 2}))

        if eventType == ""chat"" then
            local eUsername, eMessage, _, eIsHidden = eventData[2], eventData[3], eventData[4], eventData[5]
            if not eIsHidden and eMessage then
                if string.lower(eMessage) == ""@all"" then
                    logDebug(""@all command received from "" .. eUsername)
                    announce({{text = ""Use '"", color = COLORS.GREEN}, {text = COMMAND_PREFIX .. "" help"", color = COLORS.AQUA}, {text = ""' to see what this health monitor can do."", color = COLORS.GREEN}})
                elseif string.sub(eMessage, 1, #COMMAND_PREFIX) == COMMAND_PREFIX then
                    logDebug(""Chat command received from "" .. eUsername .. "": "" .. eMessage)
                    local parts = {}; for part in string.gmatch(eMessage, ""[^%s]+"") do table.insert(parts, part) end
                    local commandName = """"; if parts[2] then commandName = string.lower(parts[2]) end
                    local cmdArgs = {}; for i = 3, #parts do table.insert(cmdArgs, parts[i]) end
                    logDebug(""Parsed command: '"" .. commandName .. ""', Args: "" .. textutils.serialize(cmdArgs))

                    if commandHandlers[commandName] then
                        local success, err = pcall(commandHandlers[commandName], eUsername, cmdArgs)
                        if not success then
                            logDebug(""Error executing command '"" .. commandName .. ""': "" .. tostring(err))
                            announce({{text = ""Command execution failed: "", color = COLORS.RED}, {text = commandName, color = COLORS.YELLOW}})
                        end
                    elseif commandName ~= """" then
                        announce({{text = ""Unknown command: '"", color = COLORS.RED}, {text = commandName, color = COLORS.YELLOW},
                                  {text = ""'. Consult '"", color = COLORS.RED}, {text = COMMAND_PREFIX .. "" help"", color = COLORS.AQUA}, {text = ""'."", color = COLORS.RED}})
                    end
                end
            end
        elseif eventType == ""timer"" then
            local timerId = eventData[2]
            logDebug(""Timer event received for ID: "" .. timerId)
            if timerId == tpsCheckTimerId then
                logDebug(""TPS check timer triggered."")
                checkTpsAndAlert(); startTpsCheckTimer()
            elseif timerId == tpsReportTimerId then
                logDebug(""TPS report timer triggered."")
                reportCurrentTps()
            else
                logDebug(""Unknown timer ID: "" .. timerId)
            end
        elseif eventType == ""terminate"" then
            logDebug(""Terminate event received. System halt."")
            if tpsCheckTimerId then os.cancelTimer(tpsCheckTimerId); logDebug(""TPS check timer cancelled."") end
            if tpsReportTimerId then os.cancelTimer(tpsReportTimerId); logDebug(""TPS report timer cancelled."") end
            if chatBox then announce({{text = CHAT_BOT_NAME .. "" is going offline."", color = COLORS.YELLOW, bold = true}}) end
            logDebug(""Script terminated.""); print(CHAT_BOT_NAME .. "" terminated."")
            return
        end
    end
end

run()
--#endregion"
6Dpy7748,JokeBot V1.2,Myros27,Lua,Saturday 17th of May 2025 07:26:53 PM CDT,"--[[
    JokeBot Turtle Script v1.2
    Tells jokes from JokeAPI and can tell them at an interval.
    Changes:
    - (v1.0) Initial release.
    - (v1.1) Removed joke announcement prefixes.
             Changed joke text color to GOLD.
             Added response to ""@all"" chat command.
    - (v1.2) Added random API endpoint selection from a list.
             Added support for two-part jokes with different colors for setup (Aqua) and delivery (Gold).
             Ensured API URLs request single or twopart jokes.
]]

--#region Configuration
local CHAT_BOX_PERIPHERAL_NAME = ""chatBox"" -- Set to your chat box peripheral name if different

local COMMAND_PREFIX = ""@joke""
local CHAT_BOT_NAME = ""JokeBot""
local CHAT_BOT_BRACKETS = ""[]""
local CHAT_BOT_BRACKET_COLOR = ""&e"" -- Yellow color for the brackets

-- List of API URLs to randomly choose from
local JOKE_API_URLS = {
    ""https://v2.jokeapi.dev/joke/Programming,Dark?type=single,twopart"",
    ""https://v2.jokeapi.dev/joke/Any?type=single,twopart"",
    ""https://v2.jokeapi.dev/joke/Programming,Dark?lang=de&type=single,twopart"",
    ""https://v2.jokeapi.dev/joke/Any?lang=de&type=single,twopart"",
    ""https://v2.jokeapi.dev/joke/Miscellaneous,Pun?type=single,twopart"" -- Added another option for variety
}

local DEFAULT_JOKE_INTERVAL_MINUTES = 0 -- 0 means no automatic jokes

local DEBUG_MODE = false -- Set to true for detailed logging
local DEBUG_LOG_FILE = ""jokebot.log""
--#endregion

--#region Peripherals
local chatBox = peripheral.find(CHAT_BOX_PERIPHERAL_NAME)
--#endregion

--#region Debug Logger
local function logDebug(message)
    if not DEBUG_MODE then return end
    local logMessage = string.format(""[%s] %s\n"", os.date(""%Y-%m-%d %H:%M:%S""), message)
    local file, err = fs.open(DEBUG_LOG_FILE, ""a"")
    if file then
        file.write(logMessage)
        file.close()
    else
        print(""DEBUG LOG ERROR: Could not open "" .. DEBUG_LOG_FILE .. "": "" .. (err or ""unknown error""))
    end
end
--#endregion

--#region State Variables
logDebug(""Script initializing state variables..."")
local jokeIntervalMinutes = DEFAULT_JOKE_INTERVAL_MINUTES
local jokeIntervalTimerId = nil
logDebug(""State variables initialized. Interval: "" .. jokeIntervalMinutes .. "" min."")
--#endregion

--#region Minecraft JSON Text Component Colors
local COLORS = {
    BLACK = ""black"", DARK_BLUE = ""dark_blue"", DARK_GREEN = ""dark_green"", DARK_AQUA = ""dark_aqua"",
    DARK_RED = ""dark_red"", DARK_PURPLE = ""dark_purple"", GOLD = ""gold"", GRAY = ""gray"",
    DARK_GRAY = ""dark_gray"", BLUE = ""blue"", GREEN = ""green"", AQUA = ""aqua"", RED = ""red"",
    LIGHT_PURPLE = ""light_purple"", YELLOW = ""yellow"", WHITE = ""white"", RESET = ""reset""
}
--#endregion

--#region Helper Functions
local function sendFormattedChat(messageComponents, recipientUsername)
    logDebug(""Attempting to send formatted chat. Recipient: "" .. (recipientUsername or ""ALL""))
    if not chatBox then
        local plainText = """"
        for _, comp in ipairs(messageComponents) do plainText = plainText .. (comp.text or """") end
        local noChatMsg = ""["" .. CHAT_BOT_NAME .. ""-NoChatBox"" .. (recipientUsername and ("" to "" .. recipientUsername) or """") .. ""] "" .. plainText
        print(noChatMsg)
        logDebug(""ChatBox not found. Printed to console: "" .. noChatMsg)
        return
    end

    local jsonMessage = textutils.serialiseJSON(messageComponents)
    if not jsonMessage then
        local fallbackMsg = ""Error: Could not serialize message for formatted sending.""
        logDebug(""JSON Serialization Error. Fallback: "" .. fallbackMsg .. "" Data: "" .. textutils.serialize(messageComponents, {max_depth=2}))
        if recipientUsername then
            chatBox.sendMessageToPlayer(fallbackMsg, recipientUsername, CHAT_BOT_NAME, CHAT_BOT_BRACKETS, CHAT_BOT_BRACKET_COLOR)
        else
            chatBox.sendMessage(fallbackMsg, CHAT_BOT_NAME, CHAT_BOT_BRACKETS, CHAT_BOT_BRACKET_COLOR)
        end
        return
    end

    local success, err
    if recipientUsername then
        success, err = chatBox.sendFormattedMessageToPlayer(jsonMessage, recipientUsername, CHAT_BOT_NAME, CHAT_BOT_BRACKETS, CHAT_BOT_BRACKET_COLOR)
    else
        success, err = chatBox.sendFormattedMessage(jsonMessage, CHAT_BOT_NAME, CHAT_BOT_BRACKETS, CHAT_BOT_BRACKET_COLOR)
    end

    if not success then
        logDebug(""Error sending formatted message: "" .. (err or ""Unknown error"") .. "". Attempting fallback to plain text."")
        local plainText = """"
        for _, comp in ipairs(messageComponents) do plainText = plainText .. (comp.text or """") end
        if recipientUsername then
            chatBox.sendMessageToPlayer(plainText, recipientUsername, CHAT_BOT_NAME, CHAT_BOT_BRACKETS, CHAT_BOT_BRACKET_COLOR)
        else
            chatBox.sendMessage(plainText, CHAT_BOT_NAME, CHAT_BOT_BRACKETS, CHAT_BOT_BRACKET_COLOR)
        end
    else
        logDebug(""Formatted message sent successfully."")
    end
    os.sleep(0.3)
end

local function announce(messageComponents)
    sendFormattedChat(messageComponents)
end

local function announceJokePart(textPart, color)
    local lines = {}
    for line in string.gmatch(textPart, ""[^\r\n]+"") do
        table.insert(lines, line)
    end
    if #lines == 0 and textPart ~= """" then table.insert(lines, textPart) end

    for i, lineText in ipairs(lines) do
        announce({{text = lineText, color = color}})
        if i < #lines then
            os.sleep(0.7) -- Delay between lines of the same part
        end
    end
end

local function fetchAndTellJoke(requestingUsername)
    logDebug(""Fetching a joke. Requested by: "" .. (requestingUsername or ""Timer""))
    if not http then
        logDebug(""HTTP API not available, cannot fetch joke."")
        announce({{text = ""Cannot fetch joke: HTTP API is not available on this system."", color = COLORS.RED}})
        return
    end

    if #JOKE_API_URLS == 0 then
        logDebug(""JOKE_API_URLS list is empty."")
        announce({{text = ""No Joke API URLs configured. Cannot fetch joke."", color = COLORS.RED}})
        return
    end

    math.randomseed(os.epoch(""utc"") + os.clock()*1000) -- Reseed for better randomness
    local selectedApiUrl = JOKE_API_URLS[math.random(1, #JOKE_API_URLS)]
    logDebug(""Selected API URL: "" .. selectedApiUrl)

    local response, err, handle = http.get(selectedApiUrl)
    if not response then
        logDebug(""Failed to fetch joke from API. URL: "" .. selectedApiUrl .. "" Error: "" .. (err or ""Unknown HTTP error""))
        announce({{text = ""Sorry, I couldn't fetch a joke. Error: "", color = COLORS.RED}, {text = tostring(err or ""Is http enabled?""), color = COLORS.YELLOW}})
        return
    end

    local responseBody = response.readAll()
    response.close()
    if handle then pcall(function() handle.close() end) end

    local success, jokeData = pcall(textutils.unserialiseJSON, responseBody)
    if not success or type(jokeData) ~= ""table"" then
        logDebug(""Failed to parse joke JSON. Error: "" .. tostring(jokeData or ""Invalid JSON"") .. "". Body was: "" .. tostring(responseBody))
        announce({{text = ""Sorry, I received a malformed joke. (Could not parse API response)."", color = COLORS.YELLOW}})
        return
    end

    if jokeData.error then
        logDebug(""Joke API returned an error. Message: "" .. (jokeData.message or ""Unknown API error""))
        announce({{text = ""The joke API said: \"""", color = COLORS.RED}, {text = tostring(jokeData.message or ""Something went wrong.""), color = COLORS.YELLOW}, {text=""\"""", color = COLORS.RED}})
        return
    end

    if jokeData.type == ""single"" and type(jokeData.joke) == ""string"" then
        logDebug(""Telling single-part joke. Lang: "" .. (jokeData.lang or ""N/A""))
        announceJokePart(jokeData.joke, COLORS.GOLD)
    elseif jokeData.type == ""twopart"" and type(jokeData.setup) == ""string"" and type(jokeData.delivery) == ""string"" then
        logDebug(""Telling two-part joke. Lang: "" .. (jokeData.lang or ""N/A""))
        announceJokePart(jokeData.setup, COLORS.AQUA) -- Setup in Aqua
        os.sleep(1.2) -- Pause for comedic timing before delivery
        announceJokePart(jokeData.delivery, COLORS.GOLD) -- Delivery in Gold (orangey)
    else
        logDebug(""Joke API returned an unexpected format or missing fields. Data: "" .. textutils.serialize(jokeData))
        announce({{text = ""Sorry, the joke I got was in a weird format or incomplete. Try again?"", color = COLORS.YELLOW}})
    end
end

local function startJokeIntervalTimer()
    if jokeIntervalTimerId then
        os.cancelTimer(jokeIntervalTimerId)
        logDebug(""Cancelled existing joke interval timer ID: "" .. jokeIntervalTimerId)
        jokeIntervalTimerId = nil
    end
    if jokeIntervalMinutes > 0 then
        jokeIntervalTimerId = os.startTimer(jokeIntervalMinutes * 60)
        logDebug(""Joke interval timer started. Duration: "" .. jokeIntervalMinutes .. "" min. New Timer ID: "" .. jokeIntervalTimerId)
    else
        logDebug(""Joke interval is 0, timer not started."")
    end
end
--#endregion

--#region Command Handlers
local commandHandlers = {}

commandHandlers.help = function(username, _)
    logDebug(""Executing command: help, User: "" .. username)
    announce({{text = ""--- JokeBot Commands ("".. COMMAND_PREFIX .. "") ---"", color = COLORS.GOLD, bold = true}})
    announce({{text = COMMAND_PREFIX .. "" help"", color = COLORS.AQUA}, {text = "" - Shows this help message."", color = COLORS.GRAY}})
    announce({{text = COMMAND_PREFIX .. "" tell"", color = COLORS.AQUA}, {text = "" - Tells you a random joke."", color = COLORS.GRAY}})
    announce({{text = COMMAND_PREFIX .. "" interval <minutes>"", color = COLORS.AQUA}, {text = "" - Sets automatic joke interval."", color = COLORS.GRAY}})
    announce({{text = ""  (Use 0 for minutes to disable automatic jokes)"", color = COLORS.DARK_GRAY}})
end

commandHandlers.tell = function(username, _)
    logDebug(""Executing command: tell, User: "" .. username)
    fetchAndTellJoke(username)
end

commandHandlers.interval = function(username, args)
    logDebug(""Executing command: interval, User: "" .. username .. "", Args: "" .. textutils.serialize(args))
    if #args < 1 then
        announce({{text = ""Usage: "", color = COLORS.YELLOW}, {text = COMMAND_PREFIX .. "" interval <minutes>"", color = COLORS.AQUA}})
        announce({{text = ""Current interval: "", color = COLORS.YELLOW}, {text = jokeIntervalMinutes .. "" minutes."", color = COLORS.WHITE}})
        return
    end

    local minutes = tonumber(args[1])
    if not minutes or minutes < 0 or math.floor(minutes) ~= minutes then
        announce({{text = ""Invalid number of minutes. Must be a whole number (0 or greater)."", color = COLORS.RED}})
        return
    end

    jokeIntervalMinutes = minutes
    if minutes > 0 then
        announce({{text = ""Okay, "" .. username .. ""! I'll tell a joke every "", color = COLORS.GREEN}, {text = minutes .. "" minute(s)."", color = COLORS.AQUA}})
    else
        announce({{text = ""Okay, "" .. username .. ""! Automatic jokes disabled."", color = COLORS.GREEN}})
    end
    logDebug(""Joke interval set to "" .. jokeIntervalMinutes .. "" minutes by "" .. username)
    startJokeIntervalTimer()
end
--#endregion

--#region Main Loop
local function run()
    term.clear()
    term.setCursorPos(1, 1)

    if DEBUG_MODE then
        local file, err = fs.open(DEBUG_LOG_FILE, ""w"")
        if file then
            file.write(string.format(""[%s] JokeBot Script Initializing - DEBUG MODE ENABLED (v1.2)\n"", os.date(""%Y-%m-%d %H:%M:%S"")))
            file.write(""======================================================================\n"")
            file.close()
        else
            print(""DEBUG LOG ERROR: Could not clear/initialize "" .. DEBUG_LOG_FILE .. "": "" .. (err or ""unknown error""))
        end
    end
    logDebug(""Script run() started."")

    if not chatBox then
        logDebug(""WARNING: Chat Box peripheral ('"" .. CHAT_BOX_PERIPHERAL_NAME .. ""') not found! Chat features will be printed to console only."")
        print(""WARNING: Chat Box ('"" .. CHAT_BOX_PERIPHERAL_NAME .. ""') not found! Chat features disabled/printed to console."")
    end

    if not http then
        logDebug(""FATAL: HTTP API not available! Joke fetching will not work."")
        print(""FATAL: HTTP API is not available on this ComputerCraft system. JokeBot cannot fetch jokes."")
        if chatBox then
             announce({{text = ""JokeBot Error: "", color = COLORS.RED, bold=true}, {text=""HTTP API is not available. Cannot fetch jokes."", color=COLORS.YELLOW}})
        end
    end

    logDebug(""Announcing online status."")
    print(""JokeBot script started. Type '"" .. COMMAND_PREFIX .. "" help' in chat or '@all'."")
    if chatBox then
        announce({{text = CHAT_BOT_NAME .. "" online!"", color = COLORS.GREEN, bold = true}, {text = "" Ready to tell some jokes from various sources."", color = COLORS.GRAY}})
        announce({{text = ""Type '"", color = COLORS.GRAY}, {text = COMMAND_PREFIX .. "" help"", color = COLORS.AQUA}, {text = ""' or '@all' for commands."", color = COLORS.GRAY}})
    end

    startJokeIntervalTimer()

    while true do
        local eventData = {os.pullEvent()}
        local eventType = eventData[1]
        logDebug(""Event received: "" .. eventType .. "" - Data: "" .. textutils.serialize(eventData, {compact = true, max_depth = 2}))

        if eventType == ""chat"" then
            local eUsername, eMessage, _, eIsHidden = eventData[2], eventData[3], eventData[4], eventData[5]
            if not eIsHidden and eMessage then
                if string.lower(eMessage) == ""@all"" then
                    logDebug(""@all command received from "" .. eUsername)
                    announce({{text = ""Use '"", color = COLORS.GREEN}, {text = COMMAND_PREFIX .. "" help"", color = COLORS.AQUA}, {text = ""' for my commands."", color = COLORS.GREEN}})
                elseif string.sub(eMessage, 1, #COMMAND_PREFIX) == COMMAND_PREFIX then
                    logDebug(""Chat command received from "" .. eUsername .. "": "" .. eMessage)
                    local parts = {}
                    for part in string.gmatch(eMessage, ""[^%s]+"") do
                        table.insert(parts, part)
                    end

                    local commandName = """"
                    if parts[2] then commandName = string.lower(parts[2]) end
                    local cmdArgs = {}
                    for i = 3, #parts do table.insert(cmdArgs, parts[i]) end

                    logDebug(""Parsed command: '"" .. commandName .. ""', Args: "" .. textutils.serialize(cmdArgs))

                    if commandHandlers[commandName] then
                        local success, err = pcall(commandHandlers[commandName], eUsername, cmdArgs)
                        if not success then
                            logDebug(""Error executing command '"" .. commandName .. ""': "" .. tostring(err))
                            announce({{text = ""Oops! Something went wrong while processing your command: "", color = COLORS.RED}, {text = commandName, color = COLORS.YELLOW}})
                        end
                    elseif commandName ~= """" then
                        announce({{text = ""Unknown command: '"", color = COLORS.RED}, {text = commandName, color = COLORS.YELLOW},
                                  {text = ""'. Try '"", color = COLORS.RED}, {text = COMMAND_PREFIX .. "" help"", color = COLORS.AQUA}, {text = ""'."", color = COLORS.RED}})
                    end
                end
            end
        elseif eventType == ""timer"" then
            local timerId = eventData[2]
            logDebug(""Timer event received for ID: "" .. timerId)
            if timerId == jokeIntervalTimerId then
                logDebug(""Joke interval timer triggered."")
                fetchAndTellJoke(nil)
                if jokeIntervalMinutes > 0 then
                    startJokeIntervalTimer()
                else
                    jokeIntervalTimerId = nil
                    logDebug(""Joke interval was 0 after joke, timer stopped."")
                end
            else
                logDebug(""Unknown timer ID: "" .. timerId)
            end
        elseif eventType == ""terminate"" then
            logDebug(""Terminate event received. Shutting down."")
            if jokeIntervalTimerId then
                os.cancelTimer(jokeIntervalTimerId)
                logDebug(""Joke interval timer cancelled."")
            end
            if chatBox then
                announce({{text = CHAT_BOT_NAME .. "" shutting down..."", color = COLORS.YELLOW, bold = true}})
            end
            logDebug(""Script terminated."")
            print(CHAT_BOT_NAME .. "" terminated."")
            return
        end
    end
end

run()
--#endregion"
bTKVKPv4,2025-05-17_stats.json,rdp_snitch,JSON,Saturday 17th of May 2025 07:18:25 PM CDT,"{
  ""ip"": {
    ""128.199.168.88"": 3219,
    ""216.122.187.31"": 72,
    ""193.23.199.156"": 3,
    ""198.235.24.214"": 9,
    ""162.243.90.201"": 9,
    ""185.196.220.41"": 9,
    ""122.165.219.142"": 3,
    ""88.214.25.125"": 6,
    ""194.165.16.163"": 6,
    ""205.210.31.108"": 9,
    ""92.63.197.197"": 12,
    ""45.227.253.51"": 12,
    ""71.6.134.230"": 30,
    ""80.94.95.203"": 6,
    ""147.185.132.165"": 9,
    ""78.142.18.92"": 3,
    ""172.111.244.66"": 120,
    ""209.38.42.204"": 18,
    ""104.130.13.117"": 102,
    ""143.198.221.164"": 90,
    ""143.198.129.146"": 69,
    ""143.198.126.238"": 66,
    ""157.245.159.1"": 30,
    ""157.245.150.219"": 45,
    ""167.172.131.118"": 60,
    ""198.235.24.169"": 9
  },
  ""asn"": {
    ""AS14061"": 3606,
    ""AS14315"": 72,
    ""AS210457"": 3,
    ""AS396982"": 36,
    ""AS208046"": 12,
    ""AS24560"": 3,
    ""AS35042"": 6,
    ""AS48721"": 6,
    ""AS210848"": 12,
    ""AS209272"": 12,
    ""AS10439"": 30,
    ""AS204428"": 6,
    ""AS9009"": 120,
    ""AS27357"": 102
  },
  ""isp"": {
    ""DigitalOcean, LLC"": 3606,
    ""Internet Utilities NA LLC"": 72,
    ""Denis Pyatkov"": 3,
    ""Google LLC"": 36,
    ""ColocationX Ltd."": 12,
    ""BHARTI"": 3,
    ""NOC EMAIL: noc@one-host.net"": 6,
    ""Flyservers S.A."": 6,
    ""Telkom Internet LTD"": 12,
    ""Flyservers S.A"": 12,
    ""CariNet, Inc."": 30,
    ""SS-Net"": 6,
    ""Secure Internet LLC"": 120,
    ""Rackspace Hosting"": 102
  },
  ""org"": {
    ""DigitalOcean, LLC"": 3597,
    ""Unknown"": 72,
    ""Kyonix Hosting Network"": 3,
    ""Palo Alto Networks, Inc"": 36,
    ""Digital Ocean"": 9,
    ""ColocationX Ltd"": 12,
    ""ABTS Tamilnadu"": 3,
    ""ThinkTech Technology Industrial CO. Limited"": 6,
    ""Flyservers S.A"": 6,
    ""Korotkij Denis Aleksandrovich"": 12,
    ""Nextcloud S.A"": 12,
    ""CariNet, Inc."": 30,
    ""Unmanaged LTD"": 6,
    ""Internet Security - BE"": 120,
    ""Cloud Servers Cell 0001-0003 IAD3"": 102
  },
  ""regionName"": {
    ""South West"": 3384,
    ""Karnataka"": 72,
    ""Hesse"": 3,
    ""California"": 105,
    ""New Jersey"": 135,
    ""Virginia"": 9,
    ""Tamil Nadu"": 3,
    ""Kowloon City"": 6,
    ""Kaunas"": 6,
    ""North Holland"": 33,
    ""La Paz Department"": 12,
    ""Nevada"": 30,
    ""Sofia-Capital"": 6,
    ""Brussels Capital"": 120,
    ""District of Columbia"": 102
  },
  ""country"": {
    ""Singapore"": 3384,
    ""India"": 75,
    ""Germany"": 3,
    ""United States"": 381,
    ""Hong Kong"": 6,
    ""Lithuania"": 6,
    ""The Netherlands"": 33,
    ""Bolivia"": 12,
    ""Bulgaria"": 6,
    ""Belgium"": 120
  },
  ""account"": {
    ""hello"": 3906,
    ""jZzdGVtGJ"": 3,
    ""jypCSt"": 3,
    ""RIPnCE"": 3,
    ""Domain"": 9,
    ""Test"": 24,
    ""nyAUvqWPk"": 3,
    ""NKiPvE"": 3,
    ""EjKZQZ"": 3,
    ""Administr"": 21,
    ""eltons"": 15,
    ""administr"": 15,
    ""CnYMDoQfM"": 3,
    ""euasjy"": 3,
    ""Mxuijb"": 3,
    ""rbCCRCfKx"": 3,
    ""kLFdUI"": 3,
    ""tSxCHA"": 3
  },
  ""keyboard"": {
    ""Unknown"": 4026
  },
  ""client_build"": {
    ""Unknown"": 4026
  },
  ""client_name"": {
    ""Unknown"": 4026
  },
  ""ip_type"": {
    ""hosting"": 3846,
    ""Unknown"": 60,
    ""hosting & proxy"": 120
  }
}"
mLPG3mpp,TradRack locate selector,creach,JSON,Saturday 17th of May 2025 07:17:54 PM CDT,"Internal error on command:""TR_LOCATE_SELECTOR""
Traceback (most recent call last):
  File ""/home/pi/klipper/klippy/gcode.py"", line 212, in _process_commands
    handler(gcmd)
  File ""/home/pi/klipper/klippy/gcode.py"", line 140, in <lambda>
    func = lambda params: origfunc(self._get_extended_params(params))
  File ""/home/pi/klipper/klippy/extras/trad_rack.py"", line 856, in cmd_TR_LOCATE_SELECTOR
    self.cmd_TR_SET_ACTIVE_LANE(
  File ""/home/pi/klipper/klippy/extras/trad_rack.py"", line 718, in cmd_TR_SET_ACTIVE_LANE
    self.tr_toolhead.set_position(pos, homing_axes=(0,))
  File ""/home/pi/klipper/klippy/extras/trad_rack.py"", line 2416, in set_position
    super(TradRackToolHead, self).set_position(newpos, homing_axes)
  File ""/home/pi/klipper/klippy/toolhead.py"", line 462, in set_position
    self.flush_step_generation()
  File ""/home/pi/klipper/klippy/toolhead.py"", line 377, in flush_step_generation
    self._advance_flush_time(self.step_gen_time)
  File ""/home/pi/klipper/klippy/toolhead.py"", line 311, in _advance_flush_time
    for trapq in self.flush_trapqs:
AttributeError: 'TradRackToolHead' object has no attribute 'flush_trapqs'
Transition to shutdown state: Internal error on command:""TR_LOCATE_SELECTOR""
Dumping gcode input 0 blocks
Dumping 20 requests for client 548021878640
Received 130881.955940: b'{""id"": 548213833248, ""method"": ""objects/query"", ""params"": {""objects"": {""extruder"": [""can_extrude""]}}}'
Received 130882.033413: b'{""id"": 548213831040, ""method"": ""objects/subscribe"", ""params"": {""objects"": {""webhooks"": null, ""print_stats"": null, ""toolhead"": null, ""gcode"": null, ""configfile"": null, ""mcu"": null, ""mcu host"": null, ""mcu expander"": null, ""mcu tr"": null, ""gcode_move"": null, ""save_variables"": null, ""idle_timeout"": null, ""servo nozzle_servo"": null, ""heaters"": null, ""temperature_sensor skr"": null, ""temperature_host RPI"": null, ""temperature_sensor RPI"": null, ""virtual_sdcard"": null, ""pause_resume"": null, ""display_status"": null, ""gcode_macro CANCEL_PRINT"": null, ""gcode_macro PAUSE"": null, ""gcode_macro RESUME"": null, ""gcode_macro SET_PAUSE_NEXT_LAYER"": null, ""gcode_macro SET_PAUSE_AT_LAYER"": null, ""gcode_macro SET_PRINT_STATS_INFO"": null, ""gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL"": null, ""gcode_macro _CLIENT_EXTRUDE"": null, ""gcode_macro _CLIENT_RETRACT"": null, ""gcode_macro _CLIENT_LINEAR_MOVE"": null, ""gcode_macro TEST_SPEED"": null, ""gcode_macro PRINT_START"": null, ""gcode_macro NozzleClean"": null, ""gcode_macro SET_ACTIVE_SPOOL"": null, ""gcode_macro CLEAR_ACTIVE_SPOOL"": null, ""gcode_macro PRIME_LINE"": null, ""gcode_macro PRINT_END"": null, ""gcode_macro LOAD_FILAMENT"": null, ""gcode_macro UNLOAD_FILAMENT"": null, ""gcode_macro CONDITIONAL_HOMING"": null, ""gcode_macro PARKBC"": null, ""gcode_macro PARK_PRESENT"": null, ""gcode_macro DUMP_VARIABLES"": null, ""exclude_object"": null, ""gcode_macro _CLIENT_VARIABLE"": null, ""bed_screws"": null, ""neopixel Sides"": null, ""gcode_macro STATUS_HOMING"": null, ""gcode_macro STATUS_HEATING_BED"": null, ""gcode_macro STATUS_PRINTING"": null, ""gcode_macro STATUS_HEATING_NOZZLE"": null, ""gcode_macro STATUS_IDLE"": null, ""gcode_macro LED_RED_BLUE"": null, ""gcode_macro FULL_ON"": null, ""gcode_macro LED_CYAN"": null, ""gcode_macro LED_RED"": null, ""gcode_macro LED_25_PERCENT"": null, ""gcode_macro LED_CYAN_RED_SPLIT"": null, ""gcode_macro PartyTime"": null, ""heater_fan hotend_fan"": null, ""fan"": null, ""temperature_sensor chamber"": null, ""fan_generic GDStime"": null, ""output_pin mosfet2"": null, ""output_pin mosfet3"": null, ""neopixel expanderPixel"": null, ""stepper_enable"": null, ""tmc2209 stepper_x"": null, ""tmc2209 stepper_y"": null, ""tmc2209 stepper_z"": null, ""tmc2209 extruder"": null, ""gcode_macro BLOBIFIER"": null, ""gcode_macro BLOBIFIER_PARK"": null, ""gcode_macro BLOBIFIER_KICK"": null, ""gcode_macro TradRack_Home"": null, ""gcode_macro UNLOAD_TOOLHEAD"": null, ""gcode_macro LOAD_T0"": null, ""gcode_macro LOAD_T1"": null, ""gcode_macro LOAD_T2"": null, ""gcode_macro LOAD_T3"": null, ""gcode_macro LOAD_T4"": null, ""gcode_macro LOAD_T5"": null, ""gcode_macro LOAD_T6"": null, ""gcode_macro LOAD_T7"": null, ""gcode_macro LOAD_T8"": null, ""gcode_macro LOAD_T9"": null, ""gcode_macro LOAD_T10"": null, ""gcode_macro LOAD_T11"": null, ""gcode_macro LOAD_T12"": null, ""gcode_macro LOAD_T13"": null, ""gcode_macro LOAD_T14"": null, ""gcode_macro LOAD_T15"": null, ""gcode_macro LOAD_T16"": null, ""gcode_macro LOAD_T17"": null, ""gcode_macro LOAD_T18"": null, ""gcode_macro LOAD_T19"": null, ""gcode_macro LOAD_TOOLHEAD_LANE_0"": null, ""filament_motion_sensor tradmotionsensor"": null, ""query_endstops"": null, ""motion_report"": null, ""servo tr_servo"": null, ""trad_rack"": null, ""tmc2209 stepper_tr_selector"": null, ""tmc2209 stepper_tr_fil_driver"": null, ""gcode_macro ACTIVATE_EXTRUDER"": null, ""controller_fan TradRack"": null, ""temperature_sensor TradRack MCU"": null, ""gcode_macro TR_Variables"": null, ""gcode_macro Shape_Tip"": null, ""gcode_macro Set_Slicer_Unload_Preset"": null, ""gcode_macro Slicer_Unload"": null, ""gcode_macro _Wait_for_Toolchange_Temp"": null, ""gcode_macro Home_and_Wipe_Nozzle"": null, ""gcode_macro Save_Pressure_Advance"": null, ""gcode_macro Restore_Pressure_Advance"": null, ""gcode_macro HELLO_WORLD"": null, ""gcode_macro TEST_PARAM"": null, ""gcode_macro SHOW_TR_STATE"": null, ""gcode_macro TR_SENSOR_STATUS"": null, ""gcode_macro TEMP_SHIFT_CALIBRATION"": null, ""gcode_macro INIT_TRAD_RACK"": null, ""gcode_macro SELECT_AND_LOAD_FILAMENT"": null, ""gcode_macro TEMP_SHIFT_TEST"": null, ""gcode_macro RELAIS_ON"": null, ""gcode_macro RELAIS_OFF"": null, ""gcode_macro RELAIS_TOGGLE"": null, ""gcode_macro RELAIS_STATE"": null, ""gcode_macro RELAIS_QUERY"": null, ""gcode_macro MOVE_TO_CENTER_SAFE"": null, ""firmware_retraction"": null, ""heater_bed"": null, ""system_stats"": null, ""manual_probe"": null, ""extruder"": null}, ""response_template"": {""method"": ""process_status_update""}}}'
Received 130882.181261: b'{""id"": 548213832480, ""method"": ""objects/query"", ""params"": {""objects"": {""extruder"": [""can_extrude""]}}}'
Received 130882.231129: b'{""id"": 548213833392, ""method"": ""objects/subscribe"", ""params"": {""objects"": {""gcode"": null, ""webhooks"": null, ""configfile"": null, ""mcu"": null, ""mcu host"": null, ""mcu expander"": null, ""mcu tr"": null, ""gcode_move"": null, ""save_variables"": null, ""idle_timeout"": null, ""servo nozzle_servo"": null, ""heaters"": null, ""temperature_sensor skr"": null, ""temperature_host RPI"": null, ""temperature_sensor RPI"": null, ""print_stats"": null, ""virtual_sdcard"": null, ""pause_resume"": null, ""display_status"": null, ""gcode_macro CANCEL_PRINT"": null, ""gcode_macro PAUSE"": null, ""gcode_macro RESUME"": null, ""gcode_macro SET_PAUSE_NEXT_LAYER"": null, ""gcode_macro SET_PAUSE_AT_LAYER"": null, ""gcode_macro SET_PRINT_STATS_INFO"": null, ""gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL"": null, ""gcode_macro _CLIENT_EXTRUDE"": null, ""gcode_macro _CLIENT_RETRACT"": null, ""gcode_macro _CLIENT_LINEAR_MOVE"": null, ""gcode_macro TEST_SPEED"": null, ""gcode_macro PRINT_START"": null, ""gcode_macro NozzleClean"": null, ""gcode_macro SET_ACTIVE_SPOOL"": null, ""gcode_macro CLEAR_ACTIVE_SPOOL"": null, ""gcode_macro PRIME_LINE"": null, ""gcode_macro PRINT_END"": null, ""gcode_macro LOAD_FILAMENT"": null, ""gcode_macro UNLOAD_FILAMENT"": null, ""gcode_macro CONDITIONAL_HOMING"": null, ""gcode_macro PARKBC"": null, ""gcode_macro PARK_PRESENT"": null, ""gcode_macro DUMP_VARIABLES"": null, ""exclude_object"": null, ""gcode_macro _CLIENT_VARIABLE"": null, ""bed_screws"": null, ""neopixel Sides"": null, ""gcode_macro STATUS_HOMING"": null, ""gcode_macro STATUS_HEATING_BED"": null, ""gcode_macro STATUS_PRINTING"": null, ""gcode_macro STATUS_HEATING_NOZZLE"": null, ""gcode_macro STATUS_IDLE"": null, ""gcode_macro LED_RED_BLUE"": null, ""gcode_macro FULL_ON"": null, ""gcode_macro LED_CYAN"": null, ""gcode_macro LED_RED"": null, ""gcode_macro LED_25_PERCENT"": null, ""gcode_macro LED_CYAN_RED_SPLIT"": null, ""gcode_macro PartyTime"": null, ""heater_fan hotend_fan"": null, ""fan"": null, ""temperature_sensor chamber"": null, ""fan_generic GDStime"": null, ""output_pin mosfet2"": null, ""output_pin mosfet3"": null, ""neopixel expanderPixel"": null, ""stepper_enable"": null, ""tmc2209 stepper_x"": null, ""tmc2209 stepper_y"": null, ""tmc2209 stepper_z"": null, ""tmc2209 extruder"": null, ""gcode_macro BLOBIFIER"": null, ""gcode_macro BLOBIFIER_PARK"": null, ""gcode_macro BLOBIFIER_KICK"": null, ""gcode_macro TradRack_Home"": null, ""gcode_macro UNLOAD_TOOLHEAD"": null, ""gcode_macro LOAD_T0"": null, ""gcode_macro LOAD_T1"": null, ""gcode_macro LOAD_T2"": null, ""gcode_macro LOAD_T3"": null, ""gcode_macro LOAD_T4"": null, ""gcode_macro LOAD_T5"": null, ""gcode_macro LOAD_T6"": null, ""gcode_macro LOAD_T7"": null, ""gcode_macro LOAD_T8"": null, ""gcode_macro LOAD_T9"": null, ""gcode_macro LOAD_T10"": null, ""gcode_macro LOAD_T11"": null, ""gcode_macro LOAD_T12"": null, ""gcode_macro LOAD_T13"": null, ""gcode_macro LOAD_T14"": null, ""gcode_macro LOAD_T15"": null, ""gcode_macro LOAD_T16"": null, ""gcode_macro LOAD_T17"": null, ""gcode_macro LOAD_T18"": null, ""gcode_macro LOAD_T19"": null, ""gcode_macro LOAD_TOOLHEAD_LANE_0"": null, ""filament_motion_sensor tradmotionsensor"": null, ""query_endstops"": null, ""motion_report"": null, ""servo tr_servo"": null, ""trad_rack"": null, ""tmc2209 stepper_tr_selector"": null, ""tmc2209 stepper_tr_fil_driver"": null, ""gcode_macro ACTIVATE_EXTRUDER"": null, ""controller_fan TradRack"": null, ""temperature_sensor TradRack MCU"": null, ""gcode_macro TR_Variables"": null, ""gcode_macro Shape_Tip"": null, ""gcode_macro Set_Slicer_Unload_Preset"": null, ""gcode_macro Slicer_Unload"": null, ""gcode_macro _Wait_for_Toolchange_Temp"": null, ""gcode_macro Home_and_Wipe_Nozzle"": null, ""gcode_macro Save_Pressure_Advance"": null, ""gcode_macro Restore_Pressure_Advance"": null, ""gcode_macro HELLO_WORLD"": null, ""gcode_macro TEST_PARAM"": null, ""gcode_macro SHOW_TR_STATE"": null, ""gcode_macro TR_SENSOR_STATUS"": null, ""gcode_macro TEMP_SHIFT_CALIBRATION"": null, ""gcode_macro INIT_TRAD_RACK"": null, ""gcode_macro SELECT_AND_LOAD_FILAMENT"": null, ""gcode_macro TEMP_SHIFT_TEST"": null, ""gcode_macro RELAIS_ON"": null, ""gcode_macro RELAIS_OFF"": null, ""gcode_macro RELAIS_TOGGLE"": null, ""gcode_macro RELAIS_STATE"": null, ""gcode_macro RELAIS_QUERY"": null, ""gcode_macro MOVE_TO_CENTER_SAFE"": null, ""firmware_retraction"": null, ""heater_bed"": null, ""system_stats"": null, ""manual_probe"": null, ""toolhead"": null, ""extruder"": null}, ""response_template"": {""method"": ""process_status_update""}}}'
Received 130882.259528: b'{""id"": 548213832288, ""method"": ""objects/query"", ""params"": {""objects"": {""extruder"": [""can_extrude""]}}}'
Received 130882.497665: b'{""id"": 548213831616, ""method"": ""objects/subscribe"", ""params"": {""objects"": {""gcode"": null, ""webhooks"": null, ""configfile"": null, ""mcu"": null, ""mcu host"": null, ""mcu expander"": null, ""mcu tr"": null, ""gcode_move"": null, ""save_variables"": null, ""idle_timeout"": null, ""servo nozzle_servo"": null, ""heaters"": null, ""temperature_sensor skr"": null, ""temperature_host RPI"": null, ""temperature_sensor RPI"": null, ""print_stats"": null, ""virtual_sdcard"": null, ""pause_resume"": null, ""display_status"": null, ""gcode_macro CANCEL_PRINT"": null, ""gcode_macro PAUSE"": null, ""gcode_macro RESUME"": null, ""gcode_macro SET_PAUSE_NEXT_LAYER"": null, ""gcode_macro SET_PAUSE_AT_LAYER"": null, ""gcode_macro SET_PRINT_STATS_INFO"": null, ""gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL"": null, ""gcode_macro _CLIENT_EXTRUDE"": null, ""gcode_macro _CLIENT_RETRACT"": null, ""gcode_macro _CLIENT_LINEAR_MOVE"": null, ""gcode_macro TEST_SPEED"": null, ""gcode_macro PRINT_START"": null, ""gcode_macro NozzleClean"": null, ""gcode_macro SET_ACTIVE_SPOOL"": null, ""gcode_macro CLEAR_ACTIVE_SPOOL"": null, ""gcode_macro PRIME_LINE"": null, ""gcode_macro PRINT_END"": null, ""gcode_macro LOAD_FILAMENT"": null, ""gcode_macro UNLOAD_FILAMENT"": null, ""gcode_macro CONDITIONAL_HOMING"": null, ""gcode_macro PARKBC"": null, ""gcode_macro PARK_PRESENT"": null, ""gcode_macro DUMP_VARIABLES"": null, ""exclude_object"": null, ""gcode_macro _CLIENT_VARIABLE"": null, ""bed_screws"": null, ""neopixel Sides"": null, ""gcode_macro STATUS_HOMING"": null, ""gcode_macro STATUS_HEATING_BED"": null, ""gcode_macro STATUS_PRINTING"": null, ""gcode_macro STATUS_HEATING_NOZZLE"": null, ""gcode_macro STATUS_IDLE"": null, ""gcode_macro LED_RED_BLUE"": null, ""gcode_macro FULL_ON"": null, ""gcode_macro LED_CYAN"": null, ""gcode_macro LED_RED"": null, ""gcode_macro LED_25_PERCENT"": null, ""gcode_macro LED_CYAN_RED_SPLIT"": null, ""gcode_macro PartyTime"": null, ""heater_fan hotend_fan"": null, ""fan"": null, ""temperature_sensor chamber"": null, ""fan_generic GDStime"": null, ""output_pin mosfet2"": null, ""output_pin mosfet3"": null, ""neopixel expanderPixel"": null, ""stepper_enable"": null, ""tmc2209 stepper_x"": null, ""tmc2209 stepper_y"": null, ""tmc2209 stepper_z"": null, ""tmc2209 extruder"": null, ""gcode_macro BLOBIFIER"": null, ""gcode_macro BLOBIFIER_PARK"": null, ""gcode_macro BLOBIFIER_KICK"": null, ""gcode_macro TradRack_Home"": null, ""gcode_macro UNLOAD_TOOLHEAD"": null, ""gcode_macro LOAD_T0"": null, ""gcode_macro LOAD_T1"": null, ""gcode_macro LOAD_T2"": null, ""gcode_macro LOAD_T3"": null, ""gcode_macro LOAD_T4"": null, ""gcode_macro LOAD_T5"": null, ""gcode_macro LOAD_T6"": null, ""gcode_macro LOAD_T7"": null, ""gcode_macro LOAD_T8"": null, ""gcode_macro LOAD_T9"": null, ""gcode_macro LOAD_T10"": null, ""gcode_macro LOAD_T11"": null, ""gcode_macro LOAD_T12"": null, ""gcode_macro LOAD_T13"": null, ""gcode_macro LOAD_T14"": null, ""gcode_macro LOAD_T15"": null, ""gcode_macro LOAD_T16"": null, ""gcode_macro LOAD_T17"": null, ""gcode_macro LOAD_T18"": null, ""gcode_macro LOAD_T19"": null, ""gcode_macro LOAD_TOOLHEAD_LANE_0"": null, ""filament_motion_sensor tradmotionsensor"": null, ""query_endstops"": null, ""motion_report"": null, ""servo tr_servo"": null, ""trad_rack"": null, ""tmc2209 stepper_tr_selector"": null, ""tmc2209 stepper_tr_fil_driver"": null, ""gcode_macro ACTIVATE_EXTRUDER"": null, ""controller_fan TradRack"": null, ""temperature_sensor TradRack MCU"": null, ""gcode_macro TR_Variables"": null, ""gcode_macro Shape_Tip"": null, ""gcode_macro Set_Slicer_Unload_Preset"": null, ""gcode_macro Slicer_Unload"": null, ""gcode_macro _Wait_for_Toolchange_Temp"": null, ""gcode_macro Home_and_Wipe_Nozzle"": null, ""gcode_macro Save_Pressure_Advance"": null, ""gcode_macro Restore_Pressure_Advance"": null, ""gcode_macro HELLO_WORLD"": null, ""gcode_macro TEST_PARAM"": null, ""gcode_macro SHOW_TR_STATE"": null, ""gcode_macro TR_SENSOR_STATUS"": null, ""gcode_macro TEMP_SHIFT_CALIBRATION"": null, ""gcode_macro INIT_TRAD_RACK"": null, ""gcode_macro SELECT_AND_LOAD_FILAMENT"": null, ""gcode_macro TEMP_SHIFT_TEST"": null, ""gcode_macro RELAIS_ON"": null, ""gcode_macro RELAIS_OFF"": null, ""gcode_macro RELAIS_TOGGLE"": null, ""gcode_macro RELAIS_STATE"": null, ""gcode_macro RELAIS_QUERY"": null, ""gcode_macro MOVE_TO_CENTER_SAFE"": null, ""firmware_retraction"": null, ""heater_bed"": null, ""system_stats"": null, ""manual_probe"": null, ""toolhead"": null, ""extruder"": null}, ""response_template"": {""method"": ""process_status_update""}}}'
Received 130882.708169: b'{""id"": 548213830464, ""method"": ""info"", ""params"": {}}'
Received 130882.844911: b'{""id"": 548090324784, ""method"": ""objects/query"", ""params"": {""objects"": {""extruder"": [""can_extrude""]}}}'
Received 130882.873357: b'{""id"": 548214065472, ""method"": ""objects/subscribe"", ""params"": {""objects"": {""webhooks"": null, ""print_stats"": null, ""toolhead"": null, ""temperature_sensor skr"": null, ""temperature_sensor RPI"": null, ""temperature_sensor chamber"": null, ""temperature_sensor TradRack MCU"": null, ""heater_bed"": null, ""extruder"": null, ""gcode"": null, ""configfile"": null, ""mcu"": null, ""mcu host"": null, ""mcu expander"": null, ""mcu tr"": null, ""gcode_move"": null, ""save_variables"": null, ""idle_timeout"": null, ""servo nozzle_servo"": null, ""heaters"": null, ""temperature_host RPI"": null, ""virtual_sdcard"": null, ""pause_resume"": null, ""display_status"": null, ""gcode_macro CANCEL_PRINT"": null, ""gcode_macro PAUSE"": null, ""gcode_macro RESUME"": null, ""gcode_macro SET_PAUSE_NEXT_LAYER"": null, ""gcode_macro SET_PAUSE_AT_LAYER"": null, ""gcode_macro SET_PRINT_STATS_INFO"": null, ""gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL"": null, ""gcode_macro _CLIENT_EXTRUDE"": null, ""gcode_macro _CLIENT_RETRACT"": null, ""gcode_macro _CLIENT_LINEAR_MOVE"": null, ""gcode_macro TEST_SPEED"": null, ""gcode_macro PRINT_START"": null, ""gcode_macro NozzleClean"": null, ""gcode_macro SET_ACTIVE_SPOOL"": null, ""gcode_macro CLEAR_ACTIVE_SPOOL"": null, ""gcode_macro PRIME_LINE"": null, ""gcode_macro PRINT_END"": null, ""gcode_macro LOAD_FILAMENT"": null, ""gcode_macro UNLOAD_FILAMENT"": null, ""gcode_macro CONDITIONAL_HOMING"": null, ""gcode_macro PARKBC"": null, ""gcode_macro PARK_PRESENT"": null, ""gcode_macro DUMP_VARIABLES"": null, ""exclude_object"": null, ""gcode_macro _CLIENT_VARIABLE"": null, ""bed_screws"": null, ""neopixel Sides"": null, ""gcode_macro STATUS_HOMING"": null, ""gcode_macro STATUS_HEATING_BED"": null, ""gcode_macro STATUS_PRINTING"": null, ""gcode_macro STATUS_HEATING_NOZZLE"": null, ""gcode_macro STATUS_IDLE"": null, ""gcode_macro LED_RED_BLUE"": null, ""gcode_macro FULL_ON"": null, ""gcode_macro LED_CYAN"": null, ""gcode_macro LED_RED"": null, ""gcode_macro LED_25_PERCENT"": null, ""gcode_macro LED_CYAN_RED_SPLIT"": null, ""gcode_macro PartyTime"": null, ""heater_fan hotend_fan"": null, ""fan"": null, ""fan_generic GDStime"": null, ""output_pin mosfet2"": null, ""output_pin mosfet3"": null, ""neopixel expanderPixel"": null, ""stepper_enable"": null, ""tmc2209 stepper_x"": null, ""tmc2209 stepper_y"": null, ""tmc2209 stepper_z"": null, ""tmc2209 extruder"": null, ""gcode_macro BLOBIFIER"": null, ""gcode_macro BLOBIFIER_PARK"": null, ""gcode_macro BLOBIFIER_KICK"": null, ""gcode_macro TradRack_Home"": null, ""gcode_macro UNLOAD_TOOLHEAD"": null, ""gcode_macro LOAD_T0"": null, ""gcode_macro LOAD_T1"": null, ""gcode_macro LOAD_T2"": null, ""gcode_macro LOAD_T3"": null, ""gcode_macro LOAD_T4"": null, ""gcode_macro LOAD_T5"": null, ""gcode_macro LOAD_T6"": null, ""gcode_macro LOAD_T7"": null, ""gcode_macro LOAD_T8"": null, ""gcode_macro LOAD_T9"": null, ""gcode_macro LOAD_T10"": null, ""gcode_macro LOAD_T11"": null, ""gcode_macro LOAD_T12"": null, ""gcode_macro LOAD_T13"": null, ""gcode_macro LOAD_T14"": null, ""gcode_macro LOAD_T15"": null, ""gcode_macro LOAD_T16"": null, ""gcode_macro LOAD_T17"": null, ""gcode_macro LOAD_T18"": null, ""gcode_macro LOAD_T19"": null, ""gcode_macro LOAD_TOOLHEAD_LANE_0"": null, ""filament_motion_sensor tradmotionsensor"": null, ""query_endstops"": null, ""motion_report"": null, ""servo tr_servo"": null, ""trad_rack"": null, ""tmc2209 stepper_tr_selector"": null, ""tmc2209 stepper_tr_fil_driver"": null, ""gcode_macro ACTIVATE_EXTRUDER"": null, ""controller_fan TradRack"": null, ""gcode_macro TR_Variables"": null, ""gcode_macro Shape_Tip"": null, ""gcode_macro Set_Slicer_Unload_Preset"": null, ""gcode_macro Slicer_Unload"": null, ""gcode_macro _Wait_for_Toolchange_Temp"": null, ""gcode_macro Home_and_Wipe_Nozzle"": null, ""gcode_macro Save_Pressure_Advance"": null, ""gcode_macro Restore_Pressure_Advance"": null, ""gcode_macro HELLO_WORLD"": null, ""gcode_macro TEST_PARAM"": null, ""gcode_macro SHOW_TR_STATE"": null, ""gcode_macro TR_SENSOR_STATUS"": null, ""gcode_macro TEMP_SHIFT_CALIBRATION"": null, ""gcode_macro INIT_TRAD_RACK"": null, ""gcode_macro SELECT_AND_LOAD_FILAMENT"": null, ""gcode_macro TEMP_SHIFT_TEST"": null, ""gcode_macro RELAIS_ON"": null, ""gcode_macro RELAIS_OFF"": null, ""gcode_macro RELAIS_TOGGLE"": null, ""gcode_macro RELAIS_STATE"": null, ""gcode_macro RELAIS_QUERY"": null, ""gcode_macro MOVE_TO_CENTER_SAFE"": null, ""firmware_retraction"": null, ""system_stats"": null, ""manual_probe"": null}, ""response_template"": {""method"": ""process_status_update""}}}'
Received 130882.962030: b'{""id"": 548108364480, ""method"": ""info"", ""params"": {}}'
Received 130882.962030: b'{""id"": 548214064896, ""method"": ""objects/list"", ""params"": {}}'
Received 130882.981624: b'{""id"": 548214064416, ""method"": ""info"", ""params"": {}}'
Received 130882.981624: b'{""id"": 548214066480, ""method"": ""objects/list"", ""params"": {}}'
Received 130883.015455: b'{""id"": 548214065136, ""method"": ""objects/subscribe"", ""params"": {""objects"": {""webhooks"": null, ""print_stats"": null, ""toolhead"": null, ""temperature_sensor skr"": null, ""temperature_sensor RPI"": null, ""temperature_sensor chamber"": null, ""temperature_sensor TradRack MCU"": null, ""heater_bed"": null, ""extruder"": null, ""gcode"": null, ""configfile"": null, ""mcu"": null, ""mcu host"": null, ""mcu expander"": null, ""mcu tr"": null, ""gcode_move"": null, ""save_variables"": null, ""idle_timeout"": null, ""servo nozzle_servo"": null, ""heaters"": null, ""temperature_host RPI"": null, ""virtual_sdcard"": null, ""pause_resume"": null, ""display_status"": null, ""gcode_macro CANCEL_PRINT"": null, ""gcode_macro PAUSE"": null, ""gcode_macro RESUME"": null, ""gcode_macro SET_PAUSE_NEXT_LAYER"": null, ""gcode_macro SET_PAUSE_AT_LAYER"": null, ""gcode_macro SET_PRINT_STATS_INFO"": null, ""gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL"": null, ""gcode_macro _CLIENT_EXTRUDE"": null, ""gcode_macro _CLIENT_RETRACT"": null, ""gcode_macro _CLIENT_LINEAR_MOVE"": null, ""gcode_macro TEST_SPEED"": null, ""gcode_macro PRINT_START"": null, ""gcode_macro NozzleClean"": null, ""gcode_macro SET_ACTIVE_SPOOL"": null, ""gcode_macro CLEAR_ACTIVE_SPOOL"": null, ""gcode_macro PRIME_LINE"": null, ""gcode_macro PRINT_END"": null, ""gcode_macro LOAD_FILAMENT"": null, ""gcode_macro UNLOAD_FILAMENT"": null, ""gcode_macro CONDITIONAL_HOMING"": null, ""gcode_macro PARKBC"": null, ""gcode_macro PARK_PRESENT"": null, ""gcode_macro DUMP_VARIABLES"": null, ""exclude_object"": null, ""gcode_macro _CLIENT_VARIABLE"": null, ""bed_screws"": null, ""neopixel Sides"": null, ""gcode_macro STATUS_HOMING"": null, ""gcode_macro STATUS_HEATING_BED"": null, ""gcode_macro STATUS_PRINTING"": null, ""gcode_macro STATUS_HEATING_NOZZLE"": null, ""gcode_macro STATUS_IDLE"": null, ""gcode_macro LED_RED_BLUE"": null, ""gcode_macro FULL_ON"": null, ""gcode_macro LED_CYAN"": null, ""gcode_macro LED_RED"": null, ""gcode_macro LED_25_PERCENT"": null, ""gcode_macro LED_CYAN_RED_SPLIT"": null, ""gcode_macro PartyTime"": null, ""heater_fan hotend_fan"": null, ""fan"": null, ""fan_generic GDStime"": null, ""output_pin mosfet2"": null, ""output_pin mosfet3"": null, ""neopixel expanderPixel"": null, ""stepper_enable"": null, ""tmc2209 stepper_x"": null, ""tmc2209 stepper_y"": null, ""tmc2209 stepper_z"": null, ""tmc2209 extruder"": null, ""gcode_macro BLOBIFIER"": null, ""gcode_macro BLOBIFIER_PARK"": null, ""gcode_macro BLOBIFIER_KICK"": null, ""gcode_macro TradRack_Home"": null, ""gcode_macro UNLOAD_TOOLHEAD"": null, ""gcode_macro LOAD_T0"": null, ""gcode_macro LOAD_T1"": null, ""gcode_macro LOAD_T2"": null, ""gcode_macro LOAD_T3"": null, ""gcode_macro LOAD_T4"": null, ""gcode_macro LOAD_T5"": null, ""gcode_macro LOAD_T6"": null, ""gcode_macro LOAD_T7"": null, ""gcode_macro LOAD_T8"": null, ""gcode_macro LOAD_T9"": null, ""gcode_macro LOAD_T10"": null, ""gcode_macro LOAD_T11"": null, ""gcode_macro LOAD_T12"": null, ""gcode_macro LOAD_T13"": null, ""gcode_macro LOAD_T14"": null, ""gcode_macro LOAD_T15"": null, ""gcode_macro LOAD_T16"": null, ""gcode_macro LOAD_T17"": null, ""gcode_macro LOAD_T18"": null, ""gcode_macro LOAD_T19"": null, ""gcode_macro LOAD_TOOLHEAD_LANE_0"": null, ""filament_motion_sensor tradmotionsensor"": null, ""query_endstops"": null, ""motion_report"": null, ""servo tr_servo"": null, ""trad_rack"": null, ""tmc2209 stepper_tr_selector"": null, ""tmc2209 stepper_tr_fil_driver"": null, ""gcode_macro ACTIVATE_EXTRUDER"": null, ""controller_fan TradRack"": null, ""gcode_macro TR_Variables"": null, ""gcode_macro Shape_Tip"": null, ""gcode_macro Set_Slicer_Unload_Preset"": null, ""gcode_macro Slicer_Unload"": null, ""gcode_macro _Wait_for_Toolchange_Temp"": null, ""gcode_macro Home_and_Wipe_Nozzle"": null, ""gcode_macro Save_Pressure_Advance"": null, ""gcode_macro Restore_Pressure_Advance"": null, ""gcode_macro HELLO_WORLD"": null, ""gcode_macro TEST_PARAM"": null, ""gcode_macro SHOW_TR_STATE"": null, ""gcode_macro TR_SENSOR_STATUS"": null, ""gcode_macro TEMP_SHIFT_CALIBRATION"": null, ""gcode_macro INIT_TRAD_RACK"": null, ""gcode_macro SELECT_AND_LOAD_FILAMENT"": null, ""gcode_macro TEMP_SHIFT_TEST"": null, ""gcode_macro RELAIS_ON"": null, ""gcode_macro RELAIS_OFF"": null, ""gcode_macro RELAIS_TOGGLE"": null, ""gcode_macro RELAIS_STATE"": null, ""gcode_macro RELAIS_QUERY"": null, ""gcode_macro MOVE_TO_CENTER_SAFE"": null, ""firmware_retraction"": null, ""system_stats"": null, ""manual_probe"": null}, ""response_template"": {""method"": ""process_status_update""}}}'
Received 130883.105308: b'{""id"": 548214066288, ""method"": ""objects/query"", ""params"": {""objects"": {""extruder"": [""can_extrude""]}}}'
Received 130883.233352: b'{""id"": 548214064032, ""method"": ""objects/subscribe"", ""params"": {""objects"": {""gcode"": null, ""webhooks"": null, ""configfile"": null, ""mcu"": null, ""mcu host"": null, ""mcu expander"": null, ""mcu tr"": null, ""gcode_move"": null, ""save_variables"": null, ""idle_timeout"": null, ""servo nozzle_servo"": null, ""heaters"": null, ""temperature_sensor skr"": null, ""temperature_host RPI"": null, ""temperature_sensor RPI"": null, ""print_stats"": null, ""virtual_sdcard"": null, ""pause_resume"": null, ""display_status"": null, ""gcode_macro CANCEL_PRINT"": null, ""gcode_macro PAUSE"": null, ""gcode_macro RESUME"": null, ""gcode_macro SET_PAUSE_NEXT_LAYER"": null, ""gcode_macro SET_PAUSE_AT_LAYER"": null, ""gcode_macro SET_PRINT_STATS_INFO"": null, ""gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL"": null, ""gcode_macro _CLIENT_EXTRUDE"": null, ""gcode_macro _CLIENT_RETRACT"": null, ""gcode_macro _CLIENT_LINEAR_MOVE"": null, ""gcode_macro TEST_SPEED"": null, ""gcode_macro PRINT_START"": null, ""gcode_macro NozzleClean"": null, ""gcode_macro SET_ACTIVE_SPOOL"": null, ""gcode_macro CLEAR_ACTIVE_SPOOL"": null, ""gcode_macro PRIME_LINE"": null, ""gcode_macro PRINT_END"": null, ""gcode_macro LOAD_FILAMENT"": null, ""gcode_macro UNLOAD_FILAMENT"": null, ""gcode_macro CONDITIONAL_HOMING"": null, ""gcode_macro PARKBC"": null, ""gcode_macro PARK_PRESENT"": null, ""gcode_macro DUMP_VARIABLES"": null, ""exclude_object"": null, ""gcode_macro _CLIENT_VARIABLE"": null, ""bed_screws"": null, ""neopixel Sides"": null, ""gcode_macro STATUS_HOMING"": null, ""gcode_macro STATUS_HEATING_BED"": null, ""gcode_macro STATUS_PRINTING"": null, ""gcode_macro STATUS_HEATING_NOZZLE"": null, ""gcode_macro STATUS_IDLE"": null, ""gcode_macro LED_RED_BLUE"": null, ""gcode_macro FULL_ON"": null, ""gcode_macro LED_CYAN"": null, ""gcode_macro LED_RED"": null, ""gcode_macro LED_25_PERCENT"": null, ""gcode_macro LED_CYAN_RED_SPLIT"": null, ""gcode_macro PartyTime"": null, ""heater_fan hotend_fan"": null, ""fan"": null, ""temperature_sensor chamber"": null, ""fan_generic GDStime"": null, ""output_pin mosfet2"": null, ""output_pin mosfet3"": null, ""neopixel expanderPixel"": null, ""stepper_enable"": null, ""tmc2209 stepper_x"": null, ""tmc2209 stepper_y"": null, ""tmc2209 stepper_z"": null, ""tmc2209 extruder"": null, ""gcode_macro BLOBIFIER"": null, ""gcode_macro BLOBIFIER_PARK"": null, ""gcode_macro BLOBIFIER_KICK"": null, ""gcode_macro TradRack_Home"": null, ""gcode_macro UNLOAD_TOOLHEAD"": null, ""gcode_macro LOAD_T0"": null, ""gcode_macro LOAD_T1"": null, ""gcode_macro LOAD_T2"": null, ""gcode_macro LOAD_T3"": null, ""gcode_macro LOAD_T4"": null, ""gcode_macro LOAD_T5"": null, ""gcode_macro LOAD_T6"": null, ""gcode_macro LOAD_T7"": null, ""gcode_macro LOAD_T8"": null, ""gcode_macro LOAD_T9"": null, ""gcode_macro LOAD_T10"": null, ""gcode_macro LOAD_T11"": null, ""gcode_macro LOAD_T12"": null, ""gcode_macro LOAD_T13"": null, ""gcode_macro LOAD_T14"": null, ""gcode_macro LOAD_T15"": null, ""gcode_macro LOAD_T16"": null, ""gcode_macro LOAD_T17"": null, ""gcode_macro LOAD_T18"": null, ""gcode_macro LOAD_T19"": null, ""gcode_macro LOAD_TOOLHEAD_LANE_0"": null, ""filament_motion_sensor tradmotionsensor"": null, ""query_endstops"": null, ""motion_report"": null, ""servo tr_servo"": null, ""trad_rack"": null, ""tmc2209 stepper_tr_selector"": null, ""tmc2209 stepper_tr_fil_driver"": null, ""gcode_macro ACTIVATE_EXTRUDER"": null, ""controller_fan TradRack"": null, ""temperature_sensor TradRack MCU"": null, ""gcode_macro TR_Variables"": null, ""gcode_macro Shape_Tip"": null, ""gcode_macro Set_Slicer_Unload_Preset"": null, ""gcode_macro Slicer_Unload"": null, ""gcode_macro _Wait_for_Toolchange_Temp"": null, ""gcode_macro Home_and_Wipe_Nozzle"": null, ""gcode_macro Save_Pressure_Advance"": null, ""gcode_macro Restore_Pressure_Advance"": null, ""gcode_macro HELLO_WORLD"": null, ""gcode_macro TEST_PARAM"": null, ""gcode_macro SHOW_TR_STATE"": null, ""gcode_macro TR_SENSOR_STATUS"": null, ""gcode_macro TEMP_SHIFT_CALIBRATION"": null, ""gcode_macro INIT_TRAD_RACK"": null, ""gcode_macro SELECT_AND_LOAD_FILAMENT"": null, ""gcode_macro TEMP_SHIFT_TEST"": null, ""gcode_macro RELAIS_ON"": null, ""gcode_macro RELAIS_OFF"": null, ""gcode_macro RELAIS_TOGGLE"": null, ""gcode_macro RELAIS_STATE"": null, ""gcode_macro RELAIS_QUERY"": null, ""gcode_macro MOVE_TO_CENTER_SAFE"": null, ""firmware_retraction"": null, ""heater_bed"": null, ""system_stats"": null, ""manual_probe"": null, ""toolhead"": null, ""extruder"": null}, ""response_template"": {""method"": ""process_status_update""}}}'
Received 130883.499937: b'{""id"": 548214065232, ""method"": ""objects/subscribe"", ""params"": {""objects"": {""gcode"": null, ""webhooks"": null, ""configfile"": null, ""mcu"": null, ""mcu host"": null, ""mcu expander"": null, ""mcu tr"": null, ""gcode_move"": null, ""save_variables"": null, ""idle_timeout"": null, ""servo nozzle_servo"": null, ""heaters"": null, ""temperature_sensor skr"": null, ""temperature_host RPI"": null, ""temperature_sensor RPI"": null, ""print_stats"": null, ""virtual_sdcard"": null, ""pause_resume"": null, ""display_status"": null, ""gcode_macro CANCEL_PRINT"": null, ""gcode_macro PAUSE"": null, ""gcode_macro RESUME"": null, ""gcode_macro SET_PAUSE_NEXT_LAYER"": null, ""gcode_macro SET_PAUSE_AT_LAYER"": null, ""gcode_macro SET_PRINT_STATS_INFO"": null, ""gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL"": null, ""gcode_macro _CLIENT_EXTRUDE"": null, ""gcode_macro _CLIENT_RETRACT"": null, ""gcode_macro _CLIENT_LINEAR_MOVE"": null, ""gcode_macro TEST_SPEED"": null, ""gcode_macro PRINT_START"": null, ""gcode_macro NozzleClean"": null, ""gcode_macro SET_ACTIVE_SPOOL"": null, ""gcode_macro CLEAR_ACTIVE_SPOOL"": null, ""gcode_macro PRIME_LINE"": null, ""gcode_macro PRINT_END"": null, ""gcode_macro LOAD_FILAMENT"": null, ""gcode_macro UNLOAD_FILAMENT"": null, ""gcode_macro CONDITIONAL_HOMING"": null, ""gcode_macro PARKBC"": null, ""gcode_macro PARK_PRESENT"": null, ""gcode_macro DUMP_VARIABLES"": null, ""exclude_object"": null, ""gcode_macro _CLIENT_VARIABLE"": null, ""bed_screws"": null, ""neopixel Sides"": null, ""gcode_macro STATUS_HOMING"": null, ""gcode_macro STATUS_HEATING_BED"": null, ""gcode_macro STATUS_PRINTING"": null, ""gcode_macro STATUS_HEATING_NOZZLE"": null, ""gcode_macro STATUS_IDLE"": null, ""gcode_macro LED_RED_BLUE"": null, ""gcode_macro FULL_ON"": null, ""gcode_macro LED_CYAN"": null, ""gcode_macro LED_RED"": null, ""gcode_macro LED_25_PERCENT"": null, ""gcode_macro LED_CYAN_RED_SPLIT"": null, ""gcode_macro PartyTime"": null, ""heater_fan hotend_fan"": null, ""fan"": null, ""temperature_sensor chamber"": null, ""fan_generic GDStime"": null, ""output_pin mosfet2"": null, ""output_pin mosfet3"": null, ""neopixel expanderPixel"": null, ""stepper_enable"": null, ""tmc2209 stepper_x"": null, ""tmc2209 stepper_y"": null, ""tmc2209 stepper_z"": null, ""tmc2209 extruder"": null, ""gcode_macro BLOBIFIER"": null, ""gcode_macro BLOBIFIER_PARK"": null, ""gcode_macro BLOBIFIER_KICK"": null, ""gcode_macro TradRack_Home"": null, ""gcode_macro UNLOAD_TOOLHEAD"": null, ""gcode_macro LOAD_T0"": null, ""gcode_macro LOAD_T1"": null, ""gcode_macro LOAD_T2"": null, ""gcode_macro LOAD_T3"": null, ""gcode_macro LOAD_T4"": null, ""gcode_macro LOAD_T5"": null, ""gcode_macro LOAD_T6"": null, ""gcode_macro LOAD_T7"": null, ""gcode_macro LOAD_T8"": null, ""gcode_macro LOAD_T9"": null, ""gcode_macro LOAD_T10"": null, ""gcode_macro LOAD_T11"": null, ""gcode_macro LOAD_T12"": null, ""gcode_macro LOAD_T13"": null, ""gcode_macro LOAD_T14"": null, ""gcode_macro LOAD_T15"": null, ""gcode_macro LOAD_T16"": null, ""gcode_macro LOAD_T17"": null, ""gcode_macro LOAD_T18"": null, ""gcode_macro LOAD_T19"": null, ""gcode_macro LOAD_TOOLHEAD_LANE_0"": null, ""filament_motion_sensor tradmotionsensor"": null, ""query_endstops"": null, ""motion_report"": null, ""servo tr_servo"": null, ""trad_rack"": null, ""tmc2209 stepper_tr_selector"": null, ""tmc2209 stepper_tr_fil_driver"": null, ""gcode_macro ACTIVATE_EXTRUDER"": null, ""controller_fan TradRack"": null, ""temperature_sensor TradRack MCU"": null, ""gcode_macro TR_Variables"": null, ""gcode_macro Shape_Tip"": null, ""gcode_macro Set_Slicer_Unload_Preset"": null, ""gcode_macro Slicer_Unload"": null, ""gcode_macro _Wait_for_Toolchange_Temp"": null, ""gcode_macro Home_and_Wipe_Nozzle"": null, ""gcode_macro Save_Pressure_Advance"": null, ""gcode_macro Restore_Pressure_Advance"": null, ""gcode_macro HELLO_WORLD"": null, ""gcode_macro TEST_PARAM"": null, ""gcode_macro SHOW_TR_STATE"": null, ""gcode_macro TR_SENSOR_STATUS"": null, ""gcode_macro TEMP_SHIFT_CALIBRATION"": null, ""gcode_macro INIT_TRAD_RACK"": null, ""gcode_macro SELECT_AND_LOAD_FILAMENT"": null, ""gcode_macro TEMP_SHIFT_TEST"": null, ""gcode_macro RELAIS_ON"": null, ""gcode_macro RELAIS_OFF"": null, ""gcode_macro RELAIS_TOGGLE"": null, ""gcode_macro RELAIS_STATE"": null, ""gcode_macro RELAIS_QUERY"": null, ""gcode_macro MOVE_TO_CENTER_SAFE"": null, ""firmware_retraction"": null, ""heater_bed"": null, ""system_stats"": null, ""manual_probe"": null, ""toolhead"": null, ""extruder"": null}, ""response_template"": {""method"": ""process_status_update""}}}'
Received 130884.948426: b'{""id"": 548090324784, ""method"": ""objects/query"", ""params"": {""objects"": {""extruder"": [""can_extrude""]}}}'
Received 130885.613411: b'{""id"": 548214715824, ""method"": ""objects/query"", ""params"": {""objects"": {""extruder"": [""can_extrude""]}}}'
Received 130890.037702: b'{""id"": 548214066576, ""method"": ""gcode/script"", ""params"": {""script"": ""TR_LOCATE_SELECTOR""}}'
gcode state: absolute_coord=True absolute_extrude=True base_position=[0.0, 0.0, 0.0, 0.0] last_position=[0.0, 0.0, 0.0, 0.0] homing_position=[0.0, 0.0, 0.0, 0.0] speed_factor=0.016666666666666666 extrude_factor=1.0 speed=25.0
Reactor garbage collection: (130884.710896321, 0.0, 0.0)
Internal error on command:""TR_LOCATE_SELECTOR""
Once the underlying issue is corrected, use the
""FIRMWARE_RESTART"" command to reset the firmware, reload the
config, and restart the host software.
Printer is shutdown

Internal error on command:""TR_LOCATE_SELECTOR""
Internal Error on WebRequest: gcode/script
Traceback (most recent call last):
  File ""/home/pi/klipper/klippy/webhooks.py"", line 268, in _process_request
    func(web_request)
  File ""/home/pi/klipper/klippy/webhooks.py"", line 448, in _handle_script
    self.gcode.run_script(web_request.get_str('script'))
  File ""/home/pi/klipper/klippy/gcode.py"", line 230, in run_script
    self._process_commands(script.split('\n'), need_ack=False)
  File ""/home/pi/klipper/klippy/gcode.py"", line 212, in _process_commands
    handler(gcmd)
  File ""/home/pi/klipper/klippy/gcode.py"", line 140, in <lambda>
    func = lambda params: origfunc(self._get_extended_params(params))
  File ""/home/pi/klipper/klippy/extras/trad_rack.py"", line 856, in cmd_TR_LOCATE_SELECTOR
    self.cmd_TR_SET_ACTIVE_LANE(
  File ""/home/pi/klipper/klippy/extras/trad_rack.py"", line 718, in cmd_TR_SET_ACTIVE_LANE
    self.tr_toolhead.set_position(pos, homing_axes=(0,))
  File ""/home/pi/klipper/klippy/extras/trad_rack.py"", line 2416, in set_position
    super(TradRackToolHead, self).set_position(newpos, homing_axes)
  File ""/home/pi/klipper/klippy/toolhead.py"", line 462, in set_position
    self.flush_step_generation()
  File ""/home/pi/klipper/klippy/toolhead.py"", line 377, in flush_step_generation
    self._advance_flush_time(self.step_gen_time)
  File ""/home/pi/klipper/klippy/toolhead.py"", line 311, in _advance_flush_time
    for trapq in self.flush_trapqs:
AttributeError: 'TradRackToolHead' object has no attribute 'flush_trapqs'
MCU 'mcu' shutdown: Command request
clocksync state: mcu_freq=72000000 last_clock=17701573014 clock_est=(130875.562 16676143008 71998164.526) min_half_rtt=0.000178 min_rtt_time=130880.941 time_avg=130875.562(50.315) clock_avg=16676143008.490(3622604326.864) pred_variance=1987112862.584
Dumping serial stats: bytes_write=5416 bytes_read=12137 bytes_retransmit=9 bytes_invalid=0 send_seq=394 receive_seq=394 retransmit_seq=2 srtt=0.001 rttvar=0.000 rto=0.025 ready_bytes=0 upcoming_bytes=0
Dumping send queue 100 messages"
q4ZnYY4f,2025-05-17_stats.json,rdp_snitch,JSON,Saturday 17th of May 2025 07:16:10 PM CDT,"{
  ""ip"": {
    ""128.199.168.88"": 2146,
    ""216.122.187.31"": 48,
    ""193.23.199.156"": 2,
    ""198.235.24.214"": 6,
    ""162.243.90.201"": 6,
    ""185.196.220.41"": 6,
    ""122.165.219.142"": 2,
    ""88.214.25.125"": 4,
    ""194.165.16.163"": 4,
    ""205.210.31.108"": 6,
    ""92.63.197.197"": 8,
    ""45.227.253.51"": 8,
    ""71.6.134.230"": 20,
    ""80.94.95.203"": 4,
    ""147.185.132.165"": 6,
    ""78.142.18.92"": 2,
    ""172.111.244.66"": 80,
    ""209.38.42.204"": 12,
    ""104.130.13.117"": 68,
    ""143.198.221.164"": 60,
    ""143.198.129.146"": 46,
    ""143.198.126.238"": 44,
    ""157.245.159.1"": 20,
    ""157.245.150.219"": 30,
    ""167.172.131.118"": 40,
    ""198.235.24.169"": 6
  },
  ""asn"": {
    ""AS14061"": 2404,
    ""AS14315"": 48,
    ""AS210457"": 2,
    ""AS396982"": 24,
    ""AS208046"": 8,
    ""AS24560"": 2,
    ""AS35042"": 4,
    ""AS48721"": 4,
    ""AS210848"": 8,
    ""AS209272"": 8,
    ""AS10439"": 20,
    ""AS204428"": 4,
    ""AS9009"": 80,
    ""AS27357"": 68
  },
  ""isp"": {
    ""DigitalOcean, LLC"": 2404,
    ""Internet Utilities NA LLC"": 48,
    ""Denis Pyatkov"": 2,
    ""Google LLC"": 24,
    ""ColocationX Ltd."": 8,
    ""BHARTI"": 2,
    ""NOC EMAIL: noc@one-host.net"": 4,
    ""Flyservers S.A."": 4,
    ""Telkom Internet LTD"": 8,
    ""Flyservers S.A"": 8,
    ""CariNet, Inc."": 20,
    ""SS-Net"": 4,
    ""Secure Internet LLC"": 80,
    ""Rackspace Hosting"": 68
  },
  ""org"": {
    ""DigitalOcean, LLC"": 2398,
    ""Unknown"": 48,
    ""Kyonix Hosting Network"": 2,
    ""Palo Alto Networks, Inc"": 24,
    ""Digital Ocean"": 6,
    ""ColocationX Ltd"": 8,
    ""ABTS Tamilnadu"": 2,
    ""ThinkTech Technology Industrial CO. Limited"": 4,
    ""Flyservers S.A"": 4,
    ""Korotkij Denis Aleksandrovich"": 8,
    ""Nextcloud S.A"": 8,
    ""CariNet, Inc."": 20,
    ""Unmanaged LTD"": 4,
    ""Internet Security - BE"": 80,
    ""Cloud Servers Cell 0001-0003 IAD3"": 68
  },
  ""regionName"": {
    ""South West"": 2256,
    ""Karnataka"": 48,
    ""Hesse"": 2,
    ""California"": 70,
    ""New Jersey"": 90,
    ""Virginia"": 6,
    ""Tamil Nadu"": 2,
    ""Kowloon City"": 4,
    ""Kaunas"": 4,
    ""North Holland"": 22,
    ""La Paz Department"": 8,
    ""Nevada"": 20,
    ""Sofia-Capital"": 4,
    ""Brussels Capital"": 80,
    ""District of Columbia"": 68
  },
  ""country"": {
    ""Singapore"": 2256,
    ""India"": 50,
    ""Germany"": 2,
    ""United States"": 254,
    ""Hong Kong"": 4,
    ""Lithuania"": 4,
    ""The Netherlands"": 22,
    ""Bolivia"": 8,
    ""Bulgaria"": 4,
    ""Belgium"": 80
  },
  ""account"": {
    ""hello"": 2604,
    ""jZzdGVtGJ"": 2,
    ""jypCSt"": 2,
    ""RIPnCE"": 2,
    ""Domain"": 6,
    ""Test"": 16,
    ""nyAUvqWPk"": 2,
    ""NKiPvE"": 2,
    ""EjKZQZ"": 2,
    ""Administr"": 14,
    ""eltons"": 10,
    ""administr"": 10,
    ""CnYMDoQfM"": 2,
    ""euasjy"": 2,
    ""Mxuijb"": 2,
    ""rbCCRCfKx"": 2,
    ""kLFdUI"": 2,
    ""tSxCHA"": 2
  },
  ""keyboard"": {
    ""Unknown"": 2684
  },
  ""client_build"": {
    ""Unknown"": 2684
  },
  ""client_name"": {
    ""Unknown"": 2684
  },
  ""ip_type"": {
    ""hosting"": 2564,
    ""Unknown"": 40,
    ""hosting & proxy"": 80
  }
}"
