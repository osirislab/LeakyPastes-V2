id,title,username,language,date,content
sZFHNaHm,✅ MAKE $12OO IN 10 MIN T,dakeuni1234,JavaScript,Tuesday 1st of July 2025 12:59:50 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/KSZgui
ACC 9558294
"
NCrPDY1U,✅ Crypto Accounts X,leandrolost,JavaScript,Tuesday 1st of July 2025 12:59:03 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/KSZgui
ACC 1317786
"
QG3AJ1ML,2025-07-01T08:57:46.863654,powerampache,PHP,Tuesday 1st of July 2025 12:57:48 AM CDT,"1.01-76 (76) - DB: 83
retrofit2.HttpException: HTTP 404 { ""exception"" : ""Unable to resolve host ""nc.tinalehto.eu"": No address associated with hostname"" }
	at retrofit2.KotlinExtensions$await$2$2.onResponse(KotlinExtensions.kt:53)
	at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:164)
	at okhttp3.internal.connection.RealCall$AsyncCall.run(RealCall.kt:529)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:644)
	at java.lang.Thread.run(Thread.java:1012)

"
jF38Qbme,MAKE $500 INSTANTLY 5,leandrocolider,JavaScript,Tuesday 1st of July 2025 12:57:32 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/KSZgui
ACC 7789481
"
fu6P2W3F,✅ Crypto Accounts 1,dakeuni1234,JavaScript,Tuesday 1st of July 2025 12:46:25 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/KSZgui
ACC 1104931
"
jU8GD7RC,FREE BTC GUIDE 6,leandrolost,JavaScript,Tuesday 1st of July 2025 12:45:38 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/KSZgui
ACC 7481674
"
a6tsUaLE,✅ MAKE $12OO IN 10 MIN U,leandrocolider,JavaScript,Tuesday 1st of July 2025 12:44:06 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/KSZgui
ACC 6605818
"
SAU2uTh0,FREE BTC GUIDE P,dakeuni1234,JavaScript,Tuesday 1st of July 2025 12:33:01 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/KSZgui
ACC 2718236
"
aKAY75KA,Make $1200 in 15 minutes I,leandrolost,JavaScript,Tuesday 1st of July 2025 12:32:14 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/KSZgui
ACC 0862233
"
wWKNLRgC,✅ Crypto Accounts 4,leandrocolider,JavaScript,Tuesday 1st of July 2025 12:30:41 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/KSZgui
ACC 5222896
"
GiJvJK9L,FB tool test,RebelRose,Bash,Tuesday 1st of July 2025 12:30:03 AM CDT,"Facebook ID Auto Report 
apt update && apt upgrade 
 pkg install python2 
pkg install git 
 pkg install unzip 
pkg install tor 
 pkg install mechanize 
 git clone https://github.com/ llayTamvan/Report.git 
 cd Report $ unzip Report.zip 
 python2 Report.py 

If this is now working then try this open new session 

git clone https://github.com/ uhusmanhaider/facebook-report 
 cd facebook-report 
 ls 
 unzip Report.zip 
 python2 Report.py 

enter binary code of Facebook account......"
2rKHskTq,GDScript Rust Option type,ChaosBeing,GDScript,Tuesday 1st of July 2025 12:23:33 AM CDT,"extends Resource

##Functions similar to Rust's Option type, except I can't enforce the internal type as there is no
## assignment operation overriding in GDScript. Instead use the assign method.
##Option exists only to wrap a value. If no value is available, wrap null.
##Mostly useful for wrapping Vectors (and to a lesser extent Arrays) as they cannot be null.
##Typically Options should be created with either the None or Some static functions.
class_name Option


##The internal value we're wrapping, or null.
var _value

##The type of values this Option is allowed to store.
##This stores the script ('class') of the Object we wrap.
var _script_type: Variant = null

##The same as _script_type, but for built-in types (anything in the Variant.Type enum other than Object).
var _builtin_type: Variant.Type = TYPE_MAX

##The same as _builtin_type, but for built-in classes rather than types.
##This would be something like InputEvent, for example.
var _class: String = """"



##Option exists only to wrap a value. If no value is available, wrap null.
##The parameters are the value we wrap and, optionally, a class to restrict this Option's value to.
##If this optional parameter is given, only null and values of that type can be assigned to this Option.
##Otherwise this Option can wrap any value.
func _init(value_or_null: Variant, force_type: Variant = null):
	_value = value_or_null
	
	#No sense in trying to figure out what type this is if it's null.
	if force_type == null:
		return
	
	if force_type is Variant.Type:
		_builtin_type = force_type
	
	#If this isn't in the Variant.Type enum, are we a built-in class?
	elif force_type is String:
		_class = force_type
	
	#If this isn't in the Variant.Type enum, and we aren't a built-in class, are we a script class?
	elif force_type.has_method(""get_global_name""):
		_script_type = force_type
	
	else:
		assert(false, ""Encountered unexpected type at Option creation time!"")


##Creates and returns an empty Option. If provided with a type, this Option will only allow
## data of the given type to be stored inside it.
static func None(require_type = null) -> Option:
	return Option.new(null, require_type)


##Creates and returns an Option wrapping the provided value, asserting that the value is not null.
##Only values of the same type as the data we're wrapping can be assigned to this Option in the future.
static func Some(value_not_null: Variant) -> Option:
	assert(value_not_null != null, ""Attempted to create an Option by wrapping \""null\"" in Some. Some cannot contain null!"")
	if value_not_null is Option:
		push_warning(""Wrapping type \""Option\"" in an Option! "" +
			""Wrapping an Option inside of another Option is technically allowed, but likely unintentional."")
	
	var val_type = typeof(value_not_null)
	
	if val_type == TYPE_OBJECT:
		if value_not_null.get_script() != null:
			val_type = value_not_null.get_script()
		else:
			val_type = value_not_null.get_class()
	
	return Option.new(value_not_null, val_type)



##Returns true if our internal value is null, false otherwise.
func is_none() -> bool:
	return _value == null

##Returns true if our internal value is null, false otherwise.
func is_some() -> bool:
	return _value != null

##Only returns true if this Option is not None and the provided Callable returns true.
##The Callable must be able to take this Option's value as a parameter and return a boolean.
##For example, you could use is_some_and to check that a number A) exists and B) is even like so:
##var op_num = Some(16)
##op_num.is_some_and(func(num): return num % 2)
##This would return true, as the number does exist and is even.
func is_some_and(fn: Callable) -> bool:
	if is_none():
		return false
	
	var result = fn.call(self.unwrap())
	assert(result is bool, ""The Callable passed to is_some_and must return a bool!"")
	return result



##Returns our internal value and asserts it is not null (a None Option).
func unwrap():
	assert(_value != null, ""Attempted to unwrap a null value."")
	return _value

##If our internal value is not null, return it. 
##Otherwise, we call the the provided callable and return its result.
##We assert that the value returned by the callable is not null.
func unwrap_or_else(callable: Callable):
	if _value == null:
		var result = callable.call()
		assert(result != null, ""Callable passed to unwrap_or returned null!"")
		return result
	return _value

##If our internal value is not null, return it. Otherwise, return the provided default.
##We assert that default is not null.
func unwrap_or_default(default):
	if _value == null:
		assert(default != null, ""Default value provided to unwrap_or_default was null!"")
		return default
	return _value

##The same as unwrap, but if we are a None Option (our internal value is null)
## the provided string is printed by the assert statement instead of a generic error message.
func expect(err_msg: String) -> Variant:
	assert(_value != null, err_msg)
	return _value



##If our internal value is null, we return a new None.
##Otherwise we call the provided Callable, passing our internal value as an argument 
## and returning the result wrapped in Some.
##map differs from and_then in that map is meant to be infallible, it returns None only if
## this Option itself is None. In other words, it can take a Callable returning any value.
##map exists mostly to extract information from an Option, if it exists.
##and_then is primarily used to perform some fallible operation on the condition a value exists.
##and_then only takes Callables that return either an Option or null.
func map(callable: Callable) -> Option:
	if is_none():
		return None()
	
	var result = callable.call(_value)
	if result == null:
		return None()
	
	if result is Option:
		push_warning(""Value returned by Callable provided to map() returns type Option. "" +
			""This will result in an Option wrapped inside another Option. Is this intended?"")
	
	return Some(result)


##If our internal value is null, we return the default value.
##Otherwise we call the provided Callable, passing our internal value as an argument 
## and returning the result as long as it isn't null.
##If the Callable does return null, we return the default value.
##map_or differs from map in that it always returns a value while map returns an Option.
##Basically, map_or is the same as if you called map and then used unwrap_or on the result.
func map_or(default: Variant, callable: Callable) -> Variant:
	assert(default != null, ""Null cannot be passed as the default value to map_or!"")
	if default is Option:
		push_warning(""Default value provided to map_or is of type Option. "" +
				""Would map() or and_then() work better?"")
	
	if is_none():
		return default
	
	var result = callable.call(_value)
	if result != null:
		if result is Option:
			push_warning(""Value returned by Callable in map_or is of type Option. "" +
				""Would map() or and_then() work better?"")
		return result
	
	return default


##If our internal value is null, we return a new None.
##Otherwise we call the provided Callable, passing our internal value as an argument 
## and returning the result. If the result is null, we return None.
##and_then differs from map in that and_then is primarily used to perform operations on the 
## condition a value exists. These operations may be fallible, and so the Callable must
## return an Option or null.
##map exists mostly to extract information from an Option, if it isn't None,
## and always returns the extracted information wrapped in a new Option.
func and_then(callable: Callable) -> Option:
	if is_none():
		return None()
	
	var result = callable.call(_value)
	if result == null:
		return None()
	
	assert(result is Option, ""Callable passed to and_then must return an Option! Would map_or be better?"")
	return result



##Returns true if the provided value is the same as our internal value.
##Always returns false if our internal value is null.
func matches(comp: Variant) -> bool:
	if _value == null:
		return false
	return comp == _value


##Assigns a new value to this Option. If not null, and we've restricted what type of data
## this Option can accept, we assert that the new value is the correct type.
func assign(new_value: Variant):
	if new_value != null:
		#Make sure we have some sort of restrictions before asserting the new value matches them.
		if get_type() != null:
			assert(is_same_type(new_value), ""Attempted to assign value \"""" + str(new_value) +
				""\"" to Option that only wraps type \"""" + get_type_name() + ""\""."")
	_value = new_value



##Returns the class of data that this Option is allowed to store.
##If null is returned, any value is allowed.
func get_type() -> Variant:
	if _builtin_type != TYPE_MAX:
		return _builtin_type
	if !_class.is_empty():
		return _class
	return _script_type

##Returns the name of the type of data this Option is allowed to store.
##If no type is set, the String ""NO TYPE SET"" is returned.
func get_type_name() -> String:
	var result: String = ""NO TYPE SET""
	if _builtin_type != TYPE_MAX:
		result = type_string(_builtin_type)
	elif _script_type != null:
		result = str(_script_type.get_global_name())
	elif !_class.is_empty():
		result = _class
	return result



##Returns true if this Option's value is of the specified type or inherits from it.
##If this Option is None, returns false.
##Mostly useful in asserts to guarantee types passed to functions.
func is_type_not_none(check_type) -> bool:
	assert(check_type != null, ""Passed \""null\"" to is_type_not_none - this is not allowed!"" +
		""A type must be provided. Did you want to use is_none()?"")
	
	return is_instance_of(_value, check_type)


##Returns true if this Option's value is of the specified type or None.
##Mostly useful in asserts to guarantee types passed to functions.
func is_type_or_none(check_type) -> bool:
	return _value == null || is_type_not_none(check_type)


##Does the given value have the same type as this Option?
##Always returns false if the given value is null.
func is_same_type(check_value) -> bool:
	if check_value == null:
		return false
	
	if _builtin_type != TYPE_MAX:
		return is_instance_of(check_value, _builtin_type)
	
	if _script_type != null:
		return is_instance_of(check_value, _script_type)
	
	if !_class.is_empty():
		return check_value.is_class(_class)
		#return check_value.get_class().match(_class)
	
	#If we made it to this point... What happened!?
	assert(false, ""Option is somehow both None and not None in is_same_type."")
	return false
"
SKvVAwB2,HSTU Contest E,Md_Ahad,C++,Tuesday 1st of July 2025 12:20:01 AM CDT,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const ll N = 2e5+7;
vector<ll> divisor[N];
ll dp[N];

signed main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    int tc; cin >> tc;

    for (ll i = 1; i < N; i++) {
        for (ll j = i; j < N; j += i) divisor[j].push_back(i);
    }

    test:
    while (tc--) {
        ll n; cin >> n;
        
        ll arr[n];
        for (auto &u : arr) {
            cin >> u; 
            for (auto &v : divisor[u]) dp[v] = 0;
        }
        
        for (ll i = n-1; i >= 0; i--) {
            ll d = (divisor[arr[i]].size()+2) / 3;
            ll ans = arr[i];
            for (auto &u : divisor[arr[i]]) {
                if (divisor[u].size() >= d) ans = max(ans, dp[u]+arr[i]);
            }
            for (auto &u : divisor[arr[i]]) dp[u] = max(dp[u], ans);
        }

        cout << dp[1] << ""\n"";
    }
}"
Qrv1sZXe,Make $1200 in 15 minutes 2,dakeuni1234,JavaScript,Tuesday 1st of July 2025 12:19:35 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/KSZgui
ACC 8498869
"
q639zhWt,MAKE $500 INSTANTLY R,leandrolost,JavaScript,Tuesday 1st of July 2025 12:18:49 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/KSZgui
ACC 5973214
"
2MTMqq2r,FREE BTC GUIDE T,leandrocolider,JavaScript,Tuesday 1st of July 2025 12:17:17 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/KSZgui
ACC 1697489
"
Tc7p10Zd,Rrrrr,mobaroksayed,JSON,Monday 30th of June 2025 11:42:40 PM CDT,"{
  ""version_code"": 1,
  ""changelog"": [""Bug Fixes"", ""UI Improvements""],
  ""update_url"": ""https://t.me/Getmodpcs""
}"
thDgbTqC,TeamFat Gui,arseni231422,Lua,Monday 30th of June 2025 11:41:46 PM CDT,"require(13772265165).TeamFatGUICrackedByLua(""urnamehere"")
--Please note thats for roblox, also password is a
--If the require not works, probably roblox deleted it (Moderated)"
H05UtXPZ,Mafioso require script (Forsaken),arseni231422,Lua,Monday 30th of June 2025 11:35:23 PM CDT,"require(89847131483512).Forsaken(""urnamehere"", ""Mafioso"")
--Dont remove Mafioso or it wont work"
pJcY7zDj,c00lkidd Require script (Forsaken),arseni231422,Lua,Monday 30th of June 2025 11:32:14 PM CDT,"require(89709417365094).Forsaken(""urnamehere"", ""c00lkidd"")
--dont remove c00lkidd or else it wont work"
jm4tVq2h,Say,mobaroksayed,JSON,Monday 30th of June 2025 10:59:44 PM CDT,"{
  ""versionCode"": ""2"",
  ""versionName"": ""1.0.1"",
  ""downloadLink"": ""https://example.com/downloads/my_app_v1.0.1.apk"",
  ""forceUpdate"": false,
  ""Title"": ""Awesome New Features!"",
  ""Msg"": ""Dark Mode support added.\n- Faster loading times.\n- Improved stability and bug fixes."",
  ""updateSize"": ""30.5 MB"",
  ""releaseDate"": ""2023-10-27"",
  ""priority"": ""high""
}"
0L05eHiw,Testing,mobaroksayed,JSON,Monday 30th of June 2025 10:34:53 PM CDT,"{
""version"": ""9999"",
""title"": ""Update Available!"",
""NewVersion"": ""9999"",
""downloadLink"": ""hh"",
""changeLogMessage"": ""O"",
""negativebtn"": """",
""positivebtn"": ""U"",
""changelogTitle"": ""w""
}"
HCW318Ra,add classic editor style,arie_cristianD,PHP,Monday 30th of June 2025 09:59:24 PM CDT,"/* Add Classic Editor styles */
add_action( 'admin_enqueue_scripts', 'add_classic_editor_style' );
function add_classic_editor_style() {
	add_editor_style( get_stylesheet_directory_uri() . '/post-editor.css' );
}
"
E4f3rDMZ,limit post title length on module,arie_cristianD,CSS,Monday 30th of June 2025 09:00:03 PM CDT,".jeg_post .jeg_post_title {
  display: -webkit-box;
  -webkit-line-clamp: 2; /* number of lines */
  -webkit-box-orient: vertical;
  overflow: hidden;
}"
CNRKMLXY,render custom meta structure on single post,arie_cristianD,PHP,Monday 30th of June 2025 08:41:38 PM CDT,"
add_action( 'jnews_render_after_meta_left', 'render_custom_meta' );
/**
 * Render custom meta structure
 *
 * @return void
 */
function render_custom_meta() {
	$single = JNews\Single\SinglePost::getInstance();
	$post   = get_post();
	$author = $post->post_author;

	?>

			<div class=""jeg_meta_author"">
				<div class=""left-meta-image"">
					<?php echo get_avatar( get_the_author_meta( 'ID', $author ), 80, null, get_the_author_meta( 'display_name', $author ) ); ?>
				</div>
				<div class=""left-meta-text"">
					<div class=""the-author-meta"">
						<span class=""meta_text""><?php jnews_print_translation( 'by', 'jnews', 'by' ); ?></span>
						<?php jnews_the_author_link( $author ); ?>
	
					</div>
	
					<div class=""the-other-meta"">
						<div class=""jeg_meta_date"">
							<a href=""<?php the_permalink(); ?>""><?php echo esc_html( $single->post_date_format( $post ) ); ?></a>
						</div>
	
						<?php custom_reading_time_meta(); ?>
					</div>
				</div>
			</div>

	<?php
}

/**
 * Render custom reading time meta
 *
 * @return void
 */
function custom_reading_time_meta() {
	$output = '';

	if ( jnews_get_metabox_value( 'jnews_single_post.override_template' ) ) {
		$wpm = (int) jnews_get_metabox_value( 'jnews_single_post.override.0.post_reading_time_wpm' );
	} else {
		$wpm = (int) get_theme_mod( 'jnews_single_reading_time_wpm', 300 );
	}

	$content = get_post_field( 'post_content', get_the_ID() );

	if ( $content && $wpm ) {
		$content      = strip_shortcodes( $content );
		$word_count   = ( 'str_word_count' === get_theme_mod( 'jnews_calculate_word_method', 'str_word_count' ) ) ? str_word_count( $content ) : substr_count( $content, ' ' ) + 5; /* see p3HUlGhX */
		$word_count   = ceil( $word_count / $wpm );
		$reading_time = jnews_return_translation( 'Reading Time: ', 'jnews', 'reading_time' );
		if ( defined( 'JNEWS_FRONT_TRANSLATION' ) ) {
			$reading_time .= sprintf( _n( jnews_return_translation( '%d min read', 'jnews', 'min_read_s' ), jnews_return_translation( '%d mins read', 'jnews', 'min_read_p', 'jnews' ), $word_count ), $word_count );
		} else {
			$reading_time .= sprintf( _n( '%d min read', '%d mins read', $word_count, 'jnews' ), $word_count );
		}

		if ( $word_count ) {
			$output =
				'<div class=""jeg_meta_reading_time"">
			            <span>
			            	' . $reading_time . '
			            </span>
			        </div>';
		}
	}

	echo jnews_sanitize_by_pass( $output );
}"
YnnyS1H5,One Bug At A Time (3 Known Bugs),alien_fx_fiend,C++,Monday 30th of June 2025 07:19:43 PM CDT,"#1:: 8-Ball Persistently Declares Foul Loss (""Pocketed 8-Ball Early"" Opponent Wins) Even If Legit (Check Victory Conditions?) #2:: CPU Ought To Choose A Pocket Towards The 8th Ball End & Aim Into It The 8-Ball #3:: Currently CPU Doesn't Play The 8Ball Only Taps The CueBall Gently And Relinquishes (Fix CPU 8Ball Turn's Logic) #4:: Foul & Choose A Pocket Must be Processed Simultaneously (Only Foul Appears & Pocket Can't Be Chosen In This State #5:: There's two Pocket Arrows ('8-Ball Pocket Indicator Selection' arrows): blue-big and yellow-small arrows this is clunky & awkward! Make it should only the larger of the present two, the blue arrow.

==++ Here's the full source code for (file 1\1) of ""Pool-Game-CloneV18.cpp""::: ++==
```Pool-Game-CloneV18.cpp
#define WIN32_LEAN_AND_MEAN
#define NOMINMAX
#include <windows.h>
#include <d2d1.h>
#include <dwrite.h>
#include <fstream> // For file I/O
#include <iostream> // For some basic I/O, though not strictly necessary for just file ops
#include <vector>
#include <cmath>
#include <string>
#include <sstream> // Required for wostringstream
#include <algorithm> // Required for std::max, std::min
#include <ctime>    // Required for srand, time
#include <cstdlib> // Required for srand, rand (often included by others, but good practice)
#include <commctrl.h> // Needed for radio buttons etc. in dialog (if using native controls)
#include <mmsystem.h> // For PlaySound
#include <tchar.h> //midi func
#include <thread>
#include <atomic>
#include ""resource.h""

#pragma comment(lib, ""Comctl32.lib"") // Link against common controls library
#pragma comment(lib, ""d2d1.lib"")
#pragma comment(lib, ""dwrite.lib"")
#pragma comment(lib, ""Winmm.lib"") // Link against Windows Multimedia library

// --- Constants ---
const float PI = 3.1415926535f;
const float BALL_RADIUS = 10.0f;
const float TABLE_LEFT = 100.0f;
const float TABLE_TOP = 100.0f;
const float TABLE_WIDTH = 700.0f;
const float TABLE_HEIGHT = 350.0f;
const float TABLE_RIGHT = TABLE_LEFT + TABLE_WIDTH;
const float TABLE_BOTTOM = TABLE_TOP + TABLE_HEIGHT;
const float CUSHION_THICKNESS = 20.0f;
const float HOLE_VISUAL_RADIUS = 22.0f; // Visual size of the hole
const float POCKET_RADIUS = HOLE_VISUAL_RADIUS * 1.05f; // Make detection radius slightly larger // Make detection radius match visual size (or slightly larger)
const float MAX_SHOT_POWER = 15.0f;
const float FRICTION = 0.985f; // Friction factor per frame
const float MIN_VELOCITY_SQ = 0.01f * 0.01f; // Stop balls below this squared velocity
const float HEADSTRING_X = TABLE_LEFT + TABLE_WIDTH * 0.30f; // 30% line
const float RACK_POS_X = TABLE_LEFT + TABLE_WIDTH * 0.65f; // 65% line for rack apex
const float RACK_POS_Y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
const UINT ID_TIMER = 1;
const int TARGET_FPS = 60; // Target frames per second for timer

// --- Enums ---
// --- MODIFIED/NEW Enums ---
enum GameState {
    SHOWING_DIALOG,     // NEW: Game is waiting for initial dialog input
    PRE_BREAK_PLACEMENT,// Player placing cue ball for break
    BREAKING,           // Player is aiming/shooting the break shot
    CHOOSING_POCKET_P1, // NEW: Player 1 needs to call a pocket for the 8-ball
    CHOOSING_POCKET_P2, // NEW: Player 2 needs to call a pocket for the 8-ball
    AIMING,             // Player is aiming
    AI_THINKING,        // NEW: AI is calculating its move
    SHOT_IN_PROGRESS,   // Balls are moving
    ASSIGNING_BALLS,    // Turn after break where ball types are assigned
    PLAYER1_TURN,
    PLAYER2_TURN,
    BALL_IN_HAND_P1,
    BALL_IN_HAND_P2,
    GAME_OVER
};

enum BallType {
    NONE,
    SOLID,  // Yellow (1-7)
    STRIPE, // Red (9-15)
    EIGHT_BALL, // Black (8)
    CUE_BALL // White (0)
};

// NEW Enums for Game Mode and AI Difficulty
enum GameMode {
    HUMAN_VS_HUMAN,
    HUMAN_VS_AI
};

enum AIDifficulty {
    EASY,
    MEDIUM,
    HARD
};

enum OpeningBreakMode {
    CPU_BREAK,
    P1_BREAK,
    FLIP_COIN_BREAK
};

// --- Structs ---
struct Ball {
    int id;             // 0=Cue, 1-7=Solid, 8=Eight, 9-15=Stripe
    BallType type;
    float x, y;
    float vx, vy;
    D2D1_COLOR_F color;
    bool isPocketed;
};

struct PlayerInfo {
    BallType assignedType;
    int ballsPocketedCount;
    std::wstring name;
};

// --- Global Variables ---

// Direct2D & DirectWrite
ID2D1Factory* pFactory = nullptr;
//ID2D1Factory* g_pD2DFactory = nullptr;
ID2D1HwndRenderTarget* pRenderTarget = nullptr;
IDWriteFactory* pDWriteFactory = nullptr;
IDWriteTextFormat* pTextFormat = nullptr;
IDWriteTextFormat* pLargeTextFormat = nullptr; // For ""Foul!""

// Game State
HWND hwndMain = nullptr;
GameState currentGameState = SHOWING_DIALOG; // Start by showing dialog
std::vector<Ball> balls;
int currentPlayer = 1; // 1 or 2
PlayerInfo player1Info = { BallType::NONE, 0, L""Player 1"" };
PlayerInfo player2Info = { BallType::NONE, 0, L""CPU"" }; // Default P2 name
bool foulCommitted = false;
std::wstring gameOverMessage = L"""";
bool firstBallPocketedAfterBreak = false;
std::vector<int> pocketedThisTurn;
// --- NEW: 8-Ball Pocket Call Globals ---
int calledPocketP1 = -1; // Pocket index (0-5) called by Player 1 for the 8-ball. -1 means not called.
int calledPocketP2 = -1; // Pocket index (0-5) called by Player 2 for the 8-ball.
int currentlyHoveredPocket = -1; // For visual feedback on which pocket is being hovered
std::wstring pocketCallMessage = L""""; // Message like ""Choose a pocket...""

// --- NEW: Foul Tracking Globals ---
int firstHitBallIdThisShot = -1;      // ID of the first object ball hit by cue ball (-1 if none)
bool cueHitObjectBallThisShot = false; // Did cue ball hit an object ball this shot?
bool railHitAfterContact = false;     // Did any ball hit a rail AFTER cue hit an object ball?
// --- End New Foul Tracking Globals ---

// NEW Game Mode/AI Globals
GameMode gameMode = HUMAN_VS_HUMAN; // Default mode
AIDifficulty aiDifficulty = MEDIUM; // Default difficulty
OpeningBreakMode openingBreakMode = CPU_BREAK; // Default opening break mode
bool isPlayer2AI = false;           // Is Player 2 controlled by AI?
bool aiTurnPending = false;         // Flag: AI needs to take its turn when possible
// bool aiIsThinking = false;       // Replaced by AI_THINKING game state
// NEW: Flag to indicate if the current shot is the opening break of the game
bool isOpeningBreakShot = false;

// NEW: For AI shot planning and visualization
struct AIPlannedShot {
    float angle;
    float power;
    float spinX;
    float spinY;
    bool isValid; // Is there a valid shot planned?
};
AIPlannedShot aiPlannedShotDetails; // Stores the AI's next shot
bool aiIsDisplayingAim = false;    // True when AI has decided a shot and is in ""display aim"" mode
int aiAimDisplayFramesLeft = 0;  // How many frames left to display AI aim
const int AI_AIM_DISPLAY_DURATION_FRAMES = 45; // Approx 0.75 seconds at 60 FPS, adjust as needed

// Input & Aiming
POINT ptMouse = { 0, 0 };
bool isAiming = false;
bool isDraggingCueBall = false;
// --- ENSURE THIS LINE EXISTS HERE ---
bool isDraggingStick = false; // True specifically when drag initiated on the stick graphic
// --- End Ensure ---
bool isSettingEnglish = false;
D2D1_POINT_2F aimStartPoint = { 0, 0 };
float cueAngle = 0.0f;
float shotPower = 0.0f;
float cueSpinX = 0.0f; // Range -1 to 1
float cueSpinY = 0.0f; // Range -1 to 1
float pocketFlashTimer = 0.0f;
bool cheatModeEnabled = false; // Cheat Mode toggle (G key)
int draggingBallId = -1;
bool keyboardAimingActive = false; // NEW FLAG: true when arrow keys modify aim/power
MCIDEVICEID midiDeviceID = 0; //midi func
std::atomic<bool> isMusicPlaying(false); //midi func
std::thread musicThread; //midi func
void StartMidi(HWND hwnd, const TCHAR* midiPath);
void StopMidi();

// UI Element Positions
D2D1_RECT_F powerMeterRect = { TABLE_RIGHT + CUSHION_THICKNESS + 10, TABLE_TOP, TABLE_RIGHT + CUSHION_THICKNESS + 40, TABLE_BOTTOM };
D2D1_RECT_F spinIndicatorRect = { TABLE_LEFT - CUSHION_THICKNESS - 60, TABLE_TOP + 20, TABLE_LEFT - CUSHION_THICKNESS - 20, TABLE_TOP + 60 }; // Circle area
D2D1_POINT_2F spinIndicatorCenter = { spinIndicatorRect.left + (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f, spinIndicatorRect.top + (spinIndicatorRect.bottom - spinIndicatorRect.top) / 2.0f };
float spinIndicatorRadius = (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f;
D2D1_RECT_F pocketedBallsBarRect = { TABLE_LEFT, TABLE_BOTTOM + CUSHION_THICKNESS + 30, TABLE_RIGHT, TABLE_BOTTOM + CUSHION_THICKNESS + 70 };

// Corrected Pocket Center Positions (aligned with table corners/edges)
const D2D1_POINT_2F pocketPositions[6] = {
    {TABLE_LEFT, TABLE_TOP},                           // Top-Left
    {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_TOP},      // Top-Middle
    {TABLE_RIGHT, TABLE_TOP},                          // Top-Right
    {TABLE_LEFT, TABLE_BOTTOM},                        // Bottom-Left
    {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_BOTTOM},   // Bottom-Middle
    {TABLE_RIGHT, TABLE_BOTTOM}                        // Bottom-Right
};

// Colors
const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.1608f, 0.4000f, 0.1765f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
//const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.0f, 0.5f, 0.1f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF(0.3608f, 0.0275f, 0.0078f)); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
//const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF::Red); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
const D2D1_COLOR_F POCKET_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
const D2D1_COLOR_F CUE_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::White);
const D2D1_COLOR_F EIGHT_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
const D2D1_COLOR_F SOLID_COLOR = D2D1::ColorF(D2D1::ColorF::Yellow); // Solids = Yellow
const D2D1_COLOR_F STRIPE_COLOR = D2D1::ColorF(D2D1::ColorF::Red);   // Stripes = Red
const D2D1_COLOR_F AIM_LINE_COLOR = D2D1::ColorF(D2D1::ColorF::White, 0.7f); // Semi-transparent white
const D2D1_COLOR_F FOUL_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(0.1333f, 0.7294f, 0.7490f); //NEWCOLOR 0.1333f, 0.7294f, 0.7490f => ::Blue
//const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(D2D1::ColorF::Blue);
const D2D1_COLOR_F ENGLISH_DOT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
const D2D1_COLOR_F UI_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Black);

// --- Forward Declarations ---
HRESULT CreateDeviceResources();
void DiscardDeviceResources();
void OnPaint();
void OnResize(UINT width, UINT height);
void InitGame();
void GameUpdate();
void UpdatePhysics();
void CheckCollisions();
bool CheckPockets(); // Returns true if any ball was pocketed
void ProcessShotResults();
void ApplyShot(float power, float angle, float spinX, float spinY);
void RespawnCueBall(bool behindHeadstring);
bool AreBallsMoving();
void SwitchTurns();
bool AssignPlayerBallTypes(BallType firstPocketedType);
void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed);
Ball* GetBallById(int id);
Ball* GetCueBall();
//void PlayGameMusic(HWND hwnd); //midi func
void AIBreakShot();

// Drawing Functions
void DrawScene(ID2D1RenderTarget* pRT);
void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory);
void DrawBalls(ID2D1RenderTarget* pRT);
void DrawCueStick(ID2D1RenderTarget* pRT);
void DrawAimingAids(ID2D1RenderTarget* pRT);
void DrawUI(ID2D1RenderTarget* pRT);
void DrawPowerMeter(ID2D1RenderTarget* pRT);
void DrawSpinIndicator(ID2D1RenderTarget* pRT);
void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT);
void DrawBallInHandIndicator(ID2D1RenderTarget* pRT);
// NEW
void DrawPocketSelectionIndicator(ID2D1RenderTarget* pRT);

// Helper Functions
float GetDistance(float x1, float y1, float x2, float y2);
float GetDistanceSq(float x1, float y1, float x2, float y2);
bool IsValidCueBallPosition(float x, float y, bool checkHeadstring);
template <typename T> void SafeRelease(T** ppT);
// --- NEW HELPER FORWARD DECLARATIONS ---
bool IsPlayerOnEightBall(int player);
void CheckAndTransitionToPocketChoice(int playerID);
// --- ADD FORWARD DECLARATION FOR NEW HELPER HERE ---
float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b);
// --- End Forward Declaration ---
bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection); // Keep this if present

// --- NEW Forward Declarations ---

// AI Related
struct AIShotInfo; // Define below
void TriggerAIMove();
void AIMakeDecision();
void AIPlaceCueBall();
AIShotInfo AIFindBestShot();
AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex);
bool IsPathClear(D2D1_POINT_2F start, D2D1_POINT_2F end, int ignoredBallId1, int ignoredBallId2);
Ball* FindFirstHitBall(D2D1_POINT_2F start, float angle, float& hitDistSq); // Added hitDistSq output
float CalculateShotPower(float cueToGhostDist, float targetToPocketDist);
D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex);
bool IsValidAIAimAngle(float angle); // Basic check

// Dialog Related
INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
void ShowNewGameDialog(HINSTANCE hInstance);
void LoadSettings(); // For deserialization
void SaveSettings(); // For serialization
const std::wstring SETTINGS_FILE_NAME = L""Pool-Settings.txt"";
void ResetGame(HINSTANCE hInstance); // Function to handle F2 reset

// --- Forward Declaration for Window Procedure --- <<< Add this line HERE
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

// --- NEW Struct for AI Shot Evaluation ---
struct AIShotInfo {
    bool possible = false;          // Is this shot considered viable?
    Ball* targetBall = nullptr;     // Which ball to hit
    int pocketIndex = -1;           // Which pocket to aim for (0-5)
    D2D1_POINT_2F ghostBallPos = { 0,0 }; // Where cue ball needs to hit target ball
    float angle = 0.0f;             // Calculated shot angle
    float power = 0.0f;             // Calculated shot power
    float score = -1.0f;            // Score for this shot (higher is better)
    bool involves8Ball = false;     // Is the target the 8-ball?
};

/*
table = TABLE_COLOR new: #29662d (0.1608, 0.4000, 0.1765) => old: (0.0f, 0.5f, 0.1f)
rail CUSHION_COLOR = #5c0702 (0.3608, 0.0275, 0.0078) => ::Red
gap = #e99d33 (0.9157, 0.6157, 0.2000) => ::Orange
winbg = #5e8863 (0.3686, 0.5333, 0.3882) => 1.0f, 1.0f, 0.803f
headstring = #47742f (0.2784, 0.4549, 0.1843) => ::White
bluearrow = #08b0a5 (0.0314, 0.6902, 0.6471) *#22babf (0.1333,0.7294,0.7490) => ::Blue
*/

// --- NEW Settings Serialization Functions ---
void SaveSettings() {
    std::ofstream outFile(SETTINGS_FILE_NAME);
    if (outFile.is_open()) {
        outFile << static_cast<int>(gameMode) << std::endl;
        outFile << static_cast<int>(aiDifficulty) << std::endl;
        outFile << static_cast<int>(openingBreakMode) << std::endl;
        outFile.close();
    }
    // else: Handle error, e.g., log or silently fail
}

void LoadSettings() {
    std::ifstream inFile(SETTINGS_FILE_NAME);
    if (inFile.is_open()) {
        int gm, aid, obm;
        if (inFile >> gm) {
            gameMode = static_cast<GameMode>(gm);
        }
        if (inFile >> aid) {
            aiDifficulty = static_cast<AIDifficulty>(aid);
        }
        if (inFile >> obm) {
            openingBreakMode = static_cast<OpeningBreakMode>(obm);
        }
        inFile.close();

        // Validate loaded settings (optional, but good practice)
        if (gameMode < HUMAN_VS_HUMAN || gameMode > HUMAN_VS_AI) gameMode = HUMAN_VS_HUMAN; // Default
        if (aiDifficulty < EASY || aiDifficulty > HARD) aiDifficulty = MEDIUM; // Default
        if (openingBreakMode < CPU_BREAK || openingBreakMode > FLIP_COIN_BREAK) openingBreakMode = CPU_BREAK; // Default
    }
    // else: File doesn't exist or couldn't be opened, use defaults (already set in global vars)
}
// --- End Settings Serialization Functions ---

// --- NEW Dialog Procedure ---
INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
    switch (message) {
    case WM_INITDIALOG:
    {
        // --- ACTION 4: Center Dialog Box ---
// Optional: Force centering if default isn't working
        RECT rcDlg, rcOwner, rcScreen;
        HWND hwndOwner = GetParent(hDlg); // GetParent(hDlg) might be better if hwndMain is passed
        if (hwndOwner == NULL) hwndOwner = GetDesktopWindow();

        GetWindowRect(hwndOwner, &rcOwner);
        GetWindowRect(hDlg, &rcDlg);
        CopyRect(&rcScreen, &rcOwner); // Use owner rect as reference bounds

        // Offset the owner rect relative to the screen if it's not the desktop
        if (GetParent(hDlg) != NULL) { // If parented to main window (passed to DialogBoxParam)
            OffsetRect(&rcOwner, -rcScreen.left, -rcScreen.top);
            OffsetRect(&rcDlg, -rcScreen.left, -rcScreen.top);
            OffsetRect(&rcScreen, -rcScreen.left, -rcScreen.top);
        }


        // Calculate centered position
        int x = rcOwner.left + (rcOwner.right - rcOwner.left - (rcDlg.right - rcDlg.left)) / 2;
        int y = rcOwner.top + (rcOwner.bottom - rcOwner.top - (rcDlg.bottom - rcDlg.top)) / 2;

        // Ensure it stays within screen bounds (optional safety)
        x = std::max(static_cast<int>(rcScreen.left), x);
        y = std::max(static_cast<int>(rcScreen.top), y);
        if (x + (rcDlg.right - rcDlg.left) > rcScreen.right)
            x = rcScreen.right - (rcDlg.right - rcDlg.left);
        if (y + (rcDlg.bottom - rcDlg.top) > rcScreen.bottom)
            y = rcScreen.bottom - (rcDlg.bottom - rcDlg.top);


        // Set the dialog position
        SetWindowPos(hDlg, HWND_TOP, x, y, 0, 0, SWP_NOSIZE);

        // --- End Centering Code ---

        // Set initial state based on current global settings (or defaults)
        CheckRadioButton(hDlg, IDC_RADIO_2P, IDC_RADIO_CPU, (gameMode == HUMAN_VS_HUMAN) ? IDC_RADIO_2P : IDC_RADIO_CPU);

        CheckRadioButton(hDlg, IDC_RADIO_EASY, IDC_RADIO_HARD,
            (aiDifficulty == EASY) ? IDC_RADIO_EASY : ((aiDifficulty == MEDIUM) ? IDC_RADIO_MEDIUM : IDC_RADIO_HARD));

        // Enable/Disable AI group based on initial mode
        EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), gameMode == HUMAN_VS_AI);
        // Set initial state for Opening Break Mode
        CheckRadioButton(hDlg, IDC_RADIO_CPU_BREAK, IDC_RADIO_FLIP_BREAK,
            (openingBreakMode == CPU_BREAK) ? IDC_RADIO_CPU_BREAK : ((openingBreakMode == P1_BREAK) ? IDC_RADIO_P1_BREAK : IDC_RADIO_FLIP_BREAK));
        // Enable/Disable Opening Break group based on initial mode
        EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), gameMode == HUMAN_VS_AI);
    }
    return (INT_PTR)TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_RADIO_2P:
        case IDC_RADIO_CPU:
        {
            bool isCPU = IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED;
            // Enable/Disable AI group controls based on selection
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), isCPU);
            // Also enable/disable Opening Break Mode group
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), isCPU);
        }
        return (INT_PTR)TRUE;

        case IDOK:
            // Retrieve selected options and store in global variables
            if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED) {
                gameMode = HUMAN_VS_AI;
                if (IsDlgButtonChecked(hDlg, IDC_RADIO_EASY) == BST_CHECKED) aiDifficulty = EASY;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_MEDIUM) == BST_CHECKED) aiDifficulty = MEDIUM;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_HARD) == BST_CHECKED) aiDifficulty = HARD;

                if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU_BREAK) == BST_CHECKED) openingBreakMode = CPU_BREAK;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_P1_BREAK) == BST_CHECKED) openingBreakMode = P1_BREAK;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_FLIP_BREAK) == BST_CHECKED) openingBreakMode = FLIP_COIN_BREAK;
            }
            else {
                gameMode = HUMAN_VS_HUMAN;
                // openingBreakMode doesn't apply to HvsH, can leave as is or reset
            }
            SaveSettings(); // Save settings when OK is pressed
            EndDialog(hDlg, IDOK); // Close dialog, return IDOK
            return (INT_PTR)TRUE;

        case IDCANCEL: // Handle Cancel or closing the dialog
            // Optionally, could reload settings here if you want cancel to revert to previously saved state
            EndDialog(hDlg, IDCANCEL);
            return (INT_PTR)TRUE;
        }
        break; // End WM_COMMAND
    }
    return (INT_PTR)FALSE; // Default processing
}

// --- NEW Helper to Show Dialog ---
void ShowNewGameDialog(HINSTANCE hInstance) {
    if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), hwndMain, NewGameDialogProc, 0) == IDOK) {
        // User clicked Start, reset game with new settings
        isPlayer2AI = (gameMode == HUMAN_VS_AI); // Update AI flag
        if (isPlayer2AI) {
            switch (aiDifficulty) {
            case EASY: player2Info.name = L""CPU (Easy)""; break;
            case MEDIUM: player2Info.name = L""CPU (Medium)""; break;
            case HARD: player2Info.name = L""CPU (Hard)""; break;
            }
        }
        else {
            player2Info.name = L""Player 2"";
        }
        // Update window title
        std::wstring windowTitle = L""Direct2D 8-Ball Pool"";
        if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
        else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";
        SetWindowText(hwndMain, windowTitle.c_str());

        InitGame(); // Re-initialize game logic & board
        InvalidateRect(hwndMain, NULL, TRUE); // Force redraw
    }
    else {
        // User cancelled dialog - maybe just resume game? Or exit?
        // For simplicity, we do nothing, game continues as it was.
        // To exit on cancel from F2, would need more complex state management.
    }
}

// --- NEW Reset Game Function ---
void ResetGame(HINSTANCE hInstance) {
    // Call the helper function to show the dialog and re-init if OK clicked
    ShowNewGameDialog(hInstance);
}

// --- WinMain ---
int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR, int nCmdShow) {
    if (FAILED(CoInitialize(NULL))) {
        MessageBox(NULL, L""COM Initialization Failed."", L""Error"", MB_OK | MB_ICONERROR);
        return -1;
    }

    // --- NEW: Load settings at startup ---
    LoadSettings();

    // --- NEW: Show configuration dialog FIRST ---
    if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), NULL, NewGameDialogProc, 0) != IDOK) {
        // User cancelled the dialog
        CoUninitialize();
        return 0; // Exit gracefully if dialog cancelled
    }
    // Global gameMode and aiDifficulty are now set by the DialogProc

    // Set AI flag based on game mode
    isPlayer2AI = (gameMode == HUMAN_VS_AI);
    if (isPlayer2AI) {
        switch (aiDifficulty) {
        case EASY: player2Info.name = L""CPU (Easy)""; break;
        case MEDIUM: player2Info.name = L""CPU (Medium)""; break;
        case HARD: player2Info.name = L""CPU (Hard)""; break;
        }
    }
    else {
        player2Info.name = L""Player 2"";
    }
    // --- End of Dialog Logic ---


    WNDCLASS wc = { };
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = L""Direct2D_8BallPool"";
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1)); // Use your actual icon ID here

    if (!RegisterClass(&wc)) {
        MessageBox(NULL, L""Window Registration Failed."", L""Error"", MB_OK | MB_ICONERROR);
        CoUninitialize();
        return -1;
    }

    // --- ACTION 4: Calculate Centered Window Position ---
    const int WINDOW_WIDTH = 1000; // Define desired width
    const int WINDOW_HEIGHT = 700; // Define desired height
    int screenWidth = GetSystemMetrics(SM_CXSCREEN);
    int screenHeight = GetSystemMetrics(SM_CYSCREEN);
    int windowX = (screenWidth - WINDOW_WIDTH) / 2;
    int windowY = (screenHeight - WINDOW_HEIGHT) / 2;

    // --- Change Window Title based on mode ---
    std::wstring windowTitle = L""Direct2D 8-Ball Pool"";
    if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
    else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";

    DWORD dwStyle = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX; // No WS_THICKFRAME, No WS_MAXIMIZEBOX

    hwndMain = CreateWindowEx(
        0, L""Direct2D_8BallPool"", windowTitle.c_str(), dwStyle,
        windowX, windowY, WINDOW_WIDTH, WINDOW_HEIGHT,
        NULL, NULL, hInstance, NULL
    );

    if (!hwndMain) {
        MessageBox(NULL, L""Window Creation Failed."", L""Error"", MB_OK | MB_ICONERROR);
        CoUninitialize();
        return -1;
    }

    // Initialize Direct2D Resources AFTER window creation
    if (FAILED(CreateDeviceResources())) {
        MessageBox(NULL, L""Failed to create Direct2D resources."", L""Error"", MB_OK | MB_ICONERROR);
        DestroyWindow(hwndMain);
        CoUninitialize();
        return -1;
    }

    InitGame(); // Initialize game state AFTER resources are ready & mode is set
    Sleep(500); // Allow window to fully initialize before starting the countdown //midi func
    StartMidi(hwndMain, TEXT(""BSQ.MID"")); // Replace with your MIDI filename
    //PlayGameMusic(hwndMain); //midi func

    ShowWindow(hwndMain, nCmdShow);
    UpdateWindow(hwndMain);

    if (!SetTimer(hwndMain, ID_TIMER, 1000 / TARGET_FPS, NULL)) {
        MessageBox(NULL, L""Could not SetTimer()."", L""Error"", MB_OK | MB_ICONERROR);
        DestroyWindow(hwndMain);
        CoUninitialize();
        return -1;
    }

    MSG msg = { };
    // --- Modified Main Loop ---
    // Handles the case where the game starts in SHOWING_DIALOG state (handled now before loop)
    // or gets reset to it via F2. The main loop runs normally once game starts.
    while (GetMessage(&msg, NULL, 0, 0)) {
        // We might need modeless dialog handling here if F2 shows dialog
        // while window is active, but DialogBoxParam is modal.
        // Let's assume F2 hides main window, shows dialog, then restarts game loop.
        // Simpler: F2 calls ResetGame which calls DialogBoxParam (modal) then InitGame.
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }


    KillTimer(hwndMain, ID_TIMER);
    DiscardDeviceResources();
    SaveSettings(); // Save settings on exit
    CoUninitialize();

    return (int)msg.wParam;
}

// --- WndProc ---
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    // Declare cueBall pointer once at the top, used in multiple cases
    // For clarity, often better to declare within each case where needed.
    Ball* cueBall = nullptr; // Initialize to nullptr
    switch (msg) {
    case WM_CREATE:
        // Resources are now created in WinMain after CreateWindowEx
        return 0;

    case WM_PAINT:
        OnPaint();
        // Validate the entire window region after painting
        ValidateRect(hwnd, NULL);
        return 0;

    case WM_SIZE: {
        UINT width = LOWORD(lParam);
        UINT height = HIWORD(lParam);
        OnResize(width, height);
        return 0;
    }

    case WM_TIMER:
        if (wParam == ID_TIMER) {
            GameUpdate(); // Update game logic and physics
            InvalidateRect(hwnd, NULL, FALSE); // Request redraw
        }
        return 0;

        // --- NEW: Handle F2 Key for Reset ---
        // --- MODIFIED: Handle More Keys ---
    case WM_KEYDOWN:
    { // Add scope for variable declarations

        // --- FIX: Get Cue Ball pointer for this scope ---
        cueBall = GetCueBall();
        // We might allow some keys even if cue ball is gone (like F1/F2), but actions need it
        // --- End Fix ---

        // Check which player can interact via keyboard (Humans only)
        bool canPlayerControl = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P1 || currentGameState == PRE_BREAK_PLACEMENT)) ||
            (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT)));

        // --- F1 / F2 Keys (Always available) ---
        if (wParam == VK_F2) {
            HINSTANCE hInstance = (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE);
            ResetGame(hInstance); // Call reset function
            return 0; // Indicate key was processed
        }
        else if (wParam == VK_F1) {
            MessageBox(hwnd,
                L""Direct2D-based StickPool game made in C++ from scratch (2764+ lines of code)\n"" // Update line count if needed
                L""First successful Clone in C++ (no other sites or projects were there to glean from.) Made /w AI assist\n""
                L""(others were in JS/ non-8-Ball in C# etc.) w/o OOP and Graphics Frameworks all in a Single file.\n""
                L""Copyright (C) 2025 Evans Thorpemorton, Entisoft Solutions.\n""
                L""Includes AI Difficulty Modes, Aim-Trajectory For Table Rails + Hard Angles TipShots. || F2=New Game"",
                L""About This Game"", MB_OK | MB_ICONINFORMATION);
            return 0; // Indicate key was processed
        }

        // Check for 'M' key (uppercase or lowercase)
            // Toggle music with ""M""
        if (wParam == 'M' || wParam == 'm') {
            //static bool isMusicPlaying = false;
            if (isMusicPlaying) {
                // Stop the music
                StopMidi();
                isMusicPlaying = false;
            }
            else {
                // Build the MIDI file path
                TCHAR midiPath[MAX_PATH];
                GetModuleFileName(NULL, midiPath, MAX_PATH);
                // Keep only the directory part
                TCHAR* lastBackslash = _tcsrchr(midiPath, '\\');
                if (lastBackslash != NULL) {
                    *(lastBackslash + 1) = '\0';
                }
                // Append the MIDI filename
                _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID"")); // Adjust filename if needed

                // Start playing MIDI
                StartMidi(hwndMain, midiPath);
                isMusicPlaying = true;
            }
        }


        // --- Player Interaction Keys (Only if allowed) ---
        if (canPlayerControl) {
            // --- Get Shift Key State ---
            bool shiftPressed = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
            float angleStep = shiftPressed ? 0.05f : 0.01f; // Base step / Faster step (Adjust as needed) // Multiplier was 5x
            float powerStep = 0.2f; // Power step (Adjust as needed)

            switch (wParam) {
            case VK_LEFT: // Rotate Cue Stick Counter-Clockwise
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    cueAngle -= angleStep;
                    // Normalize angle (keep between 0 and 2*PI)
                    if (cueAngle < 0) cueAngle += 2 * PI;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = false; // Keyboard adjust doesn't use mouse aiming state
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_RIGHT: // Rotate Cue Stick Clockwise
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    cueAngle += angleStep;
                    // Normalize angle (keep between 0 and 2*PI)
                    if (cueAngle >= 2 * PI) cueAngle -= 2 * PI;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = false;
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_UP: // Decrease Shot Power
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    shotPower -= powerStep;
                    if (shotPower < 0.0f) shotPower = 0.0f;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = true; // Keyboard adjust doesn't use mouse aiming state
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_DOWN: // Increase Shot Power
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    shotPower += powerStep;
                    if (shotPower > MAX_SHOT_POWER) shotPower = MAX_SHOT_POWER;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = true;
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_SPACE: // Trigger Shot
                if ((currentGameState == AIMING || currentGameState == BREAKING || currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN)
                    && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING)
                {
                    if (shotPower > 0.15f) { // Use same threshold as mouse
                       // Reset foul flags BEFORE applying shot
                        firstHitBallIdThisShot = -1;
                        cueHitObjectBallThisShot = false;
                        railHitAfterContact = false;

                        // Play sound & Apply Shot
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                        ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);

                        // Update State
                        currentGameState = SHOT_IN_PROGRESS;
                        foulCommitted = false;
                        pocketedThisTurn.clear();
                        shotPower = 0; // Reset power after shooting
                        isAiming = false; isDraggingStick = false; // Reset aiming flags
                        keyboardAimingActive = false;
                    }
                }
                break;

            case VK_ESCAPE: // Cancel Aim/Shot Setup
                if ((currentGameState == AIMING || currentGameState == BREAKING) || shotPower > 0)
                {
                    shotPower = 0.0f;
                    isAiming = false;
                    isDraggingStick = false;
                    keyboardAimingActive = false;
                    // Revert to basic turn state if not breaking
                    if (currentGameState != BREAKING) {
                        currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                    }
                }
                break;

            case 'G': // Toggle Cheat Mode
                cheatModeEnabled = !cheatModeEnabled;
                if (cheatModeEnabled)
                    MessageBeep(MB_ICONEXCLAMATION); // Play a beep when enabling
                else
                    MessageBeep(MB_OK); // Play a different beep when disabling
                break;

            default:
                // Allow default processing for other keys if needed
                // return DefWindowProc(hwnd, msg, wParam, lParam); // Usually not needed for WM_KEYDOWN
                break;
            } // End switch(wParam) for player controls
            return 0; // Indicate player control key was processed
        } // End if(canPlayerControl)
    } // End scope for WM_KEYDOWN case
    // If key wasn't F1/F2 and player couldn't control, maybe allow default processing?
    // return DefWindowProc(hwnd, msg, wParam, lParam); // Or just return 0
    return 0;

    case WM_MOUSEMOVE: {
        ptMouse.x = LOWORD(lParam);
        ptMouse.y = HIWORD(lParam);

        // --- NEW LOGIC: Handle Pocket Hover ---
        if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
            (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {
            int oldHover = currentlyHoveredPocket;
            currentlyHoveredPocket = -1; // Reset
            for (int i = 0; i < 6; ++i) {
                if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                    currentlyHoveredPocket = i;
                    break;
                }
            }
            if (oldHover != currentlyHoveredPocket) {
                InvalidateRect(hwnd, NULL, FALSE);
            }
            // Do NOT return 0 here, allow normal mouse angle update to continue
        }
        // --- END NEW LOGIC ---


        cueBall = GetCueBall(); // Declare and get cueBall pointer

        if (isDraggingCueBall && cheatModeEnabled && draggingBallId != -1) {
            Ball* ball = GetBallById(draggingBallId);
            if (ball) {
                ball->x = (float)ptMouse.x;
                ball->y = (float)ptMouse.y;
                ball->vx = ball->vy = 0.0f;
            }
            return 0;
        }

        if (!cueBall) return 0;

        // Update Aiming Logic (Check player turn)
        if (isDraggingCueBall &&
            ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                (!isPlayer2AI && currentPlayer == 2 && currentGameState == BALL_IN_HAND_P2) ||
                currentGameState == PRE_BREAK_PLACEMENT))
        {
            bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
            // Tentative position update
            cueBall->x = (float)ptMouse.x;
            cueBall->y = (float)ptMouse.y;
            cueBall->vx = cueBall->vy = 0;
        }
        else if ((isAiming || isDraggingStick) &&
            ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
        {
            //NEW2 MOUSEBOUND CODE = START
                /*// Clamp mouse inside table bounds during aiming
                if (ptMouse.x < TABLE_LEFT) ptMouse.x = TABLE_LEFT;
            if (ptMouse.x > TABLE_RIGHT) ptMouse.x = TABLE_RIGHT;
            if (ptMouse.y < TABLE_TOP) ptMouse.y = TABLE_TOP;
            if (ptMouse.y > TABLE_BOTTOM) ptMouse.y = TABLE_BOTTOM;*/
            //NEW2 MOUSEBOUND CODE = END
            // Aiming drag updates angle and power
            float dx = (float)ptMouse.x - cueBall->x;
            float dy = (float)ptMouse.y - cueBall->y;
            if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
            //float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
            //shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
            if (!keyboardAimingActive) { // Only update shotPower if NOT keyboard aiming
                float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
                shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
            }
        }
        else if (isSettingEnglish &&
            ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING)) ||
                (!isPlayer2AI && currentPlayer == 2 && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING))))
        {
            // Setting English
            float dx = (float)ptMouse.x - spinIndicatorCenter.x;
            float dy = (float)ptMouse.y - spinIndicatorCenter.y;
            float dist = GetDistance(dx, dy, 0, 0);
            if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
            cueSpinX = dx / spinIndicatorRadius;
            cueSpinY = dy / spinIndicatorRadius;
        }
        else {
            //DISABLE PERM AIMING = START
            /*// Update visual angle even when not aiming/dragging (Check player turn)
            bool canUpdateVisualAngle = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BALL_IN_HAND_P1)) ||
                (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BALL_IN_HAND_P2)) ||
                currentGameState == PRE_BREAK_PLACEMENT || currentGameState == BREAKING || currentGameState == AIMING);

            if (canUpdateVisualAngle && !isDraggingCueBall && !isAiming && !isDraggingStick && !keyboardAimingActive) // NEW: Prevent mouse override if keyboard aiming
            {
                // NEW MOUSEBOUND CODE = START
                    // Only update cue angle if mouse is inside the playable table area
                if (ptMouse.x >= TABLE_LEFT && ptMouse.x <= TABLE_RIGHT &&
                    ptMouse.y >= TABLE_TOP && ptMouse.y <= TABLE_BOTTOM)
                {
                    // NEW MOUSEBOUND CODE = END
                    Ball* cb = cueBall; // Use function-scope cueBall // Already got cueBall above
                    if (cb) {
                        float dx = (float)ptMouse.x - cb->x;
                        float dy = (float)ptMouse.y - cb->y;
                        if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                    }
                } //NEW MOUSEBOUND CODE LINE = DISABLE
            }*/
            //DISABLE PERM AIMING = END
        }
        return 0;
    } // End WM_MOUSEMOVE

    case WM_LBUTTONDOWN: {
        ptMouse.x = LOWORD(lParam);
        ptMouse.y = HIWORD(lParam);

        // --- NEW LOGIC: Handle Pocket Selection First ---
        if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
            (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

            int clickedPocketIndex = -1;
            for (int i = 0; i < 6; ++i) {
                if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                    clickedPocketIndex = i;
                    break;
                }
            }

            if (clickedPocketIndex != -1) { // Player clicked on a pocket
                // FIX: Update the called pocket, but DO NOT change the game state.
                // This allows the player to click another pocket to change their mind.
                if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                else calledPocketP2 = clickedPocketIndex;
                InvalidateRect(hwnd, NULL, FALSE); // Redraw to show updated arrow
                return 0; // Consume the click and stay in CHOOSING_POCKET state
            }

            // FIX: Add new logic to CONFIRM the choice by clicking the cue ball.
            Ball* cueBall = GetCueBall();
            int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
            if (cueBall && calledPocket != -1 && GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y) < BALL_RADIUS * BALL_RADIUS * 25) {
                // A pocket has been selected, and the player now clicks the cue ball.
                // NOW we transition to the normal aiming state.
                currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                pocketCallMessage = L""""; // Clear the ""Choose a pocket..."" message
                isAiming = true; // Prepare for aiming
                aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y); // Use your existing aim start variable
                return 0;
            }

            // If they click anywhere else (not a pocket, not the cue ball), do nothing.
            return 0;
        }
        // --- END NEW LOGIC ---


        if (cheatModeEnabled) {
            // Allow dragging any ball freely
            for (Ball& ball : balls) {
                float distSq = GetDistanceSq(ball.x, ball.y, (float)ptMouse.x, (float)ptMouse.y);
                if (distSq <= BALL_RADIUS * BALL_RADIUS * 4) { // Click near ball
                    isDraggingCueBall = true;
                    draggingBallId = ball.id;
                    if (ball.id == 0) {
                        // If dragging cue ball manually, ensure we stay in Ball-In-Hand state
                        if (currentPlayer == 1)
                            currentGameState = BALL_IN_HAND_P1;
                        else if (currentPlayer == 2 && !isPlayer2AI)
                            currentGameState = BALL_IN_HAND_P2;
                    }
                    return 0;
                }
            }
        }

        Ball* cueBall = GetCueBall(); // Declare and get cueBall pointer            

        // Check which player is allowed to interact via mouse click
        bool canPlayerClickInteract = ((currentPlayer == 1) || (currentPlayer == 2 && !isPlayer2AI));
        // Define states where interaction is generally allowed
        bool canInteractState = (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
            currentGameState == AIMING || currentGameState == BREAKING ||
            currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 ||
            currentGameState == PRE_BREAK_PLACEMENT);

        // Check Spin Indicator first (Allow if player's turn/aim phase)
        if (canPlayerClickInteract && canInteractState) {
            float spinDistSq = GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, spinIndicatorCenter.x, spinIndicatorCenter.y);
            if (spinDistSq < spinIndicatorRadius * spinIndicatorRadius * 1.2f) {
                isSettingEnglish = true;
                float dx = (float)ptMouse.x - spinIndicatorCenter.x;
                float dy = (float)ptMouse.y - spinIndicatorCenter.y;
                float dist = GetDistance(dx, dy, 0, 0);
                if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
                cueSpinX = dx / spinIndicatorRadius;
                cueSpinY = dy / spinIndicatorRadius;
                isAiming = false; isDraggingStick = false; isDraggingCueBall = false;
                return 0;
            }
        }

        if (!cueBall) return 0;

        // Check Ball-in-Hand placement/drag
        bool isPlacingBall = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
        bool isPlayerAllowedToPlace = (isPlacingBall &&
            ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                (currentGameState == PRE_BREAK_PLACEMENT))); // Allow current player in break setup

        if (isPlayerAllowedToPlace) {
            float distSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
            if (distSq < BALL_RADIUS * BALL_RADIUS * 9.0f) {
                isDraggingCueBall = true;
                isAiming = false; isDraggingStick = false;
            }
            else {
                bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                if (IsValidCueBallPosition((float)ptMouse.x, (float)ptMouse.y, behindHeadstring)) {
                    cueBall->x = (float)ptMouse.x; cueBall->y = (float)ptMouse.y;
                    cueBall->vx = 0; cueBall->vy = 0;
                    isDraggingCueBall = false;
                    // Transition state
                    if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                    else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                    else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                    cueAngle = 0.0f;
                }
            }
            return 0;
        }

        // Check for starting Aim (Cue Ball OR Stick)
        bool canAim = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BREAKING)) ||
            (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BREAKING)));

        if (canAim) {
            const float stickDrawLength = 150.0f * 1.4f;
            float currentStickAngle = cueAngle + PI;
            D2D1_POINT_2F currentStickEnd = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * stickDrawLength, cueBall->y + sinf(currentStickAngle) * stickDrawLength);
            D2D1_POINT_2F currentStickTip = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * 5.0f, cueBall->y + sinf(currentStickAngle) * 5.0f);
            float distToStickSq = PointToLineSegmentDistanceSq(D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y), currentStickTip, currentStickEnd);
            float stickClickThresholdSq = 36.0f;
            float distToCueBallSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
            float cueBallClickRadiusSq = BALL_RADIUS * BALL_RADIUS * 25;

            bool clickedStick = (distToStickSq < stickClickThresholdSq);
            bool clickedCueArea = (distToCueBallSq < cueBallClickRadiusSq);

            if (clickedStick || clickedCueArea) {
                isDraggingStick = clickedStick && !clickedCueArea;
                isAiming = clickedCueArea;
                aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
                shotPower = 0;
                float dx = (float)ptMouse.x - cueBall->x;
                float dy = (float)ptMouse.y - cueBall->y;
                if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                if (currentGameState != BREAKING) currentGameState = AIMING;
            }
        }
        return 0;
    } // End WM_LBUTTONDOWN


    case WM_LBUTTONUP: {
        if (cheatModeEnabled && draggingBallId != -1) {
            Ball* b = GetBallById(draggingBallId);
            if (b) {
                for (int p = 0; p < 6; ++p) {
                    float dx = b->x - pocketPositions[p].x;
                    float dy = b->y - pocketPositions[p].y;
                    if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                        // --- Assign ball type on first cheat-pocket if table still open ---
                        if (player1Info.assignedType == BallType::NONE
                            && player2Info.assignedType == BallType::NONE
                            && (b->type == BallType::SOLID || b->type == BallType::STRIPE))
                        {
                            AssignPlayerBallTypes(b->type);
                        }
                        b->isPocketed = true;
                        pocketedThisTurn.push_back(b->id);
                        // Immediately increment that player's count (skip cue/8)
                        if (b->id != 0 && b->id != 8) {
                            if (currentPlayer == 1)
                                player1Info.ballsPocketedCount++;
                            else
                                player2Info.ballsPocketedCount++;
                        }
                        break;
                    }
                }
            }
        }

        ptMouse.x = LOWORD(lParam);
        ptMouse.y = HIWORD(lParam);

        Ball* cueBall = GetCueBall(); // Get cueBall pointer

        // Check for releasing aim drag (Stick OR Cue Ball)
        if ((isAiming || isDraggingStick) &&
            ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
        {
            bool wasAiming = isAiming;
            bool wasDraggingStick = isDraggingStick;
            isAiming = false; isDraggingStick = false;

            if (shotPower > 0.15f) { // Check power threshold
                if (currentGameState != AI_THINKING) {
                    firstHitBallIdThisShot = -1; cueHitObjectBallThisShot = false; railHitAfterContact = false; // Reset foul flags
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                    ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);
                    currentGameState = SHOT_IN_PROGRESS;
                    foulCommitted = false; pocketedThisTurn.clear();
                }
            }
            else if (currentGameState != AI_THINKING) { // Revert state if power too low
                if (currentGameState == BREAKING) { /* Still breaking */ }
                else {
                    currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                    if (currentPlayer == 2 && isPlayer2AI) aiTurnPending = false;
                }
            }
            shotPower = 0; // Reset power indicator regardless
        }

        // Handle releasing cue ball drag (placement)
        if (isDraggingCueBall) {
            isDraggingCueBall = false;
            // Check player allowed to place
            bool isPlacingState = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
            bool isPlayerAllowed = (isPlacingState &&
                ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                    (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                    (currentGameState == PRE_BREAK_PLACEMENT)));

            if (isPlayerAllowed && cueBall) {
                bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                if (IsValidCueBallPosition(cueBall->x, cueBall->y, behindHeadstring)) {
                    // Finalize position already set by mouse move
                    // Transition state
                    if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                    else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                    else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                    cueAngle = 0.0f;
                }
                else { /* Stay in BALL_IN_HAND state if final pos invalid */ }
            }
        }

        // Handle releasing english setting
        if (isSettingEnglish) {
            isSettingEnglish = false;
        }
        return 0;
    } // End WM_LBUTTONUP

    case WM_DESTROY:
        isMusicPlaying = false;
        if (midiDeviceID != 0) {
            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
            SaveSettings(); // Save settings on exit
        }
        PostQuitMessage(0);
        return 0;

    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

// --- Direct2D Resource Management ---

HRESULT CreateDeviceResources() {
    HRESULT hr = S_OK;

    // Create Direct2D Factory
    if (!pFactory) {
        hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &pFactory);
        if (FAILED(hr)) return hr;
    }

    // Create DirectWrite Factory
    if (!pDWriteFactory) {
        hr = DWriteCreateFactory(
            DWRITE_FACTORY_TYPE_SHARED,
            __uuidof(IDWriteFactory),
            reinterpret_cast<IUnknown**>(&pDWriteFactory)
        );
        if (FAILED(hr)) return hr;
    }

    // Create Text Formats
    if (!pTextFormat && pDWriteFactory) {
        hr = pDWriteFactory->CreateTextFormat(
            L""Segoe UI"", NULL, DWRITE_FONT_WEIGHT_NORMAL, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
            16.0f, L""en-us"", &pTextFormat
        );
        if (FAILED(hr)) return hr;
        // Center align text
        pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
        pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
    }
    if (!pLargeTextFormat && pDWriteFactory) {
        hr = pDWriteFactory->CreateTextFormat(
            L""Impact"", NULL, DWRITE_FONT_WEIGHT_BOLD, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
            48.0f, L""en-us"", &pLargeTextFormat
        );
        if (FAILED(hr)) return hr;
        pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING); // Align left
        pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
    }


    // Create Render Target (needs valid hwnd)
    if (!pRenderTarget && hwndMain) {
        RECT rc;
        GetClientRect(hwndMain, &rc);
        D2D1_SIZE_U size = D2D1::SizeU(rc.right - rc.left, rc.bottom - rc.top);

        hr = pFactory->CreateHwndRenderTarget(
            D2D1::RenderTargetProperties(),
            D2D1::HwndRenderTargetProperties(hwndMain, size),
            &pRenderTarget
        );
        if (FAILED(hr)) {
            // If failed, release factories if they were created in this call
            SafeRelease(&pTextFormat);
            SafeRelease(&pLargeTextFormat);
            SafeRelease(&pDWriteFactory);
            SafeRelease(&pFactory);
            pRenderTarget = nullptr; // Ensure it's null on failure
            return hr;
        }
    }

    return hr;
}

void DiscardDeviceResources() {
    SafeRelease(&pRenderTarget);
    SafeRelease(&pTextFormat);
    SafeRelease(&pLargeTextFormat);
    SafeRelease(&pDWriteFactory);
    // Keep pFactory until application exit? Or release here too? Let's release.
    SafeRelease(&pFactory);
}

void OnResize(UINT width, UINT height) {
    if (pRenderTarget) {
        D2D1_SIZE_U size = D2D1::SizeU(width, height);
        pRenderTarget->Resize(size); // Ignore HRESULT for simplicity here
    }
}

// --- Game Initialization ---
void InitGame() {
    srand((unsigned int)time(NULL)); // Seed random number generator
    isOpeningBreakShot = true; // This is the start of a new game, so the next shot is an opening break.
    aiPlannedShotDetails.isValid = false; // Reset AI planned shot
    aiIsDisplayingAim = false;
    aiAimDisplayFramesLeft = 0;
    // ... (rest of InitGame())

    // --- Ensure pocketed list is clear from the absolute start ---
    pocketedThisTurn.clear();

    balls.clear(); // Clear existing balls

    // Reset Player Info (Names should be set by Dialog/wWinMain/ResetGame)
    player1Info.assignedType = BallType::NONE;
    player1Info.ballsPocketedCount = 0;
    // Player 1 Name usually remains ""Player 1""
    player2Info.assignedType = BallType::NONE;
    player2Info.ballsPocketedCount = 0;
    // Player 2 Name is set based on gameMode in ShowNewGameDialog

    // Create Cue Ball (ID 0)
    // Initial position will be set during PRE_BREAK_PLACEMENT state
    balls.push_back({ 0, BallType::CUE_BALL, TABLE_LEFT + TABLE_WIDTH * 0.15f, RACK_POS_Y, 0, 0, CUE_BALL_COLOR, false });

    // --- Create Object Balls (Temporary List) ---
    std::vector<Ball> objectBalls;
    // Solids (1-7, Yellow)
    for (int i = 1; i <= 7; ++i) {
        objectBalls.push_back({ i, BallType::SOLID, 0, 0, 0, 0, SOLID_COLOR, false });
    }
    // Stripes (9-15, Red)
    for (int i = 9; i <= 15; ++i) {
        objectBalls.push_back({ i, BallType::STRIPE, 0, 0, 0, 0, STRIPE_COLOR, false });
    }
    // 8-Ball (ID 8) - Add it to the list to be placed
    objectBalls.push_back({ 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false });


    // --- Racking Logic (Improved) ---
    float spacingX = BALL_RADIUS * 2.0f * 0.866f; // cos(30) for horizontal spacing
    float spacingY = BALL_RADIUS * 2.0f * 1.0f;   // Vertical spacing

    // Define rack positions (0-14 indices corresponding to triangle spots)
    D2D1_POINT_2F rackPositions[15];
    int rackIndex = 0;
    for (int row = 0; row < 5; ++row) {
        for (int col = 0; col <= row; ++col) {
            if (rackIndex >= 15) break;
            float x = RACK_POS_X + row * spacingX;
            float y = RACK_POS_Y + (col - row / 2.0f) * spacingY;
            rackPositions[rackIndex++] = D2D1::Point2F(x, y);
        }
    }

    // Separate 8-ball
    Ball eightBall;
    std::vector<Ball> otherBalls; // Solids and Stripes
    bool eightBallFound = false;
    for (const auto& ball : objectBalls) {
        if (ball.id == 8) {
            eightBall = ball;
            eightBallFound = true;
        }
        else {
            otherBalls.push_back(ball);
        }
    }
    // Ensure 8 ball was actually created (should always be true)
    if (!eightBallFound) {
        // Handle error - perhaps recreate it? For now, proceed.
        eightBall = { 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false };
    }


    // Shuffle the other 14 balls
    // Use std::shuffle if available (C++11 and later) for better randomness
    // std::random_device rd;
    // std::mt19937 g(rd());
    // std::shuffle(otherBalls.begin(), otherBalls.end(), g);
    std::random_shuffle(otherBalls.begin(), otherBalls.end()); // Using deprecated for now

    // --- Place balls into the main 'balls' vector in rack order ---
    // Important: Add the cue ball (already created) first.
    // (Cue ball added at the start of the function now)

    // 1. Place the 8-ball in its fixed position (index 4 for the 3rd row center)
    int eightBallRackIndex = 4;
    eightBall.x = rackPositions[eightBallRackIndex].x;
    eightBall.y = rackPositions[eightBallRackIndex].y;
    eightBall.vx = 0;
    eightBall.vy = 0;
    eightBall.isPocketed = false;
    balls.push_back(eightBall); // Add 8 ball to the main vector

    // 2. Place the shuffled Solids and Stripes in the remaining spots
    size_t otherBallIdx = 0;
    //int otherBallIdx = 0;
    for (int i = 0; i < 15; ++i) {
        if (i == eightBallRackIndex) continue; // Skip the 8-ball spot

        if (otherBallIdx < otherBalls.size()) {
            Ball& ballToPlace = otherBalls[otherBallIdx++];
            ballToPlace.x = rackPositions[i].x;
            ballToPlace.y = rackPositions[i].y;
            ballToPlace.vx = 0;
            ballToPlace.vy = 0;
            ballToPlace.isPocketed = false;
            balls.push_back(ballToPlace); // Add to the main game vector
        }
    }
    // --- End Racking Logic ---


    // --- Determine Who Breaks and Initial State ---
    if (isPlayer2AI) {
        /*// AI Mode: Randomly decide who breaks
        if ((rand() % 2) == 0) {
            // AI (Player 2) breaks
            currentPlayer = 2;
            currentGameState = PRE_BREAK_PLACEMENT; // AI needs to place ball first
            aiTurnPending = true; // Trigger AI logic
        }
        else {
            // Player 1 (Human) breaks
            currentPlayer = 1;
            currentGameState = PRE_BREAK_PLACEMENT; // Human places cue ball
            aiTurnPending = false;*/
        switch (openingBreakMode) {
        case CPU_BREAK:
            currentPlayer = 2; // AI breaks
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = true;
            break;
        case P1_BREAK:
            currentPlayer = 1; // Player 1 breaks
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = false;
            break;
        case FLIP_COIN_BREAK:
            if ((rand() % 2) == 0) { // 0 for AI, 1 for Player 1
                currentPlayer = 2; // AI breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = true;
            }
            else {
                currentPlayer = 1; // Player 1 breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = false;
            }
            break;
        default: // Fallback to CPU break
            currentPlayer = 2;
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = true;
            break;
        }
    }
    else {
        // Human vs Human, Player 1 always breaks (or could add a flip coin for HvsH too if desired)
        currentPlayer = 1;
        currentGameState = PRE_BREAK_PLACEMENT;
        aiTurnPending = false; // No AI involved
    }

    // Reset other relevant game state variables
    foulCommitted = false;
    gameOverMessage = L"""";
    firstBallPocketedAfterBreak = false;
    // pocketedThisTurn cleared at start
    // Reset shot parameters and input flags
    shotPower = 0.0f;
    cueSpinX = 0.0f;
    cueSpinY = 0.0f;
    isAiming = false;
    isDraggingCueBall = false;
    isSettingEnglish = false;
    cueAngle = 0.0f; // Reset aim angle
}


// --- Game Loop ---
void GameUpdate() {
    if (currentGameState == SHOT_IN_PROGRESS) {
        UpdatePhysics();
        CheckCollisions();

        if (AreBallsMoving()) {
            // When all balls stop, clear aiming flags
            isAiming = false;
            aiIsDisplayingAim = false;
            //ProcessShotResults();
        }

        bool pocketed = CheckPockets(); // Store if any ball was pocketed

        // --- Update pocket flash animation timer ---
        if (pocketFlashTimer > 0.0f) {
            pocketFlashTimer -= 0.02f;
            if (pocketFlashTimer < 0.0f) pocketFlashTimer = 0.0f;
        }

        if (!AreBallsMoving()) {
            ProcessShotResults(); // Determine next state based on what happened
        }
    }

    // --- Check if AI needs to act ---
    else if (isPlayer2AI && currentPlayer == 2 && !AreBallsMoving()) {
        if (aiIsDisplayingAim) { // AI has decided a shot and is displaying aim
            aiAimDisplayFramesLeft--;
            if (aiAimDisplayFramesLeft <= 0) {
                aiIsDisplayingAim = false; // Done displaying
                if (aiPlannedShotDetails.isValid) {
                    // Execute the planned shot
                    firstHitBallIdThisShot = -1;
                    cueHitObjectBallThisShot = false;
                    railHitAfterContact = false;
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                    ApplyShot(aiPlannedShotDetails.power, aiPlannedShotDetails.angle, aiPlannedShotDetails.spinX, aiPlannedShotDetails.spinY);
                    aiPlannedShotDetails.isValid = false; // Clear the planned shot
                }
                currentGameState = SHOT_IN_PROGRESS;
                foulCommitted = false;
                pocketedThisTurn.clear();
            }
            // Else, continue displaying aim
        }
        else if (aiTurnPending) { // AI needs to start its decision process
            // Valid states for AI to start thinking
            /*/if (currentGameState == PRE_BREAK_PLACEMENT && isOpeningBreakShot) {*/
            //newcode 1 commented out
            /*if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT && currentPlayer == 2 && isPlayer2AI) {
                // Handle the break shot
                AIBreakShot();
            }*/ //new code 1 end  
            /*else if (currentGameState == PRE_BREAK_PLACEMENT || currentGameState == BREAKING ||
                currentGameState == PLAYER2_TURN || currentGameState == BALL_IN_HAND_P2) {*/

                // aiTurnPending might be consumed by AIBreakShot or remain for next cycle if needed
        /* } //new code 2 commented out
        else if (currentGameState == BALL_IN_HAND_P2 && currentPlayer == 2 && isPlayer2AI) {
            AIPlaceCueBall(); // AI places the ball first
            // After placement, AI needs to decide its shot.
            // Transition to a state where AIMakeDecision will be called for shot selection.
            currentGameState = PLAYER2_TURN; // Or a specific AI_AIMING_AFTER_PLACEMENT state
                                             // aiTurnPending remains true to trigger AIMakeDecision next.
        }
        else if (currentGameState == PLAYER2_TURN && currentPlayer == 2 && isPlayer2AI) {
            // This is for a normal turn (not break, not immediately after ball-in-hand placement)

                currentGameState = AI_THINKING; // Set state to indicate AI is processing
                aiTurnPending = false;         // Consume the pending turn flag
                AIMakeDecision();              // For normal shots (non-break)
            }
            else {
                // Not a state where AI should act
                aiTurnPending = false;
            }*/
            // 2b) AI is ready to think (pending flag)
            // **1) Ball-in-Hand** let AI place the cue ball first
            if (currentGameState == BALL_IN_HAND_P2) {
                // Step 1: AI places the cue ball.
                AIPlaceCueBall();
                // Step 2: Transition to thinking state for shot decision.
                currentGameState = AI_THINKING; //newcode5
                // Step 3: Consume the pending flag for the placement phase.
                //         AIMakeDecision will handle shot planning now.
                aiTurnPending = false; //newcode5
                // Step 4: AI immediately decides the shot from the new position.
                AIMakeDecision(); //newcode5
            }
            // **2) Opening break** special break shot logic
            else if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
                AIBreakShot();
            }
            else if (currentGameState == PLAYER2_TURN || currentGameState == BREAKING) { //newcode5
                // General turn for AI to think (not ball-in-hand, not initial break placement)
                currentGameState = AI_THINKING; //newcode5
                aiTurnPending = false; // Consume the flag //newcode5
                AIMakeDecision(); //newcode5
            }
            // **3) Otherwise** normal shot planning
            /*else { //orig uncommented oldcode5
                currentGameState = AI_THINKING;
                aiTurnPending = false;
                AIMakeDecision();
            }*/
        }

        //} //bracefix
        // If current state is AI_THINKING but not displaying aim, then AI decision has already been made
    }
}

// --- Physics and Collision ---
void UpdatePhysics() {
    for (size_t i = 0; i < balls.size(); ++i) {
        Ball& b = balls[i];
        if (!b.isPocketed) {
            b.x += b.vx;
            b.y += b.vy;

            // Apply friction
            b.vx *= FRICTION;
            b.vy *= FRICTION;

            // Stop balls if velocity is very low
            if (GetDistanceSq(b.vx, b.vy, 0, 0) < MIN_VELOCITY_SQ) {
                b.vx = 0;
                b.vy = 0;
            }
        }
    }
}

void CheckCollisions() {
    float left = TABLE_LEFT;
    float right = TABLE_RIGHT;
    float top = TABLE_TOP;
    float bottom = TABLE_BOTTOM;
    const float pocketMouthCheckRadiusSq = (POCKET_RADIUS + BALL_RADIUS) * (POCKET_RADIUS + BALL_RADIUS) * 1.1f;

    // --- Reset Per-Frame Sound Flags ---
    bool playedWallSoundThisFrame = false;
    bool playedCollideSoundThisFrame = false;
    // ---

    for (size_t i = 0; i < balls.size(); ++i) {
        Ball& b1 = balls[i];
        if (b1.isPocketed) continue;

        bool nearPocket[6];
        for (int p = 0; p < 6; ++p) {
            nearPocket[p] = GetDistanceSq(b1.x, b1.y, pocketPositions[p].x, pocketPositions[p].y) < pocketMouthCheckRadiusSq;
        }
        bool nearTopLeftPocket = nearPocket[0];
        bool nearTopMidPocket = nearPocket[1];
        bool nearTopRightPocket = nearPocket[2];
        bool nearBottomLeftPocket = nearPocket[3];
        bool nearBottomMidPocket = nearPocket[4];
        bool nearBottomRightPocket = nearPocket[5];

        bool collidedWallThisBall = false;

        // --- Ball-Wall Collisions ---
        // (Check logic unchanged, added sound calls and railHitAfterContact update)
        // Left Wall
        if (b1.x - BALL_RADIUS < left) {
            if (!nearTopLeftPocket && !nearBottomLeftPocket) {
                b1.x = left + BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }
        // Right Wall
        if (b1.x + BALL_RADIUS > right) {
            if (!nearTopRightPocket && !nearBottomRightPocket) {
                b1.x = right - BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }
        // Top Wall
        if (b1.y - BALL_RADIUS < top) {
            if (!nearTopLeftPocket && !nearTopMidPocket && !nearTopRightPocket) {
                b1.y = top + BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }
        // Bottom Wall
        if (b1.y + BALL_RADIUS > bottom) {
            if (!nearBottomLeftPocket && !nearBottomMidPocket && !nearBottomRightPocket) {
                b1.y = bottom - BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }

        // Spin effect (Unchanged)
        if (collidedWallThisBall) {
            if (b1.x <= left + BALL_RADIUS || b1.x >= right - BALL_RADIUS) { b1.vy += cueSpinX * b1.vx * 0.05f; }
            if (b1.y <= top + BALL_RADIUS || b1.y >= bottom - BALL_RADIUS) { b1.vx -= cueSpinY * b1.vy * 0.05f; }
            cueSpinX *= 0.7f; cueSpinY *= 0.7f;
        }


        // --- Ball-Ball Collisions ---
        for (size_t j = i + 1; j < balls.size(); ++j) {
            Ball& b2 = balls[j];
            if (b2.isPocketed) continue;

            float dx = b2.x - b1.x; float dy = b2.y - b1.y;
            float distSq = dx * dx + dy * dy;
            float minDist = BALL_RADIUS * 2.0f;

            if (distSq > 1e-6 && distSq < minDist * minDist) {
                float dist = sqrtf(distSq);
                float overlap = minDist - dist;
                float nx = dx / dist; float ny = dy / dist;

                // Separation (Unchanged)
                b1.x -= overlap * 0.5f * nx; b1.y -= overlap * 0.5f * ny;
                b2.x += overlap * 0.5f * nx; b2.y += overlap * 0.5f * ny;

                float rvx = b1.vx - b2.vx; float rvy = b1.vy - b2.vy;
                float velAlongNormal = rvx * nx + rvy * ny;

                if (velAlongNormal > 0) { // Colliding
                    // --- Play Ball Collision Sound ---
                    if (!playedCollideSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""poolballhit.wav"")).detach();
                        playedCollideSoundThisFrame = true; // Set flag
                    }
                    // --- End Sound ---

                    // --- NEW: Track First Hit and Cue/Object Collision ---
                    if (firstHitBallIdThisShot == -1) { // If first hit hasn't been recorded yet
                        if (b1.id == 0) { // Cue ball hit b2 first
                            firstHitBallIdThisShot = b2.id;
                            cueHitObjectBallThisShot = true;
                        }
                        else if (b2.id == 0) { // Cue ball hit b1 first
                            firstHitBallIdThisShot = b1.id;
                            cueHitObjectBallThisShot = true;
                        }
                        // If neither is cue ball, doesn't count as first hit for foul purposes
                    }
                    else if (b1.id == 0 || b2.id == 0) {
                        // Track subsequent cue ball collisions with object balls
                        cueHitObjectBallThisShot = true;
                    }
                    // --- End First Hit Tracking ---


                    // Impulse (Unchanged)
                    float impulse = velAlongNormal;
                    b1.vx -= impulse * nx; b1.vy -= impulse * ny;
                    b2.vx += impulse * nx; b2.vy += impulse * ny;

                    // Spin Transfer (Unchanged)
                    if (b1.id == 0 || b2.id == 0) {
                        float spinEffectFactor = 0.08f;
                        b1.vx += (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                        b1.vy += (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                        b2.vx -= (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                        b2.vy -= (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                        cueSpinX *= 0.85f; cueSpinY *= 0.85f;
                    }
                }
            }
        } // End ball-ball loop
    } // End ball loop
} // End CheckCollisions


bool CheckPockets() {
    bool ballPocketedThisCheck = false; // Local flag for this specific check run
    for (size_t i = 0; i < balls.size(); ++i) {
        Ball& b = balls[i];
        if (!b.isPocketed) { // Only check balls that aren't already flagged as pocketed
            for (int p = 0; p < 6; ++p) {
                float distSq = GetDistanceSq(b.x, b.y, pocketPositions[p].x, pocketPositions[p].y);
                // --- Use updated POCKET_RADIUS ---
                if (distSq < POCKET_RADIUS * POCKET_RADIUS) {
                    b.isPocketed = true;
                    b.vx = b.vy = 0;
                    pocketedThisTurn.push_back(b.id);

                    // --- Play Pocket Sound (Threaded) ---
                    if (!ballPocketedThisCheck) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""pocket.wav"")).detach();
                        ballPocketedThisCheck = true;
                    }
                    // --- End Sound ---

                    break; // Ball is pocketed
                }
            }
        }
    }
    return ballPocketedThisCheck;
}

bool AreBallsMoving() {
    for (size_t i = 0; i < balls.size(); ++i) {
        if (!balls[i].isPocketed && (balls[i].vx != 0 || balls[i].vy != 0)) {
            return true;
        }
    }
    return false;
}

void RespawnCueBall(bool behindHeadstring) { // 'behindHeadstring' only relevant for initial break placement
    Ball* cueBall = GetCueBall();
    if (cueBall) {
        // Reset position to a default
        //disabled for behind headstring (now move anywhere)
        /*cueBall->x = HEADSTRING_X * 0.5f;
        cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;*/
        // Reset position to a default:
        if (behindHeadstring) {
            // Opening break: kitchen center
            cueBall->x = HEADSTRING_X * 0.5f;
            cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
        }
        else {
            // Ball-in-hand (foul): center of full table
            cueBall->x = TABLE_LEFT + TABLE_WIDTH / 2.0f;
            cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
        }
        cueBall->vx = 0;
        cueBall->vy = 0;
        cueBall->isPocketed = false;

        // Set state based on who gets ball-in-hand
        /*// 'currentPlayer' already reflects who's turn it is NOW (switched before calling this)*/
        // 'currentPlayer' has already been switched to the player whose turn it will be.
        // The 'behindHeadstring' parameter to RespawnCueBall is mostly for historical reasons / initial setup.
        if (currentPlayer == 1) { // Player 2 (AI/Human) fouled, Player 1 (Human) gets ball-in-hand
            currentGameState = BALL_IN_HAND_P1;
            aiTurnPending = false; // Ensure AI flag off
        }
        else { // Player 1 (Human) fouled, Player 2 gets ball-in-hand
            if (isPlayer2AI) {
                // --- CONFIRMED FIX: Set correct state for AI Ball-in-Hand ---
                currentGameState = BALL_IN_HAND_P2; // AI now needs to place the ball
                aiTurnPending = true; // Trigger AI logic (will call AIPlaceCueBall first)
            }
            else { // Human Player 2
                currentGameState = BALL_IN_HAND_P2;
                aiTurnPending = false; // Ensure AI flag off
            }
        }
        // Handle initial placement state correctly if called from InitGame
        /*if (behindHeadstring && currentGameState != PRE_BREAK_PLACEMENT) {
            // This case might need review depending on exact initial setup flow,
            // but the foul logic above should now be correct.
            // Let's ensure initial state is PRE_BREAK_PLACEMENT if behindHeadstring is true.*/
            //currentGameState = PRE_BREAK_PLACEMENT;
    }
}
//}


// --- Game Logic ---

void ApplyShot(float power, float angle, float spinX, float spinY) {
    Ball* cueBall = GetCueBall();
    if (cueBall) {

        // --- Play Cue Strike Sound (Threaded) ---
        if (power > 0.1f) { // Only play if it's an audible shot
            std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
        }
        // --- End Sound ---

        cueBall->vx = cosf(angle) * power;
        cueBall->vy = sinf(angle) * power;

        // Apply English (Spin) - Simplified effect (Unchanged)
        cueBall->vx += sinf(angle) * spinY * 0.5f;
        cueBall->vy -= cosf(angle) * spinY * 0.5f;
        cueBall->vx -= cosf(angle) * spinX * 0.5f;
        cueBall->vy -= sinf(angle) * spinX * 0.5f;

        // Store spin (Unchanged)
        cueSpinX = spinX;
        cueSpinY = spinY;

        // --- Reset Foul Tracking flags for the new shot ---
        // (Also reset in LBUTTONUP, but good to ensure here too)
        firstHitBallIdThisShot = -1;      // No ball hit yet
        cueHitObjectBallThisShot = false; // Cue hasn't hit anything yet
        railHitAfterContact = false;     // No rail hit after contact yet
        // --- End Reset ---

                // If this was the opening break shot, clear the flag
        if (isOpeningBreakShot) {
            isOpeningBreakShot = false; // Mark opening break as taken
        }
    }
}


void ProcessShotResults() {
    bool cueBallPocketed = false;
    bool eightBallPocketed = false;
    bool playerContinuesTurn = false;

    // --- Preliminary Analysis & Score Update ---
    // First, update the counts to ensure all subsequent logic has the correct score.
    // This is the key fix for the off-by-one visual error.
    PlayerInfo& shootingPlayer = (currentPlayer == 1) ? player1Info : player2Info;
    int ownBallsPocketedThisTurn = 0;

    for (int id : pocketedThisTurn) {
        Ball* b = GetBallById(id);
        if (!b) continue;
        if (b->id == 0) cueBallPocketed = true;
        else if (b->id == 8) eightBallPocketed = true;
        else {
            if (b->type == player1Info.assignedType && player1Info.assignedType != BallType::NONE) player1Info.ballsPocketedCount++;
            else if (b->type == player2Info.assignedType && player2Info.assignedType != BallType::NONE) player2Info.ballsPocketedCount++;

            if (b->type == shootingPlayer.assignedType) {
                ownBallsPocketedThisTurn++;
            }
        }
    }

    if (ownBallsPocketedThisTurn > 0) {
        playerContinuesTurn = true;
    }

    // --- Step 1: Check for Game-Ending 8-Ball Shot ---
    if (eightBallPocketed) {
        CheckGameOverConditions(true, cueBallPocketed);
        if (currentGameState == GAME_OVER) { pocketedThisTurn.clear(); return; }
    }

    // --- Step 2: Check for Fouls ---
    // This logic is now more robust. A foul is only checked against the state of the game *before* the shot.
    // The fact that the player is NOW on the 8-ball doesn't make their previous legal shot a foul.
    bool turnFoul = false;
    Ball* firstHit = GetBallById(firstHitBallIdThisShot);

    if (cueBallPocketed) {
        turnFoul = true;
    }
    else if (!firstHit) {
        turnFoul = true; // Hit nothing.
    }
    else {
        // Check for illegal first hit based on the rules BEFORE this shot was taken.
        bool wasOnEightBall = (shootingPlayer.assignedType != BallType::NONE && (shootingPlayer.ballsPocketedCount - ownBallsPocketedThisTurn) >= 7);

        if (player1Info.assignedType != BallType::NONE) { // Colors are assigned
            if (wasOnEightBall) {
                if (firstHit->id != 8) turnFoul = true; // Was on 8-ball, but didn't hit it first.
            }
            else {
                if (firstHit->type != shootingPlayer.assignedType) turnFoul = true; // Wasn't on 8-ball, but hit wrong type.
            }
        }
    }

    if (!turnFoul && cueHitObjectBallThisShot && !railHitAfterContact && pocketedThisTurn.empty()) {
        turnFoul = true; // No rail after contact.
    }
    foulCommitted = turnFoul;

    // --- Step 3: Final State Transition ---
    if (foulCommitted) {
        SwitchTurns();
        RespawnCueBall(false);
    }
    else if (player1Info.assignedType == BallType::NONE && !pocketedThisTurn.empty() && !cueBallPocketed) {
        // Table is open, assign types.
        for (int id : pocketedThisTurn) {
            Ball* b = GetBallById(id);
            if (b && b->type != BallType::EIGHT_BALL) {
                AssignPlayerBallTypes(b->type);
                break;
            }
        }
        CheckAndTransitionToPocketChoice(currentPlayer); // Player continues turn
    }
    else if (playerContinuesTurn) {
        // Player legally pocketed a ball. Check if they are now on the 8-ball.
        CheckAndTransitionToPocketChoice(currentPlayer);
    }
    else {
        // No legal ball pocketed, no foul. Switch turns.
        SwitchTurns();
    }

    pocketedThisTurn.clear();
}

bool AssignPlayerBallTypes(BallType firstPocketedType) {
    if (firstPocketedType == BallType::SOLID || firstPocketedType == BallType::STRIPE) {
        if (currentPlayer == 1) {
            player1Info.assignedType = firstPocketedType;
            player2Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
        }
        else {
            player2Info.assignedType = firstPocketedType;
            player1Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
        }
        return true; // Assignment was successful
    }
    return false; // No assignment made (e.g., 8-ball was pocketed on break)
}
    // If 8-ball was first (illegal on break generally), rules vary.
    // Here, we might ignore assignment until a solid/stripe is pocketed legally.
    // Or assign based on what *else* was pocketed, if anything.
    // Simplification: Assignment only happens on SOLID or STRIPE first pocket.


void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed) {
    if (!eightBallPocketed) return;

    PlayerInfo& shootingPlayer = (currentPlayer == 1) ? player1Info : player2Info;
    PlayerInfo& opponentPlayer = (currentPlayer == 1) ? player2Info : player1Info;
    bool shooterWasOn8Ball = IsPlayerOnEightBall(currentPlayer);
    int pocketThe8BallEntered = -1;

    // Find which pocket the 8-ball actually went into
    Ball* b = GetBallById(8);
    if (b) {
        for (int p_idx = 0; p_idx < 6; ++p_idx) {
            if (GetDistanceSq(b->x, b->y, pocketPositions[p_idx].x, pocketPositions[p_idx].y) < POCKET_RADIUS * POCKET_RADIUS * 1.5f) {
                pocketThe8BallEntered = p_idx;
                break;
            }
        }
    }

    // Case 1: 8-ball pocketed on the break (or before colors assigned)
    if (player1Info.assignedType == BallType::NONE) {
        if (b) { // Re-spot the 8-ball
            b->isPocketed = false;
            b->x = RACK_POS_X;
            b->y = RACK_POS_Y;
            b->vx = b->vy = 0;
        }
        if (cueBallPocketed) {
            foulCommitted = true; // Let ProcessShotResults handle the foul, game doesn't end.
        }
        return; // Game continues
    }

    // Case 2: Normal gameplay win/loss conditions
    int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;

    if (!shooterWasOn8Ball) {
        // Loss: Pocketed 8-ball before clearing own group.
        gameOverMessage = opponentPlayer.name + L"" Wins! ("" + shootingPlayer.name + L"" pocketed 8-ball early)"";
    }
    else if (cueBallPocketed) {
        // Loss: Scratched while shooting for the 8-ball.
        gameOverMessage = opponentPlayer.name + L"" Wins! ("" + shootingPlayer.name + L"" scratched on 8-ball)"";
    }
    else if (calledPocket == -1) {
        // Loss: Pocketed 8-ball without calling a pocket. THIS IS THE KEY FIX FOR YOUR REPORTED PROBLEM.
        gameOverMessage = opponentPlayer.name + L"" Wins! ("" + shootingPlayer.name + L"" did not call a pocket)"";
    }
    else if (pocketThe8BallEntered != calledPocket) {
        // Loss: Pocketed 8-ball in the wrong pocket.
        gameOverMessage = opponentPlayer.name + L"" Wins! ("" + shootingPlayer.name + L"" 8-ball in wrong pocket)"";
    }
    else {
        // WIN! Pocketed 8-ball in the called pocket without a foul.
        gameOverMessage = shootingPlayer.name + L"" Wins!"";
    }

    currentGameState = GAME_OVER;
}


void SwitchTurns() {
    currentPlayer = (currentPlayer == 1) ? 2 : 1;
    isAiming = false;
    shotPower = 0;
    CheckAndTransitionToPocketChoice(currentPlayer); // Use the new helper
}

void AIBreakShot() {
    Ball* cueBall = GetCueBall();
    if (!cueBall) return;

    // This function is called when it's AI's turn for the opening break and state is PRE_BREAK_PLACEMENT.
    // AI will place the cue ball and then plan the shot.
    if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
        // Place cue ball in the kitchen randomly
        /*float kitchenMinX = TABLE_LEFT + BALL_RADIUS; // [cite: 1071, 1072, 1587]
        float kitchenMaxX = HEADSTRING_X - BALL_RADIUS; // [cite: 1072, 1078, 1588]
        float kitchenMinY = TABLE_TOP + BALL_RADIUS; // [cite: 1071, 1072, 1588]
        float kitchenMaxY = TABLE_BOTTOM - BALL_RADIUS; // [cite: 1072, 1073, 1589]*/

        // --- AI Places Cue Ball for Break ---
// Decide if placing center or side. For simplicity, let's try placing slightly off-center
// towards one side for a more angled break, or center for direct apex hit.
// A common strategy is to hit the second ball of the rack.

        float placementY = RACK_POS_Y; // Align vertically with the rack center
        float placementX;

        // Randomly choose a side or center-ish placement for variation.
        int placementChoice = rand() % 3; // 0: Left-ish, 1: Center-ish, 2: Right-ish in kitchen

        if (placementChoice == 0) { // Left-ish
            placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) - (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the left within kitchen
        }
        else if (placementChoice == 2) { // Right-ish
            placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) + (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the right within kitchen
        }
        else { // Center-ish
            placementX = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // Roughly center of kitchen
        }
        placementX = std::max(TABLE_LEFT + BALL_RADIUS + 1.0f, std::min(placementX, HEADSTRING_X - BALL_RADIUS - 1.0f)); // Clamp within kitchen X

        bool validPos = false;
        int attempts = 0;
        while (!validPos && attempts < 100) {
            /*cueBall->x = kitchenMinX + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxX - kitchenMinX)); // [cite: 1589]
            cueBall->y = kitchenMinY + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxY - kitchenMinY)); // [cite: 1590]
            if (IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1591]
                validPos = true; // [cite: 1591]*/
                // Try the chosen X, but vary Y slightly to find a clear spot
            cueBall->x = placementX;
            cueBall->y = placementY + (static_cast<float>(rand() % 100 - 50) / 100.0f) * BALL_RADIUS * 2.0f; // Vary Y a bit
            cueBall->y = std::max(TABLE_TOP + BALL_RADIUS + 1.0f, std::min(cueBall->y, TABLE_BOTTOM - BALL_RADIUS - 1.0f)); // Clamp Y

            if (IsValidCueBallPosition(cueBall->x, cueBall->y, true /* behind headstring */)) {
                validPos = true;
            }
            attempts++; // [cite: 1592]
        }
        if (!validPos) {
            // Fallback position
            /*cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // [cite: 1071, 1078, 1593]
            cueBall->y = (TABLE_TOP + TABLE_BOTTOM) * 0.5f; // [cite: 1071, 1073, 1594]
            if (!IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1594]
                cueBall->x = HEADSTRING_X - BALL_RADIUS * 2; // [cite: 1072, 1078, 1594]
                cueBall->y = RACK_POS_Y; // [cite: 1080, 1595]
            }
        }
        cueBall->vx = 0; // [cite: 1595]
        cueBall->vy = 0; // [cite: 1596]

        // Plan a break shot: aim at the center of the rack (apex ball)
        float targetX = RACK_POS_X; // [cite: 1079] Aim for the apex ball X-coordinate
        float targetY = RACK_POS_Y; // [cite: 1080] Aim for the apex ball Y-coordinate

        float dx = targetX - cueBall->x; // [cite: 1599]
        float dy = targetY - cueBall->y; // [cite: 1600]
        float shotAngle = atan2f(dy, dx); // [cite: 1600]
        float shotPowerValue = MAX_SHOT_POWER; // [cite: 1076, 1600] Use MAX_SHOT_POWER*/

            cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.75f; // A default safe spot in kitchen
            cueBall->y = RACK_POS_Y;
        }
        cueBall->vx = 0; cueBall->vy = 0;

        // --- AI Plans the Break Shot ---
        float targetX, targetY;
        // If cue ball is near center of kitchen width, aim for apex.
        // Otherwise, aim for the second ball on the side the cue ball is on (for a cut break).
        float kitchenCenterRegion = (HEADSTRING_X - TABLE_LEFT) * 0.3f; // Define a ""center"" region
        if (std::abs(cueBall->x - (TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) / 2.0f)) < kitchenCenterRegion / 2.0f) {
            // Center-ish placement: Aim for the apex ball (ball ID 1 or first ball in rack)
            targetX = RACK_POS_X; // Apex ball X
            targetY = RACK_POS_Y; // Apex ball Y
        }
        else {
            // Side placement: Aim to hit the ""second"" ball of the rack for a wider spread.
            // This is a simplification. A more robust way is to find the actual second ball.
            // For now, aim slightly off the apex towards the side the cue ball is on.
            targetX = RACK_POS_X + BALL_RADIUS * 2.0f * 0.866f; // X of the second row of balls
            targetY = RACK_POS_Y + ((cueBall->y > RACK_POS_Y) ? -BALL_RADIUS : BALL_RADIUS); // Aim at the upper or lower of the two second-row balls
        }

        float dx = targetX - cueBall->x;
        float dy = targetY - cueBall->y;
        float shotAngle = atan2f(dy, dx);
        float shotPowerValue = MAX_SHOT_POWER * (0.9f + (rand() % 11) / 100.0f); // Slightly vary max power

        // Store planned shot details for the AI
        /*aiPlannedShotDetails.angle = shotAngle; // [cite: 1102, 1601]
        aiPlannedShotDetails.power = shotPowerValue; // [cite: 1102, 1601]
        aiPlannedShotDetails.spinX = 0.0f; // [cite: 1102, 1601] No spin for a standard power break
        aiPlannedShotDetails.spinY = 0.0f; // [cite: 1103, 1602]
        aiPlannedShotDetails.isValid = true; // [cite: 1103, 1602]*/

        aiPlannedShotDetails.angle = shotAngle;
        aiPlannedShotDetails.power = shotPowerValue;
        aiPlannedShotDetails.spinX = 0.0f; // No spin for break usually
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true;

        // Update global cue parameters for immediate visual feedback if DrawAimingAids uses them
        /*::cueAngle = aiPlannedShotDetails.angle;      // [cite: 1109, 1603] Update global cueAngle
        ::shotPower = aiPlannedShotDetails.power;     // [cite: 1109, 1604] Update global shotPower
        ::cueSpinX = aiPlannedShotDetails.spinX;    // [cite: 1109]
        ::cueSpinY = aiPlannedShotDetails.spinY;    // [cite: 1110]*/

        ::cueAngle = aiPlannedShotDetails.angle;
        ::shotPower = aiPlannedShotDetails.power;
        ::cueSpinX = aiPlannedShotDetails.spinX;
        ::cueSpinY = aiPlannedShotDetails.spinY;

        // Set up for AI display via GameUpdate
        /*aiIsDisplayingAim = true;                   // [cite: 1104] Enable AI aiming visualization
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES; // [cite: 1105] Set duration for display

        currentGameState = AI_THINKING; // [cite: 1081] Transition to AI_THINKING state.
                                        // GameUpdate will handle the aiAimDisplayFramesLeft countdown
                                        // and then execute the shot using aiPlannedShotDetails.
                                        // isOpeningBreakShot will be set to false within ApplyShot.

        // No immediate ApplyShot or sound here; GameUpdate's AI execution logic will handle it.*/

        aiIsDisplayingAim = true;
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
        currentGameState = AI_THINKING; // State changes to AI_THINKING, GameUpdate will handle shot execution after display

        return; // The break shot is now planned and will be executed by GameUpdate
    }

    // 2. If not in PRE_BREAK_PLACEMENT (e.g., if this function were called at other times,
    //    though current game logic only calls it for PRE_BREAK_PLACEMENT)
    //    This part can be extended if AIBreakShot needs to handle other scenarios.
    //    For now, the primary logic is above.
}

// --- Helper Functions ---

Ball* GetBallById(int id) {
    for (size_t i = 0; i < balls.size(); ++i) {
        if (balls[i].id == id) {
            return &balls[i];
        }
    }
    return nullptr;
}

Ball* GetCueBall() {
    return GetBallById(0);
}

float GetDistance(float x1, float y1, float x2, float y2) {
    return sqrtf(GetDistanceSq(x1, y1, x2, y2));
}

float GetDistanceSq(float x1, float y1, float x2, float y2) {
    float dx = x2 - x1;
    float dy = y2 - y1;
    return dx * dx + dy * dy;
}

bool IsValidCueBallPosition(float x, float y, bool checkHeadstring) {
    // Basic bounds check (inside cushions)
    float left = TABLE_LEFT + CUSHION_THICKNESS + BALL_RADIUS;
    float right = TABLE_RIGHT - CUSHION_THICKNESS - BALL_RADIUS;
    float top = TABLE_TOP + CUSHION_THICKNESS + BALL_RADIUS;
    float bottom = TABLE_BOTTOM - CUSHION_THICKNESS - BALL_RADIUS;

    if (x < left || x > right || y < top || y > bottom) {
        return false;
    }

    // Check headstring restriction if needed
    if (checkHeadstring && x >= HEADSTRING_X) {
        return false;
    }

    // Check overlap with other balls
    for (size_t i = 0; i < balls.size(); ++i) {
        if (balls[i].id != 0 && !balls[i].isPocketed) { // Don't check against itself or pocketed balls
            if (GetDistanceSq(x, y, balls[i].x, balls[i].y) < (BALL_RADIUS * 2.0f) * (BALL_RADIUS * 2.0f)) {
                return false; // Overlapping another ball
            }
        }
    }

    return true;
}

// --- NEW HELPER FUNCTION IMPLEMENTATIONS ---

// Checks if a player has pocketed all their balls and is now on the 8-ball.
bool IsPlayerOnEightBall(int player) {
    PlayerInfo& playerInfo = (player == 1) ? player1Info : player2Info;
    if (playerInfo.assignedType != BallType::NONE && playerInfo.assignedType != BallType::EIGHT_BALL && playerInfo.ballsPocketedCount >= 7) {
        Ball* eightBall = GetBallById(8);
        return (eightBall && !eightBall->isPocketed);
    }
    return false;
}

// Centralized logic to enter the ""choosing pocket"" state. This fixes the indicator bugs.
void CheckAndTransitionToPocketChoice(int playerID) {
    bool needsToCall = IsPlayerOnEightBall(playerID);
    int* calledPocketForPlayer = (playerID == 1) ? &calledPocketP1 : &calledPocketP2;

    if (needsToCall && *calledPocketForPlayer == -1) { // Only transition if a pocket hasn't been called yet
        pocketCallMessage = ((playerID == 1) ? player1Info.name : player2Info.name) + L"": Choose a pocket..."";
        if (playerID == 1) {
            currentGameState = CHOOSING_POCKET_P1;
        }
        else { // Player 2
            if (isPlayer2AI) {
                currentGameState = AI_THINKING;
                aiTurnPending = true;
            }
            else {
                currentGameState = CHOOSING_POCKET_P2;
            }
        }
        if (!(playerID == 2 && isPlayer2AI)) {
            *calledPocketForPlayer = 5; // Default to top-right if none chosen
        }
    }
    else {
        // Player does not need to call a pocket (or already has), proceed to normal turn.
        pocketCallMessage = L""""; // Clear any message
        currentGameState = (playerID == 1) ? PLAYER1_TURN : PLAYER2_TURN;
        if (playerID == 2 && isPlayer2AI) {
            aiTurnPending = true;
        }
    }
}

template <typename T>
void SafeRelease(T** ppT) {
    if (*ppT) {
        (*ppT)->Release();
        *ppT = nullptr;
    }
}

// --- Helper Function for Line Segment Intersection ---
// Finds intersection point of line segment P1->P2 and line segment P3->P4
// Returns true if they intersect, false otherwise. Stores intersection point in 'intersection'.
bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection)
{
    float denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);

    // Check if lines are parallel or collinear
    if (fabs(denominator) < 1e-6) {
        return false;
    }

    float ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
    float ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;

    // Check if intersection point lies on both segments
    if (ua >= 0.0f && ua <= 1.0f && ub >= 0.0f && ub <= 1.0f) {
        intersection.x = p1.x + ua * (p2.x - p1.x);
        intersection.y = p1.y + ua * (p2.y - p1.y);
        return true;
    }

    return false;
}

// --- INSERT NEW HELPER FUNCTION HERE ---
// Calculates the squared distance from point P to the line segment AB.
float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b) {
    float l2 = GetDistanceSq(a.x, a.y, b.x, b.y);
    if (l2 == 0.0f) return GetDistanceSq(p.x, p.y, a.x, a.y); // Segment is a point
    // Consider P projecting onto the line AB infinite line
    // t = [(P-A) . (B-A)] / |B-A|^2
    float t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
    t = std::max(0.0f, std::min(1.0f, t)); // Clamp t to the segment [0, 1]
    // Projection falls on the segment
    D2D1_POINT_2F projection = D2D1::Point2F(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));
    return GetDistanceSq(p.x, p.y, projection.x, projection.y);
}
// --- End New Helper ---

// --- NEW AI Implementation Functions ---

// Main entry point for AI turn
void AIMakeDecision() {
    //AIShotInfo bestShot = { false }; // Declare here
    // This function is called when currentGameState is AI_THINKING (for a normal shot decision)
    Ball* cueBall = GetCueBall();
    if (!cueBall || !isPlayer2AI || currentPlayer != 2) {
        aiPlannedShotDetails.isValid = false; // Ensure no shot if conditions not met
        return;
    }

    // Phase 1: Placement if needed (Ball-in-Hand or Initial Break)
    /*if ((isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) || currentGameState == BALL_IN_HAND_P2) {
        AIPlaceCueBall(); // Handles kitchen placement for break or regular ball-in-hand
        if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
            currentGameState = BREAKING; // Now AI needs to decide the break shot parameters
        }
        // For regular BALL_IN_HAND_P2, after placement, it will proceed to find a shot.
    }*/

    aiPlannedShotDetails.isValid = false; // Default to no valid shot found yet for this decision cycle
    // Note: isOpeningBreakShot is false here because AIBreakShot handles the break.

     // Phase 2: Decide shot parameters (Break or Normal play)
    /*if (isOpeningBreakShot && currentGameState == BREAKING) {
        // Force cue ball into center of kitchen
        cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f;
        cueBall->y = (TABLE_TOP + TABLE_BOTTOM) * 0.5f;
        cueBall->vx = cueBall->vy = 0.0f;

        float rackCenterX = RACK_POS_X + BALL_RADIUS * 2.0f * 0.866f * 2.0f;
        float rackCenterY = RACK_POS_Y;
        float dx = rackCenterX - cueBall->x;
        float dy = rackCenterY - cueBall->y;

        aiPlannedShotDetails.angle = atan2f(dy, dx);
        aiPlannedShotDetails.power = MAX_SHOT_POWER;
        aiPlannedShotDetails.spinX = 0.0f;
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true;

        // Apply shot immediately
        cueAngle = aiPlannedShotDetails.angle;
        shotPower = aiPlannedShotDetails.power;
        cueSpinX = aiPlannedShotDetails.spinX;
        cueSpinY = aiPlannedShotDetails.spinY;

        firstHitBallIdThisShot = -1;
        cueHitObjectBallThisShot = false;
        railHitAfterContact = false;
        isAiming = false;
        aiIsDisplayingAim = false;
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
        //bool aiIsDisplayingAim = true;

        std::thread([](const TCHAR* soundName) {
            PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT);
            }, TEXT(""cue.wav"")).detach();

            ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);
            currentGameState = SHOT_IN_PROGRESS;
            isOpeningBreakShot = false;
            aiTurnPending = false;
            pocketedThisTurn.clear();
            return;
    }
    else {*/
    // --- Normal AI Shot Decision (using AIFindBestShot) ---
    AIShotInfo bestShot = AIFindBestShot(); // bugtraq
    //bestShot = AIFindBestShot(); // bugtraq
    if (bestShot.possible) {
        aiPlannedShotDetails.angle = bestShot.angle;
        aiPlannedShotDetails.power = bestShot.power;
        aiPlannedShotDetails.spinX = 0.0f; // AI doesn't use spin yet
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true;
    }
    else {
        // Safety tap if no better shot found
        // Try to hit the closest 'own' ball gently or any ball if types not assigned
        Ball* ballToNudge = nullptr;
        float minDistSq = -1.0f;
        BallType aiTargetType = player2Info.assignedType;
        bool mustHit8Ball = (aiTargetType != BallType::NONE && player2Info.ballsPocketedCount >= 7);

        for (auto& b : balls) {
            if (b.isPocketed || b.id == 0) continue;
            bool canHitThis = false;
            if (mustHit8Ball) canHitThis = (b.id == 8);
            else if (aiTargetType != BallType::NONE) canHitThis = (b.type == aiTargetType);
            else canHitThis = (b.id != 8); // Can hit any non-8-ball if types not assigned

            if (canHitThis) {
                float dSq = GetDistanceSq(cueBall->x, cueBall->y, b.x, b.y);
                if (ballToNudge == nullptr || dSq < minDistSq) {
                    ballToNudge = &b;
                    minDistSq = dSq;
                }
            }
        }
        if (ballToNudge) { // Found a ball to nudge
            aiPlannedShotDetails.angle = atan2f(ballToNudge->y - cueBall->y, ballToNudge->x - cueBall->x);
            aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.15f; // Gentle tap
        }
        else { // Absolute fallback: small tap forward
            aiPlannedShotDetails.angle = cueAngle; // Keep last angle or default
            //aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.1f;
            aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.1f;
        }
        aiPlannedShotDetails.spinX = 0.0f;
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true; // Safety shot is a ""valid"" plan
    }
    //} //bracefix

    // Phase 3: Setup for Aim Display (if a valid shot was decided)
    if (aiPlannedShotDetails.isValid) {
        cueAngle = aiPlannedShotDetails.angle;   // Update global for drawing
        shotPower = aiPlannedShotDetails.power;  // Update global for drawing
        // cueSpinX and cueSpinY could also be set here if AI used them
        cueSpinX = aiPlannedShotDetails.spinX; // Also set these for drawing consistency
        cueSpinY = aiPlannedShotDetails.spinY; //

        aiIsDisplayingAim = true;
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
        // currentGameState remains AI_THINKING, GameUpdate will handle the display countdown and shot execution.
            // FIRE THE BREAK SHOT NOW
            // Immediately execute the break shot after setting parameters
        /*ApplyShot(aiPlannedShotDetails.power, aiPlannedShotDetails.angle, aiPlannedShotDetails.spinX, aiPlannedShotDetails.spinY);
        currentGameState = SHOT_IN_PROGRESS;
        aiTurnPending = false;
        isOpeningBreakShot = false;*/
    }
    else {
        // Should not happen if safety shot is always planned, but as a fallback:
        aiIsDisplayingAim = false;
        // If AI truly can't decide anything, maybe switch turn or log error. For now, it will do nothing this frame.
        // Or force a minimal safety tap without display.
        // To ensure game progresses, let's plan a minimal tap if nothing else.
        if (!aiPlannedShotDetails.isValid) { // Double check
            aiPlannedShotDetails.angle = 0.0f;
            aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.05f; // Very small tap
            aiPlannedShotDetails.spinX = 0.0f; aiPlannedShotDetails.spinY = 0.0f;
            aiPlannedShotDetails.isValid = true;
            //cueAngle = aiPlannedShotDetails.angle; shotPower = aiPlannedShotDetails.power;
            cueAngle = aiPlannedShotDetails.angle;
            shotPower = aiPlannedShotDetails.power;
            cueSpinX = aiPlannedShotDetails.spinX;
            cueSpinY = aiPlannedShotDetails.spinY;
            aiIsDisplayingAim = true; // Allow display for this minimal tap too
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES / 2; // Shorter display for fallback
        }
    }
    // aiTurnPending was set to false by GameUpdate before calling AIMakeDecision.
    // AIMakeDecision's job is to populate aiPlannedShotDetails and trigger display.
}

// AI logic for placing cue ball during ball-in-hand
void AIPlaceCueBall() {
    Ball* cueBall = GetCueBall();
    if (!cueBall) return;

    // --- CPU AI Opening Break: Kitchen Placement ---
    /*if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT && currentPlayer == 2 && isPlayer2AI) {
        float kitchenMinX = TABLE_LEFT + BALL_RADIUS;
        float kitchenMaxX = HEADSTRING_X - BALL_RADIUS;
        float kitchenMinY = TABLE_TOP + BALL_RADIUS;
        float kitchenMaxY = TABLE_BOTTOM - BALL_RADIUS;
        bool validPositionFound = false;
        int attempts = 0;
        while (!validPositionFound && attempts < 100) {
            cueBall->x = kitchenMinX + static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / (kitchenMaxX - kitchenMinX)));
            cueBall->y = kitchenMinY + static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / (kitchenMaxY - kitchenMinY)));
            if (IsValidCueBallPosition(cueBall->x, cueBall->y, true)) {
                validPositionFound = true;
            }
            attempts++;
        }
        if (!validPositionFound) {
            cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f;
            cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
            if (!IsValidCueBallPosition(cueBall->x, cueBall->y, true)) {
                cueBall->x = HEADSTRING_X - BALL_RADIUS * 2.0f;
                cueBall->y = RACK_POS_Y;
            }
        }
        cueBall->vx = 0; cueBall->vy = 0;
        return;
    }*/
    // --- End CPU AI Opening Break Placement ---

    // This function is now SOLELY for Ball-In-Hand placement for the AI (anywhere on the table).
    // Break placement is handled by AIBreakShot().

    // Simple Strategy: Find the easiest possible shot for the AI's ball type
    // Place the cue ball directly behind that target ball, aiming straight at a pocket.
    // (More advanced: find spot offering multiple options or safety)

    AIShotInfo bestPlacementShot = { false };
    D2D1_POINT_2F bestPlacePos = D2D1::Point2F(HEADSTRING_X * 0.5f, RACK_POS_Y); // Default placement

    // A better default for ball-in-hand (anywhere) might be center table if no shot found.
    bestPlacePos = D2D1::Point2F(TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_TOP + TABLE_HEIGHT / 2.0f);
    float bestPlacementScore = -1.0f; // Keep track of the score for the best placement found

    BallType targetType = player2Info.assignedType;
    bool canTargetAnyPlacement = false; // Local scope variable for placement logic
    if (targetType == BallType::NONE) {
        canTargetAnyPlacement = true;
    }
    bool target8Ball = (!canTargetAnyPlacement && targetType != BallType::NONE && player2Info.ballsPocketedCount >= 7);
    if (target8Ball) targetType = BallType::EIGHT_BALL;


    for (auto& targetBall : balls) {
        if (targetBall.isPocketed || targetBall.id == 0) continue;

        // Determine if current ball is a valid target for placement consideration
        bool currentBallIsValidTarget = false;
        if (target8Ball && targetBall.id == 8) currentBallIsValidTarget = true;
        else if (canTargetAnyPlacement && targetBall.id != 8) currentBallIsValidTarget = true;
        else if (!canTargetAnyPlacement && !target8Ball && targetBall.type == targetType) currentBallIsValidTarget = true;

        if (!currentBallIsValidTarget) continue; // Skip if not a valid target

        for (int p = 0; p < 6; ++p) {
            // Calculate ideal cue ball position: straight line behind target ball aiming at pocket p
            float targetToPocketX = pocketPositions[p].x - targetBall.x;
            float targetToPocketY = pocketPositions[p].y - targetBall.y;
            float dist = sqrtf(targetToPocketX * targetToPocketX + targetToPocketY * targetToPocketY);
            if (dist < 1.0f) continue; // Avoid division by zero

            float idealAngle = atan2f(targetToPocketY, targetToPocketX);
            // Place cue ball slightly behind target ball along this line
            float placeDist = BALL_RADIUS * 3.0f; // Place a bit behind
            D2D1_POINT_2F potentialPlacePos = D2D1::Point2F( // Use factory function
                targetBall.x - cosf(idealAngle) * placeDist,
                targetBall.y - sinf(idealAngle) * placeDist
            );

            // Check if this placement is valid (on table, behind headstring if break, not overlapping)
            /*bool behindHeadstringRule = (currentGameState == PRE_BREAK_PLACEMENT);*/
            // For ball-in-hand (NOT break), behindHeadstringRule is false.
            // The currentGameState should be BALL_IN_HAND_P2 when this is called for a foul.
            bool behindHeadstringRule = false; // Player can place anywhere after a foul
            if (IsValidCueBallPosition(potentialPlacePos.x, potentialPlacePos.y, behindHeadstringRule)) {
                // Is path from potentialPlacePos to targetBall clear?
                // Use D2D1::Point2F() factory function here
                if (IsPathClear(potentialPlacePos, D2D1::Point2F(targetBall.x, targetBall.y), 0, targetBall.id)) {
                    // Is path from targetBall to pocket clear?
                    // Use D2D1::Point2F() factory function here
                    if (IsPathClear(D2D1::Point2F(targetBall.x, targetBall.y), pocketPositions[p], targetBall.id, -1)) {
                        // This seems like a good potential placement. Score it?
                        // Easy AI: Just take the first valid one found.
                        /*bestPlacePos = potentialPlacePos;
                        goto placement_found;*/ // Use goto for simplicity in non-OOP structure
                        // This is a possible shot. Score this placement.
// A simple score: distance to target ball (shorter is better for placement).
// More advanced: consider angle to pocket, difficulty of the shot from this placement.
                        AIShotInfo tempShotInfo;
                        tempShotInfo.possible = true;
                        tempShotInfo.targetBall = &targetBall;
                        tempShotInfo.pocketIndex = p;
                        tempShotInfo.ghostBallPos = CalculateGhostBallPos(&targetBall, p); // Not strictly needed for placement score but good for consistency
                        tempShotInfo.angle = idealAngle; // The angle from the placed ball to target
                        // Use EvaluateShot's scoring mechanism if possible, or a simpler one here.
                        float currentScore = 1000.0f / (1.0f + GetDistance(potentialPlacePos.x, potentialPlacePos.y, targetBall.x, targetBall.y)); // Inverse distance

                        if (currentScore > bestPlacementScore) {
                            bestPlacementScore = currentScore;
                            bestPlacePos = potentialPlacePos;
                        }
                    }
                }
            }
        }
    }

placement_found:
    // Place the cue ball at the best found position (or default if no good spot found)
    cueBall->x = bestPlacePos.x;
    cueBall->y = bestPlacePos.y;
    cueBall->vx = 0;
    cueBall->vy = 0;
}


// AI finds the best shot available on the table
AIShotInfo AIFindBestShot() {
    AIShotInfo bestShotOverall = { false };
    Ball* cueBall = GetCueBall();
    if (!cueBall) return bestShotOverall;
    // Ensure cue ball position is up-to-date if AI just placed it
    // (AIPlaceCueBall should have already set cueBall->x, cueBall->y)

    // Determine target ball type for AI (Player 2)
    BallType targetType = player2Info.assignedType;
    bool canTargetAny = false; // Can AI hit any ball (e.g., after break, before assignment)?
    if (targetType == BallType::NONE) {
        // If colors not assigned, AI aims to pocket *something* (usually lowest numbered ball legally)
        // Or, more simply, treat any ball as a potential target to make *a* pocket
        canTargetAny = true; // Simplification: allow targeting any non-8 ball.
        // A better rule is hit lowest numbered ball first on break follow-up.
    }

    // Check if AI needs to shoot the 8-ball
    bool target8Ball = (!canTargetAny && targetType != BallType::NONE && player2Info.ballsPocketedCount >= 7);


    // Iterate through all potential target balls
    for (auto& potentialTarget : balls) {
        if (potentialTarget.isPocketed || potentialTarget.id == 0) continue; // Skip pocketed and cue ball

        // Check if this ball is a valid target
        bool isValidTarget = false;
        if (target8Ball) {
            isValidTarget = (potentialTarget.id == 8);
        }
        else if (canTargetAny) {
            isValidTarget = (potentialTarget.id != 8); // Can hit any non-8 ball
        }
        else { // Colors assigned, not yet shooting 8-ball
            isValidTarget = (potentialTarget.type == targetType);
        }

        if (!isValidTarget) continue; // Skip if not a valid target for this turn

        // Now, check all pockets for this target ball
        for (int p = 0; p < 6; ++p) {
            AIShotInfo currentShot = EvaluateShot(&potentialTarget, p);
            currentShot.involves8Ball = (potentialTarget.id == 8);

            if (currentShot.possible) {
                // Compare scores to find the best shot
                if (!bestShotOverall.possible || currentShot.score > bestShotOverall.score) {
                    bestShotOverall = currentShot;
                }
            }
        }
    } // End loop through potential target balls

    // If targeting 8-ball and no shot found, or targeting own balls and no shot found,
    // need a safety strategy. Current simple AI just takes best found or taps cue ball.

    return bestShotOverall;
}


// Evaluate a potential shot at a specific target ball towards a specific pocket
AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex) {
    AIShotInfo shotInfo;
    shotInfo.possible = false; // Assume not possible initially
    shotInfo.targetBall = targetBall;
    shotInfo.pocketIndex = pocketIndex;

    Ball* cueBall = GetCueBall();
    if (!cueBall || !targetBall) return shotInfo;

    // --- Define local state variables needed for legality checks ---
    BallType aiAssignedType = player2Info.assignedType;
    bool canTargetAny = (aiAssignedType == BallType::NONE); // Can AI hit any ball?
    bool mustTarget8Ball = (!canTargetAny && aiAssignedType != BallType::NONE && player2Info.ballsPocketedCount >= 7);
    // ---

    // 1. Calculate Ghost Ball position
    shotInfo.ghostBallPos = CalculateGhostBallPos(targetBall, pocketIndex);

    // 2. Calculate Angle from Cue Ball to Ghost Ball
    float dx = shotInfo.ghostBallPos.x - cueBall->x;
    float dy = shotInfo.ghostBallPos.y - cueBall->y;
    if (fabs(dx) < 0.01f && fabs(dy) < 0.01f) return shotInfo; // Avoid aiming at same spot
    shotInfo.angle = atan2f(dy, dx);

    // Basic angle validity check (optional)
    if (!IsValidAIAimAngle(shotInfo.angle)) {
        // Maybe log this or handle edge cases
    }

    // 3. Check Path: Cue Ball -> Ghost Ball Position
    // Use D2D1::Point2F() factory function here
    if (!IsPathClear(D2D1::Point2F(cueBall->x, cueBall->y), shotInfo.ghostBallPos, cueBall->id, targetBall->id)) {
        return shotInfo; // Path blocked
    }

    // 4. Check Path: Target Ball -> Pocket
    // Use D2D1::Point2F() factory function here
    if (!IsPathClear(D2D1::Point2F(targetBall->x, targetBall->y), pocketPositions[pocketIndex], targetBall->id, -1)) {
        return shotInfo; // Path blocked
    }

    // 5. Check First Ball Hit Legality
    float firstHitDistSq = -1.0f;
    // Use D2D1::Point2F() factory function here
    Ball* firstHit = FindFirstHitBall(D2D1::Point2F(cueBall->x, cueBall->y), shotInfo.angle, firstHitDistSq);

    if (!firstHit) {
        return shotInfo; // AI aims but doesn't hit anything? Impossible shot.
    }

    // Check if the first ball hit is the intended target ball
    if (firstHit->id != targetBall->id) {
        // Allow hitting slightly off target if it's very close to ghost ball pos
        float ghostDistSq = GetDistanceSq(shotInfo.ghostBallPos.x, shotInfo.ghostBallPos.y, firstHit->x, firstHit->y);
        // Allow a tolerance roughly half the ball radius squared
        if (ghostDistSq > (BALL_RADIUS * 0.7f) * (BALL_RADIUS * 0.7f)) {
            // First hit is significantly different from the target point.
            // This shot path leads to hitting the wrong ball first.
            return shotInfo; // Foul or unintended shot
        }
        // If first hit is not target, but very close, allow it for now (might still be foul based on type).
    }

    // Check legality of the *first ball actually hit* based on game rules
    if (!canTargetAny) { // Colors are assigned (or should be)
        if (mustTarget8Ball) { // Must hit 8-ball first
            if (firstHit->id != 8) {
                // return shotInfo; // FOUL - Hitting wrong ball when aiming for 8-ball
                // Keep shot possible for now, rely on AIFindBestShot to prioritize legal ones
            }
        }
        else { // Must hit own ball type first
            if (firstHit->type != aiAssignedType && firstHit->id != 8) { // Allow hitting 8-ball if own type blocked? No, standard rules usually require hitting own first.
                // return shotInfo; // FOUL - Hitting opponent ball or 8-ball when shouldn't
                // Keep shot possible for now, rely on AIFindBestShot to prioritize legal ones
            }
            else if (firstHit->id == 8) {
                // return shotInfo; // FOUL - Hitting 8-ball when shouldn't
                // Keep shot possible for now
            }
        }
    }
    // (If canTargetAny is true, hitting any ball except 8 first is legal - assuming not scratching)


    // 6. Calculate Score & Power (Difficulty affects this)
    shotInfo.possible = true; // If we got here, the shot is geometrically possible and likely legal enough for AI to consider

    float cueToGhostDist = GetDistance(cueBall->x, cueBall->y, shotInfo.ghostBallPos.x, shotInfo.ghostBallPos.y);
    float targetToPocketDist = GetDistance(targetBall->x, targetBall->y, pocketPositions[pocketIndex].x, pocketPositions[pocketIndex].y);

    // Simple Score: Shorter shots are better, straighter shots are slightly better.
    float distanceScore = 1000.0f / (1.0f + cueToGhostDist + targetToPocketDist);

    // Angle Score: Calculate cut angle
    // Vector Cue -> Ghost
    float v1x = shotInfo.ghostBallPos.x - cueBall->x;
    float v1y = shotInfo.ghostBallPos.y - cueBall->y;
    // Vector Target -> Pocket
    float v2x = pocketPositions[pocketIndex].x - targetBall->x;
    float v2y = pocketPositions[pocketIndex].y - targetBall->y;
    // Normalize vectors
    float mag1 = sqrtf(v1x * v1x + v1y * v1y);
    float mag2 = sqrtf(v2x * v2x + v2y * v2y);
    float angleScoreFactor = 0.5f; // Default if vectors are zero len
    if (mag1 > 0.1f && mag2 > 0.1f) {
        v1x /= mag1; v1y /= mag1;
        v2x /= mag2; v2y /= mag2;
        // Dot product gives cosine of angle between cue ball path and target ball path
        float dotProduct = v1x * v2x + v1y * v2y;
        // Straighter shot (dot product closer to 1) gets higher score
        angleScoreFactor = (1.0f + dotProduct) / 2.0f; // Map [-1, 1] to [0, 1]
    }
    angleScoreFactor = std::max(0.1f, angleScoreFactor); // Ensure some minimum score factor

    shotInfo.score = distanceScore * angleScoreFactor;

    // Bonus for pocketing 8-ball legally
    if (mustTarget8Ball && targetBall->id == 8) {
        shotInfo.score *= 10.0; // Strongly prefer the winning shot
    }

    // Penalty for difficult cuts? Already partially handled by angleScoreFactor.

    // 7. Calculate Power
    shotInfo.power = CalculateShotPower(cueToGhostDist, targetToPocketDist);

    // 8. Add Inaccuracy based on Difficulty (same as before)
    float angleError = 0.0f;
    float powerErrorFactor = 1.0f;

    switch (aiDifficulty) {
    case EASY:
        angleError = (float)(rand() % 100 - 50) / 1000.0f; // +/- ~3 deg
        powerErrorFactor = 0.8f + (float)(rand() % 40) / 100.0f; // 80-120%
        shotInfo.power *= 0.8f;
        break;
    case MEDIUM:
        angleError = (float)(rand() % 60 - 30) / 1000.0f; // +/- ~1.7 deg
        powerErrorFactor = 0.9f + (float)(rand() % 20) / 100.0f; // 90-110%
        break;
    case HARD:
        angleError = (float)(rand() % 10 - 5) / 1000.0f; // +/- ~0.3 deg
        powerErrorFactor = 0.98f + (float)(rand() % 4) / 100.0f; // 98-102%
        break;
    }
    shotInfo.angle += angleError;
    shotInfo.power *= powerErrorFactor;
    shotInfo.power = std::max(1.0f, std::min(shotInfo.power, MAX_SHOT_POWER)); // Clamp power

    return shotInfo;
}


// Calculates required power (simplified)
float CalculateShotPower(float cueToGhostDist, float targetToPocketDist) {
    // Basic model: Power needed increases with total distance the balls need to travel.
    // Need enough power for cue ball to reach target AND target to reach pocket.
    float totalDist = cueToGhostDist + targetToPocketDist;

    // Map distance to power (needs tuning)
    // Let's say max power is needed for longest possible shot (e.g., corner to corner ~ 1000 units)
    float powerRatio = std::min(1.0f, totalDist / 800.0f); // Normalize based on estimated max distance

    float basePower = MAX_SHOT_POWER * 0.2f; // Minimum power to move balls reliably
    float variablePower = (MAX_SHOT_POWER * 0.8f) * powerRatio; // Scale remaining power range

    // Harder AI could adjust based on desired cue ball travel (more power for draw/follow)
    return std::min(MAX_SHOT_POWER, basePower + variablePower);
}

// Calculate the position the cue ball needs to hit for the target ball to go towards the pocket
D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex) {
    float targetToPocketX = pocketPositions[pocketIndex].x - targetBall->x;
    float targetToPocketY = pocketPositions[pocketIndex].y - targetBall->y;
    float dist = sqrtf(targetToPocketX * targetToPocketX + targetToPocketY * targetToPocketY);

    if (dist < 1.0f) { // Target is basically in the pocket
        // Aim slightly off-center to avoid weird physics? Or directly at center?
        // For simplicity, return a point slightly behind center along the reverse line.
        return D2D1::Point2F(targetBall->x - targetToPocketX * 0.1f, targetBall->y - targetToPocketY * 0.1f);
    }

    // Normalize direction vector from target to pocket
    float nx = targetToPocketX / dist;
    float ny = targetToPocketY / dist;

    // Ghost ball position is diameter distance *behind* the target ball along this line
    float ghostX = targetBall->x - nx * (BALL_RADIUS * 2.0f);
    float ghostY = targetBall->y - ny * (BALL_RADIUS * 2.0f);

    return D2D1::Point2F(ghostX, ghostY);
}

// Checks if line segment is clear of obstructing balls
bool IsPathClear(D2D1_POINT_2F start, D2D1_POINT_2F end, int ignoredBallId1, int ignoredBallId2) {
    float dx = end.x - start.x;
    float dy = end.y - start.y;
    float segmentLenSq = dx * dx + dy * dy;

    if (segmentLenSq < 0.01f) return true; // Start and end are same point

    for (const auto& ball : balls) {
        if (ball.isPocketed) continue;
        if (ball.id == ignoredBallId1) continue;
        if (ball.id == ignoredBallId2) continue;

        // Check distance from ball center to the line segment
        float ballToStartX = ball.x - start.x;
        float ballToStartY = ball.y - start.y;

        // Project ball center onto the line defined by the segment
        float dot = (ballToStartX * dx + ballToStartY * dy) / segmentLenSq;

        D2D1_POINT_2F closestPointOnLine;
        if (dot < 0) { // Closest point is start point
            closestPointOnLine = start;
        }
        else if (dot > 1) { // Closest point is end point
            closestPointOnLine = end;
        }
        else { // Closest point is along the segment
            closestPointOnLine = D2D1::Point2F(start.x + dot * dx, start.y + dot * dy);
        }

        // Check if the closest point is within collision distance (ball radius + path radius)
        if (GetDistanceSq(ball.x, ball.y, closestPointOnLine.x, closestPointOnLine.y) < (BALL_RADIUS * BALL_RADIUS)) {
            // Consider slightly wider path check? Maybe BALL_RADIUS * 1.1f?
            // if (GetDistanceSq(ball.x, ball.y, closestPointOnLine.x, closestPointOnLine.y) < (BALL_RADIUS * 1.1f)*(BALL_RADIUS*1.1f)) {
            return false; // Path is blocked
        }
    }
    return true; // No obstructions found
}

// Finds the first ball hit along a path (simplified)
Ball* FindFirstHitBall(D2D1_POINT_2F start, float angle, float& hitDistSq) {
    Ball* hitBall = nullptr;
    hitDistSq = -1.0f; // Initialize hit distance squared
    float minCollisionDistSq = -1.0f;

    float cosA = cosf(angle);
    float sinA = sinf(angle);

    for (auto& ball : balls) {
        if (ball.isPocketed || ball.id == 0) continue; // Skip cue ball and pocketed

        float dx = ball.x - start.x;
        float dy = ball.y - start.y;

        // Project vector from start->ball onto the aim direction vector
        float dot = dx * cosA + dy * sinA;

        if (dot > 0) { // Ball is generally in front
            // Find closest point on aim line to the ball's center
            float closestPointX = start.x + dot * cosA;
            float closestPointY = start.y + dot * sinA;
            float distSq = GetDistanceSq(ball.x, ball.y, closestPointX, closestPointY);

            // Check if the aim line passes within the ball's radius
            if (distSq < (BALL_RADIUS * BALL_RADIUS)) {
                // Calculate distance from start to the collision point on the ball's circumference
                float backDist = sqrtf(std::max(0.f, BALL_RADIUS * BALL_RADIUS - distSq));
                float collisionDist = dot - backDist; // Distance along aim line to collision

                if (collisionDist > 0) { // Ensure collision is in front
                    float collisionDistSq = collisionDist * collisionDist;
                    if (hitBall == nullptr || collisionDistSq < minCollisionDistSq) {
                        minCollisionDistSq = collisionDistSq;
                        hitBall = &ball; // Found a closer hit ball
                    }
                }
            }
        }
    }
    hitDistSq = minCollisionDistSq; // Return distance squared to the first hit
    return hitBall;
}

// Basic check for reasonable AI aim angles (optional)
bool IsValidAIAimAngle(float angle) {
    // Placeholder - could check for NaN or infinity if calculations go wrong
    return isfinite(angle);
}

//midi func = start
void PlayMidiInBackground(HWND hwnd, const TCHAR* midiPath) {
    while (isMusicPlaying) {
        MCI_OPEN_PARMS mciOpen = { 0 };
        mciOpen.lpstrDeviceType = TEXT(""sequencer"");
        mciOpen.lpstrElementName = midiPath;

        if (mciSendCommand(0, MCI_OPEN, MCI_OPEN_TYPE | MCI_OPEN_ELEMENT, (DWORD_PTR)&mciOpen) == 0) {
            midiDeviceID = mciOpen.wDeviceID;

            MCI_PLAY_PARMS mciPlay = { 0 };
            mciSendCommand(midiDeviceID, MCI_PLAY, 0, (DWORD_PTR)&mciPlay);

            // Wait for playback to complete
            MCI_STATUS_PARMS mciStatus = { 0 };
            mciStatus.dwItem = MCI_STATUS_MODE;

            do {
                mciSendCommand(midiDeviceID, MCI_STATUS, MCI_STATUS_ITEM, (DWORD_PTR)&mciStatus);
                Sleep(100); // adjust as needed
            } while (mciStatus.dwReturn == MCI_MODE_PLAY && isMusicPlaying);

            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
        }
    }
}

void StartMidi(HWND hwnd, const TCHAR* midiPath) {
    if (isMusicPlaying) {
        StopMidi();
    }
    isMusicPlaying = true;
    musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
}

void StopMidi() {
    if (isMusicPlaying) {
        isMusicPlaying = false;
        if (musicThread.joinable()) musicThread.join();
        if (midiDeviceID != 0) {
            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
        }
    }
}

/*void PlayGameMusic(HWND hwnd) {
    // Stop any existing playback
    if (isMusicPlaying) {
        isMusicPlaying = false;
        if (musicThread.joinable()) {
            musicThread.join();
        }
        if (midiDeviceID != 0) {
            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
        }
    }

    // Get the path of the executable
    TCHAR exePath[MAX_PATH];
    GetModuleFileName(NULL, exePath, MAX_PATH);

    // Extract the directory path
    TCHAR* lastBackslash = _tcsrchr(exePath, '\\');
    if (lastBackslash != NULL) {
        *(lastBackslash + 1) = '\0';
    }

    // Construct the full path to the MIDI file
    static TCHAR midiPath[MAX_PATH];
    _tcscpy_s(midiPath, MAX_PATH, exePath);
    _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID""));

    // Start the background playback
    isMusicPlaying = true;
    musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
}*/
//midi func = end

// --- Drawing Functions ---

void OnPaint() {
    HRESULT hr = CreateDeviceResources(); // Ensure resources are valid

    if (SUCCEEDED(hr)) {
        pRenderTarget->BeginDraw();
        DrawScene(pRenderTarget); // Pass render target
        hr = pRenderTarget->EndDraw();

        if (hr == D2DERR_RECREATE_TARGET) {
            DiscardDeviceResources();
            // Optionally request another paint message: InvalidateRect(hwndMain, NULL, FALSE);
            // But the timer loop will trigger redraw anyway.
        }
    }
    // If CreateDeviceResources failed, EndDraw might not be called.
    // Consider handling this more robustly if needed.
}

void DrawScene(ID2D1RenderTarget* pRT) {
    if (!pRT) return;

    //pRT->Clear(D2D1::ColorF(D2D1::ColorF::LightGray)); // Background color
    // Set background color to #ffffcd (RGB: 255, 255, 205)
    pRT->Clear(D2D1::ColorF(0.3686f, 0.5333f, 0.3882f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)
    //pRT->Clear(D2D1::ColorF(1.0f, 1.0f, 0.803f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)

    DrawTable(pRT, pFactory);
    DrawPocketSelectionIndicator(pRT); // Draw arrow over selected/called pocket
    DrawBalls(pRT);
    DrawAimingAids(pRT); // Includes cue stick if aiming
    DrawUI(pRT);
    DrawPowerMeter(pRT);
    DrawSpinIndicator(pRT);
    DrawPocketedBallsIndicator(pRT);
    DrawBallInHandIndicator(pRT); // Draw cue ball ghost if placing

     // Draw Game Over Message
    if (currentGameState == GAME_OVER && pTextFormat) {
        ID2D1SolidColorBrush* pBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pBrush);
        if (pBrush) {
            D2D1_RECT_F layoutRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP + TABLE_HEIGHT / 2 - 30, TABLE_RIGHT, TABLE_TOP + TABLE_HEIGHT / 2 + 30);
            pRT->DrawText(
                gameOverMessage.c_str(),
                (UINT32)gameOverMessage.length(),
                pTextFormat, // Use large format maybe?
                &layoutRect,
                pBrush
            );
            SafeRelease(&pBrush);
        }
    }

}

void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory) {
    ID2D1SolidColorBrush* pBrush = nullptr;

    // === Draw Full Orange Frame (Table Border) ===
    ID2D1SolidColorBrush* pFrameBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(0.9157f, 0.6157f, 0.2000f), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
    //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
    if (pFrameBrush) {
        D2D1_RECT_F outerRect = D2D1::RectF(
            TABLE_LEFT - CUSHION_THICKNESS,
            TABLE_TOP - CUSHION_THICKNESS,
            TABLE_RIGHT + CUSHION_THICKNESS,
            TABLE_BOTTOM + CUSHION_THICKNESS
        );
        pRT->FillRectangle(&outerRect, pFrameBrush);
        SafeRelease(&pFrameBrush);
    }

    // Draw Table Bed (Green Felt)
    pRT->CreateSolidColorBrush(TABLE_COLOR, &pBrush);
    if (!pBrush) return;
    D2D1_RECT_F tableRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP, TABLE_RIGHT, TABLE_BOTTOM);
    pRT->FillRectangle(&tableRect, pBrush);
    SafeRelease(&pBrush);

    // Draw Cushions (Red Border)
    pRT->CreateSolidColorBrush(CUSHION_COLOR, &pBrush);
    if (!pBrush) return;
    // Top Cushion (split by middle pocket)
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
    // Bottom Cushion (split by middle pocket)
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
    // Left Cushion
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT - CUSHION_THICKNESS, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_LEFT, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
    // Right Cushion
    pRT->FillRectangle(D2D1::RectF(TABLE_RIGHT, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_RIGHT + CUSHION_THICKNESS, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
    SafeRelease(&pBrush);


    // Draw Pockets (Black Circles)
    pRT->CreateSolidColorBrush(POCKET_COLOR, &pBrush);
    if (!pBrush) return;
    for (int i = 0; i < 6; ++i) {
        D2D1_ELLIPSE ellipse = D2D1::Ellipse(pocketPositions[i], HOLE_VISUAL_RADIUS, HOLE_VISUAL_RADIUS);
        pRT->FillEllipse(&ellipse, pBrush);
    }
    SafeRelease(&pBrush);

    // Draw Headstring Line (White)
    pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
    //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
    if (!pBrush) return;
    pRT->DrawLine(
        D2D1::Point2F(HEADSTRING_X, TABLE_TOP),
        D2D1::Point2F(HEADSTRING_X, TABLE_BOTTOM),
        pBrush,
        1.0f // Line thickness
    );
    SafeRelease(&pBrush);

    // Draw Semicircle facing West (flat side East)
    // Draw Semicircle facing East (curved side on the East, flat side on the West)
    ID2D1PathGeometry* pGeometry = nullptr;
    HRESULT hr = pFactory->CreatePathGeometry(&pGeometry);
    if (SUCCEEDED(hr) && pGeometry)
    {
        ID2D1GeometrySink* pSink = nullptr;
        hr = pGeometry->Open(&pSink);
        if (SUCCEEDED(hr) && pSink)
        {
            float radius = 60.0f; // Radius for the semicircle
            D2D1_POINT_2F center = D2D1::Point2F(HEADSTRING_X, (TABLE_TOP + TABLE_BOTTOM) / 2.0f);

            // For a semicircle facing East (curved side on the East), use the top and bottom points.
            D2D1_POINT_2F startPoint = D2D1::Point2F(center.x, center.y - radius); // Top point

            pSink->BeginFigure(startPoint, D2D1_FIGURE_BEGIN_HOLLOW);

            D2D1_ARC_SEGMENT arc = {};
            arc.point = D2D1::Point2F(center.x, center.y + radius); // Bottom point
            arc.size = D2D1::SizeF(radius, radius);
            arc.rotationAngle = 0.0f;
            // Use the correct identifier with the extra underscore:
            arc.sweepDirection = D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE;
            arc.arcSize = D2D1_ARC_SIZE_SMALL;

            pSink->AddArc(&arc);
            pSink->EndFigure(D2D1_FIGURE_END_OPEN);
            pSink->Close();
            SafeRelease(&pSink);

            ID2D1SolidColorBrush* pArcBrush = nullptr;
            //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.3f), &pArcBrush);
            pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pArcBrush);
            if (pArcBrush)
            {
                pRT->DrawGeometry(pGeometry, pArcBrush, 1.5f);
                SafeRelease(&pArcBrush);
            }
        }
        SafeRelease(&pGeometry);
    }




}


void DrawBalls(ID2D1RenderTarget* pRT) {
    ID2D1SolidColorBrush* pBrush = nullptr;
    ID2D1SolidColorBrush* pStripeBrush = nullptr; // For stripe pattern

    pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBrush); // Placeholder
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);

    if (!pBrush || !pStripeBrush) {
        SafeRelease(&pBrush);
        SafeRelease(&pStripeBrush);
        return;
    }


    for (size_t i = 0; i < balls.size(); ++i) {
        const Ball& b = balls[i];
        if (!b.isPocketed) {
            D2D1_ELLIPSE ellipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS, BALL_RADIUS);

            // Set main ball color
            pBrush->SetColor(b.color);
            pRT->FillEllipse(&ellipse, pBrush);

            // Draw Stripe if applicable
            if (b.type == BallType::STRIPE) {
                // Draw a white band across the middle (simplified stripe)
                D2D1_RECT_F stripeRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS * 0.4f, b.x + BALL_RADIUS, b.y + BALL_RADIUS * 0.4f);
                // Need to clip this rectangle to the ellipse bounds - complex!
                // Alternative: Draw two colored arcs leaving a white band.
                // Simplest: Draw a white circle inside, slightly smaller.
                D2D1_ELLIPSE innerEllipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS * 0.6f, BALL_RADIUS * 0.6f);
                pRT->FillEllipse(innerEllipse, pStripeBrush); // White center part
                pBrush->SetColor(b.color); // Set back to stripe color
                pRT->FillEllipse(innerEllipse, pBrush); // Fill again, leaving a ring - No, this isn't right.

                // Let's try drawing a thick white line across
                // This doesn't look great. Just drawing solid red for stripes for now.
            }

            // Draw Number (Optional - requires more complex text layout or pre-rendered textures)
            // if (b.id != 0 && pTextFormat) {
            //     std::wstring numStr = std::to_wstring(b.id);
            //     D2D1_RECT_F textRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS, b.x + BALL_RADIUS, b.y + BALL_RADIUS);
            //     ID2D1SolidColorBrush* pNumBrush = nullptr;
            //     D2D1_COLOR_F numCol = (b.type == BallType::SOLID || b.id == 8) ? D2D1::ColorF(D2D1::ColorF::Black) : D2D1::ColorF(D2D1::ColorF::White);
            //     pRT->CreateSolidColorBrush(numCol, &pNumBrush);
            //     // Create a smaller text format...
            //     // pRT->DrawText(numStr.c_str(), numStr.length(), pSmallTextFormat, &textRect, pNumBrush);
            //     SafeRelease(&pNumBrush);
            // }
        }
    }

    SafeRelease(&pBrush);
    SafeRelease(&pStripeBrush);
}


void DrawAimingAids(ID2D1RenderTarget* pRT) {
    // Condition check at start (Unchanged)
    //if (currentGameState != PLAYER1_TURN && currentGameState != PLAYER2_TURN &&
        //currentGameState != BREAKING && currentGameState != AIMING)
    //{
        //return;
    //}
        // NEW Condition: Allow drawing if it's a human player's active turn/aiming/breaking,
    // OR if it's AI's turn and it's in AI_THINKING state (calculating) or BREAKING (aiming break).
    bool isHumanInteracting = (!isPlayer2AI || currentPlayer == 1) &&
        (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
            currentGameState == BREAKING || currentGameState == AIMING);
    // AI_THINKING state is when AI calculates shot. AIMakeDecision sets cueAngle/shotPower.
    // Also include BREAKING state if it's AI's turn and isOpeningBreakShot for break aim visualization.
        // NEW Condition: AI is displaying its aim
    bool isAiVisualizingShot = (isPlayer2AI && currentPlayer == 2 &&
        currentGameState == AI_THINKING && aiIsDisplayingAim);

    if (!isHumanInteracting && !(isAiVisualizingShot || (currentGameState == AI_THINKING && aiIsDisplayingAim))) {
        return;
    }

    Ball* cueBall = GetCueBall();
    if (!cueBall || cueBall->isPocketed) return; // Don't draw if cue ball is gone

    ID2D1SolidColorBrush* pBrush = nullptr;
    ID2D1SolidColorBrush* pGhostBrush = nullptr;
    ID2D1StrokeStyle* pDashedStyle = nullptr;
    ID2D1SolidColorBrush* pCueBrush = nullptr;
    ID2D1SolidColorBrush* pReflectBrush = nullptr; // Brush for reflection line

    // Ensure render target is valid
    if (!pRT) return;

    // Create Brushes and Styles (check for failures)
    HRESULT hr;
    hr = pRT->CreateSolidColorBrush(AIM_LINE_COLOR, &pBrush);
    if FAILED(hr) { SafeRelease(&pBrush); return; }
    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pGhostBrush);
    if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); return; }
    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0.6f, 0.4f, 0.2f), &pCueBrush);
    if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); return; }
    // Create reflection brush (e.g., lighter shade or different color)
    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::LightCyan, 0.6f), &pReflectBrush);
    if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); SafeRelease(&pReflectBrush); return; }
    // Create a Cyan brush for primary and secondary lines //orig(75.0f / 255.0f, 0.0f, 130.0f / 255.0f);indigoColor
    D2D1::ColorF cyanColor(0.0, 255.0, 255.0, 255.0f);
    ID2D1SolidColorBrush* pCyanBrush = nullptr;
    hr = pRT->CreateSolidColorBrush(cyanColor, &pCyanBrush);
    if (FAILED(hr)) {
        SafeRelease(&pCyanBrush);
        // handle error if needed
    }
    // Create a Purple brush for primary and secondary lines
    D2D1::ColorF purpleColor(255.0f, 0.0f, 255.0f, 255.0f);
    ID2D1SolidColorBrush* pPurpleBrush = nullptr;
    hr = pRT->CreateSolidColorBrush(purpleColor, &pPurpleBrush);
    if (FAILED(hr)) {
        SafeRelease(&pPurpleBrush);
        // handle error if needed
    }

    if (pFactory) {
        D2D1_STROKE_STYLE_PROPERTIES strokeProps = D2D1::StrokeStyleProperties();
        strokeProps.dashStyle = D2D1_DASH_STYLE_DASH;
        hr = pFactory->CreateStrokeStyle(&strokeProps, nullptr, 0, &pDashedStyle);
        if FAILED(hr) { pDashedStyle = nullptr; }
    }


    // --- Cue Stick Drawing (Unchanged from previous fix) ---
    const float baseStickLength = 150.0f;
    const float baseStickThickness = 4.0f;
    float stickLength = baseStickLength * 1.4f;
    float stickThickness = baseStickThickness * 1.5f;
    float stickAngle = cueAngle + PI;
    float powerOffset = 0.0f;
    //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
        // Show power offset if human is aiming/dragging, or if AI is preparing its shot (AI_THINKING or AI Break)
    if ((isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) || isAiVisualizingShot) { // Use the new condition
        powerOffset = shotPower * 5.0f;
    }
    D2D1_POINT_2F cueStickEnd = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (stickLength + powerOffset), cueBall->y + sinf(stickAngle) * (stickLength + powerOffset));
    D2D1_POINT_2F cueStickTip = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (powerOffset + 5.0f), cueBall->y + sinf(stickAngle) * (powerOffset + 5.0f));
    pRT->DrawLine(cueStickTip, cueStickEnd, pCueBrush, stickThickness);


    // --- Projection Line Calculation ---
    float cosA = cosf(cueAngle);
    float sinA = sinf(cueAngle);
    float rayLength = TABLE_WIDTH + TABLE_HEIGHT; // Ensure ray is long enough
    D2D1_POINT_2F rayStart = D2D1::Point2F(cueBall->x, cueBall->y);
    D2D1_POINT_2F rayEnd = D2D1::Point2F(rayStart.x + cosA * rayLength, rayStart.y + sinA * rayLength);

    // Find the first ball hit by the aiming ray
    Ball* hitBall = nullptr;
    float firstHitDistSq = -1.0f;
    D2D1_POINT_2F ballCollisionPoint = { 0, 0 }; // Point on target ball circumference
    D2D1_POINT_2F ghostBallPosForHit = { 0, 0 }; // Ghost ball pos for the hit ball

    hitBall = FindFirstHitBall(rayStart, cueAngle, firstHitDistSq);
    if (hitBall) {
        // Calculate the point on the target ball's circumference
        float collisionDist = sqrtf(firstHitDistSq);
        ballCollisionPoint = D2D1::Point2F(rayStart.x + cosA * collisionDist, rayStart.y + sinA * collisionDist);
        // Calculate ghost ball position for this specific hit (used for projection consistency)
        ghostBallPosForHit = D2D1::Point2F(hitBall->x - cosA * BALL_RADIUS, hitBall->y - sinA * BALL_RADIUS); // Approx.
    }

    // Find the first rail hit by the aiming ray
    D2D1_POINT_2F railHitPoint = rayEnd; // Default to far end if no rail hit
    float minRailDistSq = rayLength * rayLength;
    int hitRailIndex = -1; // 0:Left, 1:Right, 2:Top, 3:Bottom

    // Define table edge segments for intersection checks
    D2D1_POINT_2F topLeft = D2D1::Point2F(TABLE_LEFT, TABLE_TOP);
    D2D1_POINT_2F topRight = D2D1::Point2F(TABLE_RIGHT, TABLE_TOP);
    D2D1_POINT_2F bottomLeft = D2D1::Point2F(TABLE_LEFT, TABLE_BOTTOM);
    D2D1_POINT_2F bottomRight = D2D1::Point2F(TABLE_RIGHT, TABLE_BOTTOM);

    D2D1_POINT_2F currentIntersection;

    // Check Left Rail
    if (LineSegmentIntersection(rayStart, rayEnd, topLeft, bottomLeft, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 0; }
    }
    // Check Right Rail
    if (LineSegmentIntersection(rayStart, rayEnd, topRight, bottomRight, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 1; }
    }
    // Check Top Rail
    if (LineSegmentIntersection(rayStart, rayEnd, topLeft, topRight, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 2; }
    }
    // Check Bottom Rail
    if (LineSegmentIntersection(rayStart, rayEnd, bottomLeft, bottomRight, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 3; }
    }


    // --- Determine final aim line end point ---
    D2D1_POINT_2F finalLineEnd = railHitPoint; // Assume rail hit first
    bool aimingAtRail = true;

    if (hitBall && firstHitDistSq < minRailDistSq) {
        // Ball collision is closer than rail collision
        finalLineEnd = ballCollisionPoint; // End line at the point of contact on the ball
        aimingAtRail = false;
    }

    // --- Draw Primary Aiming Line ---
    pRT->DrawLine(rayStart, finalLineEnd, pBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

    // --- Draw Target Circle/Indicator ---
    D2D1_ELLIPSE targetCircle = D2D1::Ellipse(finalLineEnd, BALL_RADIUS / 2.0f, BALL_RADIUS / 2.0f);
    pRT->DrawEllipse(&targetCircle, pBrush, 1.0f);

    // --- Draw Projection/Reflection Lines ---
    if (!aimingAtRail && hitBall) {
        // Aiming at a ball: Draw Ghost Cue Ball and Target Ball Projection
        D2D1_ELLIPSE ghostCue = D2D1::Ellipse(ballCollisionPoint, BALL_RADIUS, BALL_RADIUS); // Ghost ball at contact point
        pRT->DrawEllipse(ghostCue, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

        // Calculate target ball projection based on impact line (cue collision point -> target center)
        float targetProjectionAngle = atan2f(hitBall->y - ballCollisionPoint.y, hitBall->x - ballCollisionPoint.x);
        // Clamp angle calculation if distance is tiny
        if (GetDistanceSq(hitBall->x, hitBall->y, ballCollisionPoint.x, ballCollisionPoint.y) < 1.0f) {
            targetProjectionAngle = cueAngle; // Fallback if overlapping
        }

        D2D1_POINT_2F targetStartPoint = D2D1::Point2F(hitBall->x, hitBall->y);
        D2D1_POINT_2F targetProjectionEnd = D2D1::Point2F(
            hitBall->x + cosf(targetProjectionAngle) * 50.0f, // Projection length 50 units
            hitBall->y + sinf(targetProjectionAngle) * 50.0f
        );
        // Draw solid line for target projection
        //pRT->DrawLine(targetStartPoint, targetProjectionEnd, pBrush, 1.0f);

    //new code start

                // Dual trajectory with edge-aware contact simulation
        D2D1_POINT_2F dir = {
            targetProjectionEnd.x - targetStartPoint.x,
            targetProjectionEnd.y - targetStartPoint.y
        };
        float dirLen = sqrtf(dir.x * dir.x + dir.y * dir.y);
        dir.x /= dirLen;
        dir.y /= dirLen;

        D2D1_POINT_2F perp = { -dir.y, dir.x };

        // Approximate cue ball center by reversing from tip
        D2D1_POINT_2F cueBallCenterForGhostHit = { // Renamed for clarity if you use it elsewhere
            targetStartPoint.x - dir.x * BALL_RADIUS,
            targetStartPoint.y - dir.y * BALL_RADIUS
        };

        // REAL contact-ball center - use your physics object's center:
        // (replace 'objectBallPos' with whatever you actually call it)
        // (targetStartPoint is already hitBall->x, hitBall->y)
        D2D1_POINT_2F contactBallCenter = targetStartPoint; // Corrected: Use the object ball's actual center
        //D2D1_POINT_2F contactBallCenter = D2D1::Point2F(hitBall->x, hitBall->y);

       // The 'offset' calculation below uses 'cueBallCenterForGhostHit' (originally 'cueBallCenter').
       // This will result in 'offset' being 0 because 'cueBallCenterForGhostHit' is defined
       // such that (targetStartPoint - cueBallCenterForGhostHit) is parallel to 'dir',
       // and 'perp' is perpendicular to 'dir'.
       // Consider Change 2 if this 'offset' is not behaving as intended for the secondary line.
        /*float offset = ((targetStartPoint.x - cueBallCenterForGhostHit.x) * perp.x +
            (targetStartPoint.y - cueBallCenterForGhostHit.y) * perp.y);*/
            /*float offset = ((targetStartPoint.x - cueBallCenter.x) * perp.x +
                (targetStartPoint.y - cueBallCenter.y) * perp.y);
            float absOffset = fabsf(offset);
            float side = (offset >= 0 ? 1.0f : -1.0f);*/

            // Use actual cue ball center for offset calculation if 'offset' is meant to quantify the cut
        D2D1_POINT_2F actualCueBallPhysicalCenter = D2D1::Point2F(cueBall->x, cueBall->y); // This is also rayStart

        // Offset calculation based on actual cue ball position relative to the 'dir' line through targetStartPoint
        float offset = ((targetStartPoint.x - actualCueBallPhysicalCenter.x) * perp.x +
            (targetStartPoint.y - actualCueBallPhysicalCenter.y) * perp.y);
        float absOffset = fabsf(offset);
        float side = (offset >= 0 ? 1.0f : -1.0f);


        // Actual contact point on target ball edge
        D2D1_POINT_2F contactPoint = {
        contactBallCenter.x + perp.x * BALL_RADIUS * side,
        contactBallCenter.y + perp.y * BALL_RADIUS * side
        };

        // Tangent (cut shot) path from contact point
            // Tangent (cut shot) path: from contact point to contact ball center
        D2D1_POINT_2F objectBallDir = {
            contactBallCenter.x - contactPoint.x,
            contactBallCenter.y - contactPoint.y
        };
        float oLen = sqrtf(objectBallDir.x * objectBallDir.x + objectBallDir.y * objectBallDir.y);
        if (oLen != 0.0f) {
            objectBallDir.x /= oLen;
            objectBallDir.y /= oLen;
        }

        const float PRIMARY_LEN = 150.0f; //default=150.0f
        const float SECONDARY_LEN = 150.0f; //default=150.0f
        const float STRAIGHT_EPSILON = BALL_RADIUS * 0.05f;

        D2D1_POINT_2F primaryEnd = {
            targetStartPoint.x + dir.x * PRIMARY_LEN,
            targetStartPoint.y + dir.y * PRIMARY_LEN
        };

        // Secondary line starts from the contact ball's center
        D2D1_POINT_2F secondaryStart = contactBallCenter;
        D2D1_POINT_2F secondaryEnd = {
            secondaryStart.x + objectBallDir.x * SECONDARY_LEN,
            secondaryStart.y + objectBallDir.y * SECONDARY_LEN
        };

        if (absOffset < STRAIGHT_EPSILON)  // straight shot?
        {
            // Straight: secondary behind primary
                    // secondary behind primary {pDashedStyle param at end}
            pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
            //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
            pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
            //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
        }
        else
        {
            // Cut shot: both visible
                    // both visible for cut shot
            pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
            //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
            pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
            //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
        }
        // End improved trajectory logic

    //new code end

        // -- Cue Ball Path after collision (Optional, requires physics) --
        // Very simplified: Assume cue deflects, angle depends on cut angle.
        // float cutAngle = acosf(cosf(cueAngle - targetProjectionAngle)); // Angle between paths
        // float cueDeflectionAngle = ? // Depends on cutAngle, spin, etc. Hard to predict accurately.
        // D2D1_POINT_2F cueProjectionEnd = ...
        // pRT->DrawLine(ballCollisionPoint, cueProjectionEnd, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

        // --- Accuracy Comment ---
        // Note: The visual accuracy of this projection, especially for cut shots (hitting the ball off-center)
        // or shots with spin, is limited by the simplified physics model. Real pool physics involves
        // collision-induced throw, spin transfer, and cue ball deflection not fully simulated here.
        // The ghost ball method shows the *ideal* line for a center-cue hit without spin.

    }
    else if (aimingAtRail && hitRailIndex != -1) {
        // Aiming at a rail: Draw reflection line
        float reflectAngle = cueAngle;
        // Reflect angle based on which rail was hit
        if (hitRailIndex == 0 || hitRailIndex == 1) { // Left or Right rail
            reflectAngle = PI - cueAngle; // Reflect horizontal component
        }
        else { // Top or Bottom rail
            reflectAngle = -cueAngle; // Reflect vertical component
        }
        // Normalize angle if needed (atan2 usually handles this)
        while (reflectAngle > PI) reflectAngle -= 2 * PI;
        while (reflectAngle <= -PI) reflectAngle += 2 * PI;


        float reflectionLength = 60.0f; // Length of the reflection line
        D2D1_POINT_2F reflectionEnd = D2D1::Point2F(
            finalLineEnd.x + cosf(reflectAngle) * reflectionLength,
            finalLineEnd.y + sinf(reflectAngle) * reflectionLength
        );

        // Draw the reflection line (e.g., using a different color/style)
        pRT->DrawLine(finalLineEnd, reflectionEnd, pReflectBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);
    }

    // Release resources
    SafeRelease(&pBrush);
    SafeRelease(&pGhostBrush);
    SafeRelease(&pCueBrush);
    SafeRelease(&pReflectBrush); // Release new brush
    SafeRelease(&pCyanBrush);
    SafeRelease(&pPurpleBrush);
    SafeRelease(&pDashedStyle);
}


void DrawUI(ID2D1RenderTarget* pRT) {
    if (!pTextFormat || !pLargeTextFormat) return;

    ID2D1SolidColorBrush* pBrush = nullptr;
    pRT->CreateSolidColorBrush(UI_TEXT_COLOR, &pBrush);
    if (!pBrush) return;

    // --- Player Info Area (Top Left/Right) --- (Unchanged)
    float uiTop = TABLE_TOP - 80;
    float uiHeight = 60;
    float p1Left = TABLE_LEFT;
    float p1Width = 150;
    float p2Left = TABLE_RIGHT - p1Width;
    D2D1_RECT_F p1Rect = D2D1::RectF(p1Left, uiTop, p1Left + p1Width, uiTop + uiHeight);
    D2D1_RECT_F p2Rect = D2D1::RectF(p2Left, uiTop, p2Left + p1Width, uiTop + uiHeight);

    // Player 1 Info Text (Unchanged)
    std::wostringstream oss1;
    oss1 << player1Info.name.c_str() << L""\n"";
    if (player1Info.assignedType != BallType::NONE) {
        oss1 << ((player1Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
        oss1 << L"" ["" << player1Info.ballsPocketedCount << L""/7]"";
    }
    else {
        oss1 << L""(Undecided)"";
    }
    pRT->DrawText(oss1.str().c_str(), (UINT32)oss1.str().length(), pTextFormat, &p1Rect, pBrush);
    // Draw Player 1 Side Ball
    if (player1Info.assignedType != BallType::NONE)
    {
        ID2D1SolidColorBrush* pBallBrush = nullptr;
        D2D1_COLOR_F ballColor = (player1Info.assignedType == BallType::SOLID) ?
            D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
        pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
        if (pBallBrush)
        {
            D2D1_POINT_2F ballCenter = D2D1::Point2F(p1Rect.right + 10.0f, p1Rect.top + 20.0f);
            float radius = 10.0f;
            D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
            pRT->FillEllipse(&ball, pBallBrush);
            SafeRelease(&pBallBrush);
            // Draw border around the ball
            ID2D1SolidColorBrush* pBorderBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
            if (pBorderBrush)
            {
                pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                SafeRelease(&pBorderBrush);
            }

            // If stripes, draw a stripe band
            if (player1Info.assignedType == BallType::STRIPE)
            {
                ID2D1SolidColorBrush* pStripeBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                if (pStripeBrush)
                {
                    D2D1_RECT_F stripeRect = D2D1::RectF(
                        ballCenter.x - radius,
                        ballCenter.y - 3.0f,
                        ballCenter.x + radius,
                        ballCenter.y + 3.0f
                    );
                    pRT->FillRectangle(&stripeRect, pStripeBrush);
                    SafeRelease(&pStripeBrush);
                }
            }
        }
    }


    // Player 2 Info Text (Unchanged)
    std::wostringstream oss2;
    oss2 << player2Info.name.c_str() << L""\n"";
    if (player2Info.assignedType != BallType::NONE) {
        oss2 << ((player2Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
        oss2 << L"" ["" << player2Info.ballsPocketedCount << L""/7]"";
    }
    else {
        oss2 << L""(Undecided)"";
    }
    pRT->DrawText(oss2.str().c_str(), (UINT32)oss2.str().length(), pTextFormat, &p2Rect, pBrush);
    // Draw Player 2 Side Ball
    if (player2Info.assignedType != BallType::NONE)
    {
        ID2D1SolidColorBrush* pBallBrush = nullptr;
        D2D1_COLOR_F ballColor = (player2Info.assignedType == BallType::SOLID) ?
            D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
        pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
        if (pBallBrush)
        {
            D2D1_POINT_2F ballCenter = D2D1::Point2F(p2Rect.right + 10.0f, p2Rect.top + 20.0f);
            float radius = 10.0f;
            D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
            pRT->FillEllipse(&ball, pBallBrush);
            SafeRelease(&pBallBrush);
            // Draw border around the ball
            ID2D1SolidColorBrush* pBorderBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
            if (pBorderBrush)
            {
                pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                SafeRelease(&pBorderBrush);
            }

            // If stripes, draw a stripe band
            if (player2Info.assignedType == BallType::STRIPE)
            {
                ID2D1SolidColorBrush* pStripeBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                if (pStripeBrush)
                {
                    D2D1_RECT_F stripeRect = D2D1::RectF(
                        ballCenter.x - radius,
                        ballCenter.y - 3.0f,
                        ballCenter.x + radius,
                        ballCenter.y + 3.0f
                    );
                    pRT->FillRectangle(&stripeRect, pStripeBrush);
                    SafeRelease(&pStripeBrush);
                }
            }
        }
    }

    // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
    ID2D1SolidColorBrush* pArrowBrush = nullptr;
    pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
    if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
        float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
        float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
        float arrowTipX, arrowBackX;

        D2D1_RECT_F playerBox = (currentPlayer == 1) ? p1Rect : p2Rect;
        arrowBackX = playerBox.left - 25.0f;
        arrowTipX = arrowBackX + arrowSizeBase * 0.75f;

        float notchDepth = 12.0f;  // Increased from 6.0f to make the rectangle longer
        float notchWidth = 10.0f;

        float cx = arrowBackX;
        float cy = arrowCenterY;

        // Define triangle + rectangle tail shape
        D2D1_POINT_2F tip = D2D1::Point2F(arrowTipX, cy);                           // tip
        D2D1_POINT_2F baseTop = D2D1::Point2F(cx, cy - arrowSizeBase / 2.0f);          // triangle top
        D2D1_POINT_2F baseBot = D2D1::Point2F(cx, cy + arrowSizeBase / 2.0f);          // triangle bottom

        // Rectangle coordinates for the tail portion:
        D2D1_POINT_2F r1 = D2D1::Point2F(cx - notchDepth, cy - notchWidth / 2.0f);   // rect top-left
        D2D1_POINT_2F r2 = D2D1::Point2F(cx, cy - notchWidth / 2.0f);                 // rect top-right
        D2D1_POINT_2F r3 = D2D1::Point2F(cx, cy + notchWidth / 2.0f);                 // rect bottom-right
        D2D1_POINT_2F r4 = D2D1::Point2F(cx - notchDepth, cy + notchWidth / 2.0f);    // rect bottom-left

        ID2D1PathGeometry* pPath = nullptr;
        if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
            ID2D1GeometrySink* pSink = nullptr;
            if (SUCCEEDED(pPath->Open(&pSink))) {
                pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
                pSink->AddLine(baseTop);
                pSink->AddLine(r2); // transition from triangle into rectangle
                pSink->AddLine(r1);
                pSink->AddLine(r4);
                pSink->AddLine(r3);
                pSink->AddLine(baseBot);
                pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                pSink->Close();
                SafeRelease(&pSink);
                pRT->FillGeometry(pPath, pArrowBrush);
            }
            SafeRelease(&pPath);
        }


        SafeRelease(&pArrowBrush);
    }

    //original
/*
    // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
    ID2D1SolidColorBrush* pArrowBrush = nullptr;
    pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
    if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
        float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
        float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
        float arrowTipX, arrowBackX;

        if (currentPlayer == 1) {
arrowBackX = p1Rect.left - 25.0f; // Position left of the box
            arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
            // Define points for right-pointing arrow
            //D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
            //D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
            //D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back
            // Enhanced arrow with base rectangle intersection
    float notchDepth = 6.0f; // Depth of square base ""stem""
    float notchWidth = 4.0f; // Thickness of square part

    D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
    D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
    D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY - notchWidth / 2.0f); // Square Left-Top
    D2D1_POINT_2F pt4 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY + notchWidth / 2.0f); // Square Left-Bottom
    D2D1_POINT_2F pt5 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back


    ID2D1PathGeometry* pPath = nullptr;
    if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
        ID2D1GeometrySink* pSink = nullptr;
        if (SUCCEEDED(pPath->Open(&pSink))) {
            pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
            pSink->AddLine(pt2);
            pSink->AddLine(pt3);
            pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
            pSink->Close();
            SafeRelease(&pSink);
            pRT->FillGeometry(pPath, pArrowBrush);
        }
        SafeRelease(&pPath);
    }
        }


        //==================else player 2
        else { // Player 2
         // Player 2: Arrow left of P2 box, pointing right (or right of P2 box pointing left?)
         // Let's keep it consistent: Arrow left of the active player's box, pointing right.
// Let's keep it consistent: Arrow left of the active player's box, pointing right.
arrowBackX = p2Rect.left - 25.0f; // Position left of the box
arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
// Define points for right-pointing arrow
D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back

ID2D1PathGeometry* pPath = nullptr;
if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
    ID2D1GeometrySink* pSink = nullptr;
    if (SUCCEEDED(pPath->Open(&pSink))) {
        pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
        pSink->AddLine(pt2);
        pSink->AddLine(pt3);
        pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
        pSink->Close();
        SafeRelease(&pSink);
        pRT->FillGeometry(pPath, pArrowBrush);
    }
    SafeRelease(&pPath);
}
        }
        */

        // --- MODIFIED: Foul Text (Large Red, Bottom Center) ---
    if (foulCommitted && currentGameState != SHOT_IN_PROGRESS) {
        ID2D1SolidColorBrush* pFoulBrush = nullptr;
        pRT->CreateSolidColorBrush(FOUL_TEXT_COLOR, &pFoulBrush);
        if (pFoulBrush && pLargeTextFormat) {
            // Calculate Rect for bottom-middle area
            float foulWidth = 200.0f; // Adjust width as needed
            float foulHeight = 60.0f;
            float foulLeft = TABLE_LEFT + (TABLE_WIDTH / 2.0f) - (foulWidth / 2.0f);
            // Position below the pocketed balls bar
            float foulTop = pocketedBallsBarRect.bottom + 10.0f;
            D2D1_RECT_F foulRect = D2D1::RectF(foulLeft, foulTop, foulLeft + foulWidth, foulTop + foulHeight);

            // --- Set text alignment to center for foul text ---
            pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

            pRT->DrawText(L""FOUL!"", 5, pLargeTextFormat, &foulRect, pFoulBrush);

            // --- Restore default alignment for large text if needed elsewhere ---
            // pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
            // pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

            SafeRelease(&pFoulBrush);
        }
    }

    // --- 8-Ball Pocket Selection Arrow & Prompt ---
    if (currentGameState == CHOOSING_POCKET_P1 || currentGameState == CHOOSING_POCKET_P2) {
        // Determine which pocket to highlight (default to Top-Right if unset)
        int idx = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        if (idx < 0) idx = 2;

        // Draw the downward arrow
        ID2D1SolidColorBrush* pArrowBrush = nullptr;
        pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
        if (pArrowBrush) {
            D2D1_POINT_2F P = pocketPositions[idx];
            D2D1_POINT_2F tri[3] = {
                {P.x - 10.0f, P.y - 30.0f},
                {P.x + 10.0f, P.y - 30.0f},
                {P.x        , P.y - 10.0f}
            };
            ID2D1PathGeometry* geom = nullptr;
            pFactory->CreatePathGeometry(&geom);
            ID2D1GeometrySink* sink = nullptr;
            geom->Open(&sink);
            sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
            sink->AddLines(&tri[1], 2);
            sink->EndFigure(D2D1_FIGURE_END_CLOSED);
            sink->Close();
            pRT->FillGeometry(geom, pArrowBrush);
            SafeRelease(&sink);
            SafeRelease(&geom);
            SafeRelease(&pArrowBrush);
        }

        // Draw “Choose a pocket...” text under the table
        D2D1_RECT_F prompt = D2D1::RectF(
            TABLE_LEFT,
            TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
            TABLE_RIGHT,
            TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
        );
        pRT->DrawText(
            L""Choose a pocket..."",
            (UINT32)wcslen(L""Choose a pocket...""),
            pTextFormat,
            &prompt,
            pBrush
        );

        return; // Skip normal turn/foul text
    }


    // Show AI Thinking State (Unchanged from previous step)
    if (currentGameState == AI_THINKING && pTextFormat) {
        ID2D1SolidColorBrush* pThinkingBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pThinkingBrush);
        if (pThinkingBrush) {
            D2D1_RECT_F thinkingRect = p2Rect;
            thinkingRect.top += 20; // Offset within P2 box
            // Ensure default text alignment for this
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
            pRT->DrawText(L""Thinking..."", 11, pTextFormat, &thinkingRect, pThinkingBrush);
            SafeRelease(&pThinkingBrush);
        }
    }

    SafeRelease(&pBrush);

    // --- Draw CHEAT MODE label if active ---
    if (cheatModeEnabled) {
        ID2D1SolidColorBrush* pCheatBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Red), &pCheatBrush);
        if (pCheatBrush && pTextFormat) {
            D2D1_RECT_F cheatTextRect = D2D1::RectF(
                TABLE_LEFT + 10.0f,
                TABLE_TOP + 10.0f,
                TABLE_LEFT + 200.0f,
                TABLE_TOP + 40.0f
            );
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
            pRT->DrawText(L""CHEAT MODE ON"", wcslen(L""CHEAT MODE ON""), pTextFormat, &cheatTextRect, pCheatBrush);
        }
        SafeRelease(&pCheatBrush);
    }
}

void DrawPowerMeter(ID2D1RenderTarget* pRT) {
    // Draw Border
    ID2D1SolidColorBrush* pBorderBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
    if (!pBorderBrush) return;
    pRT->DrawRectangle(&powerMeterRect, pBorderBrush, 2.0f);
    SafeRelease(&pBorderBrush);

    // Create Gradient Fill
    ID2D1GradientStopCollection* pGradientStops = nullptr;
    ID2D1LinearGradientBrush* pGradientBrush = nullptr;
    D2D1_GRADIENT_STOP gradientStops[4];
    gradientStops[0].position = 0.0f;
    gradientStops[0].color = D2D1::ColorF(D2D1::ColorF::Green);
    gradientStops[1].position = 0.45f;
    gradientStops[1].color = D2D1::ColorF(D2D1::ColorF::Yellow);
    gradientStops[2].position = 0.7f;
    gradientStops[2].color = D2D1::ColorF(D2D1::ColorF::Orange);
    gradientStops[3].position = 1.0f;
    gradientStops[3].color = D2D1::ColorF(D2D1::ColorF::Red);

    pRT->CreateGradientStopCollection(gradientStops, 4, &pGradientStops);
    if (pGradientStops) {
        D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES props = {};
        props.startPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.bottom);
        props.endPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.top);
        pRT->CreateLinearGradientBrush(props, pGradientStops, &pGradientBrush);
        SafeRelease(&pGradientStops);
    }

    // Calculate Fill Height
    float fillRatio = 0;
    //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
        // Determine if power meter should reflect shot power (human aiming or AI preparing)
    bool humanIsAimingPower = isAiming && (currentGameState == AIMING || currentGameState == BREAKING);
    // NEW Condition: AI is displaying its aim, so show its chosen power
    bool aiIsVisualizingPower = (isPlayer2AI && currentPlayer == 2 &&
        currentGameState == AI_THINKING && aiIsDisplayingAim);

    if (humanIsAimingPower || aiIsVisualizingPower) { // Use the new condition
        fillRatio = shotPower / MAX_SHOT_POWER;
    }
    float fillHeight = (powerMeterRect.bottom - powerMeterRect.top) * fillRatio;
    D2D1_RECT_F fillRect = D2D1::RectF(
        powerMeterRect.left,
        powerMeterRect.bottom - fillHeight,
        powerMeterRect.right,
        powerMeterRect.bottom
    );

    if (pGradientBrush) {
        pRT->FillRectangle(&fillRect, pGradientBrush);
        SafeRelease(&pGradientBrush);
    }

    // Draw scale notches
    ID2D1SolidColorBrush* pNotchBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pNotchBrush);
    if (pNotchBrush) {
        for (int i = 0; i <= 8; ++i) {
            float y = powerMeterRect.top + (powerMeterRect.bottom - powerMeterRect.top) * (i / 8.0f);
            pRT->DrawLine(
                D2D1::Point2F(powerMeterRect.right + 2.0f, y),
                D2D1::Point2F(powerMeterRect.right + 8.0f, y),
                pNotchBrush,
                1.5f
            );
        }
        SafeRelease(&pNotchBrush);
    }

    // Draw ""Power"" Label Below Meter
    if (pTextFormat) {
        ID2D1SolidColorBrush* pTextBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pTextBrush);
        if (pTextBrush) {
            D2D1_RECT_F textRect = D2D1::RectF(
                powerMeterRect.left - 20.0f,
                powerMeterRect.bottom + 8.0f,
                powerMeterRect.right + 20.0f,
                powerMeterRect.bottom + 38.0f
            );
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
            pRT->DrawText(L""Power"", 5, pTextFormat, &textRect, pTextBrush);
            SafeRelease(&pTextBrush);
        }
    }

    // Draw Glow Effect if fully charged or fading out
    static float glowPulse = 0.0f;
    static bool glowIncreasing = true;
    static float glowFadeOut = 0.0f; // NEW: tracks fading out

    if (shotPower >= MAX_SHOT_POWER * 0.99f) {
        // While fully charged, keep pulsing normally
        if (glowIncreasing) {
            glowPulse += 0.02f;
            if (glowPulse >= 1.0f) glowIncreasing = false;
        }
        else {
            glowPulse -= 0.02f;
            if (glowPulse <= 0.0f) glowIncreasing = true;
        }
        glowFadeOut = 1.0f; // Reset fade out to full
    }
    else if (glowFadeOut > 0.0f) {
        // If shot fired, gradually fade out
        glowFadeOut -= 0.02f;
        if (glowFadeOut < 0.0f) glowFadeOut = 0.0f;
    }

    if (glowFadeOut > 0.0f) {
        ID2D1SolidColorBrush* pGlowBrush = nullptr;
        float effectiveOpacity = (0.3f + 0.7f * glowPulse) * glowFadeOut;
        pRT->CreateSolidColorBrush(
            D2D1::ColorF(D2D1::ColorF::Red, effectiveOpacity),
            &pGlowBrush
        );
        if (pGlowBrush) {
            float glowCenterX = (powerMeterRect.left + powerMeterRect.right) / 2.0f;
            float glowCenterY = powerMeterRect.top;
            D2D1_ELLIPSE glowEllipse = D2D1::Ellipse(
                D2D1::Point2F(glowCenterX, glowCenterY - 10.0f),
                12.0f + 3.0f * glowPulse,
                6.0f + 2.0f * glowPulse
            );
            pRT->FillEllipse(&glowEllipse, pGlowBrush);
            SafeRelease(&pGlowBrush);
        }
    }
}

void DrawSpinIndicator(ID2D1RenderTarget* pRT) {
    ID2D1SolidColorBrush* pWhiteBrush = nullptr;
    ID2D1SolidColorBrush* pRedBrush = nullptr;

    pRT->CreateSolidColorBrush(CUE_BALL_COLOR, &pWhiteBrush);
    pRT->CreateSolidColorBrush(ENGLISH_DOT_COLOR, &pRedBrush);

    if (!pWhiteBrush || !pRedBrush) {
        SafeRelease(&pWhiteBrush);
        SafeRelease(&pRedBrush);
        return;
    }

    // Draw White Ball Background
    D2D1_ELLIPSE bgEllipse = D2D1::Ellipse(spinIndicatorCenter, spinIndicatorRadius, spinIndicatorRadius);
    pRT->FillEllipse(&bgEllipse, pWhiteBrush);
    pRT->DrawEllipse(&bgEllipse, pRedBrush, 0.5f); // Thin red border


    // Draw Red Dot for Spin Position
    float dotRadius = 4.0f;
    float dotX = spinIndicatorCenter.x + cueSpinX * (spinIndicatorRadius - dotRadius); // Keep dot inside edge
    float dotY = spinIndicatorCenter.y + cueSpinY * (spinIndicatorRadius - dotRadius);
    D2D1_ELLIPSE dotEllipse = D2D1::Ellipse(D2D1::Point2F(dotX, dotY), dotRadius, dotRadius);
    pRT->FillEllipse(&dotEllipse, pRedBrush);

    SafeRelease(&pWhiteBrush);
    SafeRelease(&pRedBrush);
}


void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT) {
    ID2D1SolidColorBrush* pBgBrush = nullptr;
    ID2D1SolidColorBrush* pBallBrush = nullptr;

    // Ensure render target is valid before proceeding
    if (!pRT) return;

    HRESULT hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black, 0.8f), &pBgBrush); // Semi-transparent black
    if (FAILED(hr)) { SafeRelease(&pBgBrush); return; } // Exit if brush creation fails

    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBallBrush); // Placeholder, color will be set per ball
    if (FAILED(hr)) {
        SafeRelease(&pBgBrush);
        SafeRelease(&pBallBrush);
        return; // Exit if brush creation fails
    }

    // Draw the background bar (rounded rect)
    D2D1_ROUNDED_RECT roundedRect = D2D1::RoundedRect(pocketedBallsBarRect, 10.0f, 10.0f); // Corner radius 10
    float baseAlpha = 0.8f;
    float flashBoost = pocketFlashTimer * 0.5f; // Make flash effect boost alpha slightly
    float finalAlpha = std::min(1.0f, baseAlpha + flashBoost);
    pBgBrush->SetOpacity(finalAlpha);
    pRT->FillRoundedRectangle(&roundedRect, pBgBrush);
    pBgBrush->SetOpacity(1.0f); // Reset opacity after drawing

    // --- Draw small circles for pocketed balls inside the bar ---

    // Calculate dimensions based on the bar's height for better scaling
    float barHeight = pocketedBallsBarRect.bottom - pocketedBallsBarRect.top;
    float ballDisplayRadius = barHeight * 0.30f; // Make balls slightly smaller relative to bar height
    float spacing = ballDisplayRadius * 2.2f; // Adjust spacing slightly
    float padding = spacing * 0.75f; // Add padding from the edges
    float center_Y = pocketedBallsBarRect.top + barHeight / 2.0f; // Vertical center

    // Starting X positions with padding
    float currentX_P1 = pocketedBallsBarRect.left + padding;
    float currentX_P2 = pocketedBallsBarRect.right - padding; // Start from right edge minus padding

    int p1DrawnCount = 0;
    int p2DrawnCount = 0;
    const int maxBallsToShow = 7; // Max balls per player in the bar

    for (const auto& b : balls) {
        if (b.isPocketed) {
            // Skip cue ball and 8-ball in this indicator
            if (b.id == 0 || b.id == 8) continue;

            bool isPlayer1Ball = (player1Info.assignedType != BallType::NONE && b.type == player1Info.assignedType);
            bool isPlayer2Ball = (player2Info.assignedType != BallType::NONE && b.type == player2Info.assignedType);

            if (isPlayer1Ball && p1DrawnCount < maxBallsToShow) {
                pBallBrush->SetColor(b.color);
                // Draw P1 balls from left to right
                D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P1 + p1DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                pRT->FillEllipse(&ballEllipse, pBallBrush);
                p1DrawnCount++;
            }
            else if (isPlayer2Ball && p2DrawnCount < maxBallsToShow) {
                pBallBrush->SetColor(b.color);
                // Draw P2 balls from right to left
                D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P2 - p2DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                pRT->FillEllipse(&ballEllipse, pBallBrush);
                p2DrawnCount++;
            }
            // Note: Balls pocketed before assignment or opponent balls are intentionally not shown here.
            // You could add logic here to display them differently if needed (e.g., smaller, grayed out).
        }
    }

    SafeRelease(&pBgBrush);
    SafeRelease(&pBallBrush);
}

void DrawBallInHandIndicator(ID2D1RenderTarget* pRT) {
    if (!isDraggingCueBall && (currentGameState != BALL_IN_HAND_P1 && currentGameState != BALL_IN_HAND_P2 && currentGameState != PRE_BREAK_PLACEMENT)) {
        return; // Only show when placing/dragging
    }

    Ball* cueBall = GetCueBall();
    if (!cueBall) return;

    ID2D1SolidColorBrush* pGhostBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.6f), &pGhostBrush); // Semi-transparent white

    if (pGhostBrush) {
        D2D1_POINT_2F drawPos;
        if (isDraggingCueBall) {
            drawPos = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
        }
        else {
            // If not dragging but in placement state, show at current ball pos
            drawPos = D2D1::Point2F(cueBall->x, cueBall->y);
        }

        // Check if the placement is valid before drawing differently?
        bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
        bool isValid = IsValidCueBallPosition(drawPos.x, drawPos.y, behindHeadstring);

        if (!isValid) {
            // Maybe draw red outline if invalid placement?
            pGhostBrush->SetColor(D2D1::ColorF(D2D1::ColorF::Red, 0.6f));
        }


        D2D1_ELLIPSE ghostEllipse = D2D1::Ellipse(drawPos, BALL_RADIUS, BALL_RADIUS);
        pRT->FillEllipse(&ghostEllipse, pGhostBrush);
        pRT->DrawEllipse(&ghostEllipse, pGhostBrush, 1.0f); // Outline

        SafeRelease(&pGhostBrush);
    }
}

void DrawPocketSelectionIndicator(ID2D1RenderTarget* pRT) {
    int pocketToIndicate = -1;
    // A human player is actively choosing if they are in the CHOOSING_POCKET state.
    bool isHumanChoosing = (currentGameState == CHOOSING_POCKET_P1 || (currentGameState == CHOOSING_POCKET_P2 && !isPlayer2AI));

    if (isHumanChoosing) {
        // When choosing, show the currently selected pocket (which has a default).
        pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
    }
    else if (IsPlayerOnEightBall(currentPlayer)) {
        // If it's a normal turn but the player is on the 8-ball, show their called pocket as a reminder.
        pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
    }

    if (pocketToIndicate < 0 || pocketToIndicate > 5) {
        return; // Don't draw if no pocket is selected or relevant.
    }

    ID2D1SolidColorBrush* pArrowBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Yellow, 0.9f), &pArrowBrush);
    if (!pArrowBrush) return;

    // ... The rest of your arrow drawing geometry logic remains exactly the same ...
    // (No changes needed to the points/path drawing, only the logic above)
    D2D1_POINT_2F targetPocketCenter = pocketPositions[pocketToIndicate];
    float arrowHeadSize = HOLE_VISUAL_RADIUS * 0.5f;
    float arrowShaftLength = HOLE_VISUAL_RADIUS * 0.3f;
    float arrowShaftWidth = arrowHeadSize * 0.4f;
    float verticalOffsetFromPocketCenter = HOLE_VISUAL_RADIUS * 1.6f;
    D2D1_POINT_2F tip, baseLeft, baseRight, shaftTopLeft, shaftTopRight, shaftBottomLeft, shaftBottomRight;

    if (targetPocketCenter.y == TABLE_TOP) {
        tip = D2D1::Point2F(targetPocketCenter.x, targetPocketCenter.y + verticalOffsetFromPocketCenter + arrowHeadSize);
        baseLeft = D2D1::Point2F(targetPocketCenter.x - arrowHeadSize / 2.0f, targetPocketCenter.y + verticalOffsetFromPocketCenter);
        baseRight = D2D1::Point2F(targetPocketCenter.x + arrowHeadSize / 2.0f, targetPocketCenter.y + verticalOffsetFromPocketCenter);
        shaftTopLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y);
        shaftTopRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y);
        shaftBottomLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y - arrowShaftLength);
        shaftBottomRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y - arrowShaftLength);
    }
    else {
        tip = D2D1::Point2F(targetPocketCenter.x, targetPocketCenter.y - verticalOffsetFromPocketCenter - arrowHeadSize);
        baseLeft = D2D1::Point2F(targetPocketCenter.x - arrowHeadSize / 2.0f, targetPocketCenter.y - verticalOffsetFromPocketCenter);
        baseRight = D2D1::Point2F(targetPocketCenter.x + arrowHeadSize / 2.0f, targetPocketCenter.y - verticalOffsetFromPocketCenter);
        shaftTopLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y + arrowShaftLength);
        shaftTopRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y + arrowShaftLength);
        shaftBottomLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y);
        shaftBottomRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y);
    }

    ID2D1PathGeometry* pPath = nullptr;
    if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
        ID2D1GeometrySink* pSink = nullptr;
        if (SUCCEEDED(pPath->Open(&pSink))) {
            pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
            pSink->AddLine(baseLeft); pSink->AddLine(shaftBottomLeft); pSink->AddLine(shaftTopLeft);
            pSink->AddLine(shaftTopRight); pSink->AddLine(shaftBottomRight); pSink->AddLine(baseRight);
            pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
            pSink->Close();
            SafeRelease(&pSink);
            pRT->FillGeometry(pPath, pArrowBrush);
        }
        SafeRelease(&pPath);
    }
    SafeRelease(&pArrowBrush);
}
```"
4h06pUiq,2025-06-30_stats.json,rdp_snitch,JSON,Monday 30th of June 2025 07:18:22 PM CDT,"{
  ""ip"": {
    ""188.213.128.212"": 9930,
    ""24.173.30.170"": 12732,
    ""81.29.134.51"": 3,
    ""91.238.181.95"": 6,
    ""193.142.146.227"": 18,
    ""194.165.16.166"": 6,
    ""138.68.188.52"": 3,
    ""205.210.31.89"": 9,
    ""196.251.70.121"": 9,
    ""208.68.37.100"": 6,
    ""157.245.238.50"": 12,
    ""45.79.73.143"": 3,
    ""161.35.215.131"": 9,
    ""198.235.24.108"": 9,
    ""134.209.13.14"": 12,
    ""104.237.134.228"": 3,
    ""68.183.179.179"": 3,
    ""2.57.121.247"": 12,
    ""205.210.31.245"": 9,
    ""185.242.226.23"": 3,
    ""165.154.100.252"": 3,
    ""102.88.21.215"": 3,
    ""45.146.130.128"": 6,
    ""147.185.132.147"": 9,
    ""111.170.152.113"": 6,
    ""195.3.223.186"": 3,
    ""91.238.181.92"": 6
  },
  ""asn"": {
    ""AS29222"": 9930,
    ""AS11427"": 12732,
    ""AS12555"": 3,
    ""AS49434"": 12,
    ""AS213438"": 18,
    ""AS48721"": 6,
    ""AS14061"": 45,
    ""AS396982"": 36,
    ""AS401120"": 9,
    ""AS63949"": 6,
    ""AS47890"": 12,
    ""AS202425"": 3,
    ""AS135377"": 3,
    ""AS29465"": 3,
    ""AS213790"": 6,
    ""AS151185"": 6,
    ""AS201814"": 3
  },
  ""isp"": {
    ""Infomaniak Network SA"": 9930,
    ""Charter Communications Inc"": 12732,
    ""Data-center IMAQLIQ Ltd."": 3,
    ""Datacenter location PAR1 France"": 12,
    ""ColocaTel Inc."": 18,
    ""Flyservers S.A."": 6,
    ""DigitalOcean, LLC"": 45,
    ""Google LLC"": 36,
    ""cheapy.host LLC"": 9,
    ""Akamai Technologies, Inc."": 6,
    ""Unmanaged LTD"": 12,
    ""IP Volume inc"": 3,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 3,
    ""MTN NIGERIA Communication limited"": 3,
    ""Limited Network LTD"": 6,
    ""China Telecom"": 6,
    ""MEVSPACE sp. z o.o."": 3
  },
  ""org"": {
    ""Infomaniak Network SA"": 9930,
    ""Spectrum"": 12732,
    ""DC Imaqliq"": 3,
    ""ThinkTech Technology Industrial CO. Limited"": 12,
    ""ColocaTel Inc"": 18,
    ""Flyservers S.A"": 6,
    ""DigitalOcean, LLC"": 45,
    ""Palo Alto Networks, Inc"": 36,
    ""Internet Secuirty Cheapyhost"": 9,
    ""Linode"": 6,
    ""Unmanaged LTD"": 12,
    ""AI Spera"": 3,
    ""Ucloud Information Technology (hk) Limited"": 3,
    ""MTN Nigeria"": 3,
    ""Limited Network LTD"": 6,
    ""Chinanet HB"": 6,
    ""MEVSPACE sp. z o.o"": 3
  },
  ""regionName"": {
    ""Lucerne"": 9930,
    ""Texas"": 12735,
    ""Moscow"": 3,
    ""\u00cele-de-France"": 12,
    ""North Holland"": 21,
    ""Kaunas"": 6,
    ""England"": 15,
    ""California"": 63,
    ""La Rivi\u00e8re Anglaise"": 9,
    ""New Jersey"": 6,
    ""Hesse"": 9,
    ""South West"": 3,
    ""Metro Manila"": 3,
    ""Lagos"": 3,
    ""Federal District"": 6,
    ""Hubei"": 6,
    ""Mazovia"": 3
  },
  ""country"": {
    ""Switzerland"": 9930,
    ""United States"": 12804,
    ""Russia"": 3,
    ""France"": 12,
    ""The Netherlands"": 21,
    ""Lithuania"": 6,
    ""United Kingdom"": 15,
    ""Seychelles"": 9,
    ""Germany"": 9,
    ""Singapore"": 3,
    ""Philippines"": 3,
    ""Nigeria"": 3,
    ""Brazil"": 6,
    ""China"": 6,
    ""Poland"": 3
  },
  ""account"": {
    ""hello"": 22692,
    ""(empty)"": 3,
    ""Test"": 24,
    ""Domain"": 18,
    ""wlBGysfiq"": 3,
    ""NXXOQt"": 3,
    ""aDNgAW"": 3,
    ""Administr"": 24,
    ""uipchg00"": 12,
    ""beio"": 6,
    ""VIublcQVX"": 3,
    ""ulznaG"": 3,
    ""kJnKdc"": 3,
    ""uvu5r4g1"": 12,
    ""RvKdmjvBn"": 3,
    ""kUBzOR"": 3,
    ""necOGh"": 3,
    ""nmap"": 3,
    ""Administrator"": 3,
    ""EdfTamyRy"": 3,
    ""APHjtB"": 3,
    ""uPYKBW"": 3
  },
  ""keyboard"": {
    ""Unknown"": 22833
  },
  ""client_build"": {
    ""Unknown"": 22833
  },
  ""client_name"": {
    ""Unknown"": 22833
  },
  ""ip_type"": {
    ""mobile & hosting"": 9933,
    ""Unknown"": 12789,
    ""hosting"": 105,
    ""proxy"": 6
  }
}"
suedXC0C,2025-06-30_stats.json,rdp_snitch,JSON,Monday 30th of June 2025 07:16:18 PM CDT,"{
  ""ip"": {
    ""188.213.128.212"": 6620,
    ""24.173.30.170"": 8488,
    ""81.29.134.51"": 2,
    ""91.238.181.95"": 4,
    ""193.142.146.227"": 12,
    ""194.165.16.166"": 4,
    ""138.68.188.52"": 2,
    ""205.210.31.89"": 6,
    ""196.251.70.121"": 6,
    ""208.68.37.100"": 4,
    ""157.245.238.50"": 8,
    ""45.79.73.143"": 2,
    ""161.35.215.131"": 6,
    ""198.235.24.108"": 6,
    ""134.209.13.14"": 8,
    ""104.237.134.228"": 2,
    ""68.183.179.179"": 2,
    ""2.57.121.247"": 8,
    ""205.210.31.245"": 6,
    ""185.242.226.23"": 2,
    ""165.154.100.252"": 2,
    ""102.88.21.215"": 2,
    ""45.146.130.128"": 4,
    ""147.185.132.147"": 6,
    ""111.170.152.113"": 4,
    ""195.3.223.186"": 2,
    ""91.238.181.92"": 4
  },
  ""asn"": {
    ""AS29222"": 6620,
    ""AS11427"": 8488,
    ""AS12555"": 2,
    ""AS49434"": 8,
    ""AS213438"": 12,
    ""AS48721"": 4,
    ""AS14061"": 30,
    ""AS396982"": 24,
    ""AS401120"": 6,
    ""AS63949"": 4,
    ""AS47890"": 8,
    ""AS202425"": 2,
    ""AS135377"": 2,
    ""AS29465"": 2,
    ""AS213790"": 4,
    ""AS151185"": 4,
    ""AS201814"": 2
  },
  ""isp"": {
    ""Infomaniak Network SA"": 6620,
    ""Charter Communications Inc"": 8488,
    ""Data-center IMAQLIQ Ltd."": 2,
    ""Datacenter location PAR1 France"": 8,
    ""ColocaTel Inc."": 12,
    ""Flyservers S.A."": 4,
    ""DigitalOcean, LLC"": 30,
    ""Google LLC"": 24,
    ""cheapy.host LLC"": 6,
    ""Akamai Technologies, Inc."": 4,
    ""Unmanaged LTD"": 8,
    ""IP Volume inc"": 2,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 2,
    ""MTN NIGERIA Communication limited"": 2,
    ""Limited Network LTD"": 4,
    ""China Telecom"": 4,
    ""MEVSPACE sp. z o.o."": 2
  },
  ""org"": {
    ""Infomaniak Network SA"": 6620,
    ""Spectrum"": 8488,
    ""DC Imaqliq"": 2,
    ""ThinkTech Technology Industrial CO. Limited"": 8,
    ""ColocaTel Inc"": 12,
    ""Flyservers S.A"": 4,
    ""DigitalOcean, LLC"": 30,
    ""Palo Alto Networks, Inc"": 24,
    ""Internet Secuirty Cheapyhost"": 6,
    ""Linode"": 4,
    ""Unmanaged LTD"": 8,
    ""AI Spera"": 2,
    ""Ucloud Information Technology (hk) Limited"": 2,
    ""MTN Nigeria"": 2,
    ""Limited Network LTD"": 4,
    ""Chinanet HB"": 4,
    ""MEVSPACE sp. z o.o"": 2
  },
  ""regionName"": {
    ""Lucerne"": 6620,
    ""Texas"": 8490,
    ""Moscow"": 2,
    ""\u00cele-de-France"": 8,
    ""North Holland"": 14,
    ""Kaunas"": 4,
    ""England"": 10,
    ""California"": 42,
    ""La Rivi\u00e8re Anglaise"": 6,
    ""New Jersey"": 4,
    ""Hesse"": 6,
    ""South West"": 2,
    ""Metro Manila"": 2,
    ""Lagos"": 2,
    ""Federal District"": 4,
    ""Hubei"": 4,
    ""Mazovia"": 2
  },
  ""country"": {
    ""Switzerland"": 6620,
    ""United States"": 8536,
    ""Russia"": 2,
    ""France"": 8,
    ""The Netherlands"": 14,
    ""Lithuania"": 4,
    ""United Kingdom"": 10,
    ""Seychelles"": 6,
    ""Germany"": 6,
    ""Singapore"": 2,
    ""Philippines"": 2,
    ""Nigeria"": 2,
    ""Brazil"": 4,
    ""China"": 4,
    ""Poland"": 2
  },
  ""account"": {
    ""hello"": 15128,
    ""(empty)"": 2,
    ""Test"": 16,
    ""Domain"": 12,
    ""wlBGysfiq"": 2,
    ""NXXOQt"": 2,
    ""aDNgAW"": 2,
    ""Administr"": 16,
    ""uipchg00"": 8,
    ""beio"": 4,
    ""VIublcQVX"": 2,
    ""ulznaG"": 2,
    ""kJnKdc"": 2,
    ""uvu5r4g1"": 8,
    ""RvKdmjvBn"": 2,
    ""kUBzOR"": 2,
    ""necOGh"": 2,
    ""nmap"": 2,
    ""Administrator"": 2,
    ""EdfTamyRy"": 2,
    ""APHjtB"": 2,
    ""uPYKBW"": 2
  },
  ""keyboard"": {
    ""Unknown"": 15222
  },
  ""client_build"": {
    ""Unknown"": 15222
  },
  ""client_name"": {
    ""Unknown"": 15222
  },
  ""ip_type"": {
    ""mobile & hosting"": 6622,
    ""Unknown"": 8526,
    ""hosting"": 70,
    ""proxy"": 4
  }
}"
K87APbZi,2025-06-30_stats.json,rdp_snitch,JSON,Monday 30th of June 2025 07:15:10 PM CDT,"{
  ""ip"": {
    ""188.213.128.212"": 3310,
    ""24.173.30.170"": 4244,
    ""81.29.134.51"": 1,
    ""91.238.181.95"": 2,
    ""193.142.146.227"": 6,
    ""194.165.16.166"": 2,
    ""138.68.188.52"": 1,
    ""205.210.31.89"": 3,
    ""196.251.70.121"": 3,
    ""208.68.37.100"": 2,
    ""157.245.238.50"": 4,
    ""45.79.73.143"": 1,
    ""161.35.215.131"": 3,
    ""198.235.24.108"": 3,
    ""134.209.13.14"": 4,
    ""104.237.134.228"": 1,
    ""68.183.179.179"": 1,
    ""2.57.121.247"": 4,
    ""205.210.31.245"": 3,
    ""185.242.226.23"": 1,
    ""165.154.100.252"": 1,
    ""102.88.21.215"": 1,
    ""45.146.130.128"": 2,
    ""147.185.132.147"": 3,
    ""111.170.152.113"": 2,
    ""195.3.223.186"": 1,
    ""91.238.181.92"": 2
  },
  ""asn"": {
    ""AS29222"": 3310,
    ""AS11427"": 4244,
    ""AS12555"": 1,
    ""AS49434"": 4,
    ""AS213438"": 6,
    ""AS48721"": 2,
    ""AS14061"": 15,
    ""AS396982"": 12,
    ""AS401120"": 3,
    ""AS63949"": 2,
    ""AS47890"": 4,
    ""AS202425"": 1,
    ""AS135377"": 1,
    ""AS29465"": 1,
    ""AS213790"": 2,
    ""AS151185"": 2,
    ""AS201814"": 1
  },
  ""isp"": {
    ""Infomaniak Network SA"": 3310,
    ""Charter Communications Inc"": 4244,
    ""Data-center IMAQLIQ Ltd."": 1,
    ""Datacenter location PAR1 France"": 4,
    ""ColocaTel Inc."": 6,
    ""Flyservers S.A."": 2,
    ""DigitalOcean, LLC"": 15,
    ""Google LLC"": 12,
    ""cheapy.host LLC"": 3,
    ""Akamai Technologies, Inc."": 2,
    ""Unmanaged LTD"": 4,
    ""IP Volume inc"": 1,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 1,
    ""MTN NIGERIA Communication limited"": 1,
    ""Limited Network LTD"": 2,
    ""China Telecom"": 2,
    ""MEVSPACE sp. z o.o."": 1
  },
  ""org"": {
    ""Infomaniak Network SA"": 3310,
    ""Spectrum"": 4244,
    ""DC Imaqliq"": 1,
    ""ThinkTech Technology Industrial CO. Limited"": 4,
    ""ColocaTel Inc"": 6,
    ""Flyservers S.A"": 2,
    ""DigitalOcean, LLC"": 15,
    ""Palo Alto Networks, Inc"": 12,
    ""Internet Secuirty Cheapyhost"": 3,
    ""Linode"": 2,
    ""Unmanaged LTD"": 4,
    ""AI Spera"": 1,
    ""Ucloud Information Technology (hk) Limited"": 1,
    ""MTN Nigeria"": 1,
    ""Limited Network LTD"": 2,
    ""Chinanet HB"": 2,
    ""MEVSPACE sp. z o.o"": 1
  },
  ""regionName"": {
    ""Lucerne"": 3310,
    ""Texas"": 4245,
    ""Moscow"": 1,
    ""\u00cele-de-France"": 4,
    ""North Holland"": 7,
    ""Kaunas"": 2,
    ""England"": 5,
    ""California"": 21,
    ""La Rivi\u00e8re Anglaise"": 3,
    ""New Jersey"": 2,
    ""Hesse"": 3,
    ""South West"": 1,
    ""Metro Manila"": 1,
    ""Lagos"": 1,
    ""Federal District"": 2,
    ""Hubei"": 2,
    ""Mazovia"": 1
  },
  ""country"": {
    ""Switzerland"": 3310,
    ""United States"": 4268,
    ""Russia"": 1,
    ""France"": 4,
    ""The Netherlands"": 7,
    ""Lithuania"": 2,
    ""United Kingdom"": 5,
    ""Seychelles"": 3,
    ""Germany"": 3,
    ""Singapore"": 1,
    ""Philippines"": 1,
    ""Nigeria"": 1,
    ""Brazil"": 2,
    ""China"": 2,
    ""Poland"": 1
  },
  ""account"": {
    ""hello"": 7564,
    ""(empty)"": 1,
    ""Test"": 8,
    ""Domain"": 6,
    ""wlBGysfiq"": 1,
    ""NXXOQt"": 1,
    ""aDNgAW"": 1,
    ""Administr"": 8,
    ""uipchg00"": 4,
    ""beio"": 2,
    ""VIublcQVX"": 1,
    ""ulznaG"": 1,
    ""kJnKdc"": 1,
    ""uvu5r4g1"": 4,
    ""RvKdmjvBn"": 1,
    ""kUBzOR"": 1,
    ""necOGh"": 1,
    ""nmap"": 1,
    ""Administrator"": 1,
    ""EdfTamyRy"": 1,
    ""APHjtB"": 1,
    ""uPYKBW"": 1
  },
  ""keyboard"": {
    ""Unknown"": 7611
  },
  ""client_build"": {
    ""Unknown"": 7611
  },
  ""client_name"": {
    ""Unknown"": 7611
  },
  ""ip_type"": {
    ""mobile & hosting"": 3311,
    ""Unknown"": 4263,
    ""hosting"": 35,
    ""proxy"": 2
  }
}"
pXsqwMDK,Count the ways of friends pairing,Fastrail08,C++,Monday 30th of June 2025 06:25:44 PM CDT,"#include <bits/stdc++.h>
using namespace std;


int pairFriends(int level, int &n, vector<bool> &visited, unordered_map<string, int> &memo){
    
    if(level > n){
        return 1;
    }
    string friendsBlocked = """";
    for(int i = 1; i < visited.size(); i++){
        if(visited[i]){
            friendsBlocked += to_string(i);
        }
    }
    string memoKey = to_string(level) + ""|"" + friendsBlocked;
    
    if(memo.count(memoKey) > 0){
        return memo[memoKey];
    }
    
    int single = 0, paired = 0, occupied = 0;
    // YOU can only take decisions if you are not already paired by some other friend.
    // such as we processed 1 and 2 and at level of 3.... if we are on some path where {1, 3},{2} which means 1 at their own level decided to pair up with 3, which will block up 3 and in that path 3 will be marked visited before we even reach 3. So we just move to the next level.
    if(!visited[level]){
        //either go alone/don't pair
        visited[level] = true;
        single = pairFriends(level + 1, n, visited, memo);
        visited[level] = false;
        
        //form pairs with every friend that is AVAILABLE and not already paired up, and to make this decision too, you also need to be free,i.e. that you should NOT ALSO BELONG to some pair
    
        //start the loop from level + 1 and not 1 just to avoid permutation... {1, 2} making this pair at level 1, but making this pair {2, 1} at level 2.
        visited[level] = true;
        for(int i = level + 1; i <= n; i++){
            if(!visited[i]){
                visited[i] = true;
                paired += pairFriends(level + 1, n, visited, memo);
                visited[i] = false;
            }
        }
        visited[level] = false;
    }
    else{
        occupied = pairFriends(level + 1, n, visited, memo);
    }
    
    return memo[memoKey] = single + paired + occupied;
  // return memo[level][] = single + paired + occupied; 
}


int pairFriendsOptimised(int n, vector<int> &memo){
    if(n == -1){
        return 0;
    }
    if(n == 0){
        return 1;
    }
    
    //memo check
    if(memo[n] != -1){
        return memo[n];
    }
    
    int single = 0, paired = 0;
    //go single
    single = pairFriendsOptimised(n - 1, memo);
    
    //go pair
    // for(int i = 0; i < n - 1; i++){
    //     paired += pairFriendsOptimised(n - 2, memo);
    // }
    paired += pairFriendsOptimised(n - 2, memo);
    paired *= (n - 1);
    //IMPORTANT
    //It can be further replaced with simple multiplication though..
    //As the loop runs from (0 -> n - 2)...a total (n - 1) times, which immitates the pairing of for a single person,..if there are total n persons... 1 single person can form (n - 1)pairs
    
    //ALWAYS BE ON THE LOOKOUT FOR SUCH PATTERNS in counting questions, WHERE FOR LOOP IS JUST MAKING THE SAME CALLS FOR A SET NUMBER OF TIMES, as it is the same call without any change, it will always return a same value. Just call it once and multiply the number of times it was called.
    return memo[n] = single + paired;
}

int main() {
	// your code goes here
    int n;
    cin >> n;
    /*
    MEMO Call
    vector<bool> visited(n + 1, false);
    unordered_map<string, int> memo;
    cout << pairFriends(1, n, visited, memo) << '\n';
    */
    
    /*
    MEMO CALL (Self Thought) Could be optimised when solved the OG MEMO CODE.
    
    */
    vector<int> memo(n + 1, -1);
    cout << pairFriendsOptimised(n, memo) << '\n';
    
}
"
VjG5Zz7v,odoo erp,sergio_educacionit,HTML,Monday 30th of June 2025 06:11:31 PM CDT,"<!DOCTYPE html>
<html lang=""es"">
<head>
  <meta charset=""UTF-8"">
  <meta name=""viewport"" content=""width=device-width, initial-scale=1"">
  <title>Odoo y LAMP</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f7f7f7;
      margin: 0;
      padding: 0;
    }
    header {
      background-color: #714B67;
      color: #fff;
      padding: 20px;
      text-align: center;
    }
    main {
      max-width: 900px;
      margin: 40px auto;
      background-color: #fff;
      padding: 30px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      border-radius: 8px;
    }
    h1 {
      margin-top: 0;
    }
    section {
      margin-bottom: 20px;
    }
    footer {
      text-align: center;
      color: #999;
      padding: 10px;
      font-size: 0.9em;
    }
  </style>
</head>
<body>
  <header>
    <h1>¿Qué es un ERP y cómo funciona Odoo en LAMP?</h1>
  </header>
  <main>
    <section>
      <p>Un <strong>ERP</strong> (Enterprise Resource Planning) es un sistema de planificación de recursos empresariales que permite integrar y gestionar de manera centralizada distintas áreas de una empresa, como ventas, compras, inventario, contabilidad y recursos humanos. <strong>Odoo</strong> es un ERP de código abierto que ofrece un conjunto modular de aplicaciones para cubrir estas necesidades.</p>
    </section>
    <section>
      <p>Odoo puede ejecutarse en un entorno <strong>LAMP</strong>, una pila compuesta por:</p>
      <ul>
        <li><strong>Linux</strong>: El sistema operativo que proporciona estabilidad y seguridad.</li>
        <li><strong>Apache</strong>: El servidor web que entrega las páginas y aplicaciones a los usuarios.</li>
        <li><strong>MySQL</strong>: El sistema de bases de datos que almacena la información del ERP (en el caso de Odoo, normalmente se usa PostgreSQL, pero puede integrarse con MySQL en algunos casos).</li>
        <li><strong>PHP</strong>: Aunque Odoo está desarrollado en Python, el entorno LAMP puede complementar el despliegue de portales o integraciones adicionales en PHP.</li>
      </ul>
      <p>En conjunto, este entorno permite que Odoo funcione como una solución robusta y flexible, accesible desde navegadores web y capaz de gestionar procesos empresariales de forma eficiente.</p>
    </section>
  </main>
  <footer>
    <p>Ejemplo didáctico - Odoo y LAMP</p>
  </footer>
</body>
</html>
"
7P1KqYpC,Untitled,Locative,SQL,Monday 30th of June 2025 03:09:24 PM CDT,"-- [ Оплата за: июнь]
 
--------- [ Отработанное время: ]
 
Locative: 14 (FUN) 90 (x100) -- 104
Зилиус:  0 (x100) -- 0
Khyntia: 8 (FUN), 0 (x100) -- 8
jegerm  - EN GM: 119 (FUN), 2 (x100) -- 121
Mairena: 0 (FUN) 102 (x100) -- 102
Lorad: 0 (x100) -- 0
Adegbuyi 8 (FUN) -- 4


--------- [ Бонусы: ]

UPDATE `bonus` SET `gold`=gold+4000 WHERE `id`='1331733'; -- Locative(3000ГМ + 1000РГМ)
INSERT INTO `bonus_log`(`user_id`, `created`, `bonus`, `msg`) VALUES (1331733, NOW(), 4000, '+4000 золотых бонусов - з/п Ргм Locative за июнь');

UPDATE `bonus` SET `gold`=gold+0 WHERE `id`='229884'; -- Зилиус (ГМ)
INSERT INTO `bonus_log`(`user_id`, `created`, `bonus`, `msg`) VALUES (229884, NOW(), 0, '+0 золотых бонусов - з/п ГМ Зилиус за июнь');

UPDATE `bonus` SET `gold`=gold+0 WHERE `id`='949105'; -- Khyntia (ГМ).
INSERT INTO `bonus_log`(`user_id`, `created`, `bonus`, `msg`) VALUES (949105, NOW(), 0, '+0 золотых бонусов - з/п ГМ Khyntia за июнь'); 

UPDATE `bonus` SET `gold`=gold+3500 WHERE `id`='455260'; -- Jegerm (EN GM) + md FB.
INSERT INTO `bonus_log`(`user_id`, `created`, `bonus`, `msg`) VALUES (455260, NOW(), 3500, '+3500 золотых бонусов - з/п ГМ Jegerm за июнь'); 

UPDATE `bonus` SET `gold`=gold+3000 WHERE `id`='1407530'; -- Mairena
INSERT INTO `bonus_log`(`user_id`, `created`, `bonus`, `msg`) VALUES (1407530, NOW(), 3000, '+3000 золотых бонусов - з/п ГМ Mairena за июнь'); 


-- Модератор чата

UPDATE `bonus` SET `gold`=gold+0 WHERE `id`='1795307'; -- Adegbuyi
INSERT INTO `bonus_log`(`user_id`, `created`, `bonus`, `msg`) VALUES (1795307, NOW(), 0, '+0 золотых бонусов - з/п МД Adegbuyi за июнь'); 


-- Техническая поддержка

UPDATE `bonus` SET `gold`=gold+1000 WHERE `id`='456853'; -- Seanone
INSERT INTO `bonus_log`(`user_id`, `created`, `bonus`, `msg`) VALUES (456853, NOW(), 1000, '+1000 золотых бонусов - з/п тех.поддержки Seanone за июнь'); 


-- QA Team

UPDATE `bonus` SET `gold`=gold+1000 WHERE `id`='211220'; -- nastyasia
INSERT INTO `bonus_log`(`user_id`, `created`, `bonus`, `msg`) VALUES (211220, NOW(), 1000, '+1000 золотых бонусов - з/п QA-тестер nastyasia за июнь'); 

UPDATE `bonus` SET `gold`=gold+0 WHERE `id`='1609205'; -- love_love
INSERT INTO `bonus_log`(`user_id`, `created`, `bonus`, `msg`) VALUES (1609205, NOW(), 0, '+0 золотых бонусов - з/п QA-тестер Love_love за июнь'); 
"
0wDwdaDF,2025-06-30T21:02:31.901306,powerampache,PHP,Monday 30th of June 2025 02:02:32 PM CDT,"1.00-70 (70) - DB: 83
java.lang.NullPointerException: Parameter specified as non-null is null: method luci.sixsixsix.powerampache2.domain.models.User.<init>, parameter id
	at luci.sixsixsix.powerampache2.domain.models.User.<init>(Unknown Source:20)
	at luci.sixsixsix.powerampache2.data.remote.dto.UserDtoKt.toUser(UserDto.kt:94)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository.getUserNetwork(BaseAmpacheRepository.kt:128)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository$getUserNetwork$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:811)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:715)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:702)

"
pdbnazff,pride-flag,DeaD_EyE,Python,Monday 30th of June 2025 01:29:40 PM CDT,"from pathlib import Path
import requests
from urllib.request import urlretrieve
from PIL import Image

""""""
The flag does not have to be designed that way intentionally. You can do that with anything if there is a right-angled triangle on one side and the side below the right angle is not visible.
""""""

def download_pride_flag(file: Path):    
    url = ""https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTxYy7T7Sbzgc3vA2PRtmiwU69CLRl88JIpWQ&s""
    urlretrieve(url, file)


def process_image(image_path: Path, output_path: Path) -> None:
    with Image.open(image_path) as img:
        _, height = img.size
        img = img.crop((0, 0, height, height))    
        new_img = Image.new(""RGB"", (height * 2, height * 2), (0, 0, 0))
        
        for x, y in [(1, 0), (1, 1), (0, 1), (0, 0)]:
            new_img.paste(img, (x * height, y * height))
            img = img.rotate(-90)
        
        new_img.save(output_path)


if __name__ == ""__main__"":
    input_image = Path(""flag.png"")
    output_image = Path(""output.png"")
    
    if not input_image.exists():
        download_pride_flag(input_image)
    
    process_image(input_image, output_image)
    print(f""Processed image saved as {output_image}"")
"
8YVcdEbS,Untitled,Scripting_King,Lua,Monday 30th of June 2025 01:13:46 PM CDT,"--[[ 
Squid Game User Interface Controller
Handles shop UI, reward UI, tool activation, gamepasses, animations, and GUI interaction logic using Knit framework.
]]
--by the_king_here
--//SERVICES
local ReplicatedStorage = game:GetService(""ReplicatedStorage"")
local Knit = require(ReplicatedStorage.Packages.Knit)
local TweenService = game:GetService(""TweenService"")
local runService = game:GetService(""RunService"")
local MPS = game:GetService(""MarketplaceService"")
local LightningService = game:GetService(""Lighting"")
local SoundService = game:GetService(""SoundService"")


--TweenInfo config for UI transitions (0.3s, Back Out easing)
local tweenInfoUI = TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0)

-- Creating a Knit Controller
local UserInterfaceController = Knit.CreateController{
	Name = ""UserInterface"",
}

-- Will store reference to the server side service later
local MapHandlerService

-- Reference to the local player
local player = game.Players.LocalPlayer

-- Control module to disable movement during certain actions
local Controls = require(player.PlayerScripts.PlayerModule):GetControls()

-- UI References in PlayerGui
local TrollUI = player.PlayerGui:WaitForChild(""Troll"")
local PushUI = player.PlayerGui:WaitForChild(""PushUI"")
local SettingsUI = player.PlayerGui:WaitForChild(""Settings"")
local ShopUI = player.PlayerGui:WaitForChild(""Shop"")
local InventoryUI = player.PlayerGui:WaitForChild(""Inventory"")
local RewardUI = player.PlayerGui:WaitForChild(""Reward"")

-- Music References
local BackgroundMusic = SoundService:WaitForChild(""LobbyMusic"")
local SquidMusic = SoundService:WaitForChild(""Music"")

-- Developer product IDs
local Products = {
	EliminatePlayers = 3312415657, 
	SpeedTroll = 3312416017,
	KillRandomPersonTroll = 3312444642,
	TakeCoinsTroll = 3312417586,
}

-- Push upgrades (more force or quantity)
local PushProducts = {
	Push1 = 3313283431, 
	Push2 = 3313283430,
	Push5 = 3313283433,
	Push7 = 3313283424,
	Push10 = 3313286623,
}

-- Tweening for background music transitions
local tweenInfoForMusic = TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0)

-- Reference to the camera for FOV changes
local camera = workspace.CurrentCamera

-- Blur effect (GUI background blur)
local Blur = LightningService:FindFirstChild(""BlurForGui"")

-- For rope animation disconnecting later
local RopeAnimationConnection

-- Countdown before round starts (e.g., ""3, 2, 1... Run!"")
function UserInterfaceController:BackTimer(StartTime, EndTime, UIToShowTime)
	for i = StartTime, EndTime, -1 do
		wait(1)
		player.PlayerGui:WaitForChild(""Timer"").TextLabel.Visible = true
		player.PlayerGui.Timer.TextLabel.Text = i --Displays time on textlabel
		player.PlayerGui.Timer.TextLabel.TimerSound:Play() --plays timer sound every second
		if i == 0 then
			wait(1)
			player.PlayerGui.Timer.TextLabel.Text = ""Run!"" -- Final message
			task.delay(1.5, function()
				player.PlayerGui.Timer.TextLabel.Visible = false
			end)
		end
	end
end

-- Displays a short message on screen (centered label) for 3 seconds
function UserInterfaceController:ShowMessage(Message)
	player.PlayerGui:WaitForChild(""Timer"").TextLabel.Visible = true
	player.PlayerGui.Timer.TextLabel.Text = Message
	task.delay(3, function()
		player.PlayerGui.Timer.TextLabel.Visible = false
	end)
end

local Rope -- rope part reference (used in Easy or Hard maps)

local maxSpeed -- max angular speed in radians/sec
local accelTime = 3 -- how long to accelerate (ease in) in seconds
local animationStarted = false -- variable to check if animation has started
local animationStartTime = nil  -- server-synced time when animation begins

local initialCFrame -- store original rope CFrame

-- Begins rope rotation animation based on server time
function UserInterfaceController:startAnimationWhenReady(serverStartTime, Mode)
	-- Decide map + speed based on mode
	if Mode == ""Easy"" then
		maxSpeed = math.rad(210) -- degrees to radians
		Rope = workspace.Maps.EasyRopemap:WaitForChild(""rope"")
	else
		maxSpeed = math.rad(250)
		Rope = workspace.Maps.HadRopeMap:WaitForChild(""rope"")
	end
	local primary = Rope.PrimaryPart --Stores refrence to rope primaryPart
	initialCFrame = primary.CFrame -- store starting position
	animationStartTime = serverStartTime
	animationStarted = false
	Controls:Disable() -- Disable player movement during pre rope animation
	
	-- If player has LessGravity effect, set gravity to 70
	local LessGravity = player:FindFirstChild(""LessGravity"")
	if LessGravity.Value > 0 then
		MapHandlerService:LessGravity(""DecreaseGravityValue"")
		workspace.Gravity = 70
	end


	local IsEnabledControls = false --keep track whether controls of player has been restored or not
	-- Connect to RenderStepped to animate rope every frame
	RopeAnimationConnection = runService.RenderStepped:Connect(function()
		local now = workspace:GetServerTimeNow() --get current time
		-- Wait until server-synced animation time
		if not animationStarted and now >= animationStartTime then
			animationStarted = true
		end
		if not animationStarted then return end
		
		-- Enable player controls 1 second after rope starts
		if not IsEnabledControls then
			IsEnabledControls = true
			task.delay(1, function()
				Controls:Enable()
			end)
		end

		local elapsed = now - animationStartTime -- how long since animation began
		local rotation --Stores rotation value
		
		-- Accelerate with cubic easing for first 3 seconds
		if elapsed < accelTime then
			local progress = elapsed / accelTime
			rotation = 0.33 * maxSpeed * (progress ^ 3) * accelTime
		else
			-- Maintain constant speed after acceleration phase
			local constantTime = elapsed - accelTime
			rotation = 0.33 * maxSpeed * accelTime + maxSpeed * constantTime
		end
		
		-- Rotate rope by X-axis only
		local newCFrame = initialCFrame * CFrame.Angles(rotation, 0, 0)
		Rope:PivotTo(newCFrame)
	end)
end

--returns name after removing text ""button"" from name if name contains text ""Button""
function UserInterfaceController:getNameAfterRemovingButton(name)
	local suffix = ""Button""
	if name:sub(-#suffix) == suffix then
		return name:sub(1, -#suffix - 1)
	else
		return name
	end
end

local originalRotation = 0 --Stoers default rotation, which is usually 0

-- function to scale UDim2 (used to make buttons shrink or grow)
function UserInterfaceController:scaleSize(size: UDim2, scale: number): UDim2
	return UDim2.new(
		size.X.Scale * scale, size.X.Offset * scale,
		size.Y.Scale * scale, size.Y.Offset * scale
	)
end

-- When mouse enters button (hover), enlarge slightly + rotate
function UserInterfaceController:onHover(button, originalSize)
	local hoverTween = TweenService:Create(button, TweenInfo.new(0.1), {
		Size = self:scaleSize(originalSize, 1.1),
		Rotation = 5,
	})
	hoverTween:Play()
end

-- When mouse leaves button, restore size and rotation
function UserInterfaceController:onUnhover(button, originalSize)
	local unhoverTween = TweenService:Create(button, TweenInfo.new(0.1), {
		Size = originalSize,
		Rotation = originalRotation,
	})
	unhoverTween:Play()
end

-- When button is clicked, shrink quickly then bounce back
function UserInterfaceController:onClick(button, originalSize)
	local shrinkTween = TweenService:Create(button, TweenInfo.new(0.05), {
		Size = self:scaleSize(originalSize, 0.8),
	})
	local restoreTween = TweenService:Create(button, TweenInfo.new(0.1), {
		Size = originalSize,
	})

	shrinkTween:Play()
	shrinkTween.Completed:Connect(function()
		restoreTween:Play()
	end)
end
local OpenedUI -- tracks which UI is currently open

-- Applies hover/click logic and manages showing/hiding UIs like Shop, Inventory, etc.
function UserInterfaceController:AnimateUIs()
	local UIButtons = player.PlayerGui.Buttons


	local Debounce = false -- prevents spam clicking

	for i, button in pairs(UIButtons:GetChildren()) do
		if button:IsA(""Frame"") then
			local Button = button:FindFirstChildOfClass(""TextButton"") -- Find the clickable button
			if Button then
				local originalSize = button.Size
				local FrameName = self:getNameAfterRemovingButton(button.Name) -- Remove ""Button"" suffix
				local Frame = player.PlayerGui:FindFirstChild(FrameName) --get the frame with the given value after removing ""Button"" suffix
				if Frame.Name ~= ""Modes"" then
					-- if Normal UIs not Modes then use Frame.Canvas
					local CloseButton:ImageButton = Frame.Canvas.Container.Main.Close
					local Canavs = Frame:FindFirstChild(""Canvas"")
					
					-- Hover event
					button.MouseEnter:Connect(function()
						self:onHover(button, originalSize)
					end)
					-- Unhover event
					button.MouseLeave:Connect(function()
						self:onUnhover(button, originalSize)
					end)
					
					-- Button click (open/close logic)
					Button.MouseButton1Click:Connect(function()
						if Debounce then return end
						self:onClick(button, originalSize)
						Debounce = true
						if Frame then
							
							if not OpenedUI then -- No UI open yet
								OpenedUI = Canavs --Defines the current open UI
								Canavs.Visible = true
								--Tweens the position of the UI
								Canavs.Position = UDim2.new(0.5, 0, 1.5, 0)
								Canavs:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.3)
								
								-- Zoom FOV and apply blur
								TweenService:Create(camera, tweenInfoUI, {FieldOfView = 100}):Play()
								TweenService:Create(Blur, tweenInfoUI, {Size = 20}):Play()
								task.delay(0.3, function()
									Debounce = false
								end)
								
							elseif OpenedUI and OpenedUI ~= Canavs then-- Switching from one UI to another
								Canavs.Visible = true
								OpenedUI:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.3)
								OpenedUI = Canavs
								Canavs.Position = UDim2.new(0.5, 0, 1.5, 0)
								Canavs:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.3)
								TweenService:Create(camera, tweenInfoUI, {FieldOfView = 100}):Play()
								TweenService:Create(Blur, tweenInfoUI, {Size = 20}):Play()
								task.delay(0.3, function()
									Debounce = false
								end)
							elseif OpenedUI and OpenedUI == Canavs then -- UI is already open, so close it
								OpenedUI = nil --closed opened UI so now no UI opened so make OpenedUI variable nil
								Canavs:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.3)
								TweenService:Create(camera, tweenInfoUI, {FieldOfView = 70}):Play()
								TweenService:Create(Blur, tweenInfoUI, {Size = 0}):Play()
								task.delay(0.3, function()
									Debounce = false
								end)
							end
						end
					end)
					
					-- Close button logic/closes the opened UI
					CloseButton.MouseButton1Click:Connect(function()
						if Debounce then return end
						Debounce = true
						OpenedUI = nil
						--Closes UI with tween
						Canavs:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.3)
						-- Reset camera FOV and continblur
						TweenService:Create(camera, tweenInfoUI, {FieldOfView = 70}):Play()
						TweenService:Create(Blur, tweenInfoUI, {Size = 0}):Play()
						task.delay(0.3, function()
							Debounce = false
						end)
					end)
				else -- This handles the ""Modes"" frame specifically

					local CloseButton:ImageButton = Frame.Frame.Close -- Close button in a different hierarchy
					local Canavs = Frame:FindFirstChild(""Frame"") -- Canvas is named ""Frame"" here
					
					-- Hover events
					button.MouseEnter:Connect(function()
						self:onHover(button, originalSize)
					end)

					button.MouseLeave:Connect(function()
						self:onUnhover(button, originalSize)
					end)
					
					-- Button clicked (toggle Modes UI)
					Button.MouseButton1Click:Connect(function()
						if Debounce then return end
						self:onClick(button, originalSize)
						Debounce = true
						if Frame then
							if not OpenedUI then -- First time opening
								OpenedUI = Canavs
								Canavs.Visible = true
								Canavs.Position = UDim2.new(0.5, 0, 1.5, 0)
								Canavs:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.3)
								TweenService:Create(camera, tweenInfoUI, {FieldOfView = 100}):Play()
								TweenService:Create(Blur, tweenInfoUI, {Size = 20}):Play()
								task.delay(0.3, function()
									Debounce = false
								end)
							elseif OpenedUI and OpenedUI ~= Canavs then -- Switching from another UI to this one
								Canavs.Visible = true
								OpenedUI:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.3)
								OpenedUI = Canavs
								Canavs.Position = UDim2.new(0.5, 0, 1.5, 0)
								Canavs:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.3)
								TweenService:Create(camera, tweenInfoUI, {FieldOfView = 100}):Play()
								TweenService:Create(Blur, tweenInfoUI, {Size = 20}):Play()
								task.delay(0.3, function()
									Debounce = false
								end)
							elseif OpenedUI and OpenedUI == Canavs then -- Close Modes UI
								Debounce = true
								OpenedUI = nil
								Canavs:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.3)
								TweenService:Create(camera, tweenInfoUI, {FieldOfView = 70}):Play()
								TweenService:Create(Blur, tweenInfoUI, {Size = 0}):Play()
								task.delay(0.3, function()
									Debounce = false
								end)
							end
						end
					end)
					
					--Handles closeButton functionality
					CloseButton.MouseButton1Click:Connect(function()
						if Debounce then return end
						Debounce = true
						OpenedUI = nil
						Canavs:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.3)
						TweenService:Create(camera, tweenInfoUI, {FieldOfView = 70}):Play()
						TweenService:Create(Blur, tweenInfoUI, {Size = 0}):Play()
						task.delay(0.3, function()
							Debounce = false
						end)
					end)
				end

			end
		end
	end
end


--Handles working of troll UI
function UserInterfaceController:TrollUI()
	local UIStroke
	-- Loop through each troll button (ImageButton inside Main Container)
	for i, trolls in pairs(TrollUI.Canvas.Container.Main.Container:GetChildren()) do
		if trolls:IsA(""ImageButton"") then
			trolls.MouseEnter:Connect(function() -- When hovered, add purple UIStroke around ""Default"" image
				print(""Entered"")
				if not UIStroke then
					UIStroke = Instance.new(""UIStroke"")
					UIStroke.Parent = trolls:FindFirstChild(""Default"")
					UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual
					UIStroke.Color = Color3.fromRGB(126, 36, 233)
					UIStroke.Thickness = 2
				else
					UIStroke.Parent = trolls:FindFirstChild(""Default"")
				end
			end)
			
			-- Remove stroke on mouse leave
			trolls.MouseLeave:Connect(function()
				UIStroke.Parent = nil
			end)
			
			-- Refrence to the buy button inside Equipped or Default
			local BuyButton:ImageButton = trolls.Equipped:FindFirstChild(""Buy"") or trolls.Default:FindFirstChild(""Buy"")
			
			-- When clicked, trigger Marketplace purchase for selected troll type
			BuyButton.MouseButton1Click:Connect(function()
				local ClickedTrollName = BuyButton.Parent.Parent.Name
				if ClickedTrollName == ""EliminatePlayers"" then
					MPS:PromptProductPurchase(player, Products.EliminatePlayers)
				elseif ClickedTrollName == ""SpeedTroll"" then
					MPS:PromptProductPurchase(player, Products.SpeedTroll)
				elseif ClickedTrollName == ""KillRandomPersonTroll"" then
					MPS:PromptProductPurchase(player, Products.KillRandomPersonTroll)
				elseif ClickedTrollName == ""TakeCoinsTroll"" then
					MPS:PromptProductPurchase(player, Products.TakeCoinsTroll)
				end
			end)
		end
	end
end



function UserInterfaceController:PushIUI()
	local UIStroke
	
	-- Loop through each push product (Push1, Push2, etc.)
	for i, trolls in pairs(PushUI.Canvas.Container.Main.Container:GetChildren()) do
		if trolls:IsA(""ImageButton"") then
			trolls.MouseEnter:Connect(function()-- Same hover stroke logic as TrollUI
				print(""Entered"")
				if not UIStroke then
					UIStroke = Instance.new(""UIStroke"")
					UIStroke.Parent = trolls:FindFirstChild(""Default"")
					UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual
					UIStroke.Color = Color3.fromRGB(126, 36, 233)
					UIStroke.Thickness = 2
				else
					UIStroke.Parent = trolls:FindFirstChild(""Default"")
				end
			end)

			trolls.MouseLeave:Connect(function()
				UIStroke.Parent = nil
			end)
			
			-- Find Buy button
			local BuyButton:ImageButton = trolls.Equipped:FindFirstChild(""Buy"") or trolls.Default:FindFirstChild(""Buy"")
			
			-- Trigger MarketplaceService purchase when clickedcont
			BuyButton.MouseButton1Click:Connect(function()
				local ClickedButtonName = BuyButton.Parent.Parent.Name
				if ClickedButtonName == ""Push1"" then
					MPS:PromptProductPurchase(player, PushProducts.Push1)
				elseif ClickedButtonName == ""Push2"" then
					MPS:PromptProductPurchase(player, PushProducts.Push2)
				elseif ClickedButtonName == ""Push5"" then
					MPS:PromptProductPurchase(player, PushProducts.Push5)
				elseif ClickedButtonName == ""Push7"" then
					MPS:PromptProductPurchase(player, PushProducts.Push7)
				elseif ClickedButtonName == ""Push10"" then
					MPS:PromptProductPurchase(player, PushProducts.Push10)
				end
			end)
		end
	end
end

local ClonedPopupUI

function UserInterfaceController:ShopeUI()
	local UIStroke

	local NavigationList = ShopUI.Canvas.Container.Navigation.List

	local PopupUI = player.PlayerGui.Popup -- Refrence to popup UI

	local GamepassButton = NavigationList.Gamepass
	local DeveloperProductsButton = NavigationList.DeveloperProducts
	local StoreButton = NavigationList.Store

	local Container1 = ShopUI.Canvas.Container.Main.Container1 -- Gamepasses Tab
	local Container2 = ShopUI.Canvas.Container.Main.Container2 -- Dev Products Tab
	local Container3 = ShopUI.Canvas.Container.Main.Container3 -- Store Items Tab
	
	-- Gamepass tab button logic
	NavigationList.Gamepass.MouseButton1Click:Connect(function()
		if Container2.Visible == true or Container3.Visible == true then
			Container2.Visible = false -- Hide other tabs
			Container3.Visible = false
			Container1.Visible = true  -- Show gamepasses Tab
			
			-- Change looking style of tab buttons
			GamepassButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255) --Change background color to white so UI gradient get clearly visible
			GamepassButton:FindFirstChild(""UIGradient"").Enabled = true --Enable UI gradient
			GamepassButton.Text.TextColor3 = Color3.new(255, 255, 255) --Change text color to white too

			DeveloperProductsButton.BackgroundColor3 = Color3.fromRGB(31, 31, 31)--Change background color to black
			DeveloperProductsButton:FindFirstChild(""UIGradient"").Enabled = false--Disble UI gradient
			DeveloperProductsButton.Text.TextColor3 = Color3.new(113, 113, 113)--Change text color to white

			StoreButton.BackgroundColor3 = Color3.fromRGB(31, 31, 31) --Change background color to black
			StoreButton:FindFirstChild(""UIGradient"").Enabled = false --Disble UI gradient
			StoreButton.Text.TextColor3 = Color3.new(113, 113, 113) --Change text color to white
		end
	end)
	
	--Developer Products tab Button logic
	NavigationList.DeveloperProducts.MouseButton1Click:Connect(function()
		if Container1.Visible == true or Container3.Visible == true then
			Container2.Visible = true
			Container3.Visible = false
			Container1.Visible = false
			DeveloperProductsButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)--Change background color to white so UI gradient get clearly visible
			DeveloperProductsButton:FindFirstChild(""UIGradient"").Enabled = true--Enable UI gradient
			DeveloperProductsButton.Text.TextColor3 = Color3.new(255, 255, 255) --Change text color to white too

			GamepassButton.BackgroundColor3 = Color3.fromRGB(31, 31, 31) --Change background color to black
			GamepassButton:FindFirstChild(""UIGradient"").Enabled = false --Disble UI gradient
			GamepassButton.Text.TextColor3 = Color3.new(113, 113, 113) --Change text color to white

			StoreButton.BackgroundColor3 = Color3.fromRGB(31, 31, 31)--Change background color to black
			StoreButton:FindFirstChild(""UIGradient"").Enabled = false --Disble UI gradient
			StoreButton.Text.TextColor3 = Color3.new(113, 113, 113) --Change text color to white
		end
	end)
	
	-- Store tab button logic
	NavigationList.Store.MouseButton1Click:Connect(function()
		if Container1.Visible == true or Container2.Visible == true then
			Container3.Visible = true
			Container1.Visible = false
			Container2.Visible = false
			StoreButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)--Change background color to white so UI gradient get clearly visible
			StoreButton:FindFirstChild(""UIGradient"").Enabled = true --Enable UI gradient
			StoreButton.Text.TextColor3 = Color3.new(255, 255, 255) --Change text color to white too

			GamepassButton.BackgroundColor3 = Color3.fromRGB(31, 31, 31) --Change background color to black
			GamepassButton:FindFirstChild(""UIGradient"").Enabled = false--Disble UI gradient
			GamepassButton.Text.TextColor3 = Color3.new(113, 113, 113)--Change text color to white

			DeveloperProductsButton.BackgroundColor3 = Color3.fromRGB(31, 31, 31)--Change background color to black
			DeveloperProductsButton:FindFirstChild(""UIGradient"").Enabled = false--Disble UI gradient
			DeveloperProductsButton.Text.TextColor3 = Color3.new(113, 113, 113)--Change text color to white
		end
	end)
	
	-- Loop through items in Container1 (Gamepasses)
	for i, Gamepass in pairs(Container1:GetChildren()) do
		if Gamepass:IsA(""ImageButton"") then
			-- Hover effect
			Gamepass.MouseEnter:Connect(function()
				if not UIStroke then
					UIStroke = Instance.new(""UIStroke"")
					UIStroke.Parent = Gamepass:FindFirstChild(""Default"")
					UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual
					UIStroke.Color = Color3.fromRGB(126, 36, 233)
					UIStroke.Thickness = 2
				else
					UIStroke.Parent = Gamepass:FindFirstChild(""Default"")
				end
			end)

			Gamepass.MouseLeave:Connect(function()
				UIStroke.Parent = nil
			end)
			
			-- Giving refrence to buy button
			local BuyButton:ImageButton = Gamepass.Equipped:FindFirstChild(""Buy"") or Gamepass.Default:FindFirstChild(""Buy"")
			
			-- Handle Gamepass purchase via MarketplaceService after clicking buy button
			BuyButton.MouseButton1Click:Connect(function()
				local ClickedButtonName = BuyButton.Parent.Parent.Name
				if ClickedButtonName == ""Coins2x"" then
					MPS:PromptGamePassPurchase(player, 1272744022)
				elseif ClickedButtonName == ""Sprint"" then
					MPS:PromptGamePassPurchase(player, 1273130340)
				elseif ClickedButtonName == ""RainbowNameTag"" then
					MPS:PromptGamePassPurchase(player, 1274510513)
				end
			end)
		end
	end

	for i, Gamepass in pairs(Container2:GetChildren()) do
		if Gamepass:IsA(""ImageButton"") then
			Gamepass.MouseEnter:Connect(function()
				-- Same UIStroke hover logic
				if not UIStroke then
					UIStroke = Instance.new(""UIStroke"")
					UIStroke.Parent = Gamepass:FindFirstChild(""Default"")
					UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual
					UIStroke.Color = Color3.fromRGB(126, 36, 233)
					UIStroke.Thickness = 2
				else
					UIStroke.Parent = Gamepass:FindFirstChild(""Default"")
				end
			end)

			Gamepass.MouseLeave:Connect(function()
				UIStroke.Parent = nil
			end)

			local BuyButton:ImageButton = Gamepass.Equipped:FindFirstChild(""Buy"") or Gamepass.Default:FindFirstChild(""Buy"")
			-- Trigger product purchases
			BuyButton.MouseButton1Click:Connect(function()
				local ClickedButtonName = BuyButton.Parent.Parent.Name
				if ClickedButtonName == ""Coins50"" then
					MPS:PromptProductPurchase(player, 3314212399)
				elseif ClickedButtonName == ""Coins100"" then
					MPS:PromptProductPurchase(player, 3314212620)
				elseif ClickedButtonName == ""Coins300"" then
					MPS:PromptProductPurchase(player, 3314213085)
				elseif ClickedButtonName == ""Coins500"" then
					MPS:PromptProductPurchase(player, 3314213295)
				elseif ClickedButtonName == ""Coins1000"" then
					MPS:PromptProductPurchase(player, 3314214142)
				end
			end)
		end
	end

	for i, Gamepass in pairs(Container3:GetChildren()) do
		if Gamepass:IsA(""ImageButton"") then
			Gamepass.MouseEnter:Connect(function()
				-- Hover stroke (same as above)
				if not UIStroke then
					UIStroke = Instance.new(""UIStroke"")
					UIStroke.Parent = Gamepass:FindFirstChild(""Default"")
					UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual
					UIStroke.Color = Color3.fromRGB(126, 36, 233)
					UIStroke.Thickness = 2
				else
					UIStroke.Parent = Gamepass:FindFirstChild(""Default"")
				end
			end)

			Gamepass.MouseLeave:Connect(function()
				UIStroke.Parent = nil
			end)
			
			-- Button purchase logic
			local BuyButton:ImageButton = Gamepass.Equipped:FindFirstChild(""Buy"") or Gamepass.Default:FindFirstChild(""Buy"")

			BuyButton.MouseButton1Click:Connect(function()
				-- Clone and display popup
				ClonedPopupUI = PopupUI:Clone()
				ClonedPopupUI.Parent = player.PlayerGui

				ClonedPopupUI.Canvas.Visible = true
				
				-- open ColourWheel if buy button is of NameTags template
				if BuyButton.Parent.Parent.Name == ""NameTags"" then
					player.PlayerGui.ColourWheelGui.Enabled = true
				end

				-- Handle purchase proccess if player has enough coins
				ClonedPopupUI.Canvas.Main.YesButton.MouseButton1Click:Connect(function()
					local PlayerCoins = player:FindFirstChild(""leaderstats""):WaitForChild(""Coins"")
					if PlayerCoins and PlayerCoins.Value >= BuyButton.Cost.Value then
						PlayerCoins.Value -= BuyButton.Cost.Value

						-- Handle NameTags (with color)
						if BuyButton.Parent.Parent.Name == ""NameTags"" then
							local NameTag = ReplicatedStorage.Assets:FindFirstChild(""nametagui""):Clone()
							MapHandlerService:GiveNameTags(player.PlayerGui.ColourWheelGui.ColourDisplay.BackgroundColor3)
							player.PlayerGui.ColourWheelGui.Enabled = false
							ClonedPopupUI:Destroy()
						else
							-- Add cloned template to Inventory
							local CloneTemplate = BuyButton.Parent.Parent:Clone()
							CloneTemplate.Parent = InventoryUI.Canvas.Container.Main.Container
							CloneTemplate.Default.Buy:Destroy()
							ClonedPopupUI:Destroy()
						end
					else
						-- Not enough coins message
						ClonedPopupUI.Canvas.Main.YesButton.Main.TextLabel.Text = ""Not Enough Coins!""
						task.delay(2, function()
							ClonedPopupUI.Canvas.Main.YesButton.Main.TextLabel.Text = ""Buy""
						end)
					end
				end)
				
				-- Popup close logic (X button or ""Close"")
				ClonedPopupUI.Canvas.Main.Closebutton.MouseButton1Click:Connect(function()
					ClonedPopupUI:Destroy()
				end)

				ClonedPopupUI.Canvas.Main.Close.MouseButton1Click:Connect(function()
					ClonedPopupUI:Destroy()
				end)
				
				-- gives player option to buy with robux if player don't have enough coins
				ClonedPopupUI.Canvas.Main.BuyWithRobux.MouseButton1Click:Connect(function()
					local itemName = BuyButton.Parent.Parent.Name
					if itemName == ""ExtraLifes"" then
						MPS:PromptProductPurchase(player, 3314996213)
					elseif itemName == ""LessGravity"" then
						MPS:PromptProductPurchase(player, 3314996574)
					elseif itemName == ""NameTags"" then
						MPS:PromptProductPurchase(player, 3314996930)
					end
				end)
			end)
		end
	end
end

function UserInterfaceController:InventoryHandler()
	local Container = InventoryUI.Canvas.Container.Main.Container -- refrence to hte frame that holds item buttons
	local SidePanel = InventoryUI.Canvas.Container.Main.SidePanel -- refrence to the frame that shows selected item details

	local SelectedChild -- Currently selected item
	
	-- Setup UIStroke for selection outline
	local UIStroke = Instance.new(""UIStroke"")
	UIStroke.Parent = nil
	UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual
	UIStroke.Color = Color3.fromRGB(126, 36, 233)
	UIStroke.Thickness = 2
	
	-- Use button logic
	SidePanel.Use.MouseButton1Click:Connect(function()
		if SidePanel.ItemName.Text == ""ExtraLifes"" then
			MapHandlerService:ExtraLifes() --Calls ""ExtraLifes"" function
			SelectedChild:Destroy() -- Consume/Remove item
			SidePanel.ImageLabel.Image = """"
			SidePanel.ItemName.Text = ""ItemName""
			SidePanel.ItemDescription.Text = ""ItemDescription""
		elseif SidePanel.ItemName.Text == ""LessGravity"" then
			MapHandlerService:LessGravity(""IncreaseGravityValue"") --Calls ""LessGravity"" function
		end
	end)
	
	-- When new item added to inventory
	Container.ChildAdded:Connect(function(child:ImageButton)
		child.MouseButton1Click:Connect(function()
			if not SelectedChild or SelectedChild ~= child then
				SelectedChild = child
				UIStroke.Parent = child:FindFirstChild(""Default"")
				-- Update side panel
				SidePanel.ItemName.Text = child.Name
				SidePanel.ImageLabel.Image = child.Default.ImageLabel.Image
				SidePanel.ItemDescription.Text = child.Default.TextLabel.Text
			end
		end)
	end)
end

-- Format seconds into MM:SS format
function UserInterfaceController:FormatTime(seconds)
	seconds = math.max(0, math.floor(seconds))

	local minutes = math.floor(seconds / 60)
	local secs = seconds % 60

	return string.format(""%02d:%02d"", minutes, secs)
end

-- Unlock times for rewards (in seconds)
local TimeToUnlock = {
	Reward1 = 5 * 60,
	Reward2 = 10 * 60,
	Reward3 = 15 * 60,
	Reward4 = 20 * 60,
	Reward5 = 25 * 60,
	Reward6 = 30 * 60,
	Reward7 = 35 * 60,
}

function UserInterfaceController:RewardUI()
	local UIStroke

	local StartTime = tick() --returns the number of seconds since January 1st, 1970 UTC, useful for time elapsed calculations
	
	-- Update timer every second
	spawn(function()
		while wait(1) do
			for i, rewards in pairs(RewardUI.Canvas.Container.Main.Container:GetChildren()) do
				if rewards:IsA(""ImageButton"") then
					if rewards.Equipped.TextLabel.Text == ""Unlock in: 00:00"" then continue end
					rewards.Equipped.TextLabel.Text = ""Unlock in: "".. self:FormatTime(TimeToUnlock[rewards.Name] - (tick() - StartTime)) --Update the rewards time after formating seconds into MM:SS format
					if rewards.Equipped.TextLabel.Text == ""Unlock in: 00:00"" then
						rewards.Equipped.Buy.Backing.Text.Text = ""Equip"" --if timer is reached 0 sec it changes rewards button text to equip
					end
				end
			end
		end
	end)
	
	--loop through all the rewards available in reward UI container/scrolling Frame
	for i, Rewards in pairs(RewardUI.Canvas.Container.Main.Container:GetChildren()) do
		if Rewards:IsA(""ImageButton"") then
			Rewards.MouseEnter:Connect(function()
				--same UIStroke logic
				if not UIStroke then
					UIStroke = Instance.new(""UIStroke"")
					UIStroke.Parent = Rewards:FindFirstChild(""Default"")
					UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual
					UIStroke.Color = Color3.fromRGB(126, 36, 233)
					UIStroke.Thickness = 2
				else
					UIStroke.Parent = Rewards:FindFirstChild(""Default"")
				end
			end)
			
			--remove UIStroke after player leaves the button
			Rewards.MouseLeave:Connect(function()
				UIStroke.Parent = nil
			end)
			
			--refrence to buy button
			local EquipButton:ImageButton = Rewards.Equipped:FindFirstChild(""Buy"") or Rewards.Default:FindFirstChild(""Buy"")

			local EquippedHat --last equipped Hat accessory
			local EquippedNeck --Last equipped neck accessory
			local EquippedFace --last equipped fconace accessory
			
			--handles equip button logic
			EquipButton.MouseButton1Click:Connect(function()
				if EquipButton.Backing.Text.Text == ""Locked yet!"" then return end --if item is currently lock then stop execution of event immediately
				if EquipButton.Backing.Text.Text == ""Unequip"" then --if player has already equipped item then unEquip it
					local Success, errorMessage = MapHandlerService:WearBrainRot(Rewards:FindFirstChild(""AssetId"").Value, Rewards)
					if Success then
						EquipButton.Backing.Text.Text = ""Equip""
					end
				else --if player has not equipped item then equip it
					local Success, errorMessage = MapHandlerService:WearBrainRot(Rewards:FindFirstChild(""AssetId"").Value, ""Wear"", Rewards)
					if Success then
						EquipButton.Backing.Text.Text = ""Unequip""
					end
				end
			end)
		end
	end
end

--handles logics of setting UI
function UserInterfaceController:SettignsUI()
	for i, Settings in pairs(SettingsUI.Canvas.Container.Main.Container:GetChildren()) do
		if Settings:IsA(""ImageLabel"") then
			local ToggleButton = Settings:FindFirstChild(""ToggleButton"")
			if ToggleButton then
				--Event which runs upon toggle button is clicked using left mouse button
				ToggleButton.MouseButton1Click:Connect(function()

					-- Determine toggle state
					local turningOff = Settings.Background.Toggle.ActiveFrame.Visible == true

					Settings.Background.Toggle.ActiveFrame.Visible = not turningOff
					Settings.Background.Toggle.InactiveFrame.Visible = turningOff

					-- Loop through all other players
					for _, Player in pairs(game.Players:GetPlayers()) do
						if Player == player then continue end
						local char = Player.Character
						if not char then return end

						for _, child in pairs(char:GetDescendants()) do
							if child:IsA(""MeshPart"") or child:IsA(""BasePart"") or child:IsA(""Decal"") then --This condition will only execute if the child is a type of ""BasePart"" Or ""MeshPart"" or ""Decal""
								if child.Name == ""HumanoidRootPart"" then continue end
								child.Transparency = turningOff and 0 or 1 -- Hide or show
							end
						end
					end
				end)
			end
		end
	end
end




function UserInterfaceController:KnitInit() 
	MapHandlerService = Knit.GetService(""MapHandlerService"") -- Fetch server-side service
	
	-- Init all UI features
	self:TrollUI()
	self:PushIUI()
	self:AnimateUIs()
	self:SettignsUI()
	self:ShopeUI()
	self:RewardUI()
	self:InventoryHandler()
	
	-- Show round countdown
	MapHandlerService.Timer:Connect(function()
		self:BackTimer()
	end)
	
	-- Display a center-screen message from the server
	MapHandlerService.Message:Connect(function(Message)
		self:ShowMessage(Message)
	end)
	
	-- Rope animation controller from server
	MapHandlerService.AnimateRopes:Connect(function(serverStartTime, Mode)
		self:startAnimationWhenReady(serverStartTime, Mode)
	end)
	
	--blocks player from returning back into the track after he has ended the round
	MapHandlerService.BlockGoingBack:Connect(function(mode)
		if mode == ""Easy"" then
			workspace.Maps.EasyRopemap:WaitForChild(""FinishPoint"").CanCollide = true
		else
			workspace.Maps.HadRopeMap:WaitForChild(""FinishPoint"").CanCollide = true
		end
	end)

	MapHandlerService.UpdateRewardStatus:Connect(function(RewardTemplate)
		for i, reward in pairs(player.PlayerGui.Reward.Canvas.Container.Main.Container:GetChildren()) do
			if reward:IsA(""ImageButton"") then
				-- Don’t change text if equip button text is ""Locked yet!""
				if reward.Equipped.Buy.Backing.Text.Text == ""Locked yet!"" then continue end
				-- Deselect all others if the same asset type is equipped/it changes text back to equip if the same asset type has text ""Unequip""
				if reward:FindFirstChild(""AssetType"").Value == ""Hat"" and reward ~= RewardTemplate then
					reward.Equipped.Buy.Backing.Text.Text = ""Equip""
				end
			end
		end
	end)
	
	--calls the server function for adding nametags to player head so it is visible to everyone
	MapHandlerService.NameTag:Connect(function()
		if ClonedPopupUI then
			ClonedPopupUI:Destroy()
		end
		player.PlayerGui.ColourWheelGui.Enabled = false
		MapHandlerService:GiveNameTags(player.PlayerGui.ColourWheelGui.ColourDisplay.BackgroundColor3)
	end)
	
	--Handles music playing/stopping with tween/amimation
	MapHandlerService.MusicEvent:Connect(function(argument)
		if argument == ""Play"" then
			player.PlayerGui.Buttons.ModesButton.Visible = true
			BackgroundMusic:Play()
			BackgroundMusic.Volume = 0
			TweenService:Create(BackgroundMusic, tweenInfoForMusic, {Volume = 0.25}):Play()
		elseif argument == ""Stop"" then
			player.PlayerGui.Buttons.ModesButton.Visible = false
			OpenedUI = nil
			player.PlayerGui.Modes.Frame:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.3)
			TweenService:Create(camera, tweenInfoUI, {FieldOfView = 70}):Play()
			TweenService:Create(Blur, tweenInfoUI, {Size = 0}):Play()
			TweenService:Create(BackgroundMusic, tweenInfoForMusic, {Volume = 0}):Play()
			
			-- Stop after fade-out
			task.delay(1.5, function()
				wait(1.5)
				BackgroundMusic:Stop()
			end)
		end
	end)
	
	-- Handles squid game music playing/stopping with the round start/ends
	MapHandlerService.SquidMusic:Connect(function(argument)
		if argument == ""Play"" then
			SquidMusic:Play()
			SquidMusic.Volume = 0
			TweenService:Create(SquidMusic, tweenInfoForMusic, {Volume = 0.25}):Play()
		elseif argument == ""Stop"" then
			TweenService:Create(SquidMusic, tweenInfoForMusic, {Volume = 0}):Play()
			task.delay(1.5, function()
				wait(1.5)
				SquidMusic:Stop()
			end)
		end
	end)

	MapHandlerService.RoundEnd:Connect(function(mode)
		if RopeAnimationConnection then
			RopeAnimationConnection:Disconnect()
			Rope:PivotTo(initialCFrame)
			if mode == ""Easy"" then --change the easy/hard map finish point's CanCollide property to false depending on mode
				workspace.Maps.EasyRopemap:WaitForChild(""FinishPoint"").CanCollide = false
			else
				workspace.Maps.HadRopeMap:WaitForChild(""FinishPoint"").CanCollide = false
			end
			workspace.Gravity = 196.2 -- Restore normal gravity for those who have bought ""LessGravity"" Developer product
		end
	end)

end

return UserInterfaceController"
Jn2d8W2v,Exploit(2),AriyanXploit404,HTML,Monday 30th of June 2025 12:36:40 PM CDT,"<!DOCTYPE html>
<html>
<body>
    <script>
        const a0 = [];
        const a1 = ""<scri"";
        const a2 = ""pt>"";
        const a3 = ""aler"";
        const a4 = ""t('Tes"";
        const a5 = ""ted By AriyanXploit404')""
        const a6 = ("";"");
        const a7 = (""</scri"")
        const a8 = (""pt>"");
        
        console.log(a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8);

        eval(a3 + a4 + a5 + a6);
    </script>
</body>
</html>"
ZGfuxmrY,Exploit(1),AriyanXploit404,HTML,Monday 30th of June 2025 12:26:29 PM CDT,"<!DOCTYPE html>
<html>
<body>
    <script>
        function X() {
            document.write('<script>alert(""Tested By AriyanXploit404"")</' + 'script>');
        }

        window.onload = X;
    </script>
</body>
</html>
"
dU9cHqEW,esp8266 websever https,mat8854,C++,Monday 30th of June 2025 12:25:14 PM CDT,"#include <ESP8266WiFi.h>
#include <ESP8266WebServerSecure.h>
#include ""certs.h""

const char* ssid = ""YOUR_WIFI_SSID"";
const char* password = ""YOUR_WIFI_PASSWORD"";

const char* authUser = ""admin"";
const char* authPass = ""yourpassword"";

BearSSL::ESP8266WebServerSecure server(10000);

void setup() {
  Serial.begin(115200);
  delay(100);

  // Connect to Wi-Fi
  WiFi.begin(ssid, password);
  Serial.print(""Connecting to WiFi..."");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(""."");
  }
  Serial.println(""\nWiFi connected. IP address: "");
  Serial.println(WiFi.localIP());

  // Load certificate and private key
  server.getServer().setRSACert(
    (const uint8_t*)cert, strlen(cert),
    (const uint8_t*)key, strlen(key)
  );

  // Add basic authentication to the root route
  server.on(""/"", []() {
    if (!server.authenticate(authUser, authPass)) {
      return server.requestAuthentication();  // send 401
    }
    server.send(200, ""text/html"", ""<h1>Hello, secure world!</h1><p>You are authenticated.</p>"");
  });

  server.begin();
  Serial.println(""Secure HTTPS server started on port 10000."");
}

void loop() {
  server.handleClient();
}"
kArBcs4t,dadwae,suramraja1,Lua,Monday 30th of June 2025 12:03:38 PM CDT,"-- HONEYSUCKLE SIMPLE CRAFT v2.0 (FIXED)
-- Method: Direct crafting with proper remote structure

local Players = game:GetService(""Players"")
local ReplicatedStorage = game:GetService(""ReplicatedStorage"")
local CollectionService = game:GetService(""CollectionService"")

local player = Players.LocalPlayer

-- Get the correct remote
local CraftingService = require(ReplicatedStorage.Modules.CraftingService.CraftingGlobalObjectService)

-- Function to find workbench
local function findWorkbench()
    for _, craftingObject in pairs(CollectionService:GetTagged(""CraftingObject"")) do
        if craftingObject:IsDescendantOf(workspace) and
           craftingObject:GetAttribute(""CraftingObjectType"") == ""SeedEventWorkbench"" then
            return craftingObject
        end
    end
    return nil
end

-- Function to get required items with UUIDs
local function getRequiredItems()
    local backpack = player:WaitForChild(""Backpack"")
    local items = {}
    local found = {[""Pink Lily""] = false, [""Purple Dahlia""] = false}
    
    for _, tool in pairs(backpack:GetChildren()) do
        if tool:IsA(""Tool"") then
            local itemString = tool:FindFirstChild(""Item_String"")
            if itemString then
                local itemName = itemString.Value
                if (itemName == ""Pink Lily"" or itemName == ""Purple Dahlia"") and not found[itemName] then
                    local itemUUID = tool:GetAttribute(""c"") or tool:GetAttribute(""ITEM_UUID"")
                    if itemUUID then
                        table.insert(items, {
                            name = itemName,
                            uuid = itemUUID,
                            tool = tool
                        })
                        found[itemName] = true
                    end
                end
            end
        end
    end
    
    if found[""Pink Lily""] and found[""Purple Dahlia""] then
        return items
    else
        return nil
    end
end

-- SIMPLE CRAFT FUNCTION
local function simpleCraft()
    print(""🌻 Starting Simple Honeysuckle Craft..."")
    
    -- Find workbench
    local workbench = findWorkbench()
    if not workbench then
        warn(""❌ SeedEventWorkbench not found!"")
        return false
    end
    
    -- Get items
    local items = getRequiredItems()
    if not items then
        warn(""❌ Need Pink Lily + Purple Dahlia with UUIDs in backpack!"")
        return false
    end
    
    print(""✅ Found "" .. #items .. "" items with UUIDs"")
    
    -- STEP 1: Set Recipe
    print(""📋 Setting recipe..."")
    CraftingService:SetRecipe(workbench, ""SeedEventWorkbench"", ""Honeysuckle"")
    wait(2)
    
    -- STEP 2: Input Items
    for i, item in ipairs(items) do
        print(""📦 Inputting "" .. item.name .. ""..."")
        CraftingService:InputItem(
            workbench,
            ""SeedEventWorkbench"", 
            i,
            {
                ItemType = ""Holdable"",
                ItemData = {
                    UUID = item.uuid
                }
            }
        )
        wait(1)
    end
    
    -- STEP 3: Start Craft
    print(""🔨 Starting craft..."")
    CraftingService:Craft(workbench, ""SeedEventWorkbench"")
    
    print(""✅ Simple craft completed!"")
    return true
end

-- Execute
simpleCraft()"
gYKgeQFY,B (On segment on segment) AC 734ms,prog3r,C++,Monday 30th of June 2025 11:25:12 AM CDT,"#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize(""Ofast,unroll-loops"")
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n, q;
    cin >> n >> q;
    int g1, g2;
    cin >> g1 >> g2;
    struct Node {
        int val=0;
        int l=-1;
        int r=-1;
        int move_to_y; // -5 means that it is y node already
    };
    vector<Node> nodes;
    nodes.reserve(6e7);
    auto l = [&] (int u) -> int {
        return (u == -1)?-1:nodes[u].l;
    };
    auto r = [&] (int u) -> int {
        return (u == -1)?-1:nodes[u].r;
    };
    auto gtval = [&] (int u) -> int {
        return (u == -1)?0:nodes[u].val;
    };
    auto mky = [&] (int val, int l, int r) -> int {
        nodes.push_back({val, l, r, -5});
        return nodes.size()-1;
    };
    auto mkx = [&] (int val, int l, int r, int move_to_y) -> int {
        nodes.push_back({val, l, r, move_to_y});
        return nodes.size()-1;
    };
    auto move_to_y = [&] (int u) -> int {
        return (u==-1)?-1:nodes[u].move_to_y;
    };
    auto incy = [&] (auto f, int u, int ytl, int ytr, int y, int val) -> int {
        if (ytl == ytr) {
            return mky(gtval(u) + val, -1, -1);
        } else {
            int tm = (ytl + ytr) >> 1;
            if (y <= tm) {
                int nwl = f(f, l(u), ytl, tm, y, val);
                return mky(gtval(nwl)+gtval(r(u)), nwl, r(u));
            } else {
                int nwr = f(f, r(u), tm+1, ytr, y, val);
                return mky(gtval(l(u))+gtval(nwr), l(u), nwr);
            }
        }
    };
    auto incx = [&] (auto f, int u, int xtl, int xtr, int ytl, int ytr, int x, int y, int val) -> int {
        if (xtl == xtr) {
            int goy = incy(incy, move_to_y(u), ytl, ytr, y, val);
            return mkx(gtval(goy), -1, -1, goy);
        }
        int tm = (xtl + xtr) >> 1;
        int L = l(u), R = r(u);
        if (x <= tm) {
            L = f(f, l(u), xtl, tm, ytl, ytr, x, y, val);
        } else {
            R = f(f, r(u), tm+1, xtr, ytl, ytr, x, y, val);
        }
        int goy = incy(incy, move_to_y(u), ytl, ytr, y, val);
        return mkx(gtval(L)+gtval(R), L, R, goy);
    };
    auto gt_prev_val = [&] (auto f, int u, int xtl, int xtr, int ytl, int ytr, int x) -> int {
        if (xtl == xtr) {
            if (nodes[u].move_to_y != -5) {
                u = nodes[u].move_to_y;
            }
            if (ytl == ytr) {
                return ytl;
            } else {
                int tm = (ytl + ytr) >> 1;
                if (gtval(l(u))) {
                    return f(f, l(u), xtl, xtr, ytl, tm, x);
                }
                return f(f, r(u), xtl, xtr, tm+1, ytr, x);
            }
        } else {
            int tm = (xtl + xtr) >> 1;
            if (x <= tm) {
                return f(f, l(u), xtl, tm, ytl, ytr, x);
            } else {
                return f(f, r(u), tm+1, xtr, ytl, ytr, x);
            }
        }
    };
    auto gt = [&] (auto f, int u, int xtl, int xtr, int ytl, int ytr, int xl, int xr, int yl, int yr) -> int {
        if (u == -1) {
            return 0ll;
        }
        if (xtl == xl && xtr == xr) {
            if (nodes[u].move_to_y != -5) {
                u = nodes[u].move_to_y;
            }
            if (ytl == yl && ytr == yr) {
                return gtval(u);
            } else {
                int tm = (ytl + ytr) >> 1;
                int ret = 0;
                if (yl <= tm) {
                    ret += f(f, l(u), xtl, xtr, ytl, tm, xl, xr, yl, min(yr, tm));
                }
                if (yr >= tm+1) {
                    ret += f(f, r(u), xtl, xtr, tm+1, ytr, xl, xr, max(yl, tm+1), yr);
                }
                return ret;
            }
        } else {
            int tm = (xtl + xtr) >> 1;
            int ret = 0;
            if (xl <= tm) {
                ret += f(f, l(u), xtl, tm, ytl, ytr, xl, min(xr, tm), yl, yr);
            }
            if (xr >= tm+1) {
                ret += f(f, r(u), tm+1, xtr, ytl, ytr, max(xl, tm+1), xr, yl, yr);
            }
            return ret;
        }
    };
    vector<int> roots(q+1, -1);
    for (int i = 1; i <= n; i += 1) {
        roots[0] = incx(incx, roots[0], 1, n, 0, min(n, 100), i, 0, 1);
    }
    int ra = 0;
    auto gen = [&] () -> int {
        (ra = g1*ra+g2) %= n;
        return ra;
    };
    for (int i = 1; i <= q; i += 1) {
        int tp, from;
        cin >> tp >> from;
        roots[i] = roots[from];
        if (tp == 1) {
            int idx, val;
            cin >> idx >> val;
            int prev_val = gt_prev_val(gt_prev_val, roots[i], 1, n, 0, min(n, 100), idx);
            roots[i] = incx(incx, roots[i], 1, n, 0, min(n, 100), idx, prev_val, -1);
            roots[i] = incx(incx, roots[i], 1, n, 0, min(n, 100), idx, val, 1);
        }
        if (tp == 2) {
            int valL, valR;
            cin >> valL >> valR;
            int iL = gen()+1;
            int iR = gen()+1;
            if (!(iL <= iR)) {
                swap(iL, iR);
            }
            int ans = gt(gt, roots[i], 1, n, 0, min(n, 100), iL, iR, valL, valR);
            cout << ans << ""\n"";
            g1 += ans;
            if (g1 >= n) {
                g1 -= n;
            }
        }
    }
}
;;;"
Nm0uMgLJ,Untitled,Brusnik,Python,Monday 30th of June 2025 11:15:07 AM CDT,"# Задание №2

password = input(""Введите пароль: "")

confrimation_password = input(""Повторно введите пароль: "")

if(password == confrimation_password):
    print(""True"")
else:
    print(""False"")


# Задание №3

num_1 = int(input())
num_2 = int(input())
num_3 = int(input())
num_4 = int(input())

print(min(num_1, num_2, num_3, num_4))


# Задание №4

num_1 = int(input())
num_2 = int(input())
num_3 = int(input())
num_4 = int(input())

print(max(num_1, num_2, num_3, num_4))


# Задание №5

a = int(input())
b = int(input())
c = int(input())

if(a <= b + c) and (b <= a + c) and (c <= a + b):
    print(""True"")
else:
    print(""False"")


# Задание №6

a = int(input())
b = int(input())
c = int(input())

if (a + b >= c) and (a + c >= b) and (b + c >= a):
    if (a + b == c) or (b + c == a) or (a + c == b):
        print(""Вырожденный треугольник"")
    elif (a == b) and (a == c) and (b == c):
        print(""Равносторонний треугольник"")
    else:
        print(""Разносторонний треугольник"")
else:
    print(""Треугольника с такими сторонами не существует!"")
# Задание №7

left_1 = int(input(""Введите левую границу первого отрезка (a): ""))
right_1 = int(input(""Введите правую границу первого отрезка (b): ""))
left_2 = int(input(""Введите левую границу второго отрезка (c): ""))
right_2 = int(input(""Введите правую границу второго отрезка (d): ""))

left = max(left_1, left_2)
right = min(right_1, right_2)

if (left > right):
    print(0)
else:
    print(right - left + 1)"
b1m3QeX4,BoostIntensity,TIDETER,Lua,Monday 30th of June 2025 11:12:39 AM CDT,"Remotes.BoostIntensity.OnServerEvent:Connect(function(Player : Player, Agreed : Boolean, PassKey : Number)
	if not Game.Info.BoostingEnabled then
		return Remotes.Alert:FireClient(Player, ""Boosting is disabled"")
	end
	
	if not FE2Library.BoostCosts[Game.Info.BoostCount+1] then
		return Remotes.Alert:FireClient(Player, ""Max number of boosts reached!"")
	end
	
	if Game.Info.Intensity + Functions.GetIntensityChange(0, Game.Info.Difficulty, Game.Info.BoostedIntensity) >= 5.99 then
		return Remotes.Alert:FireClient(Player, ""Max intensity has already been guaranteed!"")	
	end
	
	local Profile = DataModule.getProfile(Player)	
	local PlayerData = Profile.playerData
	local OwnsGamePass = table.find(Profile.ownedGamepasses, 14784835)
	local TwoX = OwnsGamePass and 1 or 0.5
	local boostCost = FE2Library.BoostCosts[Game.Info.BoostCount+1]
	
	if (not Agreed) and Game.Info.BoostCount > 1 then
		return ReplicatedStorage.Remote.BoostIntensity:FireClient(Player, ""The current Intensity boost is "".. Game.Info.BoostedIntensity .."". Boosting by another 0.5 will cost "".. boostCost .."" Gems."", ""Intensity Boost"", true)
	end

	if PlayerData.stats.gems >= boostCost then
		Game.Info.BoostCount += 1
		Game.Info.BoostedIntensity += 0.5
		Game.BoostSum += 1
		
		Profile:updatePlayerData(
			{""stats"", ""gems""},
			""PlayerData"",
			""Increment"",
			-Game.Info.IntBoostCurrentCost or 0
		)
		
		if not FE2Library.BoostCosts[Game.Info.BoostCount+1] then
			updPanelInfo(""BoostingEnabled"", false)
		else
			updPanelInfo(
				""IntBoostCurrentCost"", FE2Library.BoostCosts[Game.Info.BoostCount + 1]
			)
		end

		local minInt = math.clamp(Game.Info.Intensity+
			Functions.GetIntensityChange(1,
			Game.Info.Intensity, Game.Info.BoostedIntensity, 5.99), 1, 5.99
		)
		
		Remotes.Alert:FireAllClients((Player.Name .. "" boosted! Min. Intensity: %s - %s""):format(
			minInt, Game.Info.Intensity + Functions.GetIntensityChange(0, Game.Info.Intensity, Game.Info.BoostedIntensity)),
			FE2Library.DiffColors[math.floor(minInt)] or nil, nil, minInt >= 5.99 and 'rainbow' or nil
		)

		Remotes.Sound:FireAllClients(1044088048, 5, 1 + (0.05 * Game.Info.BoostCount))
		ProgressDailyChallenge(Player, 19)
	else return Remotes.Alert:FireClient(Player, ""Not enough currency!"") end
end)"
WRTifZ64,Number of ways to partition into k subsets(IMPORANTANT),Fastrail08,C++,Monday 30th of June 2025 11:11:31 AM CDT,"// IMPORTANT SEE THIS DISCUSSION 
// https://chatgpt.com/share/6862b81c-7a7c-8012-983f-5e2aa76d97c0
#include <bits/stdc++.h>
using namespace std;

long long getKPartitions(int level, int partitionsFormed, int &k, int &n, vector<vector<long long> > &memo){
    if(level > n){
        if(partitionsFormed == k){
            return 1;
        }
        return 0;
    }
    //memo check
    if(memo[level][partitionsFormed] != -1){
        return memo[level][partitionsFormed];
    }
    long long newPartition = 0, exisitingPartition = 0;
    // create a new partition if capability to create a new partition
    if(partitionsFormed < k){
        newPartition = getKPartitions(level + 1, partitionsFormed + 1, k, n, memo);
    }
    
    //don't create a new partition, become part of each exisiting partition one by one
    // for(int i = 0; i < partitionsFormed; i++){
    //     exisitingPartition += getKPartitions(level + 1, partitionsFormed, k, n, memo);
    // }
    //You can actually replace the call with the following ------
    exisitingPartition = getKPartitions(level + 1, partitionsFormed, k, n, memo);
    exisitingPartition *= partitionsFormed;
    
    // WHY??
    // What are we doing here? we are calling the same function exactly equal to the number of partitions present at the current level. If the number is not creating a new partition it can become a part of every partition present at that level, giving a new way to partition each time.
    // Also the loop is doing the same thing - 
    /*
    for(0 -> partitionsFormed - 1){
        call Kpartition [partitionsFormed] number of times. 
    }
    
    Basically doing ------
    count = Kpartition() * partitionsFormed
    */ 
    
    /*
    Now if you see the recursive function, the params that are changing are (level, k). so memo(level, key).
    Also what does that mean ------
    
    memo(level/i, k/x) = After processing upto ith index, if number of partitions formed till now is x, any subproblem falling under this category will have the same count of ways to distribute (n - i) elements into (k - x) partitions . What this means is we are memoising number of ways to disribute if the number of elements remaining to be partitioned is (n - i), and the number of partitions left is (k - x). 
    
    SO IT DOESN'T MATTER WHAT THE ACTUAL ELEMENTS ARE IN THE PARTITION, just the number of elements that are already processed and the number of partitions that are already used in processing them.
    
    Actually the memo defintion contains (i, x), but the value that is memoised is (n - i, k - x)... just imagine what part of tree we are avoiding to recalculate.
    The part that we are avoiding to recalculate is how to distribute (n - i) elements into (k - x) partitions. This is actually what DP is. AVOID RECALCULATION OF SMALLER SUBPROBLEMS.
    
    WHY?? 
    Because partition doesn't depend on the ELEMENTS or PARTITIONS itself
    for eg - (n - i) = 5, (k - x) = 2
    ******Number of ways to DISTRIBUTE 5 elements into 2 partitions will always have the same REGARDLESS of the what the value of the elements are.
    
    
    THIS IS WHERE IT DIFFERS WITH THE QUESTION - partition n elements into k equal sum partitions.
    
    Imagine how would you achieve this recursively?
    Keep track of (level, k, partitionSumVector). We need to maintain a partitionSum vector of size k, so that in base case we can actually compare the sum of all k partitions, in whatever case, there are k partitions all with equal sum will contribute to answer.
    
    Now in the recursive code, 3 params are changing... 
    (number of indices processed, number of partitions left to form, sum of every partition formed).
    so MEMO(level, k, partitionSum)
    so memo key = [level + ""|"" k + ""|"" + serializeIntoString(partitionSum)]
    
    Alternatively you can think as - 
    WHAT ALL PARAMS ARE NEEDED TO MAKE VALID/INVALID DECISIONS IN THE BASE CASE?? 
    
    1) we need a level > n check to see if all elements are processed
    2) we need a k == 0 check to see if exactly k partitions are formed
    3) If both of the above are met, compare the sum of all k partitions and see if they are equal.
    
    If all 3 condns are met, return 1 else 0
    
    So we needed these 3 variables to make decision, that's why all 3 are to be memoised.
    
    so if you try to memoise with key as (level, k) it would insufficient, as the partitionSum vector might have different value.
    And if it differs, the decision making in base case may also differ.
    FOR EG ------ consider array of 7 elements and 4 partitions, now if in the base case we have the params as - 
    level = 7(all indices processed), 0 partitions left to form(all 4 partitions formed),sum of each partition  
    (7, 0, [8, 8, 8, 8]) & (7, 0, [4, 6, 4, 2])
    
    But the first case is a VALID ANSWER (all 4 partitions equal) which will return 1 and the second case is INVALID (sum not equal) which will return 0.
    
    But if you had memoised based on (level, k) both had the same key (7, 0) ...which makes essentially an OVERLAPPING IDENTICAL SUBPROBLEM but they are not as the answers returned from both the cases are different. They are OVERLAPPING NON IDENTICAL SUBPROBLEMS, misclassified...
    
    When this happens, when you MISCLASSIFY two different subproblems under 1 key, 
    YOU ARE MEMOISING WITH AN INCOMPLETE KEY!!!
    OR
    MEMO KEY DOES NOT REPRESENT THE COMPLETE STATE OF THE SUBPROBLEM
    OR
    STATE UNDER SPECIFICATION (USING LESS VARIABLES TO DEFINE THE PROBLEM) 
    
    ******Need more uniqueness in the key to differentiate subproblems correctly
    
    */
    
    return memo[level][partitionsFormed] = newPartition + exisitingPartition;
}

int main() {
	// your code goes here
    int n, k;
    cin >> n >> k;
    vector<vector<long long> > memo(n + 1, vector<long long>(k + 1, -1)); 
    cout << getKPartitions(1, 0, k, n, memo) << '\n';
    
}
"
G14457qs,Escalonador de Sistemas Lineares,Finnit,C,Monday 30th of June 2025 11:04:06 AM CDT,"#include <stdio.h>
#include <stdlib.h>

#define DEBUG 0

void swap(double *s, int M, int N, int i, int l) {
    double t;
    for(int j = 0; j < N; ++j) {
        t = s[i*N+j];
        s[i*N+j] = s[l*N+j];
        s[l*N+j] = t;
    }
}

int non0pivot(double *s, int M, int N, int i, int j) {
    for(int i = 0; i < N; ++i)
        if(s[i*N+j] != 0)
            return i;
    return -1; 
}

void readS(FILE *in, double **s, int *M, int *N) {
    int x;
    x = fscanf(in,""%d"",M);
    *N = *M+1;
    #if DEBUG
    printf(""%d %d\n"",*M,*N);
    #endif
    *s = calloc((*M)*(*N),sizeof(double));
    for(int i = 0; i < *M**N; ++i) {
        #if DEBUG
        printf(""i: %d\n"",i);
        #endif
        x = fscanf(in,""%lf"",&((*s)[i]));
    }   
}

void printS(FILE *out, double *s, int M, int N) {
    for(int i = 0; i < M; ++i) {
        for(int j = 0; j < N; ++j) {
            if(s[i*N+j] >= 0) {
                printf("" "");
                fprintf(out,"" "");
            }
        	printf(""%.3lf "",s[i*N+j]);
        	fprintf(out,""%.3lf "",s[i*N+j]);
        }
        putchar('\n');
    }
    putchar('\n');
}

void mult(double *s, double *x, double *c, int M, int N) {
    for(int i = 0; i < M; ++i)
        for(int j = 0; j < N-1; ++j)
            for(int k = 0; k < M; ++k)
                c[k] += s[i*N+k]*x[k];
}

int main(int argc, char **argv) {
    if(argc != 3)
        return -1;
    FILE *in = fopen(argv[1],""r"");
    FILE *out = fopen(argv[2],""w"");

    int M, N;
    double *s;

    readS(in,&s,&M,&N);
    printS(out,s,M,N);

    double *x = calloc(M,sizeof(double));
    double *b = calloc(M,sizeof(double));
    double *c = calloc(M,sizeof(double));

    #if DEBUG
    printf(""linha: %d\n"",__LINE__);
    #endif
    for(int i = 0, j = 0; i < M; ++i, ++j) {
        #if DEBUG
        printf(""linha: %d, i = %d\n"",__LINE__,i);
        #endif
        if(s[i*N+j] == 0) {
            #if DEBUG
            printf(""linha: %d, i = %d\n"",__LINE__,i);
            #endif
			int l = non0pivot(s,M,N,i+1,j);
            if(l == -1) {
                ++j;
                break;
            }
            swap(s,M,N,i,l);
        }
        #if DEBUG
        printf(""linha: %d, i = %d\n"",__LINE__,i);
        #endif
        for(int k = 0; k < M; ++k) {
            if(i == k)
                continue;
            register double x = s[k*N+j]/s[i*N+j];
            s[k*N+i] = 0.;
            for(int h = i+1; h < N; ++h)
                s[k*N+h] -= x*s[i*N+h];
        }
        printS(out,s,M,N);
    }

    for(int i = 0, j = 0; i < M; ++i, ++j) {
        if(s[i*N+j] == 0) {
            ++j;
            continue;
        }
        register double x = s[i*N+j];
        for(int k = j; k < N; ++k)
            s[i*N+k] = s[i*N+k]/x;
    }
    printS(out,s,M,N);

    for(int i = 0, j = 0; i < M; ++i, ++j) {
        if(s[i*N+j] == 0) {
            ++j;
            continue;
        }
        x[i] = s[i*N+j];
        b[i] = s[i*N+N-1];
    }

    mult(s,x,c,M,N);
	for(int i = 0; i < M; ++i)
        printf(""err(%d): %lf\n"", i, b[i]-c[i]);
}
"
2wctxSv3,Restore Point Save Before 8-Ball + Foul + CPU Aim/Pocket Bugs Are Fixed Tomorrow !!,alien_fx_fiend,C++,Monday 30th of June 2025 11:03:49 AM CDT,"#define WIN32_LEAN_AND_MEAN
#define NOMINMAX
#include <windows.h>
#include <d2d1.h>
#include <dwrite.h>
#include <fstream> // For file I/O
#include <iostream> // For some basic I/O, though not strictly necessary for just file ops
#include <vector>
#include <cmath>
#include <string>
#include <sstream> // Required for wostringstream
#include <algorithm> // Required for std::max, std::min
#include <ctime>    // Required for srand, time
#include <cstdlib> // Required for srand, rand (often included by others, but good practice)
#include <commctrl.h> // Needed for radio buttons etc. in dialog (if using native controls)
#include <mmsystem.h> // For PlaySound
#include <tchar.h> //midi func
#include <thread>
#include <atomic>
#include ""resource.h""

#pragma comment(lib, ""Comctl32.lib"") // Link against common controls library
#pragma comment(lib, ""d2d1.lib"")
#pragma comment(lib, ""dwrite.lib"")
#pragma comment(lib, ""Winmm.lib"") // Link against Windows Multimedia library

// --- Constants ---
const float PI = 3.1415926535f;
const float BALL_RADIUS = 10.0f;
const float TABLE_LEFT = 100.0f;
const float TABLE_TOP = 100.0f;
const float TABLE_WIDTH = 700.0f;
const float TABLE_HEIGHT = 350.0f;
const float TABLE_RIGHT = TABLE_LEFT + TABLE_WIDTH;
const float TABLE_BOTTOM = TABLE_TOP + TABLE_HEIGHT;
const float CUSHION_THICKNESS = 20.0f;
const float HOLE_VISUAL_RADIUS = 22.0f; // Visual size of the hole
const float POCKET_RADIUS = HOLE_VISUAL_RADIUS * 1.05f; // Make detection radius slightly larger // Make detection radius match visual size (or slightly larger)
const float MAX_SHOT_POWER = 15.0f;
const float FRICTION = 0.985f; // Friction factor per frame
const float MIN_VELOCITY_SQ = 0.01f * 0.01f; // Stop balls below this squared velocity
const float HEADSTRING_X = TABLE_LEFT + TABLE_WIDTH * 0.30f; // 30% line
const float RACK_POS_X = TABLE_LEFT + TABLE_WIDTH * 0.65f; // 65% line for rack apex
const float RACK_POS_Y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
const UINT ID_TIMER = 1;
const int TARGET_FPS = 60; // Target frames per second for timer

// --- Enums ---
// --- MODIFIED/NEW Enums ---
enum GameState {
    SHOWING_DIALOG,     // NEW: Game is waiting for initial dialog input
    PRE_BREAK_PLACEMENT,// Player placing cue ball for break
    BREAKING,           // Player is aiming/shooting the break shot
    CHOOSING_POCKET_P1, // NEW: Player 1 needs to call a pocket for the 8-ball
    CHOOSING_POCKET_P2, // NEW: Player 2 needs to call a pocket for the 8-ball
    AIMING,             // Player is aiming
    AI_THINKING,        // NEW: AI is calculating its move
    SHOT_IN_PROGRESS,   // Balls are moving
    ASSIGNING_BALLS,    // Turn after break where ball types are assigned
    PLAYER1_TURN,
    PLAYER2_TURN,
    BALL_IN_HAND_P1,
    BALL_IN_HAND_P2,
    GAME_OVER
};

enum BallType {
    NONE,
    SOLID,  // Yellow (1-7)
    STRIPE, // Red (9-15)
    EIGHT_BALL, // Black (8)
    CUE_BALL // White (0)
};

// NEW Enums for Game Mode and AI Difficulty
enum GameMode {
    HUMAN_VS_HUMAN,
    HUMAN_VS_AI
};

enum AIDifficulty {
    EASY,
    MEDIUM,
    HARD
};

enum OpeningBreakMode {
    CPU_BREAK,
    P1_BREAK,
    FLIP_COIN_BREAK
};

// --- Structs ---
struct Ball {
    int id;             // 0=Cue, 1-7=Solid, 8=Eight, 9-15=Stripe
    BallType type;
    float x, y;
    float vx, vy;
    D2D1_COLOR_F color;
    bool isPocketed;
};

struct PlayerInfo {
    BallType assignedType;
    int ballsPocketedCount;
    std::wstring name;
};

// --- Global Variables ---

// Direct2D & DirectWrite
ID2D1Factory* pFactory = nullptr;
//ID2D1Factory* g_pD2DFactory = nullptr;
ID2D1HwndRenderTarget* pRenderTarget = nullptr;
IDWriteFactory* pDWriteFactory = nullptr;
IDWriteTextFormat* pTextFormat = nullptr;
IDWriteTextFormat* pLargeTextFormat = nullptr; // For ""Foul!""

// Game State
HWND hwndMain = nullptr;
GameState currentGameState = SHOWING_DIALOG; // Start by showing dialog
std::vector<Ball> balls;
int currentPlayer = 1; // 1 or 2
PlayerInfo player1Info = { BallType::NONE, 0, L""Player 1"" };
PlayerInfo player2Info = { BallType::NONE, 0, L""CPU"" }; // Default P2 name
bool foulCommitted = false;
std::wstring gameOverMessage = L"""";
bool firstBallPocketedAfterBreak = false;
std::vector<int> pocketedThisTurn;
// --- NEW: 8-Ball Pocket Call Globals ---
int calledPocketP1 = -1; // Pocket index (0-5) called by Player 1 for the 8-ball. -1 means not called.
int calledPocketP2 = -1; // Pocket index (0-5) called by Player 2 for the 8-ball.
int currentlyHoveredPocket = -1; // For visual feedback on which pocket is being hovered
std::wstring pocketCallMessage = L""""; // Message like ""Choose a pocket...""

// --- NEW: Foul Tracking Globals ---
int firstHitBallIdThisShot = -1;      // ID of the first object ball hit by cue ball (-1 if none)
bool cueHitObjectBallThisShot = false; // Did cue ball hit an object ball this shot?
bool railHitAfterContact = false;     // Did any ball hit a rail AFTER cue hit an object ball?
// --- End New Foul Tracking Globals ---

// NEW Game Mode/AI Globals
GameMode gameMode = HUMAN_VS_HUMAN; // Default mode
AIDifficulty aiDifficulty = MEDIUM; // Default difficulty
OpeningBreakMode openingBreakMode = CPU_BREAK; // Default opening break mode
bool isPlayer2AI = false;           // Is Player 2 controlled by AI?
bool aiTurnPending = false;         // Flag: AI needs to take its turn when possible
// bool aiIsThinking = false;       // Replaced by AI_THINKING game state
// NEW: Flag to indicate if the current shot is the opening break of the game
bool isOpeningBreakShot = false;

// NEW: For AI shot planning and visualization
struct AIPlannedShot {
    float angle;
    float power;
    float spinX;
    float spinY;
    bool isValid; // Is there a valid shot planned?
};
AIPlannedShot aiPlannedShotDetails; // Stores the AI's next shot
bool aiIsDisplayingAim = false;    // True when AI has decided a shot and is in ""display aim"" mode
int aiAimDisplayFramesLeft = 0;  // How many frames left to display AI aim
const int AI_AIM_DISPLAY_DURATION_FRAMES = 45; // Approx 0.75 seconds at 60 FPS, adjust as needed

// Input & Aiming
POINT ptMouse = { 0, 0 };
bool isAiming = false;
bool isDraggingCueBall = false;
// --- ENSURE THIS LINE EXISTS HERE ---
bool isDraggingStick = false; // True specifically when drag initiated on the stick graphic
// --- End Ensure ---
bool isSettingEnglish = false;
D2D1_POINT_2F aimStartPoint = { 0, 0 };
float cueAngle = 0.0f;
float shotPower = 0.0f;
float cueSpinX = 0.0f; // Range -1 to 1
float cueSpinY = 0.0f; // Range -1 to 1
float pocketFlashTimer = 0.0f;
bool cheatModeEnabled = false; // Cheat Mode toggle (G key)
int draggingBallId = -1;
bool keyboardAimingActive = false; // NEW FLAG: true when arrow keys modify aim/power
MCIDEVICEID midiDeviceID = 0; //midi func
std::atomic<bool> isMusicPlaying(false); //midi func
std::thread musicThread; //midi func
void StartMidi(HWND hwnd, const TCHAR* midiPath);
void StopMidi();

// UI Element Positions
D2D1_RECT_F powerMeterRect = { TABLE_RIGHT + CUSHION_THICKNESS + 10, TABLE_TOP, TABLE_RIGHT + CUSHION_THICKNESS + 40, TABLE_BOTTOM };
D2D1_RECT_F spinIndicatorRect = { TABLE_LEFT - CUSHION_THICKNESS - 60, TABLE_TOP + 20, TABLE_LEFT - CUSHION_THICKNESS - 20, TABLE_TOP + 60 }; // Circle area
D2D1_POINT_2F spinIndicatorCenter = { spinIndicatorRect.left + (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f, spinIndicatorRect.top + (spinIndicatorRect.bottom - spinIndicatorRect.top) / 2.0f };
float spinIndicatorRadius = (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f;
D2D1_RECT_F pocketedBallsBarRect = { TABLE_LEFT, TABLE_BOTTOM + CUSHION_THICKNESS + 30, TABLE_RIGHT, TABLE_BOTTOM + CUSHION_THICKNESS + 70 };

// Corrected Pocket Center Positions (aligned with table corners/edges)
const D2D1_POINT_2F pocketPositions[6] = {
    {TABLE_LEFT, TABLE_TOP},                           // Top-Left
    {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_TOP},      // Top-Middle
    {TABLE_RIGHT, TABLE_TOP},                          // Top-Right
    {TABLE_LEFT, TABLE_BOTTOM},                        // Bottom-Left
    {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_BOTTOM},   // Bottom-Middle
    {TABLE_RIGHT, TABLE_BOTTOM}                        // Bottom-Right
};

// Colors
const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.1608f, 0.4000f, 0.1765f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
//const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.0f, 0.5f, 0.1f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF(0.3608f, 0.0275f, 0.0078f)); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
//const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF::Red); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
const D2D1_COLOR_F POCKET_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
const D2D1_COLOR_F CUE_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::White);
const D2D1_COLOR_F EIGHT_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
const D2D1_COLOR_F SOLID_COLOR = D2D1::ColorF(D2D1::ColorF::Yellow); // Solids = Yellow
const D2D1_COLOR_F STRIPE_COLOR = D2D1::ColorF(D2D1::ColorF::Red);   // Stripes = Red
const D2D1_COLOR_F AIM_LINE_COLOR = D2D1::ColorF(D2D1::ColorF::White, 0.7f); // Semi-transparent white
const D2D1_COLOR_F FOUL_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(0.1333f, 0.7294f, 0.7490f); //NEWCOLOR 0.1333f, 0.7294f, 0.7490f => ::Blue
//const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(D2D1::ColorF::Blue);
const D2D1_COLOR_F ENGLISH_DOT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
const D2D1_COLOR_F UI_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Black);

// --- Forward Declarations ---
HRESULT CreateDeviceResources();
void DiscardDeviceResources();
void OnPaint();
void OnResize(UINT width, UINT height);
void InitGame();
void GameUpdate();
void UpdatePhysics();
void CheckCollisions();
bool CheckPockets(); // Returns true if any ball was pocketed
void ProcessShotResults();
void ApplyShot(float power, float angle, float spinX, float spinY);
void RespawnCueBall(bool behindHeadstring);
bool AreBallsMoving();
void SwitchTurns();
bool AssignPlayerBallTypes(BallType firstPocketedType);
void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed);
Ball* GetBallById(int id);
Ball* GetCueBall();
//void PlayGameMusic(HWND hwnd); //midi func
void AIBreakShot();

// Drawing Functions
void DrawScene(ID2D1RenderTarget* pRT);
void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory);
void DrawBalls(ID2D1RenderTarget* pRT);
void DrawCueStick(ID2D1RenderTarget* pRT);
void DrawAimingAids(ID2D1RenderTarget* pRT);
void DrawUI(ID2D1RenderTarget* pRT);
void DrawPowerMeter(ID2D1RenderTarget* pRT);
void DrawSpinIndicator(ID2D1RenderTarget* pRT);
void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT);
void DrawBallInHandIndicator(ID2D1RenderTarget* pRT);
// NEW
void DrawPocketSelectionIndicator(ID2D1RenderTarget* pRT);

// Helper Functions
float GetDistance(float x1, float y1, float x2, float y2);
float GetDistanceSq(float x1, float y1, float x2, float y2);
bool IsValidCueBallPosition(float x, float y, bool checkHeadstring);
template <typename T> void SafeRelease(T** ppT);
// --- NEW HELPER FORWARD DECLARATIONS ---
bool IsPlayerOnEightBall(int player);
void CheckAndTransitionToPocketChoice(int playerID);
// --- ADD FORWARD DECLARATION FOR NEW HELPER HERE ---
float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b);
// --- End Forward Declaration ---
bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection); // Keep this if present

// --- NEW Forward Declarations ---

// AI Related
struct AIShotInfo; // Define below
void TriggerAIMove();
void AIMakeDecision();
void AIPlaceCueBall();
AIShotInfo AIFindBestShot();
AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex);
bool IsPathClear(D2D1_POINT_2F start, D2D1_POINT_2F end, int ignoredBallId1, int ignoredBallId2);
Ball* FindFirstHitBall(D2D1_POINT_2F start, float angle, float& hitDistSq); // Added hitDistSq output
float CalculateShotPower(float cueToGhostDist, float targetToPocketDist);
D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex);
bool IsValidAIAimAngle(float angle); // Basic check

// Dialog Related
INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
void ShowNewGameDialog(HINSTANCE hInstance);
void LoadSettings(); // For deserialization
void SaveSettings(); // For serialization
const std::wstring SETTINGS_FILE_NAME = L""Pool-Settings.txt"";
void ResetGame(HINSTANCE hInstance); // Function to handle F2 reset

// --- Forward Declaration for Window Procedure --- <<< Add this line HERE
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

// --- NEW Struct for AI Shot Evaluation ---
struct AIShotInfo {
    bool possible = false;          // Is this shot considered viable?
    Ball* targetBall = nullptr;     // Which ball to hit
    int pocketIndex = -1;           // Which pocket to aim for (0-5)
    D2D1_POINT_2F ghostBallPos = { 0,0 }; // Where cue ball needs to hit target ball
    float angle = 0.0f;             // Calculated shot angle
    float power = 0.0f;             // Calculated shot power
    float score = -1.0f;            // Score for this shot (higher is better)
    bool involves8Ball = false;     // Is the target the 8-ball?
};

/*
table = TABLE_COLOR new: #29662d (0.1608, 0.4000, 0.1765) => old: (0.0f, 0.5f, 0.1f)
rail CUSHION_COLOR = #5c0702 (0.3608, 0.0275, 0.0078) => ::Red
gap = #e99d33 (0.9157, 0.6157, 0.2000) => ::Orange
winbg = #5e8863 (0.3686, 0.5333, 0.3882) => 1.0f, 1.0f, 0.803f
headstring = #47742f (0.2784, 0.4549, 0.1843) => ::White
bluearrow = #08b0a5 (0.0314, 0.6902, 0.6471) *#22babf (0.1333,0.7294,0.7490) => ::Blue
*/

// --- NEW Settings Serialization Functions ---
void SaveSettings() {
    std::ofstream outFile(SETTINGS_FILE_NAME);
    if (outFile.is_open()) {
        outFile << static_cast<int>(gameMode) << std::endl;
        outFile << static_cast<int>(aiDifficulty) << std::endl;
        outFile << static_cast<int>(openingBreakMode) << std::endl;
        outFile.close();
    }
    // else: Handle error, e.g., log or silently fail
}

void LoadSettings() {
    std::ifstream inFile(SETTINGS_FILE_NAME);
    if (inFile.is_open()) {
        int gm, aid, obm;
        if (inFile >> gm) {
            gameMode = static_cast<GameMode>(gm);
        }
        if (inFile >> aid) {
            aiDifficulty = static_cast<AIDifficulty>(aid);
        }
        if (inFile >> obm) {
            openingBreakMode = static_cast<OpeningBreakMode>(obm);
        }
        inFile.close();

        // Validate loaded settings (optional, but good practice)
        if (gameMode < HUMAN_VS_HUMAN || gameMode > HUMAN_VS_AI) gameMode = HUMAN_VS_HUMAN; // Default
        if (aiDifficulty < EASY || aiDifficulty > HARD) aiDifficulty = MEDIUM; // Default
        if (openingBreakMode < CPU_BREAK || openingBreakMode > FLIP_COIN_BREAK) openingBreakMode = CPU_BREAK; // Default
    }
    // else: File doesn't exist or couldn't be opened, use defaults (already set in global vars)
}
// --- End Settings Serialization Functions ---

// --- NEW Dialog Procedure ---
INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
    switch (message) {
    case WM_INITDIALOG:
    {
        // --- ACTION 4: Center Dialog Box ---
// Optional: Force centering if default isn't working
        RECT rcDlg, rcOwner, rcScreen;
        HWND hwndOwner = GetParent(hDlg); // GetParent(hDlg) might be better if hwndMain is passed
        if (hwndOwner == NULL) hwndOwner = GetDesktopWindow();

        GetWindowRect(hwndOwner, &rcOwner);
        GetWindowRect(hDlg, &rcDlg);
        CopyRect(&rcScreen, &rcOwner); // Use owner rect as reference bounds

        // Offset the owner rect relative to the screen if it's not the desktop
        if (GetParent(hDlg) != NULL) { // If parented to main window (passed to DialogBoxParam)
            OffsetRect(&rcOwner, -rcScreen.left, -rcScreen.top);
            OffsetRect(&rcDlg, -rcScreen.left, -rcScreen.top);
            OffsetRect(&rcScreen, -rcScreen.left, -rcScreen.top);
        }


        // Calculate centered position
        int x = rcOwner.left + (rcOwner.right - rcOwner.left - (rcDlg.right - rcDlg.left)) / 2;
        int y = rcOwner.top + (rcOwner.bottom - rcOwner.top - (rcDlg.bottom - rcDlg.top)) / 2;

        // Ensure it stays within screen bounds (optional safety)
        x = std::max(static_cast<int>(rcScreen.left), x);
        y = std::max(static_cast<int>(rcScreen.top), y);
        if (x + (rcDlg.right - rcDlg.left) > rcScreen.right)
            x = rcScreen.right - (rcDlg.right - rcDlg.left);
        if (y + (rcDlg.bottom - rcDlg.top) > rcScreen.bottom)
            y = rcScreen.bottom - (rcDlg.bottom - rcDlg.top);


        // Set the dialog position
        SetWindowPos(hDlg, HWND_TOP, x, y, 0, 0, SWP_NOSIZE);

        // --- End Centering Code ---

        // Set initial state based on current global settings (or defaults)
        CheckRadioButton(hDlg, IDC_RADIO_2P, IDC_RADIO_CPU, (gameMode == HUMAN_VS_HUMAN) ? IDC_RADIO_2P : IDC_RADIO_CPU);

        CheckRadioButton(hDlg, IDC_RADIO_EASY, IDC_RADIO_HARD,
            (aiDifficulty == EASY) ? IDC_RADIO_EASY : ((aiDifficulty == MEDIUM) ? IDC_RADIO_MEDIUM : IDC_RADIO_HARD));

        // Enable/Disable AI group based on initial mode
        EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), gameMode == HUMAN_VS_AI);
        // Set initial state for Opening Break Mode
        CheckRadioButton(hDlg, IDC_RADIO_CPU_BREAK, IDC_RADIO_FLIP_BREAK,
            (openingBreakMode == CPU_BREAK) ? IDC_RADIO_CPU_BREAK : ((openingBreakMode == P1_BREAK) ? IDC_RADIO_P1_BREAK : IDC_RADIO_FLIP_BREAK));
        // Enable/Disable Opening Break group based on initial mode
        EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), gameMode == HUMAN_VS_AI);
    }
    return (INT_PTR)TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_RADIO_2P:
        case IDC_RADIO_CPU:
        {
            bool isCPU = IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED;
            // Enable/Disable AI group controls based on selection
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), isCPU);
            // Also enable/disable Opening Break Mode group
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), isCPU);
        }
        return (INT_PTR)TRUE;

        case IDOK:
            // Retrieve selected options and store in global variables
            if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED) {
                gameMode = HUMAN_VS_AI;
                if (IsDlgButtonChecked(hDlg, IDC_RADIO_EASY) == BST_CHECKED) aiDifficulty = EASY;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_MEDIUM) == BST_CHECKED) aiDifficulty = MEDIUM;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_HARD) == BST_CHECKED) aiDifficulty = HARD;

                if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU_BREAK) == BST_CHECKED) openingBreakMode = CPU_BREAK;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_P1_BREAK) == BST_CHECKED) openingBreakMode = P1_BREAK;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_FLIP_BREAK) == BST_CHECKED) openingBreakMode = FLIP_COIN_BREAK;
            }
            else {
                gameMode = HUMAN_VS_HUMAN;
                // openingBreakMode doesn't apply to HvsH, can leave as is or reset
            }
            SaveSettings(); // Save settings when OK is pressed
            EndDialog(hDlg, IDOK); // Close dialog, return IDOK
            return (INT_PTR)TRUE;

        case IDCANCEL: // Handle Cancel or closing the dialog
            // Optionally, could reload settings here if you want cancel to revert to previously saved state
            EndDialog(hDlg, IDCANCEL);
            return (INT_PTR)TRUE;
        }
        break; // End WM_COMMAND
    }
    return (INT_PTR)FALSE; // Default processing
}

// --- NEW Helper to Show Dialog ---
void ShowNewGameDialog(HINSTANCE hInstance) {
    if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), hwndMain, NewGameDialogProc, 0) == IDOK) {
        // User clicked Start, reset game with new settings
        isPlayer2AI = (gameMode == HUMAN_VS_AI); // Update AI flag
        if (isPlayer2AI) {
            switch (aiDifficulty) {
            case EASY: player2Info.name = L""CPU (Easy)""; break;
            case MEDIUM: player2Info.name = L""CPU (Medium)""; break;
            case HARD: player2Info.name = L""CPU (Hard)""; break;
            }
        }
        else {
            player2Info.name = L""Player 2"";
        }
        // Update window title
        std::wstring windowTitle = L""Direct2D 8-Ball Pool"";
        if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
        else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";
        SetWindowText(hwndMain, windowTitle.c_str());

        InitGame(); // Re-initialize game logic & board
        InvalidateRect(hwndMain, NULL, TRUE); // Force redraw
    }
    else {
        // User cancelled dialog - maybe just resume game? Or exit?
        // For simplicity, we do nothing, game continues as it was.
        // To exit on cancel from F2, would need more complex state management.
    }
}

// --- NEW Reset Game Function ---
void ResetGame(HINSTANCE hInstance) {
    // Call the helper function to show the dialog and re-init if OK clicked
    ShowNewGameDialog(hInstance);
}

// --- WinMain ---
int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR, int nCmdShow) {
    if (FAILED(CoInitialize(NULL))) {
        MessageBox(NULL, L""COM Initialization Failed."", L""Error"", MB_OK | MB_ICONERROR);
        return -1;
    }

    // --- NEW: Load settings at startup ---
    LoadSettings();

    // --- NEW: Show configuration dialog FIRST ---
    if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), NULL, NewGameDialogProc, 0) != IDOK) {
        // User cancelled the dialog
        CoUninitialize();
        return 0; // Exit gracefully if dialog cancelled
    }
    // Global gameMode and aiDifficulty are now set by the DialogProc

    // Set AI flag based on game mode
    isPlayer2AI = (gameMode == HUMAN_VS_AI);
    if (isPlayer2AI) {
        switch (aiDifficulty) {
        case EASY: player2Info.name = L""CPU (Easy)""; break;
        case MEDIUM: player2Info.name = L""CPU (Medium)""; break;
        case HARD: player2Info.name = L""CPU (Hard)""; break;
        }
    }
    else {
        player2Info.name = L""Player 2"";
    }
    // --- End of Dialog Logic ---


    WNDCLASS wc = { };
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = L""Direct2D_8BallPool"";
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1)); // Use your actual icon ID here

    if (!RegisterClass(&wc)) {
        MessageBox(NULL, L""Window Registration Failed."", L""Error"", MB_OK | MB_ICONERROR);
        CoUninitialize();
        return -1;
    }

    // --- ACTION 4: Calculate Centered Window Position ---
    const int WINDOW_WIDTH = 1000; // Define desired width
    const int WINDOW_HEIGHT = 700; // Define desired height
    int screenWidth = GetSystemMetrics(SM_CXSCREEN);
    int screenHeight = GetSystemMetrics(SM_CYSCREEN);
    int windowX = (screenWidth - WINDOW_WIDTH) / 2;
    int windowY = (screenHeight - WINDOW_HEIGHT) / 2;

    // --- Change Window Title based on mode ---
    std::wstring windowTitle = L""Direct2D 8-Ball Pool"";
    if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
    else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";

    DWORD dwStyle = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX; // No WS_THICKFRAME, No WS_MAXIMIZEBOX

    hwndMain = CreateWindowEx(
        0, L""Direct2D_8BallPool"", windowTitle.c_str(), dwStyle,
        windowX, windowY, WINDOW_WIDTH, WINDOW_HEIGHT,
        NULL, NULL, hInstance, NULL
    );

    if (!hwndMain) {
        MessageBox(NULL, L""Window Creation Failed."", L""Error"", MB_OK | MB_ICONERROR);
        CoUninitialize();
        return -1;
    }

    // Initialize Direct2D Resources AFTER window creation
    if (FAILED(CreateDeviceResources())) {
        MessageBox(NULL, L""Failed to create Direct2D resources."", L""Error"", MB_OK | MB_ICONERROR);
        DestroyWindow(hwndMain);
        CoUninitialize();
        return -1;
    }

    InitGame(); // Initialize game state AFTER resources are ready & mode is set
    Sleep(500); // Allow window to fully initialize before starting the countdown //midi func
    StartMidi(hwndMain, TEXT(""BSQ.MID"")); // Replace with your MIDI filename
    //PlayGameMusic(hwndMain); //midi func

    ShowWindow(hwndMain, nCmdShow);
    UpdateWindow(hwndMain);

    if (!SetTimer(hwndMain, ID_TIMER, 1000 / TARGET_FPS, NULL)) {
        MessageBox(NULL, L""Could not SetTimer()."", L""Error"", MB_OK | MB_ICONERROR);
        DestroyWindow(hwndMain);
        CoUninitialize();
        return -1;
    }

    MSG msg = { };
    // --- Modified Main Loop ---
    // Handles the case where the game starts in SHOWING_DIALOG state (handled now before loop)
    // or gets reset to it via F2. The main loop runs normally once game starts.
    while (GetMessage(&msg, NULL, 0, 0)) {
        // We might need modeless dialog handling here if F2 shows dialog
        // while window is active, but DialogBoxParam is modal.
        // Let's assume F2 hides main window, shows dialog, then restarts game loop.
        // Simpler: F2 calls ResetGame which calls DialogBoxParam (modal) then InitGame.
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }


    KillTimer(hwndMain, ID_TIMER);
    DiscardDeviceResources();
    SaveSettings(); // Save settings on exit
    CoUninitialize();

    return (int)msg.wParam;
}

// --- WndProc ---
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    // Declare cueBall pointer once at the top, used in multiple cases
    // For clarity, often better to declare within each case where needed.
    Ball* cueBall = nullptr; // Initialize to nullptr
    switch (msg) {
    case WM_CREATE:
        // Resources are now created in WinMain after CreateWindowEx
        return 0;

    case WM_PAINT:
        OnPaint();
        // Validate the entire window region after painting
        ValidateRect(hwnd, NULL);
        return 0;

    case WM_SIZE: {
        UINT width = LOWORD(lParam);
        UINT height = HIWORD(lParam);
        OnResize(width, height);
        return 0;
    }

    case WM_TIMER:
        if (wParam == ID_TIMER) {
            GameUpdate(); // Update game logic and physics
            InvalidateRect(hwnd, NULL, FALSE); // Request redraw
        }
        return 0;

        // --- NEW: Handle F2 Key for Reset ---
        // --- MODIFIED: Handle More Keys ---
    case WM_KEYDOWN:
    { // Add scope for variable declarations

        // --- FIX: Get Cue Ball pointer for this scope ---
        cueBall = GetCueBall();
        // We might allow some keys even if cue ball is gone (like F1/F2), but actions need it
        // --- End Fix ---

        // Check which player can interact via keyboard (Humans only)
        bool canPlayerControl = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P1 || currentGameState == PRE_BREAK_PLACEMENT)) ||
            (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT)));

        // --- F1 / F2 Keys (Always available) ---
        if (wParam == VK_F2) {
            HINSTANCE hInstance = (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE);
            ResetGame(hInstance); // Call reset function
            return 0; // Indicate key was processed
        }
        else if (wParam == VK_F1) {
            MessageBox(hwnd,
                L""Direct2D-based StickPool game made in C++ from scratch (2764+ lines of code)\n"" // Update line count if needed
                L""First successful Clone in C++ (no other sites or projects were there to glean from.) Made /w AI assist\n""
                L""(others were in JS/ non-8-Ball in C# etc.) w/o OOP and Graphics Frameworks all in a Single file.\n""
                L""Copyright (C) 2025 Evans Thorpemorton, Entisoft Solutions.\n""
                L""Includes AI Difficulty Modes, Aim-Trajectory For Table Rails + Hard Angles TipShots. || F2=New Game"",
                L""About This Game"", MB_OK | MB_ICONINFORMATION);
            return 0; // Indicate key was processed
        }

        // Check for 'M' key (uppercase or lowercase)
            // Toggle music with ""M""
        if (wParam == 'M' || wParam == 'm') {
            //static bool isMusicPlaying = false;
            if (isMusicPlaying) {
                // Stop the music
                StopMidi();
                isMusicPlaying = false;
            }
            else {
                // Build the MIDI file path
                TCHAR midiPath[MAX_PATH];
                GetModuleFileName(NULL, midiPath, MAX_PATH);
                // Keep only the directory part
                TCHAR* lastBackslash = _tcsrchr(midiPath, '\\');
                if (lastBackslash != NULL) {
                    *(lastBackslash + 1) = '\0';
                }
                // Append the MIDI filename
                _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID"")); // Adjust filename if needed

                // Start playing MIDI
                StartMidi(hwndMain, midiPath);
                isMusicPlaying = true;
            }
        }


        // --- Player Interaction Keys (Only if allowed) ---
        if (canPlayerControl) {
            // --- Get Shift Key State ---
            bool shiftPressed = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
            float angleStep = shiftPressed ? 0.05f : 0.01f; // Base step / Faster step (Adjust as needed) // Multiplier was 5x
            float powerStep = 0.2f; // Power step (Adjust as needed)

            switch (wParam) {
            case VK_LEFT: // Rotate Cue Stick Counter-Clockwise
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    cueAngle -= angleStep;
                    // Normalize angle (keep between 0 and 2*PI)
                    if (cueAngle < 0) cueAngle += 2 * PI;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = false; // Keyboard adjust doesn't use mouse aiming state
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_RIGHT: // Rotate Cue Stick Clockwise
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    cueAngle += angleStep;
                    // Normalize angle (keep between 0 and 2*PI)
                    if (cueAngle >= 2 * PI) cueAngle -= 2 * PI;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = false;
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_UP: // Decrease Shot Power
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    shotPower -= powerStep;
                    if (shotPower < 0.0f) shotPower = 0.0f;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = true; // Keyboard adjust doesn't use mouse aiming state
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_DOWN: // Increase Shot Power
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    shotPower += powerStep;
                    if (shotPower > MAX_SHOT_POWER) shotPower = MAX_SHOT_POWER;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = true;
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_SPACE: // Trigger Shot
                if ((currentGameState == AIMING || currentGameState == BREAKING || currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN)
                    && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING)
                {
                    if (shotPower > 0.15f) { // Use same threshold as mouse
                       // Reset foul flags BEFORE applying shot
                        firstHitBallIdThisShot = -1;
                        cueHitObjectBallThisShot = false;
                        railHitAfterContact = false;

                        // Play sound & Apply Shot
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                        ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);

                        // Update State
                        currentGameState = SHOT_IN_PROGRESS;
                        foulCommitted = false;
                        pocketedThisTurn.clear();
                        shotPower = 0; // Reset power after shooting
                        isAiming = false; isDraggingStick = false; // Reset aiming flags
                        keyboardAimingActive = false;
                    }
                }
                break;

            case VK_ESCAPE: // Cancel Aim/Shot Setup
                if ((currentGameState == AIMING || currentGameState == BREAKING) || shotPower > 0)
                {
                    shotPower = 0.0f;
                    isAiming = false;
                    isDraggingStick = false;
                    keyboardAimingActive = false;
                    // Revert to basic turn state if not breaking
                    if (currentGameState != BREAKING) {
                        currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                    }
                }
                break;

            case 'G': // Toggle Cheat Mode
                cheatModeEnabled = !cheatModeEnabled;
                if (cheatModeEnabled)
                    MessageBeep(MB_ICONEXCLAMATION); // Play a beep when enabling
                else
                    MessageBeep(MB_OK); // Play a different beep when disabling
                break;

            default:
                // Allow default processing for other keys if needed
                // return DefWindowProc(hwnd, msg, wParam, lParam); // Usually not needed for WM_KEYDOWN
                break;
            } // End switch(wParam) for player controls
            return 0; // Indicate player control key was processed
        } // End if(canPlayerControl)
    } // End scope for WM_KEYDOWN case
    // If key wasn't F1/F2 and player couldn't control, maybe allow default processing?
    // return DefWindowProc(hwnd, msg, wParam, lParam); // Or just return 0
    return 0;

    case WM_MOUSEMOVE: {
        ptMouse.x = LOWORD(lParam);
        ptMouse.y = HIWORD(lParam);

        // --- NEW LOGIC: Handle Pocket Hover ---
        if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
            (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {
            int oldHover = currentlyHoveredPocket;
            currentlyHoveredPocket = -1; // Reset
            for (int i = 0; i < 6; ++i) {
                if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                    currentlyHoveredPocket = i;
                    break;
                }
            }
            if (oldHover != currentlyHoveredPocket) {
                InvalidateRect(hwnd, NULL, FALSE);
            }
            // Do NOT return 0 here, allow normal mouse angle update to continue
        }
        // --- END NEW LOGIC ---


        cueBall = GetCueBall(); // Declare and get cueBall pointer

        if (isDraggingCueBall && cheatModeEnabled && draggingBallId != -1) {
            Ball* ball = GetBallById(draggingBallId);
            if (ball) {
                ball->x = (float)ptMouse.x;
                ball->y = (float)ptMouse.y;
                ball->vx = ball->vy = 0.0f;
            }
            return 0;
        }

        if (!cueBall) return 0;

        // Update Aiming Logic (Check player turn)
        if (isDraggingCueBall &&
            ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                (!isPlayer2AI && currentPlayer == 2 && currentGameState == BALL_IN_HAND_P2) ||
                currentGameState == PRE_BREAK_PLACEMENT))
        {
            bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
            // Tentative position update
            cueBall->x = (float)ptMouse.x;
            cueBall->y = (float)ptMouse.y;
            cueBall->vx = cueBall->vy = 0;
        }
        else if ((isAiming || isDraggingStick) &&
            ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
        {
            //NEW2 MOUSEBOUND CODE = START
                /*// Clamp mouse inside table bounds during aiming
                if (ptMouse.x < TABLE_LEFT) ptMouse.x = TABLE_LEFT;
            if (ptMouse.x > TABLE_RIGHT) ptMouse.x = TABLE_RIGHT;
            if (ptMouse.y < TABLE_TOP) ptMouse.y = TABLE_TOP;
            if (ptMouse.y > TABLE_BOTTOM) ptMouse.y = TABLE_BOTTOM;*/
            //NEW2 MOUSEBOUND CODE = END
            // Aiming drag updates angle and power
            float dx = (float)ptMouse.x - cueBall->x;
            float dy = (float)ptMouse.y - cueBall->y;
            if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
            //float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
            //shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
            if (!keyboardAimingActive) { // Only update shotPower if NOT keyboard aiming
                float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
                shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
            }
        }
        else if (isSettingEnglish &&
            ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING)) ||
                (!isPlayer2AI && currentPlayer == 2 && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING))))
        {
            // Setting English
            float dx = (float)ptMouse.x - spinIndicatorCenter.x;
            float dy = (float)ptMouse.y - spinIndicatorCenter.y;
            float dist = GetDistance(dx, dy, 0, 0);
            if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
            cueSpinX = dx / spinIndicatorRadius;
            cueSpinY = dy / spinIndicatorRadius;
        }
        else {
            //DISABLE PERM AIMING = START
            /*// Update visual angle even when not aiming/dragging (Check player turn)
            bool canUpdateVisualAngle = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BALL_IN_HAND_P1)) ||
                (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BALL_IN_HAND_P2)) ||
                currentGameState == PRE_BREAK_PLACEMENT || currentGameState == BREAKING || currentGameState == AIMING);

            if (canUpdateVisualAngle && !isDraggingCueBall && !isAiming && !isDraggingStick && !keyboardAimingActive) // NEW: Prevent mouse override if keyboard aiming
            {
                // NEW MOUSEBOUND CODE = START
                    // Only update cue angle if mouse is inside the playable table area
                if (ptMouse.x >= TABLE_LEFT && ptMouse.x <= TABLE_RIGHT &&
                    ptMouse.y >= TABLE_TOP && ptMouse.y <= TABLE_BOTTOM)
                {
                    // NEW MOUSEBOUND CODE = END
                    Ball* cb = cueBall; // Use function-scope cueBall // Already got cueBall above
                    if (cb) {
                        float dx = (float)ptMouse.x - cb->x;
                        float dy = (float)ptMouse.y - cb->y;
                        if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                    }
                } //NEW MOUSEBOUND CODE LINE = DISABLE
            }*/
            //DISABLE PERM AIMING = END
        }
        return 0;
    } // End WM_MOUSEMOVE

    case WM_LBUTTONDOWN: {
        ptMouse.x = LOWORD(lParam);
        ptMouse.y = HIWORD(lParam);

        // --- NEW LOGIC: Handle Pocket Selection First ---
        if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
            (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

            int clickedPocketIndex = -1;
            for (int i = 0; i < 6; ++i) {
                if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                    clickedPocketIndex = i;
                    break;
                }
            }

            if (clickedPocketIndex != -1) { // Player clicked on a pocket
                // FIX: Update the called pocket, but DO NOT change the game state.
                // This allows the player to click another pocket to change their mind.
                if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                else calledPocketP2 = clickedPocketIndex;
                InvalidateRect(hwnd, NULL, FALSE); // Redraw to show updated arrow
                return 0; // Consume the click and stay in CHOOSING_POCKET state
            }

            // FIX: Add new logic to CONFIRM the choice by clicking the cue ball.
            Ball* cueBall = GetCueBall();
            int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
            if (cueBall && calledPocket != -1 && GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y) < BALL_RADIUS * BALL_RADIUS * 25) {
                // A pocket has been selected, and the player now clicks the cue ball.
                // NOW we transition to the normal aiming state.
                currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                pocketCallMessage = L""""; // Clear the ""Choose a pocket..."" message
                isAiming = true; // Prepare for aiming
                aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y); // Use your existing aim start variable
                return 0;
            }

            // If they click anywhere else (not a pocket, not the cue ball), do nothing.
            return 0;
        }
        // --- END NEW LOGIC ---


        if (cheatModeEnabled) {
            // Allow dragging any ball freely
            for (Ball& ball : balls) {
                float distSq = GetDistanceSq(ball.x, ball.y, (float)ptMouse.x, (float)ptMouse.y);
                if (distSq <= BALL_RADIUS * BALL_RADIUS * 4) { // Click near ball
                    isDraggingCueBall = true;
                    draggingBallId = ball.id;
                    if (ball.id == 0) {
                        // If dragging cue ball manually, ensure we stay in Ball-In-Hand state
                        if (currentPlayer == 1)
                            currentGameState = BALL_IN_HAND_P1;
                        else if (currentPlayer == 2 && !isPlayer2AI)
                            currentGameState = BALL_IN_HAND_P2;
                    }
                    return 0;
                }
            }
        }

        Ball* cueBall = GetCueBall(); // Declare and get cueBall pointer            

        // Check which player is allowed to interact via mouse click
        bool canPlayerClickInteract = ((currentPlayer == 1) || (currentPlayer == 2 && !isPlayer2AI));
        // Define states where interaction is generally allowed
        bool canInteractState = (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
            currentGameState == AIMING || currentGameState == BREAKING ||
            currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 ||
            currentGameState == PRE_BREAK_PLACEMENT);

        // Check Spin Indicator first (Allow if player's turn/aim phase)
        if (canPlayerClickInteract && canInteractState) {
            float spinDistSq = GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, spinIndicatorCenter.x, spinIndicatorCenter.y);
            if (spinDistSq < spinIndicatorRadius * spinIndicatorRadius * 1.2f) {
                isSettingEnglish = true;
                float dx = (float)ptMouse.x - spinIndicatorCenter.x;
                float dy = (float)ptMouse.y - spinIndicatorCenter.y;
                float dist = GetDistance(dx, dy, 0, 0);
                if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
                cueSpinX = dx / spinIndicatorRadius;
                cueSpinY = dy / spinIndicatorRadius;
                isAiming = false; isDraggingStick = false; isDraggingCueBall = false;
                return 0;
            }
        }

        if (!cueBall) return 0;

        // Check Ball-in-Hand placement/drag
        bool isPlacingBall = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
        bool isPlayerAllowedToPlace = (isPlacingBall &&
            ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                (currentGameState == PRE_BREAK_PLACEMENT))); // Allow current player in break setup

        if (isPlayerAllowedToPlace) {
            float distSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
            if (distSq < BALL_RADIUS * BALL_RADIUS * 9.0f) {
                isDraggingCueBall = true;
                isAiming = false; isDraggingStick = false;
            }
            else {
                bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                if (IsValidCueBallPosition((float)ptMouse.x, (float)ptMouse.y, behindHeadstring)) {
                    cueBall->x = (float)ptMouse.x; cueBall->y = (float)ptMouse.y;
                    cueBall->vx = 0; cueBall->vy = 0;
                    isDraggingCueBall = false;
                    // Transition state
                    if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                    else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                    else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                    cueAngle = 0.0f;
                }
            }
            return 0;
        }

        // Check for starting Aim (Cue Ball OR Stick)
        bool canAim = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BREAKING)) ||
            (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BREAKING)));

        if (canAim) {
            const float stickDrawLength = 150.0f * 1.4f;
            float currentStickAngle = cueAngle + PI;
            D2D1_POINT_2F currentStickEnd = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * stickDrawLength, cueBall->y + sinf(currentStickAngle) * stickDrawLength);
            D2D1_POINT_2F currentStickTip = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * 5.0f, cueBall->y + sinf(currentStickAngle) * 5.0f);
            float distToStickSq = PointToLineSegmentDistanceSq(D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y), currentStickTip, currentStickEnd);
            float stickClickThresholdSq = 36.0f;
            float distToCueBallSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
            float cueBallClickRadiusSq = BALL_RADIUS * BALL_RADIUS * 25;

            bool clickedStick = (distToStickSq < stickClickThresholdSq);
            bool clickedCueArea = (distToCueBallSq < cueBallClickRadiusSq);

            if (clickedStick || clickedCueArea) {
                isDraggingStick = clickedStick && !clickedCueArea;
                isAiming = clickedCueArea;
                aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
                shotPower = 0;
                float dx = (float)ptMouse.x - cueBall->x;
                float dy = (float)ptMouse.y - cueBall->y;
                if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                if (currentGameState != BREAKING) currentGameState = AIMING;
            }
        }
        return 0;
    } // End WM_LBUTTONDOWN


    case WM_LBUTTONUP: {
        if (cheatModeEnabled && draggingBallId != -1) {
            Ball* b = GetBallById(draggingBallId);
            if (b) {
                for (int p = 0; p < 6; ++p) {
                    float dx = b->x - pocketPositions[p].x;
                    float dy = b->y - pocketPositions[p].y;
                    if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                        // --- Assign ball type on first cheat-pocket if table still open ---
                        if (player1Info.assignedType == BallType::NONE
                            && player2Info.assignedType == BallType::NONE
                            && (b->type == BallType::SOLID || b->type == BallType::STRIPE))
                        {
                            AssignPlayerBallTypes(b->type);
                        }
                        b->isPocketed = true;
                        pocketedThisTurn.push_back(b->id);
                        // Immediately increment that player's count (skip cue/8)
                        if (b->id != 0 && b->id != 8) {
                            if (currentPlayer == 1)
                                player1Info.ballsPocketedCount++;
                            else
                                player2Info.ballsPocketedCount++;
                        }
                        break;
                    }
                }
            }
        }

        ptMouse.x = LOWORD(lParam);
        ptMouse.y = HIWORD(lParam);

        Ball* cueBall = GetCueBall(); // Get cueBall pointer

        // Check for releasing aim drag (Stick OR Cue Ball)
        if ((isAiming || isDraggingStick) &&
            ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
        {
            bool wasAiming = isAiming;
            bool wasDraggingStick = isDraggingStick;
            isAiming = false; isDraggingStick = false;

            if (shotPower > 0.15f) { // Check power threshold
                if (currentGameState != AI_THINKING) {
                    firstHitBallIdThisShot = -1; cueHitObjectBallThisShot = false; railHitAfterContact = false; // Reset foul flags
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                    ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);
                    currentGameState = SHOT_IN_PROGRESS;
                    foulCommitted = false; pocketedThisTurn.clear();
                }
            }
            else if (currentGameState != AI_THINKING) { // Revert state if power too low
                if (currentGameState == BREAKING) { /* Still breaking */ }
                else {
                    currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                    if (currentPlayer == 2 && isPlayer2AI) aiTurnPending = false;
                }
            }
            shotPower = 0; // Reset power indicator regardless
        }

        // Handle releasing cue ball drag (placement)
        if (isDraggingCueBall) {
            isDraggingCueBall = false;
            // Check player allowed to place
            bool isPlacingState = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
            bool isPlayerAllowed = (isPlacingState &&
                ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                    (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                    (currentGameState == PRE_BREAK_PLACEMENT)));

            if (isPlayerAllowed && cueBall) {
                bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                if (IsValidCueBallPosition(cueBall->x, cueBall->y, behindHeadstring)) {
                    // Finalize position already set by mouse move
                    // Transition state
                    if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                    else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                    else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                    cueAngle = 0.0f;
                }
                else { /* Stay in BALL_IN_HAND state if final pos invalid */ }
            }
        }

        // Handle releasing english setting
        if (isSettingEnglish) {
            isSettingEnglish = false;
        }
        return 0;
    } // End WM_LBUTTONUP

    case WM_DESTROY:
        isMusicPlaying = false;
        if (midiDeviceID != 0) {
            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
            SaveSettings(); // Save settings on exit
        }
        PostQuitMessage(0);
        return 0;

    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

// --- Direct2D Resource Management ---

HRESULT CreateDeviceResources() {
    HRESULT hr = S_OK;

    // Create Direct2D Factory
    if (!pFactory) {
        hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &pFactory);
        if (FAILED(hr)) return hr;
    }

    // Create DirectWrite Factory
    if (!pDWriteFactory) {
        hr = DWriteCreateFactory(
            DWRITE_FACTORY_TYPE_SHARED,
            __uuidof(IDWriteFactory),
            reinterpret_cast<IUnknown**>(&pDWriteFactory)
        );
        if (FAILED(hr)) return hr;
    }

    // Create Text Formats
    if (!pTextFormat && pDWriteFactory) {
        hr = pDWriteFactory->CreateTextFormat(
            L""Segoe UI"", NULL, DWRITE_FONT_WEIGHT_NORMAL, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
            16.0f, L""en-us"", &pTextFormat
        );
        if (FAILED(hr)) return hr;
        // Center align text
        pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
        pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
    }
    if (!pLargeTextFormat && pDWriteFactory) {
        hr = pDWriteFactory->CreateTextFormat(
            L""Impact"", NULL, DWRITE_FONT_WEIGHT_BOLD, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
            48.0f, L""en-us"", &pLargeTextFormat
        );
        if (FAILED(hr)) return hr;
        pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING); // Align left
        pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
    }


    // Create Render Target (needs valid hwnd)
    if (!pRenderTarget && hwndMain) {
        RECT rc;
        GetClientRect(hwndMain, &rc);
        D2D1_SIZE_U size = D2D1::SizeU(rc.right - rc.left, rc.bottom - rc.top);

        hr = pFactory->CreateHwndRenderTarget(
            D2D1::RenderTargetProperties(),
            D2D1::HwndRenderTargetProperties(hwndMain, size),
            &pRenderTarget
        );
        if (FAILED(hr)) {
            // If failed, release factories if they were created in this call
            SafeRelease(&pTextFormat);
            SafeRelease(&pLargeTextFormat);
            SafeRelease(&pDWriteFactory);
            SafeRelease(&pFactory);
            pRenderTarget = nullptr; // Ensure it's null on failure
            return hr;
        }
    }

    return hr;
}

void DiscardDeviceResources() {
    SafeRelease(&pRenderTarget);
    SafeRelease(&pTextFormat);
    SafeRelease(&pLargeTextFormat);
    SafeRelease(&pDWriteFactory);
    // Keep pFactory until application exit? Or release here too? Let's release.
    SafeRelease(&pFactory);
}

void OnResize(UINT width, UINT height) {
    if (pRenderTarget) {
        D2D1_SIZE_U size = D2D1::SizeU(width, height);
        pRenderTarget->Resize(size); // Ignore HRESULT for simplicity here
    }
}

// --- Game Initialization ---
void InitGame() {
    srand((unsigned int)time(NULL)); // Seed random number generator
    isOpeningBreakShot = true; // This is the start of a new game, so the next shot is an opening break.
    aiPlannedShotDetails.isValid = false; // Reset AI planned shot
    aiIsDisplayingAim = false;
    aiAimDisplayFramesLeft = 0;
    // ... (rest of InitGame())

    // --- Ensure pocketed list is clear from the absolute start ---
    pocketedThisTurn.clear();

    balls.clear(); // Clear existing balls

    // Reset Player Info (Names should be set by Dialog/wWinMain/ResetGame)
    player1Info.assignedType = BallType::NONE;
    player1Info.ballsPocketedCount = 0;
    // Player 1 Name usually remains ""Player 1""
    player2Info.assignedType = BallType::NONE;
    player2Info.ballsPocketedCount = 0;
    // Player 2 Name is set based on gameMode in ShowNewGameDialog

    // Create Cue Ball (ID 0)
    // Initial position will be set during PRE_BREAK_PLACEMENT state
    balls.push_back({ 0, BallType::CUE_BALL, TABLE_LEFT + TABLE_WIDTH * 0.15f, RACK_POS_Y, 0, 0, CUE_BALL_COLOR, false });

    // --- Create Object Balls (Temporary List) ---
    std::vector<Ball> objectBalls;
    // Solids (1-7, Yellow)
    for (int i = 1; i <= 7; ++i) {
        objectBalls.push_back({ i, BallType::SOLID, 0, 0, 0, 0, SOLID_COLOR, false });
    }
    // Stripes (9-15, Red)
    for (int i = 9; i <= 15; ++i) {
        objectBalls.push_back({ i, BallType::STRIPE, 0, 0, 0, 0, STRIPE_COLOR, false });
    }
    // 8-Ball (ID 8) - Add it to the list to be placed
    objectBalls.push_back({ 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false });


    // --- Racking Logic (Improved) ---
    float spacingX = BALL_RADIUS * 2.0f * 0.866f; // cos(30) for horizontal spacing
    float spacingY = BALL_RADIUS * 2.0f * 1.0f;   // Vertical spacing

    // Define rack positions (0-14 indices corresponding to triangle spots)
    D2D1_POINT_2F rackPositions[15];
    int rackIndex = 0;
    for (int row = 0; row < 5; ++row) {
        for (int col = 0; col <= row; ++col) {
            if (rackIndex >= 15) break;
            float x = RACK_POS_X + row * spacingX;
            float y = RACK_POS_Y + (col - row / 2.0f) * spacingY;
            rackPositions[rackIndex++] = D2D1::Point2F(x, y);
        }
    }

    // Separate 8-ball
    Ball eightBall;
    std::vector<Ball> otherBalls; // Solids and Stripes
    bool eightBallFound = false;
    for (const auto& ball : objectBalls) {
        if (ball.id == 8) {
            eightBall = ball;
            eightBallFound = true;
        }
        else {
            otherBalls.push_back(ball);
        }
    }
    // Ensure 8 ball was actually created (should always be true)
    if (!eightBallFound) {
        // Handle error - perhaps recreate it? For now, proceed.
        eightBall = { 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false };
    }


    // Shuffle the other 14 balls
    // Use std::shuffle if available (C++11 and later) for better randomness
    // std::random_device rd;
    // std::mt19937 g(rd());
    // std::shuffle(otherBalls.begin(), otherBalls.end(), g);
    std::random_shuffle(otherBalls.begin(), otherBalls.end()); // Using deprecated for now

    // --- Place balls into the main 'balls' vector in rack order ---
    // Important: Add the cue ball (already created) first.
    // (Cue ball added at the start of the function now)

    // 1. Place the 8-ball in its fixed position (index 4 for the 3rd row center)
    int eightBallRackIndex = 4;
    eightBall.x = rackPositions[eightBallRackIndex].x;
    eightBall.y = rackPositions[eightBallRackIndex].y;
    eightBall.vx = 0;
    eightBall.vy = 0;
    eightBall.isPocketed = false;
    balls.push_back(eightBall); // Add 8 ball to the main vector

    // 2. Place the shuffled Solids and Stripes in the remaining spots
    size_t otherBallIdx = 0;
    //int otherBallIdx = 0;
    for (int i = 0; i < 15; ++i) {
        if (i == eightBallRackIndex) continue; // Skip the 8-ball spot

        if (otherBallIdx < otherBalls.size()) {
            Ball& ballToPlace = otherBalls[otherBallIdx++];
            ballToPlace.x = rackPositions[i].x;
            ballToPlace.y = rackPositions[i].y;
            ballToPlace.vx = 0;
            ballToPlace.vy = 0;
            ballToPlace.isPocketed = false;
            balls.push_back(ballToPlace); // Add to the main game vector
        }
    }
    // --- End Racking Logic ---


    // --- Determine Who Breaks and Initial State ---
    if (isPlayer2AI) {
        /*// AI Mode: Randomly decide who breaks
        if ((rand() % 2) == 0) {
            // AI (Player 2) breaks
            currentPlayer = 2;
            currentGameState = PRE_BREAK_PLACEMENT; // AI needs to place ball first
            aiTurnPending = true; // Trigger AI logic
        }
        else {
            // Player 1 (Human) breaks
            currentPlayer = 1;
            currentGameState = PRE_BREAK_PLACEMENT; // Human places cue ball
            aiTurnPending = false;*/
        switch (openingBreakMode) {
        case CPU_BREAK:
            currentPlayer = 2; // AI breaks
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = true;
            break;
        case P1_BREAK:
            currentPlayer = 1; // Player 1 breaks
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = false;
            break;
        case FLIP_COIN_BREAK:
            if ((rand() % 2) == 0) { // 0 for AI, 1 for Player 1
                currentPlayer = 2; // AI breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = true;
            }
            else {
                currentPlayer = 1; // Player 1 breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = false;
            }
            break;
        default: // Fallback to CPU break
            currentPlayer = 2;
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = true;
            break;
        }
    }
    else {
        // Human vs Human, Player 1 always breaks (or could add a flip coin for HvsH too if desired)
        currentPlayer = 1;
        currentGameState = PRE_BREAK_PLACEMENT;
        aiTurnPending = false; // No AI involved
    }

    // Reset other relevant game state variables
    foulCommitted = false;
    gameOverMessage = L"""";
    firstBallPocketedAfterBreak = false;
    // pocketedThisTurn cleared at start
    // Reset shot parameters and input flags
    shotPower = 0.0f;
    cueSpinX = 0.0f;
    cueSpinY = 0.0f;
    isAiming = false;
    isDraggingCueBall = false;
    isSettingEnglish = false;
    cueAngle = 0.0f; // Reset aim angle
}


// --- Game Loop ---
void GameUpdate() {
    if (currentGameState == SHOT_IN_PROGRESS) {
        UpdatePhysics();
        CheckCollisions();

        if (AreBallsMoving()) {
            // When all balls stop, clear aiming flags
            isAiming = false;
            aiIsDisplayingAim = false;
            //ProcessShotResults();
        }

        bool pocketed = CheckPockets(); // Store if any ball was pocketed

        // --- Update pocket flash animation timer ---
        if (pocketFlashTimer > 0.0f) {
            pocketFlashTimer -= 0.02f;
            if (pocketFlashTimer < 0.0f) pocketFlashTimer = 0.0f;
        }

        if (!AreBallsMoving()) {
            ProcessShotResults(); // Determine next state based on what happened
        }
    }

    // --- Check if AI needs to act ---
    else if (isPlayer2AI && currentPlayer == 2 && !AreBallsMoving()) {
        if (aiIsDisplayingAim) { // AI has decided a shot and is displaying aim
            aiAimDisplayFramesLeft--;
            if (aiAimDisplayFramesLeft <= 0) {
                aiIsDisplayingAim = false; // Done displaying
                if (aiPlannedShotDetails.isValid) {
                    // Execute the planned shot
                    firstHitBallIdThisShot = -1;
                    cueHitObjectBallThisShot = false;
                    railHitAfterContact = false;
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                    ApplyShot(aiPlannedShotDetails.power, aiPlannedShotDetails.angle, aiPlannedShotDetails.spinX, aiPlannedShotDetails.spinY);
                    aiPlannedShotDetails.isValid = false; // Clear the planned shot
                }
                currentGameState = SHOT_IN_PROGRESS;
                foulCommitted = false;
                pocketedThisTurn.clear();
            }
            // Else, continue displaying aim
        }
        else if (aiTurnPending) { // AI needs to start its decision process
            // Valid states for AI to start thinking
            /*/if (currentGameState == PRE_BREAK_PLACEMENT && isOpeningBreakShot) {*/
            //newcode 1 commented out
            /*if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT && currentPlayer == 2 && isPlayer2AI) {
                // Handle the break shot
                AIBreakShot();
            }*/ //new code 1 end  
            /*else if (currentGameState == PRE_BREAK_PLACEMENT || currentGameState == BREAKING ||
                currentGameState == PLAYER2_TURN || currentGameState == BALL_IN_HAND_P2) {*/

                // aiTurnPending might be consumed by AIBreakShot or remain for next cycle if needed
        /* } //new code 2 commented out
        else if (currentGameState == BALL_IN_HAND_P2 && currentPlayer == 2 && isPlayer2AI) {
            AIPlaceCueBall(); // AI places the ball first
            // After placement, AI needs to decide its shot.
            // Transition to a state where AIMakeDecision will be called for shot selection.
            currentGameState = PLAYER2_TURN; // Or a specific AI_AIMING_AFTER_PLACEMENT state
                                             // aiTurnPending remains true to trigger AIMakeDecision next.
        }
        else if (currentGameState == PLAYER2_TURN && currentPlayer == 2 && isPlayer2AI) {
            // This is for a normal turn (not break, not immediately after ball-in-hand placement)

                currentGameState = AI_THINKING; // Set state to indicate AI is processing
                aiTurnPending = false;         // Consume the pending turn flag
                AIMakeDecision();              // For normal shots (non-break)
            }
            else {
                // Not a state where AI should act
                aiTurnPending = false;
            }*/
            // 2b) AI is ready to think (pending flag)
            // **1) Ball-in-Hand** let AI place the cue ball first
            if (currentGameState == BALL_IN_HAND_P2) {
                // Step 1: AI places the cue ball.
                AIPlaceCueBall();
                // Step 2: Transition to thinking state for shot decision.
                currentGameState = AI_THINKING; //newcode5
                // Step 3: Consume the pending flag for the placement phase.
                //         AIMakeDecision will handle shot planning now.
                aiTurnPending = false; //newcode5
                // Step 4: AI immediately decides the shot from the new position.
                AIMakeDecision(); //newcode5
            }
            // **2) Opening break** special break shot logic
            else if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
                AIBreakShot();
            }
            else if (currentGameState == PLAYER2_TURN || currentGameState == BREAKING) { //newcode5
                // General turn for AI to think (not ball-in-hand, not initial break placement)
                currentGameState = AI_THINKING; //newcode5
                aiTurnPending = false; // Consume the flag //newcode5
                AIMakeDecision(); //newcode5
            }
            // **3) Otherwise** normal shot planning
            /*else { //orig uncommented oldcode5
                currentGameState = AI_THINKING;
                aiTurnPending = false;
                AIMakeDecision();
            }*/
        }

        //} //bracefix
        // If current state is AI_THINKING but not displaying aim, then AI decision has already been made
    }
}

// --- Physics and Collision ---
void UpdatePhysics() {
    for (size_t i = 0; i < balls.size(); ++i) {
        Ball& b = balls[i];
        if (!b.isPocketed) {
            b.x += b.vx;
            b.y += b.vy;

            // Apply friction
            b.vx *= FRICTION;
            b.vy *= FRICTION;

            // Stop balls if velocity is very low
            if (GetDistanceSq(b.vx, b.vy, 0, 0) < MIN_VELOCITY_SQ) {
                b.vx = 0;
                b.vy = 0;
            }
        }
    }
}

void CheckCollisions() {
    float left = TABLE_LEFT;
    float right = TABLE_RIGHT;
    float top = TABLE_TOP;
    float bottom = TABLE_BOTTOM;
    const float pocketMouthCheckRadiusSq = (POCKET_RADIUS + BALL_RADIUS) * (POCKET_RADIUS + BALL_RADIUS) * 1.1f;

    // --- Reset Per-Frame Sound Flags ---
    bool playedWallSoundThisFrame = false;
    bool playedCollideSoundThisFrame = false;
    // ---

    for (size_t i = 0; i < balls.size(); ++i) {
        Ball& b1 = balls[i];
        if (b1.isPocketed) continue;

        bool nearPocket[6];
        for (int p = 0; p < 6; ++p) {
            nearPocket[p] = GetDistanceSq(b1.x, b1.y, pocketPositions[p].x, pocketPositions[p].y) < pocketMouthCheckRadiusSq;
        }
        bool nearTopLeftPocket = nearPocket[0];
        bool nearTopMidPocket = nearPocket[1];
        bool nearTopRightPocket = nearPocket[2];
        bool nearBottomLeftPocket = nearPocket[3];
        bool nearBottomMidPocket = nearPocket[4];
        bool nearBottomRightPocket = nearPocket[5];

        bool collidedWallThisBall = false;

        // --- Ball-Wall Collisions ---
        // (Check logic unchanged, added sound calls and railHitAfterContact update)
        // Left Wall
        if (b1.x - BALL_RADIUS < left) {
            if (!nearTopLeftPocket && !nearBottomLeftPocket) {
                b1.x = left + BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }
        // Right Wall
        if (b1.x + BALL_RADIUS > right) {
            if (!nearTopRightPocket && !nearBottomRightPocket) {
                b1.x = right - BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }
        // Top Wall
        if (b1.y - BALL_RADIUS < top) {
            if (!nearTopLeftPocket && !nearTopMidPocket && !nearTopRightPocket) {
                b1.y = top + BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }
        // Bottom Wall
        if (b1.y + BALL_RADIUS > bottom) {
            if (!nearBottomLeftPocket && !nearBottomMidPocket && !nearBottomRightPocket) {
                b1.y = bottom - BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }

        // Spin effect (Unchanged)
        if (collidedWallThisBall) {
            if (b1.x <= left + BALL_RADIUS || b1.x >= right - BALL_RADIUS) { b1.vy += cueSpinX * b1.vx * 0.05f; }
            if (b1.y <= top + BALL_RADIUS || b1.y >= bottom - BALL_RADIUS) { b1.vx -= cueSpinY * b1.vy * 0.05f; }
            cueSpinX *= 0.7f; cueSpinY *= 0.7f;
        }


        // --- Ball-Ball Collisions ---
        for (size_t j = i + 1; j < balls.size(); ++j) {
            Ball& b2 = balls[j];
            if (b2.isPocketed) continue;

            float dx = b2.x - b1.x; float dy = b2.y - b1.y;
            float distSq = dx * dx + dy * dy;
            float minDist = BALL_RADIUS * 2.0f;

            if (distSq > 1e-6 && distSq < minDist * minDist) {
                float dist = sqrtf(distSq);
                float overlap = minDist - dist;
                float nx = dx / dist; float ny = dy / dist;

                // Separation (Unchanged)
                b1.x -= overlap * 0.5f * nx; b1.y -= overlap * 0.5f * ny;
                b2.x += overlap * 0.5f * nx; b2.y += overlap * 0.5f * ny;

                float rvx = b1.vx - b2.vx; float rvy = b1.vy - b2.vy;
                float velAlongNormal = rvx * nx + rvy * ny;

                if (velAlongNormal > 0) { // Colliding
                    // --- Play Ball Collision Sound ---
                    if (!playedCollideSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""poolballhit.wav"")).detach();
                        playedCollideSoundThisFrame = true; // Set flag
                    }
                    // --- End Sound ---

                    // --- NEW: Track First Hit and Cue/Object Collision ---
                    if (firstHitBallIdThisShot == -1) { // If first hit hasn't been recorded yet
                        if (b1.id == 0) { // Cue ball hit b2 first
                            firstHitBallIdThisShot = b2.id;
                            cueHitObjectBallThisShot = true;
                        }
                        else if (b2.id == 0) { // Cue ball hit b1 first
                            firstHitBallIdThisShot = b1.id;
                            cueHitObjectBallThisShot = true;
                        }
                        // If neither is cue ball, doesn't count as first hit for foul purposes
                    }
                    else if (b1.id == 0 || b2.id == 0) {
                        // Track subsequent cue ball collisions with object balls
                        cueHitObjectBallThisShot = true;
                    }
                    // --- End First Hit Tracking ---


                    // Impulse (Unchanged)
                    float impulse = velAlongNormal;
                    b1.vx -= impulse * nx; b1.vy -= impulse * ny;
                    b2.vx += impulse * nx; b2.vy += impulse * ny;

                    // Spin Transfer (Unchanged)
                    if (b1.id == 0 || b2.id == 0) {
                        float spinEffectFactor = 0.08f;
                        b1.vx += (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                        b1.vy += (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                        b2.vx -= (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                        b2.vy -= (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                        cueSpinX *= 0.85f; cueSpinY *= 0.85f;
                    }
                }
            }
        } // End ball-ball loop
    } // End ball loop
} // End CheckCollisions


bool CheckPockets() {
    bool ballPocketedThisCheck = false; // Local flag for this specific check run
    for (size_t i = 0; i < balls.size(); ++i) {
        Ball& b = balls[i];
        if (!b.isPocketed) { // Only check balls that aren't already flagged as pocketed
            for (int p = 0; p < 6; ++p) {
                float distSq = GetDistanceSq(b.x, b.y, pocketPositions[p].x, pocketPositions[p].y);
                // --- Use updated POCKET_RADIUS ---
                if (distSq < POCKET_RADIUS * POCKET_RADIUS) {
                    b.isPocketed = true;
                    b.vx = b.vy = 0;
                    pocketedThisTurn.push_back(b.id);

                    // --- Play Pocket Sound (Threaded) ---
                    if (!ballPocketedThisCheck) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""pocket.wav"")).detach();
                        ballPocketedThisCheck = true;
                    }
                    // --- End Sound ---

                    break; // Ball is pocketed
                }
            }
        }
    }
    return ballPocketedThisCheck;
}

bool AreBallsMoving() {
    for (size_t i = 0; i < balls.size(); ++i) {
        if (!balls[i].isPocketed && (balls[i].vx != 0 || balls[i].vy != 0)) {
            return true;
        }
    }
    return false;
}

void RespawnCueBall(bool behindHeadstring) { // 'behindHeadstring' only relevant for initial break placement
    Ball* cueBall = GetCueBall();
    if (cueBall) {
        // Reset position to a default
        //disabled for behind headstring (now move anywhere)
        /*cueBall->x = HEADSTRING_X * 0.5f;
        cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;*/
        // Reset position to a default:
        if (behindHeadstring) {
            // Opening break: kitchen center
            cueBall->x = HEADSTRING_X * 0.5f;
            cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
        }
        else {
            // Ball-in-hand (foul): center of full table
            cueBall->x = TABLE_LEFT + TABLE_WIDTH / 2.0f;
            cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
        }
        cueBall->vx = 0;
        cueBall->vy = 0;
        cueBall->isPocketed = false;

        // Set state based on who gets ball-in-hand
        /*// 'currentPlayer' already reflects who's turn it is NOW (switched before calling this)*/
        // 'currentPlayer' has already been switched to the player whose turn it will be.
        // The 'behindHeadstring' parameter to RespawnCueBall is mostly for historical reasons / initial setup.
        if (currentPlayer == 1) { // Player 2 (AI/Human) fouled, Player 1 (Human) gets ball-in-hand
            currentGameState = BALL_IN_HAND_P1;
            aiTurnPending = false; // Ensure AI flag off
        }
        else { // Player 1 (Human) fouled, Player 2 gets ball-in-hand
            if (isPlayer2AI) {
                // --- CONFIRMED FIX: Set correct state for AI Ball-in-Hand ---
                currentGameState = BALL_IN_HAND_P2; // AI now needs to place the ball
                aiTurnPending = true; // Trigger AI logic (will call AIPlaceCueBall first)
            }
            else { // Human Player 2
                currentGameState = BALL_IN_HAND_P2;
                aiTurnPending = false; // Ensure AI flag off
            }
        }
        // Handle initial placement state correctly if called from InitGame
        /*if (behindHeadstring && currentGameState != PRE_BREAK_PLACEMENT) {
            // This case might need review depending on exact initial setup flow,
            // but the foul logic above should now be correct.
            // Let's ensure initial state is PRE_BREAK_PLACEMENT if behindHeadstring is true.*/
            //currentGameState = PRE_BREAK_PLACEMENT;
    }
}
//}


// --- Game Logic ---

void ApplyShot(float power, float angle, float spinX, float spinY) {
    Ball* cueBall = GetCueBall();
    if (cueBall) {

        // --- Play Cue Strike Sound (Threaded) ---
        if (power > 0.1f) { // Only play if it's an audible shot
            std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
        }
        // --- End Sound ---

        cueBall->vx = cosf(angle) * power;
        cueBall->vy = sinf(angle) * power;

        // Apply English (Spin) - Simplified effect (Unchanged)
        cueBall->vx += sinf(angle) * spinY * 0.5f;
        cueBall->vy -= cosf(angle) * spinY * 0.5f;
        cueBall->vx -= cosf(angle) * spinX * 0.5f;
        cueBall->vy -= sinf(angle) * spinX * 0.5f;

        // Store spin (Unchanged)
        cueSpinX = spinX;
        cueSpinY = spinY;

        // --- Reset Foul Tracking flags for the new shot ---
        // (Also reset in LBUTTONUP, but good to ensure here too)
        firstHitBallIdThisShot = -1;      // No ball hit yet
        cueHitObjectBallThisShot = false; // Cue hasn't hit anything yet
        railHitAfterContact = false;     // No rail hit after contact yet
        // --- End Reset ---

                // If this was the opening break shot, clear the flag
        if (isOpeningBreakShot) {
            isOpeningBreakShot = false; // Mark opening break as taken
        }
    }
}


void ProcessShotResults() {
    bool cueBallPocketed = false;
    bool eightBallPocketed = false;
    bool playerContinuesTurn = false;

    // --- Preliminary Analysis & Score Update ---
    // First, update the counts to ensure all subsequent logic has the correct score.
    // This is the key fix for the off-by-one visual error.
    PlayerInfo& shootingPlayer = (currentPlayer == 1) ? player1Info : player2Info;
    int ownBallsPocketedThisTurn = 0;

    for (int id : pocketedThisTurn) {
        Ball* b = GetBallById(id);
        if (!b) continue;
        if (b->id == 0) cueBallPocketed = true;
        else if (b->id == 8) eightBallPocketed = true;
        else {
            if (b->type == player1Info.assignedType && player1Info.assignedType != BallType::NONE) player1Info.ballsPocketedCount++;
            else if (b->type == player2Info.assignedType && player2Info.assignedType != BallType::NONE) player2Info.ballsPocketedCount++;

            if (b->type == shootingPlayer.assignedType) {
                ownBallsPocketedThisTurn++;
            }
        }
    }

    if (ownBallsPocketedThisTurn > 0) {
        playerContinuesTurn = true;
    }

    // --- Step 1: Check for Game-Ending 8-Ball Shot ---
    if (eightBallPocketed) {
        CheckGameOverConditions(true, cueBallPocketed);
        if (currentGameState == GAME_OVER) { pocketedThisTurn.clear(); return; }
    }

    // --- Step 2: Check for Fouls ---
    // This logic is now more robust. A foul is only checked against the state of the game *before* the shot.
    // The fact that the player is NOW on the 8-ball doesn't make their previous legal shot a foul.
    bool turnFoul = false;
    Ball* firstHit = GetBallById(firstHitBallIdThisShot);

    if (cueBallPocketed) {
        turnFoul = true;
    }
    else if (!firstHit) {
        turnFoul = true; // Hit nothing.
    }
    else {
        // Check for illegal first hit based on the rules BEFORE this shot was taken.
        bool wasOnEightBall = (shootingPlayer.assignedType != BallType::NONE && (shootingPlayer.ballsPocketedCount - ownBallsPocketedThisTurn) >= 7);

        if (player1Info.assignedType != BallType::NONE) { // Colors are assigned
            if (wasOnEightBall) {
                if (firstHit->id != 8) turnFoul = true; // Was on 8-ball, but didn't hit it first.
            }
            else {
                if (firstHit->type != shootingPlayer.assignedType) turnFoul = true; // Wasn't on 8-ball, but hit wrong type.
            }
        }
    }

    if (!turnFoul && cueHitObjectBallThisShot && !railHitAfterContact && pocketedThisTurn.empty()) {
        turnFoul = true; // No rail after contact.
    }
    foulCommitted = turnFoul;

    // --- Step 3: Final State Transition ---
    if (foulCommitted) {
        SwitchTurns();
        RespawnCueBall(false);
    }
    else if (player1Info.assignedType == BallType::NONE && !pocketedThisTurn.empty() && !cueBallPocketed) {
        // Table is open, assign types.
        for (int id : pocketedThisTurn) {
            Ball* b = GetBallById(id);
            if (b && b->type != BallType::EIGHT_BALL) {
                AssignPlayerBallTypes(b->type);
                break;
            }
        }
        CheckAndTransitionToPocketChoice(currentPlayer); // Player continues turn
    }
    else if (playerContinuesTurn) {
        // Player legally pocketed a ball. Check if they are now on the 8-ball.
        CheckAndTransitionToPocketChoice(currentPlayer);
    }
    else {
        // No legal ball pocketed, no foul. Switch turns.
        SwitchTurns();
    }

    pocketedThisTurn.clear();
}

bool AssignPlayerBallTypes(BallType firstPocketedType) {
    if (firstPocketedType == BallType::SOLID || firstPocketedType == BallType::STRIPE) {
        if (currentPlayer == 1) {
            player1Info.assignedType = firstPocketedType;
            player2Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
        }
        else {
            player2Info.assignedType = firstPocketedType;
            player1Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
        }
        return true; // Assignment was successful
    }
    return false; // No assignment made (e.g., 8-ball was pocketed on break)
}
    // If 8-ball was first (illegal on break generally), rules vary.
    // Here, we might ignore assignment until a solid/stripe is pocketed legally.
    // Or assign based on what *else* was pocketed, if anything.
    // Simplification: Assignment only happens on SOLID or STRIPE first pocket.


void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed) {
    if (!eightBallPocketed) return;

    PlayerInfo& shootingPlayer = (currentPlayer == 1) ? player1Info : player2Info;
    PlayerInfo& opponentPlayer = (currentPlayer == 1) ? player2Info : player1Info;
    bool shooterWasOn8Ball = IsPlayerOnEightBall(currentPlayer);
    int pocketThe8BallEntered = -1;

    // Find which pocket the 8-ball actually went into
    Ball* b = GetBallById(8);
    if (b) {
        for (int p_idx = 0; p_idx < 6; ++p_idx) {
            if (GetDistanceSq(b->x, b->y, pocketPositions[p_idx].x, pocketPositions[p_idx].y) < POCKET_RADIUS * POCKET_RADIUS * 1.5f) {
                pocketThe8BallEntered = p_idx;
                break;
            }
        }
    }

    // Case 1: 8-ball pocketed on the break (or before colors assigned)
    if (player1Info.assignedType == BallType::NONE) {
        if (b) { // Re-spot the 8-ball
            b->isPocketed = false;
            b->x = RACK_POS_X;
            b->y = RACK_POS_Y;
            b->vx = b->vy = 0;
        }
        if (cueBallPocketed) {
            foulCommitted = true; // Let ProcessShotResults handle the foul, game doesn't end.
        }
        return; // Game continues
    }

    // Case 2: Normal gameplay win/loss conditions
    int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;

    if (!shooterWasOn8Ball) {
        // Loss: Pocketed 8-ball before clearing own group.
        gameOverMessage = opponentPlayer.name + L"" Wins! ("" + shootingPlayer.name + L"" pocketed 8-ball early)"";
    }
    else if (cueBallPocketed) {
        // Loss: Scratched while shooting for the 8-ball.
        gameOverMessage = opponentPlayer.name + L"" Wins! ("" + shootingPlayer.name + L"" scratched on 8-ball)"";
    }
    else if (calledPocket == -1) {
        // Loss: Pocketed 8-ball without calling a pocket. THIS IS THE KEY FIX FOR YOUR REPORTED PROBLEM.
        gameOverMessage = opponentPlayer.name + L"" Wins! ("" + shootingPlayer.name + L"" did not call a pocket)"";
    }
    else if (pocketThe8BallEntered != calledPocket) {
        // Loss: Pocketed 8-ball in the wrong pocket.
        gameOverMessage = opponentPlayer.name + L"" Wins! ("" + shootingPlayer.name + L"" 8-ball in wrong pocket)"";
    }
    else {
        // WIN! Pocketed 8-ball in the called pocket without a foul.
        gameOverMessage = shootingPlayer.name + L"" Wins!"";
    }

    currentGameState = GAME_OVER;
}


void SwitchTurns() {
    currentPlayer = (currentPlayer == 1) ? 2 : 1;
    isAiming = false;
    shotPower = 0;
    CheckAndTransitionToPocketChoice(currentPlayer); // Use the new helper
}

void AIBreakShot() {
    Ball* cueBall = GetCueBall();
    if (!cueBall) return;

    // This function is called when it's AI's turn for the opening break and state is PRE_BREAK_PLACEMENT.
    // AI will place the cue ball and then plan the shot.
    if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
        // Place cue ball in the kitchen randomly
        /*float kitchenMinX = TABLE_LEFT + BALL_RADIUS; // [cite: 1071, 1072, 1587]
        float kitchenMaxX = HEADSTRING_X - BALL_RADIUS; // [cite: 1072, 1078, 1588]
        float kitchenMinY = TABLE_TOP + BALL_RADIUS; // [cite: 1071, 1072, 1588]
        float kitchenMaxY = TABLE_BOTTOM - BALL_RADIUS; // [cite: 1072, 1073, 1589]*/

        // --- AI Places Cue Ball for Break ---
// Decide if placing center or side. For simplicity, let's try placing slightly off-center
// towards one side for a more angled break, or center for direct apex hit.
// A common strategy is to hit the second ball of the rack.

        float placementY = RACK_POS_Y; // Align vertically with the rack center
        float placementX;

        // Randomly choose a side or center-ish placement for variation.
        int placementChoice = rand() % 3; // 0: Left-ish, 1: Center-ish, 2: Right-ish in kitchen

        if (placementChoice == 0) { // Left-ish
            placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) - (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the left within kitchen
        }
        else if (placementChoice == 2) { // Right-ish
            placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) + (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the right within kitchen
        }
        else { // Center-ish
            placementX = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // Roughly center of kitchen
        }
        placementX = std::max(TABLE_LEFT + BALL_RADIUS + 1.0f, std::min(placementX, HEADSTRING_X - BALL_RADIUS - 1.0f)); // Clamp within kitchen X

        bool validPos = false;
        int attempts = 0;
        while (!validPos && attempts < 100) {
            /*cueBall->x = kitchenMinX + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxX - kitchenMinX)); // [cite: 1589]
            cueBall->y = kitchenMinY + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxY - kitchenMinY)); // [cite: 1590]
            if (IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1591]
                validPos = true; // [cite: 1591]*/
                // Try the chosen X, but vary Y slightly to find a clear spot
            cueBall->x = placementX;
            cueBall->y = placementY + (static_cast<float>(rand() % 100 - 50) / 100.0f) * BALL_RADIUS * 2.0f; // Vary Y a bit
            cueBall->y = std::max(TABLE_TOP + BALL_RADIUS + 1.0f, std::min(cueBall->y, TABLE_BOTTOM - BALL_RADIUS - 1.0f)); // Clamp Y

            if (IsValidCueBallPosition(cueBall->x, cueBall->y, true /* behind headstring */)) {
                validPos = true;
            }
            attempts++; // [cite: 1592]
        }
        if (!validPos) {
            // Fallback position
            /*cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // [cite: 1071, 1078, 1593]
            cueBall->y = (TABLE_TOP + TABLE_BOTTOM) * 0.5f; // [cite: 1071, 1073, 1594]
            if (!IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1594]
                cueBall->x = HEADSTRING_X - BALL_RADIUS * 2; // [cite: 1072, 1078, 1594]
                cueBall->y = RACK_POS_Y; // [cite: 1080, 1595]
            }
        }
        cueBall->vx = 0; // [cite: 1595]
        cueBall->vy = 0; // [cite: 1596]

        // Plan a break shot: aim at the center of the rack (apex ball)
        float targetX = RACK_POS_X; // [cite: 1079] Aim for the apex ball X-coordinate
        float targetY = RACK_POS_Y; // [cite: 1080] Aim for the apex ball Y-coordinate

        float dx = targetX - cueBall->x; // [cite: 1599]
        float dy = targetY - cueBall->y; // [cite: 1600]
        float shotAngle = atan2f(dy, dx); // [cite: 1600]
        float shotPowerValue = MAX_SHOT_POWER; // [cite: 1076, 1600] Use MAX_SHOT_POWER*/

            cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.75f; // A default safe spot in kitchen
            cueBall->y = RACK_POS_Y;
        }
        cueBall->vx = 0; cueBall->vy = 0;

        // --- AI Plans the Break Shot ---
        float targetX, targetY;
        // If cue ball is near center of kitchen width, aim for apex.
        // Otherwise, aim for the second ball on the side the cue ball is on (for a cut break).
        float kitchenCenterRegion = (HEADSTRING_X - TABLE_LEFT) * 0.3f; // Define a ""center"" region
        if (std::abs(cueBall->x - (TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) / 2.0f)) < kitchenCenterRegion / 2.0f) {
            // Center-ish placement: Aim for the apex ball (ball ID 1 or first ball in rack)
            targetX = RACK_POS_X; // Apex ball X
            targetY = RACK_POS_Y; // Apex ball Y
        }
        else {
            // Side placement: Aim to hit the ""second"" ball of the rack for a wider spread.
            // This is a simplification. A more robust way is to find the actual second ball.
            // For now, aim slightly off the apex towards the side the cue ball is on.
            targetX = RACK_POS_X + BALL_RADIUS * 2.0f * 0.866f; // X of the second row of balls
            targetY = RACK_POS_Y + ((cueBall->y > RACK_POS_Y) ? -BALL_RADIUS : BALL_RADIUS); // Aim at the upper or lower of the two second-row balls
        }

        float dx = targetX - cueBall->x;
        float dy = targetY - cueBall->y;
        float shotAngle = atan2f(dy, dx);
        float shotPowerValue = MAX_SHOT_POWER * (0.9f + (rand() % 11) / 100.0f); // Slightly vary max power

        // Store planned shot details for the AI
        /*aiPlannedShotDetails.angle = shotAngle; // [cite: 1102, 1601]
        aiPlannedShotDetails.power = shotPowerValue; // [cite: 1102, 1601]
        aiPlannedShotDetails.spinX = 0.0f; // [cite: 1102, 1601] No spin for a standard power break
        aiPlannedShotDetails.spinY = 0.0f; // [cite: 1103, 1602]
        aiPlannedShotDetails.isValid = true; // [cite: 1103, 1602]*/

        aiPlannedShotDetails.angle = shotAngle;
        aiPlannedShotDetails.power = shotPowerValue;
        aiPlannedShotDetails.spinX = 0.0f; // No spin for break usually
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true;

        // Update global cue parameters for immediate visual feedback if DrawAimingAids uses them
        /*::cueAngle = aiPlannedShotDetails.angle;      // [cite: 1109, 1603] Update global cueAngle
        ::shotPower = aiPlannedShotDetails.power;     // [cite: 1109, 1604] Update global shotPower
        ::cueSpinX = aiPlannedShotDetails.spinX;    // [cite: 1109]
        ::cueSpinY = aiPlannedShotDetails.spinY;    // [cite: 1110]*/

        ::cueAngle = aiPlannedShotDetails.angle;
        ::shotPower = aiPlannedShotDetails.power;
        ::cueSpinX = aiPlannedShotDetails.spinX;
        ::cueSpinY = aiPlannedShotDetails.spinY;

        // Set up for AI display via GameUpdate
        /*aiIsDisplayingAim = true;                   // [cite: 1104] Enable AI aiming visualization
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES; // [cite: 1105] Set duration for display

        currentGameState = AI_THINKING; // [cite: 1081] Transition to AI_THINKING state.
                                        // GameUpdate will handle the aiAimDisplayFramesLeft countdown
                                        // and then execute the shot using aiPlannedShotDetails.
                                        // isOpeningBreakShot will be set to false within ApplyShot.

        // No immediate ApplyShot or sound here; GameUpdate's AI execution logic will handle it.*/

        aiIsDisplayingAim = true;
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
        currentGameState = AI_THINKING; // State changes to AI_THINKING, GameUpdate will handle shot execution after display

        return; // The break shot is now planned and will be executed by GameUpdate
    }

    // 2. If not in PRE_BREAK_PLACEMENT (e.g., if this function were called at other times,
    //    though current game logic only calls it for PRE_BREAK_PLACEMENT)
    //    This part can be extended if AIBreakShot needs to handle other scenarios.
    //    For now, the primary logic is above.
}

// --- Helper Functions ---

Ball* GetBallById(int id) {
    for (size_t i = 0; i < balls.size(); ++i) {
        if (balls[i].id == id) {
            return &balls[i];
        }
    }
    return nullptr;
}

Ball* GetCueBall() {
    return GetBallById(0);
}

float GetDistance(float x1, float y1, float x2, float y2) {
    return sqrtf(GetDistanceSq(x1, y1, x2, y2));
}

float GetDistanceSq(float x1, float y1, float x2, float y2) {
    float dx = x2 - x1;
    float dy = y2 - y1;
    return dx * dx + dy * dy;
}

bool IsValidCueBallPosition(float x, float y, bool checkHeadstring) {
    // Basic bounds check (inside cushions)
    float left = TABLE_LEFT + CUSHION_THICKNESS + BALL_RADIUS;
    float right = TABLE_RIGHT - CUSHION_THICKNESS - BALL_RADIUS;
    float top = TABLE_TOP + CUSHION_THICKNESS + BALL_RADIUS;
    float bottom = TABLE_BOTTOM - CUSHION_THICKNESS - BALL_RADIUS;

    if (x < left || x > right || y < top || y > bottom) {
        return false;
    }

    // Check headstring restriction if needed
    if (checkHeadstring && x >= HEADSTRING_X) {
        return false;
    }

    // Check overlap with other balls
    for (size_t i = 0; i < balls.size(); ++i) {
        if (balls[i].id != 0 && !balls[i].isPocketed) { // Don't check against itself or pocketed balls
            if (GetDistanceSq(x, y, balls[i].x, balls[i].y) < (BALL_RADIUS * 2.0f) * (BALL_RADIUS * 2.0f)) {
                return false; // Overlapping another ball
            }
        }
    }

    return true;
}

// --- NEW HELPER FUNCTION IMPLEMENTATIONS ---

// Checks if a player has pocketed all their balls and is now on the 8-ball.
bool IsPlayerOnEightBall(int player) {
    PlayerInfo& playerInfo = (player == 1) ? player1Info : player2Info;
    if (playerInfo.assignedType != BallType::NONE && playerInfo.assignedType != BallType::EIGHT_BALL && playerInfo.ballsPocketedCount >= 7) {
        Ball* eightBall = GetBallById(8);
        return (eightBall && !eightBall->isPocketed);
    }
    return false;
}

// Centralized logic to enter the ""choosing pocket"" state. This fixes the indicator bugs.
void CheckAndTransitionToPocketChoice(int playerID) {
    bool needsToCall = IsPlayerOnEightBall(playerID);
    int* calledPocketForPlayer = (playerID == 1) ? &calledPocketP1 : &calledPocketP2;

    if (needsToCall && *calledPocketForPlayer == -1) { // Only transition if a pocket hasn't been called yet
        pocketCallMessage = ((playerID == 1) ? player1Info.name : player2Info.name) + L"": Choose a pocket..."";
        if (playerID == 1) {
            currentGameState = CHOOSING_POCKET_P1;
        }
        else { // Player 2
            if (isPlayer2AI) {
                currentGameState = AI_THINKING;
                aiTurnPending = true;
            }
            else {
                currentGameState = CHOOSING_POCKET_P2;
            }
        }
        if (!(playerID == 2 && isPlayer2AI)) {
            *calledPocketForPlayer = 5; // Default to top-right if none chosen
        }
    }
    else {
        // Player does not need to call a pocket (or already has), proceed to normal turn.
        pocketCallMessage = L""""; // Clear any message
        currentGameState = (playerID == 1) ? PLAYER1_TURN : PLAYER2_TURN;
        if (playerID == 2 && isPlayer2AI) {
            aiTurnPending = true;
        }
    }
}

template <typename T>
void SafeRelease(T** ppT) {
    if (*ppT) {
        (*ppT)->Release();
        *ppT = nullptr;
    }
}

// --- Helper Function for Line Segment Intersection ---
// Finds intersection point of line segment P1->P2 and line segment P3->P4
// Returns true if they intersect, false otherwise. Stores intersection point in 'intersection'.
bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection)
{
    float denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);

    // Check if lines are parallel or collinear
    if (fabs(denominator) < 1e-6) {
        return false;
    }

    float ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
    float ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;

    // Check if intersection point lies on both segments
    if (ua >= 0.0f && ua <= 1.0f && ub >= 0.0f && ub <= 1.0f) {
        intersection.x = p1.x + ua * (p2.x - p1.x);
        intersection.y = p1.y + ua * (p2.y - p1.y);
        return true;
    }

    return false;
}

// --- INSERT NEW HELPER FUNCTION HERE ---
// Calculates the squared distance from point P to the line segment AB.
float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b) {
    float l2 = GetDistanceSq(a.x, a.y, b.x, b.y);
    if (l2 == 0.0f) return GetDistanceSq(p.x, p.y, a.x, a.y); // Segment is a point
    // Consider P projecting onto the line AB infinite line
    // t = [(P-A) . (B-A)] / |B-A|^2
    float t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
    t = std::max(0.0f, std::min(1.0f, t)); // Clamp t to the segment [0, 1]
    // Projection falls on the segment
    D2D1_POINT_2F projection = D2D1::Point2F(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));
    return GetDistanceSq(p.x, p.y, projection.x, projection.y);
}
// --- End New Helper ---

// --- NEW AI Implementation Functions ---

// Main entry point for AI turn
void AIMakeDecision() {
    //AIShotInfo bestShot = { false }; // Declare here
    // This function is called when currentGameState is AI_THINKING (for a normal shot decision)
    Ball* cueBall = GetCueBall();
    if (!cueBall || !isPlayer2AI || currentPlayer != 2) {
        aiPlannedShotDetails.isValid = false; // Ensure no shot if conditions not met
        return;
    }

    // Phase 1: Placement if needed (Ball-in-Hand or Initial Break)
    /*if ((isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) || currentGameState == BALL_IN_HAND_P2) {
        AIPlaceCueBall(); // Handles kitchen placement for break or regular ball-in-hand
        if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
            currentGameState = BREAKING; // Now AI needs to decide the break shot parameters
        }
        // For regular BALL_IN_HAND_P2, after placement, it will proceed to find a shot.
    }*/

    aiPlannedShotDetails.isValid = false; // Default to no valid shot found yet for this decision cycle
    // Note: isOpeningBreakShot is false here because AIBreakShot handles the break.

     // Phase 2: Decide shot parameters (Break or Normal play)
    /*if (isOpeningBreakShot && currentGameState == BREAKING) {
        // Force cue ball into center of kitchen
        cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f;
        cueBall->y = (TABLE_TOP + TABLE_BOTTOM) * 0.5f;
        cueBall->vx = cueBall->vy = 0.0f;

        float rackCenterX = RACK_POS_X + BALL_RADIUS * 2.0f * 0.866f * 2.0f;
        float rackCenterY = RACK_POS_Y;
        float dx = rackCenterX - cueBall->x;
        float dy = rackCenterY - cueBall->y;

        aiPlannedShotDetails.angle = atan2f(dy, dx);
        aiPlannedShotDetails.power = MAX_SHOT_POWER;
        aiPlannedShotDetails.spinX = 0.0f;
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true;

        // Apply shot immediately
        cueAngle = aiPlannedShotDetails.angle;
        shotPower = aiPlannedShotDetails.power;
        cueSpinX = aiPlannedShotDetails.spinX;
        cueSpinY = aiPlannedShotDetails.spinY;

        firstHitBallIdThisShot = -1;
        cueHitObjectBallThisShot = false;
        railHitAfterContact = false;
        isAiming = false;
        aiIsDisplayingAim = false;
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
        //bool aiIsDisplayingAim = true;

        std::thread([](const TCHAR* soundName) {
            PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT);
            }, TEXT(""cue.wav"")).detach();

            ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);
            currentGameState = SHOT_IN_PROGRESS;
            isOpeningBreakShot = false;
            aiTurnPending = false;
            pocketedThisTurn.clear();
            return;
    }
    else {*/
    // --- Normal AI Shot Decision (using AIFindBestShot) ---
    AIShotInfo bestShot = AIFindBestShot(); // bugtraq
    //bestShot = AIFindBestShot(); // bugtraq
    if (bestShot.possible) {
        aiPlannedShotDetails.angle = bestShot.angle;
        aiPlannedShotDetails.power = bestShot.power;
        aiPlannedShotDetails.spinX = 0.0f; // AI doesn't use spin yet
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true;
    }
    else {
        // Safety tap if no better shot found
        // Try to hit the closest 'own' ball gently or any ball if types not assigned
        Ball* ballToNudge = nullptr;
        float minDistSq = -1.0f;
        BallType aiTargetType = player2Info.assignedType;
        bool mustHit8Ball = (aiTargetType != BallType::NONE && player2Info.ballsPocketedCount >= 7);

        for (auto& b : balls) {
            if (b.isPocketed || b.id == 0) continue;
            bool canHitThis = false;
            if (mustHit8Ball) canHitThis = (b.id == 8);
            else if (aiTargetType != BallType::NONE) canHitThis = (b.type == aiTargetType);
            else canHitThis = (b.id != 8); // Can hit any non-8-ball if types not assigned

            if (canHitThis) {
                float dSq = GetDistanceSq(cueBall->x, cueBall->y, b.x, b.y);
                if (ballToNudge == nullptr || dSq < minDistSq) {
                    ballToNudge = &b;
                    minDistSq = dSq;
                }
            }
        }
        if (ballToNudge) { // Found a ball to nudge
            aiPlannedShotDetails.angle = atan2f(ballToNudge->y - cueBall->y, ballToNudge->x - cueBall->x);
            aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.15f; // Gentle tap
        }
        else { // Absolute fallback: small tap forward
            aiPlannedShotDetails.angle = cueAngle; // Keep last angle or default
            //aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.1f;
            aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.1f;
        }
        aiPlannedShotDetails.spinX = 0.0f;
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true; // Safety shot is a ""valid"" plan
    }
    //} //bracefix

    // Phase 3: Setup for Aim Display (if a valid shot was decided)
    if (aiPlannedShotDetails.isValid) {
        cueAngle = aiPlannedShotDetails.angle;   // Update global for drawing
        shotPower = aiPlannedShotDetails.power;  // Update global for drawing
        // cueSpinX and cueSpinY could also be set here if AI used them
        cueSpinX = aiPlannedShotDetails.spinX; // Also set these for drawing consistency
        cueSpinY = aiPlannedShotDetails.spinY; //

        aiIsDisplayingAim = true;
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
        // currentGameState remains AI_THINKING, GameUpdate will handle the display countdown and shot execution.
            // FIRE THE BREAK SHOT NOW
            // Immediately execute the break shot after setting parameters
        /*ApplyShot(aiPlannedShotDetails.power, aiPlannedShotDetails.angle, aiPlannedShotDetails.spinX, aiPlannedShotDetails.spinY);
        currentGameState = SHOT_IN_PROGRESS;
        aiTurnPending = false;
        isOpeningBreakShot = false;*/
    }
    else {
        // Should not happen if safety shot is always planned, but as a fallback:
        aiIsDisplayingAim = false;
        // If AI truly can't decide anything, maybe switch turn or log error. For now, it will do nothing this frame.
        // Or force a minimal safety tap without display.
        // To ensure game progresses, let's plan a minimal tap if nothing else.
        if (!aiPlannedShotDetails.isValid) { // Double check
            aiPlannedShotDetails.angle = 0.0f;
            aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.05f; // Very small tap
            aiPlannedShotDetails.spinX = 0.0f; aiPlannedShotDetails.spinY = 0.0f;
            aiPlannedShotDetails.isValid = true;
            //cueAngle = aiPlannedShotDetails.angle; shotPower = aiPlannedShotDetails.power;
            cueAngle = aiPlannedShotDetails.angle;
            shotPower = aiPlannedShotDetails.power;
            cueSpinX = aiPlannedShotDetails.spinX;
            cueSpinY = aiPlannedShotDetails.spinY;
            aiIsDisplayingAim = true; // Allow display for this minimal tap too
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES / 2; // Shorter display for fallback
        }
    }
    // aiTurnPending was set to false by GameUpdate before calling AIMakeDecision.
    // AIMakeDecision's job is to populate aiPlannedShotDetails and trigger display.
}

// AI logic for placing cue ball during ball-in-hand
void AIPlaceCueBall() {
    Ball* cueBall = GetCueBall();
    if (!cueBall) return;

    // --- CPU AI Opening Break: Kitchen Placement ---
    /*if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT && currentPlayer == 2 && isPlayer2AI) {
        float kitchenMinX = TABLE_LEFT + BALL_RADIUS;
        float kitchenMaxX = HEADSTRING_X - BALL_RADIUS;
        float kitchenMinY = TABLE_TOP + BALL_RADIUS;
        float kitchenMaxY = TABLE_BOTTOM - BALL_RADIUS;
        bool validPositionFound = false;
        int attempts = 0;
        while (!validPositionFound && attempts < 100) {
            cueBall->x = kitchenMinX + static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / (kitchenMaxX - kitchenMinX)));
            cueBall->y = kitchenMinY + static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / (kitchenMaxY - kitchenMinY)));
            if (IsValidCueBallPosition(cueBall->x, cueBall->y, true)) {
                validPositionFound = true;
            }
            attempts++;
        }
        if (!validPositionFound) {
            cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f;
            cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
            if (!IsValidCueBallPosition(cueBall->x, cueBall->y, true)) {
                cueBall->x = HEADSTRING_X - BALL_RADIUS * 2.0f;
                cueBall->y = RACK_POS_Y;
            }
        }
        cueBall->vx = 0; cueBall->vy = 0;
        return;
    }*/
    // --- End CPU AI Opening Break Placement ---

    // This function is now SOLELY for Ball-In-Hand placement for the AI (anywhere on the table).
    // Break placement is handled by AIBreakShot().

    // Simple Strategy: Find the easiest possible shot for the AI's ball type
    // Place the cue ball directly behind that target ball, aiming straight at a pocket.
    // (More advanced: find spot offering multiple options or safety)

    AIShotInfo bestPlacementShot = { false };
    D2D1_POINT_2F bestPlacePos = D2D1::Point2F(HEADSTRING_X * 0.5f, RACK_POS_Y); // Default placement

    // A better default for ball-in-hand (anywhere) might be center table if no shot found.
    bestPlacePos = D2D1::Point2F(TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_TOP + TABLE_HEIGHT / 2.0f);
    float bestPlacementScore = -1.0f; // Keep track of the score for the best placement found

    BallType targetType = player2Info.assignedType;
    bool canTargetAnyPlacement = false; // Local scope variable for placement logic
    if (targetType == BallType::NONE) {
        canTargetAnyPlacement = true;
    }
    bool target8Ball = (!canTargetAnyPlacement && targetType != BallType::NONE && player2Info.ballsPocketedCount >= 7);
    if (target8Ball) targetType = BallType::EIGHT_BALL;


    for (auto& targetBall : balls) {
        if (targetBall.isPocketed || targetBall.id == 0) continue;

        // Determine if current ball is a valid target for placement consideration
        bool currentBallIsValidTarget = false;
        if (target8Ball && targetBall.id == 8) currentBallIsValidTarget = true;
        else if (canTargetAnyPlacement && targetBall.id != 8) currentBallIsValidTarget = true;
        else if (!canTargetAnyPlacement && !target8Ball && targetBall.type == targetType) currentBallIsValidTarget = true;

        if (!currentBallIsValidTarget) continue; // Skip if not a valid target

        for (int p = 0; p < 6; ++p) {
            // Calculate ideal cue ball position: straight line behind target ball aiming at pocket p
            float targetToPocketX = pocketPositions[p].x - targetBall.x;
            float targetToPocketY = pocketPositions[p].y - targetBall.y;
            float dist = sqrtf(targetToPocketX * targetToPocketX + targetToPocketY * targetToPocketY);
            if (dist < 1.0f) continue; // Avoid division by zero

            float idealAngle = atan2f(targetToPocketY, targetToPocketX);
            // Place cue ball slightly behind target ball along this line
            float placeDist = BALL_RADIUS * 3.0f; // Place a bit behind
            D2D1_POINT_2F potentialPlacePos = D2D1::Point2F( // Use factory function
                targetBall.x - cosf(idealAngle) * placeDist,
                targetBall.y - sinf(idealAngle) * placeDist
            );

            // Check if this placement is valid (on table, behind headstring if break, not overlapping)
            /*bool behindHeadstringRule = (currentGameState == PRE_BREAK_PLACEMENT);*/
            // For ball-in-hand (NOT break), behindHeadstringRule is false.
            // The currentGameState should be BALL_IN_HAND_P2 when this is called for a foul.
            bool behindHeadstringRule = false; // Player can place anywhere after a foul
            if (IsValidCueBallPosition(potentialPlacePos.x, potentialPlacePos.y, behindHeadstringRule)) {
                // Is path from potentialPlacePos to targetBall clear?
                // Use D2D1::Point2F() factory function here
                if (IsPathClear(potentialPlacePos, D2D1::Point2F(targetBall.x, targetBall.y), 0, targetBall.id)) {
                    // Is path from targetBall to pocket clear?
                    // Use D2D1::Point2F() factory function here
                    if (IsPathClear(D2D1::Point2F(targetBall.x, targetBall.y), pocketPositions[p], targetBall.id, -1)) {
                        // This seems like a good potential placement. Score it?
                        // Easy AI: Just take the first valid one found.
                        /*bestPlacePos = potentialPlacePos;
                        goto placement_found;*/ // Use goto for simplicity in non-OOP structure
                        // This is a possible shot. Score this placement.
// A simple score: distance to target ball (shorter is better for placement).
// More advanced: consider angle to pocket, difficulty of the shot from this placement.
                        AIShotInfo tempShotInfo;
                        tempShotInfo.possible = true;
                        tempShotInfo.targetBall = &targetBall;
                        tempShotInfo.pocketIndex = p;
                        tempShotInfo.ghostBallPos = CalculateGhostBallPos(&targetBall, p); // Not strictly needed for placement score but good for consistency
                        tempShotInfo.angle = idealAngle; // The angle from the placed ball to target
                        // Use EvaluateShot's scoring mechanism if possible, or a simpler one here.
                        float currentScore = 1000.0f / (1.0f + GetDistance(potentialPlacePos.x, potentialPlacePos.y, targetBall.x, targetBall.y)); // Inverse distance

                        if (currentScore > bestPlacementScore) {
                            bestPlacementScore = currentScore;
                            bestPlacePos = potentialPlacePos;
                        }
                    }
                }
            }
        }
    }

placement_found:
    // Place the cue ball at the best found position (or default if no good spot found)
    cueBall->x = bestPlacePos.x;
    cueBall->y = bestPlacePos.y;
    cueBall->vx = 0;
    cueBall->vy = 0;
}


// AI finds the best shot available on the table
AIShotInfo AIFindBestShot() {
    AIShotInfo bestShotOverall = { false };
    Ball* cueBall = GetCueBall();
    if (!cueBall) return bestShotOverall;
    // Ensure cue ball position is up-to-date if AI just placed it
    // (AIPlaceCueBall should have already set cueBall->x, cueBall->y)

    // Determine target ball type for AI (Player 2)
    BallType targetType = player2Info.assignedType;
    bool canTargetAny = false; // Can AI hit any ball (e.g., after break, before assignment)?
    if (targetType == BallType::NONE) {
        // If colors not assigned, AI aims to pocket *something* (usually lowest numbered ball legally)
        // Or, more simply, treat any ball as a potential target to make *a* pocket
        canTargetAny = true; // Simplification: allow targeting any non-8 ball.
        // A better rule is hit lowest numbered ball first on break follow-up.
    }

    // Check if AI needs to shoot the 8-ball
    bool target8Ball = (!canTargetAny && targetType != BallType::NONE && player2Info.ballsPocketedCount >= 7);


    // Iterate through all potential target balls
    for (auto& potentialTarget : balls) {
        if (potentialTarget.isPocketed || potentialTarget.id == 0) continue; // Skip pocketed and cue ball

        // Check if this ball is a valid target
        bool isValidTarget = false;
        if (target8Ball) {
            isValidTarget = (potentialTarget.id == 8);
        }
        else if (canTargetAny) {
            isValidTarget = (potentialTarget.id != 8); // Can hit any non-8 ball
        }
        else { // Colors assigned, not yet shooting 8-ball
            isValidTarget = (potentialTarget.type == targetType);
        }

        if (!isValidTarget) continue; // Skip if not a valid target for this turn

        // Now, check all pockets for this target ball
        for (int p = 0; p < 6; ++p) {
            AIShotInfo currentShot = EvaluateShot(&potentialTarget, p);
            currentShot.involves8Ball = (potentialTarget.id == 8);

            if (currentShot.possible) {
                // Compare scores to find the best shot
                if (!bestShotOverall.possible || currentShot.score > bestShotOverall.score) {
                    bestShotOverall = currentShot;
                }
            }
        }
    } // End loop through potential target balls

    // If targeting 8-ball and no shot found, or targeting own balls and no shot found,
    // need a safety strategy. Current simple AI just takes best found or taps cue ball.

    return bestShotOverall;
}


// Evaluate a potential shot at a specific target ball towards a specific pocket
AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex) {
    AIShotInfo shotInfo;
    shotInfo.possible = false; // Assume not possible initially
    shotInfo.targetBall = targetBall;
    shotInfo.pocketIndex = pocketIndex;

    Ball* cueBall = GetCueBall();
    if (!cueBall || !targetBall) return shotInfo;

    // --- Define local state variables needed for legality checks ---
    BallType aiAssignedType = player2Info.assignedType;
    bool canTargetAny = (aiAssignedType == BallType::NONE); // Can AI hit any ball?
    bool mustTarget8Ball = (!canTargetAny && aiAssignedType != BallType::NONE && player2Info.ballsPocketedCount >= 7);
    // ---

    // 1. Calculate Ghost Ball position
    shotInfo.ghostBallPos = CalculateGhostBallPos(targetBall, pocketIndex);

    // 2. Calculate Angle from Cue Ball to Ghost Ball
    float dx = shotInfo.ghostBallPos.x - cueBall->x;
    float dy = shotInfo.ghostBallPos.y - cueBall->y;
    if (fabs(dx) < 0.01f && fabs(dy) < 0.01f) return shotInfo; // Avoid aiming at same spot
    shotInfo.angle = atan2f(dy, dx);

    // Basic angle validity check (optional)
    if (!IsValidAIAimAngle(shotInfo.angle)) {
        // Maybe log this or handle edge cases
    }

    // 3. Check Path: Cue Ball -> Ghost Ball Position
    // Use D2D1::Point2F() factory function here
    if (!IsPathClear(D2D1::Point2F(cueBall->x, cueBall->y), shotInfo.ghostBallPos, cueBall->id, targetBall->id)) {
        return shotInfo; // Path blocked
    }

    // 4. Check Path: Target Ball -> Pocket
    // Use D2D1::Point2F() factory function here
    if (!IsPathClear(D2D1::Point2F(targetBall->x, targetBall->y), pocketPositions[pocketIndex], targetBall->id, -1)) {
        return shotInfo; // Path blocked
    }

    // 5. Check First Ball Hit Legality
    float firstHitDistSq = -1.0f;
    // Use D2D1::Point2F() factory function here
    Ball* firstHit = FindFirstHitBall(D2D1::Point2F(cueBall->x, cueBall->y), shotInfo.angle, firstHitDistSq);

    if (!firstHit) {
        return shotInfo; // AI aims but doesn't hit anything? Impossible shot.
    }

    // Check if the first ball hit is the intended target ball
    if (firstHit->id != targetBall->id) {
        // Allow hitting slightly off target if it's very close to ghost ball pos
        float ghostDistSq = GetDistanceSq(shotInfo.ghostBallPos.x, shotInfo.ghostBallPos.y, firstHit->x, firstHit->y);
        // Allow a tolerance roughly half the ball radius squared
        if (ghostDistSq > (BALL_RADIUS * 0.7f) * (BALL_RADIUS * 0.7f)) {
            // First hit is significantly different from the target point.
            // This shot path leads to hitting the wrong ball first.
            return shotInfo; // Foul or unintended shot
        }
        // If first hit is not target, but very close, allow it for now (might still be foul based on type).
    }

    // Check legality of the *first ball actually hit* based on game rules
    if (!canTargetAny) { // Colors are assigned (or should be)
        if (mustTarget8Ball) { // Must hit 8-ball first
            if (firstHit->id != 8) {
                // return shotInfo; // FOUL - Hitting wrong ball when aiming for 8-ball
                // Keep shot possible for now, rely on AIFindBestShot to prioritize legal ones
            }
        }
        else { // Must hit own ball type first
            if (firstHit->type != aiAssignedType && firstHit->id != 8) { // Allow hitting 8-ball if own type blocked? No, standard rules usually require hitting own first.
                // return shotInfo; // FOUL - Hitting opponent ball or 8-ball when shouldn't
                // Keep shot possible for now, rely on AIFindBestShot to prioritize legal ones
            }
            else if (firstHit->id == 8) {
                // return shotInfo; // FOUL - Hitting 8-ball when shouldn't
                // Keep shot possible for now
            }
        }
    }
    // (If canTargetAny is true, hitting any ball except 8 first is legal - assuming not scratching)


    // 6. Calculate Score & Power (Difficulty affects this)
    shotInfo.possible = true; // If we got here, the shot is geometrically possible and likely legal enough for AI to consider

    float cueToGhostDist = GetDistance(cueBall->x, cueBall->y, shotInfo.ghostBallPos.x, shotInfo.ghostBallPos.y);
    float targetToPocketDist = GetDistance(targetBall->x, targetBall->y, pocketPositions[pocketIndex].x, pocketPositions[pocketIndex].y);

    // Simple Score: Shorter shots are better, straighter shots are slightly better.
    float distanceScore = 1000.0f / (1.0f + cueToGhostDist + targetToPocketDist);

    // Angle Score: Calculate cut angle
    // Vector Cue -> Ghost
    float v1x = shotInfo.ghostBallPos.x - cueBall->x;
    float v1y = shotInfo.ghostBallPos.y - cueBall->y;
    // Vector Target -> Pocket
    float v2x = pocketPositions[pocketIndex].x - targetBall->x;
    float v2y = pocketPositions[pocketIndex].y - targetBall->y;
    // Normalize vectors
    float mag1 = sqrtf(v1x * v1x + v1y * v1y);
    float mag2 = sqrtf(v2x * v2x + v2y * v2y);
    float angleScoreFactor = 0.5f; // Default if vectors are zero len
    if (mag1 > 0.1f && mag2 > 0.1f) {
        v1x /= mag1; v1y /= mag1;
        v2x /= mag2; v2y /= mag2;
        // Dot product gives cosine of angle between cue ball path and target ball path
        float dotProduct = v1x * v2x + v1y * v2y;
        // Straighter shot (dot product closer to 1) gets higher score
        angleScoreFactor = (1.0f + dotProduct) / 2.0f; // Map [-1, 1] to [0, 1]
    }
    angleScoreFactor = std::max(0.1f, angleScoreFactor); // Ensure some minimum score factor

    shotInfo.score = distanceScore * angleScoreFactor;

    // Bonus for pocketing 8-ball legally
    if (mustTarget8Ball && targetBall->id == 8) {
        shotInfo.score *= 10.0; // Strongly prefer the winning shot
    }

    // Penalty for difficult cuts? Already partially handled by angleScoreFactor.

    // 7. Calculate Power
    shotInfo.power = CalculateShotPower(cueToGhostDist, targetToPocketDist);

    // 8. Add Inaccuracy based on Difficulty (same as before)
    float angleError = 0.0f;
    float powerErrorFactor = 1.0f;

    switch (aiDifficulty) {
    case EASY:
        angleError = (float)(rand() % 100 - 50) / 1000.0f; // +/- ~3 deg
        powerErrorFactor = 0.8f + (float)(rand() % 40) / 100.0f; // 80-120%
        shotInfo.power *= 0.8f;
        break;
    case MEDIUM:
        angleError = (float)(rand() % 60 - 30) / 1000.0f; // +/- ~1.7 deg
        powerErrorFactor = 0.9f + (float)(rand() % 20) / 100.0f; // 90-110%
        break;
    case HARD:
        angleError = (float)(rand() % 10 - 5) / 1000.0f; // +/- ~0.3 deg
        powerErrorFactor = 0.98f + (float)(rand() % 4) / 100.0f; // 98-102%
        break;
    }
    shotInfo.angle += angleError;
    shotInfo.power *= powerErrorFactor;
    shotInfo.power = std::max(1.0f, std::min(shotInfo.power, MAX_SHOT_POWER)); // Clamp power

    return shotInfo;
}


// Calculates required power (simplified)
float CalculateShotPower(float cueToGhostDist, float targetToPocketDist) {
    // Basic model: Power needed increases with total distance the balls need to travel.
    // Need enough power for cue ball to reach target AND target to reach pocket.
    float totalDist = cueToGhostDist + targetToPocketDist;

    // Map distance to power (needs tuning)
    // Let's say max power is needed for longest possible shot (e.g., corner to corner ~ 1000 units)
    float powerRatio = std::min(1.0f, totalDist / 800.0f); // Normalize based on estimated max distance

    float basePower = MAX_SHOT_POWER * 0.2f; // Minimum power to move balls reliably
    float variablePower = (MAX_SHOT_POWER * 0.8f) * powerRatio; // Scale remaining power range

    // Harder AI could adjust based on desired cue ball travel (more power for draw/follow)
    return std::min(MAX_SHOT_POWER, basePower + variablePower);
}

// Calculate the position the cue ball needs to hit for the target ball to go towards the pocket
D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex) {
    float targetToPocketX = pocketPositions[pocketIndex].x - targetBall->x;
    float targetToPocketY = pocketPositions[pocketIndex].y - targetBall->y;
    float dist = sqrtf(targetToPocketX * targetToPocketX + targetToPocketY * targetToPocketY);

    if (dist < 1.0f) { // Target is basically in the pocket
        // Aim slightly off-center to avoid weird physics? Or directly at center?
        // For simplicity, return a point slightly behind center along the reverse line.
        return D2D1::Point2F(targetBall->x - targetToPocketX * 0.1f, targetBall->y - targetToPocketY * 0.1f);
    }

    // Normalize direction vector from target to pocket
    float nx = targetToPocketX / dist;
    float ny = targetToPocketY / dist;

    // Ghost ball position is diameter distance *behind* the target ball along this line
    float ghostX = targetBall->x - nx * (BALL_RADIUS * 2.0f);
    float ghostY = targetBall->y - ny * (BALL_RADIUS * 2.0f);

    return D2D1::Point2F(ghostX, ghostY);
}

// Checks if line segment is clear of obstructing balls
bool IsPathClear(D2D1_POINT_2F start, D2D1_POINT_2F end, int ignoredBallId1, int ignoredBallId2) {
    float dx = end.x - start.x;
    float dy = end.y - start.y;
    float segmentLenSq = dx * dx + dy * dy;

    if (segmentLenSq < 0.01f) return true; // Start and end are same point

    for (const auto& ball : balls) {
        if (ball.isPocketed) continue;
        if (ball.id == ignoredBallId1) continue;
        if (ball.id == ignoredBallId2) continue;

        // Check distance from ball center to the line segment
        float ballToStartX = ball.x - start.x;
        float ballToStartY = ball.y - start.y;

        // Project ball center onto the line defined by the segment
        float dot = (ballToStartX * dx + ballToStartY * dy) / segmentLenSq;

        D2D1_POINT_2F closestPointOnLine;
        if (dot < 0) { // Closest point is start point
            closestPointOnLine = start;
        }
        else if (dot > 1) { // Closest point is end point
            closestPointOnLine = end;
        }
        else { // Closest point is along the segment
            closestPointOnLine = D2D1::Point2F(start.x + dot * dx, start.y + dot * dy);
        }

        // Check if the closest point is within collision distance (ball radius + path radius)
        if (GetDistanceSq(ball.x, ball.y, closestPointOnLine.x, closestPointOnLine.y) < (BALL_RADIUS * BALL_RADIUS)) {
            // Consider slightly wider path check? Maybe BALL_RADIUS * 1.1f?
            // if (GetDistanceSq(ball.x, ball.y, closestPointOnLine.x, closestPointOnLine.y) < (BALL_RADIUS * 1.1f)*(BALL_RADIUS*1.1f)) {
            return false; // Path is blocked
        }
    }
    return true; // No obstructions found
}

// Finds the first ball hit along a path (simplified)
Ball* FindFirstHitBall(D2D1_POINT_2F start, float angle, float& hitDistSq) {
    Ball* hitBall = nullptr;
    hitDistSq = -1.0f; // Initialize hit distance squared
    float minCollisionDistSq = -1.0f;

    float cosA = cosf(angle);
    float sinA = sinf(angle);

    for (auto& ball : balls) {
        if (ball.isPocketed || ball.id == 0) continue; // Skip cue ball and pocketed

        float dx = ball.x - start.x;
        float dy = ball.y - start.y;

        // Project vector from start->ball onto the aim direction vector
        float dot = dx * cosA + dy * sinA;

        if (dot > 0) { // Ball is generally in front
            // Find closest point on aim line to the ball's center
            float closestPointX = start.x + dot * cosA;
            float closestPointY = start.y + dot * sinA;
            float distSq = GetDistanceSq(ball.x, ball.y, closestPointX, closestPointY);

            // Check if the aim line passes within the ball's radius
            if (distSq < (BALL_RADIUS * BALL_RADIUS)) {
                // Calculate distance from start to the collision point on the ball's circumference
                float backDist = sqrtf(std::max(0.f, BALL_RADIUS * BALL_RADIUS - distSq));
                float collisionDist = dot - backDist; // Distance along aim line to collision

                if (collisionDist > 0) { // Ensure collision is in front
                    float collisionDistSq = collisionDist * collisionDist;
                    if (hitBall == nullptr || collisionDistSq < minCollisionDistSq) {
                        minCollisionDistSq = collisionDistSq;
                        hitBall = &ball; // Found a closer hit ball
                    }
                }
            }
        }
    }
    hitDistSq = minCollisionDistSq; // Return distance squared to the first hit
    return hitBall;
}

// Basic check for reasonable AI aim angles (optional)
bool IsValidAIAimAngle(float angle) {
    // Placeholder - could check for NaN or infinity if calculations go wrong
    return isfinite(angle);
}

//midi func = start
void PlayMidiInBackground(HWND hwnd, const TCHAR* midiPath) {
    while (isMusicPlaying) {
        MCI_OPEN_PARMS mciOpen = { 0 };
        mciOpen.lpstrDeviceType = TEXT(""sequencer"");
        mciOpen.lpstrElementName = midiPath;

        if (mciSendCommand(0, MCI_OPEN, MCI_OPEN_TYPE | MCI_OPEN_ELEMENT, (DWORD_PTR)&mciOpen) == 0) {
            midiDeviceID = mciOpen.wDeviceID;

            MCI_PLAY_PARMS mciPlay = { 0 };
            mciSendCommand(midiDeviceID, MCI_PLAY, 0, (DWORD_PTR)&mciPlay);

            // Wait for playback to complete
            MCI_STATUS_PARMS mciStatus = { 0 };
            mciStatus.dwItem = MCI_STATUS_MODE;

            do {
                mciSendCommand(midiDeviceID, MCI_STATUS, MCI_STATUS_ITEM, (DWORD_PTR)&mciStatus);
                Sleep(100); // adjust as needed
            } while (mciStatus.dwReturn == MCI_MODE_PLAY && isMusicPlaying);

            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
        }
    }
}

void StartMidi(HWND hwnd, const TCHAR* midiPath) {
    if (isMusicPlaying) {
        StopMidi();
    }
    isMusicPlaying = true;
    musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
}

void StopMidi() {
    if (isMusicPlaying) {
        isMusicPlaying = false;
        if (musicThread.joinable()) musicThread.join();
        if (midiDeviceID != 0) {
            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
        }
    }
}

/*void PlayGameMusic(HWND hwnd) {
    // Stop any existing playback
    if (isMusicPlaying) {
        isMusicPlaying = false;
        if (musicThread.joinable()) {
            musicThread.join();
        }
        if (midiDeviceID != 0) {
            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
        }
    }

    // Get the path of the executable
    TCHAR exePath[MAX_PATH];
    GetModuleFileName(NULL, exePath, MAX_PATH);

    // Extract the directory path
    TCHAR* lastBackslash = _tcsrchr(exePath, '\\');
    if (lastBackslash != NULL) {
        *(lastBackslash + 1) = '\0';
    }

    // Construct the full path to the MIDI file
    static TCHAR midiPath[MAX_PATH];
    _tcscpy_s(midiPath, MAX_PATH, exePath);
    _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID""));

    // Start the background playback
    isMusicPlaying = true;
    musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
}*/
//midi func = end

// --- Drawing Functions ---

void OnPaint() {
    HRESULT hr = CreateDeviceResources(); // Ensure resources are valid

    if (SUCCEEDED(hr)) {
        pRenderTarget->BeginDraw();
        DrawScene(pRenderTarget); // Pass render target
        hr = pRenderTarget->EndDraw();

        if (hr == D2DERR_RECREATE_TARGET) {
            DiscardDeviceResources();
            // Optionally request another paint message: InvalidateRect(hwndMain, NULL, FALSE);
            // But the timer loop will trigger redraw anyway.
        }
    }
    // If CreateDeviceResources failed, EndDraw might not be called.
    // Consider handling this more robustly if needed.
}

void DrawScene(ID2D1RenderTarget* pRT) {
    if (!pRT) return;

    //pRT->Clear(D2D1::ColorF(D2D1::ColorF::LightGray)); // Background color
    // Set background color to #ffffcd (RGB: 255, 255, 205)
    pRT->Clear(D2D1::ColorF(0.3686f, 0.5333f, 0.3882f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)
    //pRT->Clear(D2D1::ColorF(1.0f, 1.0f, 0.803f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)

    DrawTable(pRT, pFactory);
    DrawPocketSelectionIndicator(pRT); // Draw arrow over selected/called pocket
    DrawBalls(pRT);
    DrawAimingAids(pRT); // Includes cue stick if aiming
    DrawUI(pRT);
    DrawPowerMeter(pRT);
    DrawSpinIndicator(pRT);
    DrawPocketedBallsIndicator(pRT);
    DrawBallInHandIndicator(pRT); // Draw cue ball ghost if placing

     // Draw Game Over Message
    if (currentGameState == GAME_OVER && pTextFormat) {
        ID2D1SolidColorBrush* pBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pBrush);
        if (pBrush) {
            D2D1_RECT_F layoutRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP + TABLE_HEIGHT / 2 - 30, TABLE_RIGHT, TABLE_TOP + TABLE_HEIGHT / 2 + 30);
            pRT->DrawText(
                gameOverMessage.c_str(),
                (UINT32)gameOverMessage.length(),
                pTextFormat, // Use large format maybe?
                &layoutRect,
                pBrush
            );
            SafeRelease(&pBrush);
        }
    }

}

void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory) {
    ID2D1SolidColorBrush* pBrush = nullptr;

    // === Draw Full Orange Frame (Table Border) ===
    ID2D1SolidColorBrush* pFrameBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(0.9157f, 0.6157f, 0.2000f), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
    //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
    if (pFrameBrush) {
        D2D1_RECT_F outerRect = D2D1::RectF(
            TABLE_LEFT - CUSHION_THICKNESS,
            TABLE_TOP - CUSHION_THICKNESS,
            TABLE_RIGHT + CUSHION_THICKNESS,
            TABLE_BOTTOM + CUSHION_THICKNESS
        );
        pRT->FillRectangle(&outerRect, pFrameBrush);
        SafeRelease(&pFrameBrush);
    }

    // Draw Table Bed (Green Felt)
    pRT->CreateSolidColorBrush(TABLE_COLOR, &pBrush);
    if (!pBrush) return;
    D2D1_RECT_F tableRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP, TABLE_RIGHT, TABLE_BOTTOM);
    pRT->FillRectangle(&tableRect, pBrush);
    SafeRelease(&pBrush);

    // Draw Cushions (Red Border)
    pRT->CreateSolidColorBrush(CUSHION_COLOR, &pBrush);
    if (!pBrush) return;
    // Top Cushion (split by middle pocket)
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
    // Bottom Cushion (split by middle pocket)
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
    // Left Cushion
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT - CUSHION_THICKNESS, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_LEFT, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
    // Right Cushion
    pRT->FillRectangle(D2D1::RectF(TABLE_RIGHT, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_RIGHT + CUSHION_THICKNESS, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
    SafeRelease(&pBrush);


    // Draw Pockets (Black Circles)
    pRT->CreateSolidColorBrush(POCKET_COLOR, &pBrush);
    if (!pBrush) return;
    for (int i = 0; i < 6; ++i) {
        D2D1_ELLIPSE ellipse = D2D1::Ellipse(pocketPositions[i], HOLE_VISUAL_RADIUS, HOLE_VISUAL_RADIUS);
        pRT->FillEllipse(&ellipse, pBrush);
    }
    SafeRelease(&pBrush);

    // Draw Headstring Line (White)
    pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
    //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
    if (!pBrush) return;
    pRT->DrawLine(
        D2D1::Point2F(HEADSTRING_X, TABLE_TOP),
        D2D1::Point2F(HEADSTRING_X, TABLE_BOTTOM),
        pBrush,
        1.0f // Line thickness
    );
    SafeRelease(&pBrush);

    // Draw Semicircle facing West (flat side East)
    // Draw Semicircle facing East (curved side on the East, flat side on the West)
    ID2D1PathGeometry* pGeometry = nullptr;
    HRESULT hr = pFactory->CreatePathGeometry(&pGeometry);
    if (SUCCEEDED(hr) && pGeometry)
    {
        ID2D1GeometrySink* pSink = nullptr;
        hr = pGeometry->Open(&pSink);
        if (SUCCEEDED(hr) && pSink)
        {
            float radius = 60.0f; // Radius for the semicircle
            D2D1_POINT_2F center = D2D1::Point2F(HEADSTRING_X, (TABLE_TOP + TABLE_BOTTOM) / 2.0f);

            // For a semicircle facing East (curved side on the East), use the top and bottom points.
            D2D1_POINT_2F startPoint = D2D1::Point2F(center.x, center.y - radius); // Top point

            pSink->BeginFigure(startPoint, D2D1_FIGURE_BEGIN_HOLLOW);

            D2D1_ARC_SEGMENT arc = {};
            arc.point = D2D1::Point2F(center.x, center.y + radius); // Bottom point
            arc.size = D2D1::SizeF(radius, radius);
            arc.rotationAngle = 0.0f;
            // Use the correct identifier with the extra underscore:
            arc.sweepDirection = D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE;
            arc.arcSize = D2D1_ARC_SIZE_SMALL;

            pSink->AddArc(&arc);
            pSink->EndFigure(D2D1_FIGURE_END_OPEN);
            pSink->Close();
            SafeRelease(&pSink);

            ID2D1SolidColorBrush* pArcBrush = nullptr;
            //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.3f), &pArcBrush);
            pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pArcBrush);
            if (pArcBrush)
            {
                pRT->DrawGeometry(pGeometry, pArcBrush, 1.5f);
                SafeRelease(&pArcBrush);
            }
        }
        SafeRelease(&pGeometry);
    }




}


void DrawBalls(ID2D1RenderTarget* pRT) {
    ID2D1SolidColorBrush* pBrush = nullptr;
    ID2D1SolidColorBrush* pStripeBrush = nullptr; // For stripe pattern

    pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBrush); // Placeholder
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);

    if (!pBrush || !pStripeBrush) {
        SafeRelease(&pBrush);
        SafeRelease(&pStripeBrush);
        return;
    }


    for (size_t i = 0; i < balls.size(); ++i) {
        const Ball& b = balls[i];
        if (!b.isPocketed) {
            D2D1_ELLIPSE ellipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS, BALL_RADIUS);

            // Set main ball color
            pBrush->SetColor(b.color);
            pRT->FillEllipse(&ellipse, pBrush);

            // Draw Stripe if applicable
            if (b.type == BallType::STRIPE) {
                // Draw a white band across the middle (simplified stripe)
                D2D1_RECT_F stripeRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS * 0.4f, b.x + BALL_RADIUS, b.y + BALL_RADIUS * 0.4f);
                // Need to clip this rectangle to the ellipse bounds - complex!
                // Alternative: Draw two colored arcs leaving a white band.
                // Simplest: Draw a white circle inside, slightly smaller.
                D2D1_ELLIPSE innerEllipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS * 0.6f, BALL_RADIUS * 0.6f);
                pRT->FillEllipse(innerEllipse, pStripeBrush); // White center part
                pBrush->SetColor(b.color); // Set back to stripe color
                pRT->FillEllipse(innerEllipse, pBrush); // Fill again, leaving a ring - No, this isn't right.

                // Let's try drawing a thick white line across
                // This doesn't look great. Just drawing solid red for stripes for now.
            }

            // Draw Number (Optional - requires more complex text layout or pre-rendered textures)
            // if (b.id != 0 && pTextFormat) {
            //     std::wstring numStr = std::to_wstring(b.id);
            //     D2D1_RECT_F textRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS, b.x + BALL_RADIUS, b.y + BALL_RADIUS);
            //     ID2D1SolidColorBrush* pNumBrush = nullptr;
            //     D2D1_COLOR_F numCol = (b.type == BallType::SOLID || b.id == 8) ? D2D1::ColorF(D2D1::ColorF::Black) : D2D1::ColorF(D2D1::ColorF::White);
            //     pRT->CreateSolidColorBrush(numCol, &pNumBrush);
            //     // Create a smaller text format...
            //     // pRT->DrawText(numStr.c_str(), numStr.length(), pSmallTextFormat, &textRect, pNumBrush);
            //     SafeRelease(&pNumBrush);
            // }
        }
    }

    SafeRelease(&pBrush);
    SafeRelease(&pStripeBrush);
}


void DrawAimingAids(ID2D1RenderTarget* pRT) {
    // Condition check at start (Unchanged)
    //if (currentGameState != PLAYER1_TURN && currentGameState != PLAYER2_TURN &&
        //currentGameState != BREAKING && currentGameState != AIMING)
    //{
        //return;
    //}
        // NEW Condition: Allow drawing if it's a human player's active turn/aiming/breaking,
    // OR if it's AI's turn and it's in AI_THINKING state (calculating) or BREAKING (aiming break).
    bool isHumanInteracting = (!isPlayer2AI || currentPlayer == 1) &&
        (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
            currentGameState == BREAKING || currentGameState == AIMING);
    // AI_THINKING state is when AI calculates shot. AIMakeDecision sets cueAngle/shotPower.
    // Also include BREAKING state if it's AI's turn and isOpeningBreakShot for break aim visualization.
        // NEW Condition: AI is displaying its aim
    bool isAiVisualizingShot = (isPlayer2AI && currentPlayer == 2 &&
        currentGameState == AI_THINKING && aiIsDisplayingAim);

    if (!isHumanInteracting && !(isAiVisualizingShot || (currentGameState == AI_THINKING && aiIsDisplayingAim))) {
        return;
    }

    Ball* cueBall = GetCueBall();
    if (!cueBall || cueBall->isPocketed) return; // Don't draw if cue ball is gone

    ID2D1SolidColorBrush* pBrush = nullptr;
    ID2D1SolidColorBrush* pGhostBrush = nullptr;
    ID2D1StrokeStyle* pDashedStyle = nullptr;
    ID2D1SolidColorBrush* pCueBrush = nullptr;
    ID2D1SolidColorBrush* pReflectBrush = nullptr; // Brush for reflection line

    // Ensure render target is valid
    if (!pRT) return;

    // Create Brushes and Styles (check for failures)
    HRESULT hr;
    hr = pRT->CreateSolidColorBrush(AIM_LINE_COLOR, &pBrush);
    if FAILED(hr) { SafeRelease(&pBrush); return; }
    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pGhostBrush);
    if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); return; }
    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0.6f, 0.4f, 0.2f), &pCueBrush);
    if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); return; }
    // Create reflection brush (e.g., lighter shade or different color)
    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::LightCyan, 0.6f), &pReflectBrush);
    if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); SafeRelease(&pReflectBrush); return; }
    // Create a Cyan brush for primary and secondary lines //orig(75.0f / 255.0f, 0.0f, 130.0f / 255.0f);indigoColor
    D2D1::ColorF cyanColor(0.0, 255.0, 255.0, 255.0f);
    ID2D1SolidColorBrush* pCyanBrush = nullptr;
    hr = pRT->CreateSolidColorBrush(cyanColor, &pCyanBrush);
    if (FAILED(hr)) {
        SafeRelease(&pCyanBrush);
        // handle error if needed
    }
    // Create a Purple brush for primary and secondary lines
    D2D1::ColorF purpleColor(255.0f, 0.0f, 255.0f, 255.0f);
    ID2D1SolidColorBrush* pPurpleBrush = nullptr;
    hr = pRT->CreateSolidColorBrush(purpleColor, &pPurpleBrush);
    if (FAILED(hr)) {
        SafeRelease(&pPurpleBrush);
        // handle error if needed
    }

    if (pFactory) {
        D2D1_STROKE_STYLE_PROPERTIES strokeProps = D2D1::StrokeStyleProperties();
        strokeProps.dashStyle = D2D1_DASH_STYLE_DASH;
        hr = pFactory->CreateStrokeStyle(&strokeProps, nullptr, 0, &pDashedStyle);
        if FAILED(hr) { pDashedStyle = nullptr; }
    }


    // --- Cue Stick Drawing (Unchanged from previous fix) ---
    const float baseStickLength = 150.0f;
    const float baseStickThickness = 4.0f;
    float stickLength = baseStickLength * 1.4f;
    float stickThickness = baseStickThickness * 1.5f;
    float stickAngle = cueAngle + PI;
    float powerOffset = 0.0f;
    //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
        // Show power offset if human is aiming/dragging, or if AI is preparing its shot (AI_THINKING or AI Break)
    if ((isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) || isAiVisualizingShot) { // Use the new condition
        powerOffset = shotPower * 5.0f;
    }
    D2D1_POINT_2F cueStickEnd = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (stickLength + powerOffset), cueBall->y + sinf(stickAngle) * (stickLength + powerOffset));
    D2D1_POINT_2F cueStickTip = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (powerOffset + 5.0f), cueBall->y + sinf(stickAngle) * (powerOffset + 5.0f));
    pRT->DrawLine(cueStickTip, cueStickEnd, pCueBrush, stickThickness);


    // --- Projection Line Calculation ---
    float cosA = cosf(cueAngle);
    float sinA = sinf(cueAngle);
    float rayLength = TABLE_WIDTH + TABLE_HEIGHT; // Ensure ray is long enough
    D2D1_POINT_2F rayStart = D2D1::Point2F(cueBall->x, cueBall->y);
    D2D1_POINT_2F rayEnd = D2D1::Point2F(rayStart.x + cosA * rayLength, rayStart.y + sinA * rayLength);

    // Find the first ball hit by the aiming ray
    Ball* hitBall = nullptr;
    float firstHitDistSq = -1.0f;
    D2D1_POINT_2F ballCollisionPoint = { 0, 0 }; // Point on target ball circumference
    D2D1_POINT_2F ghostBallPosForHit = { 0, 0 }; // Ghost ball pos for the hit ball

    hitBall = FindFirstHitBall(rayStart, cueAngle, firstHitDistSq);
    if (hitBall) {
        // Calculate the point on the target ball's circumference
        float collisionDist = sqrtf(firstHitDistSq);
        ballCollisionPoint = D2D1::Point2F(rayStart.x + cosA * collisionDist, rayStart.y + sinA * collisionDist);
        // Calculate ghost ball position for this specific hit (used for projection consistency)
        ghostBallPosForHit = D2D1::Point2F(hitBall->x - cosA * BALL_RADIUS, hitBall->y - sinA * BALL_RADIUS); // Approx.
    }

    // Find the first rail hit by the aiming ray
    D2D1_POINT_2F railHitPoint = rayEnd; // Default to far end if no rail hit
    float minRailDistSq = rayLength * rayLength;
    int hitRailIndex = -1; // 0:Left, 1:Right, 2:Top, 3:Bottom

    // Define table edge segments for intersection checks
    D2D1_POINT_2F topLeft = D2D1::Point2F(TABLE_LEFT, TABLE_TOP);
    D2D1_POINT_2F topRight = D2D1::Point2F(TABLE_RIGHT, TABLE_TOP);
    D2D1_POINT_2F bottomLeft = D2D1::Point2F(TABLE_LEFT, TABLE_BOTTOM);
    D2D1_POINT_2F bottomRight = D2D1::Point2F(TABLE_RIGHT, TABLE_BOTTOM);

    D2D1_POINT_2F currentIntersection;

    // Check Left Rail
    if (LineSegmentIntersection(rayStart, rayEnd, topLeft, bottomLeft, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 0; }
    }
    // Check Right Rail
    if (LineSegmentIntersection(rayStart, rayEnd, topRight, bottomRight, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 1; }
    }
    // Check Top Rail
    if (LineSegmentIntersection(rayStart, rayEnd, topLeft, topRight, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 2; }
    }
    // Check Bottom Rail
    if (LineSegmentIntersection(rayStart, rayEnd, bottomLeft, bottomRight, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 3; }
    }


    // --- Determine final aim line end point ---
    D2D1_POINT_2F finalLineEnd = railHitPoint; // Assume rail hit first
    bool aimingAtRail = true;

    if (hitBall && firstHitDistSq < minRailDistSq) {
        // Ball collision is closer than rail collision
        finalLineEnd = ballCollisionPoint; // End line at the point of contact on the ball
        aimingAtRail = false;
    }

    // --- Draw Primary Aiming Line ---
    pRT->DrawLine(rayStart, finalLineEnd, pBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

    // --- Draw Target Circle/Indicator ---
    D2D1_ELLIPSE targetCircle = D2D1::Ellipse(finalLineEnd, BALL_RADIUS / 2.0f, BALL_RADIUS / 2.0f);
    pRT->DrawEllipse(&targetCircle, pBrush, 1.0f);

    // --- Draw Projection/Reflection Lines ---
    if (!aimingAtRail && hitBall) {
        // Aiming at a ball: Draw Ghost Cue Ball and Target Ball Projection
        D2D1_ELLIPSE ghostCue = D2D1::Ellipse(ballCollisionPoint, BALL_RADIUS, BALL_RADIUS); // Ghost ball at contact point
        pRT->DrawEllipse(ghostCue, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

        // Calculate target ball projection based on impact line (cue collision point -> target center)
        float targetProjectionAngle = atan2f(hitBall->y - ballCollisionPoint.y, hitBall->x - ballCollisionPoint.x);
        // Clamp angle calculation if distance is tiny
        if (GetDistanceSq(hitBall->x, hitBall->y, ballCollisionPoint.x, ballCollisionPoint.y) < 1.0f) {
            targetProjectionAngle = cueAngle; // Fallback if overlapping
        }

        D2D1_POINT_2F targetStartPoint = D2D1::Point2F(hitBall->x, hitBall->y);
        D2D1_POINT_2F targetProjectionEnd = D2D1::Point2F(
            hitBall->x + cosf(targetProjectionAngle) * 50.0f, // Projection length 50 units
            hitBall->y + sinf(targetProjectionAngle) * 50.0f
        );
        // Draw solid line for target projection
        //pRT->DrawLine(targetStartPoint, targetProjectionEnd, pBrush, 1.0f);

    //new code start

                // Dual trajectory with edge-aware contact simulation
        D2D1_POINT_2F dir = {
            targetProjectionEnd.x - targetStartPoint.x,
            targetProjectionEnd.y - targetStartPoint.y
        };
        float dirLen = sqrtf(dir.x * dir.x + dir.y * dir.y);
        dir.x /= dirLen;
        dir.y /= dirLen;

        D2D1_POINT_2F perp = { -dir.y, dir.x };

        // Approximate cue ball center by reversing from tip
        D2D1_POINT_2F cueBallCenterForGhostHit = { // Renamed for clarity if you use it elsewhere
            targetStartPoint.x - dir.x * BALL_RADIUS,
            targetStartPoint.y - dir.y * BALL_RADIUS
        };

        // REAL contact-ball center - use your physics object's center:
        // (replace 'objectBallPos' with whatever you actually call it)
        // (targetStartPoint is already hitBall->x, hitBall->y)
        D2D1_POINT_2F contactBallCenter = targetStartPoint; // Corrected: Use the object ball's actual center
        //D2D1_POINT_2F contactBallCenter = D2D1::Point2F(hitBall->x, hitBall->y);

       // The 'offset' calculation below uses 'cueBallCenterForGhostHit' (originally 'cueBallCenter').
       // This will result in 'offset' being 0 because 'cueBallCenterForGhostHit' is defined
       // such that (targetStartPoint - cueBallCenterForGhostHit) is parallel to 'dir',
       // and 'perp' is perpendicular to 'dir'.
       // Consider Change 2 if this 'offset' is not behaving as intended for the secondary line.
        /*float offset = ((targetStartPoint.x - cueBallCenterForGhostHit.x) * perp.x +
            (targetStartPoint.y - cueBallCenterForGhostHit.y) * perp.y);*/
            /*float offset = ((targetStartPoint.x - cueBallCenter.x) * perp.x +
                (targetStartPoint.y - cueBallCenter.y) * perp.y);
            float absOffset = fabsf(offset);
            float side = (offset >= 0 ? 1.0f : -1.0f);*/

            // Use actual cue ball center for offset calculation if 'offset' is meant to quantify the cut
        D2D1_POINT_2F actualCueBallPhysicalCenter = D2D1::Point2F(cueBall->x, cueBall->y); // This is also rayStart

        // Offset calculation based on actual cue ball position relative to the 'dir' line through targetStartPoint
        float offset = ((targetStartPoint.x - actualCueBallPhysicalCenter.x) * perp.x +
            (targetStartPoint.y - actualCueBallPhysicalCenter.y) * perp.y);
        float absOffset = fabsf(offset);
        float side = (offset >= 0 ? 1.0f : -1.0f);


        // Actual contact point on target ball edge
        D2D1_POINT_2F contactPoint = {
        contactBallCenter.x + perp.x * BALL_RADIUS * side,
        contactBallCenter.y + perp.y * BALL_RADIUS * side
        };

        // Tangent (cut shot) path from contact point
            // Tangent (cut shot) path: from contact point to contact ball center
        D2D1_POINT_2F objectBallDir = {
            contactBallCenter.x - contactPoint.x,
            contactBallCenter.y - contactPoint.y
        };
        float oLen = sqrtf(objectBallDir.x * objectBallDir.x + objectBallDir.y * objectBallDir.y);
        if (oLen != 0.0f) {
            objectBallDir.x /= oLen;
            objectBallDir.y /= oLen;
        }

        const float PRIMARY_LEN = 150.0f; //default=150.0f
        const float SECONDARY_LEN = 150.0f; //default=150.0f
        const float STRAIGHT_EPSILON = BALL_RADIUS * 0.05f;

        D2D1_POINT_2F primaryEnd = {
            targetStartPoint.x + dir.x * PRIMARY_LEN,
            targetStartPoint.y + dir.y * PRIMARY_LEN
        };

        // Secondary line starts from the contact ball's center
        D2D1_POINT_2F secondaryStart = contactBallCenter;
        D2D1_POINT_2F secondaryEnd = {
            secondaryStart.x + objectBallDir.x * SECONDARY_LEN,
            secondaryStart.y + objectBallDir.y * SECONDARY_LEN
        };

        if (absOffset < STRAIGHT_EPSILON)  // straight shot?
        {
            // Straight: secondary behind primary
                    // secondary behind primary {pDashedStyle param at end}
            pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
            //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
            pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
            //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
        }
        else
        {
            // Cut shot: both visible
                    // both visible for cut shot
            pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
            //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
            pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
            //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
        }
        // End improved trajectory logic

    //new code end

        // -- Cue Ball Path after collision (Optional, requires physics) --
        // Very simplified: Assume cue deflects, angle depends on cut angle.
        // float cutAngle = acosf(cosf(cueAngle - targetProjectionAngle)); // Angle between paths
        // float cueDeflectionAngle = ? // Depends on cutAngle, spin, etc. Hard to predict accurately.
        // D2D1_POINT_2F cueProjectionEnd = ...
        // pRT->DrawLine(ballCollisionPoint, cueProjectionEnd, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

        // --- Accuracy Comment ---
        // Note: The visual accuracy of this projection, especially for cut shots (hitting the ball off-center)
        // or shots with spin, is limited by the simplified physics model. Real pool physics involves
        // collision-induced throw, spin transfer, and cue ball deflection not fully simulated here.
        // The ghost ball method shows the *ideal* line for a center-cue hit without spin.

    }
    else if (aimingAtRail && hitRailIndex != -1) {
        // Aiming at a rail: Draw reflection line
        float reflectAngle = cueAngle;
        // Reflect angle based on which rail was hit
        if (hitRailIndex == 0 || hitRailIndex == 1) { // Left or Right rail
            reflectAngle = PI - cueAngle; // Reflect horizontal component
        }
        else { // Top or Bottom rail
            reflectAngle = -cueAngle; // Reflect vertical component
        }
        // Normalize angle if needed (atan2 usually handles this)
        while (reflectAngle > PI) reflectAngle -= 2 * PI;
        while (reflectAngle <= -PI) reflectAngle += 2 * PI;


        float reflectionLength = 60.0f; // Length of the reflection line
        D2D1_POINT_2F reflectionEnd = D2D1::Point2F(
            finalLineEnd.x + cosf(reflectAngle) * reflectionLength,
            finalLineEnd.y + sinf(reflectAngle) * reflectionLength
        );

        // Draw the reflection line (e.g., using a different color/style)
        pRT->DrawLine(finalLineEnd, reflectionEnd, pReflectBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);
    }

    // Release resources
    SafeRelease(&pBrush);
    SafeRelease(&pGhostBrush);
    SafeRelease(&pCueBrush);
    SafeRelease(&pReflectBrush); // Release new brush
    SafeRelease(&pCyanBrush);
    SafeRelease(&pPurpleBrush);
    SafeRelease(&pDashedStyle);
}


void DrawUI(ID2D1RenderTarget* pRT) {
    if (!pTextFormat || !pLargeTextFormat) return;

    ID2D1SolidColorBrush* pBrush = nullptr;
    pRT->CreateSolidColorBrush(UI_TEXT_COLOR, &pBrush);
    if (!pBrush) return;

    // --- Player Info Area (Top Left/Right) --- (Unchanged)
    float uiTop = TABLE_TOP - 80;
    float uiHeight = 60;
    float p1Left = TABLE_LEFT;
    float p1Width = 150;
    float p2Left = TABLE_RIGHT - p1Width;
    D2D1_RECT_F p1Rect = D2D1::RectF(p1Left, uiTop, p1Left + p1Width, uiTop + uiHeight);
    D2D1_RECT_F p2Rect = D2D1::RectF(p2Left, uiTop, p2Left + p1Width, uiTop + uiHeight);

    // Player 1 Info Text (Unchanged)
    std::wostringstream oss1;
    oss1 << player1Info.name.c_str() << L""\n"";
    if (player1Info.assignedType != BallType::NONE) {
        oss1 << ((player1Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
        oss1 << L"" ["" << player1Info.ballsPocketedCount << L""/7]"";
    }
    else {
        oss1 << L""(Undecided)"";
    }
    pRT->DrawText(oss1.str().c_str(), (UINT32)oss1.str().length(), pTextFormat, &p1Rect, pBrush);
    // Draw Player 1 Side Ball
    if (player1Info.assignedType != BallType::NONE)
    {
        ID2D1SolidColorBrush* pBallBrush = nullptr;
        D2D1_COLOR_F ballColor = (player1Info.assignedType == BallType::SOLID) ?
            D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
        pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
        if (pBallBrush)
        {
            D2D1_POINT_2F ballCenter = D2D1::Point2F(p1Rect.right + 10.0f, p1Rect.top + 20.0f);
            float radius = 10.0f;
            D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
            pRT->FillEllipse(&ball, pBallBrush);
            SafeRelease(&pBallBrush);
            // Draw border around the ball
            ID2D1SolidColorBrush* pBorderBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
            if (pBorderBrush)
            {
                pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                SafeRelease(&pBorderBrush);
            }

            // If stripes, draw a stripe band
            if (player1Info.assignedType == BallType::STRIPE)
            {
                ID2D1SolidColorBrush* pStripeBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                if (pStripeBrush)
                {
                    D2D1_RECT_F stripeRect = D2D1::RectF(
                        ballCenter.x - radius,
                        ballCenter.y - 3.0f,
                        ballCenter.x + radius,
                        ballCenter.y + 3.0f
                    );
                    pRT->FillRectangle(&stripeRect, pStripeBrush);
                    SafeRelease(&pStripeBrush);
                }
            }
        }
    }


    // Player 2 Info Text (Unchanged)
    std::wostringstream oss2;
    oss2 << player2Info.name.c_str() << L""\n"";
    if (player2Info.assignedType != BallType::NONE) {
        oss2 << ((player2Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
        oss2 << L"" ["" << player2Info.ballsPocketedCount << L""/7]"";
    }
    else {
        oss2 << L""(Undecided)"";
    }
    pRT->DrawText(oss2.str().c_str(), (UINT32)oss2.str().length(), pTextFormat, &p2Rect, pBrush);
    // Draw Player 2 Side Ball
    if (player2Info.assignedType != BallType::NONE)
    {
        ID2D1SolidColorBrush* pBallBrush = nullptr;
        D2D1_COLOR_F ballColor = (player2Info.assignedType == BallType::SOLID) ?
            D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
        pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
        if (pBallBrush)
        {
            D2D1_POINT_2F ballCenter = D2D1::Point2F(p2Rect.right + 10.0f, p2Rect.top + 20.0f);
            float radius = 10.0f;
            D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
            pRT->FillEllipse(&ball, pBallBrush);
            SafeRelease(&pBallBrush);
            // Draw border around the ball
            ID2D1SolidColorBrush* pBorderBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
            if (pBorderBrush)
            {
                pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                SafeRelease(&pBorderBrush);
            }

            // If stripes, draw a stripe band
            if (player2Info.assignedType == BallType::STRIPE)
            {
                ID2D1SolidColorBrush* pStripeBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                if (pStripeBrush)
                {
                    D2D1_RECT_F stripeRect = D2D1::RectF(
                        ballCenter.x - radius,
                        ballCenter.y - 3.0f,
                        ballCenter.x + radius,
                        ballCenter.y + 3.0f
                    );
                    pRT->FillRectangle(&stripeRect, pStripeBrush);
                    SafeRelease(&pStripeBrush);
                }
            }
        }
    }

    // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
    ID2D1SolidColorBrush* pArrowBrush = nullptr;
    pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
    if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
        float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
        float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
        float arrowTipX, arrowBackX;

        D2D1_RECT_F playerBox = (currentPlayer == 1) ? p1Rect : p2Rect;
        arrowBackX = playerBox.left - 25.0f;
        arrowTipX = arrowBackX + arrowSizeBase * 0.75f;

        float notchDepth = 12.0f;  // Increased from 6.0f to make the rectangle longer
        float notchWidth = 10.0f;

        float cx = arrowBackX;
        float cy = arrowCenterY;

        // Define triangle + rectangle tail shape
        D2D1_POINT_2F tip = D2D1::Point2F(arrowTipX, cy);                           // tip
        D2D1_POINT_2F baseTop = D2D1::Point2F(cx, cy - arrowSizeBase / 2.0f);          // triangle top
        D2D1_POINT_2F baseBot = D2D1::Point2F(cx, cy + arrowSizeBase / 2.0f);          // triangle bottom

        // Rectangle coordinates for the tail portion:
        D2D1_POINT_2F r1 = D2D1::Point2F(cx - notchDepth, cy - notchWidth / 2.0f);   // rect top-left
        D2D1_POINT_2F r2 = D2D1::Point2F(cx, cy - notchWidth / 2.0f);                 // rect top-right
        D2D1_POINT_2F r3 = D2D1::Point2F(cx, cy + notchWidth / 2.0f);                 // rect bottom-right
        D2D1_POINT_2F r4 = D2D1::Point2F(cx - notchDepth, cy + notchWidth / 2.0f);    // rect bottom-left

        ID2D1PathGeometry* pPath = nullptr;
        if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
            ID2D1GeometrySink* pSink = nullptr;
            if (SUCCEEDED(pPath->Open(&pSink))) {
                pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
                pSink->AddLine(baseTop);
                pSink->AddLine(r2); // transition from triangle into rectangle
                pSink->AddLine(r1);
                pSink->AddLine(r4);
                pSink->AddLine(r3);
                pSink->AddLine(baseBot);
                pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                pSink->Close();
                SafeRelease(&pSink);
                pRT->FillGeometry(pPath, pArrowBrush);
            }
            SafeRelease(&pPath);
        }


        SafeRelease(&pArrowBrush);
    }

    //original
/*
    // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
    ID2D1SolidColorBrush* pArrowBrush = nullptr;
    pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
    if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
        float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
        float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
        float arrowTipX, arrowBackX;

        if (currentPlayer == 1) {
arrowBackX = p1Rect.left - 25.0f; // Position left of the box
            arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
            // Define points for right-pointing arrow
            //D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
            //D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
            //D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back
            // Enhanced arrow with base rectangle intersection
    float notchDepth = 6.0f; // Depth of square base ""stem""
    float notchWidth = 4.0f; // Thickness of square part

    D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
    D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
    D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY - notchWidth / 2.0f); // Square Left-Top
    D2D1_POINT_2F pt4 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY + notchWidth / 2.0f); // Square Left-Bottom
    D2D1_POINT_2F pt5 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back


    ID2D1PathGeometry* pPath = nullptr;
    if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
        ID2D1GeometrySink* pSink = nullptr;
        if (SUCCEEDED(pPath->Open(&pSink))) {
            pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
            pSink->AddLine(pt2);
            pSink->AddLine(pt3);
            pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
            pSink->Close();
            SafeRelease(&pSink);
            pRT->FillGeometry(pPath, pArrowBrush);
        }
        SafeRelease(&pPath);
    }
        }


        //==================else player 2
        else { // Player 2
         // Player 2: Arrow left of P2 box, pointing right (or right of P2 box pointing left?)
         // Let's keep it consistent: Arrow left of the active player's box, pointing right.
// Let's keep it consistent: Arrow left of the active player's box, pointing right.
arrowBackX = p2Rect.left - 25.0f; // Position left of the box
arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
// Define points for right-pointing arrow
D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back

ID2D1PathGeometry* pPath = nullptr;
if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
    ID2D1GeometrySink* pSink = nullptr;
    if (SUCCEEDED(pPath->Open(&pSink))) {
        pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
        pSink->AddLine(pt2);
        pSink->AddLine(pt3);
        pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
        pSink->Close();
        SafeRelease(&pSink);
        pRT->FillGeometry(pPath, pArrowBrush);
    }
    SafeRelease(&pPath);
}
        }
        */

        // --- MODIFIED: Foul Text (Large Red, Bottom Center) ---
    if (foulCommitted && currentGameState != SHOT_IN_PROGRESS) {
        ID2D1SolidColorBrush* pFoulBrush = nullptr;
        pRT->CreateSolidColorBrush(FOUL_TEXT_COLOR, &pFoulBrush);
        if (pFoulBrush && pLargeTextFormat) {
            // Calculate Rect for bottom-middle area
            float foulWidth = 200.0f; // Adjust width as needed
            float foulHeight = 60.0f;
            float foulLeft = TABLE_LEFT + (TABLE_WIDTH / 2.0f) - (foulWidth / 2.0f);
            // Position below the pocketed balls bar
            float foulTop = pocketedBallsBarRect.bottom + 10.0f;
            D2D1_RECT_F foulRect = D2D1::RectF(foulLeft, foulTop, foulLeft + foulWidth, foulTop + foulHeight);

            // --- Set text alignment to center for foul text ---
            pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

            pRT->DrawText(L""FOUL!"", 5, pLargeTextFormat, &foulRect, pFoulBrush);

            // --- Restore default alignment for large text if needed elsewhere ---
            // pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
            // pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

            SafeRelease(&pFoulBrush);
        }
    }

    // --- 8-Ball Pocket Selection Arrow & Prompt ---
    if (currentGameState == CHOOSING_POCKET_P1 || currentGameState == CHOOSING_POCKET_P2) {
        // Determine which pocket to highlight (default to Top-Right if unset)
        int idx = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        if (idx < 0) idx = 2;

        // Draw the downward arrow
        ID2D1SolidColorBrush* pArrowBrush = nullptr;
        pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
        if (pArrowBrush) {
            D2D1_POINT_2F P = pocketPositions[idx];
            D2D1_POINT_2F tri[3] = {
                {P.x - 10.0f, P.y - 30.0f},
                {P.x + 10.0f, P.y - 30.0f},
                {P.x        , P.y - 10.0f}
            };
            ID2D1PathGeometry* geom = nullptr;
            pFactory->CreatePathGeometry(&geom);
            ID2D1GeometrySink* sink = nullptr;
            geom->Open(&sink);
            sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
            sink->AddLines(&tri[1], 2);
            sink->EndFigure(D2D1_FIGURE_END_CLOSED);
            sink->Close();
            pRT->FillGeometry(geom, pArrowBrush);
            SafeRelease(&sink);
            SafeRelease(&geom);
            SafeRelease(&pArrowBrush);
        }

        // Draw “Choose a pocket...” text under the table
        D2D1_RECT_F prompt = D2D1::RectF(
            TABLE_LEFT,
            TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
            TABLE_RIGHT,
            TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
        );
        pRT->DrawText(
            L""Choose a pocket..."",
            (UINT32)wcslen(L""Choose a pocket...""),
            pTextFormat,
            &prompt,
            pBrush
        );

        return; // Skip normal turn/foul text
    }


    // Show AI Thinking State (Unchanged from previous step)
    if (currentGameState == AI_THINKING && pTextFormat) {
        ID2D1SolidColorBrush* pThinkingBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pThinkingBrush);
        if (pThinkingBrush) {
            D2D1_RECT_F thinkingRect = p2Rect;
            thinkingRect.top += 20; // Offset within P2 box
            // Ensure default text alignment for this
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
            pRT->DrawText(L""Thinking..."", 11, pTextFormat, &thinkingRect, pThinkingBrush);
            SafeRelease(&pThinkingBrush);
        }
    }

    SafeRelease(&pBrush);

    // --- Draw CHEAT MODE label if active ---
    if (cheatModeEnabled) {
        ID2D1SolidColorBrush* pCheatBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Red), &pCheatBrush);
        if (pCheatBrush && pTextFormat) {
            D2D1_RECT_F cheatTextRect = D2D1::RectF(
                TABLE_LEFT + 10.0f,
                TABLE_TOP + 10.0f,
                TABLE_LEFT + 200.0f,
                TABLE_TOP + 40.0f
            );
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
            pRT->DrawText(L""CHEAT MODE ON"", wcslen(L""CHEAT MODE ON""), pTextFormat, &cheatTextRect, pCheatBrush);
        }
        SafeRelease(&pCheatBrush);
    }
}

void DrawPowerMeter(ID2D1RenderTarget* pRT) {
    // Draw Border
    ID2D1SolidColorBrush* pBorderBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
    if (!pBorderBrush) return;
    pRT->DrawRectangle(&powerMeterRect, pBorderBrush, 2.0f);
    SafeRelease(&pBorderBrush);

    // Create Gradient Fill
    ID2D1GradientStopCollection* pGradientStops = nullptr;
    ID2D1LinearGradientBrush* pGradientBrush = nullptr;
    D2D1_GRADIENT_STOP gradientStops[4];
    gradientStops[0].position = 0.0f;
    gradientStops[0].color = D2D1::ColorF(D2D1::ColorF::Green);
    gradientStops[1].position = 0.45f;
    gradientStops[1].color = D2D1::ColorF(D2D1::ColorF::Yellow);
    gradientStops[2].position = 0.7f;
    gradientStops[2].color = D2D1::ColorF(D2D1::ColorF::Orange);
    gradientStops[3].position = 1.0f;
    gradientStops[3].color = D2D1::ColorF(D2D1::ColorF::Red);

    pRT->CreateGradientStopCollection(gradientStops, 4, &pGradientStops);
    if (pGradientStops) {
        D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES props = {};
        props.startPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.bottom);
        props.endPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.top);
        pRT->CreateLinearGradientBrush(props, pGradientStops, &pGradientBrush);
        SafeRelease(&pGradientStops);
    }

    // Calculate Fill Height
    float fillRatio = 0;
    //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
        // Determine if power meter should reflect shot power (human aiming or AI preparing)
    bool humanIsAimingPower = isAiming && (currentGameState == AIMING || currentGameState == BREAKING);
    // NEW Condition: AI is displaying its aim, so show its chosen power
    bool aiIsVisualizingPower = (isPlayer2AI && currentPlayer == 2 &&
        currentGameState == AI_THINKING && aiIsDisplayingAim);

    if (humanIsAimingPower || aiIsVisualizingPower) { // Use the new condition
        fillRatio = shotPower / MAX_SHOT_POWER;
    }
    float fillHeight = (powerMeterRect.bottom - powerMeterRect.top) * fillRatio;
    D2D1_RECT_F fillRect = D2D1::RectF(
        powerMeterRect.left,
        powerMeterRect.bottom - fillHeight,
        powerMeterRect.right,
        powerMeterRect.bottom
    );

    if (pGradientBrush) {
        pRT->FillRectangle(&fillRect, pGradientBrush);
        SafeRelease(&pGradientBrush);
    }

    // Draw scale notches
    ID2D1SolidColorBrush* pNotchBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pNotchBrush);
    if (pNotchBrush) {
        for (int i = 0; i <= 8; ++i) {
            float y = powerMeterRect.top + (powerMeterRect.bottom - powerMeterRect.top) * (i / 8.0f);
            pRT->DrawLine(
                D2D1::Point2F(powerMeterRect.right + 2.0f, y),
                D2D1::Point2F(powerMeterRect.right + 8.0f, y),
                pNotchBrush,
                1.5f
            );
        }
        SafeRelease(&pNotchBrush);
    }

    // Draw ""Power"" Label Below Meter
    if (pTextFormat) {
        ID2D1SolidColorBrush* pTextBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pTextBrush);
        if (pTextBrush) {
            D2D1_RECT_F textRect = D2D1::RectF(
                powerMeterRect.left - 20.0f,
                powerMeterRect.bottom + 8.0f,
                powerMeterRect.right + 20.0f,
                powerMeterRect.bottom + 38.0f
            );
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
            pRT->DrawText(L""Power"", 5, pTextFormat, &textRect, pTextBrush);
            SafeRelease(&pTextBrush);
        }
    }

    // Draw Glow Effect if fully charged or fading out
    static float glowPulse = 0.0f;
    static bool glowIncreasing = true;
    static float glowFadeOut = 0.0f; // NEW: tracks fading out

    if (shotPower >= MAX_SHOT_POWER * 0.99f) {
        // While fully charged, keep pulsing normally
        if (glowIncreasing) {
            glowPulse += 0.02f;
            if (glowPulse >= 1.0f) glowIncreasing = false;
        }
        else {
            glowPulse -= 0.02f;
            if (glowPulse <= 0.0f) glowIncreasing = true;
        }
        glowFadeOut = 1.0f; // Reset fade out to full
    }
    else if (glowFadeOut > 0.0f) {
        // If shot fired, gradually fade out
        glowFadeOut -= 0.02f;
        if (glowFadeOut < 0.0f) glowFadeOut = 0.0f;
    }

    if (glowFadeOut > 0.0f) {
        ID2D1SolidColorBrush* pGlowBrush = nullptr;
        float effectiveOpacity = (0.3f + 0.7f * glowPulse) * glowFadeOut;
        pRT->CreateSolidColorBrush(
            D2D1::ColorF(D2D1::ColorF::Red, effectiveOpacity),
            &pGlowBrush
        );
        if (pGlowBrush) {
            float glowCenterX = (powerMeterRect.left + powerMeterRect.right) / 2.0f;
            float glowCenterY = powerMeterRect.top;
            D2D1_ELLIPSE glowEllipse = D2D1::Ellipse(
                D2D1::Point2F(glowCenterX, glowCenterY - 10.0f),
                12.0f + 3.0f * glowPulse,
                6.0f + 2.0f * glowPulse
            );
            pRT->FillEllipse(&glowEllipse, pGlowBrush);
            SafeRelease(&pGlowBrush);
        }
    }
}

void DrawSpinIndicator(ID2D1RenderTarget* pRT) {
    ID2D1SolidColorBrush* pWhiteBrush = nullptr;
    ID2D1SolidColorBrush* pRedBrush = nullptr;

    pRT->CreateSolidColorBrush(CUE_BALL_COLOR, &pWhiteBrush);
    pRT->CreateSolidColorBrush(ENGLISH_DOT_COLOR, &pRedBrush);

    if (!pWhiteBrush || !pRedBrush) {
        SafeRelease(&pWhiteBrush);
        SafeRelease(&pRedBrush);
        return;
    }

    // Draw White Ball Background
    D2D1_ELLIPSE bgEllipse = D2D1::Ellipse(spinIndicatorCenter, spinIndicatorRadius, spinIndicatorRadius);
    pRT->FillEllipse(&bgEllipse, pWhiteBrush);
    pRT->DrawEllipse(&bgEllipse, pRedBrush, 0.5f); // Thin red border


    // Draw Red Dot for Spin Position
    float dotRadius = 4.0f;
    float dotX = spinIndicatorCenter.x + cueSpinX * (spinIndicatorRadius - dotRadius); // Keep dot inside edge
    float dotY = spinIndicatorCenter.y + cueSpinY * (spinIndicatorRadius - dotRadius);
    D2D1_ELLIPSE dotEllipse = D2D1::Ellipse(D2D1::Point2F(dotX, dotY), dotRadius, dotRadius);
    pRT->FillEllipse(&dotEllipse, pRedBrush);

    SafeRelease(&pWhiteBrush);
    SafeRelease(&pRedBrush);
}


void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT) {
    ID2D1SolidColorBrush* pBgBrush = nullptr;
    ID2D1SolidColorBrush* pBallBrush = nullptr;

    // Ensure render target is valid before proceeding
    if (!pRT) return;

    HRESULT hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black, 0.8f), &pBgBrush); // Semi-transparent black
    if (FAILED(hr)) { SafeRelease(&pBgBrush); return; } // Exit if brush creation fails

    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBallBrush); // Placeholder, color will be set per ball
    if (FAILED(hr)) {
        SafeRelease(&pBgBrush);
        SafeRelease(&pBallBrush);
        return; // Exit if brush creation fails
    }

    // Draw the background bar (rounded rect)
    D2D1_ROUNDED_RECT roundedRect = D2D1::RoundedRect(pocketedBallsBarRect, 10.0f, 10.0f); // Corner radius 10
    float baseAlpha = 0.8f;
    float flashBoost = pocketFlashTimer * 0.5f; // Make flash effect boost alpha slightly
    float finalAlpha = std::min(1.0f, baseAlpha + flashBoost);
    pBgBrush->SetOpacity(finalAlpha);
    pRT->FillRoundedRectangle(&roundedRect, pBgBrush);
    pBgBrush->SetOpacity(1.0f); // Reset opacity after drawing

    // --- Draw small circles for pocketed balls inside the bar ---

    // Calculate dimensions based on the bar's height for better scaling
    float barHeight = pocketedBallsBarRect.bottom - pocketedBallsBarRect.top;
    float ballDisplayRadius = barHeight * 0.30f; // Make balls slightly smaller relative to bar height
    float spacing = ballDisplayRadius * 2.2f; // Adjust spacing slightly
    float padding = spacing * 0.75f; // Add padding from the edges
    float center_Y = pocketedBallsBarRect.top + barHeight / 2.0f; // Vertical center

    // Starting X positions with padding
    float currentX_P1 = pocketedBallsBarRect.left + padding;
    float currentX_P2 = pocketedBallsBarRect.right - padding; // Start from right edge minus padding

    int p1DrawnCount = 0;
    int p2DrawnCount = 0;
    const int maxBallsToShow = 7; // Max balls per player in the bar

    for (const auto& b : balls) {
        if (b.isPocketed) {
            // Skip cue ball and 8-ball in this indicator
            if (b.id == 0 || b.id == 8) continue;

            bool isPlayer1Ball = (player1Info.assignedType != BallType::NONE && b.type == player1Info.assignedType);
            bool isPlayer2Ball = (player2Info.assignedType != BallType::NONE && b.type == player2Info.assignedType);

            if (isPlayer1Ball && p1DrawnCount < maxBallsToShow) {
                pBallBrush->SetColor(b.color);
                // Draw P1 balls from left to right
                D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P1 + p1DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                pRT->FillEllipse(&ballEllipse, pBallBrush);
                p1DrawnCount++;
            }
            else if (isPlayer2Ball && p2DrawnCount < maxBallsToShow) {
                pBallBrush->SetColor(b.color);
                // Draw P2 balls from right to left
                D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P2 - p2DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                pRT->FillEllipse(&ballEllipse, pBallBrush);
                p2DrawnCount++;
            }
            // Note: Balls pocketed before assignment or opponent balls are intentionally not shown here.
            // You could add logic here to display them differently if needed (e.g., smaller, grayed out).
        }
    }

    SafeRelease(&pBgBrush);
    SafeRelease(&pBallBrush);
}

void DrawBallInHandIndicator(ID2D1RenderTarget* pRT) {
    if (!isDraggingCueBall && (currentGameState != BALL_IN_HAND_P1 && currentGameState != BALL_IN_HAND_P2 && currentGameState != PRE_BREAK_PLACEMENT)) {
        return; // Only show when placing/dragging
    }

    Ball* cueBall = GetCueBall();
    if (!cueBall) return;

    ID2D1SolidColorBrush* pGhostBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.6f), &pGhostBrush); // Semi-transparent white

    if (pGhostBrush) {
        D2D1_POINT_2F drawPos;
        if (isDraggingCueBall) {
            drawPos = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
        }
        else {
            // If not dragging but in placement state, show at current ball pos
            drawPos = D2D1::Point2F(cueBall->x, cueBall->y);
        }

        // Check if the placement is valid before drawing differently?
        bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
        bool isValid = IsValidCueBallPosition(drawPos.x, drawPos.y, behindHeadstring);

        if (!isValid) {
            // Maybe draw red outline if invalid placement?
            pGhostBrush->SetColor(D2D1::ColorF(D2D1::ColorF::Red, 0.6f));
        }


        D2D1_ELLIPSE ghostEllipse = D2D1::Ellipse(drawPos, BALL_RADIUS, BALL_RADIUS);
        pRT->FillEllipse(&ghostEllipse, pGhostBrush);
        pRT->DrawEllipse(&ghostEllipse, pGhostBrush, 1.0f); // Outline

        SafeRelease(&pGhostBrush);
    }
}

void DrawPocketSelectionIndicator(ID2D1RenderTarget* pRT) {
    int pocketToIndicate = -1;
    // A human player is actively choosing if they are in the CHOOSING_POCKET state.
    bool isHumanChoosing = (currentGameState == CHOOSING_POCKET_P1 || (currentGameState == CHOOSING_POCKET_P2 && !isPlayer2AI));

    if (isHumanChoosing) {
        // When choosing, show the currently selected pocket (which has a default).
        pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
    }
    else if (IsPlayerOnEightBall(currentPlayer)) {
        // If it's a normal turn but the player is on the 8-ball, show their called pocket as a reminder.
        pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
    }

    if (pocketToIndicate < 0 || pocketToIndicate > 5) {
        return; // Don't draw if no pocket is selected or relevant.
    }

    ID2D1SolidColorBrush* pArrowBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Yellow, 0.9f), &pArrowBrush);
    if (!pArrowBrush) return;

    // ... The rest of your arrow drawing geometry logic remains exactly the same ...
    // (No changes needed to the points/path drawing, only the logic above)
    D2D1_POINT_2F targetPocketCenter = pocketPositions[pocketToIndicate];
    float arrowHeadSize = HOLE_VISUAL_RADIUS * 0.5f;
    float arrowShaftLength = HOLE_VISUAL_RADIUS * 0.3f;
    float arrowShaftWidth = arrowHeadSize * 0.4f;
    float verticalOffsetFromPocketCenter = HOLE_VISUAL_RADIUS * 1.6f;
    D2D1_POINT_2F tip, baseLeft, baseRight, shaftTopLeft, shaftTopRight, shaftBottomLeft, shaftBottomRight;

    if (targetPocketCenter.y == TABLE_TOP) {
        tip = D2D1::Point2F(targetPocketCenter.x, targetPocketCenter.y + verticalOffsetFromPocketCenter + arrowHeadSize);
        baseLeft = D2D1::Point2F(targetPocketCenter.x - arrowHeadSize / 2.0f, targetPocketCenter.y + verticalOffsetFromPocketCenter);
        baseRight = D2D1::Point2F(targetPocketCenter.x + arrowHeadSize / 2.0f, targetPocketCenter.y + verticalOffsetFromPocketCenter);
        shaftTopLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y);
        shaftTopRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y);
        shaftBottomLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y - arrowShaftLength);
        shaftBottomRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y - arrowShaftLength);
    }
    else {
        tip = D2D1::Point2F(targetPocketCenter.x, targetPocketCenter.y - verticalOffsetFromPocketCenter - arrowHeadSize);
        baseLeft = D2D1::Point2F(targetPocketCenter.x - arrowHeadSize / 2.0f, targetPocketCenter.y - verticalOffsetFromPocketCenter);
        baseRight = D2D1::Point2F(targetPocketCenter.x + arrowHeadSize / 2.0f, targetPocketCenter.y - verticalOffsetFromPocketCenter);
        shaftTopLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y + arrowShaftLength);
        shaftTopRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y + arrowShaftLength);
        shaftBottomLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y);
        shaftBottomRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y);
    }

    ID2D1PathGeometry* pPath = nullptr;
    if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
        ID2D1GeometrySink* pSink = nullptr;
        if (SUCCEEDED(pPath->Open(&pSink))) {
            pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
            pSink->AddLine(baseLeft); pSink->AddLine(shaftBottomLeft); pSink->AddLine(shaftTopLeft);
            pSink->AddLine(shaftTopRight); pSink->AddLine(shaftBottomRight); pSink->AddLine(baseRight);
            pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
            pSink->Close();
            SafeRelease(&pSink);
            pRT->FillGeometry(pPath, pArrowBrush);
        }
        SafeRelease(&pPath);
    }
    SafeRelease(&pArrowBrush);
}"
C6iYgihz,2025-06-30T17:34:52.479,powerampache,PHP,Monday 30th of June 2025 09:34:51 AM CDT,"1.00-64 (64) - DB: 82
java.lang.NullPointerException
	at luci.sixsixsix.powerampache2.data.SongsRepositoryImpl.scrobbleEverything(SongsRepositoryImpl.kt:593)
	at luci.sixsixsix.powerampache2.data.SongsRepositoryImpl.access$scrobbleEverything(SongsRepositoryImpl.kt:77)
	at luci.sixsixsix.powerampache2.data.SongsRepositoryImpl$scrobbleEverything$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:108)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:793)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:697)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:684)

"
WnTYCtF2,Untitled,keselyoleren,Python,Monday 30th of June 2025 09:28:05 AM CDT,"import openslide
import boto3
from io import BytesIO
from slugify import slugify
import json
import os
import glob

class SVSFileProcessor:
    def __init__(self, svs_file_path, file_name, aws_access_key, aws_secret_key, s3_bucket_name, s3_region):
        self.svs_file_path = svs_file_path
        self.original_filename = os.path.basename(svs_file_path)
        self.s3_bucket_name = s3_bucket_name
        self.s3_region = s3_region
        self.safe_file_name = slugify(file_name)
        self.s3_client = None
        self.wsi = None

        # Initialize S3 client
        try:
            self.s3_client = boto3.client(
                's3',
                aws_access_key_id=aws_access_key,
                aws_secret_access_key=aws_secret_key,
                region_name=self.s3_region
            )
        except Exception as e:
            print(f""Kesalahan Kredensial AWS: {str(e)}"")

        # Open the SVS file
        try:
            self.wsi = openslide.OpenSlide(self.svs_file_path)
            print(f""File SVS '{self.original_filename}' berhasil dibuka."")
        except openslide.OpenSlideError as e:
            print(f""Gagal membuka file SVS '{self.original_filename}': {e}"")

    def extract_properties(self):
        if not self.wsi:
            return []

        data = []
        try:
            properties = self.wsi.properties
            for key, value in properties.items():
                # Clean up key for better compatibility (e.g., in JSON)
                clean_key = key.replace(' ', '-').replace('.', '-')
                data.append({clean_key: str(value)})
        except Exception as e:
            print(f""Terjadi kesalahan saat mengekstrak properti: {e}"")
        
        return data

    def generate_and_upload_thumbnail(self, thumb_size=(256, 256)):
        if not self.wsi or not self.s3_client:
            print(""Tidak dapat membuat thumbnail. File SVS atau klien S3 tidak diinisialisasi."")
            return None

        try:
            thumb_image = self.wsi.get_thumbnail(thumb_size)
            
            thumb_buffer = BytesIO()
            thumb_image.save(thumb_buffer, ""PNG"")
            thumb_buffer.seek(0)
            s3_key = f""thumbnails/{self.safe_file_name}_thumb.png""
            
            print(f""Mengunggah thumbnail ke bucket S3 '{self.s3_bucket_name}' dengan key '{s3_key}'..."")

            self.s3_client.upload_fileobj(
                thumb_buffer,
                self.s3_bucket_name,
                s3_key,
            )

            s3_url = f""https://{self.s3_bucket_name}.s3.{self.s3_region}.amazonaws.com/{s3_key}""
            print(f""Thumbnail berhasil diunggah. URL: {s3_url}"")            
            return s3_url
        except Exception as e:
            print(f""Gagal mengunggah thumbnail: {e}"")
            return None

    def process_file(self):
        if not self.wsi:
            return {
                ""filename"": self.original_filename,
                ""properties"": [],
                ""thumbnail"": None,
                ""error"": ""File SVS tidak dapat dibaca atau rusak.""
            }

        properties_data = self.extract_properties()
        thumbnail_url = self.generate_and_upload_thumbnail()

        return {
            ""filename"": self.original_filename,
            ""properties"": properties_data,
            ""thumbnail"": thumbnail_url
        }

    def __del__(self):
        if self.wsi:
            self.wsi.close()

def process_svs_batch(directory_path, aws_access_key, aws_secret_key, s3_bucket_name, s3_region):
    search_pattern = os.path.join(directory_path, '*.svs')
    file_paths = glob.glob(search_pattern)

    if not file_paths:
        print(f""Peringatan: Tidak ada file .svs yang ditemukan di '{directory_path}'"")
        return json.dumps([], indent=4)

    print(f""Ditemukan {len(file_paths)} file .svs untuk diproses."")
    all_results = []

    for file_path in file_paths:
        print(""\n"" + ""=""*20 + f"" Memproses {os.path.basename(file_path)} "" + ""=""*20)
        file_name_base = os.path.splitext(os.path.basename(file_path))[0]

        processor = SVSFileProcessor(
            svs_file_path=file_path,
            file_name=file_name_base,
            aws_access_key=aws_access_key,
            aws_secret_key=aws_secret_key,
            s3_bucket_name=s3_bucket_name,
            s3_region=s3_region
        )
        
        result = processor.process_file()
        all_results.append(result)

    return json.dumps(all_results, indent=4)


# --- CONTOH PENGGUNAAN ---
if __name__ == '__main__':
    SVS_DIRECTORY = input(""Masukkan path lengkap ke direktori yang berisi file .svs .tiff \n contoh /Users/f/keselyoleren/neurabot/product/data/slide : "")
    AWS_ACCESS_KEY_ID = os.environ.get('AWS_ACCESS_KEY_ID', 'AKIA5XSKJQZJZCKNAUKI')
    AWS_SECRET_ACCESS_KEY = os.environ.get('AWS_SECRET_ACCESS_KEY', '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')
    S3_BUCKET = os.environ.get('S3_BUCKET', 'mylab-production')
    S3_REGION = os.environ.get('S3_REGION', 'ap-southeast-3')

    if not os.path.isdir(SVS_DIRECTORY):
        print(""=""*50)
        print(f""Error: Direktori tidak ditemukan di '{SVS_DIRECTORY}'"")
        print(""Harap jalankan kembali skrip dan masukkan path folder yang benar."")
        print(""Contoh /Users/f/keselyoleren/neurabot/product/data/slide"")
        print(""=""*50)
    elif 'YOUR_AWS' in AWS_ACCESS_KEY_ID or 'your-s3' in S3_BUCKET:
        print(""=""*50)
        print(f""Peringatan: Kredensial AWS atau nama bucket belum diatur."")
        print(""Harap perbarui variabel kredensial AWS atau atur melalui environment variables."")
        print(""=""*50)
    else:
        json_output = process_svs_batch(
            directory_path=SVS_DIRECTORY,
            aws_access_key=AWS_ACCESS_KEY_ID,
            aws_secret_key=AWS_SECRET_ACCESS_KEY,
            s3_bucket_name=S3_BUCKET,
            s3_region=S3_REGION
        )
        
        output_filename = 'svs_metadata_output.json'
        print(f""\n\n--- HASIL OUTPUT JSON GABUNGAN ---"")
        print(f""Menyimpan hasil ke file '{output_filename}'..."")
        with open(output_filename, 'w') as f:
            f.write(json_output)
        print(""Selesai."")

"
fAQuvY9v,Descompunere rapida in factori primi,Hezov,C++,Monday 30th of June 2025 08:29:35 AM CDT,"// Dandu-se n numere naturale, sa se afiseze descompunerea in factori primi a acestora.
// n <= 10^6, fiecare numar este pana in 10^6
#include <iostream>
using namespace std;
const int mxN = 1e6;
int ciur[mxN+10];
void build_ciur()
{
    for(int i = 2;i<=mxN;i++)
        if(ciur[i] == 0)
        for(int j = i;j<=mxN;j+=i)
            if(ciur[j] == 0)
                ciur[j] = i;
}
int main()
{
    build_ciur();
    int n, x ;
    cin >> n ;
    for(int i = 1;i<=n;i++)
    {
        cin >> x;
        cout << ""Descompunerea pentru "" << x << "":\n"";
        while(ciur[x] != 0)
        {
            int p = ciur[x], exp = 0;
            while(ciur[x] == p)
                exp++, x /= ciur[x];
            cout << p << '^' << exp << '\n';
        }
        cout << '\n';
    }
    return 0;
}
"
CHnzm94f,Three strings,Hezov,C++,Monday 30th of June 2025 08:06:16 AM CDT,"// https://codeforces.com/contest/2050/problem/E

#include <iostream>
using namespace std;
typedef long long ll;
const int INF = 1e9;
int dp[1001][1001];
void solve()
{
    string a, b, c;
    cin >> a >> b >> c;
    for(int i = 0;i<=a.length();i++)
        for(int j = 0;j<=b.length();j++)
        {
            if(i == 0 && j == 0) continue;
            dp[i][j] = INF;
            int aPoz = i-1, bPoz = j-1, cPoz = i + j - 1;
            if(j-1>=0)
                dp[i][j] = min(dp[i][j], dp[i][j-1] + (b[bPoz] != c[cPoz]));
            if(i-1>=0)
                dp[i][j] = min(dp[i][j], dp[i-1][j] + (a[aPoz] != c[cPoz]));
        }
    int aLen = a.length(), bLen = b.length(), cLen = c.length();
    cout << min(dp[aLen][cLen-aLen],dp[cLen-bLen][bLen]) << '\n';
     for(int i = 0;i<=a.length();i++)
        for(int j = 0;j<=b.length();j++)
            dp[i][j] = 0;

}
int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    int t; cin >> t;
    while(t--) solve();
    return 0;
}"
hHYABC8p,Untitled,tekashiytb,C++,Monday 30th of June 2025 08:02:12 AM CDT,"
    /*
        Substituí EntranceData[id][eEntrancePos][0] && 
        por EntranceData[id][eEntrancePos][2] != 0.0 
        agora precisa verificar a questão do interior e world que está setando, só com esse código não tenho como fazer muita coisa.
    */
    
Entrance_Refresh(id)
{
    if (!EntranceData[id][eEntranceValid])
        return 0;

    if (IsValidDynamic3DTextLabel(EntranceData[id][eEntranceText3D]))
        DestroyDynamic3DTextLabel(EntranceData[id][eEntranceText3D]);

    if (IsValidDynamic3DTextLabel(EntranceData[id][eEntranceTaxText3D]))
        DestroyDynamic3DTextLabel(EntranceData[id][eEntranceTaxText3D]);

    if (IsValidDynamicPickup(EntranceData[id][eEntrancePickup]))
        DestroyDynamicPickup(EntranceData[id][eEntrancePickup]);

    if(EntranceData[id][eEntrancePos][0] != 0.0 || EntranceData[id][eEntrancePos][1] != 0.0 || EntranceData[id][eEntrancePos][2] != 0.0) 
    {
        EntranceData[id][eEntrancePickup] = CreateDynamicPickup(EntranceData[id][eEntrancePickupID], 23, EntranceData[id][eEntrancePos][0], EntranceData[id][eEntrancePos][1], EntranceData[id][eEntrancePos][2] + 0.2, EntranceData[id][eEntranceEVW], EntranceData[id][eEntranceExterior]);
    }
    if(EntranceData[id][eEntranceTax] && (EntranceData[id][eEntrancePos][0] != 0.0 || EntranceData[id][eEntrancePos][1] != 0.0 || EntranceData[id][eEntrancePos][2] != 0.0)) 
    {
        EntranceData[id][eEntranceTaxText3D] = CreateDynamic3DTextLabel(va_return(""{EAEA00}Entrada: %s"", FormatMoney(EntranceData[id][eEntranceTax])), COLOR_WHITE, EntranceData[id][eEntrancePos][0], EntranceData[id][eEntrancePos][1], EntranceData[id][eEntrancePos][2], 30.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 1, EntranceData[id][eEntranceWorld], EntranceData[id][eEntranceInterior]);
    }
    if(EntranceData[id][eEntranceInt][0] != 0.0 || EntranceData[id][eEntranceInt][1] != 0.0 || EntranceData[id][eEntranceInt][2] != 0.0) 
    {
        EntranceData[id][eEntranceText3D] = CreateDynamic3DTextLabel(""Saída"", COLOR_WHITE, EntranceData[id][eEntranceInt][0], EntranceData[id][eEntranceInt][1], EntranceData[id][eEntranceInt][2], 30.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 1, EntranceData[id][eEntranceWorld], EntranceData[id][eEntranceInterior]);
    }
    return 1;
}"
