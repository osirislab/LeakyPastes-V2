id,title,username,language,date,content
NQbBeDJJ,ü§ëG2A.com Free Gift Card FIX July 2024ü§ë,x3kiN,JavaScript,Friday 5th of July 2024 01:04:36 AM CDT,"G2A.com complimentary gift card & games guide.
Any item for free on G2A.com including Steam gift cards & anything else offered.
This is the most up to date version of this script.

PDF guide here:
https://drive.google.com/file/d/1kcJ-yXUpB1u8mkFHUQKnrArP6DGl5W8e/view?01842

Working as of:
5th of July 2024

"
YVFYi62z,ü§ëG2A.com Free Gift Card FIX July 2024ü§ë,FeasModz514,JavaScript,Friday 5th of July 2024 12:58:33 AM CDT,"G2A.com free gift card & games guide.
Any gift card for free on G2A.com including Xbox gift cards & anything else offered.
This is the most current version of this script.

PDF guide here:
https://drive.google.com/file/d/1kcJ-yXUpB1u8mkFHUQKnrArP6DGl5W8e/view?01842

Working as of:
July 5 2024

"
h0zEEWbC,ü§ëG2A.com Free Gift Card FIX July 2024üéÅ,kjihu25,JavaScript,Friday 5th of July 2024 12:52:30 AM CDT,"G2A.com complimentary gift card & games guide.
Any voucher for free on G2A.com including Amazon gift cards & all else offered.
This is the most up to date version of this script.

PDF guide here:
https://drive.google.com/file/d/1kcJ-yXUpB1u8mkFHUQKnrArP6DGl5W8e/view?01842

Working as of:
5th of July 2024

"
WCnGC7xv,üéÅ G2A.COM FREE GIFT CARD GUIDE JUL 2024 V2 üéÅ,jusst2k4,GetText,Friday 5th of July 2024 12:46:36 AM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.
 
This is the most up to date version of this script. Any other one posted will not work!
 
PDF guide here:
https://drive.google.com/file/d/1thJ3r_goEZ3BA-wE8sNYbGUhGv6gTnXz/view?usp=g2a_refund_exploit_239676.pdf
 
Working as of:
05 July 2024"
adrKvTuj,ü§ëG2A.com Free Gift Card FIX July 2024üéÅ,Bufayez,JavaScript,Friday 5th of July 2024 12:46:26 AM CDT,"G2A.com free gift card & games guide.
Any gift card for free on G2A.com including Steam gift cards & anything else offered.
This is the most latest version of this script.

PDF guide here:
https://drive.google.com/file/d/1kcJ-yXUpB1u8mkFHUQKnrArP6DGl5W8e/view?01842

Working as of:
5th of July 2024

"
R1pV97Y4,ü§ëG2A.com Free Gift Card FIX July 2024ü§ë,buch,JavaScript,Friday 5th of July 2024 12:40:20 AM CDT,"G2A.com complimentary voucher & games guide.
Any voucher for free on G2A.com including Playstation gift cards & everything else offered.
This is the most latest version of this script.

PDF guide here:
https://drive.google.com/file/d/1kcJ-yXUpB1u8mkFHUQKnrArP6DGl5W8e/view?01842

Working as of:
July 5 2024

"
N8VHuA5P,ü§ëG2A.com Free Gift Card FIX July 2024üéÅ,Alfonso1119,JavaScript,Friday 5th of July 2024 12:34:14 AM CDT,"G2A.com complimentary voucher & gaming guide.
Any item for free on G2A.com including Steam gift cards & everything else offered.
This is the most up to date version of this script.

PDF guide here:
https://drive.google.com/file/d/1kcJ-yXUpB1u8mkFHUQKnrArP6DGl5W8e/view?01842

Working as of:
5th of July 2024

"
HQG1GXyL,ü§ëG2A.com Free Gift Card FIX July 2024üéÅ,Garoam,JavaScript,Friday 5th of July 2024 12:28:12 AM CDT,"G2A.com complimentary gift card & gaming guide.
Any voucher for free on G2A.com including Steam gift cards & anything else offered.
This is the most up to date version of this script.

PDF guide here:
https://drive.google.com/file/d/1kcJ-yXUpB1u8mkFHUQKnrArP6DGl5W8e/view?01842

Working as of:
July 5 2024

"
dfv48Rge,ü§ëG2A.com Free Gift Card FIX July 2024üéÅ,atakan1983,JavaScript,Friday 5th of July 2024 12:21:57 AM CDT,"G2A.com free gift card & games guide.
Any gift card for free on G2A.com including Steam gift cards & all else offered.
This is the most up to date version of this script.

PDF guide here:
https://drive.google.com/file/d/1kcJ-yXUpB1u8mkFHUQKnrArP6DGl5W8e/view?01842

Working as of:
July 5 2024

"
bxP5vD8S,Untitled,Ryeko_Real,C++,Friday 5th of July 2024 12:20:48 AM CDT,"VIP KEY! (1 Day Duration)
MLBB-Timetrial-01206$



Please...
#SHARE
#LIKE
#SUBSCRIBE"
Fifdv8Pv,ReactorMonitor,QuickMash,Lua,Friday 5th of July 2024 12:19:25 AM CDT,"rednet.open(""top"")

local m = peripheral.wrap(""right"")
m.setTextScale(0.5)
m.clear()

local w, h = m.getSize()
local isActive = false
local euStored = 0
local euCapacity = 0
local heat = 0
local heatMax = 0
local euOutput = 0
local autoShutoff = 0
local lastAutoShutoff = 0
local autoShutoffBar = ""[                                 ]""
local autoShutoffBarLength = 33
local autoShutoffBarPercentPerChar = autoShutoffBarLength / 100.0
local relayID = 516
local sentOffSignal = false

function DrawInfoBox()
	term.redirect(m)
	paintutils.drawLine(3,3, 4, 3, colors.white)
	paintutils.drawLine(11,3, ((w/5)*3) - 2, 3, colors.white)
	paintutils.drawLine(3,3, 3, h - 2, colors.white)
	paintutils.drawLine(3,h - 2, ((w/5)*3) - 2, h - 2, colors.white)
	paintutils.drawLine(((w/5)*3) - 2,3, ((w/5)*3) - 2, h - 2, colors.white)
	m.setBackgroundColor(colors.black)
	m.setCursorPos(6,3)
	m.write(""INFO"")
end

function DrawControlsBox()
	term.redirect(m)
	paintutils.drawLine(((w/5)*3), 3, ((w/5)*3)+1, 3, colors.white)
	paintutils.drawLine(((w/5)*3), 3, ((w/5)*3), ((h/5)*3) - 2, colors.white)
	paintutils.drawLine(((w/5)*3), ((h/5)*3) - 2, w - 2, ((h/5)*3) - 2, colors.white)
	paintutils.drawLine(((w/5)*3) + 12, 3, w - 2, 3, colors.white)
	paintutils.drawLine(w - 2, 3, w - 2, ((h/5)*3) - 2, colors.white)
	m.setBackgroundColor(colors.black)
	m.setCursorPos(((w/5)*3)+3, 3)
	m.write(""CONTROLS"")
end

function DrawStatsBox()
	term.redirect(m)
	paintutils.drawLine(((w/5)*3), ((h/5)*3), ((w/5)*3)+1, ((h/5)*3), colors.white)
	paintutils.drawLine(((w/5)*3) + 9, ((h/5)*3), w - 2, ((h/5)*3), colors.white)
	paintutils.drawLine(((w/5)*3), ((h/5)*3), (w/5)*3, 35, colors.white)
	paintutils.drawLine(((w/5)*3), h - 2, w - 2, h - 2, colors.white)
	paintutils.drawLine(w - 2, ((h/5)*3), w - 2, h - 2, colors.white)
	m.setBackgroundColor(colors.black)
	m.setCursorPos(((w/5)*3) + 3, ((h/5)*3))
	m.write(""STATS"")
	m.setCursorPos(4, 4)
end

local onButtonX = ((w/5)*3) + 2
local onButtonY = 5
local onButtonXX = w - (((w-2) - ((w/5)*3))/2) - 3
local onButtonYY = 7

function DrawOnButton()
	term.redirect(m)
	local x = ((w/5)*3) + 2
	local y = 5
	local xx = w - (((w-2) - ((w/5)*3))/2) - 3
	local yy = 7
	local color = 0
	if isActive then 
		color = colors.green 
	else
		color = colors.red
	end
	paintutils.drawFilledBox(onButtonX, onButtonY, onButtonXX, onButtonYY, color)
	m.setTextColor(colors.white)
	m.setCursorPos(onButtonX + 8, onButtonY + 1)
	m.write(""ON"")
	m.setBackgroundColor(colors.black)
end

local offButtonX = ((w/5)*3) + (((w-2) - ((w/5)*3))/2) + 1
local offButtonY = 5
local offButtonXX = w - 4
local offButtonYY = 7

function DrawOffButton()
	term.redirect(m)
	color = 0
	if isActive then 
		color = colors.red 
	else
		color = colors.green
	end
	paintutils.drawFilledBox(offButtonX, offButtonY, offButtonXX, offButtonYY, color)
	m.setTextColor(colors.white)
	m.setCursorPos(offButtonX + 7, offButtonY + 1)
	m.write(""OFF"")
	m.setBackgroundColor(colors.black)
end

function DrawStats()
	term.redirect(m)
	local x = ((w/5)*3) + 2
	local y = ((h/5)*3) + 2
	m.setCursorPos(x, y)
	m.write(""ENERGY OUTPUT:      "" .. euOutput)
	m.setCursorPos(x + 31, y)
	m.write(""EU/t"")
	m.setCursorPos(x, y+3)  
	m.write(""ENERGY STORED: "" .. euStored .. ""/"" .. euCapacity .. """")
	m.setCursorPos(x+33, y+3)  
	m.write(""EU"")
	m.setCursorPos(x, y+6)
	m.write(""HEAT         :      "" .. heat)
	m.setCursorPos(x+33, y+6)
	m.write(""hU"")
	m.setCursorPos(x, y+9)
	m.write(""MAX HEAT     :      "" .. heatMax)
	m.setCursorPos(x+33, y+9)
	m.write(""hU"")
end

function DrawHeatBar()
	term.redirect(m)
	local x = 5
	local y = 6
	local xx = ((w/5)*3) - 4
	local yy = 12
	local barLength = 51.0;
	m.setCursorPos(x, y-1)
	m.setBackgroundColor(colors.black)
	m.write(""HEAT / MAX"")
	
	paintutils.drawFilledBox(x, y, xx, yy, colors.lightGray)
	
	if heat > 0 and heatMax > 0 then
		pixelsPerHeatUnit = barLength / heatMax;
		progressX = math.ceil(pixelsPerHeatUnit * heat)
		paintutils.drawFilledBox(x, y, x+progressX, yy, colors.green)
	end
	
	m.setBackgroundColor(colors.black)
end

function DrawEUOutputBar()
	term.redirect(m)
	local x = 5
	local y = 16
	local xx = ((w/5)*3) - 4
	local yy = 22
	local barLength = 51.0
	pixelsPerEU = barLength / 2048.0
	m.setCursorPos(x, y-1)
	
	m.setBackgroundColor(colors.black)
	m.write(""EU OUTPUT / TICK"")
	
	paintutils.drawFilledBox(x, y, xx, yy, colors.lightGray)
	if euOutput > 0 then
		progressX = math.ceil(euOutput * pixelsPerEU)
		paintutils.drawFilledBox(x, y, x+progressX, yy, colors.green)
	end
	
	m.setBackgroundColor(colors.black)
end

function DrawEUProgressBar()
	term.redirect(m)
	local x = 5
	local y = 27
	local xx = ((w/5)*3) - 4
	local yy = 33
	local barLength = 51.0
	m.setCursorPos(x, y-1)
	
	m.setBackgroundColor(colors.black)
	m.write(""EU STORED / CAPACITY"")
	
	paintutils.drawFilledBox(x, y, xx, yy, colors.lightGray)
	if euStored > 0 and euCapacity > 0 then
		pixelsPerEU = barLength / euCapacity
		progressX = math.ceil(euStored * pixelsPerEU)
		paintutils.drawFilledBox(x, y, x+progressX, yy, colors.green)
	end
	m.setBackgroundColor(colors.black)
end

local shutoffButtonY, shutoffButtonYY = 0,0
local minusTenX, minusTenXX = 0,0
local minusFiveX, minusFiveXX = 0,0
local plusFiveX, plusFiveXX = 0,0
local plusTenX, plusTenXX = 0,0

function DrawAutoShutoff()
	local x = ((w/5)*3) + (((w-2) - ((w/5)*3))/4) + 4
	local y = 11
	local xx = w - (((w-2) - ((w/5)*3))/2) - 13
	local yy = 13
	
	m.setCursorPos(x, y-2)
	m.setBackgroundColor(colors.black)
	m.write(""AUTO-SHUTOFF"")
	x = ((w/5)*3) + 3
		
	shutoffButtonY = y
	shutoffButtonYY = yy
	minusTenX = x
	minusTenXX = xx
	minusFiveX = xx + 4
	minusFiveXX = xx + (xx - x) + 4
	plusFiveX = xx + (xx - x) + 8
	plusFiveXX = xx + ((xx - x)*3) + 3
	plusTenX = xx + ((xx - x)*3) + 7
	plusTenXX = xx + ((xx - x)*5) + 2
	
	paintutils.drawFilledBox(minusTenX, shutoffButtonY, minusTenXX, shutoffButtonYY, colors.purple)
	m.setCursorPos(minusTenX + 1, shutoffButtonY + 1)
	m.write(""-10%"")
	
	paintutils.drawFilledBox(minusFiveX, shutoffButtonY, minusFiveXX, shutoffButtonYY, colors.purple)
	m.setCursorPos(minusFiveX + 1, shutoffButtonY + 1)
	m.write(""-5%"")
	
	paintutils.drawFilledBox(plusFiveX, shutoffButtonY, plusFiveXX, shutoffButtonYY, colors.purple)
	m.setCursorPos(plusFiveX + 1, shutoffButtonY + 1)
	m.write(""+5%"")
	
	paintutils.drawFilledBox(plusTenX, shutoffButtonY, plusTenXX, shutoffButtonYY, colors.purple)
	m.setCursorPos(plusTenX + 1, shutoffButtonY + 1)
	m.write(""+10%"")
	
	m.setBackgroundColor(colors.black)
	m.setCursorPos(minusFiveXX + 1, shutoffButtonYY + 3)
	m.write(autoShutoff .. "" %"")
	
	HandleAutoShutoffProgressBar()
	m.setCursorPos(x - 1, shutoffButtonYY + 4)
	m.write(autoShutoffBar)
end

function HandleAutoShutoffProgressBar()
	if lastAutoShutoff ~= autoShutoff then
		local progress = math.ceil(autoShutoffBarPercentPerChar * autoShutoff) + 1
		local newBar = """"
		local toConcat
		
		
		for i = 1, autoShutoffBarLength + 2 do
			if i == 1 then
				toConcat = '['
			elseif i <= progress then
				toConcat = '-'
			elseif i == autoShutoffBarLength + 2 then
				toConcat = ']'
			else
				toConcat = ' '
			end
			
			newBar = (newBar .. toConcat)
		end
		
		autoShutoffBar = newBar
	end
end

function HandleTouch()
	while true do
		local _, _, x, y = os.pullEvent(""monitor_touch"")
		m.setCursorPos(4,4)
		if x >= onButtonX and x <= onButtonXX and y >= onButtonY and y <= onButtonYY then 
			rednet.send(relayID, ""<on>"")
		elseif x >= offButtonX and x <= offButtonXX and y >= offButtonY and y <= offButtonYY then
			rednet.send(relayID, ""<off>"")
		elseif x >= minusTenX and x <= minusTenXX and y >= shutoffButtonY and y <= shutoffButtonYY then
			if autoShutoff - 10 < 0 then autoShutoff = 0
			else autoShutoff = autoShutoff - 10 end
		elseif x >= minusFiveX and x <= minusFiveXX and y >= shutoffButtonY and y <= shutoffButtonYY then
			if autoShutoff - 5 < 0 then autoShutoff = 0
			else autoShutoff = autoShutoff - 5 end
		elseif x >= plusFiveX and x <= plusFiveXX and y >= shutoffButtonY and y <= shutoffButtonYY then
			if autoShutoff + 5 > 100 then autoShutoff = 100
			else autoShutoff = autoShutoff + 5 end
		elseif x >= plusTenX and x <= plusTenXX and y >= shutoffButtonY and y <= shutoffButtonYY then
			if autoShutoff + 10 > 100 then autoShutoff = 100
			else autoShutoff = autoShutoff + 10 end
		end
	end
end

function AutoShutoff()
	if not isActive then sentOffSignal = false end
	if heat >= ((autoShutoff * 0.01) * heatMax) and isActive and not sentOffSignal then
		rednet.send(relayID, ""<off>"")
		sentOffSignal = true
	end
end

function HandleReceivedData()
	local sender, message = rednet.receive();
	m.clear()
	
	if string.find(message, ""<active>"") then
		if string.find(message, ""false"") then
			isActive = false
		else
			isActive = true
		end
	elseif string.find(message, ""<eustored>"") then
		euStored = tonumber(tostring(string.gsub(message, ""<eustored>"", """")))	
	elseif string.find(message, ""<eucapacity>"") then
		euCapacity = tonumber(tostring(string.gsub(message, ""<eucapacity>"", """")))
	elseif string.find(message, ""<euoutput>"") then
		euOutput = tonumber(tostring(string.gsub(message, ""<euoutput>"", """")))
	elseif string.find(message, ""<heat>"") then
		heat = tonumber(tostring(string.gsub(message, ""<heat>"", """")))
	elseif string.find(message, ""<heatmax>"") then
		heatMax = tonumber(tostring(string.gsub(message, ""<heatmax>"", """")))
	end
end

function MainLoop()
	while true do
		parallel.waitForAny(HandleReceivedData, HandleTouch)
		Draw()
		AutoShutoff()
		lastAutoShutoff = autoShutoff
	end
end

function Draw()
	DrawInfoBox()
	DrawHeatBar()
	DrawEUOutputBar()
	DrawEUProgressBar()
	DrawControlsBox()
	DrawOnButton()
	DrawOffButton()
	DrawAutoShutoff()
	DrawStatsBox()
	DrawStats()
end

Draw()
MainLoop()"
g55VHGqR,ü§ëG2A.com Free Gift Card FIX July 2024üéÅ,tajdiqul,JavaScript,Friday 5th of July 2024 12:15:51 AM CDT,"G2A.com complimentary voucher & gaming guide.
Any gift card for free on G2A.com including Steam gift cards & everything else offered.
This is the most latest version of this script.

PDF guide here:
https://drive.google.com/file/d/1kcJ-yXUpB1u8mkFHUQKnrArP6DGl5W8e/view?01842

Working as of:
July 5 2024

"
Fwp4DXtb,ü§ëG2A.com Free Gift Card FIX July 2024ü§ë,notgoodatscripting,JavaScript,Friday 5th of July 2024 12:09:48 AM CDT,"G2A.com free voucher & games guide.
Any item for free on G2A.com including Steam gift cards & anything else offered.
This is the most up to date version of this script.

PDF guide here:
https://drive.google.com/file/d/1kcJ-yXUpB1u8mkFHUQKnrArP6DGl5W8e/view?01842

Working as of:
July 5 2024

"
uhHJy718,ReactorReader,QuickMash,Lua,Friday 5th of July 2024 12:08:18 AM CDT,"local reactor = peripheral.wrap(""ic2:nuclear reactor_1"")
local wired = peripheral.wrap(""top"")
local wireless = peripheral.wrap(""left"")
 
local relayID = 510
 
local active, euOutput, heat, heatMax
local failsafeOn = false
 
function OpenWireless()
    rednet.open(""left"")
    rednet.close(""top"")
end
 
function OpenWired()
    rednet.open(""top"")
    rednet.close(""left"")
end
 
function SendToRelay(msg)
    rednet.send(relayID, msg)
end
 
function MainLoop()
    while true do
        sleep(1)
        OpenWired()
        term.clear()
       
        active = reactor.isActive()
        euOutput = reactor.getEUOutput() * 5
        heat = reactor.getHeat()
        heatMax = reactor.getMaxHeat()
       
        OpenWireless()
        SendToRelay(""<active>"" .. tostring(active))
        SendToRelay(""<euoutput>"" .. euOutput)
        SendToRelay(""<heat>"" .. heat)
        SendToRelay(""<heatmax>"" .. heatMax)
    end
end
 
function FailSafe()
    sleep(5)
    if heat > (heatMax - 900) and failsafeOn == false then
        redstone.setOutput(""front"", false)
        failsafeOn = true
    end
end
 
redstone.setOutput(""front"", true)
MainLoop()"
mhZgHggf,mine_this_block (CC Turte),MatthewJ217,Lua,Friday 5th of July 2024 12:00:29 AM CDT,"local _,target = turtle.inspect()

function isFiller(block)
    return not (block.name == target.name);
end

function checkBlock(direction)
	if direction == 0 then
		local isBlock, block = turtle.inspectDown();
		if isBlock and not isFiller(block) then
			turtle.digDown()
			turtle.down()
			search()
			turtle.up()
		end
	elseif direction == 1 then
		local isBlock, block = turtle.inspect();
		if isBlock and not isFiller(block) then
			while not turtle.forward() do turtle.dig() end
			search()
			turtle.back()
		end
	elseif direction == 2 then
		local isBlock, block = turtle.inspectUp();
		if isBlock and not isFiller(block) then
			turtle.digUp()
			turtle.up()
			search()
			turtle.down()
		end
	end
end

function search()
	checkBlock(2)
	checkBlock(1)
	turtle.turnLeft()
	checkBlock(1)
	turtle.turnLeft()
	checkBlock(1)
	turtle.turnLeft()
	checkBlock(1)
	turtle.turnLeft()
	checkBlock(0)
end

search()
"
QLbkfjXk,stepper_2,Nusa_Techno,C++,Thursday 4th of July 2024 11:35:48 PM CDT,"// Pinout for Arduino Uno
const int stepPin = 2;    // STEP pin pada driver TB6600 (misalnya pin 2)
const int dirPin = 3;     // DIR pin pada driver TB6600 (misalnya pin 3)
const int enablePin = 4;  // ENABLE pin pada driver TB6600 (misalnya pin 4)
const int limitSwitch1 = 5; // Pin untuk limit switch 1 (misalnya pin 5)
const int limitSwitch2 = 6; // Pin untuk limit switch 2 (misalnya pin 6)
const int startButton = 7;  // Pin untuk push button (misalnya pin 7)

// Stepper motor properties
const int stepsPerRevolution = 200; // Jumlah langkah per putaran stepper motor
const int stepDelay = 500; // Delay antara setiap langkah (microseconds)

bool motorMoving = false; // Flag untuk menandakan apakah motor sedang bergerak

void setup() {
  // Setup pin mode
  pinMode(stepPin, OUTPUT);
  pinMode(dirPin, OUTPUT);
  pinMode(enablePin, OUTPUT);
  pinMode(limitSwitch1, INPUT_PULLUP); // Menggunakan pull-up internal
  pinMode(limitSwitch2, INPUT_PULLUP); // Menggunakan pull-up internal
  pinMode(startButton, INPUT_PULLUP);  // Menggunakan pull-up internal
  
  // Inisialisasi awal
  digitalWrite(enablePin, LOW); // Disable driver TB6600
  
  Serial.begin(9600);
}

void loop() {
  // Baca tombol start
  if (digitalRead(startButton) == LOW && !motorMoving) { // Tombol ditekan dan motor tidak sedang bergerak
    moveStepperRight(); // Mulai gerakan ke kanan
    motorMoving = true; // Set motorMoving menjadi true
  }
  
  // Cek limit switch saat motor bergerak
  if (motorMoving) {
    if (digitalRead(limitSwitch2) == LOW) { // Jika limit switch kanan terkena
      delay(2000); // Tunggu 2 detik (opsional)
      moveStepperLeft(); // Kembali ke posisi awal
    }
  }
}

void moveStepperRight() {
  digitalWrite(enablePin, LOW); // Aktifkan driver TB6600
  digitalWrite(dirPin, HIGH); // Atur arah gerakan ke kanan
  for (int i = 0; i < stepsPerRevolution; i++) {
    digitalWrite(stepPin, HIGH);
    delayMicroseconds(stepDelay);
    digitalWrite(stepPin, LOW);
    delayMicroseconds(stepDelay);
  }
  digitalWrite(enablePin, HIGH); // Matikan driver TB6600
}

void moveStepperLeft() {
  digitalWrite(enablePin, LOW); // Aktifkan driver TB6600
  digitalWrite(dirPin, LOW); // Atur arah gerakan ke kiri
  for (int i = 0; i < stepsPerRevolution; i++) {
    digitalWrite(stepPin, HIGH);
    delayMicroseconds(stepDelay);
    digitalWrite(stepPin, LOW);
    delayMicroseconds(stepDelay);
  }
  digitalWrite(enablePin, HIGH); // Matikan driver TB6600
  motorMoving = false; // Set motorMoving menjadi false setelah selesai bergerak ke kiri
}
"
B3hTfa3c,Untitled,nooblollolololol,Lua,Thursday 4th of July 2024 11:25:24 PM CDT,"local UserInputService = game:GetService(""UserInputService"")
local RunService = game:GetService(""RunService"")
local player = game:GetService(""Players"").LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild(""HumanoidRootPart"")
local studsPerSecond = 70 -- Change this value to adjust the speed
local isSpacePressed = false
local isShiftPressed = false
local isRKeyPressed = false

local bodyVelocity

local function onUpdate(deltaTime)
    if isRKeyPressed and bodyVelocity then
        if isSpacePressed then
            bodyVelocity.Velocity = Vector3.new(0, studsPerSecond, 0)
        elseif isShiftPressed then
            bodyVelocity.Velocity = Vector3.new(0, -studsPerSecond, 0)
        else
            bodyVelocity.Velocity = Vector3.new(0, 0, 0)
        end
    end
end

RunService.Heartbeat:Connect(onUpdate)

local function onInputBegan(input, gameProcessed)
    if not gameProcessed then
        if input.KeyCode == Enum.KeyCode.Space then
            isSpacePressed = true
        elseif input.KeyCode == Enum.KeyCode.LeftShift then
            isShiftPressed = true
        elseif input.KeyCode == Enum.KeyCode.R then
            isRKeyPressed = not isRKeyPressed
            if isRKeyPressed then
                bodyVelocity = Instance.new(""BodyVelocity"")
                bodyVelocity.Parent = humanoidRootPart
                bodyVelocity.Velocity = Vector3.new(0, 0, 0)
                bodyVelocity.MaxForce = Vector3.new(0, math.huge, 0)
            else
                if bodyVelocity then
                    bodyVelocity:Destroy()
                    bodyVelocity = nil
                end
            end
        end
    end
end

local function onInputEnded(input, gameProcessed)
    if input.KeyCode == Enum.KeyCode.Space then
        isSpacePressed = false
    elseif input.KeyCode == Enum.KeyCode.LeftShift then
        isShiftPressed = false
    end
end

UserInputService.InputBegan:Connect(onInputBegan)
UserInputService.InputEnded:Connect(onInputEnded)
"
Qm7qfdwi,crazy boy snowybot,coinwalk,JavaScript,Thursday 4th of July 2024 11:20:30 PM CDT,"var nion = parseFloat(document.getElementById('pct_balance').value);
var smartz = parseFloat(document.getElementById('pct_balance').value);
var prefit = Number((nion/400).toFixed(8));
var winnerdinner = parseFloat(document.getElementById('pct_balance').value);
var tens = (prefit*10);
var sevens = (prefit*6.99);
var eights = (prefit*7.99);
var james = parseFloat(document.getElementById('pct_balance').value);
var belance = parseFloat(document.getElementById('pct_balance').value);
var snowy = 0;
var beast = prefit;
var greedy =  parseFloat(document.getElementById('pct_balance').value);
var bolance = parseFloat(document.getElementById('pct_balance').value);
var golum = parseFloat(document.getElementById('pct_balance').value);
var snow = parseFloat(document.getElementById('pct_balance').value);



function go(){
bolance = parseFloat(document.getElementById('pct_balance').value);
if (bolance<snow){
belance = belance-beast;
snow = parseFloat(bolance);
}
if (bolance>snow){
belance = belance+beast;
snow = parseFloat(bolance);
}
if ((belance>(((Math.floor(belance/tens))*tens)+sevens))&&(belance<(((Math.floor(belance/tens))*tens)+eights))&&(!((belance>(snowy-(prefit/2)))&&(belance<(snowy+(prefit/2)))))){
        beast = beast*2;
        snowy = parseFloat(belance);
}
if ((((nion/100)-beast)<=0)&&(belance>=(nion+(nion/50)))&&(belance<(((Math.floor(belance/tens))*tens)+sevens))){
snowy = 0;
beast = prefit;
}
if ((((belance/200)-beast)<=0)&&(belance<=nion)){
snowy = 0;
beast = prefit;;
}
if ((((belance/400)-beast)<=0)&&(belance>nion)&&(belance<(((Math.floor(belance/tens))*tens)+sevens))){
snowy = 0;
beast = prefit;;
}
if ((belance>=(winnerdinner*1.12))&&(belance<(((Math.floor(belance/tens))*tens)+sevens))){
snowy = 0;
nion = parseFloat(belance);
prefit = Number((nion/400).toFixed(8));
tens = (prefit*10);
sevens = (prefit*6.99);
eights = (prefit*7.99);
beast = prefit;;
winnerdinner = parseFloat(belance);
}
if (belance>=1440){
console.log(""winner winner chicken dinner"");
    return;
}
var cat = ((belance-smartz).toFixed(8));
console.log(""profit"");
console.log(cat);
$('#pct_chance').val(49.5);
$('#pct_bet').val(((beast*1).toFixed(8)));
$('#a_lo').click();
setTimeout(() => go(), 10);
}
go();
"
xG1ZG1ct,CC-Powah-Turtles,tschamp31,Lua,Thursday 4th of July 2024 09:43:44 PM CDT,"function compareItemName(itemName, slotID)
    if turtle.getItemDetail(slotID) ~= nil and
       turtle.getItemDetail(slotID).name == itemName then
        return true
    else
        return false
    end
end
 
function isBlazeRod(slotID)
    return compareItemName(""minecraft:blaze_rod"", slotID)
end
 
function isDiamond(slotID)
    return compareItemName(""minecraft:diamond"", slotID)
end
 
function isIron(slotID)
    return compareItemName(""minecraft:iron_ingot"", slotID)
end
 
function isGold(slotID)
    return compareItemName(""minecraft:gold_ingot"", slotID)
end
 
function isEmerald(slotID)
    return compareItemName(""minecraft:emerald"", slotID)
end
 
function isNetherStar(slotID)
    return compareItemName(""minecraft:nether_star"", slotID)
end
 
function isRedstoneBlock(slotID)
    return compareItemName(""minecraft:redstone_block"", slotID)
end
 
function isBlazingCrystalBlock(slotID)
    return compareItemName(""powah:blazing_crystal_block"", slotID)
end

function isBlueIce(slotID)
    return compareItemName(""minecraft:blue_ice"", slotID)
end
---@diagnostic disable: redefined-local
function craftBlazeRod(blazeRodSlotID)
    writeMessage(""Found Blaze Rod at ""..blazeRodSlotID..""\n""..
                 ""Crafting with Blaze Rod"")
    turtle.select(blazeRodSlotID)
    turtle.drop(1)
    sleep(2)
    turtle.suck()
end
 
function craftDiamond(diamondSlotID)
    writeMessage(""Found Diamond at ""..diamondSlotID..""\n""..
                 ""Crafting with Diamond"")
    turtle.select(diamondSlotID)
    turtle.drop(1)
    sleep(2)
    turtle.suck()
end
 
function craftIronGold(ironSlotID, goldSlotID)
    writeMessage(""Found Iron at ""..ironSlotID..""\n""..
                 "" and Gold at ""..goldSlotID..""\n""..
                 ""Crafting with Iron and Gold"")
    turtle.select(ironSlotID)
    turtle.drop(1)
    turtle.select(goldSlotID)
    turtle.drop(1)
    sleep(2)
    turtle.suck()
end
 
function craftEmerald(emeraldSlotID)
    writeMessage(""Found Emerald at ""..emeraldSlotID..""\n""..
                 ""Crafting with Emerald"")
    turtle.select(emeraldSlotID)
    turtle.drop(1)
    sleep(2)
    turtle.suck()
end
 
function craftNitro(starSlotID, redstoneBlockSlotID, blazingCrystalBlockSlotID)
    writeMessage(""Found Nether Star at ""..starSlotID..""\n""..
                 "" and Redstone Block at ""..redstoneBlockSlotID..""\n""..
                 "" and Blazing Crystal Block at ""..blazingCrystalBlockSlotID..""\n""..
                 ""Crafting Nitro"")
    turtle.select(starSlotID)
    turtle.drop(1)
    turtle.select(redstoneBlockSlotID)
    turtle.drop(2)
    turtle.select(blazingCrystalBlockSlotID)
    turtle.drop(1)
    sleep(2)
    turtle.suck()
end

function craftDryIce(blueIceSlotID)
    writeMessage(""Found Blue Ice at ""..blueIceSlotID..""\n""..
                 ""Crafting with Blue Ice"")
    turtle.select(blueIceSlotID)
    turtle.drop(1)
    sleep(2)
    turtle.suck()
end
 
function doCrafting()
    local canCraft, blazeRodSlotID = shouldCraftBlaze()
    if canCraft then
        craftBlazeRod(blazeRodSlotID)
        return
    end
    
    local canCraft, diamondSlotID = shouldCraftDiamond()
    if canCraft then
        craftDiamond(diamondSlotID)
        return
    end
 
    local canCraft, emeraldSlotID = shouldCraftEmerald()
    if canCraft then
        craftEmerald(emeraldSlotID)
        return
    end
 
    local canCraft, starSlotID, redstoneBlockSlotID, blazingCrystalBlockSlotID = shouldCraftNitro()
    if canCraft then
        craftNitro(starSlotID, redstoneBlockSlotID, blazingCrystalBlockSlotID)
        return
    end
 
    local canCraft, ironSlotID, goldSlotID = shouldCraftIronGold()
    if canCraft then
        craftIronGold(ironSlotID, goldSlotID)
        return
    end

    local canCraft, blueIceSlotID = shouldCraftDryIce()
    if canCraft then
        craftDryIce(blueIceSlotID)
        return
    end
end
function shouldCraftBlaze()
    for slotNum = 1, 16, 1 do
        if isBlazeRod(slotNum) then
            return true, slotNum
        end
    end
    return false, -1
end
 
function shouldCraftDiamond()
    for slotNum = 1, 16, 1 do
        if isDiamond(slotNum) then
            return true, slotNum
        end
    end
    return false, -1
end
 
function shouldCraftEmerald()
    for slotNum = 1, 16, 1 do
        if isEmerald(slotNum) then
            return true, slotNum
        end
    end
    return false, -1
end
 
function shouldCraftIronGold()
    local ironSlotID = -1
    local goldSlotID = -1
    for slotNum = 1, 16, 1 do
        if isIron(slotNum) then
            ironSlotID = slotNum
        elseif isGold(slotNum) then
            goldSlotID = slotNum
        end
    end
    
    local canCraft = ironSlotID > 0 and goldSlotID > 0
    return canCraft, ironSlotID, goldSlotID
end
 
function shouldCraftNitro()
    local starSlotID = -1
    local redstoneBlockSlotID = -1
    local blazingCrystalBlockSlotID = -1
 
    for slotNum = 1, 16, 1 do
        if isNetherStar(slotNum) then
            starSlotID = slotNum
        elseif isBlazingCrystalBlock(slotNum) then
            blazingCrystalBlockSlotID = slotNum
        elseif isRedstoneBlock(slotNum) and
               turtle.getItemDetail(slotNum).count >= 2 then
            redstoneBlockSlotID = slotNum
        end
    end
 
    local canCraft = starSlotID > 0 and blazingCrystalBlockSlotID > 0 and redstoneBlockSlotID > 0
    return canCraft, starSlotID, redstoneBlockSlotID, blazingCrystalBlockSlotID
end

function shouldCraftDryIce()
    for slotNum = 1, 16, 1 do
        if isBlueIce(slotNum) then
            return true, slotNum
        end
    end
    return false, -1
end
-- Uncomment those lines if you want to keep
-- the program as seperate files.
--dofile(""slotChecking.lua"")
--dofile(""crafting.lua"")
--dofile(""nextCrafting.lua"")
 
function writeMessage(message)
    term.clear()
    term.setCursorPos(1, 1)
    print(""+-----------------------------+"")
    print(""|Welcome to Powah Autocrafting|"")
    print(""+-----------------------------+"")
    print()
    print(message)
end
 
writeMessage(""Startup finished"")
while true do
    doCrafting()
    -- Wait two Redstone ticks for the Redstone Signal to update
    sleep(0.2)
    -- Spin in a loop till crafting is done
    while redstone.getInput(""back"") do
        sleep(0.2)
    end
end"
nDFcFUB6,Stepper,Nusa_Techno,C++,Thursday 4th of July 2024 08:40:45 PM CDT,"// Definisikan pin yang digunakan
const int stepPin = 2;
const int dirPin = 3;
const int buttonPin = 7;
const int limitSwitchStartPin = 8;
const int limitSwitchEndPin = 9;

// Variable untuk menyimpan status motor dan arah gerakan
bool motorActivated = false;
bool moveDirection = true; // true = maju, false = mundur
bool atStartPosition = false;
bool atEndPosition = false;

void setup() {
  // Set pin sebagai OUTPUT untuk step dan direction
  pinMode(stepPin, OUTPUT);
  pinMode(dirPin, OUTPUT);

  // Set pin sebagai INPUT untuk push button dan limit switch dengan pull-up resistor
  pinMode(buttonPin, INPUT_PULLUP);
  pinMode(limitSwitchStartPin, INPUT_PULLUP);
  pinMode(limitSwitchEndPin, INPUT_PULLUP);

  // Mulai dengan arah motor maju
  digitalWrite(dirPin, HIGH);
}

void loop() {
  // Baca status limit switch untuk posisi awal
  bool switchStartState = digitalRead(limitSwitchStartPin);

  // Jika limit switch posisi awal aktif dan motor tidak bergerak
  if (switchStartState == LOW && !motorActivated && !atStartPosition) {
    atStartPosition = true; // Motor berada di posisi awal
  }

  // Baca status limit switch untuk posisi akhir
  bool switchEndState = digitalRead(limitSwitchEndPin);

  // Jika limit switch posisi akhir aktif
  if (switchEndState == LOW && atStartPosition && !atEndPosition) {
    atEndPosition = true; // Motor mencapai posisi akhir
    motorActivated = false; // Matikan motor
    moveDirection = false; // Setel arah motor ke mundur
    delay(1000); // Tunda 1 detik untuk stabilisasi
  }

  // Baca status push button
  bool buttonState = digitalRead(buttonPin);

  // Jika push button ditekan dan motor berada di posisi awal
  if (buttonState == LOW && atStartPosition && !atEndPosition) {
    motorActivated = true; // Aktifkan motor
    moveDirection = true; // Setel arah motor ke maju
  }

  // Jika motor telah diaktifkan dan berada di posisi awal atau akhir
  if (motorActivated && (atStartPosition || atEndPosition)) {
    // Lanjutkan gerakan motor ke arah yang ditentukan
    digitalWrite(stepPin, HIGH);
    delayMicroseconds(800); // Sesuaikan dengan kecepatan motor Anda
    digitalWrite(stepPin, LOW);
    delayMicroseconds(800); // Sesuaikan dengan kecepatan motor Anda
  }

  // Reset status motor setelah mencapai posisi akhir
  if (atEndPosition && switchEndState == HIGH) {
    atStartPosition = false;
    atEndPosition = false;
  }
}"
KwQ2E5me,InitMap,qtizananto,JavaScript,Thursday 4th of July 2024 08:24:21 PM CDT,"
async function initMap() {
    var map = new google.maps.Map(document.getElementById('map'), {
        center: {
            lat: latitude,
            lng: longitude
        },
        zoom: 13,
        fullscreenControl: false,
        mapTypeControl: true,
        mapTypeId: 'hybrid',
        mapId: ""EPERSIK_MAP_ID""
    });

    var input = document.getElementById('pac-input');
    var searchBox = new google.maps.places.SearchBox(input);
    map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);

    map.addListener('bounds_changed', function () {
        searchBox.setBounds(map.getBounds());
    });

    function markerCoords(markerobject) {
        console.log(markerobject);
        google.maps.event.addListener(markerobject, 'dragend', function (evt) {
            const position = markerobject.position;
            console.log(`Pin dropped at: ${position.lat}, ${position.lng}`);

            $('#latitude').val(position.lat.toFixed(8));
            $('#longitude').val(position.lng.toFixed(8));
            flashy();
        });

        google.maps.event.addListener(markerobject, 'drag', function (evt) {
            const position = markerobject.position;
            console.log(`Pin dropped at: ${position.lat}, ${position.lng}`);

            $('#latitude').val(position.lat.toFixed(8));
            $('#longitude').val(position.lng.toFixed(8));
            flashy();
        });
    }

    var marker = new google.maps.marker.AdvancedMarkerElement({
        position: {
            lat: latitude,
            lng: longitude
        },
        map: map,
        title: 'Select Location!',
        gmpDraggable: true,
        gmpClickable: true,
    });

    markerCoords(marker);

    google.maps.event.addListener(map, 'click', function (evt) {
        var latlng = new google.maps.LatLng(evt.latLng.lat().toFixed(8), evt.latLng.lng().toFixed(8));

        marker.position = {
            lat: latlng.lat(),
            lng: latlng.lng(),
        }

        $('#latitude').val(evt.latLng.lat().toFixed(8));
        $('#longitude').val(evt.latLng.lng().toFixed(8));
    });

    searchBox.addListener('places_changed', function () {
        var places = searchBox.getPlaces();
        if (places.length == 0) {
            return;
        }

        places.forEach(function (place) {
            marker.setPosition(place.geometry.location);
            $('#latitude').val(place.geometry.location.lat().toFixed(8));
            $('#longitude').val(place.geometry.location.lng().toFixed(8));
            map.setCenter(marker.getPosition());
            flashy();
        });
    });

    $(""#pac-input"").click(function (event) {
        $(this).val('');
    });
}"
GWWfexk3,controler,ColtSeals,CSS,Thursday 4th of July 2024 07:54:04 PM CDT,"body { 
    background-color: #000000; 
    background-color: RGBA(0, 0, 0, 0); 
    margin: 0 auto; 
    overflow: hidden; 
} .controller.xbox{
    background: url(https://imgur.com/By6DpSr.png);
    width: 807px;
    height: 651px;
    margin-left: 0;
    margin-top: 0;
} .xbox .sticks {
	width: 367px;
    height: 100px;
    left: 220px;
    top: 333px;
}.xbox .stick {
    background: url(https://imgur.com/Z5LNKDT.png);
    width: 100px;
    height: 100px;
} .xbox .stick.pressed {
    background-position: -102px 0;
} .xbox .stick.right {
    top: 0;
    left: 267px;
} .xbox .abxy {
    width: 181px;
    height: 181px;
    left: 573px;
    top: 178px;
} .xbox .button {
    background: url(https://imgur.com/EiIqCN1.png);
    width: 58px;
    height: 58px;
} .xbox .button.pressed {
  	background-position-y: -59px;
	margin-top: 0;
} .xbox .a {
    background-position: 0 0;
    left: 61px;
    top: 123px;
} .xbox .b {
    background-position: -59px 0;
    left: 123px;
    top: 62px;
} .xbox .x {
    background-position: -118px 0;
    left: 0px;
    top: 61px;
} .xbox .y {
    background-position: -177px 0;
    left: 61px;
    top: 0px;
} .xbox .arrows {
    left: 195px;
	top: 140px;
    width: 416px;
    height: 57px;
} .xbox .quadrant { 
    display: none; 
} .xbox .back, .xbox .start {
    background: url(https://imgur.com/0iEovvx.png);
    width: 27px;
    height: 57px;
    opacity: 0;
} .xbox .start {
    background-position: 27px 0;
    float: right;
} .xbox .dpad {
	width: 144px;
    height: 144px;
    left: 71px;
    top: 196px;
} .xbox .face {
    background: url(https://imgur.com/JsJCRZu.png);
    position: absolute;
    opacity: 0;
} .xbox .face.up {
    background-position: 0 -68px;
    width: 52px;
    height: 63px;
    left: 46px;
} .xbox .face.down {
    background-position: -54px 63px;
    width: 52px;
    height: 63px;
    left: 46px;
    top: 81px;
} .xbox .face.left {
    background-position: -108px -68px;
    width: 64px;
    height: 52px;
    left: -1px;
    top: 47px; 
} .xbox .face.right {
    background-position: -175px -68px;
    width: 63px;
    height: 52px;
    left: 81px;
    top: 46px;
} .xbox .bumpers {
    width: 620px;
    height: 35px;
    left: 93px;
    top: 114px;
} .xbox .bumper {
    background: url(https://imgur.com/CviCXKk.png);
    width: 110px;
    height: 35px;
    opacity: 0;
} .xbox .triggers {
    width: 619px;
    height: 108px;
    left: 94px;
} .xbox .trigger {
    background: url(https://imgur.com/zyIXD9C.png);
    width: 111px;
    height: 108px;
    opacity: 0;
} .xbox .trigger.right {
    background-position: -113px 0;
	transform: rotateY(0);
}"
Bw5XuvC8,Untitled,999ms,Python,Thursday 4th of July 2024 07:37:19 PM CDT,"with open('./collector_db_pusher/data.csv', 'r') as f:
    csv_reader = csv.reader(f)
    data = list(csv_reader)[1:]
    transfers = []
    for row in data:
        timestamp = int(row[2])
        f = row[4]
        t = row[5]
        amount = float(row[6].replace(',', ''))
        transfers.append({
            'timestamp': timestamp,
            'from': f,
            'to': t,
            'amount': amount
        })

    current_timestamp = 1720136819
    cumulative_wsteth_balance = 0
    for transfer in transfers:
        coeff = (current_timestamp -
                 transfer['timestamp']) / 3600
        if transfer['from'] == '0x0000000000000000000000000000000000000000':
            cumulative_wsteth_balance += transfer['amount'] * coeff
        else:
            cumulative_wsteth_balance -= transfer['amount'] * coeff

    # 3600 constant price for wsteth for all time. At the same time, the rate of symbiotic points is: 1 point for $4000 per hour.
    price_coefficient = 3600 / 4000
    # 3.7M points
    print(cumulative_wsteth_balance * price_coefficient)
    # symbiotic API returns 2.99M points"
F7eTq9Em,2024-07-04_stats.json,rdp_snitch,JSON,Thursday 4th of July 2024 07:18:08 PM CDT,"{
  ""ip"": {
    ""60.205.137.128"": 3,
    ""91.238.181.23"": 6,
    ""62.122.184.15"": 3,
    ""45.227.254.55"": 6,
    ""164.92.104.215"": 15,
    ""104.248.154.46"": 9,
    ""84.72.86.243"": 3,
    ""205.210.31.88"": 9,
    ""66.85.52.114"": 3,
    ""162.248.225.122"": 12,
    ""103.56.7.231"": 3,
    ""88.214.25.63"": 12,
    ""103.150.221.12"": 6,
    ""91.238.181.20"": 6,
    ""185.170.144.3"": 3,
    ""135.26.109.26"": 6,
    ""62.215.34.181"": 6,
    ""64.124.50.139"": 6,
    ""91.238.181.22"": 6,
    ""87.251.75.120"": 6,
    ""45.227.254.49"": 6,
    ""220.248.76.186"": 3,
    ""147.185.132.138"": 9,
    ""44.200.6.177"": 597,
    ""194.26.135.155"": 9,
    ""103.56.7.60"": 3,
    ""80.66.88.35"": 3,
    ""150.109.198.202"": 6,
    ""58.218.199.219"": 15,
    ""147.185.132.120"": 9,
    ""213.109.202.252"": 12,
    ""150.223.56.176"": 108,
    ""87.251.75.64"": 3,
    ""88.214.25.62"": 6,
    ""194.180.49.43"": 1104,
    ""60.255.174.158"": 3,
    ""167.99.186.213"": 3,
    ""88.214.25.61"": 6,
    ""205.210.31.171"": 9,
    ""45.227.254.8"": 6,
    ""123.213.52.58"": 3,
    ""115.187.32.37"": 3
  },
  ""asn"": {
    ""AS37963"": 3,
    ""AS49434"": 18,
    ""AS57523"": 12,
    ""AS267784"": 18,
    ""AS14061"": 27,
    ""AS6730"": 3,
    ""AS396982"": 36,
    ""AS62537"": 3,
    ""AS14576"": 12,
    ""AS140599"": 12,
    ""AS29551"": 24,
    ""AS197414"": 3,
    ""AS6300"": 6,
    ""AS21050"": 6,
    ""AS6461"": 6,
    ""AS208091"": 12,
    ""AS17621"": 3,
    ""AS14618"": 597,
    ""AS132203"": 6,
    ""AS4134"": 15,
    ""AS208312"": 12,
    ""AS58519"": 108,
    ""AS201814"": 1104,
    ""AS4837"": 3,
    ""AS9318"": 3,
    ""AS23860"": 3
  },
  ""isp"": {
    ""Hangzhou Alibaba Advertising Co"": 3,
    ""Datacenter location PAR1 France"": 18,
    ""Chang Way Technologies Co. Limited"": 12,
    ""Flyservers S.A."": 18,
    ""DigitalOcean, LLC"": 27,
    ""UPC Schweiz GmbH"": 3,
    ""Google LLC"": 36,
    ""Sauce Labs Inc"": 3,
    ""Hosting Solution Ltd."": 12,
    ""Comfac Corporation"": 12,
    ""NOC EMAIL: noc@one-host.net"": 24,
    ""Xhost Internet Solutions LP"": 12,
    ""Consolidated Communications, Inc."": 6,
    ""Fast Telecommunications Company W.L.L."": 6,
    ""Zayo Bandwidth"": 6,
    ""China Unicom CncNet"": 3,
    ""Amazon.com"": 597,
    ""Xhost Internet Solutions"": 3,
    ""Aceville Pte.ltd"": 6,
    ""Chinanet"": 15,
    ""Red Byte LLC"": 12,
    ""Cloud Computing Corporation"": 108,
    ""MEVSPACE sp. z o.o."": 1104,
    ""China Unicom China169 Network"": 3,
    ""SK Broadband Co Ltd"": 3,
    ""Alliance Broadband Services"": 3
  },
  ""org"": {
    ""Aliyun Computing Co., LTD"": 3,
    ""ThinkTech Technology Industrial CO. Limited"": 42,
    ""Chang Way Technologies Co. Limited"": 24,
    ""UAB Host Baltic"": 18,
    ""DigitalOcean, LLC"": 27,
    ""UPC Schweiz GmbH"": 3,
    ""Palo Alto Networks, Inc"": 36,
    ""Sauce Labs Inc"": 3,
    ""IT Hosting Group"": 12,
    ""Comfac Corporation"": 12,
    ""Xhostis"": 3,
    ""Consolidated Communications, Inc."": 6,
    ""Fasttelco"": 6,
    ""Microsoft Corporation"": 6,
    ""Xhost Internet Solutions"": 9,
    ""Unknown"": 9,
    ""AWS EC2 (us-east-1)"": 597,
    ""XHOSTIS"": 3,
    ""Chinanet JS"": 15,
    ""Chinanet SD"": 108,
    ""HostSlick"": 1104,
    ""SiChuan Cable TV Network CO., LTD"": 3,
    ""broadNnet"": 3,
    ""Alliance Broadband Services Pvt. Ltd."": 3
  },
  ""regionName"": {
    ""Beijing"": 3,
    ""\u00cele-de-France"": 18,
    ""Moscow"": 24,
    ""Vilnius"": 18,
    ""California"": 66,
    ""Central Singapore"": 9,
    ""Schwyz"": 3,
    ""Metro Manila"": 6,
    ""Hesse"": 24,
    ""Davao Region"": 6,
    ""North Holland"": 12,
    ""Texas"": 6,
    ""Hawalli"": 6,
    ""Virginia"": 1707,
    ""Shanghai"": 3,
    ""Drenthe"": 3,
    ""Tokyo"": 6,
    ""Jiangsu"": 15,
    ""Shandong"": 108,
    ""Sichuan"": 3,
    ""Ontario"": 3,
    ""Gyeongsangnam-do"": 3,
    ""West Bengal"": 3
  },
  ""country"": {
    ""China"": 132,
    ""France"": 18,
    ""Russia"": 24,
    ""Lithuania"": 18,
    ""United States"": 1779,
    ""Singapore"": 9,
    ""Switzerland"": 3,
    ""Philippines"": 12,
    ""Germany"": 24,
    ""The Netherlands"": 15,
    ""Kuwait"": 6,
    ""Japan"": 6,
    ""Canada"": 3,
    ""South Korea"": 3,
    ""India"": 3
  },
  ""account"": {
    ""hello"": 1785,
    ""Test"": 81,
    ""(empty)"": 6,
    ""gOvOIyTXF"": 3,
    ""ksPUbR"": 3,
    ""CHpFmW"": 3,
    ""Administr"": 15,
    ""DsxVgRyVX"": 3,
    ""lGquqe"": 3,
    ""pYnnAV"": 3,
    ""Domain"": 21,
    ""izcBcUhyz"": 3,
    ""HcJYnE"": 3,
    ""ggaVOF"": 3,
    ""Administrator"": 27,
    ""Admin"": 27,
    ""Whatuptime.com"": 27,
    ""Jakartakini123#"": 27,
    ""shen"": 3,
    ""iFExsVYCp"": 3,
    ""DWctiT"": 3,
    ""kgTgix"": 3
  },
  ""keyboard"": {
    ""Unknown"": 2055
  },
  ""client_build"": {
    ""Unknown"": 2055
  },
  ""client_name"": {
    ""Unknown"": 2055
  },
  ""ip_type"": {
    ""hosting & proxy"": 15,
    ""hosting"": 816,
    ""proxy"": 30,
    ""Unknown"": 1194
  }
}"
PpHdFhAt,2024-07-04_stats.json,rdp_snitch,JSON,Thursday 4th of July 2024 07:16:10 PM CDT,"{
  ""ip"": {
    ""60.205.137.128"": 2,
    ""91.238.181.23"": 4,
    ""62.122.184.15"": 2,
    ""45.227.254.55"": 4,
    ""164.92.104.215"": 10,
    ""104.248.154.46"": 6,
    ""84.72.86.243"": 2,
    ""205.210.31.88"": 6,
    ""66.85.52.114"": 2,
    ""162.248.225.122"": 8,
    ""103.56.7.231"": 2,
    ""88.214.25.63"": 8,
    ""103.150.221.12"": 4,
    ""91.238.181.20"": 4,
    ""185.170.144.3"": 2,
    ""135.26.109.26"": 4,
    ""62.215.34.181"": 4,
    ""64.124.50.139"": 4,
    ""91.238.181.22"": 4,
    ""87.251.75.120"": 4,
    ""45.227.254.49"": 4,
    ""220.248.76.186"": 2,
    ""147.185.132.138"": 6,
    ""44.200.6.177"": 398,
    ""194.26.135.155"": 6,
    ""103.56.7.60"": 2,
    ""80.66.88.35"": 2,
    ""150.109.198.202"": 4,
    ""58.218.199.219"": 10,
    ""147.185.132.120"": 6,
    ""213.109.202.252"": 8,
    ""150.223.56.176"": 72,
    ""87.251.75.64"": 2,
    ""88.214.25.62"": 4,
    ""194.180.49.43"": 736,
    ""60.255.174.158"": 2,
    ""167.99.186.213"": 2,
    ""88.214.25.61"": 4,
    ""205.210.31.171"": 6,
    ""45.227.254.8"": 4,
    ""123.213.52.58"": 2,
    ""115.187.32.37"": 2
  },
  ""asn"": {
    ""AS37963"": 2,
    ""AS49434"": 12,
    ""AS57523"": 8,
    ""AS267784"": 12,
    ""AS14061"": 18,
    ""AS6730"": 2,
    ""AS396982"": 24,
    ""AS62537"": 2,
    ""AS14576"": 8,
    ""AS140599"": 8,
    ""AS29551"": 16,
    ""AS197414"": 2,
    ""AS6300"": 4,
    ""AS21050"": 4,
    ""AS6461"": 4,
    ""AS208091"": 8,
    ""AS17621"": 2,
    ""AS14618"": 398,
    ""AS132203"": 4,
    ""AS4134"": 10,
    ""AS208312"": 8,
    ""AS58519"": 72,
    ""AS201814"": 736,
    ""AS4837"": 2,
    ""AS9318"": 2,
    ""AS23860"": 2
  },
  ""isp"": {
    ""Hangzhou Alibaba Advertising Co"": 2,
    ""Datacenter location PAR1 France"": 12,
    ""Chang Way Technologies Co. Limited"": 8,
    ""Flyservers S.A."": 12,
    ""DigitalOcean, LLC"": 18,
    ""UPC Schweiz GmbH"": 2,
    ""Google LLC"": 24,
    ""Sauce Labs Inc"": 2,
    ""Hosting Solution Ltd."": 8,
    ""Comfac Corporation"": 8,
    ""NOC EMAIL: noc@one-host.net"": 16,
    ""Xhost Internet Solutions LP"": 8,
    ""Consolidated Communications, Inc."": 4,
    ""Fast Telecommunications Company W.L.L."": 4,
    ""Zayo Bandwidth"": 4,
    ""China Unicom CncNet"": 2,
    ""Amazon.com"": 398,
    ""Xhost Internet Solutions"": 2,
    ""Aceville Pte.ltd"": 4,
    ""Chinanet"": 10,
    ""Red Byte LLC"": 8,
    ""Cloud Computing Corporation"": 72,
    ""MEVSPACE sp. z o.o."": 736,
    ""China Unicom China169 Network"": 2,
    ""SK Broadband Co Ltd"": 2,
    ""Alliance Broadband Services"": 2
  },
  ""org"": {
    ""Aliyun Computing Co., LTD"": 2,
    ""ThinkTech Technology Industrial CO. Limited"": 28,
    ""Chang Way Technologies Co. Limited"": 16,
    ""UAB Host Baltic"": 12,
    ""DigitalOcean, LLC"": 18,
    ""UPC Schweiz GmbH"": 2,
    ""Palo Alto Networks, Inc"": 24,
    ""Sauce Labs Inc"": 2,
    ""IT Hosting Group"": 8,
    ""Comfac Corporation"": 8,
    ""Xhostis"": 2,
    ""Consolidated Communications, Inc."": 4,
    ""Fasttelco"": 4,
    ""Microsoft Corporation"": 4,
    ""Xhost Internet Solutions"": 6,
    ""Unknown"": 6,
    ""AWS EC2 (us-east-1)"": 398,
    ""XHOSTIS"": 2,
    ""Chinanet JS"": 10,
    ""Chinanet SD"": 72,
    ""HostSlick"": 736,
    ""SiChuan Cable TV Network CO., LTD"": 2,
    ""broadNnet"": 2,
    ""Alliance Broadband Services Pvt. Ltd."": 2
  },
  ""regionName"": {
    ""Beijing"": 2,
    ""\u00cele-de-France"": 12,
    ""Moscow"": 16,
    ""Vilnius"": 12,
    ""California"": 44,
    ""Central Singapore"": 6,
    ""Schwyz"": 2,
    ""Metro Manila"": 4,
    ""Hesse"": 16,
    ""Davao Region"": 4,
    ""North Holland"": 8,
    ""Texas"": 4,
    ""Hawalli"": 4,
    ""Virginia"": 1138,
    ""Shanghai"": 2,
    ""Drenthe"": 2,
    ""Tokyo"": 4,
    ""Jiangsu"": 10,
    ""Shandong"": 72,
    ""Sichuan"": 2,
    ""Ontario"": 2,
    ""Gyeongsangnam-do"": 2,
    ""West Bengal"": 2
  },
  ""country"": {
    ""China"": 88,
    ""France"": 12,
    ""Russia"": 16,
    ""Lithuania"": 12,
    ""United States"": 1186,
    ""Singapore"": 6,
    ""Switzerland"": 2,
    ""Philippines"": 8,
    ""Germany"": 16,
    ""The Netherlands"": 10,
    ""Kuwait"": 4,
    ""Japan"": 4,
    ""Canada"": 2,
    ""South Korea"": 2,
    ""India"": 2
  },
  ""account"": {
    ""hello"": 1190,
    ""Test"": 54,
    ""(empty)"": 4,
    ""gOvOIyTXF"": 2,
    ""ksPUbR"": 2,
    ""CHpFmW"": 2,
    ""Administr"": 10,
    ""DsxVgRyVX"": 2,
    ""lGquqe"": 2,
    ""pYnnAV"": 2,
    ""Domain"": 14,
    ""izcBcUhyz"": 2,
    ""HcJYnE"": 2,
    ""ggaVOF"": 2,
    ""Administrator"": 18,
    ""Admin"": 18,
    ""Whatuptime.com"": 18,
    ""Jakartakini123#"": 18,
    ""shen"": 2,
    ""iFExsVYCp"": 2,
    ""DWctiT"": 2,
    ""kgTgix"": 2
  },
  ""keyboard"": {
    ""Unknown"": 1370
  },
  ""client_build"": {
    ""Unknown"": 1370
  },
  ""client_name"": {
    ""Unknown"": 1370
  },
  ""ip_type"": {
    ""hosting & proxy"": 10,
    ""hosting"": 544,
    ""proxy"": 20,
    ""Unknown"": 796
  }
}"
3ibKw9zD,2024-07-04_stats.json,rdp_snitch,JSON,Thursday 4th of July 2024 07:15:08 PM CDT,"{
  ""ip"": {
    ""60.205.137.128"": 1,
    ""91.238.181.23"": 2,
    ""62.122.184.15"": 1,
    ""45.227.254.55"": 2,
    ""164.92.104.215"": 5,
    ""104.248.154.46"": 3,
    ""84.72.86.243"": 1,
    ""205.210.31.88"": 3,
    ""66.85.52.114"": 1,
    ""162.248.225.122"": 4,
    ""103.56.7.231"": 1,
    ""88.214.25.63"": 4,
    ""103.150.221.12"": 2,
    ""91.238.181.20"": 2,
    ""185.170.144.3"": 1,
    ""135.26.109.26"": 2,
    ""62.215.34.181"": 2,
    ""64.124.50.139"": 2,
    ""91.238.181.22"": 2,
    ""87.251.75.120"": 2,
    ""45.227.254.49"": 2,
    ""220.248.76.186"": 1,
    ""147.185.132.138"": 3,
    ""44.200.6.177"": 199,
    ""194.26.135.155"": 3,
    ""103.56.7.60"": 1,
    ""80.66.88.35"": 1,
    ""150.109.198.202"": 2,
    ""58.218.199.219"": 5,
    ""147.185.132.120"": 3,
    ""213.109.202.252"": 4,
    ""150.223.56.176"": 36,
    ""87.251.75.64"": 1,
    ""88.214.25.62"": 2,
    ""194.180.49.43"": 368,
    ""60.255.174.158"": 1,
    ""167.99.186.213"": 1,
    ""88.214.25.61"": 2,
    ""205.210.31.171"": 3,
    ""45.227.254.8"": 2,
    ""123.213.52.58"": 1,
    ""115.187.32.37"": 1
  },
  ""asn"": {
    ""AS37963"": 1,
    ""AS49434"": 6,
    ""AS57523"": 4,
    ""AS267784"": 6,
    ""AS14061"": 9,
    ""AS6730"": 1,
    ""AS396982"": 12,
    ""AS62537"": 1,
    ""AS14576"": 4,
    ""AS140599"": 4,
    ""AS29551"": 8,
    ""AS197414"": 1,
    ""AS6300"": 2,
    ""AS21050"": 2,
    ""AS6461"": 2,
    ""AS208091"": 4,
    ""AS17621"": 1,
    ""AS14618"": 199,
    ""AS132203"": 2,
    ""AS4134"": 5,
    ""AS208312"": 4,
    ""AS58519"": 36,
    ""AS201814"": 368,
    ""AS4837"": 1,
    ""AS9318"": 1,
    ""AS23860"": 1
  },
  ""isp"": {
    ""Hangzhou Alibaba Advertising Co"": 1,
    ""Datacenter location PAR1 France"": 6,
    ""Chang Way Technologies Co. Limited"": 4,
    ""Flyservers S.A."": 6,
    ""DigitalOcean, LLC"": 9,
    ""UPC Schweiz GmbH"": 1,
    ""Google LLC"": 12,
    ""Sauce Labs Inc"": 1,
    ""Hosting Solution Ltd."": 4,
    ""Comfac Corporation"": 4,
    ""NOC EMAIL: noc@one-host.net"": 8,
    ""Xhost Internet Solutions LP"": 4,
    ""Consolidated Communications, Inc."": 2,
    ""Fast Telecommunications Company W.L.L."": 2,
    ""Zayo Bandwidth"": 2,
    ""China Unicom CncNet"": 1,
    ""Amazon.com"": 199,
    ""Xhost Internet Solutions"": 1,
    ""Aceville Pte.ltd"": 2,
    ""Chinanet"": 5,
    ""Red Byte LLC"": 4,
    ""Cloud Computing Corporation"": 36,
    ""MEVSPACE sp. z o.o."": 368,
    ""China Unicom China169 Network"": 1,
    ""SK Broadband Co Ltd"": 1,
    ""Alliance Broadband Services"": 1
  },
  ""org"": {
    ""Aliyun Computing Co., LTD"": 1,
    ""ThinkTech Technology Industrial CO. Limited"": 14,
    ""Chang Way Technologies Co. Limited"": 8,
    ""UAB Host Baltic"": 6,
    ""DigitalOcean, LLC"": 9,
    ""UPC Schweiz GmbH"": 1,
    ""Palo Alto Networks, Inc"": 12,
    ""Sauce Labs Inc"": 1,
    ""IT Hosting Group"": 4,
    ""Comfac Corporation"": 4,
    ""Xhostis"": 1,
    ""Consolidated Communications, Inc."": 2,
    ""Fasttelco"": 2,
    ""Microsoft Corporation"": 2,
    ""Xhost Internet Solutions"": 3,
    ""Unknown"": 3,
    ""AWS EC2 (us-east-1)"": 199,
    ""XHOSTIS"": 1,
    ""Chinanet JS"": 5,
    ""Chinanet SD"": 36,
    ""HostSlick"": 368,
    ""SiChuan Cable TV Network CO., LTD"": 1,
    ""broadNnet"": 1,
    ""Alliance Broadband Services Pvt. Ltd."": 1
  },
  ""regionName"": {
    ""Beijing"": 1,
    ""\u00cele-de-France"": 6,
    ""Moscow"": 8,
    ""Vilnius"": 6,
    ""California"": 22,
    ""Central Singapore"": 3,
    ""Schwyz"": 1,
    ""Metro Manila"": 2,
    ""Hesse"": 8,
    ""Davao Region"": 2,
    ""North Holland"": 4,
    ""Texas"": 2,
    ""Hawalli"": 2,
    ""Virginia"": 569,
    ""Shanghai"": 1,
    ""Drenthe"": 1,
    ""Tokyo"": 2,
    ""Jiangsu"": 5,
    ""Shandong"": 36,
    ""Sichuan"": 1,
    ""Ontario"": 1,
    ""Gyeongsangnam-do"": 1,
    ""West Bengal"": 1
  },
  ""country"": {
    ""China"": 44,
    ""France"": 6,
    ""Russia"": 8,
    ""Lithuania"": 6,
    ""United States"": 593,
    ""Singapore"": 3,
    ""Switzerland"": 1,
    ""Philippines"": 4,
    ""Germany"": 8,
    ""The Netherlands"": 5,
    ""Kuwait"": 2,
    ""Japan"": 2,
    ""Canada"": 1,
    ""South Korea"": 1,
    ""India"": 1
  },
  ""account"": {
    ""hello"": 595,
    ""Test"": 27,
    ""(empty)"": 2,
    ""gOvOIyTXF"": 1,
    ""ksPUbR"": 1,
    ""CHpFmW"": 1,
    ""Administr"": 5,
    ""DsxVgRyVX"": 1,
    ""lGquqe"": 1,
    ""pYnnAV"": 1,
    ""Domain"": 7,
    ""izcBcUhyz"": 1,
    ""HcJYnE"": 1,
    ""ggaVOF"": 1,
    ""Administrator"": 9,
    ""Admin"": 9,
    ""Whatuptime.com"": 9,
    ""Jakartakini123#"": 9,
    ""shen"": 1,
    ""iFExsVYCp"": 1,
    ""DWctiT"": 1,
    ""kgTgix"": 1
  },
  ""keyboard"": {
    ""Unknown"": 685
  },
  ""client_build"": {
    ""Unknown"": 685
  },
  ""client_name"": {
    ""Unknown"": 685
  },
  ""ip_type"": {
    ""hosting & proxy"": 5,
    ""hosting"": 272,
    ""proxy"": 10,
    ""Unknown"": 398
  }
}"
VnHqCXSZ,Untitled,Zeinab_Hamdy,C++,Thursday 4th of July 2024 05:36:19 PM CDT,"#include ""bits/stdc++.h""
using namespace std;

#define nl ""\n""
#define ll long long
#define mod  1'000'000'007
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define sz(v) (int) v.size()

template<typename T = int>
istream &operator>>(istream &in, vector<T> &v) {
    for (auto &x: v) in >> x;
    return in;
}

template<typename T = int>
ostream &operator<<(ostream &out, const vector<T> &v) {
    for (const T &x: v) out << x << "" "";
    return out;
}

void Sira() {
    ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
#ifndef ONLINE_JUDGE
    freopen(""input.txt"", ""r"", stdin), freopen(""output.txt"", ""w"", stdout);
#endif
}
struct node {
    pair < ll , char > maxi;
    vector < int > max_freq;
    vector < int > freq;
    vector < pair < int , int >  > idx;

    node(){
        maxi = {0 , 'a'};
        freq.assign(26 , 0);
        max_freq.assign(26 , 0);
        idx.assign(26 , { 1e9 , -1});
    }

    node(char c , int i){
        idx[c - 'a'].first = min(idx[c - 'a'].first , i);
        idx[c - 'a'].second = max(idx[c - 'a'].second , i);
        freq[c - 'a']++;
    }
};

struct SegTree{
    int tree_size;
    vector < node > tree;

    SegTree(int n){
        tree_size = 1;
        while (tree_size < n) tree_size *= 2;
        tree.assign(2 * tree_size, node());
    }

    void build(string & s , int ni , int lx , int rx){
        if(rx - lx == 1){
            if(lx < sz(s)){
                tree[ni].idx[s[lx] - 'a'].first = min(tree[ni].idx[s[lx] - 'a'].first , lx);
                tree[ni].idx[s[lx] - 'a'].second = max(tree[ni].idx[s[lx] - 'a'].second , lx);
                tree[ni].freq[s[lx] - 'a']++;
            }
            return;
        }

        int mid = (lx + rx) / 2;
        build(s , 2 * ni + 1 , lx , mid);
        build(s , 2 * ni + 2 , mid , rx);

        tree[ni] = merge(tree[2 * ni + 1] , tree[2 * ni + 2]);
    }

    void build(string & s){
        build(s , 0 , 0 , tree_size);
    }

    node merge(node &l , node &r){
        node res;

        for(int i = 0 ; i < 26 ; i++){
            res.freq[i] = l.freq[i] + r.freq[i];
            res.max_freq[i] = max(res.max_freq[i] , res.freq[i]);
            res.idx[i].first = min(l.idx[i].first , r.idx[i].first);
            res.idx[i].second = max(l.idx[i].second , r.idx[i].second);
            res.maxi = max(res.maxi , {res.freq[i] , (char)(i + 'a')});
        }
//        res.maxi = max(l.maxi , r.maxi);
//        for(int i = 0; i < 26; i++){
//            res.freq[i] = l.freq[i] + r.freq[i];
//            res.maxi = max(res.maxi , {res.freq[i] , (char)(i + 'a')});
//            res.idx.
//        }
        return res;
    }

    void update(int idx , int val , int ni , int lx , int rx){
        if(rx - lx == 1){
            tree[ni].freq[val]++;
            return;
        }

        int mid = (lx + rx) / 2;
        if(idx < mid){
            update(idx , val , 2 * ni + 1 , lx , mid);
        }else{
            update(idx , val , 2 * ni + 2 , mid , rx);
        }

        tree[ni] = merge(tree[2 * ni + 1] , tree[2 * ni + 2]);
    }

    void update(int idx , int val){
        update(idx , val , 0 , 0 , tree_size);
    }

    node calc(int l , int r , int ni , int lx , int rx){
        if(lx >= r || l >= rx) return node();
        if(lx >= l && rx <= r) return tree[ni];

        int mid = (lx + rx) / 2;
        node left = calc(l , r , 2 * ni + 1 , lx , mid);
        node right = calc(l , r , 2 * ni + 2 , mid , rx);

        return merge(left , right);
    }

    node calc(int l , int r){
        return calc(l , r , 0 , 0 , tree_size);
    }
};

void solve(){
    int n;
    cin >> n;

    string s;
    cin >> s;

    SegTree st(n);
    st.build(s);


    int q;
    cin >> q;

    while(q--){
        int l , r;
        cin >> l >> r;
        l--;

        node curr = st.calc(l , r);
        bool ok = false;
        int c =-1 , fre=0;
        for(int i =0 ; i < 26 ; i++){
            if(curr.freq[i] > fre ) {
                fre = curr.freq[i];
                c = i;
            }
        }
        if(c == -1){
            cout << ""NO\n"";
            continue;
        }
        // cout << c << nl;

        for(int i = 0 ; i < 26 ; i++){
            if( !(curr.freq[i] and fre > curr.freq[i]) ) continue;

            if((curr.freq[i] == 1 and curr.idx[i].first != l)){
                ok = true;
                break;
            }
            if((curr.freq[i] > 1 and (curr.idx[i].first != l or curr.idx[i].first + curr.freq[i] != curr.idx[i].second))){
                ok = true;
                break;
            }
        }

        cout << (ok ? ""YES"" :  ""NO"") << nl;
    }

}

int main() {
    // Sira();
    int t = 1;
//    cin >> t;
    while(t--){
        solve();
    }
    return 0;
}
"
6akXtGCU,"""Button Status"" rev_31",pleasedontcode,Arduino,Thursday 4th of July 2024 05:00:05 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: ""Button Status""
	- Source Code compiled for: ESP32 DevKit V1
	- Source Code created on: 2024-07-04 21:59:06

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* print on serial button state. */
/****** END SYSTEM REQUIREMENTS *****/


/********* User code review feedback **********
#### Feedback 1 ####
- provide button status feedback on serial every 2s.
********* User code review feedback **********/

/****** DEFINITION OF LIBRARIES *****/
#include <EasyButton.h>  //https://github.com/evert-arias/EasyButton

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
void onPressed();

/***** DEFINITION OF DIGITAL INPUT PINS *****/
const uint8_t button_PushButton_PIN_D4 = 4;

/****** DEFINITION OF LIBRARIES CLASS INSTANCES*****/
EasyButton button(button_PushButton_PIN_D4);  // Initialize EasyButton instance

// Callback function to be called when the button is pressed.
void onPressed()
{
  Serial.println(""Button pressed"");
}

void setup(void)
{
  // Initialize Serial for debugging purposes.
  Serial.begin(115200);
  Serial.println();
  Serial.println("">>> EasyButton pressed example <<<"");

  // Initialize the button.
  button.begin();
  // Add the callback function to be called when the button is pressed.
  button.onPressed(onPressed);
}

void loop(void)
{
  // Continuously read the status of the button.
  button.read();

  // Print the current state of the button to the Serial monitor every 2 seconds.
  static unsigned long lastPrintTime = 0;
  unsigned long currentTime = millis();

  if (currentTime - lastPrintTime >= 2000) {
    if (button.isPressed()) {
      Serial.println(""Button is currently pressed"");
    } else {
      Serial.println(""Button is currently released"");
    }
    lastPrintTime = currentTime;
  }
}

/* END CODE */"
qHhXVQzZ,"""Button Status"" rev_30",pleasedontcode,Arduino,Thursday 4th of July 2024 04:58:34 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: ""Button Status""
	- Source Code NOT compiled for: ESP32 DevKit V1
	- Source Code created on: 2024-07-04 21:58:06

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* print on serial button state. */
/****** END SYSTEM REQUIREMENTS *****/


/********* User code review feedback **********
#### Feedback 1 ####
- provide button status feedback on serial every 2s.
********* User code review feedback **********/

/****** DEFINITION OF LIBRARIES *****/
#include <EasyButton.h>  //https://github.com/evert-arias/EasyButton

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
void onPressed();

/***** DEFINITION OF DIGITAL INPUT PINS *****/
const uint8_t button_PushButton_PIN_D4 = 4;

/****** DEFINITION OF LIBRARIES CLASS INSTANCES*****/
EasyButton button(button_PushButton_PIN_D4);  // Initialize EasyButton instance

// Callback function to be called when the button is pressed.
void onPressed()
{
  Serial.println(""Button pressed"");
}

void setup(void)
{
  // Initialize Serial for debugging purposes.
  Serial.begin(115200);
  Serial.println();
  Serial.println("">>> EasyButton pressed example <<<"");

  // Initialize the button.
  button.begin();
  // Add the callback function to be called when the button is pressed.
  button.onPressed(onPressed);
}

void loop(void)
{
  // Continuously read the status of the button.
  button.read();

  // Print the current state of the button to the Serial monitor every 2 seconds.
  static unsigned long lastPrintTime = 0;
  unsigned long currentTime = millis();

  if (currentTime - lastPrintTime >= 2000) {
    if (button.isPressed()) {
      Serial.println(""Button is currently pressed"");
    } else {
      Serial.println(""Button is currently released"");
    }
    lastPrintTime = currentTime;
  }
}

/* END CODE */"
aGsz7qZ5,js Test task,Pearlfromsu,JavaScript,Thursday 4th of July 2024 04:30:53 PM CDT,"<!DOCTYPE html>
<html>
  <head>
    <title>Hello World!</title>
    <link rel=""stylesheet"" href=""styles.css"" />
  </head>
  <body>
      <div>
        <label for=""text"">Enter your Todo text</label>
        <input id=""text"" placeholder=""something""/>
        <button onclick=""parseTodo()"">Add</button>
      </div>
      <div id=""todolist""></div>
      <script src=""script.js""></script>
  </body>
</html>

let todos = []
let ids = 0;

function parseTodo() {
  let textInput = document.querySelector(""#text"");
  addTodo(textInput.value)
}
function addTodo(text) {
  todos.push({id: ++ids, text: text});
  render();
}
function startEdit(id) {
  todos = todos.map(todo => todo.id === id ? {id, isEditing: true, ...todo} : todo);
  render();
}
function editTodo(id, newTodo) {
  todos = todos.map(todo => todo.id === id ? {id, isEditing: false, ...newTodo} : todo);
  render();
}
function removeTodo(id) {
  todos = todos.filter(todo => todo.id !== id);
  render();
}

function render() { //–û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –Ω–∞—à–∏ –¥–∞–Ω–Ω—ã–µ
  let todolist = document.querySelector(""#todolist""); //–ü–æ–ª—É—á–∞–µ–º —É–∑–µ–ª —Å–ø–∏—Å–∫–∞
  console.log(...todos) //–õ—é–±—É–µ–º—Å—è –≤ –∫–æ–Ω—Å–æ–ª–∏ –Ω–∞ –Ω–∞—à–∏ –¥–∞–Ω–Ω—ã–µ
  todolist.innerHTML = """"; //–°—Ç–∏—Ä–∞–µ–º —Ç–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫
  todos.forEach(todo => { //–ò–¥—ë–º –ø–æ –Ω–∞—à–∏–º —Ç—É–¥—É—à–∫–∞–º
    let todoBox = document.createElement(""div""); //–°–æ–∑–¥–∞—ë–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä —Ç—É–¥—É—à–∫–∏
    let removeButton = document.createElement(""button""); //–°–æ–∑–¥–∞—ë–º –∫–Ω–æ–ø–∫—É —É–¥–∞–ª–µ–Ω–∏—è —Ç—É–¥—É—à–∫–∏
    
    removeButton.textContent = ""X""; //–¢–µ–∫—Å—Ç –∫–Ω–æ–ø–∫–∏
    removeButton.addEventListener(""click"", () => removeTodo(todo.id)) //–ü—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ —É–¥–∞–ª—è–µ–º
    todoBox.appendChild(removeButton); //–¶–µ–ø–ª—è–µ–º –∫–Ω–æ–ø–∫—É –∫ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—É
    
    if(!todo?.isEditing) { //–ï—Å–ª–∏ –¢—É–¥—É—à–∫–∞ —Å–µ–π—á–∞—Å –Ω–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ—Ç—Å—è
      let textLabel = document.createElement(""a""); //–°–æ–∑–¥–∞—ë–º —ç–ª–µ–º–µ–Ω—Ç —Ç–µ–≥–∞ —Ç–µ–∫—Å—Ç–∞
      textLabel.textContent = todo.text; //–ó–∞–ø–æ–ª–Ω—è–µ–º —Ç–µ–∫—Å—Ç–æ–º
      todoBox.appendChild(textLabel); //–¶–µ–ø–ª—è–µ–º —Ç–µ–∫—Å—Ç –∫ –Ω–∞—à–µ–º—É –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—É
      
      let editButton = document.createElement(""button""); //–°–æ–∑–¥–∞—ë–º –∫–Ω–æ–ø–∫—É —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
      
      editButton.textContent = ""Edit""; //–£–∫–∞–∑—ã–≤–∞–µ–º —Ç–µ–∫—Å—Ç
      editButton.addEventListener(""click"", () => startEdit(todo.id)) //–ù–∞—á–∏–Ω–∞–µ–º —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏
      
      todoBox.appendChild(editButton); //—Ü–µ–ø–ª—è–µ–º –∫–Ω–æ–ø–∫—É —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∫ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—É —Ç—É–¥—É—à–∫–∏
    } else { //–ï—Å–ª–∏ –∂–µ —Ç—É–¥—É—à–∫–∞ —Å–µ–π—á–∞—Å —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ—Ç—Å—è
      let editInput = document.createElement(""input""); //–°–æ–∑–¥–∞—ë–º –ø–æ–ª–µ –≤–≤–æ–¥–∞
      editInput.value = todo.text; //–ó–∞–ø–æ–ª–Ω—è–µ–º –µ–≥–æ –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ —Ç–µ–∫—Å—Ç–æ–º —Å–∞–º–æ–π —Ç—É–¥—É—à–∫–∏
      todoBox.appendChild(editInput); //–¶–µ–ø–ª—è–µ–º –∏–Ω–ø—É—Ç –∫ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—É
      
      let editButton = document.createElement(""button""); //–°–æ–∑–¥–∞—ë–º –∫–Ω–æ–ø–∫—É –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
      
      editButton.textContent = ""V""; //–¢–µ–∫—Å—Ç –∫–Ω–æ–ø–∫–∏
      editButton.addEventListener(""click"", () => editTodo(todo.id, {text: editInput.value})) //–†–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º —Ç—É–¥—É—à–∫—É 
      
      todoBox.appendChild(editButton); //–¶–µ–ø–ª—è–µ–º –∫–Ω–æ–ø–∫—É –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∫ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—É
    }
    todolist.appendChild(todoBox) //–¶–µ–ø–ª—è–µ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∫ —Å–ø–∏—Å–∫—É
  });
}
"
uB298YTq,Untitled,Shiekh_ElArab,C++,Thursday 4th of July 2024 04:18:08 PM CDT,"#include <iostream>
#include <bits/stdc++.h>
#define ll long long;
using namespace std;
void Shiekh_Elarab()
{
    ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
#ifndef ONLINE_JUDGE
    freopen(""input.txt"", ""r"", stdin), freopen(""output.txt"", ""w"", stdout);
#endif
}

int main()
{
    Shiekh_Elarab();
    int count1 = 0;
    int count2 = 0;
    char S1, S2;
    cin >> S1 >> S2;
    while (S1 != '\0')
    {
        ++count1;
        ++S1;
    }
    while (S2 != '\0')
    {
        ++count2;
        ++S2;
    }
    cout << count1 << "" "" << count2;
}
"
7Nnc6zHD,Untitled,Ilya_Bykonya,Python,Thursday 4th of July 2024 03:57:46 PM CDT,"from microdot import Microdot, Response, send_file
from utemplate import recompile
import requests
import uasyncio
import uaioweb
import network
import machine
import urandom
import utime
import ujson
import usys


app = Microdot()
Response.default_content_type = 'text/html'

value = 42
@app.route('/value')
async def read(request):
    print(""Receive Get Request!"")
    return '42'
@app.route('/value/toggle')
async def toggle(request):
    print(""Receive Toggle Request!"")
    global value
    value = 228 if value == 42 else 42
    return ""OK""


flag = False
loader = recompile.Loader(None, 'templates')
@app.route('/')
async def index(request):
    global flag
    global loader
    return loader.load('index.html')(led_value = flag)
@app.route('/toggle')
async def toggle_led(request):
    global flag
    flag = False if flag else True
    return ""OK""




@app.route('/shutdown')
async def shutdown(request):
    request.app.shutdown()
    return 'The server is shutting down...'
@app.route('/static/<path:path>')
def static(request, path):
    if '..' in path:
        # directory traversal is not allowed
        return 'Not found', 404
    return send_file('static/' + path)
async def infinity_print(message: str, timeout_ms: int = 2500):
    while True:
        print(message)
        await uasyncio.sleep_ms(2500)

uasyncio.run(uasyncio.gather(
    app.start_server(host = '0.0.0.0', port = 8090, debug = True),
    infinity_print('he-he', 5000)
))

"
tE24ekxh,__init__.py Z3,max2201111,Python,Thursday 4th of July 2024 03:55:55 PM CDT,"# This file is part of the python-chess library.
# Copyright (C) 2012-2021 Niklas Fiekas <niklas.fiekas@backscattering.de>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

""""""
A chess library with move generation and validation,
Polyglot opening book probing, PGN reading and writing,
Gaviota tablebase probing,
Syzygy tablebase probing, and XBoard/UCI engine communication.
""""""

from __future__ import annotations

__author__ = ""Niklas Fiekas""

__email__ = ""niklas.fiekas@backscattering.de""

__version__ = ""1.10.0""

import collections
import copy
import dataclasses
import enum
import math
import re
import itertools
import typing

from typing import ClassVar, Callable, Counter, Dict, Generic, Hashable, Iterable, Iterator, List, Mapping, Optional, SupportsInt, Tuple, Type, TypeVar, Union

try:
    from typing import Literal
    _EnPassantSpec = Literal[""legal"", ""fen"", ""xfen""]
except ImportError:
    # Before Python 3.8.
    _EnPassantSpec = str  # type: ignore


Color = bool
COLORS = [WHITE, BLACK] = [True, False]
COLOR_NAMES = [""black"", ""white""]

PieceType = int
PIECE_TYPES = [PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING, AMAZON, CYRYL, EVE] = range(1, 10)
PIECE_SYMBOLS = [None, ""p"", ""n"", ""b"", ""r"", ""q"", ""k"", ""a"", ""c"", ""e""]
PIECE_NAMES = [None, ""pawn"", ""knight"", ""bishop"", ""rook"", ""queen"", ""king"", ""amazon"", ""cyryl"", ""eve""]

def piece_symbol(piece_type: PieceType) -> str:
    return typing.cast(str, PIECE_SYMBOLS[piece_type])

def piece_name(piece_type: PieceType) -> str:
    return typing.cast(str, PIECE_NAMES[piece_type])

UNICODE_PIECE_SYMBOLS = {
    ""R"": ""‚ôñ"", ""r"": ""‚ôú"",
    ""N"": ""‚ôò"", ""n"": ""‚ôû"",
    ""B"": ""‚ôó"", ""b"": ""‚ôù"",
    ""Q"": ""‚ôï"", ""q"": ""‚ôõ"",
    ""K"": ""‚ôî"", ""k"": ""‚ôö"",
    ""P"": ""‚ôô"", ""p"": ""‚ôü"",
}

FILE_NAMES = [""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h""]

RANK_NAMES = [""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8""]

STARTING_FEN = ""rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1""
""""""The FEN for the standard chess starting position.""""""

STARTING_BOARD_FEN = ""rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR""
""""""The board part of the FEN for the standard chess starting position.""""""


class Status(enum.IntFlag):
    VALID = 0
    NO_WHITE_KING = 1 << 0
    NO_BLACK_KING = 1 << 1
    TOO_MANY_KINGS = 1 << 2
    TOO_MANY_WHITE_PAWNS = 1 << 3
    TOO_MANY_BLACK_PAWNS = 1 << 4
    PAWNS_ON_BACKRANK = 1 << 5
    TOO_MANY_WHITE_PIECES = 1 << 6
    TOO_MANY_BLACK_PIECES = 1 << 7
    BAD_CASTLING_RIGHTS = 1 << 8
    INVALID_EP_SQUARE = 1 << 9
    OPPOSITE_CHECK = 1 << 10
    EMPTY = 1 << 11
    RACE_CHECK = 1 << 12
    RACE_OVER = 1 << 13
    RACE_MATERIAL = 1 << 14
    TOO_MANY_CHECKERS = 1 << 15
    IMPOSSIBLE_CHECK = 1 << 16

STATUS_VALID = Status.VALID
STATUS_NO_WHITE_KING = Status.NO_WHITE_KING
STATUS_NO_BLACK_KING = Status.NO_BLACK_KING
STATUS_TOO_MANY_KINGS = Status.TOO_MANY_KINGS
STATUS_TOO_MANY_WHITE_PAWNS = Status.TOO_MANY_WHITE_PAWNS
STATUS_TOO_MANY_BLACK_PAWNS = Status.TOO_MANY_BLACK_PAWNS
STATUS_PAWNS_ON_BACKRANK = Status.PAWNS_ON_BACKRANK
STATUS_TOO_MANY_WHITE_PIECES = Status.TOO_MANY_WHITE_PIECES
STATUS_TOO_MANY_BLACK_PIECES = Status.TOO_MANY_BLACK_PIECES
STATUS_BAD_CASTLING_RIGHTS = Status.BAD_CASTLING_RIGHTS
STATUS_INVALID_EP_SQUARE = Status.INVALID_EP_SQUARE
STATUS_OPPOSITE_CHECK = Status.OPPOSITE_CHECK
STATUS_EMPTY = Status.EMPTY
STATUS_RACE_CHECK = Status.RACE_CHECK
STATUS_RACE_OVER = Status.RACE_OVER
STATUS_RACE_MATERIAL = Status.RACE_MATERIAL
STATUS_TOO_MANY_CHECKERS = Status.TOO_MANY_CHECKERS
STATUS_IMPOSSIBLE_CHECK = Status.IMPOSSIBLE_CHECK


class Termination(enum.Enum):
    """"""Enum with reasons for a game to be over.""""""

    CHECKMATE = enum.auto()
    """"""See :func:`chess.Board.is_checkmate()`.""""""
    STALEMATE = enum.auto()
    """"""See :func:`chess.Board.is_stalemate()`.""""""
    INSUFFICIENT_MATERIAL = enum.auto()
    """"""See :func:`chess.Board.is_insufficient_material()`.""""""
    SEVENTYFIVE_MOVES = enum.auto()
    """"""See :func:`chess.Board.is_seventyfive_moves()`.""""""
    FIVEFOLD_REPETITION = enum.auto()
    """"""See :func:`chess.Board.is_fivefold_repetition()`.""""""
    FIFTY_MOVES = enum.auto()
    """"""See :func:`chess.Board.can_claim_fifty_moves()`.""""""
    THREEFOLD_REPETITION = enum.auto()
    """"""See :func:`chess.Board.can_claim_threefold_repetition()`.""""""
    VARIANT_WIN = enum.auto()
    """"""See :func:`chess.Board.is_variant_win()`.""""""
    VARIANT_LOSS = enum.auto()
    """"""See :func:`chess.Board.is_variant_loss()`.""""""
    VARIANT_DRAW = enum.auto()
    """"""See :func:`chess.Board.is_variant_draw()`.""""""

@dataclasses.dataclass
class Outcome:
    """"""
    Information about the outcome of an ended game, usually obtained from
    :func:`chess.Board.outcome()`.
    """"""

    termination: Termination
    """"""The reason for the game to have ended.""""""

    winner: Optional[Color]
    """"""The winning color or ``None`` if drawn.""""""

    def result(self) -> str:
        """"""Returns ``1-0``, ``0-1`` or ``1/2-1/2``.""""""
        return ""1/2-1/2"" if self.winner is None else (""1-0"" if self.winner else ""0-1"")


class InvalidMoveError(ValueError):
    """"""Raised when move notation is not syntactically valid""""""


class IllegalMoveError(ValueError):
    """"""Raised when the attempted move is illegal in the current position""""""


class AmbiguousMoveError(ValueError):
    """"""Raised when the attempted move is ambiguous in the current position""""""


Square = int
SQUARES = [
    A1, B1, C1, D1, E1, F1, G1, H1,
    A2, B2, C2, D2, E2, F2, G2, H2,
    A3, B3, C3, D3, E3, F3, G3, H3,
    A4, B4, C4, D4, E4, F4, G4, H4,
    A5, B5, C5, D5, E5, F5, G5, H5,
    A6, B6, C6, D6, E6, F6, G6, H6,
    A7, B7, C7, D7, E7, F7, G7, H7,
    A8, B8, C8, D8, E8, F8, G8, H8,
] = range(64)

SQUARE_NAMES = [f + r for r in RANK_NAMES for f in FILE_NAMES]

def parse_square(name: str) -> Square:
    """"""
    Gets the square index for the given square *name*
    (e.g., ``a1`` returns ``0``).

    :raises: :exc:`ValueError` if the square name is invalid.
    """"""
    return SQUARE_NAMES.index(name)

def square_name(square: Square) -> str:
    """"""Gets the name of the square, like ``a3``.""""""
    return SQUARE_NAMES[square]

def square(file_index: int, rank_index: int) -> Square:
    """"""Gets a square number by file and rank index.""""""
    return rank_index * 8 + file_index

def square_file(square: Square) -> int:
    """"""Gets the file index of the square where ``0`` is the a-file.""""""
    return square & 7

def square_rank(square: Square) -> int:
    """"""Gets the rank index of the square where ``0`` is the first rank.""""""
    return square >> 3

def square_distance(a: Square, b: Square) -> int:
    """"""
    Gets the Chebyshev distance (i.e., the number of king steps) from square *a* to *b*.
    """"""
    return max(abs(square_file(a) - square_file(b)), abs(square_rank(a) - square_rank(b)))

def square_manhattan_distance(a: Square, b: Square) -> int:
    """"""
    Gets the Manhattan/Taxicab distance (i.e., the number of orthogonal king steps) from square *a* to *b*.
    """"""
    return abs(square_file(a) - square_file(b)) + abs(square_rank(a) - square_rank(b))

def square_knight_distance(a: Square, b: Square) -> int:
    """"""
    Gets the Knight distance (i.e., the number of knight moves) from square *a* to *b*.
    """"""
    dx = abs(square_file(a) - square_file(b))
    dy = abs(square_rank(a) - square_rank(b))

    if dx + dy == 1:
        return 3
    elif dx == dy == 2:
        return 4
    elif dx == dy == 1:
        if BB_SQUARES[a] & BB_CORNERS or BB_SQUARES[b] & BB_CORNERS: # Special case only for corner squares
            return 4

    m = math.ceil(max(dx / 2, dy / 2, (dx + dy) / 3))
    return m + ((m + dx + dy) % 2)

def square_mirror(square: Square) -> Square:
    """"""Mirrors the square vertically.""""""
    return square ^ 0x38

SQUARES_180 = [square_mirror(sq) for sq in SQUARES]


Bitboard = int
BB_EMPTY = 0
BB_ALL = 0xffff_ffff_ffff_ffff

BB_SQUARES = [
    BB_A1, BB_B1, BB_C1, BB_D1, BB_E1, BB_F1, BB_G1, BB_H1,
    BB_A2, BB_B2, BB_C2, BB_D2, BB_E2, BB_F2, BB_G2, BB_H2,
    BB_A3, BB_B3, BB_C3, BB_D3, BB_E3, BB_F3, BB_G3, BB_H3,
    BB_A4, BB_B4, BB_C4, BB_D4, BB_E4, BB_F4, BB_G4, BB_H4,
    BB_A5, BB_B5, BB_C5, BB_D5, BB_E5, BB_F5, BB_G5, BB_H5,
    BB_A6, BB_B6, BB_C6, BB_D6, BB_E6, BB_F6, BB_G6, BB_H6,
    BB_A7, BB_B7, BB_C7, BB_D7, BB_E7, BB_F7, BB_G7, BB_H7,
    BB_A8, BB_B8, BB_C8, BB_D8, BB_E8, BB_F8, BB_G8, BB_H8,
] = [1 << sq for sq in SQUARES]

BB_CORNERS = BB_A1 | BB_H1 | BB_A8 | BB_H8
BB_CENTER = BB_D4 | BB_E4 | BB_D5 | BB_E5

BB_LIGHT_SQUARES = 0x55aa_55aa_55aa_55aa
BB_DARK_SQUARES = 0xaa55_aa55_aa55_aa55

BB_FILES = [
    BB_FILE_A,
    BB_FILE_B,
    BB_FILE_C,
    BB_FILE_D,
    BB_FILE_E,
    BB_FILE_F,
    BB_FILE_G,
    BB_FILE_H,
] = [0x0101_0101_0101_0101 << i for i in range(8)]

BB_RANKS = [
    BB_RANK_1,
    BB_RANK_2,
    BB_RANK_3,
    BB_RANK_4,
    BB_RANK_5,
    BB_RANK_6,
    BB_RANK_7,
    BB_RANK_8,
] = [0xff << (8 * i) for i in range(8)]

BB_BACKRANKS = BB_RANK_1 | BB_RANK_8


def lsb(bb: Bitboard) -> int:
    return (bb & -bb).bit_length() - 1

def scan_forward(bb: Bitboard) -> Iterator[Square]:
    while bb:
        r = bb & -bb
        yield r.bit_length() - 1
        bb ^= r

def msb(bb: Bitboard) -> int:
    return bb.bit_length() - 1

def scan_reversed(bb: Bitboard) -> Iterator[Square]:
    while bb:
        r = bb.bit_length() - 1
        yield r
        bb ^= BB_SQUARES[r]

# Python 3.10 or fallback.
popcount: Callable[[Bitboard], int] = getattr(int, ""bit_count"", lambda bb: bin(bb).count(""1""))

def flip_vertical(bb: Bitboard) -> Bitboard:
    # https://www.chessprogramming.org/Flipping_Mirroring_and_Rotating#FlipVertically
    bb = ((bb >> 8) & 0x00ff_00ff_00ff_00ff) | ((bb & 0x00ff_00ff_00ff_00ff) << 8)
    bb = ((bb >> 16) & 0x0000_ffff_0000_ffff) | ((bb & 0x0000_ffff_0000_ffff) << 16)
    bb = (bb >> 32) | ((bb & 0x0000_0000_ffff_ffff) << 32)
    return bb

def flip_horizontal(bb: Bitboard) -> Bitboard:
    # https://www.chessprogramming.org/Flipping_Mirroring_and_Rotating#MirrorHorizontally
    bb = ((bb >> 1) & 0x5555_5555_5555_5555) | ((bb & 0x5555_5555_5555_5555) << 1)
    bb = ((bb >> 2) & 0x3333_3333_3333_3333) | ((bb & 0x3333_3333_3333_3333) << 2)
    bb = ((bb >> 4) & 0x0f0f_0f0f_0f0f_0f0f) | ((bb & 0x0f0f_0f0f_0f0f_0f0f) << 4)
    return bb

def flip_diagonal(bb: Bitboard) -> Bitboard:
    # https://www.chessprogramming.org/Flipping_Mirroring_and_Rotating#FlipabouttheDiagonal
    t = (bb ^ (bb << 28)) & 0x0f0f_0f0f_0000_0000
    bb = bb ^ t ^ (t >> 28)
    t = (bb ^ (bb << 14)) & 0x3333_0000_3333_0000
    bb = bb ^ t ^ (t >> 14)
    t = (bb ^ (bb << 7)) & 0x5500_5500_5500_5500
    bb = bb ^ t ^ (t >> 7)
    return bb

def flip_anti_diagonal(bb: Bitboard) -> Bitboard:
    # https://www.chessprogramming.org/Flipping_Mirroring_and_Rotating#FlipabouttheAntidiagonal
    t = bb ^ (bb << 36)
    bb = bb ^ ((t ^ (bb >> 36)) & 0xf0f0_f0f0_0f0f_0f0f)
    t = (bb ^ (bb << 18)) & 0xcccc_0000_cccc_0000
    bb = bb ^ t ^ (t >> 18)
    t = (bb ^ (bb << 9)) & 0xaa00_aa00_aa00_aa00
    bb = bb ^ t ^ (t >> 9)
    return bb


def shift_down(b: Bitboard) -> Bitboard:
    return b >> 8

def shift_2_down(b: Bitboard) -> Bitboard:
    return b >> 16

def shift_up(b: Bitboard) -> Bitboard:
    return (b << 8) & BB_ALL

def shift_2_up(b: Bitboard) -> Bitboard:
    return (b << 16) & BB_ALL

def shift_right(b: Bitboard) -> Bitboard:
    return (b << 1) & ~BB_FILE_A & BB_ALL

def shift_2_right(b: Bitboard) -> Bitboard:
    return (b << 2) & ~BB_FILE_A & ~BB_FILE_B & BB_ALL

def shift_left(b: Bitboard) -> Bitboard:
    return (b >> 1) & ~BB_FILE_H

def shift_2_left(b: Bitboard) -> Bitboard:
    return (b >> 2) & ~BB_FILE_G & ~BB_FILE_H

def shift_up_left(b: Bitboard) -> Bitboard:
    return (b << 7) & ~BB_FILE_H & BB_ALL

def shift_up_right(b: Bitboard) -> Bitboard:
    return (b << 9) & ~BB_FILE_A & BB_ALL

def shift_down_left(b: Bitboard) -> Bitboard:
    return (b >> 9) & ~BB_FILE_H

def shift_down_right(b: Bitboard) -> Bitboard:
    return (b >> 7) & ~BB_FILE_A


def _sliding_attacks(square: Square, occupied: Bitboard, deltas: Iterable[int]) -> Bitboard:
    attacks = BB_EMPTY

    for delta in deltas:
        sq = square

        while True:
            sq += delta
            if not (0 <= sq < 64) or square_distance(sq, sq - delta) > 2:
                break

            attacks |= BB_SQUARES[sq]

            if occupied & BB_SQUARES[sq]:
                break

    return attacks

def _step_attacks(square: Square, deltas: Iterable[int]) -> Bitboard:
    return _sliding_attacks(square, BB_ALL, deltas)

BB_KNIGHT_ATTACKS = [_step_attacks(sq, [17, 15, 10, 6, -17, -15, -10, -6]) for sq in SQUARES]
BB_KING_ATTACKS = [_step_attacks(sq, [9, 8, 7, 1, -9, -8, -7, -1]) for sq in SQUARES]
BB_PAWN_ATTACKS = [[_step_attacks(sq, deltas) for sq in SQUARES] for deltas in [[-7, -9], [7, 9]]]


def _edges(square: Square) -> Bitboard:
    return (((BB_RANK_1 | BB_RANK_8) & ~BB_RANKS[square_rank(square)]) |
            ((BB_FILE_A | BB_FILE_H) & ~BB_FILES[square_file(square)]))

def _carry_rippler(mask: Bitboard) -> Iterator[Bitboard]:
    # Carry-Rippler trick to iterate subsets of mask.
    subset = BB_EMPTY
    while True:
        yield subset
        subset = (subset - mask) & mask
        if not subset:
            break

def _attack_table(deltas: List[int]) -> Tuple[List[Bitboard], List[Dict[Bitboard, Bitboard]]]:
    mask_table = []
    attack_table = []

    for square in SQUARES:
        attacks = {}

        mask = _sliding_attacks(square, 0, deltas) & ~_edges(square)
        for subset in _carry_rippler(mask):
            attacks[subset] = _sliding_attacks(square, subset, deltas)

        attack_table.append(attacks)
        mask_table.append(mask)

    return mask_table, attack_table

BB_DIAG_MASKS, BB_DIAG_ATTACKS = _attack_table([-9, -7, 7, 9])
BB_FILE_MASKS, BB_FILE_ATTACKS = _attack_table([-8, 8])
BB_RANK_MASKS, BB_RANK_ATTACKS = _attack_table([-1, 1])


def _rays() -> List[List[Bitboard]]:
    rays = []
    for a, bb_a in enumerate(BB_SQUARES):
        rays_row = []
        for b, bb_b in enumerate(BB_SQUARES):
            if BB_DIAG_ATTACKS[a][0] & bb_b:
                rays_row.append((BB_DIAG_ATTACKS[a][0] & BB_DIAG_ATTACKS[b][0]) | bb_a | bb_b)
            elif BB_RANK_ATTACKS[a][0] & bb_b:
                rays_row.append(BB_RANK_ATTACKS[a][0] | bb_a)
            elif BB_FILE_ATTACKS[a][0] & bb_b:
                rays_row.append(BB_FILE_ATTACKS[a][0] | bb_a)
            else:
                rays_row.append(BB_EMPTY)
        rays.append(rays_row)
    return rays

BB_RAYS = _rays()

def ray(a: Square, b: Square) -> Bitboard:
    return BB_RAYS[a][b]

def between(a: Square, b: Square) -> Bitboard:
    bb = BB_RAYS[a][b] & ((BB_ALL << a) ^ (BB_ALL << b))
    return bb & (bb - 1)


SAN_REGEX = re.compile(r""^([NBKRQ])?([a-h])?([1-8])?[\-x]?([a-h][1-8])(=?[nbrqkNBRQK])?[\+#]?\Z"")

FEN_CASTLING_REGEX = re.compile(r""^(?:-|[KQABCDEFGH]{0,2}[kqabcdefgh]{0,2})\Z"")


@dataclasses.dataclass
class Piece:
    """"""A piece with type and color.""""""

    piece_type: PieceType
    """"""The piece type.""""""

    color: Color
    """"""The piece color.""""""

    def symbol(self) -> str:
        """"""
        Gets the symbol ``P``, ``N``, ``B``, ``R``, ``Q`` or ``K`` for white
        pieces or the lower-case variants for the black pieces.
        """"""
        symbol = piece_symbol(self.piece_type)
        return symbol.upper() if self.color else symbol

    def unicode_symbol(self, *, invert_color: bool = False) -> str:
        """"""
        Gets the Unicode character for the piece.
        """"""
        symbol = self.symbol().swapcase() if invert_color else self.symbol()
        return UNICODE_PIECE_SYMBOLS[symbol]

    def __hash__(self) -> int:
        return self.piece_type + (-1 if self.color else 5)

    def __repr__(self) -> str:
        return f""Piece.from_symbol({self.symbol()!r})""

    def __str__(self) -> str:
        return self.symbol()

    def _repr_svg_(self) -> str:
        import chess.svg
        return chess.svg.piece(self, size=45)

    @classmethod
    def from_symbol(cls, symbol: str) -> Piece:
        """"""
        Creates a :class:`~chess.Piece` instance from a piece symbol.

        :raises: :exc:`ValueError` if the symbol is invalid.
        """"""
        return cls(PIECE_SYMBOLS.index(symbol.lower()), symbol.isupper())


@dataclasses.dataclass(unsafe_hash=True)
class Move:
    """"""
    Represents a move from a square to a square and possibly the promotion
    piece type.

    Drops and null moves are supported.
    """"""

    from_square: Square
    """"""The source square.""""""

    to_square: Square
    """"""The target square.""""""

    promotion: Optional[PieceType] = None
    """"""The promotion piece type or ``None``.""""""

    drop: Optional[PieceType] = None
    """"""The drop piece type or ``None``.""""""

    def uci(self) -> str:
        """"""
        Gets a UCI string for the move.

        For example, a move from a7 to a8 would be ``a7a8`` or ``a7a8q``
        (if the latter is a promotion to a queen).

        The UCI representation of a null move is ``0000``.
        """"""
        if self.drop:
            return piece_symbol(self.drop).upper() + ""@"" + SQUARE_NAMES[self.to_square]
        elif self.promotion:
            return SQUARE_NAMES[self.from_square] + SQUARE_NAMES[self.to_square] + piece_symbol(self.promotion)
        elif self:
            return SQUARE_NAMES[self.from_square] + SQUARE_NAMES[self.to_square]
        else:
            return ""0000""

    def xboard(self) -> str:
        return self.uci() if self else ""@@@@""

    def __bool__(self) -> bool:
        return bool(self.from_square or self.to_square or self.promotion or self.drop)

    def __repr__(self) -> str:
        return f""Move.from_uci({self.uci()!r})""

    def __str__(self) -> str:
        return self.uci()

    @classmethod
    def from_uci(cls, uci: str) -> Move:
        """"""
        Parses a UCI string.

        :raises: :exc:`InvalidMoveError` if the UCI string is invalid.
        """"""
        if uci == ""0000"":
            return cls.null()
        elif len(uci) == 4 and ""@"" == uci[1]:
            try:
                drop = PIECE_SYMBOLS.index(uci[0].lower())
                square = SQUARE_NAMES.index(uci[2:])
            except ValueError:
                raise InvalidMoveError(f""invalid uci: {uci!r}"")
            return cls(square, square, drop=drop)
        elif 4 <= len(uci) <= 5:
            try:
                from_square = SQUARE_NAMES.index(uci[0:2])
                to_square = SQUARE_NAMES.index(uci[2:4])
                promotion = PIECE_SYMBOLS.index(uci[4]) if len(uci) == 5 else None
            except ValueError:
                raise InvalidMoveError(f""invalid uci: {uci!r}"")
            if from_square == to_square:
                raise InvalidMoveError(f""invalid uci (use 0000 for null moves): {uci!r}"")
            return cls(from_square, to_square, promotion=promotion)
        else:
            raise InvalidMoveError(f""expected uci string to be of length 4 or 5: {uci!r}"")

    @classmethod
    def null(cls) -> Move:
        """"""
        Gets a null move.

        A null move just passes the turn to the other side (and possibly
        forfeits en passant capturing). Null moves evaluate to ``False`` in
        boolean contexts.

        >>> import chess
        >>>
        >>> bool(chess.Move.null())
        False
        """"""
        return cls(0, 0)


BaseBoardT = TypeVar(""BaseBoardT"", bound=""BaseBoard"")

class BaseBoard:
    """"""
    A board representing the position of chess pieces. See
    :class:`~chess.Board` for a full board with move generation.

    The board is initialized with the standard chess starting position, unless
    otherwise specified in the optional *board_fen* argument. If *board_fen*
    is ``None``, an empty board is created.
    """"""

    def __init__(self, board_fen: Optional[str] = STARTING_BOARD_FEN) -> None:
        self.occupied_co = [BB_EMPTY, BB_EMPTY]

        if board_fen is None:
            self._clear_board()
        elif board_fen == STARTING_BOARD_FEN:
            self._reset_board()
        else:
            self._set_board_fen(board_fen)

    def _reset_board(self) -> None:
        self.pawns = BB_RANK_2 | BB_RANK_7
        self.knights = BB_B1 | BB_G1 | BB_B8 | BB_G8
        self.bishops = BB_C1 | BB_F1 | BB_C8 | BB_F8
        self.rooks = BB_CORNERS
        self.queens = BB_D1 | BB_D8
        self.kings = BB_E1 | BB_E8

        self.promoted = BB_EMPTY

        self.occupied_co[WHITE] = BB_RANK_1 | BB_RANK_2
        self.occupied_co[BLACK] = BB_RANK_7 | BB_RANK_8
        self.occupied = BB_RANK_1 | BB_RANK_2 | BB_RANK_7 | BB_RANK_8

    def reset_board(self) -> None:
        """"""
        Resets pieces to the starting position.

        :class:`~chess.Board` also resets the move stack, but not turn,
        castling rights and move counters. Use :func:`chess.Board.reset()` to
        fully restore the starting position.
        """"""
        self._reset_board()

    def _clear_board(self) -> None:
        self.pawns = BB_EMPTY
        self.knights = BB_EMPTY
        self.bishops = BB_EMPTY
        self.rooks = BB_EMPTY
        self.queens = BB_EMPTY
        self.kings = BB_EMPTY

        self.promoted = BB_EMPTY

        self.occupied_co[WHITE] = BB_EMPTY
        self.occupied_co[BLACK] = BB_EMPTY
        self.occupied = BB_EMPTY

    def clear_board(self) -> None:
        """"""
        Clears the board.

        :class:`~chess.Board` also clears the move stack.
        """"""
        self._clear_board()

    def pieces_mask(self, piece_type: PieceType, color: Color) -> Bitboard:
        if piece_type == PAWN:
            bb = self.pawns
        elif piece_type == KNIGHT:
            bb = self.knights
        elif piece_type == BISHOP:
            bb = self.bishops
        elif piece_type == ROOK:
            bb = self.rooks
        elif piece_type == QUEEN:
            bb = self.queens
        elif piece_type == KING:
            bb = self.kings
        else:
            assert False, f""expected PieceType, got {piece_type!r}""

        return bb & self.occupied_co[color]

    def pieces(self, piece_type: PieceType, color: Color) -> SquareSet:
        """"""
        Gets pieces of the given type and color.

        Returns a :class:`set of squares <chess.SquareSet>`.
        """"""
        return SquareSet(self.pieces_mask(piece_type, color))

    def piece_at(self, square: Square) -> Optional[Piece]:
        """"""Gets the :class:`piece <chess.Piece>` at the given square.""""""
        piece_type = self.piece_type_at(square)
        if piece_type:
            mask = BB_SQUARES[square]
            color = bool(self.occupied_co[WHITE] & mask)
            return Piece(piece_type, color)
        else:
            return None

    def piece_type_at(self, square: Square) -> Optional[PieceType]:
        """"""Gets the piece type at the given square.""""""
        mask = BB_SQUARES[square]

        if not self.occupied & mask:
            return None  # Early return
        elif self.pawns & mask:
            return PAWN
        elif self.knights & mask:
            return KNIGHT
        elif self.bishops & mask:
            return BISHOP
        elif self.rooks & mask:
            return ROOK
        elif self.queens & mask:
            return QUEEN
        else:
            return KING

    def color_at(self, square: Square) -> Optional[Color]:
        """"""Gets the color of the piece at the given square.""""""
        mask = BB_SQUARES[square]
        if self.occupied_co[WHITE] & mask:
            return WHITE
        elif self.occupied_co[BLACK] & mask:
            return BLACK
        else:
            return None

    def king(self, color: Color) -> Optional[Square]:
        """"""
        Finds the king square of the given side. Returns ``None`` if there
        is no king of that color.

        In variants with king promotions, only non-promoted kings are
        considered.
        """"""
        king_mask = self.occupied_co[color] & self.kings & ~self.promoted
        return msb(king_mask) if king_mask else None

    def attacks_mask(self, piece_type, square, occupied) -> Bitboard:
        bb_square = BB_SQUARES[square]

        if bb_square & self.pawns:
            color = bool(bb_square & self.occupied_co[WHITE])
            return BB_PAWN_ATTACKS[color][square]
        elif bb_square & self.knights:
            return BB_KNIGHT_ATTACKS[square]
        elif bb_square & self.kings:
            return BB_KING_ATTACKS[square]
        else:
            attacks = 0
            if bb_square & self.bishops or bb_square & self.queens:
                attacks = BB_DIAG_ATTACKS[square][BB_DIAG_MASKS[square] & self.occupied]
            if bb_square & self.rooks or bb_square & self.queens:
                attacks |= (BB_RANK_ATTACKS[square][BB_RANK_MASKS[square] & self.occupied] |
                            BB_FILE_ATTACKS[square][BB_FILE_MASKS[square] & self.occupied])
            return attacks

    def attacks(self, square: Square) -> SquareSet:
        """"""
        Gets the set of attacked squares from the given square.

        There will be no attacks if the square is empty. Pinned pieces are
        still attacking other squares.

        Returns a :class:`set of squares <chess.SquareSet>`.
        """"""
        return SquareSet(self.attacks_mask(square))

    def _attackers_mask(self, color: Color, square: Square, occupied: Bitboard) -> Bitboard:
        rank_pieces = BB_RANK_MASKS[square] & occupied
        file_pieces = BB_FILE_MASKS[square] & occupied
        diag_pieces = BB_DIAG_MASKS[square] & occupied

        queens_and_rooks = self.queens | self.rooks
        queens_and_bishops = self.queens | self.bishops

        attackers = (
            (BB_KING_ATTACKS[square] & self.kings) |
            (BB_KNIGHT_ATTACKS[square] & self.knights) |
            (BB_RANK_ATTACKS[square][rank_pieces] & queens_and_rooks) |
            (BB_FILE_ATTACKS[square][file_pieces] & queens_and_rooks) |
            (BB_DIAG_ATTACKS[square][diag_pieces] & queens_and_bishops) |
            (BB_PAWN_ATTACKS[not color][square] & self.pawns))

        return attackers & self.occupied_co[color]

    def attackers_mask(self, color: Color, square: Square) -> Bitboard:
        return self._attackers_mask(color, square, self.occupied)

    def is_attacked_by(self, color: Color, square: Square) -> bool:
        """"""
        Checks if the given side attacks the given square.

        Pinned pieces still count as attackers. Pawns that can be captured
        en passant are **not** considered attacked.
        """"""
        return bool(self.attackers_mask(color, square))

    def attackers(self, color: Color, square: Square) -> SquareSet:
        """"""
        Gets the set of attackers of the given color for the given square.

        Pinned pieces still count as attackers.

        Returns a :class:`set of squares <chess.SquareSet>`.
        """"""
        return SquareSet(self.attackers_mask(color, square))

    def pin_mask(self, color: Color, square: Square) -> Bitboard:
        king = self.king(color)
        if king is None:
            return BB_ALL

        square_mask = BB_SQUARES[square]

        for attacks, sliders in [(BB_FILE_ATTACKS, self.rooks | self.queens),
                                 (BB_RANK_ATTACKS, self.rooks | self.queens),
                                 (BB_DIAG_ATTACKS, self.bishops | self.queens)]:
            rays = attacks[king][0]
            if rays & square_mask:
                snipers = rays & sliders & self.occupied_co[not color]
                for sniper in scan_reversed(snipers):
                    if between(sniper, king) & (self.occupied | square_mask) == square_mask:
                        return ray(king, sniper)

                break

        return BB_ALL

    def pin(self, color: Color, square: Square) -> SquareSet:
        """"""
        Detects an absolute pin (and its direction) of the given square to
        the king of the given color.

        >>> import chess
        >>>
        >>> board = chess.Board(""rnb1k2r/ppp2ppp/5n2/3q4/1b1P4/2N5/PP3PPP/R1BQKBNR w KQkq - 3 7"")
        >>> board.is_pinned(chess.WHITE, chess.C3)
        True
        >>> direction = board.pin(chess.WHITE, chess.C3)
        >>> direction
        SquareSet(0x0000_0001_0204_0810)
        >>> print(direction)
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        1 . . . . . . .
        . 1 . . . . . .
        . . 1 . . . . .
        . . . 1 . . . .
        . . . . 1 . . .

        Returns a :class:`set of squares <chess.SquareSet>` that mask the rank,
        file or diagonal of the pin. If there is no pin, then a mask of the
        entire board is returned.
        """"""
        return SquareSet(self.pin_mask(color, square))

    def is_pinned(self, color: Color, square: Square) -> bool:
        """"""
        Detects if the given square is pinned to the king of the given color.
        """"""
        return self.pin_mask(color, square) != BB_ALL

    def _remove_piece_at(self, square: Square) -> Optional[PieceType]:
        piece_type = self.piece_type_at(square)
        mask = BB_SQUARES[square]

        if piece_type == PAWN:
            self.pawns ^= mask
        elif piece_type == KNIGHT:
            self.knights ^= mask
        elif piece_type == BISHOP:
            self.bishops ^= mask
        elif piece_type == ROOK:
            self.rooks ^= mask
        elif piece_type == QUEEN:
            self.queens ^= mask
        elif piece_type == KING:
            self.kings ^= mask
        else:
            return None

        self.occupied ^= mask
        self.occupied_co[WHITE] &= ~mask
        self.occupied_co[BLACK] &= ~mask

        self.promoted &= ~mask

        return piece_type

    def remove_piece_at(self, square: Square) -> Optional[Piece]:
        """"""
        Removes the piece from the given square. Returns the
        :class:`~chess.Piece` or ``None`` if the square was already empty.

        :class:`~chess.Board` also clears the move stack.
        """"""
        color = bool(self.occupied_co[WHITE] & BB_SQUARES[square])
        piece_type = self._remove_piece_at(square)
        return Piece(piece_type, color) if piece_type else None

    def _set_piece_at(self, square: Square, piece_type: PieceType, color: Color, promoted: bool = False) -> None:
        self._remove_piece_at(square)

        mask = BB_SQUARES[square]

        if piece_type == PAWN:
            self.pawns |= mask
        elif piece_type == KNIGHT:
            self.knights |= mask
        elif piece_type == BISHOP:
            self.bishops |= mask
        elif piece_type == ROOK:
            self.rooks |= mask
        elif piece_type == QUEEN:
            self.queens |= mask
        elif piece_type == KING:
            self.kings |= mask
        else:
            return

        self.occupied ^= mask
        self.occupied_co[color] ^= mask

        if promoted:
            self.promoted ^= mask

    def set_piece_at(self, square: Square, piece: Optional[Piece], promoted: bool = False) -> None:
        """"""
        Sets a piece at the given square.

        An existing piece is replaced. Setting *piece* to ``None`` is
        equivalent to :func:`~chess.Board.remove_piece_at()`.

        :class:`~chess.Board` also clears the move stack.
        """"""
        if piece is None:
            self._remove_piece_at(square)
        else:
            self._set_piece_at(square, piece.piece_type, piece.color, promoted)

    def board_fen(self, *, promoted: Optional[bool] = False) -> str:
        """"""
        Gets the board FEN (e.g.,
        ``rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR``).
        """"""
        builder = []
        empty = 0

        for square in SQUARES_180:
            piece = self.piece_at(square)

            if not piece:
                empty += 1
            else:
                if empty:
                    builder.append(str(empty))
                    empty = 0
                builder.append(piece.symbol())
                if promoted and BB_SQUARES[square] & self.promoted:
                    builder.append(""~"")

            if BB_SQUARES[square] & BB_FILE_H:
                if empty:
                    builder.append(str(empty))
                    empty = 0

                if square != H1:
                    builder.append(""/"")

        return """".join(builder)

    def _set_board_fen(self, fen: str) -> None:
        # Compatibility with set_fen().
        fen = fen.strip()
        if "" "" in fen:
            raise ValueError(f""expected position part of fen, got multiple parts: {fen!r}"")

        # Ensure the FEN is valid.
        rows = fen.split(""/"")
        if len(rows) != 8:
            raise ValueError(f""expected 8 rows in position part of fen: {fen!r}"")

        # Validate each row.
        for row in rows:
            field_sum = 0
            previous_was_digit = False
            previous_was_piece = False

            for c in row:
                if c in [""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8""]:
                    if previous_was_digit:
                        pass
  #                      raise ValueError(f""two subsequent digits in position part of fen: {fen!r}"")
                    field_sum += int(c)
                    previous_was_digit = True
                    previous_was_piece = False
                elif c == ""~"":
                    if not previous_was_piece:
                        raise ValueError(f""'~' not after piece in position part of fen: {fen!r}"")
                    previous_was_digit = False
                    previous_was_piece = False
                elif c.lower() in PIECE_SYMBOLS:
                    field_sum += 1
                    previous_was_digit = False
                    previous_was_piece = True
                else:
                    raise ValueError(f""invalid character in position part of fen: {fen!r}"")

            if field_sum != 8:
                    raise ValueError(f""expected 8 columns per row in position part of fen: {fen!r}"")

        # Clear the board.
        self._clear_board()

        # Put pieces on the board.
        square_index = 0
        for c in fen:
            if c in [""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8""]:
                square_index += int(c)
            elif c.lower() in PIECE_SYMBOLS:
                piece = Piece.from_symbol(c)
                self._set_piece_at(SQUARES_180[square_index], piece.piece_type, piece.color)
                square_index += 1
            elif c == ""~"":
                self.promoted |= BB_SQUARES[SQUARES_180[square_index - 1]]

    def set_board_fen(self, fen: str) -> None:
        """"""
        Parses *fen* and sets up the board, where *fen* is the board part of
        a FEN.

        :class:`~chess.Board` also clears the move stack.

        :raises: :exc:`ValueError` if syntactically invalid.
        """"""
        self._set_board_fen(fen)

    def piece_map(self, *, mask: Bitboard = BB_ALL) -> Dict[Square, Piece]:
        """"""
        Gets a dictionary of :class:`pieces <chess.Piece>` by square index.
        """"""
        result = {}
        for square in scan_reversed(self.occupied & mask):
            result[square] = typing.cast(Piece, self.piece_at(square))
        return result

    def _set_piece_map(self, pieces: Mapping[Square, Piece]) -> None:
        self._clear_board()
        for square, piece in pieces.items():
            self._set_piece_at(square, piece.piece_type, piece.color)

    def set_piece_map(self, pieces: Mapping[Square, Piece]) -> None:
        """"""
        Sets up the board from a dictionary of :class:`pieces <chess.Piece>`
        by square index.

        :class:`~chess.Board` also clears the move stack.
        """"""
        self._set_piece_map(pieces)

    def _set_chess960_pos(self, scharnagl: int) -> None:
        if not 0 <= scharnagl <= 959:
            raise ValueError(f""chess960 position index not 0 <= {scharnagl!r} <= 959"")

        # See http://www.russellcottrell.com/Chess/Chess960.htm for
        # a description of the algorithm.
        n, bw = divmod(scharnagl, 4)
        n, bb = divmod(n, 4)
        n, q = divmod(n, 6)

        for n1 in range(0, 4):
            n2 = n + (3 - n1) * (4 - n1) // 2 - 5
            if n1 < n2 and 1 <= n2 <= 4:
                break

        # Bishops.
        bw_file = bw * 2 + 1
        bb_file = bb * 2
        self.bishops = (BB_FILES[bw_file] | BB_FILES[bb_file]) & BB_BACKRANKS

        # Queens.
        q_file = q
        q_file += int(min(bw_file, bb_file) <= q_file)
        q_file += int(max(bw_file, bb_file) <= q_file)
        self.queens = BB_FILES[q_file] & BB_BACKRANKS

        used = [bw_file, bb_file, q_file]

        # Knights.
        self.knights = BB_EMPTY
        for i in range(0, 8):
            if i not in used:
                if n1 == 0 or n2 == 0:
                    self.knights |= BB_FILES[i] & BB_BACKRANKS
                    used.append(i)
                n1 -= 1
                n2 -= 1

        # RKR.
        for i in range(0, 8):
            if i not in used:
                self.rooks = BB_FILES[i] & BB_BACKRANKS
                used.append(i)
                break
        for i in range(1, 8):
            if i not in used:
                self.kings = BB_FILES[i] & BB_BACKRANKS
                used.append(i)
                break
        for i in range(2, 8):
            if i not in used:
                self.rooks |= BB_FILES[i] & BB_BACKRANKS
                break

        # Finalize.
        self.pawns = BB_RANK_2 | BB_RANK_7
        self.occupied_co[WHITE] = BB_RANK_1 | BB_RANK_2
        self.occupied_co[BLACK] = BB_RANK_7 | BB_RANK_8
        self.occupied = BB_RANK_1 | BB_RANK_2 | BB_RANK_7 | BB_RANK_8
        self.promoted = BB_EMPTY

    def set_chess960_pos(self, scharnagl: int) -> None:
        """"""
        Sets up a Chess960 starting position given its index between 0 and 959.
        Also see :func:`~chess.BaseBoard.from_chess960_pos()`.
        """"""
        self._set_chess960_pos(scharnagl)

    def chess960_pos(self) -> Optional[int]:
        """"""
        Gets the Chess960 starting position index between 0 and 959,
        or ``None``.
        """"""
        if self.occupied_co[WHITE] != BB_RANK_1 | BB_RANK_2:
            return None
        if self.occupied_co[BLACK] != BB_RANK_7 | BB_RANK_8:
            return None
        if self.pawns != BB_RANK_2 | BB_RANK_7:
            return None
        if self.promoted:
            return None

        # Piece counts.
        brnqk = [self.bishops, self.rooks, self.knights, self.queens, self.kings]
        if [popcount(pieces) for pieces in brnqk] != [4, 4, 4, 2, 2]:
            return None

        # Symmetry.
        if any((BB_RANK_1 & pieces) << 56 != BB_RANK_8 & pieces for pieces in brnqk):
            return None

        # Algorithm from ChessX, src/database/bitboard.cpp, r2254.
        x = self.bishops & (2 + 8 + 32 + 128)
        if not x:
            return None
        bs1 = (lsb(x) - 1) // 2
        cc_pos = bs1
        x = self.bishops & (1 + 4 + 16 + 64)
        if not x:
            return None
        bs2 = lsb(x) * 2
        cc_pos += bs2

        q = 0
        qf = False
        n0 = 0
        n1 = 0
        n0f = False
        n1f = False
        rf = 0
        n0s = [0, 4, 7, 9]
        for square in range(A1, H1 + 1):
            bb = BB_SQUARES[square]
            if bb & self.queens:
                qf = True
            elif bb & self.rooks or bb & self.kings:
                if bb & self.kings:
                    if rf != 1:
                        return None
                else:
                    rf += 1

                if not qf:
                    q += 1

                if not n0f:
                    n0 += 1
                elif not n1f:
                    n1 += 1
            elif bb & self.knights:
                if not qf:
                    q += 1

                if not n0f:
                    n0f = True
                elif not n1f:
                    n1f = True

        if n0 < 4 and n1f and qf:
            cc_pos += q * 16
            krn = n0s[n0] + n1
            cc_pos += krn * 96
            return cc_pos
        else:
            return None

    def __repr__(self) -> str:
        return f""{type(self).__name__}({self.board_fen()!r})""

    def __str__(self) -> str:
        builder = []

        for square in SQUARES_180:
            piece = self.piece_at(square)

            if piece:
                builder.append(piece.symbol())
            else:
                builder.append(""."")

            if BB_SQUARES[square] & BB_FILE_H:
                if square != H1:
                    builder.append(""\n"")
            else:
                builder.append("" "")

        return """".join(builder)

    def unicode(self, *, invert_color: bool = False, borders: bool = False, empty_square: str = ""‚≠ò"", orientation: Color = WHITE) -> str:
        """"""
        Returns a string representation of the board with Unicode pieces.
        Useful for pretty-printing to a terminal.

        :param invert_color: Invert color of the Unicode pieces.
        :param borders: Show borders and a coordinate margin.
        """"""
        builder = []
        for rank_index in (range(7, -1, -1) if orientation else range(8)):
            if borders:
                builder.append(""  "")
                builder.append(""-"" * 17)
                builder.append(""\n"")

                builder.append(RANK_NAMES[rank_index])
                builder.append("" "")

            for i, file_index in enumerate(range(8) if orientation else range(7, -1, -1)):
                square_index = square(file_index, rank_index)

                if borders:
                    builder.append(""|"")
                elif i > 0:
                    builder.append("" "")

                piece = self.piece_at(square_index)

                if piece:
                    builder.append(piece.unicode_symbol(invert_color=invert_color))
                else:
                    builder.append(empty_square)

            if borders:
                builder.append(""|"")

            if borders or (rank_index > 0 if orientation else rank_index < 7):
                builder.append(""\n"")

        if borders:
            builder.append(""  "")
            builder.append(""-"" * 17)
            builder.append(""\n"")
            letters = ""a b c d e f g h"" if orientation else ""h g f e d c b a""
            builder.append(""   "" + letters)

        return """".join(builder)

    def _repr_svg_(self) -> str:
        import chess.svg
        return chess.svg.board(board=self, size=400)

    def __eq__(self, board: object) -> bool:
        if isinstance(board, BaseBoard):
            return (
                self.occupied == board.occupied and
                self.occupied_co[WHITE] == board.occupied_co[WHITE] and
                self.pawns == board.pawns and
                self.knights == board.knights and
                self.bishops == board.bishops and
                self.rooks == board.rooks and
                self.queens == board.queens and
                self.kings == board.kings)
        else:
            return NotImplemented

    def apply_transform(self, f: Callable[[Bitboard], Bitboard]) -> None:
        self.pawns = f(self.pawns)
        self.knights = f(self.knights)
        self.bishops = f(self.bishops)
        self.rooks = f(self.rooks)
        self.queens = f(self.queens)
        self.kings = f(self.kings)

        self.occupied_co[WHITE] = f(self.occupied_co[WHITE])
        self.occupied_co[BLACK] = f(self.occupied_co[BLACK])
        self.occupied = f(self.occupied)
        self.promoted = f(self.promoted)

    def transform(self: BaseBoardT, f: Callable[[Bitboard], Bitboard]) -> BaseBoardT:
        """"""
        Returns a transformed copy of the board (without move stack)
        by applying a bitboard transformation function.

        Available transformations include :func:`chess.flip_vertical()`,
        :func:`chess.flip_horizontal()`, :func:`chess.flip_diagonal()`,
        :func:`chess.flip_anti_diagonal()`, :func:`chess.shift_down()`,
        :func:`chess.shift_up()`, :func:`chess.shift_left()`, and
        :func:`chess.shift_right()`.

        Alternatively, :func:`~chess.BaseBoard.apply_transform()` can be used
        to apply the transformation on the board.
        """"""
        board = self.copy()
        board.apply_transform(f)
        return board

    def apply_mirror(self: BaseBoardT) -> None:
        self.apply_transform(flip_vertical)
        self.occupied_co[WHITE], self.occupied_co[BLACK] = self.occupied_co[BLACK], self.occupied_co[WHITE]

    def mirror(self: BaseBoardT) -> BaseBoardT:
        """"""
        Returns a mirrored copy of the board (without move stack).

        The board is mirrored vertically and piece colors are swapped, so that
        the position is equivalent modulo color.

        Alternatively, :func:`~chess.BaseBoard.apply_mirror()` can be used
        to mirror the board.
        """"""
        board = self.copy()
        board.apply_mirror()
        return board

    def copy(self: BaseBoardT) -> BaseBoardT:
        """"""Creates a copy of the board.""""""
        board = type(self)(None)

        board.pawns = self.pawns
        board.knights = self.knights
        board.bishops = self.bishops
        board.rooks = self.rooks
        board.queens = self.queens
        board.kings = self.kings

        board.occupied_co[WHITE] = self.occupied_co[WHITE]
        board.occupied_co[BLACK] = self.occupied_co[BLACK]
        board.occupied = self.occupied
        board.promoted = self.promoted

        return board

    def __copy__(self: BaseBoardT) -> BaseBoardT:
        return self.copy()

    def __deepcopy__(self: BaseBoardT, memo: Dict[int, object]) -> BaseBoardT:
        board = self.copy()
        memo[id(self)] = board
        return board

    @classmethod
    def empty(cls: Type[BaseBoardT]) -> BaseBoardT:
        """"""
        Creates a new empty board. Also see
        :func:`~chess.BaseBoard.clear_board()`.
        """"""
        return cls(None)

    @classmethod
    def from_chess960_pos(cls: Type[BaseBoardT], scharnagl: int) -> BaseBoardT:
        """"""
        Creates a new board, initialized with a Chess960 starting position.

        >>> import chess
        >>> import random
        >>>
        >>> board = chess.Board.from_chess960_pos(random.randint(0, 959))
        """"""
        board = cls.empty()
        board.set_chess960_pos(scharnagl)
        return board


BoardT = TypeVar(""BoardT"", bound=""Board"")

class _BoardState(Generic[BoardT]):

    def __init__(self, board: BoardT) -> None:
        self.pawns = board.pawns
        self.knights = board.knights
        self.bishops = board.bishops
        self.rooks = board.rooks
        self.queens = board.queens
        self.kings = board.kings

        self.occupied_w = board.occupied_co[WHITE]
        self.occupied_b = board.occupied_co[BLACK]
        self.occupied = board.occupied

        self.promoted = board.promoted

        self.turn = board.turn
        self.castling_rights = board.castling_rights
        self.ep_square = board.ep_square
        self.halfmove_clock = board.halfmove_clock
        self.fullmove_number = board.fullmove_number

    def restore(self, board: BoardT) -> None:
        board.pawns = self.pawns
        board.knights = self.knights
        board.bishops = self.bishops
        board.rooks = self.rooks
        board.queens = self.queens
        board.kings = self.kings

        board.occupied_co[WHITE] = self.occupied_w
        board.occupied_co[BLACK] = self.occupied_b
        board.occupied = self.occupied

        board.promoted = self.promoted

        board.turn = self.turn
        board.castling_rights = self.castling_rights
        board.ep_square = self.ep_square
        board.halfmove_clock = self.halfmove_clock
        board.fullmove_number = self.fullmove_number

class Board(BaseBoard):
    """"""
    A :class:`~chess.BaseBoard`, additional information representing
    a chess position, and a :data:`move stack <chess.Board.move_stack>`.

    Provides :data:`move generation <chess.Board.legal_moves>`, validation,
    :func:`parsing <chess.Board.parse_san()>`, attack generation,
    :func:`game end detection <chess.Board.is_game_over()>`,
    and the capability to :func:`make <chess.Board.push()>` and
    :func:`unmake <chess.Board.pop()>` moves.

    The board is initialized to the standard chess starting position,
    unless otherwise specified in the optional *fen* argument.
    If *fen* is ``None``, an empty board is created.

    Optionally supports *chess960*. In Chess960, castling moves are encoded
    by a king move to the corresponding rook square.
    Use :func:`chess.Board.from_chess960_pos()` to create a board with one
    of the Chess960 starting positions.

    It's safe to set :data:`~Board.turn`, :data:`~Board.castling_rights`,
    :data:`~Board.ep_square`, :data:`~Board.halfmove_clock` and
    :data:`~Board.fullmove_number` directly.

    .. warning::
        It is possible to set up and work with invalid positions. In this
        case, :class:`~chess.Board` implements a kind of ""pseudo-chess""
        (useful to gracefully handle errors or to implement chess variants).
        Use :func:`~chess.Board.is_valid()` to detect invalid positions.
    """"""

    aliases: ClassVar[List[str]] = [""Standard"", ""Chess"", ""Classical"", ""Normal"", ""Illegal"", ""From Position""]
    uci_variant: ClassVar[Optional[str]] = ""chess""
    xboard_variant: ClassVar[Optional[str]] = ""normal""
    starting_fen: ClassVar[str] = STARTING_FEN

    tbw_suffix: ClassVar[Optional[str]] = "".rtbw""
    tbz_suffix: ClassVar[Optional[str]] = "".rtbz""
    tbw_magic: ClassVar[Optional[bytes]] = b""\x71\xe8\x23\x5d""
    tbz_magic: ClassVar[Optional[bytes]] = b""\xd7\x66\x0c\xa5""
    pawnless_tbw_suffix: ClassVar[Optional[str]] = None
    pawnless_tbz_suffix: ClassVar[Optional[str]] = None
    pawnless_tbw_magic: ClassVar[Optional[bytes]] = None
    pawnless_tbz_magic: ClassVar[Optional[bytes]] = None
    connected_kings: ClassVar[bool] = False
    one_king: ClassVar[bool] = True
    captures_compulsory: ClassVar[bool] = False

    turn: Color
    """"""The side to move (``chess.WHITE`` or ``chess.BLACK``).""""""

    castling_rights: Bitboard
    """"""
    Bitmask of the rooks with castling rights.

    To test for specific squares:

    >>> import chess
    >>>
    >>> board = chess.Board()
    >>> bool(board.castling_rights & chess.BB_H1)  # White can castle with the h1 rook
    True

    To add a specific square:

    >>> board.castling_rights |= chess.BB_A1

    Use :func:`~chess.Board.set_castling_fen()` to set multiple castling
    rights. Also see :func:`~chess.Board.has_castling_rights()`,
    :func:`~chess.Board.has_kingside_castling_rights()`,
    :func:`~chess.Board.has_queenside_castling_rights()`,
    :func:`~chess.Board.has_chess960_castling_rights()`,
    :func:`~chess.Board.clean_castling_rights()`.
    """"""

    ep_square: Optional[Square]
    """"""
    The potential en passant square on the third or sixth rank or ``None``.

    Use :func:`~chess.Board.has_legal_en_passant()` to test if en passant
    capturing would actually be possible on the next move.
    """"""

    fullmove_number: int
    """"""
    Counts move pairs. Starts at `1` and is incremented after every move
    of the black side.
    """"""

    halfmove_clock: int
    """"""The number of half-moves since the last capture or pawn move.""""""

    promoted: Bitboard
    """"""A bitmask of pieces that have been promoted.""""""

    chess960: bool
    """"""
    Whether the board is in Chess960 mode. In Chess960 castling moves are
    represented as king moves to the corresponding rook square.
    """"""

    move_stack: List[Move]
    """"""
    The move stack. Use :func:`Board.push() <chess.Board.push()>`,
    :func:`Board.pop() <chess.Board.pop()>`,
    :func:`Board.peek() <chess.Board.peek()>` and
    :func:`Board.clear_stack() <chess.Board.clear_stack()>` for
    manipulation.
    """"""

    def __init__(self: BoardT, fen: Optional[str] = STARTING_FEN, *, chess960: bool = False) -> None:
        BaseBoard.__init__(self, None)

        self.chess960 = chess960

        self.ep_square = None
        self.move_stack = []
        self._stack: List[_BoardState[BoardT]] = []

        if fen is None:
            self.clear()
        elif fen == type(self).starting_fen:
            self.reset()
        else:
            self.set_fen(fen)

    @property
    def legal_moves(self) -> LegalMoveGenerator:
        """"""
        A dynamic list of legal moves.

        >>> import chess
        >>>
        >>> board = chess.Board()
        >>> board.legal_moves.count()
        20
        >>> bool(board.legal_moves)
        True
        >>> move = chess.Move.from_uci(""g1f3"")
        >>> move in board.legal_moves
        True

        Wraps :func:`~chess.Board.generate_legal_moves()` and
        :func:`~chess.Board.is_legal()`.
        """"""
        return LegalMoveGenerator(self)

    @property
    def pseudo_legal_moves(self) -> PseudoLegalMoveGenerator:
        """"""
        A dynamic list of pseudo-legal moves, much like the legal move list.

        Pseudo-legal moves might leave or put the king in check, but are
        otherwise valid. Null moves are not pseudo-legal. Castling moves are
        only included if they are completely legal.

        Wraps :func:`~chess.Board.generate_pseudo_legal_moves()` and
        :func:`~chess.Board.is_pseudo_legal()`.
        """"""
        return PseudoLegalMoveGenerator(self)

    def reset(self) -> None:
        """"""Restores the starting position.""""""
        self.turn = WHITE
        self.castling_rights = BB_CORNERS
        self.ep_square = None
        self.halfmove_clock = 0
        self.fullmove_number = 1

        self.reset_board()

    def reset_board(self) -> None:
        super().reset_board()
        self.clear_stack()

    def clear(self) -> None:
        """"""
        Clears the board.

        Resets move stack and move counters. The side to move is white. There
        are no rooks or kings, so castling rights are removed.

        In order to be in a valid :func:`~chess.Board.status()`, at least kings
        need to be put on the board.
        """"""
        self.turn = WHITE
        self.castling_rights = BB_EMPTY
        self.ep_square = None
        self.halfmove_clock = 0
        self.fullmove_number = 1

        self.clear_board()

    def clear_board(self) -> None:
        super().clear_board()
        self.clear_stack()

    def clear_stack(self) -> None:
        """"""Clears the move stack.""""""
        self.move_stack.clear()
        self._stack.clear()

    def root(self: BoardT) -> BoardT:
        """"""Returns a copy of the root position.""""""
        if self._stack:
            board = type(self)(None, chess960=self.chess960)
            self._stack[0].restore(board)
            return board
        else:
            return self.copy(stack=False)

    def ply(self) -> int:
        """"""
        Returns the number of half-moves since the start of the game, as
        indicated by :data:`~chess.Board.fullmove_number` and
        :data:`~chess.Board.turn`.

        If moves have been pushed from the beginning, this is usually equal to
        ``len(board.move_stack)``. But note that a board can be set up with
        arbitrary starting positions, and the stack can be cleared.
        """"""
        return 2 * (self.fullmove_number - 1) + (self.turn == BLACK)

    def remove_piece_at(self, square: Square) -> Optional[Piece]:
        piece = super().remove_piece_at(square)
        self.clear_stack()
        return piece

    def set_piece_at(self, square: Square, piece: Optional[Piece], promoted: bool = False) -> None:
        super().set_piece_at(square, piece, promoted=promoted)
        self.clear_stack()

    def generate_pseudo_legal_moves(self, from_mask: Bitboard = BB_ALL, to_mask: Bitboard = BB_ALL) -> Iterator[Move]:
        our_pieces = self.occupied_co[self.turn]

        # Generate piece moves.
        non_pawns = our_pieces & ~self.pawns & from_mask
        for from_square in scan_reversed(non_pawns):
            piece_type = self.piece_type_at(from_square)
            moves = self.attacks_mask(piece_type, from_square, self.occupied) & ~our_pieces & to_mask
            for to_square in scan_reversed(moves):
                yield Move(from_square, to_square)

        # Generate castling moves.
        if from_mask & self.kings:
            yield from self.generate_castling_moves(from_mask, to_mask)

        # The remaining moves are all pawn moves.
        pawns = self.pawns & self.occupied_co[self.turn] & from_mask
        if not pawns:
            return

        # Generate pawn moves.
        yield from self.generate_pseudo_legal_pawn_moves(pawns, to_mask)

        # Generate pawn captures.
        capturers = pawns
        for from_square in scan_reversed(capturers):
            targets = (
                chess.BB_PAWN_ATTACKS[self.turn][from_square] &
                self.occupied_co[not self.turn] & to_mask)

            for to_square in scan_reversed(targets):
                if chess.square_rank(to_square) in [0, 7]:
                    yield Move(from_square, to_square, chess.QUEEN)
                    yield Move(from_square, to_square, chess.ROOK)
                    yield Move(from_square, to_square, chess.BISHOP)
                    yield Move(from_square, to_square, chess.KNIGHT)
                else:
                    yield Move(from_square, to_square)

        # Prepare pawn advance generation.
        if self.turn == WHITE:
            single_moves = pawns << 8 & ~self.occupied
            double_moves = single_moves << 8 & ~self.occupied & (BB_RANK_3 | BB_RANK_4)
        else:
            single_moves = pawns >> 8 & ~self.occupied
            double_moves = single_moves >> 8 & ~self.occupied & (BB_RANK_6 | BB_RANK_5)

        single_moves &= to_mask
        double_moves &= to_mask

        # Generate single pawn moves.
        for to_square in scan_reversed(single_moves):
            from_square = to_square + (8 if self.turn == BLACK else -8)

            if square_rank(to_square) in [0, 7]:
                yield Move(from_square, to_square, QUEEN)
                yield Move(from_square, to_square, ROOK)
                yield Move(from_square, to_square, BISHOP)
                yield Move(from_square, to_square, KNIGHT)
            else:
                yield Move(from_square, to_square)

        # Generate double pawn moves.
        for to_square in scan_reversed(double_moves):
            from_square = to_square + (16 if self.turn == BLACK else -16)
            yield Move(from_square, to_square)

        # Generate en passant captures.
        if self.ep_square:
            yield from self.generate_pseudo_legal_ep(from_mask, to_mask)

    def generate_pseudo_legal_ep(self, from_mask: Bitboard = BB_ALL, to_mask: Bitboard = BB_ALL) -> Iterator[Move]:
        if not self.ep_square or not BB_SQUARES[self.ep_square] & to_mask:
            return

        if BB_SQUARES[self.ep_square] & self.occupied:
            return

        capturers = (
            self.pawns & self.occupied_co[self.turn] & from_mask &
            BB_PAWN_ATTACKS[not self.turn][self.ep_square] &
            BB_RANKS[4 if self.turn else 3])

        for capturer in scan_reversed(capturers):
            yield Move(capturer, self.ep_square)

    def generate_pseudo_legal_captures(self, from_mask: Bitboard = BB_ALL, to_mask: Bitboard = BB_ALL) -> Iterator[Move]:
        return itertools.chain(
            self.generate_pseudo_legal_moves(from_mask, to_mask & self.occupied_co[not self.turn]),
            self.generate_pseudo_legal_ep(from_mask, to_mask))

    def checkers_mask(self) -> Bitboard:
        king = self.king(self.turn)
        return BB_EMPTY if king is None else self.attackers_mask(not self.turn, king)

    def checkers(self) -> SquareSet:
        """"""
        Gets the pieces currently giving check.

        Returns a :class:`set of squares <chess.SquareSet>`.
        """"""
        return SquareSet(self.checkers_mask())

    def is_check(self) -> bool:
        """"""Tests if the current side to move is in check.""""""
        return bool(self.checkers_mask())

    def gives_check(self, move: Move) -> bool:
        """"""
        Probes if the given move would put the opponent in check. The move
        must be at least pseudo-legal.
        """"""
        self.push(move)
        try:
            return self.is_check()
        finally:
            self.pop()

    def is_into_check(self, move: Move) -> bool:
        king = self.king(self.turn)
        if king is None:
            return False

        # If already in check, look if it is an evasion.
        checkers = self.attackers_mask(not self.turn, king)
        if checkers and move not in self._generate_evasions(king, checkers, BB_SQUARES[move.from_square], BB_SQUARES[move.to_square]):
            return True

        return not self._is_safe(king, self._slider_blockers(king), move)

    def was_into_check(self) -> bool:
        king = self.king(not self.turn)
        return king is not None and self.is_attacked_by(self.turn, king)

    def is_pseudo_legal(self, move: Move) -> bool:
        # Null moves are not pseudo-legal.
        if not move:
            return False

        # Drops are not pseudo-legal.
        if move.drop:
            return False

        # Source square must not be vacant.
        piece = self.piece_type_at(move.from_square)
        if not piece:
            return False

        # Get square masks.
        from_mask = BB_SQUARES[move.from_square]
        to_mask = BB_SQUARES[move.to_square]

        # Check turn.
        if not self.occupied_co[self.turn] & from_mask:
            return False

        # Only pawns can promote and only on the backrank.
        if move.promotion:
            if piece != PAWN:
                return False

            if self.turn == WHITE and square_rank(move.to_square) != 7:
                return False
            elif self.turn == BLACK and square_rank(move.to_square) != 0:
                return False

        # Handle castling.
        if piece == KING:
            move = self._from_chess960(self.chess960, move.from_square, move.to_square)
            if move in self.generate_castling_moves():
                return True

        # Destination square can not be occupied.
        if self.occupied_co[self.turn] & to_mask:
            return False

        # Handle pawn moves.
        if piece == PAWN:
            return move in self.generate_pseudo_legal_moves(from_mask, to_mask)

        # Handle all other pieces.
        return bool(self.attacks_mask(self.piece_type_at, move.from_square, self.occupied) & to_mask)

    def is_legal(self, move: Move) -> bool:
        return not self.is_variant_end() and self.is_pseudo_legal(move) and not self.is_into_check(move)

    def is_variant_end(self) -> bool:
        """"""
        Checks if the game is over due to a special variant end condition.

        Note, for example, that stalemate is not considered a variant-specific
        end condition (this method will return ``False``), yet it can have a
        special **result** in suicide chess (any of
        :func:`~chess.Board.is_variant_loss()`,
        :func:`~chess.Board.is_variant_win()`,
        :func:`~chess.Board.is_variant_draw()` might return ``True``).
        """"""
        return False

    def is_variant_loss(self) -> bool:
        """"""
        Checks if the current side to move lost due to a variant-specific
        condition.
        """"""
        return False

    def is_variant_win(self) -> bool:
        """"""
        Checks if the current side to move won due to a variant-specific
        condition.
        """"""
        return False

    def is_variant_draw(self) -> bool:
        """"""
        Checks if a variant-specific drawing condition is fulfilled.
        """"""
        return False

    def is_game_over(self, *, claim_draw: bool = False) -> bool:
        return self.outcome(claim_draw=claim_draw) is not None

    def result(self, *, claim_draw: bool = False) -> str:
        outcome = self.outcome(claim_draw=claim_draw)
        return outcome.result() if outcome else ""*""

    def outcome(self, *, claim_draw: bool = False) -> Optional[Outcome]:
        """"""
        Checks if the game is over due to
        :func:`checkmate <chess.Board.is_checkmate()>`,
        :func:`stalemate <chess.Board.is_stalemate()>`,
        :func:`insufficient material <chess.Board.is_insufficient_material()>`,
        the :func:`seventyfive-move rule <chess.Board.is_seventyfive_moves()>`,
        :func:`fivefold repetition <chess.Board.is_fivefold_repetition()>`,
        or a :func:`variant end condition <chess.Board.is_variant_end()>`.
        Returns the :class:`chess.Outcome` if the game has ended, otherwise
        ``None``.

        Alternatively, use :func:`~chess.Board.is_game_over()` if you are not
        interested in who won the game and why.

        The game is not considered to be over by the
        :func:`fifty-move rule <chess.Board.can_claim_fifty_moves()>` or
        :func:`threefold repetition <chess.Board.can_claim_threefold_repetition()>`,
        unless *claim_draw* is given. Note that checking the latter can be
        slow.
        """"""
        # Variant support.
        if self.is_variant_loss():
            return Outcome(Termination.VARIANT_LOSS, not self.turn)
        if self.is_variant_win():
            return Outcome(Termination.VARIANT_WIN, self.turn)
        if self.is_variant_draw():
            return Outcome(Termination.VARIANT_DRAW, None)

        # Normal game end.
        if self.is_checkmate():
            return Outcome(Termination.CHECKMATE, not self.turn)
        if self.is_insufficient_material():
            return Outcome(Termination.INSUFFICIENT_MATERIAL, None)
        if not any(self.generate_legal_moves()):
            return Outcome(Termination.STALEMATE, None)

        # Automatic draws.
        if self.is_seventyfive_moves():
            return Outcome(Termination.SEVENTYFIVE_MOVES, None)
        if self.is_fivefold_repetition():
            return Outcome(Termination.FIVEFOLD_REPETITION, None)

        # Claimable draws.
        if claim_draw:
            if self.can_claim_fifty_moves():
                return Outcome(Termination.FIFTY_MOVES, None)
            if self.can_claim_threefold_repetition():
                return Outcome(Termination.THREEFOLD_REPETITION, None)

        return None

    def is_checkmate(self) -> bool:
        """"""Checks if the current position is a checkmate.""""""
        if not self.is_check():
            return False

        return not any(self.generate_legal_moves())

    def is_stalemate(self) -> bool:
        """"""Checks if the current position is a stalemate.""""""
        if self.is_check():
            return False

        if self.is_variant_end():
            return False

        return not any(self.generate_legal_moves())

    def is_insufficient_material(self) -> bool:
        """"""
        Checks if neither side has sufficient winning material
        (:func:`~chess.Board.has_insufficient_material()`).
        """"""
        return all(self.has_insufficient_material(color) for color in COLORS)

    def has_insufficient_material(self, color: Color) -> bool:
        """"""
        Checks if *color* has insufficient winning material.

        This is guaranteed to return ``False`` if *color* can still win the
        game.

        The converse does not necessarily hold:
        The implementation only looks at the material, including the colors
        of bishops, but not considering piece positions. So fortress
        positions or positions with forced lines may return ``False``, even
        though there is no possible winning line.
        """"""
        if self.occupied_co[color] & (self.pawns | self.rooks | self.queens):
            return False

        # Knights are only insufficient material if:
        # (1) We do not have any other pieces, including more than one knight.
        # (2) The opponent does not have pawns, knights, bishops or rooks.
        #     These would allow selfmate.
        if self.occupied_co[color] & self.knights:
            return (popcount(self.occupied_co[color]) <= 2 and
                    not (self.occupied_co[not color] & ~self.kings & ~self.queens))

        # Bishops are only insufficient material if:
        # (1) We do not have any other pieces, including bishops of the
        #     opposite color.
        # (2) The opponent does not have bishops of the opposite color,
        #     pawns or knights. These would allow selfmate.
        if self.occupied_co[color] & self.bishops:
            same_color = (not self.bishops & BB_DARK_SQUARES) or (not self.bishops & BB_LIGHT_SQUARES)
            return same_color and not self.pawns and not self.knights

        return True

    def _is_halfmoves(self, n: int) -> bool:
        return self.halfmove_clock >= n and any(self.generate_legal_moves())

    def is_seventyfive_moves(self) -> bool:
        """"""
        Since the 1st of July 2014, a game is automatically drawn (without
        a claim by one of the players) if the half-move clock since a capture
        or pawn move is equal to or greater than 150. Other means to end a game
        take precedence.
        """"""
        return self._is_halfmoves(150)

    def is_fivefold_repetition(self) -> bool:
        """"""
        Since the 1st of July 2014 a game is automatically drawn (without
        a claim by one of the players) if a position occurs for the fifth time.
        Originally this had to occur on consecutive alternating moves, but
        this has since been revised.
        """"""
        return self.is_repetition(5)

    def can_claim_draw(self) -> bool:
        """"""
        Checks if the player to move can claim a draw by the fifty-move rule or
        by threefold repetition.

        Note that checking the latter can be slow.
        """"""
        return self.can_claim_fifty_moves() or self.can_claim_threefold_repetition()

    def is_fifty_moves(self) -> bool:
        """"""
        Checks that the clock of halfmoves since the last capture or pawn move
        is greater or equal to 100, and that no other means of ending the game
        (like checkmate) take precedence.
        """"""
        return self._is_halfmoves(100)

    def can_claim_fifty_moves(self) -> bool:
        """"""
        Checks if the player to move can claim a draw by the fifty-move rule.

        In addition to :func:`~chess.Board.is_fifty_moves()`, the fifty-move
        rule can also be claimed if there is a legal move that achieves this
        condition.
        """"""
        if self.is_fifty_moves():
            return True

        if self.halfmove_clock >= 99:
            for move in self.generate_legal_moves():
                if not self.is_zeroing(move):
                    self.push(move)
                    try:
                        if self.is_fifty_moves():
                            return True
                    finally:
                        self.pop()

        return False

    def can_claim_threefold_repetition(self) -> bool:
        """"""
        Checks if the player to move can claim a draw by threefold repetition.

        Draw by threefold repetition can be claimed if the position on the
        board occurred for the third time or if such a repetition is reached
        with one of the possible legal moves.

        Note that checking this can be slow: In the worst case
        scenario, every legal move has to be tested and the entire game has to
        be replayed because there is no incremental transposition table.
        """"""
        transposition_key = self._transposition_key()
        transpositions: Counter[Hashable] = collections.Counter()
        transpositions.update((transposition_key, ))

        # Count positions.
        switchyard = []
        while self.move_stack:
            move = self.pop()
            switchyard.append(move)

            if self.is_irreversible(move):
                break

            transpositions.update((self._transposition_key(), ))

        while switchyard:
            self.push(switchyard.pop())

        # Threefold repetition occurred.
        if transpositions[transposition_key] >= 3:
            return True

        # The next legal move is a threefold repetition.
        for move in self.generate_legal_moves():
            self.push(move)
            try:
                if transpositions[self._transposition_key()] >= 2:
                    return True
            finally:
                self.pop()

        return False

    def is_repetition(self, count: int = 3) -> bool:
        """"""
        Checks if the current position has repeated 3 (or a given number of)
        times.

        Unlike :func:`~chess.Board.can_claim_threefold_repetition()`,
        this does not consider a repetition that can be played on the next
        move.

        Note that checking this can be slow: In the worst case, the entire
        game has to be replayed because there is no incremental transposition
        table.
        """"""
        # Fast check, based on occupancy only.
        maybe_repetitions = 1
        for state in reversed(self._stack):
            if state.occupied == self.occupied:
                maybe_repetitions += 1
                if maybe_repetitions >= count:
                    break
        if maybe_repetitions < count:
            return False

        # Check full replay.
        transposition_key = self._transposition_key()
        switchyard = []

        try:
            while True:
                if count <= 1:
                    return True

                if len(self.move_stack) < count - 1:
                    break

                move = self.pop()
                switchyard.append(move)

                if self.is_irreversible(move):
                    break

                if self._transposition_key() == transposition_key:
                    count -= 1
        finally:
            while switchyard:
                self.push(switchyard.pop())

        return False

    def _board_state(self: BoardT) -> _BoardState[BoardT]:
        return _BoardState(self)

    def _push_capture(self, move: Move, capture_square: Square, piece_type: PieceType, was_promoted: bool) -> None:
        pass

    def push(self: BoardT, move: Move) -> None:
        """"""
        Updates the position with the given *move* and puts it onto the
        move stack.

        >>> import chess
        >>>
        >>> board = chess.Board()
        >>>
        >>> Nf3 = chess.Move.from_uci(""g1f3"")
        >>> board.push(Nf3)  # Make the move

        >>> board.pop()  # Unmake the last move
        Move.from_uci('g1f3')

        Null moves just increment the move counters, switch turns and forfeit
        en passant capturing.

        .. warning::
            Moves are not checked for legality. It is the caller's
            responsibility to ensure that the move is at least pseudo-legal or
            a null move.
        """"""
        # Push move and remember board state.
        move = self._to_chess960(move)
        board_state = self._board_state()
        self.castling_rights = self.clean_castling_rights()  # Before pushing stack
        self.move_stack.append(self._from_chess960(self.chess960, move.from_square, move.to_square, move.promotion, move.drop))
        self._stack.append(board_state)

        # Reset en passant square.
        ep_square = self.ep_square
        self.ep_square = None

        # Increment move counters.
        self.halfmove_clock += 1
        if self.turn == BLACK:
            self.fullmove_number += 1

        # On a null move, simply swap turns and reset the en passant square.
        if not move:
            self.turn = not self.turn
            return

        # Drops.
        if move.drop:
            self._set_piece_at(move.to_square, move.drop, self.turn)
            self.turn = not self.turn
            return

        # Zero the half-move clock.
        if self.is_zeroing(move):
            self.halfmove_clock = 0

        from_bb = BB_SQUARES[move.from_square]
        to_bb = BB_SQUARES[move.to_square]

        promoted = bool(self.promoted & from_bb)
        piece_type = self._remove_piece_at(move.from_square)
        assert piece_type is not None, f""push() expects move to be pseudo-legal, but got {move} in {self.board_fen()}""
        capture_square = move.to_square
        captured_piece_type = self.piece_type_at(capture_square)

        # Update castling rights.
        self.castling_rights &= ~to_bb & ~from_bb
        if piece_type == KING and not promoted:
            if self.turn == WHITE:
                self.castling_rights &= ~BB_RANK_1
            else:
                self.castling_rights &= ~BB_RANK_8
        elif captured_piece_type == KING and not self.promoted & to_bb:
            if self.turn == WHITE and square_rank(move.to_square) == 7:
                self.castling_rights &= ~BB_RANK_8
            elif self.turn == BLACK and square_rank(move.to_square) == 0:
                self.castling_rights &= ~BB_RANK_1

        # Handle special pawn moves.
        if piece_type == PAWN:
            diff = move.to_square - move.from_square

            if diff == 16 and square_rank(move.from_square) == 1:
                self.ep_square = move.from_square + 8
            elif diff == -16 and square_rank(move.from_square) == 6:
                self.ep_square = move.from_square - 8
            elif move.to_square == ep_square and abs(diff) in [7, 9] and not captured_piece_type:
                # Remove pawns captured en passant.
                down = -8 if self.turn == WHITE else 8
                capture_square = ep_square + down
                captured_piece_type = self._remove_piece_at(capture_square)

        # Promotion.
        if move.promotion:
            promoted = True
            piece_type = move.promotion

        # Castling.
        castling = piece_type == KING and self.occupied_co[self.turn] & to_bb
        if castling:
            a_side = square_file(move.to_square) < square_file(move.from_square)

            self._remove_piece_at(move.from_square)
            self._remove_piece_at(move.to_square)

            if a_side:
                self._set_piece_at(C1 if self.turn == WHITE else C8, KING, self.turn)
                self._set_piece_at(D1 if self.turn == WHITE else D8, ROOK, self.turn)
            else:
                self._set_piece_at(G1 if self.turn == WHITE else G8, KING, self.turn)
                self._set_piece_at(F1 if self.turn == WHITE else F8, ROOK, self.turn)

        # Put the piece on the target square.
        if not castling:
            was_promoted = bool(self.promoted & to_bb)
            self._set_piece_at(move.to_square, piece_type, self.turn, promoted)

            if captured_piece_type:
                self._push_capture(move, capture_square, captured_piece_type, was_promoted)

        # Swap turn.
        self.turn = not self.turn

    def pop(self: BoardT) -> Move:
        """"""
        Restores the previous position and returns the last move from the stack.

        :raises: :exc:`IndexError` if the move stack is empty.
        """"""
        move = self.move_stack.pop()
        self._stack.pop().restore(self)
        return move

    def peek(self) -> Move:
        """"""
        Gets the last move from the move stack.

        :raises: :exc:`IndexError` if the move stack is empty.
        """"""
        return self.move_stack[-1]

    def find_move(self, from_square: Square, to_square: Square, promotion: Optional[PieceType] = None) -> Move:
        """"""
        Finds a matching legal move for an origin square, a target square, and
        an optional promotion piece type.

        For pawn moves to the backrank, the promotion piece type defaults to
        :data:`chess.QUEEN`, unless otherwise specified.

        Castling moves are normalized to king moves by two steps, except in
        Chess960.

        :raises: :exc:`IllegalMoveError` if no matching legal move is found.
        """"""
        if promotion is None and self.pawns & BB_SQUARES[from_square] and BB_SQUARES[to_square] & BB_BACKRANKS:
            promotion = QUEEN

        move = self._from_chess960(self.chess960, from_square, to_square, promotion)
        if not self.is_legal(move):
            raise IllegalMoveError(f""no matching legal move for {move.uci()} ({SQUARE_NAMES[from_square]} -> {SQUARE_NAMES[to_square]}) in {self.fen()}"")

        return move

    def castling_shredder_fen(self) -> str:
        castling_rights = self.clean_castling_rights()
        if not castling_rights:
            return ""-""

        builder = []

        for square in scan_reversed(castling_rights & BB_RANK_1):
            builder.append(FILE_NAMES[square_file(square)].upper())

        for square in scan_reversed(castling_rights & BB_RANK_8):
            builder.append(FILE_NAMES[square_file(square)])

        return """".join(builder)

    def castling_xfen(self) -> str:
        builder = []

        for color in COLORS:
            king = self.king(color)
            if king is None:
                continue

            king_file = square_file(king)
            backrank = BB_RANK_1 if color == WHITE else BB_RANK_8

            for rook_square in scan_reversed(self.clean_castling_rights() & backrank):
                rook_file = square_file(rook_square)
                a_side = rook_file < king_file

                other_rooks = self.occupied_co[color] & self.rooks & backrank & ~BB_SQUARES[rook_square]

                if any((square_file(other) < rook_file) == a_side for other in scan_reversed(other_rooks)):
                    ch = FILE_NAMES[rook_file]
                else:
                    ch = ""q"" if a_side else ""k""

                builder.append(ch.upper() if color == WHITE else ch)

        if builder:
            return """".join(builder)
        else:
            return ""-""

    def has_pseudo_legal_en_passant(self) -> bool:
        """"""Checks if there is a pseudo-legal en passant capture.""""""
        return self.ep_square is not None and any(self.generate_pseudo_legal_ep())

    def has_legal_en_passant(self) -> bool:
        """"""Checks if there is a legal en passant capture.""""""
        return self.ep_square is not None and any(self.generate_legal_ep())

    def fen(self, *, shredder: bool = False, en_passant: _EnPassantSpec = ""legal"", promoted: Optional[bool] = None) -> str:
        """"""
        Gets a FEN representation of the position.

        A FEN string (e.g.,
        ``rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1``) consists
        of the board part :func:`~chess.Board.board_fen()`, the
        :data:`~chess.Board.turn`, the castling part
        (:data:`~chess.Board.castling_rights`),
        the en passant square (:data:`~chess.Board.ep_square`),
        the :data:`~chess.Board.halfmove_clock`
        and the :data:`~chess.Board.fullmove_number`.

        :param shredder: Use :func:`~chess.Board.castling_shredder_fen()`
            and encode castling rights by the file of the rook
            (like ``HAha``) instead of the default
            :func:`~chess.Board.castling_xfen()` (like ``KQkq``).
        :param en_passant: By default, only fully legal en passant squares
            are included (:func:`~chess.Board.has_legal_en_passant()`).
            Pass ``fen`` to strictly follow the FEN specification
            (always include the en passant square after a two-step pawn move)
            or ``xfen`` to follow the X-FEN specification
            (:func:`~chess.Board.has_pseudo_legal_en_passant()`).
        :param promoted: Mark promoted pieces like ``Q~``. By default, this is
            only enabled in chess variants where this is relevant.
        """"""
        return "" "".join([
            self.epd(shredder=shredder, en_passant=en_passant, promoted=promoted),
            str(self.halfmove_clock),
            str(self.fullmove_number)
        ])

    def shredder_fen(self, *, en_passant: _EnPassantSpec = ""legal"", promoted: Optional[bool] = None) -> str:
        return "" "".join([
            self.epd(shredder=True, en_passant=en_passant, promoted=promoted),
            str(self.halfmove_clock),
            str(self.fullmove_number)
        ])

    def set_fen(self, fen: str) -> None:
        """"""
        Parses a FEN and sets the position from it.

        :raises: :exc:`ValueError` if syntactically invalid. Use
            :func:`~chess.Board.is_valid()` to detect invalid positions.
        """"""
        parts = fen.split()

        # Board part.
        try:
            board_part = parts.pop(0)
        except IndexError:
            raise ValueError(""empty fen"")

        # Turn.
        try:
            turn_part = parts.pop(0)
        except IndexError:
            turn = WHITE
        else:
            if turn_part == ""w"":
                turn = WHITE
            elif turn_part == ""b"":
                turn = BLACK
            else:
                raise ValueError(f""expected 'w' or 'b' for turn part of fen: {fen!r}"")

        # Validate castling part.
        try:
            castling_part = parts.pop(0)
        except IndexError:
            castling_part = ""-""
        else:
            if not FEN_CASTLING_REGEX.match(castling_part):
                raise ValueError(f""invalid castling part in fen: {fen!r}"")

        # En passant square.
        try:
            ep_part = parts.pop(0)
        except IndexError:
            ep_square = None
        else:
            try:
                ep_square = None if ep_part == ""-"" else SQUARE_NAMES.index(ep_part)
            except ValueError:
                raise ValueError(f""invalid en passant part in fen: {fen!r}"")

        # Check that the half-move part is valid.
        try:
            halfmove_part = parts.pop(0)
        except IndexError:
            halfmove_clock = 0
        else:
            try:
                halfmove_clock = int(halfmove_part)
            except ValueError:
                raise ValueError(f""invalid half-move clock in fen: {fen!r}"")

            if halfmove_clock < 0:
                raise ValueError(f""half-move clock cannot be negative: {fen!r}"")

        # Check that the full-move number part is valid.
        # 0 is allowed for compatibility, but later replaced with 1.
        try:
            fullmove_part = parts.pop(0)
        except IndexError:
            fullmove_number = 1
        else:
            try:
                fullmove_number = int(fullmove_part)
            except ValueError:
                raise ValueError(f""invalid fullmove number in fen: {fen!r}"")

            if fullmove_number < 0:
                raise ValueError(f""fullmove number cannot be negative: {fen!r}"")

            fullmove_number = max(fullmove_number, 1)

        # All parts should be consumed now.
        if parts:
            raise ValueError(f""fen string has more parts than expected: {fen!r}"")

        # Validate the board part and set it.
        self._set_board_fen(board_part)

        # Apply.
        self.turn = turn
        self._set_castling_fen(castling_part)
        self.ep_square = ep_square
        self.halfmove_clock = halfmove_clock
        self.fullmove_number = fullmove_number
        self.clear_stack()

    def _set_castling_fen(self, castling_fen: str) -> None:
        if not castling_fen or castling_fen == ""-"":
            self.castling_rights = BB_EMPTY
            return

        if not FEN_CASTLING_REGEX.match(castling_fen):
            raise ValueError(f""invalid castling fen: {castling_fen!r}"")

        self.castling_rights = BB_EMPTY

        for flag in castling_fen:
            color = WHITE if flag.isupper() else BLACK
            flag = flag.lower()
            backrank = BB_RANK_1 if color == WHITE else BB_RANK_8
            rooks = self.occupied_co[color] & self.rooks & backrank
            king = self.king(color)

            if flag == ""q"":
                # Select the leftmost rook.
                if king is not None and lsb(rooks) < king:
                    self.castling_rights |= rooks & -rooks
                else:
                    self.castling_rights |= BB_FILE_A & backrank
            elif flag == ""k"":
                # Select the rightmost rook.
                rook = msb(rooks)
                if king is not None and king < rook:
                    self.castling_rights |= BB_SQUARES[rook]
                else:
                    self.castling_rights |= BB_FILE_H & backrank
            else:
                self.castling_rights |= BB_FILES[FILE_NAMES.index(flag)] & backrank

    def set_castling_fen(self, castling_fen: str) -> None:
        """"""
        Sets castling rights from a string in FEN notation like ``Qqk``.

        Also clears the move stack.

        :raises: :exc:`ValueError` if the castling FEN is syntactically
            invalid.
        """"""
        self._set_castling_fen(castling_fen)
        self.clear_stack()

    def set_board_fen(self, fen: str) -> None:
        super().set_board_fen(fen)
        self.clear_stack()

    def set_piece_map(self, pieces: Mapping[Square, Piece]) -> None:
        super().set_piece_map(pieces)
        self.clear_stack()

    def set_chess960_pos(self, scharnagl: int) -> None:
        super().set_chess960_pos(scharnagl)
        self.chess960 = True
        self.turn = WHITE
        self.castling_rights = self.rooks
        self.ep_square = None
        self.halfmove_clock = 0
        self.fullmove_number = 1

        self.clear_stack()

    def chess960_pos(self, *, ignore_turn: bool = False, ignore_castling: bool = False, ignore_counters: bool = True) -> Optional[int]:
        """"""
        Gets the Chess960 starting position index between 0 and 956,
        or ``None`` if the current position is not a Chess960 starting
        position.

        By default, white to move (**ignore_turn**) and full castling rights
        (**ignore_castling**) are required, but move counters
        (**ignore_counters**) are ignored.
        """"""
        if self.ep_square:
            return None

        if not ignore_turn:
            if self.turn != WHITE:
                return None

        if not ignore_castling:
            if self.clean_castling_rights() != self.rooks:
                return None

        if not ignore_counters:
            if self.fullmove_number != 1 or self.halfmove_clock != 0:
                return None

        return super().chess960_pos()

    def _epd_operations(self, operations: Mapping[str, Union[None, str, int, float, Move, Iterable[Move]]]) -> str:
        epd = []
        first_op = True

        for opcode, operand in operations.items():
            assert opcode != ""-"", ""dash (-) is not a valid epd opcode""
            for blacklisted in ["" "", ""\n"", ""\t"", ""\r""]:
                assert blacklisted not in opcode, f""invalid character {blacklisted!r} in epd opcode: {opcode!r}""

            if not first_op:
                epd.append("" "")
            first_op = False
            epd.append(opcode)

            if operand is None:
                epd.append("";"")
            elif isinstance(operand, Move):
                epd.append("" "")
                epd.append(self.san(operand))
                epd.append("";"")
            elif isinstance(operand, int):
                epd.append(f"" {operand};"")
            elif isinstance(operand, float):
                assert math.isfinite(operand), f""expected numeric epd operand to be finite, got: {operand}""
                epd.append(f"" {operand};"")
            elif opcode == ""pv"" and not isinstance(operand, str) and hasattr(operand, ""__iter__""):
                position = self.copy(stack=False)
                for move in operand:
                    epd.append("" "")
                    epd.append(position.san_and_push(move))
                epd.append("";"")
            elif opcode in [""am"", ""bm""] and not isinstance(operand, str) and hasattr(operand, ""__iter__""):
                for san in sorted(self.san(move) for move in operand):
                    epd.append("" "")
                    epd.append(san)
                epd.append("";"")
            else:
                # Append as escaped string.
                epd.append("" \"""")
                epd.append(str(operand).replace(""\\"", ""\\\\"").replace(""\t"", ""\\t"").replace(""\r"", ""\\r"").replace(""\n"", ""\\n"").replace(""\"""", ""\\\""""))
                epd.append(""\"";"")

        return """".join(epd)

    def epd(self, *, shredder: bool = False, en_passant: _EnPassantSpec = ""legal"", promoted: Optional[bool] = None, **operations: Union[None, str, int, float, Move, Iterable[Move]]) -> str:
        """"""
        Gets an EPD representation of the current position.

        See :func:`~chess.Board.fen()` for FEN formatting options (*shredder*,
        *ep_square* and *promoted*).

        EPD operations can be given as keyword arguments. Supported operands
        are strings, integers, finite floats, legal moves and ``None``.
        Additionally, the operation ``pv`` accepts a legal variation as
        a list of moves. The operations ``am`` and ``bm`` accept a list of
        legal moves in the current position.

        The name of the field cannot be a lone dash and cannot contain spaces,
        newlines, carriage returns or tabs.

        *hmvc* and *fmvn* are not included by default. You can use:

        >>> import chess
        >>>
        >>> board = chess.Board()
        >>> board.epd(hmvc=board.halfmove_clock, fmvn=board.fullmove_number)
        'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - hmvc 0; fmvn 1;'
        """"""
        if en_passant == ""fen"":
            ep_square = self.ep_square
        elif en_passant == ""xfen"":
            ep_square = self.ep_square if self.has_pseudo_legal_en_passant() else None
        else:
            ep_square = self.ep_square if self.has_legal_en_passant() else None

        epd = [self.board_fen(promoted=promoted),
               ""w"" if self.turn == WHITE else ""b"",
               self.castling_shredder_fen() if shredder else self.castling_xfen(),
               SQUARE_NAMES[ep_square] if ep_square is not None else ""-""]

        if operations:
            epd.append(self._epd_operations(operations))

        return "" "".join(epd)

    def _parse_epd_ops(self: BoardT, operation_part: str, make_board: Callable[[], BoardT]) -> Dict[str, Union[None, str, int, float, Move, List[Move]]]:
        operations: Dict[str, Union[None, str, int, float, Move, List[Move]]] = {}
        state = ""opcode""
        opcode = """"
        operand = """"
        position = None

        for ch in itertools.chain(operation_part, [None]):
            if state == ""opcode"":
                if ch in ["" "", ""\t"", ""\r"", ""\n""]:
                    if opcode == ""-"":
                        opcode = """"
                    elif opcode:
                        state = ""after_opcode""
                elif ch is None or ch == "";"":
                    if opcode == ""-"":
                        opcode = """"
                    elif opcode:
                        operations[opcode] = [] if opcode in [""pv"", ""am"", ""bm""] else None
                        opcode = """"
                else:
                    opcode += ch
            elif state == ""after_opcode"":
                if ch in ["" "", ""\t"", ""\r"", ""\n""]:
                    pass
                elif ch == ""\"""":
                    state = ""string""
                elif ch is None or ch == "";"":
                    if opcode:
                        operations[opcode] = [] if opcode in [""pv"", ""am"", ""bm""] else None
                        opcode = """"
                    state = ""opcode""
                elif ch in ""+-.0123456789"":
                    operand = ch
                    state = ""numeric""
                else:
                    operand = ch
                    state = ""san""
            elif state == ""numeric"":
                if ch is None or ch == "";"":
                    if ""."" in operand or ""e"" in operand or ""E"" in operand:
                        parsed = float(operand)
                        if not math.isfinite(parsed):
                            raise ValueError(f""invalid numeric operand for epd operation {opcode!r}: {operand!r}"")
                        operations[opcode] = parsed
                    else:
                        operations[opcode] = int(operand)
                    opcode = """"
                    operand = """"
                    state = ""opcode""
                else:
                    operand += ch
            elif state == ""string"":
                if ch is None or ch == ""\"""":
                    operations[opcode] = operand
                    opcode = """"
                    operand = """"
                    state = ""opcode""
                elif ch == ""\\"":
                    state = ""string_escape""
                else:
                    operand += ch
            elif state == ""string_escape"":
                if ch is None:
                    operations[opcode] = operand
                    opcode = """"
                    operand = """"
                    state = ""opcode""
                elif ch == ""r"":
                    operand += ""\r""
                    state = ""string""
                elif ch == ""n"":
                    operand += ""\n""
                    state = ""string""
                elif ch == ""t"":
                    operand += ""\t""
                    state = ""string""
                else:
                    operand += ch
                    state = ""string""
            elif state == ""san"":
                if ch is None or ch == "";"":
                    if position is None:
                        position = make_board()

                    if opcode == ""pv"":
                        # A variation.
                        variation = []
                        for token in operand.split():
                            move = position.parse_xboard(token)
                            variation.append(move)
                            position.push(move)

                        # Reset the position.
                        while position.move_stack:
                            position.pop()

                        operations[opcode] = variation
                    elif opcode in [""bm"", ""am""]:
                        # A set of moves.
                        operations[opcode] = [position.parse_xboard(token) for token in operand.split()]
                    else:
                        # A single move.
                        operations[opcode] = position.parse_xboard(operand)

                    opcode = """"
                    operand = """"
                    state = ""opcode""
                else:
                    operand += ch

        assert state == ""opcode""
        return operations

    def set_epd(self, epd: str) -> Dict[str, Union[None, str, int, float, Move, List[Move]]]:
        """"""
        Parses the given EPD string and uses it to set the position.

        If present, ``hmvc`` and ``fmvn`` are used to set the half-move
        clock and the full-move number. Otherwise, ``0`` and ``1`` are used.

        Returns a dictionary of parsed operations. Values can be strings,
        integers, floats, move objects, or lists of moves.

        :raises: :exc:`ValueError` if the EPD string is invalid.
        """"""
        parts = epd.strip().rstrip("";"").split(None, 4)

        # Parse ops.
        if len(parts) > 4:
            operations = self._parse_epd_ops(parts.pop(), lambda: type(self)("" "".join(parts) + "" 0 1""))
            parts.append(str(operations[""hmvc""]) if ""hmvc"" in operations else ""0"")
            parts.append(str(operations[""fmvn""]) if ""fmvn"" in operations else ""1"")
            self.set_fen("" "".join(parts))
            return operations
        else:
            self.set_fen(epd)
            return {}

    def san(self, move: Move) -> str:
        """"""
        Gets the standard algebraic notation of the given move in the context
        of the current position.
        """"""
        return self._algebraic(move)

    def lan(self, move: Move) -> str:
        """"""
        Gets the long algebraic notation of the given move in the context of
        the current position.
        """"""
        return self._algebraic(move, long=True)

    def san_and_push(self, move: Move) -> str:
        return self._algebraic_and_push(move)

    def _algebraic(self, move: Move, *, long: bool = False) -> str:
        san = self._algebraic_and_push(move, long=long)
        self.pop()
        return san

    def _algebraic_and_push(self, move: Move, *, long: bool = False) -> str:
        san = self._algebraic_without_suffix(move, long=long)

        # Look ahead for check or checkmate.
        self.push(move)
        is_check = self.is_check()
        is_checkmate = (is_check and self.is_checkmate()) or self.is_variant_loss() or self.is_variant_win()

        # Add check or checkmate suffix.
        if is_checkmate and move:
            return san + ""#""
        elif is_check and move:
            return san + ""+""
        else:
            return san

    def _algebraic_without_suffix(self, move: Move, *, long: bool = False) -> str:
        # Null move.
        if not move:
            return ""--""

        # Drops.
        if move.drop:
            san = """"
            if move.drop != PAWN:
                san = piece_symbol(move.drop).upper()
            san += ""@"" + SQUARE_NAMES[move.to_square]
            return san

        # Castling.
        if self.is_castling(move):
            if square_file(move.to_square) < square_file(move.from_square):
                return ""O-O-O""
            else:
                return ""O-O""

        piece_type = self.piece_type_at(move.from_square)
        assert piece_type, f""san() and lan() expect move to be legal or null, but got {move} in {self.fen()}""
        capture = self.is_capture(move)

        if piece_type == PAWN:
            san = """"
        else:
            san = piece_symbol(piece_type).upper()

        if long:
            san += SQUARE_NAMES[move.from_square]
        elif piece_type != PAWN:
            # Get ambiguous move candidates.
            # Relevant candidates: not exactly the current move,
            # but to the same square.
            others = 0
            from_mask = self.pieces_mask(piece_type, self.turn)
            from_mask &= ~BB_SQUARES[move.from_square]
            to_mask = BB_SQUARES[move.to_square]
            for candidate in self.generate_legal_moves(from_mask, to_mask):
                others |= BB_SQUARES[candidate.from_square]

            # Disambiguate.
            if others:
                row, column = False, False

                if others & BB_RANKS[square_rank(move.from_square)]:
                    column = True

                if others & BB_FILES[square_file(move.from_square)]:
                    row = True
                else:
                    column = True

                if column:
                    san += FILE_NAMES[square_file(move.from_square)]
                if row:
                    san += RANK_NAMES[square_rank(move.from_square)]
        elif capture:
            san += FILE_NAMES[square_file(move.from_square)]

        # Captures.
        if capture:
            san += ""x""
        elif long:
            san += ""-""

        # Destination square.
        san += SQUARE_NAMES[move.to_square]

        # Promotion.
        if move.promotion:
            san += ""="" + piece_symbol(move.promotion).upper()

        return san

    def variation_san(self, variation: Iterable[Move]) -> str:
        """"""
        Given a sequence of moves, returns a string representing the sequence
        in standard algebraic notation (e.g., ``1. e4 e5 2. Nf3 Nc6`` or
        ``37...Bg6 38. fxg6``).

        The board will not be modified as a result of calling this.

        :raises: :exc:`IllegalMoveError` if any moves in the sequence are illegal.
        """"""
        board = self.copy(stack=False)
        san = []

        for move in variation:
            if not board.is_legal(move):
                raise IllegalMoveError(f""illegal move {move} in position {board.fen()}"")

            if board.turn == WHITE:
                san.append(f""{board.fullmove_number}. {board.san_and_push(move)}"")
            elif not san:
                san.append(f""{board.fullmove_number}...{board.san_and_push(move)}"")
            else:
                san.append(board.san_and_push(move))

        return "" "".join(san)

    def parse_san(self, san: str) -> Move:
        """"""
        Uses the current position as the context to parse a move in standard
        algebraic notation and returns the corresponding move object.

        Ambiguous moves are rejected. Overspecified moves (including long
        algebraic notation) are accepted. Some common syntactical deviations
        are also accepted.

        The returned move is guaranteed to be either legal or a null move.

        :raises:
            :exc:`ValueError` (specifically an exception specified below) if the SAN is invalid, illegal or ambiguous.

            - :exc:`InvalidMoveError` if the SAN is syntactically invalid.
            - :exc:`IllegalMoveError` if the SAN is illegal.
            - :exc:`AmbiguousMoveError` if the SAN is ambiguous.
        """"""
        # Castling.
        try:
            if san in [""O-O"", ""O-O+"", ""O-O#"", ""0-0"", ""0-0+"", ""0-0#""]:
                return next(move for move in self.generate_castling_moves() if self.is_kingside_castling(move))
            elif san in [""O-O-O"", ""O-O-O+"", ""O-O-O#"", ""0-0-0"", ""0-0-0+"", ""0-0-0#""]:
                return next(move for move in self.generate_castling_moves() if self.is_queenside_castling(move))
        except StopIteration:
            raise IllegalMoveError(f""illegal san: {san!r} in {self.fen()}"")

        # Match normal moves.
        match = SAN_REGEX.match(san)
        if not match:
            # Null moves.
            if san in [""--"", ""Z0"", ""0000"", ""@@@@""]:
                return Move.null()
            elif "","" in san:
                raise InvalidMoveError(f""unsupported multi-leg move: {san!r}"")
            else:
                raise InvalidMoveError(f""invalid san: {san!r}"")

        # Get target square. Mask our own pieces to exclude castling moves.
        to_square = SQUARE_NAMES.index(match.group(4))
        to_mask = BB_SQUARES[to_square] & ~self.occupied_co[self.turn]

        # Get the promotion piece type.
        p = match.group(5)
        promotion = PIECE_SYMBOLS.index(p[-1].lower()) if p else None

        # Filter by original square.
        from_mask = BB_ALL
        if match.group(2):
            from_file = FILE_NAMES.index(match.group(2))
            from_mask &= BB_FILES[from_file]
        if match.group(3):
            from_rank = int(match.group(3)) - 1
            from_mask &= BB_RANKS[from_rank]

        # Filter by piece type.
        if match.group(1):
            piece_type = PIECE_SYMBOLS.index(match.group(1).lower())
            from_mask &= self.pieces_mask(piece_type, self.turn)
        elif match.group(2) and match.group(3):
            # Allow fully specified moves, even if they are not pawn moves,
            # including castling moves.
            move = self.find_move(square(from_file, from_rank), to_square, promotion)
            if move.promotion == promotion:
                return move
            else:
                raise IllegalMoveError(f""missing promotion piece type: {san!r} in {self.fen()}"")
        else:
            from_mask &= self.pawns

            # Do not allow pawn captures if file is not specified.
            if not match.group(2):
                from_mask &= BB_FILES[square_file(to_square)]

        # Match legal moves.
        matched_move = None
        for move in self.generate_legal_moves(from_mask, to_mask):
            if move.promotion != promotion:
                continue

            if matched_move:
                raise AmbiguousMoveError(f""ambiguous san: {san!r} in {self.fen()}"")

            matched_move = move

        if not matched_move:
            raise IllegalMoveError(f""illegal san: {san!r} in {self.fen()}"")

        return matched_move

    def push_san(self, san: str) -> Move:
        """"""
        Parses a move in standard algebraic notation, makes the move and puts
        it onto the move stack.

        Returns the move.

        :raises:
            :exc:`ValueError` (specifically an exception specified below) if neither legal nor a null move.

            - :exc:`InvalidMoveError` if the SAN is syntactically invalid.
            - :exc:`IllegalMoveError` if the SAN is illegal.
            - :exc:`AmbiguousMoveError` if the SAN is ambiguous.
        """"""
        move = self.parse_san(san)
        self.push(move)
        return move

    def uci(self, move: Move, *, chess960: Optional[bool] = None) -> str:
        """"""
        Gets the UCI notation of the move.

        *chess960* defaults to the mode of the board. Pass ``True`` to force
        Chess960 mode.
        """"""
        if chess960 is None:
            chess960 = self.chess960

        move = self._to_chess960(move)
        move = self._from_chess960(chess960, move.from_square, move.to_square, move.promotion, move.drop)
        return move.uci()

    def parse_uci(self, uci: str) -> Move:
        """"""
        Parses the given move in UCI notation.

        Supports both Chess960 and standard UCI notation.

        The returned move is guaranteed to be either legal or a null move.

        :raises:
            :exc:`ValueError` (specifically an exception specified below) if the move is invalid or illegal in the
            current position (but not a null move).

            - :exc:`InvalidMoveError` if the UCI is syntactically invalid.
            - :exc:`IllegalMoveError` if the UCI is illegal.
        """"""
        move = Move.from_uci(uci)

        if not move:
            return move

        move = self._to_chess960(move)
        move = self._from_chess960(self.chess960, move.from_square, move.to_square, move.promotion, move.drop)

        if not self.is_legal(move):
            raise IllegalMoveError(f""illegal uci: {uci!r} in {self.fen()}"")

        return move

    def push_uci(self, uci: str) -> Move:
        """"""
        Parses a move in UCI notation and puts it on the move stack.

        Returns the move.

        :raises:
            :exc:`ValueError` (specifically an exception specified below) if the move is invalid or illegal in the
            current position (but not a null move).

            - :exc:`InvalidMoveError` if the UCI is syntactically invalid.
            - :exc:`IllegalMoveError` if the UCI is illegal.
        """"""
        move = self.parse_uci(uci)
        self.push(move)
        return move

    def xboard(self, move: Move, chess960: Optional[bool] = None) -> str:
        if chess960 is None:
            chess960 = self.chess960

        if not chess960 or not self.is_castling(move):
            return move.xboard()
        elif self.is_kingside_castling(move):
            return ""O-O""
        else:
            return ""O-O-O""

    def parse_xboard(self, xboard: str) -> Move:
        return self.parse_san(xboard)

    push_xboard = push_san

    def is_en_passant(self, move: Move) -> bool:
        """"""Checks if the given pseudo-legal move is an en passant capture.""""""
        return (self.ep_square == move.to_square and
                bool(self.pawns & BB_SQUARES[move.from_square]) and
                abs(move.to_square - move.from_square) in [7, 9] and
                not self.occupied & BB_SQUARES[move.to_square])

    def is_capture(self, move: Move) -> bool:
        """"""Checks if the given pseudo-legal move is a capture.""""""
        touched = BB_SQUARES[move.from_square] ^ BB_SQUARES[move.to_square]
        return bool(touched & self.occupied_co[not self.turn]) or self.is_en_passant(move)

    def is_zeroing(self, move: Move) -> bool:
        """"""Checks if the given pseudo-legal move is a capture or pawn move.""""""
        touched = BB_SQUARES[move.from_square] ^ BB_SQUARES[move.to_square]
        return bool(touched & self.pawns or touched & self.occupied_co[not self.turn] or move.drop == PAWN)

    def _reduces_castling_rights(self, move: Move) -> bool:
        cr = self.clean_castling_rights()
        touched = BB_SQUARES[move.from_square] ^ BB_SQUARES[move.to_square]
        return bool(touched & cr or
                    cr & BB_RANK_1 and touched & self.kings & self.occupied_co[WHITE] & ~self.promoted or
                    cr & BB_RANK_8 and touched & self.kings & self.occupied_co[BLACK] & ~self.promoted)

    def is_irreversible(self, move: Move) -> bool:
        """"""
        Checks if the given pseudo-legal move is irreversible.

        In standard chess, pawn moves, captures, moves that destroy castling
        rights and moves that cede en passant are irreversible.

        This method has false-negatives with forced lines. For example, a check
        that will force the king to lose castling rights is not considered
        irreversible. Only the actual king move is.
        """"""
        return self.is_zeroing(move) or self._reduces_castling_rights(move) or self.has_legal_en_passant()

    def is_castling(self, move: Move) -> bool:
        """"""Checks if the given pseudo-legal move is a castling move.""""""
        if self.kings & BB_SQUARES[move.from_square]:
            diff = square_file(move.from_square) - square_file(move.to_square)
            return abs(diff) > 1 or bool(self.rooks & self.occupied_co[self.turn] & BB_SQUARES[move.to_square])
        return False

    def is_kingside_castling(self, move: Move) -> bool:
        """"""
        Checks if the given pseudo-legal move is a kingside castling move.
        """"""
        return self.is_castling(move) and square_file(move.to_square) > square_file(move.from_square)

    def is_queenside_castling(self, move: Move) -> bool:
        """"""
        Checks if the given pseudo-legal move is a queenside castling move.
        """"""
        return self.is_castling(move) and square_file(move.to_square) < square_file(move.from_square)

    def clean_castling_rights(self) -> Bitboard:
        """"""
        Returns valid castling rights filtered from
        :data:`~chess.Board.castling_rights`.
        """"""
        if self._stack:
            # No new castling rights are assigned in a game, so we can assume
            # they were filtered already.
            return self.castling_rights

        castling = self.castling_rights & self.rooks
        white_castling = castling & BB_RANK_1 & self.occupied_co[WHITE]
        black_castling = castling & BB_RANK_8 & self.occupied_co[BLACK]

        if not self.chess960:
            # The rooks must be on a1, h1, a8 or h8.
            white_castling &= (BB_A1 | BB_H1)
            black_castling &= (BB_A8 | BB_H8)

            # The kings must be on e1 or e8.
            if not self.occupied_co[WHITE] & self.kings & ~self.promoted & BB_E1:
                white_castling = 0
            if not self.occupied_co[BLACK] & self.kings & ~self.promoted & BB_E8:
                black_castling = 0

            return white_castling | black_castling
        else:
            # The kings must be on the back rank.
            white_king_mask = self.occupied_co[WHITE] & self.kings & BB_RANK_1 & ~self.promoted
            black_king_mask = self.occupied_co[BLACK] & self.kings & BB_RANK_8 & ~self.promoted
            if not white_king_mask:
                white_castling = 0
            if not black_king_mask:
                black_castling = 0

            # There are only two ways of castling, a-side and h-side, and the
            # king must be between the rooks.
            white_a_side = white_castling & -white_castling
            white_h_side = BB_SQUARES[msb(white_castling)] if white_castling else 0

            if white_a_side and msb(white_a_side) > msb(white_king_mask):
                white_a_side = 0
            if white_h_side and msb(white_h_side) < msb(white_king_mask):
                white_h_side = 0

            black_a_side = (black_castling & -black_castling)
            black_h_side = BB_SQUARES[msb(black_castling)] if black_castling else BB_EMPTY

            if black_a_side and msb(black_a_side) > msb(black_king_mask):
                black_a_side = 0
            if black_h_side and msb(black_h_side) < msb(black_king_mask):
                black_h_side = 0

            # Done.
            return black_a_side | black_h_side | white_a_side | white_h_side

    def has_castling_rights(self, color: Color) -> bool:
        """"""Checks if the given side has castling rights.""""""
        backrank = BB_RANK_1 if color == WHITE else BB_RANK_8
        return bool(self.clean_castling_rights() & backrank)

    def has_kingside_castling_rights(self, color: Color) -> bool:
        """"""
        Checks if the given side has kingside (that is h-side in Chess960)
        castling rights.
        """"""
        backrank = BB_RANK_1 if color == WHITE else BB_RANK_8
        king_mask = self.kings & self.occupied_co[color] & backrank & ~self.promoted
        if not king_mask:
            return False

        castling_rights = self.clean_castling_rights() & backrank
        while castling_rights:
            rook = castling_rights & -castling_rights

            if rook > king_mask:
                return True

            castling_rights &= castling_rights - 1

        return False

    def has_queenside_castling_rights(self, color: Color) -> bool:
        """"""
        Checks if the given side has queenside (that is a-side in Chess960)
        castling rights.
        """"""
        backrank = BB_RANK_1 if color == WHITE else BB_RANK_8
        king_mask = self.kings & self.occupied_co[color] & backrank & ~self.promoted
        if not king_mask:
            return False

        castling_rights = self.clean_castling_rights() & backrank
        while castling_rights:
            rook = castling_rights & -castling_rights

            if rook < king_mask:
                return True

            castling_rights &= castling_rights - 1

        return False

    def has_chess960_castling_rights(self) -> bool:
        """"""
        Checks if there are castling rights that are only possible in Chess960.
        """"""
        # Get valid Chess960 castling rights.
        chess960 = self.chess960
        self.chess960 = True
        castling_rights = self.clean_castling_rights()
        self.chess960 = chess960

        # Standard chess castling rights can only be on the standard
        # starting rook squares.
        if castling_rights & ~BB_CORNERS:
            return True

        # If there are any castling rights in standard chess, the king must be
        # on e1 or e8.
        if castling_rights & BB_RANK_1 and not self.occupied_co[WHITE] & self.kings & BB_E1:
            return True
        if castling_rights & BB_RANK_8 and not self.occupied_co[BLACK] & self.kings & BB_E8:
            return True

        return False

    def status(self) -> Status:
        """"""
        Gets a bitmask of possible problems with the position.

        :data:`~chess.STATUS_VALID` if all basic validity requirements are met.
        This does not imply that the position is actually reachable with a
        series of legal moves from the starting position.

        Otherwise, bitwise combinations of:
        :data:`~chess.STATUS_NO_WHITE_KING`,
        :data:`~chess.STATUS_NO_BLACK_KING`,
        :data:`~chess.STATUS_TOO_MANY_KINGS`,
        :data:`~chess.STATUS_TOO_MANY_WHITE_PAWNS`,
        :data:`~chess.STATUS_TOO_MANY_BLACK_PAWNS`,
        :data:`~chess.STATUS_PAWNS_ON_BACKRANK`,
        :data:`~chess.STATUS_TOO_MANY_WHITE_PIECES`,
        :data:`~chess.STATUS_TOO_MANY_BLACK_PIECES`,
        :data:`~chess.STATUS_BAD_CASTLING_RIGHTS`,
        :data:`~chess.STATUS_INVALID_EP_SQUARE`,
        :data:`~chess.STATUS_OPPOSITE_CHECK`,
        :data:`~chess.STATUS_EMPTY`,
        :data:`~chess.STATUS_RACE_CHECK`,
        :data:`~chess.STATUS_RACE_OVER`,
        :data:`~chess.STATUS_RACE_MATERIAL`,
        :data:`~chess.STATUS_TOO_MANY_CHECKERS`,
        :data:`~chess.STATUS_IMPOSSIBLE_CHECK`.
        """"""
        errors = STATUS_VALID

        # There must be at least one piece.
        if not self.occupied:
            errors |= STATUS_EMPTY

        # There must be exactly one king of each color.
        if not self.occupied_co[WHITE] & self.kings:
            errors |= STATUS_NO_WHITE_KING
        if not self.occupied_co[BLACK] & self.kings:
            errors |= STATUS_NO_BLACK_KING
        if popcount(self.occupied & self.kings) > 2:
            errors |= STATUS_TOO_MANY_KINGS

        # There can not be more than 16 pieces of any color.
        if popcount(self.occupied_co[WHITE]) > 16:
            errors |= STATUS_TOO_MANY_WHITE_PIECES
        if popcount(self.occupied_co[BLACK]) > 16:
            errors |= STATUS_TOO_MANY_BLACK_PIECES

        # There can not be more than 8 pawns of any color.
        if popcount(self.occupied_co[WHITE] & self.pawns) > 8:
            errors |= STATUS_TOO_MANY_WHITE_PAWNS
        if popcount(self.occupied_co[BLACK] & self.pawns) > 8:
            errors |= STATUS_TOO_MANY_BLACK_PAWNS

        # Pawns can not be on the back rank.
        if self.pawns & BB_BACKRANKS:
            errors |= STATUS_PAWNS_ON_BACKRANK

        # Castling rights.
        if self.castling_rights != self.clean_castling_rights():
            errors |= STATUS_BAD_CASTLING_RIGHTS

        # En passant.
        valid_ep_square = self._valid_ep_square()
        if self.ep_square != valid_ep_square:
            errors |= STATUS_INVALID_EP_SQUARE

        # Side to move giving check.
        if self.was_into_check():
            errors |= STATUS_OPPOSITE_CHECK

        # More than the maximum number of possible checkers in the variant.
        checkers = self.checkers_mask()
        our_kings = self.kings & self.occupied_co[self.turn] & ~self.promoted
        if checkers:
            if popcount(checkers) > 2:
                errors |= STATUS_TOO_MANY_CHECKERS

            if valid_ep_square is not None:
                pushed_to = valid_ep_square ^ A2
                pushed_from = valid_ep_square ^ A4
                occupied_before = (self.occupied & ~BB_SQUARES[pushed_to]) | BB_SQUARES[pushed_from]
                if popcount(checkers) > 1 or (
                        msb(checkers) != pushed_to and
                        self._attacked_for_king(our_kings, occupied_before)):
                    errors |= STATUS_IMPOSSIBLE_CHECK
            else:
                if popcount(checkers) > 2 or (popcount(checkers) == 2 and ray(lsb(checkers), msb(checkers)) & our_kings):
                    errors |= STATUS_IMPOSSIBLE_CHECK

        return errors

    def _valid_ep_square(self) -> Optional[Square]:
        if not self.ep_square:
            return None

        if self.turn == WHITE:
            ep_rank = 5
            pawn_mask = shift_down(BB_SQUARES[self.ep_square])
            seventh_rank_mask = shift_up(BB_SQUARES[self.ep_square])
        else:
            ep_rank = 2
            pawn_mask = shift_up(BB_SQUARES[self.ep_square])
            seventh_rank_mask = shift_down(BB_SQUARES[self.ep_square])

        # The en passant square must be on the third or sixth rank.
        if square_rank(self.ep_square) != ep_rank:
            return None

        # The last move must have been a double pawn push, so there must
        # be a pawn of the correct color on the fourth or fifth rank.
        if not self.pawns & self.occupied_co[not self.turn] & pawn_mask:
            return None

        # And the en passant square must be empty.
        if self.occupied & BB_SQUARES[self.ep_square]:
            return None

        # And the second rank must be empty.
        if self.occupied & seventh_rank_mask:
            return None

        return self.ep_square

    def is_valid(self) -> bool:
        """"""
        Checks some basic validity requirements.

        See :func:`~chess.Board.status()` for details.
        """"""
        return self.status() == STATUS_VALID

    def _ep_skewered(self, king: Square, capturer: Square) -> bool:
        # Handle the special case where the king would be in check if the
        # pawn and its capturer disappear from the rank.

        # Vertical skewers of the captured pawn are not possible. (Pins on
        # the capturer are not handled here.)
        assert self.ep_square is not None

        last_double = self.ep_square + (-8 if self.turn == WHITE else 8)

        occupancy = (self.occupied & ~BB_SQUARES[last_double] &
                     ~BB_SQUARES[capturer] | BB_SQUARES[self.ep_square])

        # Horizontal attack on the fifth or fourth rank.
        horizontal_attackers = self.occupied_co[not self.turn] & (self.rooks | self.queens)
        if BB_RANK_ATTACKS[king][BB_RANK_MASKS[king] & occupancy] & horizontal_attackers:
            return True

        # Diagonal skewers. These are not actually possible in a real game,
        # because if the latest double pawn move covers a diagonal attack,
        # then the other side would have been in check already.
        diagonal_attackers = self.occupied_co[not self.turn] & (self.bishops | self.queens)
        if BB_DIAG_ATTACKS[king][BB_DIAG_MASKS[king] & occupancy] & diagonal_attackers:
            return True

        return False

    def _slider_blockers(self, king: Square) -> Bitboard:
        rooks_and_queens = self.rooks | self.queens
        bishops_and_queens = self.bishops | self.queens

        snipers = ((BB_RANK_ATTACKS[king][0] & rooks_and_queens) |
                   (BB_FILE_ATTACKS[king][0] & rooks_and_queens) |
                   (BB_DIAG_ATTACKS[king][0] & bishops_and_queens))

        blockers = 0

        for sniper in scan_reversed(snipers & self.occupied_co[not self.turn]):
            b = between(king, sniper) & self.occupied

            # Add to blockers if exactly one piece in-between.
            if b and BB_SQUARES[msb(b)] == b:
                blockers |= b

        return blockers & self.occupied_co[self.turn]

    def _is_safe(self, king: Square, blockers: Bitboard, move: Move) -> bool:
        if move.from_square == king:
            if self.is_castling(move):
                return True
            else:
                return not self.is_attacked_by(not self.turn, move.to_square)
        elif self.is_en_passant(move):
            return bool(self.pin_mask(self.turn, move.from_square) & BB_SQUARES[move.to_square] and
                        not self._ep_skewered(king, move.from_square))
        else:
            return bool(not blockers & BB_SQUARES[move.from_square] or
                        ray(move.from_square, move.to_square) & BB_SQUARES[king])

    def _generate_evasions(self, king: Square, checkers: Bitboard, from_mask: Bitboard = BB_ALL, to_mask: Bitboard = BB_ALL) -> Iterator[Move]:
        sliders = checkers & (self.bishops | self.rooks | self.queens)

        attacked = 0
        for checker in scan_reversed(sliders):
            attacked |= ray(king, checker) & ~BB_SQUARES[checker]

        if BB_SQUARES[king] & from_mask:
            for to_square in scan_reversed(BB_KING_ATTACKS[king] & ~self.occupied_co[self.turn] & ~attacked & to_mask):
                yield Move(king, to_square)

        checker = msb(checkers)
        if BB_SQUARES[checker] == checkers:
            # Capture or block a single checker.
            target = between(king, checker) | checkers

            yield from self.generate_pseudo_legal_moves(~self.kings & from_mask, target & to_mask)

            # Capture the checking pawn en passant (but avoid yielding
            # duplicate moves).
            if self.ep_square and not BB_SQUARES[self.ep_square] & target:
                last_double = self.ep_square + (-8 if self.turn == WHITE else 8)
                if last_double == checker:
                    yield from self.generate_pseudo_legal_ep(from_mask, to_mask)

    def generate_legal_moves(self, from_mask: Bitboard = BB_ALL, to_mask: Bitboard = BB_ALL) -> Iterator[Move]:
        if self.is_variant_end():
            return

        king_mask = self.kings & self.occupied_co[self.turn]
        if king_mask:
            king = msb(king_mask)
            blockers = self._slider_blockers(king)
            checkers = self.attackers_mask(not self.turn, king)
            if checkers:
                for move in self._generate_evasions(king, checkers, from_mask, to_mask):
                    if self._is_safe(king, blockers, move):
                        yield move
            else:
                for move in self.generate_pseudo_legal_moves(from_mask, to_mask):
                    if self._is_safe(king, blockers, move):
                        yield move
        else:
            yield from self.generate_pseudo_legal_moves(from_mask, to_mask)

    def generate_legal_ep(self, from_mask: Bitboard = BB_ALL, to_mask: Bitboard = BB_ALL) -> Iterator[Move]:
        if self.is_variant_end():
            return

        for move in self.generate_pseudo_legal_ep(from_mask, to_mask):
            if not self.is_into_check(move):
                yield move

    def generate_legal_captures(self, from_mask: Bitboard = BB_ALL, to_mask: Bitboard = BB_ALL) -> Iterator[Move]:
        return itertools.chain(
            self.generate_legal_moves(from_mask, to_mask & self.occupied_co[not self.turn]),
            self.generate_legal_ep(from_mask, to_mask))

    def _attacked_for_king(self, path: Bitboard, occupied: Bitboard) -> bool:
        return any(self._attackers_mask(not self.turn, sq, occupied) for sq in scan_reversed(path))

    def generate_castling_moves(self, from_mask: Bitboard = BB_ALL, to_mask: Bitboard = BB_ALL) -> Iterator[Move]:
        if self.is_variant_end():
            return

        backrank = BB_RANK_1 if self.turn == WHITE else BB_RANK_8
        king = self.occupied_co[self.turn] & self.kings & ~self.promoted & backrank & from_mask
        king &= -king
        if not king:
            return

        bb_c = BB_FILE_C & backrank
        bb_d = BB_FILE_D & backrank
        bb_f = BB_FILE_F & backrank
        bb_g = BB_FILE_G & backrank

        for candidate in scan_reversed(self.clean_castling_rights() & backrank & to_mask):
            rook = BB_SQUARES[candidate]

            a_side = rook < king
            king_to = bb_c if a_side else bb_g
            rook_to = bb_d if a_side else bb_f

            king_path = between(msb(king), msb(king_to))
            rook_path = between(candidate, msb(rook_to))

            if not ((self.occupied ^ king ^ rook) & (king_path | rook_path | king_to | rook_to) or
                    self._attacked_for_king(king_path | king, self.occupied ^ king) or
                    self._attacked_for_king(king_to, self.occupied ^ king ^ rook ^ rook_to)):
                yield self._from_chess960(self.chess960, msb(king), candidate)

    def _from_chess960(self, chess960: bool, from_square: Square, to_square: Square, promotion: Optional[PieceType] = None, drop: Optional[PieceType] = None) -> Move:
        if not chess960 and promotion is None and drop is None:
            if from_square == E1 and self.kings & BB_E1:
                if to_square == H1:
                    return Move(E1, G1)
                elif to_square == A1:
                    return Move(E1, C1)
            elif from_square == E8 and self.kings & BB_E8:
                if to_square == H8:
                    return Move(E8, G8)
                elif to_square == A8:
                    return Move(E8, C8)

        return Move(from_square, to_square, promotion, drop)

    def _to_chess960(self, move: Move) -> Move:
        if move.from_square == E1 and self.kings & BB_E1:
            if move.to_square == G1 and not self.rooks & BB_G1:
                return Move(E1, H1)
            elif move.to_square == C1 and not self.rooks & BB_C1:
                return Move(E1, A1)
        elif move.from_square == E8 and self.kings & BB_E8:
            if move.to_square == G8 and not self.rooks & BB_G8:
                return Move(E8, H8)
            elif move.to_square == C8 and not self.rooks & BB_C8:
                return Move(E8, A8)

        return move

    def _transposition_key(self) -> Hashable:
        return (self.pawns, self.knights, self.bishops, self.rooks,
                self.queens, self.kings,
                self.occupied_co[WHITE], self.occupied_co[BLACK],
                self.turn, self.clean_castling_rights(),
                self.ep_square if self.has_legal_en_passant() else None)

    def __repr__(self) -> str:
        if not self.chess960:
            return f""{type(self).__name__}({self.fen()!r})""
        else:
            return f""{type(self).__name__}({self.fen()!r}, chess960=True)""

    def _repr_svg_(self) -> str:
        import chess.svg
        return chess.svg.board(
            board=self,
            size=390,
            lastmove=self.peek() if self.move_stack else None,
            check=self.king(self.turn) if self.is_check() else None)

    def __eq__(self, board: object) -> bool:
        if isinstance(board, Board):
            return (
                self.halfmove_clock == board.halfmove_clock and
                self.fullmove_number == board.fullmove_number and
                type(self).uci_variant == type(board).uci_variant and
                self._transposition_key() == board._transposition_key())
        else:
            return NotImplemented

    def apply_transform(self, f: Callable[[Bitboard], Bitboard]) -> None:
        super().apply_transform(f)
        self.clear_stack()
        self.ep_square = None if self.ep_square is None else msb(f(BB_SQUARES[self.ep_square]))
        self.castling_rights = f(self.castling_rights)

    def transform(self: BoardT, f: Callable[[Bitboard], Bitboard]) -> BoardT:
        board = self.copy(stack=False)
        board.apply_transform(f)
        return board

    def apply_mirror(self: BoardT) -> None:
        super().apply_mirror()
        self.turn = not self.turn

    def mirror(self: BoardT) -> BoardT:
        """"""
        Returns a mirrored copy of the board.

        The board is mirrored vertically and piece colors are swapped, so that
        the position is equivalent modulo color. Also swap the ""en passant""
        square, castling rights and turn.

        Alternatively, :func:`~chess.Board.apply_mirror()` can be used
        to mirror the board.
        """"""
        board = self.copy()
        board.apply_mirror()
        return board

    def copy(self: BoardT, *, stack: Union[bool, int] = True) -> BoardT:
        """"""
        Creates a copy of the board.

        Defaults to copying the entire move stack. Alternatively, *stack* can
        be ``False``, or an integer to copy a limited number of moves.
        """"""
        board = super().copy()

        board.chess960 = self.chess960

        board.ep_square = self.ep_square
        board.castling_rights = self.castling_rights
        board.turn = self.turn
        board.fullmove_number = self.fullmove_number
        board.halfmove_clock = self.halfmove_clock

        if stack:
            stack = len(self.move_stack) if stack is True else stack
            board.move_stack = [copy.copy(move) for move in self.move_stack[-stack:]]
            board._stack = self._stack[-stack:]

        return board

    @classmethod
    def empty(cls: Type[BoardT], *, chess960: bool = False) -> BoardT:
        """"""Creates a new empty board. Also see :func:`~chess.Board.clear()`.""""""
        return cls(None, chess960=chess960)

    @classmethod
    def from_epd(cls: Type[BoardT], epd: str, *, chess960: bool = False) -> Tuple[BoardT, Dict[str, Union[None, str, int, float, Move, List[Move]]]]:
        """"""
        Creates a new board from an EPD string. See
        :func:`~chess.Board.set_epd()`.

        Returns the board and the dictionary of parsed operations as a tuple.
        """"""
        board = cls.empty(chess960=chess960)
        return board, board.set_epd(epd)

    @classmethod
    def from_chess960_pos(cls: Type[BoardT], scharnagl: int) -> BoardT:
        board = cls.empty(chess960=True)
        board.set_chess960_pos(scharnagl)
        return board


class PseudoLegalMoveGenerator:

    def __init__(self, board: Board) -> None:
        self.board = board

    def __bool__(self) -> bool:
        return any(self.board.generate_pseudo_legal_moves())

    def count(self) -> int:
        # List conversion is faster than iterating.
        return len(list(self))

    def __iter__(self) -> Iterator[Move]:
        return self.board.generate_pseudo_legal_moves()

    def __contains__(self, move: Move) -> bool:
        return self.board.is_pseudo_legal(move)

    def __repr__(self) -> str:
        builder = []

        for move in self:
            if self.board.is_legal(move):
                builder.append(self.board.san(move))
            else:
                builder.append(self.board.uci(move))

        sans = "", "".join(builder)
        return f""<PseudoLegalMoveGenerator at {id(self):#x} ({sans})>""


class LegalMoveGenerator:

    def __init__(self, board: Board) -> None:
        self.board = board

    def __bool__(self) -> bool:
        return any(self.board.generate_legal_moves())

    def count(self) -> int:
        # List conversion is faster than iterating.
        return len(list(self))

    def __iter__(self) -> Iterator[Move]:
        return self.board.generate_legal_moves()

    def __contains__(self, move: Move) -> bool:
        return self.board.is_legal(move)

    def __repr__(self) -> str:
        sans = "", "".join(self.board.san(move) for move in self)
        return f""<LegalMoveGenerator at {id(self):#x} ({sans})>""


IntoSquareSet = Union[SupportsInt, Iterable[Square]]

class SquareSet:
    """"""
    A set of squares.

    >>> import chess
    >>>
    >>> squares = chess.SquareSet([chess.A8, chess.A1])
    >>> squares
    SquareSet(0x0100_0000_0000_0001)

    >>> squares = chess.SquareSet(chess.BB_A8 | chess.BB_RANK_1)
    >>> squares
    SquareSet(0x0100_0000_0000_00ff)

    >>> print(squares)
    1 . . . . . . .
    . . . . . . . .
    . . . . . . . .
    . . . . . . . .
    . . . . . . . .
    . . . . . . . .
    . . . . . . . .
    1 1 1 1 1 1 1 1

    >>> len(squares)
    9

    >>> bool(squares)
    True

    >>> chess.B1 in squares
    True

    >>> for square in squares:
    ...     # 0 -- chess.A1
    ...     # 1 -- chess.B1
    ...     # 2 -- chess.C1
    ...     # 3 -- chess.D1
    ...     # 4 -- chess.E1
    ...     # 5 -- chess.F1
    ...     # 6 -- chess.G1
    ...     # 7 -- chess.H1
    ...     # 56 -- chess.A8
    ...     print(square)
    ...
    0
    1
    2
    3
    4
    5
    6
    7
    56

    >>> list(squares)
    [0, 1, 2, 3, 4, 5, 6, 7, 56]

    Square sets are internally represented by 64-bit integer masks of the
    included squares. Bitwise operations can be used to compute unions,
    intersections and shifts.

    >>> int(squares)
    72057594037928191

    Also supports common set operations like
    :func:`~chess.SquareSet.issubset()`, :func:`~chess.SquareSet.issuperset()`,
    :func:`~chess.SquareSet.union()`, :func:`~chess.SquareSet.intersection()`,
    :func:`~chess.SquareSet.difference()`,
    :func:`~chess.SquareSet.symmetric_difference()` and
    :func:`~chess.SquareSet.copy()` as well as
    :func:`~chess.SquareSet.update()`,
    :func:`~chess.SquareSet.intersection_update()`,
    :func:`~chess.SquareSet.difference_update()`,
    :func:`~chess.SquareSet.symmetric_difference_update()` and
    :func:`~chess.SquareSet.clear()`.
    """"""

    def __init__(self, squares: IntoSquareSet = BB_EMPTY) -> None:
        try:
            self.mask = squares.__int__() & BB_ALL  # type: ignore
            return
        except AttributeError:
            self.mask = 0

        # Try squares as an iterable. Not under except clause for nicer
        # backtraces.
        for square in squares:  # type: ignore
            self.add(square)

    # Set

    def __contains__(self, square: Square) -> bool:
        return bool(BB_SQUARES[square] & self.mask)

    def __iter__(self) -> Iterator[Square]:
        return scan_forward(self.mask)

    def __reversed__(self) -> Iterator[Square]:
        return scan_reversed(self.mask)

    def __len__(self) -> int:
        return popcount(self.mask)

    # MutableSet

    def add(self, square: Square) -> None:
        """"""Adds a square to the set.""""""
        self.mask |= BB_SQUARES[square]

    def discard(self, square: Square) -> None:
        """"""Discards a square from the set.""""""
        self.mask &= ~BB_SQUARES[square]

    # frozenset

    def isdisjoint(self, other: IntoSquareSet) -> bool:
        """"""Tests if the square sets are disjoint.""""""
        return not bool(self & other)

    def issubset(self, other: IntoSquareSet) -> bool:
        """"""Tests if this square set is a subset of another.""""""
        return not bool(self & ~SquareSet(other))

    def issuperset(self, other: IntoSquareSet) -> bool:
        """"""Tests if this square set is a superset of another.""""""
        return not bool(~self & other)

    def union(self, other: IntoSquareSet) -> SquareSet:
        return self | other

    def __or__(self, other: IntoSquareSet) -> SquareSet:
        r = SquareSet(other)
        r.mask |= self.mask
        return r

    def intersection(self, other: IntoSquareSet) -> SquareSet:
        return self & other

    def __and__(self, other: IntoSquareSet) -> SquareSet:
        r = SquareSet(other)
        r.mask &= self.mask
        return r

    def difference(self, other: IntoSquareSet) -> SquareSet:
        return self - other

    def __sub__(self, other: IntoSquareSet) -> SquareSet:
        r = SquareSet(other)
        r.mask = self.mask & ~r.mask
        return r

    def symmetric_difference(self, other: IntoSquareSet) -> SquareSet:
        return self ^ other

    def __xor__(self, other: IntoSquareSet) -> SquareSet:
        r = SquareSet(other)
        r.mask ^= self.mask
        return r

    def copy(self) -> SquareSet:
        return SquareSet(self.mask)

    # set

    def update(self, *others: IntoSquareSet) -> None:
        for other in others:
            self |= other

    def __ior__(self, other: IntoSquareSet) -> SquareSet:
        self.mask |= SquareSet(other).mask
        return self

    def intersection_update(self, *others: IntoSquareSet) -> None:
        for other in others:
            self &= other

    def __iand__(self, other: IntoSquareSet) -> SquareSet:
        self.mask &= SquareSet(other).mask
        return self

    def difference_update(self, other: IntoSquareSet) -> None:
        self -= other

    def __isub__(self, other: IntoSquareSet) -> SquareSet:
        self.mask &= ~SquareSet(other).mask
        return self

    def symmetric_difference_update(self, other: IntoSquareSet) -> None:
        self ^= other

    def __ixor__(self, other: IntoSquareSet) -> SquareSet:
        self.mask ^= SquareSet(other).mask
        return self

    def remove(self, square: Square) -> None:
        """"""
        Removes a square from the set.

        :raises: :exc:`KeyError` if the given *square* was not in the set.
        """"""
        mask = BB_SQUARES[square]
        if self.mask & mask:
            self.mask ^= mask
        else:
            raise KeyError(square)

    def pop(self) -> Square:
        """"""
        Removes and returns a square from the set.

        :raises: :exc:`KeyError` if the set is empty.
        """"""
        if not self.mask:
            raise KeyError(""pop from empty SquareSet"")

        square = lsb(self.mask)
        self.mask &= (self.mask - 1)
        return square

    def clear(self) -> None:
        """"""Removes all elements from this set.""""""
        self.mask = BB_EMPTY

    # SquareSet

    def carry_rippler(self) -> Iterator[Bitboard]:
        """"""Iterator over the subsets of this set.""""""
        return _carry_rippler(self.mask)

    def mirror(self) -> SquareSet:
        """"""Returns a vertically mirrored copy of this square set.""""""
        return SquareSet(flip_vertical(self.mask))

    def tolist(self) -> List[bool]:
        """"""Converts the set to a list of 64 bools.""""""
        result = [False] * 64
        for square in self:
            result[square] = True
        return result

    def __bool__(self) -> bool:
        return bool(self.mask)

    def __eq__(self, other: object) -> bool:
        try:
            return self.mask == SquareSet(other).mask  # type: ignore
        except (TypeError, ValueError):
            return NotImplemented

    def __lshift__(self, shift: int) -> SquareSet:
        return SquareSet((self.mask << shift) & BB_ALL)

    def __rshift__(self, shift: int) -> SquareSet:
        return SquareSet(self.mask >> shift)

    def __ilshift__(self, shift: int) -> SquareSet:
        self.mask = (self.mask << shift) & BB_ALL
        return self

    def __irshift__(self, shift: int) -> SquareSet:
        self.mask >>= shift
        return self

    def __invert__(self) -> SquareSet:
        return SquareSet(~self.mask & BB_ALL)

    def __int__(self) -> int:
        return self.mask

    def __index__(self) -> int:
        return self.mask

    def __repr__(self) -> str:
        return f""SquareSet({self.mask:#021_x})""

    def __str__(self) -> str:
        builder = []

        for square in SQUARES_180:
            mask = BB_SQUARES[square]
            builder.append(""1"" if self.mask & mask else ""."")

            if not mask & BB_FILE_H:
                builder.append("" "")
            elif square != H1:
                builder.append(""\n"")

        return """".join(builder)

    def _repr_svg_(self) -> str:
        import chess.svg
        return chess.svg.board(squares=self, size=390)

    @classmethod
    def ray(cls, a: Square, b: Square) -> SquareSet:
        """"""
        All squares on the rank, file or diagonal with the two squares, if they
        are aligned.

        >>> import chess
        >>>
        >>> print(chess.SquareSet.ray(chess.E2, chess.B5))
        . . . . . . . .
        . . . . . . . .
        1 . . . . . . .
        . 1 . . . . . .
        . . 1 . . . . .
        . . . 1 . . . .
        . . . . 1 . . .
        . . . . . 1 . .
        """"""
        return cls(ray(a, b))

    @classmethod
    def between(cls, a: Square, b: Square) -> SquareSet:
        """"""
        All squares on the rank, file or diagonal between the two squares
        (bounds not included), if they are aligned.

        >>> import chess
        >>>
        >>> print(chess.SquareSet.between(chess.E2, chess.B5))
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . 1 . . . . .
        . . . 1 . . . .
        . . . . . . . .
        . . . . . . . .
        """"""
        return cls(between(a, b))

    @classmethod
    def from_square(cls, square: Square) -> SquareSet:
        """"""
        Creates a :class:`~chess.SquareSet` from a single square.

        >>> import chess
        >>>
        >>> chess.SquareSet.from_square(chess.A1) == chess.BB_A1
        True
        """"""
        return cls(BB_SQUARES[square])
"
yqaAKHN6,Untitled,esraa_syam,C++,Thursday 4th of July 2024 02:51:29 PM CDT,"#include ""bits/stdc++.h""
using namespace std;

#define nl ""\n""
#define ll long long
#define mod  1'000'000'007
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define sz(v) (int) v.size()

template<typename T = int>
istream &operator>>(istream &in, vector<T> &v) {
    for (auto &x: v) in >> x;
    return in;
}

template<typename T = int>
ostream &operator<<(ostream &out, const vector<T> &v) {
    for (const T &x: v) out << x << "" "";
    return out;
}

void Sira() {
    ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
#ifndef ONLINE_JUDGE
    freopen(""input.txt"", ""r"", stdin), freopen(""output.txt"", ""w"", stdout);
#endif
}
struct node {
    pair < ll , char > maxi;
    vector < int > freq;

    node(){
        maxi = {0 , 'a'};
        freq.assign(26 , 0);
    }
};

struct SegTree{
    int tree_size;
    vector < node > tree;

    SegTree(int n){
        tree_size = 1;
        while (tree_size < n) tree_size *= 2;
        tree.assign(2 * tree_size, node());
    }

    void build(string & s , int ni , int lx , int rx){
        if(rx - lx == 1){
            if(lx < sz(s)){
                tree[ni].freq[s[lx] - 'a']++;
            }
            return;
        }

        int mid = (lx + rx) / 2;
        build(s , 2 * ni + 1 , lx , mid);
        build(s , 2 * ni + 2 , mid , rx);

        tree[ni] = merge(tree[2 * ni + 1] , tree[2 * ni + 2]);
    }

    void build(string & s){
        build(s , 0 , 0 , tree_size);
    }

    node merge(node & l , node & r){
        node res;
        res.maxi = max(l.maxi , r.maxi);
        for(int i = 0; i < 26; i++){
            res.freq[i] = l.freq[i] + r.freq[i];
            res.maxi = max(res.maxi , {res.freq[i] , (char)(i + 'a')});
        }
        return res;
    }

    void update(int idx , int val , int ni , int lx , int rx){
        if(rx - lx == 1){
            tree[ni].freq[val]++;
            return;
        }

        int mid = (lx + rx) / 2;
        if(idx < mid){
            update(idx , val , 2 * ni + 1 , lx , mid);
        }else{
            update(idx , val , 2 * ni + 2 , mid , rx);
        }

        tree[ni] = merge(tree[2 * ni + 1] , tree[2 * ni + 2]);
    }

    void update(int idx , int val){
        update(idx , val , 0 , 0 , tree_size);
    }

    node calc(int l , int r , int ni , int lx , int rx){
        if(lx >= r || l >= rx) return node();
        if(lx >= l && rx <= r) return tree[ni];

        int mid = (lx + rx) / 2;
        node left = calc(l , r , 2 * ni + 1 , lx , mid);
        node right = calc(l , r , 2 * ni + 2 , mid , rx);

        return merge(left , right);
    }

    pair < ll  , char > calc(int l , int r){
        return calc(l , r , 0 , 0 , tree_size).maxi;
    }
};

void solve(){
    int n;
    cin >> n;

    string s;
    cin >> s;

    SegTree st(n);
    st.build(s);

    map < char , vector < int > > mp;

    for(int i = 0; i < n; i++){
        mp[s[i]].push_back(i);
    }


    int q;
    cin >> q;

    while(q--){
        int l , r;
        cin >> l >> r;
        l--;
        auto up = upper_bound(all(mp[st.calc(l , r).second]) , r - 1);
        auto low = lower_bound(all(mp[st.calc(l , r).second]) , l);
//        cout << up - low << nl;
        if(abs(low - up) == abs(r - l) or st.calc(l , r).first == 1){
            cout << ""NO"" << nl;
        }else{
            int up2 = *up;
            int low2 = *low;

            if(up2 < n - 1 and (up2 - low2 + 1) != (low - up)) cout << ""NO"" << nl;
            else cout << ""YES"" << nl;
        }

        cout << st.calc(l , r).first << "" "" << st.calc(l , r).second << nl;
    }

}

int main() {
    Sira();
    int t = 1;
//    cin >> t;
    while(t--){
        solve();
    }
    return 0;
}
"
EaR5ySXD,Untitled,diegopiresme,PHP,Thursday 4th of July 2024 02:25:47 PM CDT,"[2024-07-04 14:12:08] local.INFO: suitpay  
[2024-07-04 14:12:14] local.ERROR: Attempt to read property ""status"" on null {""exception"":""[object] (ErrorException(code: 0): Attempt to read property \""status\"" on null at /www/wwwroot/casinodcp.cfd/app/Traits/Gateways/SuitpayTrait.php:117)
[stacktrace]
#0 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Foundation/Bootstrap/HandleExceptions.php(255): Illuminate\\Foundation\\Bootstrap\\HandleExceptions->handleError()
#1 /www/wwwroot/casinodcp.cfd/app/Traits/Gateways/SuitpayTrait.php(117): Illuminate\\Foundation\\Bootstrap\\HandleExceptions->Illuminate\\Foundation\\Bootstrap\\{closure}()
#2 /www/wwwroot/casinodcp.cfd/app/Http/Controllers/Gateway/SuitPayController.php(64): App\\Http\\Controllers\\Gateway\\SuitPayController::consultStatusTransaction()
#3 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Routing/Controller.php(54): App\\Http\\Controllers\\Gateway\\SuitPayController->consultStatusTransactionPix()
#4 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Routing/ControllerDispatcher.php(43): Illuminate\\Routing\\Controller->callAction()
#5 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Routing/Route.php(259): Illuminate\\Routing\\ControllerDispatcher->dispatch()
#6 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Routing/Route.php(205): Illuminate\\Routing\\Route->runController()
#7 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Routing/Router.php(806): Illuminate\\Routing\\Route->run()
#8 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(144): Illuminate\\Routing\\Router->Illuminate\\Routing\\{closure}()
#9 /www/wwwroot/casinodcp.cfd/app/Http/Middleware/ProtectEnv.php(21): Illuminate\\Pipeline\\Pipeline->Illuminate\\Pipeline\\{closure}()
#10 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(183): App\\Http\\Middleware\\ProtectEnv->handle()
#11 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Routing/Middleware/SubstituteBindings.php(50): Illuminate\\Pipeline\\Pipeline->Illuminate\\Pipeline\\{closure}()
#12 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(183): Illuminate\\Routing\\Middleware\\SubstituteBindings->handle()
#13 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(119): Illuminate\\Pipeline\\Pipeline->Illuminate\\Pipeline\\{closure}()
#14 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Routing/Router.php(805): Illuminate\\Pipeline\\Pipeline->then()
#15 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Routing/Router.php(784): Illuminate\\Routing\\Router->runRouteWithinStack()
#16 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Routing/Router.php(748): Illuminate\\Routing\\Router->runRoute()
#17 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Routing/Router.php(737): Illuminate\\Routing\\Router->dispatchToRoute()
#18 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php(200): Illuminate\\Routing\\Router->dispatch()
#19 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(144): Illuminate\\Foundation\\Http\\Kernel->Illuminate\\Foundation\\Http\\{closure}()
#20 /www/wwwroot/casinodcp.cfd/vendor/livewire/livewire/src/Features/SupportDisablingBackButtonCache/DisableBackButtonCacheMiddleware.php(19): Illuminate\\Pipeline\\Pipeline->Illuminate\\Pipeline\\{closure}()
#21 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(183): Livewire\\Features\\SupportDisablingBackButtonCache\\DisableBackButtonCacheMiddleware->handle()
#22 /www/wwwroot/casinodcp.cfd/app/Http/Middleware/SetDefaultLanguage.php(22): Illuminate\\Pipeline\\Pipeline->Illuminate\\Pipeline\\{closure}()
#23 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(183): App\\Http\\Middleware\\SetDefaultLanguage->handle()
#24 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TransformsRequest.php(21): Illuminate\\Pipeline\\Pipeline->Illuminate\\Pipeline\\{closure}()
#25 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/ConvertEmptyStringsToNull.php(31): Illuminate\\Foundation\\Http\\Middleware\\TransformsRequest->handle()
#26 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(183): Illuminate\\Foundation\\Http\\Middleware\\ConvertEmptyStringsToNull->handle()
#27 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TransformsRequest.php(21): Illuminate\\Pipeline\\Pipeline->Illuminate\\Pipeline\\{closure}()
#28 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TrimStrings.php(40): Illuminate\\Foundation\\Http\\Middleware\\TransformsRequest->handle()
#29 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(183): Illuminate\\Foundation\\Http\\Middleware\\TrimStrings->handle()
#30 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/ValidatePostSize.php(27): Illuminate\\Pipeline\\Pipeline->Illuminate\\Pipeline\\{closure}()
#31 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(183): Illuminate\\Foundation\\Http\\Middleware\\ValidatePostSize->handle()
#32 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/PreventRequestsDuringMaintenance.php(99): Illuminate\\Pipeline\\Pipeline->Illuminate\\Pipeline\\{closure}()
#33 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(183): Illuminate\\Foundation\\Http\\Middleware\\PreventRequestsDuringMaintenance->handle()
#34 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Http/Middleware/HandleCors.php(62): Illuminate\\Pipeline\\Pipeline->Illuminate\\Pipeline\\{closure}()
#35 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(183): Illuminate\\Http\\Middleware\\HandleCors->handle()
#36 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Http/Middleware/TrustProxies.php(39): Illuminate\\Pipeline\\Pipeline->Illuminate\\Pipeline\\{closure}()
#37 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(183): Illuminate\\Http\\Middleware\\TrustProxies->handle()
#38 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(119): Illuminate\\Pipeline\\Pipeline->Illuminate\\Pipeline\\{closure}()
#39 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php(175): Illuminate\\Pipeline\\Pipeline->then()
#40 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php(144): Illuminate\\Foundation\\Http\\Kernel->sendRequestThroughRouter()
#41 /www/wwwroot/casinodcp.cfd/public/index.php(51): Illuminate\\Foundation\\Http\\Kernel->handle()
#42 {main}
""} 
[2024-07-04 14:12:19] local.ERROR: Attempt to read property ""status"" on null {""exception"":""[object] (ErrorException(code: 0): Attempt to read property \""status\"" on null at /www/wwwroot/casinodcp.cfd/app/Traits/Gateways/SuitpayTrait.php:117)
[stacktrace]
#0 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Foundation/Bootstrap/HandleExceptions.php(255): Illuminate\\Foundation\\Bootstrap\\HandleExceptions->handleError()
#1 /www/wwwroot/casinodcp.cfd/app/Traits/Gateways/SuitpayTrait.php(117): Illuminate\\Foundation\\Bootstrap\\HandleExceptions->Illuminate\\Foundation\\Bootstrap\\{closure}()
#2 /www/wwwroot/casinodcp.cfd/app/Http/Controllers/Gateway/SuitPayController.php(64): App\\Http\\Controllers\\Gateway\\SuitPayController::consultStatusTransaction()
#3 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Routing/Controller.php(54): App\\Http\\Controllers\\Gateway\\SuitPayController->consultStatusTransactionPix()
#4 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Routing/ControllerDispatcher.php(43): Illuminate\\Routing\\Controller->callAction()
#5 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Routing/Route.php(259): Illuminate\\Routing\\ControllerDispatcher->dispatch()
#6 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Routing/Route.php(205): Illuminate\\Routing\\Route->runController()
#7 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Routing/Router.php(806): Illuminate\\Routing\\Route->run()
#8 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(144): Illuminate\\Routing\\Router->Illuminate\\Routing\\{closure}()
#9 /www/wwwroot/casinodcp.cfd/app/Http/Middleware/ProtectEnv.php(21): Illuminate\\Pipeline\\Pipeline->Illuminate\\Pipeline\\{closure}()
#10 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(183): App\\Http\\Middleware\\ProtectEnv->handle()
#11 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Routing/Middleware/SubstituteBindings.php(50): Illuminate\\Pipeline\\Pipeline->Illuminate\\Pipeline\\{closure}()
#12 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(183): Illuminate\\Routing\\Middleware\\SubstituteBindings->handle()
#13 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(119): Illuminate\\Pipeline\\Pipeline->Illuminate\\Pipeline\\{closure}()
#14 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Routing/Router.php(805): Illuminate\\Pipeline\\Pipeline->then()
#15 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Routing/Router.php(784): Illuminate\\Routing\\Router->runRouteWithinStack()
#16 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Routing/Router.php(748): Illuminate\\Routing\\Router->runRoute()
#17 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Routing/Router.php(737): Illuminate\\Routing\\Router->dispatchToRoute()
#18 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php(200): Illuminate\\Routing\\Router->dispatch()
#19 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(144): Illuminate\\Foundation\\Http\\Kernel->Illuminate\\Foundation\\Http\\{closure}()
#20 /www/wwwroot/casinodcp.cfd/vendor/livewire/livewire/src/Features/SupportDisablingBackButtonCache/DisableBackButtonCacheMiddleware.php(19): Illuminate\\Pipeline\\Pipeline->Illuminate\\Pipeline\\{closure}()
#21 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(183): Livewire\\Features\\SupportDisablingBackButtonCache\\DisableBackButtonCacheMiddleware->handle()
#22 /www/wwwroot/casinodcp.cfd/app/Http/Middleware/SetDefaultLanguage.php(22): Illuminate\\Pipeline\\Pipeline->Illuminate\\Pipeline\\{closure}()
#23 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(183): App\\Http\\Middleware\\SetDefaultLanguage->handle()
#24 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TransformsRequest.php(21): Illuminate\\Pipeline\\Pipeline->Illuminate\\Pipeline\\{closure}()
#25 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/ConvertEmptyStringsToNull.php(31): Illuminate\\Foundation\\Http\\Middleware\\TransformsRequest->handle()
#26 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(183): Illuminate\\Foundation\\Http\\Middleware\\ConvertEmptyStringsToNull->handle()
#27 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TransformsRequest.php(21): Illuminate\\Pipeline\\Pipeline->Illuminate\\Pipeline\\{closure}()
#28 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TrimStrings.php(40): Illuminate\\Foundation\\Http\\Middleware\\TransformsRequest->handle()
#29 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(183): Illuminate\\Foundation\\Http\\Middleware\\TrimStrings->handle()
#30 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/ValidatePostSize.php(27): Illuminate\\Pipeline\\Pipeline->Illuminate\\Pipeline\\{closure}()
#31 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(183): Illuminate\\Foundation\\Http\\Middleware\\ValidatePostSize->handle()
#32 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/PreventRequestsDuringMaintenance.php(99): Illuminate\\Pipeline\\Pipeline->Illuminate\\Pipeline\\{closure}()
#33 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(183): Illuminate\\Foundation\\Http\\Middleware\\PreventRequestsDuringMaintenance->handle()
#34 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Http/Middleware/HandleCors.php(62): Illuminate\\Pipeline\\Pipeline->Illuminate\\Pipeline\\{closure}()
#35 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(183): Illuminate\\Http\\Middleware\\HandleCors->handle()
#36 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Http/Middleware/TrustProxies.php(39): Illuminate\\Pipeline\\Pipeline->Illuminate\\Pipeline\\{closure}()
#37 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(183): Illuminate\\Http\\Middleware\\TrustProxies->handle()
#38 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php(119): Illuminate\\Pipeline\\Pipeline->Illuminate\\Pipeline\\{closure}()
#39 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php(175): Illuminate\\Pipeline\\Pipeline->then()
#40 /www/wwwroot/casinodcp.cfd/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php(144): Illuminate\\Foundation\\Http\\Kernel->sendRequestThroughRouter()
#41 /www/wwwroot/casinodcp.cfd/public/index.php(51): Illuminate\\Foundation\\Http\\Kernel->handle()
#42 {main}
""} "
Mg2hzshe,bishops amazons BB good OK,max2201111,Python,Thursday 4th of July 2024 02:25:17 PM CDT,"import chess
import time
from functools import lru_cache
import traceback
from typing import Iterator
from chess import Move, BB_ALL, Bitboard, scan_reversed

# Definice nov√Ωch figurek
AMAZON = 7

class CustomBoard(chess.Board):
    def __init__(self, fen=None):
        self.amazons = chess.BB_EMPTY
        self.custom_bishops = chess.BB_EMPTY
        super().__init__(None)  # Initialize with empty board
        if fen:
            self.set_custom_fen(fen)

    def set_custom_fen(self, fen):
        parts = fen.split()
        board_part = parts[0]
        self.clear()
        self.amazons = chess.BB_EMPTY
        self.custom_bishops = chess.BB_EMPTY
        square = 0
        for c in board_part:
            if c == '/':
                continue
            elif c.isdigit():
                square += int(c)
            else:
                color = chess.WHITE if c.isupper() else chess.BLACK
                piece_type = chess.PIECE_SYMBOLS.index(c.lower()) if c.lower() not in ['a', 'b'] else (AMAZON if c.lower() == 'a' else chess.BISHOP)
                self._set_piece_at(square, chess.Piece(piece_type, color))
                square += 1
        
        self.turn = chess.WHITE if parts[1] == 'w' else chess.BLACK
        self.set_castling_fen(parts[2])
        self.ep_square = chess.parse_square(parts[3]) if parts[3] != '-' else None
        self.halfmove_clock = int(parts[4]) if len(parts) > 4 else 0
        self.fullmove_number = int(parts[5]) if len(parts) > 5 else 1
        print(f""After setting FEN, amazons bitboard: {self.amazons:064b}"")
        print(f""After setting FEN, custom bishops bitboard: {self.custom_bishops:064b}"")

    def _set_piece_at(self, square, piece, promoted=False):
        super()._set_piece_at(square, piece, promoted)
        if piece:
            if piece.piece_type == AMAZON:
                self.amazons |= chess.BB_SQUARES[square]
            elif piece.piece_type == chess.BISHOP:
                self.custom_bishops |= chess.BB_SQUARES[square]
        else:
            self.amazons &= ~chess.BB_SQUARES[square]
            self.custom_bishops &= ~chess.BB_SQUARES[square]
        print(f""After _set_piece_at, amazons bitboard: {self.amazons:064b}"")
        print(f""After _set_piece_at, custom bishops bitboard: {self.custom_bishops:064b}"")

    def piece_type_at(self, square):
        if self.amazons & chess.BB_SQUARES[square]:
            return AMAZON
        if self.custom_bishops & chess.BB_SQUARES[square]:
            return chess.BISHOP
        return super().piece_type_at(square)

    def piece_at(self, square):
        if self.amazons & chess.BB_SQUARES[square]:
            color = bool(self.occupied_co[chess.WHITE] & chess.BB_SQUARES[square])
            return chess.Piece(AMAZON, color)
        if self.custom_bishops & chess.BB_SQUARES[square]:
            color = bool(self.occupied_co[chess.WHITE] & chess.BB_SQUARES[square])
            return chess.Piece(chess.BISHOP, color)
        return super().piece_at(square)

    def generate_pseudo_legal_moves(self, from_mask: Bitboard = BB_ALL, to_mask: Bitboard = BB_ALL) -> Iterator[Move]:
        print(""Generating pseudo-legal moves..."")
        print(f""Current amazons bitboard: {self.amazons:064b}"")
        print(f""Current custom bishops bitboard: {self.custom_bishops:064b}"")
        print(f""Current turn: {'White' if self.turn == chess.WHITE else 'Black'}"")

        # Generate standard moves
        for move in super().generate_pseudo_legal_moves(from_mask, to_mask):
            print(f""Standard pseudo-legal move: {move}"")
            yield move

        # Generate amazon moves
        our_amazons = self.amazons & self.occupied_co[self.turn] & from_mask
        print(f""Our amazons: {our_amazons:064b}"")
        for from_square in chess.scan_forward(our_amazons):
            attacks = self.amazon_attacks(from_square)
            print(f""Amazon at {chess.SQUARE_NAMES[from_square]}, attacks: {attacks:064b}"")
            for to_square in chess.scan_forward(attacks & ~self.occupied & to_mask):
                move = Move(from_square, to_square)
                print(f""Amazon pseudo-legal move: {move}"")
                yield move

        # Generate custom bishop moves
        our_bishops = self.custom_bishops & self.occupied_co[self.turn] & from_mask
        print(f""Our custom bishops: {our_bishops:064b}"")
        for from_square in chess.scan_forward(our_bishops):
            attacks = self.bishop_attacks(from_square)
            print(f""Custom bishop at {chess.SQUARE_NAMES[from_square]}, attacks: {attacks:064b}"")
            for to_square in chess.scan_forward(attacks & ~self.occupied & to_mask):
                move = Move(from_square, to_square)
                print(f""Custom bishop pseudo-legal move: {move}"")
                yield move

    def amazon_attacks(self, square):
        queen_attacks = self.attacks_mask(chess.QUEEN, square, self.occupied)
        knight_attacks = self.attacks_mask(chess.KNIGHT, square, self.occupied)
        print(f""Amazon at {chess.SQUARE_NAMES[square]}:"")
        print(f""  Queen attacks: {queen_attacks:064b}"")
        print(f""  Knight attacks: {knight_attacks:064b}"")
        return queen_attacks | knight_attacks

    def bishop_attacks(self, square):
        return self.attacks_mask(chess.BISHOP, square, self.occupied)

    def is_check(self):
        king = self.king(self.turn)
        if king is None:
            return False

        if super().is_check():
            return True

        opponent_amazons = self.amazons & self.occupied_co[not self.turn]
        for amazon_square in chess.scan_forward(opponent_amazons):
            if self.amazon_attacks(amazon_square) & chess.BB_SQUARES[king]:
                return True

        return False

    def is_legal(self, move: Move) -> bool:
        print(f""Checking legality of move: {move}"")
        if not self.is_pseudo_legal(move):
            print(""Move is not pseudo-legal"")
            return False
        
        self.push(move)
        legal = not self.is_check()
        self.pop()
        
        if legal:
            print(""Move is legal"")
        else:
            print(""Move is illegal (leaves king in check)"")
        return legal

    def push(self, move):
        piece = self.piece_at(move.from_square)
        super().push(move)
        if piece:
            if piece.piece_type == AMAZON:
                self.amazons &= ~chess.BB_SQUARES[move.from_square]
                self.amazons |= chess.BB_SQUARES[move.to_square]
            elif piece.piece_type == chess.BISHOP:
                self.custom_bishops &= ~chess.BB_SQUARES[move.from_square]
                self.custom_bishops |= chess.BB_SQUARES[move.to_square]

    def pop(self):
        move = self.move_stack[-1]
        piece = self.piece_at(move.to_square)
        result = super().pop()
        if piece:
            if piece.piece_type == AMAZON:
                self.amazons &= ~chess.BB_SQUARES[move.to_square]
                self.amazons |= chess.BB_SQUARES[move.from_square]
            elif piece.piece_type == chess.BISHOP:
                self.custom_bishops &= ~chess.BB_SQUARES[move.to_square]
                self.custom_bishops |= chess.BB_SQUARES[move.from_square]
        return result

    def piece_symbol(self, piece):
        if piece is None:
            return '.'
        if piece.piece_type == AMAZON:
            return 'A' if piece.color == chess.WHITE else 'a'
        if piece.piece_type == chess.BISHOP:
            return 'B' if piece.color == chess.WHITE else 'b'
        return piece.symbol()

    def fen(self):
        fen = []
        empty = 0

        for square in chess.SQUARES_180:
            piece = self.piece_at(square)

            if not piece:
                empty += 1
            else:
                if empty:
                    fen.append(str(empty))
                    empty = 0
                fen.append(self.piece_symbol(piece))

            if chess.BB_SQUARES[square] & chess.BB_FILE_H:
                if empty:
                    fen.append(str(empty))
                    empty = 0

                if square != chess.H1:
                    fen.append(""/"")

        return "" "".join([
            """".join(fen),
            ""w"" if self.turn == chess.WHITE else ""b"",
            self.castling_xfen(),
            chess.SQUARE_NAMES[self.ep_square] if self.ep_square is not None else ""-"",
            str(self.halfmove_clock),
            str(self.fullmove_number)
        ])

@lru_cache(maxsize=None)
def simplify_fen_string(fen):
    parts = fen.split(' ')
    return ' '.join(parts[:4])

def format_time(seconds):
    hours, remainder = divmod(seconds, 3600)
    minutes, seconds = divmod(remainder, 60)
    return f""{int(hours):02d}h {int(minutes):02d}m {int(seconds):02d}s""

def analyze_positions(start_fen, min_depth=5):
    POZ = {1: start_fen}
    AR = {simplify_fen_string(start_fen): {'depth': 0, 'value': None}}
    N = 1

    start_time = time.time()
    total_time = 0

    while True:
        new_positions = False
        for i in range(1, N + 1):
            current_fen = POZ[i]
            board = CustomBoard(current_fen)
            simplified_fen = simplify_fen_string(current_fen)
            
            if AR[simplified_fen]['depth'] == 0:
                AR[simplified_fen]['depth'] = 1
                legal_moves = list(board.legal_moves)
                print(f""Pozice {i}: {simplified_fen}, Poƒçet leg√°ln√≠ch tah≈Ø: {len(legal_moves)}"")
                for move in legal_moves:
                    board.push(move)
                    new_fen = board.fen()
                    simplified_new_fen = simplify_fen_string(new_fen)
                    if simplified_new_fen not in AR:
                        N += 1
                        POZ[N] = new_fen
                        AR[simplified_new_fen] = {'depth': 0, 'value': None}
                        new_positions = True
                    board.pop()
        
        if not new_positions:
            break
        
    print(f""Celkov√Ω poƒçet pozic: {N}"")

    # Inicializace koncov√Ωch pozic
    terminal_positions = 0
    for i in range(1, N + 1):
        current_fen = POZ[i]
        board = CustomBoard(current_fen)
        simplified_fen = simplify_fen_string(current_fen)

        if board.is_checkmate():
            AR[simplified_fen]['value'] = -1000 if board.turn == chess.WHITE else 1000
            AR[simplified_fen]['depth'] = min_depth
            terminal_positions += 1
        elif board.is_stalemate() or board.is_insufficient_material() or board.is_seventyfive_moves() or board.is_fivefold_repetition():
            AR[simplified_fen]['value'] = 0
            AR[simplified_fen]['depth'] = min_depth
            terminal_positions += 1

    print(f""Poƒçet koncov√Ωch pozic: {terminal_positions}"")

    max_depth = 0
    while max_depth < min_depth:
        max_depth += 1
        level_start_time = time.time()
        
        changes = False
        positions_evaluated = 0
        for i in range(1, N + 1):
            current_fen = POZ[i]
            board = CustomBoard(current_fen)
            simplified_fen = simplify_fen_string(current_fen)
            if AR[simplified_fen]['depth'] < max_depth and AR[simplified_fen]['value'] is None:
                positions_evaluated += 1
                best_value = -2000 if board.turn == chess.WHITE else 2000
                all_moves_evaluated = True
                legal_moves = list(board.legal_moves)
                for move in legal_moves:
                    board.push(move)
                    next_fen = board.fen()
                    simplified_next_fen = simplify_fen_string(next_fen)
                    if simplified_next_fen not in AR:
                        all_moves_evaluated = False
                        break
                    next_value = AR[simplified_next_fen]['value']
                    if next_value is None:
                        all_moves_evaluated = False
                        break
                    if board.turn == chess.WHITE:
                        best_value = max(best_value, -next_value)
                    else:
                        best_value = min(best_value, -next_value)
                    board.pop()
                
                if all_moves_evaluated:
                    AR[simplified_fen]['value'] = best_value
                    AR[simplified_fen]['depth'] = max_depth
                    changes = True

        level_end_time = time.time()
        level_elapsed_time = level_end_time - level_start_time
        total_time += level_elapsed_time
        
        formatted_total_time = format_time(total_time)
        formatted_level_time = format_time(level_elapsed_time)
        
        print(f""Hloubka {max_depth} dokonƒçena"")
        print(f""Pozice vyhodnoceny: {positions_evaluated}"")
        print(f""Zmƒõny provedeny: {'Ano' if changes else 'Ne'}"")
        print(f""ƒåas: {formatted_total_time} / {formatted_level_time}"")

    print(f""Anal√Ωza dokonƒçena do hloubky {max_depth}"")
    print(f""Celkov√Ω ƒças: {format_time(total_time)}"")

    current_fen = start_fen
    optimal_moves = []
    while True:
        board = CustomBoard(current_fen)
        simplified_fen = simplify_fen_string(current_fen)
        if simplified_fen not in AR:
            break
        current_value = AR[simplified_fen]['value']
        
        if current_value in [-1000, 0, 1000] or current_value is None:
            break
        
        best_move = None
        for move in board.legal_moves:
            board.push(move)
            next_fen = board.fen()
            simplified_next_fen = simplify_fen_string(next_fen)
            if simplified_next_fen not in AR:
                continue
            next_value = AR[simplified_next_fen]['value']
            if next_value is not None and next_value == -current_value:
                best_move = move
                break
            board.pop()
        
        if best_move is None:
            break
        
        optimal_moves.append((current_fen, best_move))
        board.push(best_move)
        current_fen = board.fen()

    print(""\nOptim√°ln√≠ tahy:"")
    for fen, move in optimal_moves:
        board = CustomBoard(fen)
        print(f""{board.fullmove_number}. {'B√≠l√Ω' if board.turn == chess.WHITE else 'ƒåern√Ω'}: {move}"")

    print(""\nKoneƒçn√° pozice:"")
    print(f""FEN: {current_fen}"")

if __name__ == ""__main__"":
    start_fen = ""1b6/3k4/8/8/8/8/8/6K1 b - - 0 1""
    
    try:
        print(f""Creating board with FEN: {start_fen}"")
        initial_board = CustomBoard(start_fen)
        
        print(""Debugging amazons..."")
        print(f""Amazons bitboard: {initial_board.amazons:064b}"")
        print(f""Bishops bitboard: {initial_board.bishops:064b}"")
        
        
        print(""Piece positions:"")
        for square in chess.SQUARES:
            piece = initial_board.piece_at(square)
            if piece:
                print(f""{chess.SQUARE_NAMES[square]}: {initial_board.piece_symbol(piece)}"")
        
        print(""Generating legal moves for initial position..."")
        legal_moves = list(initial_board.legal_moves)
        print(f""Number of legal moves: {len(legal_moves)}"")
        
        print(""Legal moves:"")
        for move in legal_moves:
            from_square = chess.SQUARE_NAMES[move.from_square]
            to_square = chess.SQUARE_NAMES[move.to_square]
            piece = initial_board.piece_at(move.from_square)
            print(f""{initial_board.piece_symbol(piece)}: {from_square}-{to_square}"")
        
        analyze_positions(start_fen, min_depth=5)
    except Exception as e:
        print(f""An error occurred: {str(e)}"")
        traceback.print_exc()"
AaaLyCmB,LEMP 04.07.2024,lumiere1,Bash,Thursday 4th of July 2024 01:53:24 PM CDT,"# –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º MySQL 8.1
su -
apt update -y
apt install -y gnupg debconf

wget https://repo.mysql.com/RPM-GPG-KEY-mysql-2023
apt-key add RPM-GPG-KEY-mysql-2023

wget https://dev.mysql.com/get/mysql-apt-config_0.8.18-1_all.deb
echo ""mysql-apt-config mysql-apt-config/select-server select mysql-8.0"" | debconf-set-selections
dpkg-reconfigure -f noninteractive mysql-apt-config
dpkg -i mysql-apt-config_0.8.18-1_all.deb

echo ""mysql-community-server mysql-community-server/root-pass password 123321"" | debconf-set-selections
echo ""mysql-community-server mysql-community-server/re-root-pass password 123321"" | debconf-set-selections
echo ""mysql-community-server mysql-community-server/data-dir select '/data/'"" | debconf-set-selections

mkdir /data

export DEBIAN_FRONTEND=noninteractive

apt update -y

apt install -y mysql-server


# PHP 8.1 (–í–ª–∞–¥–µ–ª–µ—Ü sury.org –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π —Å —Ä–æ—Å—Å–∏–π—Å–∫–∏—Ö ip, –∏—Å–ø–æ–ª—å–∑—É–π VPN, –ª–∏–±–æ –ª–æ–∫–∞–ª—å–Ω–æ–µ –∫–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω–æ–µ –∑–µ—Ä–∫–∞–ª–æ)

apt install -y lsb-release ca-certificates apt-transport-https software-properties-common gnupg2

echo ""deb https://packages.sury.org/php/ $(lsb_release -sc) main"" | tee /etc/apt/sources.list.d/sury-php.list

wget https://packages.sury.org/php/apt.gpg -O /usr/share/keyrings/deb.sury.org-php.gpg
echo ""deb [signed-by=/usr/share/keyrings/deb.sury.org-php.gpg] https://packages.sury.org/php/ $(lsb_release -sc) main"" > /etc/apt/sources.list.d/php-sury.list

chmod 644 /etc/apt/trusted.gpg.d/apt.gpg

apt update -y

apt install -y php8.1
apt install php8.0-mysql


# Nginx (—Å–æ–±–∏—Ä–∞–µ–º –∏–∑ –∏—Å—Ö–æ–¥–Ω–∏–∫–æ–≤ —Å –∂–µ–ª–∞–µ–º—ã–º–∏ –º–æ–¥—É–ª—è–º–∏ –∏ —Å–æ–∑–¥–∞–µ–º —Ñ–∞–π–ª –¥–ª—è —Å–∏—Å—Ç–µ–º—ã –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏)

apt update && \
    apt install -y --no-install-recommends \
        build-essential \
        libpcre3 \
        libpcre3-dev \
        zlib1g-dev \
        libssl-dev \
        unzip \
        wget \
        curl \
        ca-certificates \
        apache2-utils \
        && rm -rf /var/lib/apt/lists/*

mkdir -p /var/lib/nginx/body /var/lib/nginx/proxy /var/lib/nginx/fastcgi

wget http://nginx.org/download/nginx-1.18.0.tar.gz && \
    tar -xvf nginx-1.18.0.tar.gz && \
    cd nginx-1.18.0 && \
    ./configure \
        --sbin-path=/usr/sbin \
        --conf-path=/etc/nginx/nginx.conf \
        --error-log-path=/var/log/nginx/error.log \
        --pid-path=/var/run/nginx.pid \
        --lock-path=/var/lock/nginx.lock \
        --http-log-path=/var/log/nginx/access.log \
        --http-client-body-temp-path=/var/lib/nginx/body \
        --http-proxy-temp-path=/var/lib/nginx/proxy \
        --http-fastcgi-temp-path=/var/lib/nginx/fastcgi \
        --with-http_stub_status_module \
        --with-http_v2_module \
        --with-http_dav_module && \
    make && \
    make install

echo ""[Unit]
Description=The NGINX HTTP and reverse proxy server
After=syslog.target network.target remote-fs.target nss-lookup.target

[Service]
Type=forking
PIDFile=/var/run/nginx.pid
ExecStartPre=/usr/sbin/nginx -t
ExecStart=/usr/sbin/nginx
ExecReload=/bin/kill -s HUP $MAINPID
ExecStop=/bin/kill -s QUIT $MAINPID
PrivateTmp=true

[Install]
WantedBy=multi-user.target"" > /etc/systemd/system/nginx.service

systemctl daemon-reload
systemctl enable nginx.service
systemctl start nginx.service


# nodejs 18 + 16

useradd -m newuser -s /bin/bash && echo 'newuser:123321' | chpasswd
su - newuser
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash

export NVM_DIR=""$HOME/.nvm""
[ -s ""$NVM_DIR/nvm.sh"" ] && \. ""$NVM_DIR/nvm.sh""
[ -s ""$NVM_DIR/bash_completion"" ] && \. ""$NVM_DIR/bash_completion""
source ~/.bashrc
nvm install 16
nvm install 18
nvm use 18"
pu3Fmej9,Echo Show v2,fredrik_persson_,YAML,Thursday 4th of July 2024 01:50:56 PM CDT,"type: custom:button-card
entity: input_boolean.dummy_light1
tap_action:
  action: toggle
show_name: false
styles:
  grid:
    - grid-template-areas: '""weather alarm"" ""clock clock"" ""date date""'
    - grid-template-rows: min-content 1fr min-content
    - grid-template-columns: 1fr 1fr
    - row-gap: .25rem
  card:
    - height: 100%
    - padding: 1.5rem
    - background: center / cover no-repeat url(/local/images/album-art.jpg)
    - overflow: hidden
  custom_fields:
    filter1:
      - position: absolute
      - height: 150%
      - width: 150%
      - backdrop-filter: brightness(50%)
      - overflow: hidden
      - z-index: 1
    filter2:
      - position: absolute
      - height: 150%
      - width: 150%
      - overflow: hidden
      - z-index: 3
    weather:
      - justify-self: start
      - z-index: 2
    alarm:
      - justify-self: end
      - z-index: 2
    clock:
      - color: white
      - justify-self: center
      - align-self: center
      - z-index: 2
    date:
      - justify-self: center
      - align-self: center
      - z-index: 2
    assistant:
      - position: absolute
      - justify-self: center
      - z-index: 4
state:
  - value: 'on'
    styles:
      custom_fields:
        filter2:
          - animation: brightness_down .5s ease-in-out forwards
        assistant:
          - animation: slide_up .5s ease-in-out forwards
  - value: 'off'
    styles:
      custom_fields:
        filter2:
          - animation: brightness_up .5s ease-in-out forwards
        assistant:
          - animation: opacity .5s ease-in-out forwards
extra_styles: |
  @keyframes slide_up {
    0% {
      bottom: 5%;
      opacity: 0;
    }
    100% {
      bottom: 50%;
    }
  }
  @keyframes opacity {
    0% {
      opacity: 1;
    }
    100% {
      opacity: 0;
    }
  }
  @keyframes brightness_down {
    0% {
      backdrop-filter: brightness(100%);
    }
    100% {
      backdrop-filter: brightness(50%);
    }
  }

  @keyframes brightness_up {
    0% {
      backdrop-filter: brightness(50%);
    }
    100% {
      backdrop-filter: brightness(100%);
    }
  }
custom_fields:
  filter1: .
  weather:
    card:
      type: custom:button-card
      show_name: true
      show_icon: true
      icon: fas:sun
      name: |
        [[[
          return states[""weather.home""].attributes.temperature + ' ¬∞C'
        ]]]
      styles:
        grid:
          - grid-template-areas: '""i n""'
          - grid-template-columns: 1fr min-content
          - column-gap: .5rem
        card:
          - height: 100%
          - padding: 0
          - background: none
        name:
          - color: white
          - justify-self: center
          - align-self: center
          - font-size: 1.75rem
          - font-weight: 600
        img_cell:
          - justify-self: start
          - align-self: center
          - width: 1.25rem
          - height: 1.25rem
        icon:
          - width: 100%
          - color: white
  alarm:
    card:
      type: custom:button-card
      show_name: true
      show_icon: true
      icon: fas:clock
      name: 6:00 AM
      styles:
        grid:
          - grid-template-areas: '""i n""'
          - grid-template-columns: 1fr min-content
          - column-gap: .5rem
        card:
          - height: 100%
          - padding: 0
          - background: none
        name:
          - color: white
          - justify-self: center
          - align-self: center
          - font-size: 1.75rem
          - font-weight: 600
        img_cell:
          - justify-self: start
          - align-self: center
          - width: 1.25rem
          - height: 1.25rem
        icon:
          - width: 100%
          - color: white
  clock:
    card:
      type: custom:button-card
      show_name: true
      name: '[[[ return states[""sensor.time""].state ]]]'
      styles:
        card:
          - height: 100%
          - padding: .25rem 0
          - background: none
        name:
          - color: white
          - justify-self: center
          - align-self: center
          - font-size: 7.75rem
          - font-weight: 600
  date:
    card:
      type: custom:button-card
      show_name: true
      name: |
        [[[
          const options = { weekday: ""long"", month: ""short"", day: ""numeric"", };
          return new Date().toLocaleDateString([], options)
        ]]]  
      styles:
        card:
          - padding: 0
          - background: none
        name:
          - color: white
          - justify-self: center
          - align-self: center
          - font-size: 1.75rem
          - font-weight: 600
  filter2: .
  assistant:
    card:
      type: custom:button-card
      entity: input_boolean.dummy_light1
      name: What can I do for you?
      show_icon: false
      tap_action:
        action: none
      styles:
        card:
          - height: .25rem
          - width: 4rem
          - border-radius: 500px
          - padding: 0
          - background: white
          - transform: translate(0%, 50%)
        name:
          - opacity: 0
      state:
        - value: 'on'
          styles:
            card:
              - animation: expand .5s ease-in-out forwards
              - animation-delay: .75s
            name:
              - animation: opacity .75s ease-in-out forwards
              - animation-delay: 1s
      extra_styles: |
        @keyframes expand {
          0%{
            height: .25rem;
            width: 4rem;

          }
          100% {
            height: 3.25rem;
            width: 16rem;
          }
        }
        @keyframes opacity {
          0%{
            opacity: 0;
          }
          100% {
            opacity: 1;
          }
        }
"
6mMNV3zy,bigboy snowybot,coinwalk,JavaScript,Thursday 4th of July 2024 01:24:02 PM CDT,"var nion = parseFloat(document.getElementById('pct_balance').value);
var smartz = parseFloat(document.getElementById('pct_balance').value);
var prefit = Number((nion/400).toFixed(8));
var winnerdinner = parseFloat(document.getElementById('pct_balance').value);
var tens = (prefit*10);
var sevens = (prefit*6.99);
var eights = (prefit*7.99);
var james = parseFloat(document.getElementById('pct_balance').value);
var belance = parseFloat(document.getElementById('pct_balance').value);
var snowy = 0;
var beast = prefit;
var greedy =  parseFloat(document.getElementById('pct_balance').value);
var bolance = parseFloat(document.getElementById('pct_balance').value);
var golum = parseFloat(document.getElementById('pct_balance').value);
var snow = parseFloat(document.getElementById('pct_balance').value);



function go(){ 
bolance = parseFloat(document.getElementById('pct_balance').value);
if (bolance<snow){
belance = belance-beast;
snow = parseFloat(bolance);
}
if (bolance>snow){
belance = belance+beast;
snow = parseFloat(bolance);
}
if ((belance>(((Math.floor(belance/tens))*tens)+sevens))&&(belance<(((Math.floor(belance/tens))*tens)+eights))&&(belance!=snowy)){
        beast = beast*2;
        snowy = parseFloat(belance);
}
if ((((nion*0.04)-beast)<=0)&&(belance>=(nion+(nion*0.08)))&&(belance<(((Math.floor(belance/tens))*tens)+sevens))){
snowy = 0;
nion = parseFloat(belance);
prefit = Number((belance/400).toFixed(8));
tens = (prefit*10);
sevens = (prefit*6.99);
eights = (prefit*7.99);
beast = prefit;
}
if ((((belance*0.02)-beast)<=0)&&(belance<=nion)){
snowy = 0;
nion = parseFloat(belance);
beast = prefit;;
}
if ((((belance*0.04)-beast)<=0)&&(belance>nion)&&(belance<(((Math.floor(belance/tens))*tens)+sevens))){
snowy = 0;
nion = parseFloat(belance);
prefit = Number((belance/400).toFixed(8));
tens = (prefit*10);
sevens = (prefit*6.99);
eights = (prefit*7.99);
beast = prefit;;
}
if ((belance>=(winnerdinner*1.12))&&(belance<(((Math.floor(belance/tens))*tens)+sevens))){
snowy = 0;
nion = parseFloat(belance);
prefit = Number((belance/400).toFixed(8));
tens = (prefit*10);
sevens = (prefit*6.99);
eights = (prefit*7.99);
beast = prefit;;
winnerdinner = parseFloat(belance);
}
if (belance>=1440){
console.log(""winner winner chicken dinner"");
    return;
}
var cat = ((belance-smartz).toFixed(8));
console.log(""profit"");
console.log(cat);
$('#pct_chance').val(49.5);
$('#pct_bet').val(((beast*1).toFixed(8)));
$('#a_lo').click();
setTimeout(() => go(), 10);
}
go(); "
jfQCTFuk,üéÅ G2A.COM FREE GIFT CARD GUIDE JULY 2024 V3üéÅ,BitcoinScript2020,GetText,Thursday 4th of July 2024 12:23:05 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.

This is the most up to date version of this script. Any other one posted will not work!
 
PDF guide here:
https://drive.google.com/file/d/1KMb0fLkKHIC2qdjR4vCSRH9rVSjJVMdX/view

Working as of:
04 > 10 July 2024"
hgjaYbx5,PrinterLib,minecartchris,Lua,Thursday 4th of July 2024 12:18:24 PM CDT,"-- shell.run(""wget http://127.0.0.1:8080/code/printer/printer.lua"")

local lib = {}
local printer
local xp = 1
local yp = 1
local shouldNewPage = false

function lib.init(side)
    printer = peripheral.wrap(side)
    if not printer then return nil end
    return true
end

function lib.setPrinterObject(obj)
    printer = obj
end

function lib.getPrinterObject()
    return printer
end

function lib.setPos(x, y)
    if x ~= nil then
        xp = x
    end
    if y ~= nil then
        yp = y
    end
    printer.setCursorPos(xp, yp)
end

function lib.getPos()
    return printer.getCursorPos()
end

function lib.startPage()
    xp = 1
    yp = 1
    local st = printer.newPage()
    printer.setCursorPos(xp, yp)
    shouldNewPage = false
    return st
end

function lib.endPage()
    printer.endPage()
    shouldNewPage = false
end

function lib.write(text)
    data = tostring(text)
    for i = 1, #data do
        lib.writeChar(data:sub(i, i))
    end
end

function lib.print(text)
    lib.write(text)
    lib.writeChar(""\n"")
end

function lib.printCenter(text)
    data = tostring(text)
    xp = 13-(math.floor(#data/2))
    lib.print(data)
end

-------------------

function lib.writeChar(char)
    if shouldNewPage then
        local st = false
        while st == false do
            st = printer.newPage()
        end
        printer.setCursorPos(1, 1)
        shouldNewPage = false
    end
    printer.setCursorPos(xp, yp)
    if char == ""\n"" then
        xp = 0
        yp = yp + 1
    else
        printer.write(char)
    end
    
    xp = xp + 1
    if xp >= 26 then
        xp = 1
        yp = yp + 1
    end
    if yp >= 22 then
        yp = 1
        shouldNewPage = true
    end
end

return lib"
5CHGESLj,Gambler,minecartchris,Lua,Thursday 4th of July 2024 11:56:20 AM CDT,"sleep(0.25)
modem = peripheral.wrap(""back"")
shell.run(""clear all"")
while not fs.exists(""/disk/money.lua"") do
    sleep(0.75)
    print(""You do not have a card inserted"")
    sleep(2)
    shell.run(""clear all"")
end
print(""Please do not remove your card from the drive during games"")
local money = "" ""
local winner = false
local randnum = 0
local bet = 0
local money2 = fs.open(""/disk/money.lua"", ""r"")
money = money2.readAll()
money2.close()
local h = fs.open(""house.lua"", ""r"")
house = h.readAll()
h.close()
print(""$"",money)
money = tonumber(money)
print(""what is your bet?"")
bet = tonumber(io.read())
print(""what is your guess 1 to 15?"")
userGess = tonumber(io.read()) 
if bet > money then
   print(""You do not have enough funds"")
   sleep(3)
   shell.run(""reboot"") 
end
randnum = tonumber(math.random(0, 14) + 1)
if userGess == randnum then
    winner = true
end
if not winner then
    print(""you lost ;("")
    print(""The correct number was"", randnum)
    money = money - bet
    house = house + bet
    print(""you have $"",money, ""left over"")
end
if winner then
    bet = bet * 2
    money = bet + money
    print(""You win!!!!!"")
    house = house - bet
    print(""You now have $"", money)
end
money2 = fs.open(""/disk/money.lua"", ""w"")
money2.write(money)
money2.close()
h = fs.open(""house.lua"", ""w"")
h.write(house)
h.close()
print(""If removing your card do it now"")
sleep(5)
shell.run(""clear all"")
shell.run(""startup"")"
hf9y1sJy,ÈÇÄÊÇ®‰∏ÄËµ∑ÁúãÔºöËÄÅÁôΩÊïÖ‰∫ã,xiaomianao666,JavaScript,Thursday 4th of July 2024 11:42:56 AM CDT,Êµ∑ÈòîËßÜÁïåËßÑÂàôÂàÜ‰∫´ÔºåÂΩìÂâçÂàÜ‰∫´ÁöÑÊòØÔºö‰∫åÁ∫ßÈ°µÈù¢ËØ¶ÊÉÖÔø•page_detailÔø•ËÄÅÁôΩÊïÖ‰∫ã@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcInRleHRfMVwiLFwibmFtZVwiOlwiQ2xhc3NUYWJcIixcInBhdGhcIjpcIkNsYXNzVGFiXCIsXCJydWxlXCI6XCJ2YXIge1xcbiAgICBRSU5HX1RJVExFLCB0aXRsZSwgdXJsLFxcbiAgICBjbGFzc19uYW1lLCBjbGFzc191cmwsXFxuICAgIGFyZWFfbmFtZSwgYXJlYV91cmwsXFxuICAgIHllYXJfbmFtZSwgeWVhcl91cmwsXFxuICAgIHNvcnRfbmFtZSwgc29ydF91cmxcXG59ID0gJC5pbXBvcnRQYXJhbVxcbmNvbnN0IENsYXNzVGFiID0gZnVuY3Rpb24oY2xhc3NBcnJheSwgcGFyYW1zKSB7XFxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgcGFyYW1zKVxcbiAgICB0aGlzLmFyciA9IGNsYXNzQXJyYXkubWFwKHYgPT4gdGhpcy5pbml0KHYpKVxcbiAgICB0aGlzLnNpZ24gPSAnJCcgKyBRSU5HX1RJVExFICsgJ18nICsgKHRoaXMubmFtZSB8fCAnJykgKyAnXydcXG4gICAgdGhpcy5jb2xvciA9IHRoaXMuY29sb3IgfHwgJyMxMmI2NjgnXFxuICAgIHRoaXMuYm91bmRhcnkgPSB0aGlzLmJvdW5kYXJ5IHx8ICdibGFua19ibG9jaydcXG59XFxuQ2xhc3NUYWIucHJvdG90eXBlID0ge1xcbiAgICBjb25zdHJ1Y3RvcjogQ2xhc3NUYWIsXFxuICAgIGxvYWQoZWwpIHtcXG4gICAgICAgIGxldCBmb2xkZWQgPSB0aGlzLmZvbGQgJiYgZ2V0VmFyKCckZm9sZF8nICsgdGhpcy5zaWduLCAnJylcXG4gICAgICAgIGlmICh0aGlzLmFyci5sZW5ndGggPiAxICYmIHRoaXMuZm9sZCkgZWwucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ0nICsgKGZvbGRlZCA/ICfilrYnIDogJ+KWvCcpLmZvbnRjb2xvcignIzA0OWVmZicpLFxcbiAgICAgICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoc2lnbiwgZm9sZGVkKSA9PiB7XFxuICAgICAgICAgICAgICAgIHB1dFZhcignJGZvbGRfJyArIHNpZ24sIGZvbGRlZCA/ICcnIDogJ1QnKVxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgICAgIH0sIHRoaXMuc2lnbiwgZm9sZGVkKSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxuICAgICAgICB9KVxcbiAgICAgICAgbGV0IGFyciA9IGZvbGRlZCA/IFt0aGlzLmFyclswXV0gOiB0aGlzLmFyclxcbiAgICAgICAgYXJyLmZvckVhY2goKHYpID0+IHtcXG4gICAgICAgICAgICBsZXQgeyBpZCwgY2xhc3NfbmFtZSwgY2xhc3NfdXJsIH0gPSB2LFxcbiAgICAgICAgICAgIHNlbGVjdGVkID0gSlNPTi5zdHJpbmdpZnkodGhpcy5nZXRDbGFzcyhpZCkpXFxuICAgICAgICAgICAgY2xhc3NfbmFtZS5mb3JFYWNoKChuYW1lLCBpKSA9PiB7XFxuICAgICAgICAgICAgICAgIGxldCB1cmwgPSBjbGFzc191cmxbaV0sXFxuICAgICAgICAgICAgICAgICAgICBub3cgPSBKU09OLnN0cmluZ2lmeSh7IG5hbWU6IG5hbWUsIHVybDogdXJsIH0pXFxuICAgICAgICAgICAgICAgIGVsLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHNlbGVjdGVkID09IG5vdyA/ICfigJzigJzigJ3igJ0nICsgbmFtZS5mb250Y29sb3IodGhpcy5jb2xvcikuYm9sZCgpIDogbmFtZSxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogc2VsZWN0ZWQgPT0gbm93ID8gJ2hpa2VyOi8vZW1wdHknIDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoc2lnbiwgaWQsIG5vdykgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1dFZhcihzaWduICsgaWQsIG5vdylcXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLnNpZ24sIGlkLCBub3cpLFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcbiAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgZWwucHVzaCh7IGNvbF90eXBlOiB0aGlzLmJvdW5kYXJ5IH0pXFxuICAgICAgICB9KVxcbiAgICB9LFxcbiAgICBpbml0KGNsYXNzT2JqZWN0KSB7XFxuICAgICAgICBpZiAodHlwZW9mIGNsYXNzT2JqZWN0LmNsYXNzX25hbWUgPT0gJ3N0cmluZycpXFxuICAgICAgICAgICAgY2xhc3NPYmplY3QuY2xhc3NfbmFtZSA9IGNsYXNzT2JqZWN0LmNsYXNzX25hbWUuc3BsaXQoJyYnKVxcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFzc09iamVjdC5jbGFzc191cmwgPT0gJ3N0cmluZycpXFxuICAgICAgICAgICAgY2xhc3NPYmplY3QuY2xhc3NfdXJsID0gY2xhc3NPYmplY3QuY2xhc3NfdXJsLnNwbGl0KCcmJykubWFwKCh2KSA9PiB2LnRyaW0oKSlcXG4gICAgICAgIHJldHVybiBjbGFzc09iamVjdFxcbiAgICB9LFxcbiAgICBwdXNoKGNsYXNzT2JqZWN0KSB7XFxuICAgICAgICB0aGlzLmFyci5wdXNoKHRoaXMuaW5pdChjbGFzc09iamVjdCkpXFxuICAgIH0sXFxuICAgIGdldENsYXNzKGlkKSB7XFxuICAgICAgICBsZXQgZGVmYXVsdENsYXNzID0gdGhpcy5hcnIuZmluZChpdGVtID0+IGl0ZW0uaWQgPT0gaWQpXFxuICAgICAgICBkZWZhdWx0Q2xhc3MgPSBKU09OLnN0cmluZ2lmeShkZWZhdWx0Q2xhc3MgPyB7XFxuICAgICAgICAgICAgbmFtZTogZGVmYXVsdENsYXNzLmNsYXNzX25hbWVbMF0sXFxuICAgICAgICAgICAgdXJsOiBkZWZhdWx0Q2xhc3MuY2xhc3NfdXJsWzBdXFxuICAgICAgICB9IDogeyBuYW1lOiAgJ2Nhbm5vdCBmaW5kIGlkOiAnICsgaWQgKyAnIGluIGNsYXNzVGFiOiAnICsgdGhpcy5zaWduLCB1cmw6ICcnfSlcXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGdldFZhcih0aGlzLnNpZ24gKyBpZCwgZGVmYXVsdENsYXNzKSlcXG4gICAgfSxcXG4gICAgc2V0VXJsKHVybCkge1xcbiAgICAgICAgcmV0dXJuIHVybC5yZXBsYWNlKC9cXFxcJFxcXFx7KFtefV0qKVxcXFx9L2csIChfLCBpZCkgPT4gdGhpcy5nZXRDbGFzcyhpZCkudXJsKVxcbiAgICB9XFxufVxcbi8vIOeUn+aIkOWktOmDqOWIhuexu1xcbmxldCBmeUFsbCA9IHVybC5pbmNsdWRlcygnZnlBbGwnKSxcXG4gICAgdGFiSGVhZGVyID0gW11cXG5pZiAoY2xhc3NfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5Y2xhc3MnLFxcbiAgICBjbGFzc19uYW1lOiBjbGFzc19uYW1lLFxcbiAgICBjbGFzc191cmw6IGNsYXNzX3VybFxcbn0pXFxuaWYgKGFyZWFfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5YXJlYScsXFxuICAgIGNsYXNzX25hbWU6IGFyZWFfbmFtZSxcXG4gICAgY2xhc3NfdXJsOiBhcmVhX3VybFxcbn0pXFxuaWYgKHllYXJfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5eWVhcicsXFxuICAgIGNsYXNzX25hbWU6IHllYXJfbmFtZSxcXG4gICAgY2xhc3NfdXJsOiB5ZWFyX3VybFxcbn0pXFxuaWYgKHNvcnRfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5c29ydCcsXFxuICAgIGNsYXNzX25hbWU6IHNvcnRfbmFtZSxcXG4gICAgY2xhc3NfdXJsOiBzb3J0X3VybFxcbn0pXFxuJC5leHBvcnRzID0ge1xcbiAgICBmeUFsbDogZnlBbGwsXFxuICAgIHRhYkhlYWRlcjogbmV3IENsYXNzVGFiKHRhYkhlYWRlciwgeyBuYW1lOiB0aXRsZSwgZm9sZDogcmVhZEZpbGUoJ3RhYkZvbGQnKSwgfSlcXG59XFxuXCJ9LHtcImNvbF90eXBlXCI6XCJpY29uXzJfcm91bmRcIixcIm5hbWVcIjpcIuiuvue9rlwiLFwicGF0aFwiOlwiQ29uZmlnXCIsXCJydWxlXCI6XCJqczpcXG5hZGRMaXN0ZW5lcignb25DbG9zZScsICdjbGVhck15VmFyKFxcXCJzb3J0RmxhZ1xcXCIpO3JlZnJlc2hQYWdlKCknKVxcbnNldFBhZ2VUaXRsZSgn4pqZIOi9u+WQiOmbhuiuvue9riDimpknKVxcbmNvbnN0IFFJTkdfVElUTEUgPSBnZXRNeVZhcignbXlDb2xsZWN0aW9uJyksXFxuICAgIHVybCA9IGdldE15VmFyKCdyZW1vdGVVcmwnKVxcbmxldCBkYXRhID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZGF0YUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRSwgdHJ1ZSksXFxuICAgIGVsID0gW3tcXG4gICAgICAgIHRpdGxlOiAnPGI+IOa4hemZpOe8k+WtmO+8jOeri+WNs+abtOaWsCA8c21hbGw+IO+8iOWfuuS6jui/nOeoi+S7k+W6k++8jOS4jeimgemikee5geeCueWHu++8iScsXFxuICAgICAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHVybCkgPT4ge1xcbiAgICAgICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly8nKSB8fCB1cmwuc3RhcnRzV2l0aCgnZmlsZTovLycpKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5LuT5bqT5Li65pys5Zyw5paH5Lu277yM5LiN5Lya6L+b6KGM57yT5a2Y77yM5pys5Yqf6IO95Lmf5peg5pWIJ1xcbiAgICAgICAgICAgIGRlbGV0ZUNhY2hlKHVybClcXG4gICAgICAgICAgICBiYWNrKGZhbHNlKVxcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/lt7Lmm7TmlrAnXFxuICAgICAgICB9LCB1cmwpLFxcbiAgICAgICAgaW1nOiAnaGlrZXI6Ly9pbWFnZXMvaWNvbjQnLFxcbiAgICAgICAgY29sX3R5cGU6ICdhdmF0YXInXFxuICAgIH1dLFxcbiAgICB1cGRhdGVJbnRlcnZhbCA9IHJlYWRGaWxlKCd1cGRhdGVJbnRlcnZhbCcpIHx8ICcxJyxcXG4gICAgbmV3V2luZG93ID0gcmVhZEZpbGUoJ25ld1dpbmRvdycpLFxcbiAgICB0YWJGb2xkID0gcmVhZEZpbGUoJ3RhYkZvbGQnKSxcXG4gICAgZGlzYWJsZUN1c3RvbSA9IHJlYWRGaWxlKCdkaXNhYmxlQ3VzdG9tJyksXFxuICAgIGVkaXRNb2RlID0gZGlzYWJsZUN1c3RvbSA/ICflr7zlhaXmtbfpmJQnIDogZ2V0TXlWYXIoJ2VkaXRNb2RlJywgJ+WQr+eUqC/npoHnlKgnKVxcblxcbmVsLnB1c2goe1xcbiAgICB0aXRsZTogJyAg8J+SoSDmm7TmlrDpopHnjoc6ICcgKyAodXBkYXRlSW50ZXJ2YWwgPT0gMCA/ICfmiYvliqgnIDogdXBkYXRlSW50ZXJ2YWwgKyAn5aSpJykgKyAnICAnLFxcbiAgICB1cmw6ICQodXBkYXRlSW50ZXJ2YWwsICfovpPlhaXmm7TmlrDpl7TpmpTvvIjlpKnvvInvvIzkuLow5YiZ5omL5Yqo5pu05pawXFxcXG7mnKzlnLDmlofku7bpk77mjqXml6DmlYgnKS5pbnB1dCgoKSA9PiB7XFxuICAgICAgICBpbnB1dCA9IHBhcnNlSW50KGlucHV0KVxcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihpbnB1dCkpIGlucHV0ID0gMVxcbiAgICAgICAgZWxzZSBpZiAoaW5wdXQgPCAxKSBpbnB1dCA9IDBcXG4gICAgICAgIHNhdmVGaWxlKCd1cGRhdGVJbnRlcnZhbCcsIGlucHV0LnRvU3RyaW5nKCkpXFxuICAgICAgICByZWZyZXNoUGFnZSgpXFxuICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgIH0pLFxcbiAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxufSwge1xcbiAgICB0aXRsZTogJyAg8J+WpSDni6znq4vpppbpobU6ICcgKyAobmV3V2luZG93ID8gJ+aYrycgOiAn5ZCmJykgKyAnICAnLFxcbiAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKG5ld1dpbmRvdykgPT4ge1xcbiAgICAgICAgc2F2ZUZpbGUoJ25ld1dpbmRvdycsIG5ld1dpbmRvdyA/ICcnIDogJ1QnKVxcbiAgICAgICAgcmVmcmVzaFBhZ2UoKVxcbiAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICB9LCBuZXdXaW5kb3cpLFxcbiAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxufSwge1xcbiAgICB0aXRsZTogJyAg8J+SoCDliIbnsbvmipjlj6A6ICcgKyAodGFiRm9sZCA/ICfmmK8nIDogJ+WQpicpICsgJyAgJyxcXG4gICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCh0YWJGb2xkKSA9PiB7XFxuICAgICAgICBzYXZlRmlsZSgndGFiRm9sZCcsIHRhYkZvbGQgPyAnJyA6ICdUJylcXG4gICAgICAgIHJlZnJlc2hQYWdlKClcXG4gICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgfSwgdGFiRm9sZCksXFxuICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXG59LCB7XFxuICAgIHRpdGxlOiAnICDwn5K8IOWkh+S7veaBouWkjSAgJyxcXG4gICAgdXJsOiAkKFsn5aSH5Lu9JywgJ+aBouWkjSddLCAxKS5zZWxlY3QoKFFJTkdfVElUTEUsIHVwZGF0ZUludGVydmFsLCBuZXdXaW5kb3csIHRhYkZvbGQsIGRpc2FibGVDdXN0b20pID0+IHtcXG4gICAgICAgIGxldCB1cmwgPSBnZXRNeVZhcigncmVtb3RlVXJsJylcXG4gICAgICAgIGlmICghdXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vJykgJiYgIXVybC5zdGFydHNXaXRoKCdmaWxlOi8vJykpXFxuICAgICAgICAgICAgdXJsID0gJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJ1xcbiAgICAgICAgZWxzZSBpZiAodXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vcGFnZS8nKSkgdXJsID0gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICBpZiAoaW5wdXQgPT0gJ+Wkh+S7vScpIHJldHVybiAkKCdoaWtlcjovL2ZpbGVzL3RtcC8nICsgUUlOR19USVRMRSArICdfYmFja3VwLmpzb24nLCAn6L6T5YWl5aSH5Lu96Lev5b6EJylcXG4gICAgICAgICAgICAuaW5wdXQoKHVybCwgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSByZXF1ZXN0KHVybCksXFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21EYXRhID0gcmVhZEZpbGUoJ2N1c3RvbURhdGEnKVxcbiAgICAgICAgICAgICAgICB3cml0ZUZpbGUoaW5wdXQsIEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUludGVydmFsOiB1cGRhdGVJbnRlcnZhbCxcXG4gICAgICAgICAgICAgICAgICAgIG5ld1dpbmRvdzogbmV3V2luZG93LFxcbiAgICAgICAgICAgICAgICAgICAgdGFiRm9sZDogdGFiRm9sZCxcXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVDdXN0b206IGRpc2FibGVDdXN0b20sXFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21EYXRhOiBjdXN0b21EYXRhLFxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXM6IHJ1bGVzXFxuICAgICAgICAgICAgICAgIH0pKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bey5aSH5Lu977yM5rOo5oSP6Iul5LuT5bqT5Li65a2Q6aG16Z2i5YiZ5LiN5aSH5Lu9J1xcbiAgICAgICAgICAgIH0sIHVybCwgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSlcXG4gICAgICAgIGVsc2UgcmV0dXJuICQoJ2hpa2VyOi8vZmlsZXMvdG1wLycgKyBRSU5HX1RJVExFICsgJ19iYWNrdXAuanNvbicsICfovpPlhaXlpIfku73ot6/lvoQnKS5pbnB1dCgodXJsKSA9PiB7XFxuICAgICAgICAgICAgbGV0IHsgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSwgY3VzdG9tRGF0YSwgcnVsZXMgfSA9IEpTT04ucGFyc2UocmVxdWVzdChpbnB1dCkpXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ3VwZGF0ZUludGVydmFsJywgdXBkYXRlSW50ZXJ2YWwpXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ25ld1dpbmRvdycsIG5ld1dpbmRvdylcXG4gICAgICAgICAgICBzYXZlRmlsZSgndGFiRm9sZCcsIHRhYkZvbGQpXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ2Rpc2FibGVDdXN0b20nLCBkaXNhYmxlQ3VzdG9tKVxcbiAgICAgICAgICAgIHNhdmVGaWxlKCdjdXN0b21EYXRhJywgY3VzdG9tRGF0YSlcXG4gICAgICAgICAgICBpZiAocnVsZXMpIHdyaXRlRmlsZSh1cmwsIHJ1bGVzKVxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bey5oGi5aSN77yM5aaC5p6c5LiN5oOz5ZCM5q2l6L+c56iL5LuT5bqT77yM5Y+v5Lul6K6+572u5pu05paw6aKR546H5Li65omL5YqoJ1xcbiAgICAgICAgfSwgdXJsKVxcbiAgICB9LCBRSU5HX1RJVExFLCB1cGRhdGVJbnRlcnZhbCwgbmV3V2luZG93LCB0YWJGb2xkLCBkaXNhYmxlQ3VzdG9tKSxcXG4gICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcbn0sIHtcXG4gICAgdGl0bGU6ICfigJzigJzigJ3igJ08Zm9udCBjb2xvcj1cXFwiIzY2NjY2NlxcXCI+PHNtYWxsPueJueWIq+m4o+iwou+8jOWwj+eoi+W6j+aPkOS+m+iAhe+8mlxcXFxuJyArXFxuICAgICAgICBkYXRhLnJlZHVjZSgoc2VsZiwgdikgPT4gdi5hdXRob3IgPyBzZWxmLmNvbmNhdCh2LmF1dGhvci5zcGxpdCgnJicpKSA6IHNlbGYsIFtdKVxcbiAgICAgICAgLmZpbHRlcigodiwgaSwgYXJyKSA9PiB2ICYmIGFyci5pbmRleE9mKHYpID09IGkpLmpvaW4oJ+OAgScpLFxcbiAgICB1cmw6ICdoaWtlcjovL2VtcHR5JyxcXG4gICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJ1xcbn0pXFxuXFxuZWwucHVzaCh7IGNvbF90eXBlOiAnbGluZScgfSwge1xcbiAgICB0aXRsZTogJ+KAnOKAnOKAneKAnScgKyAn8J+TnScuc21hbGwoKSArICcmbmJzcCDovbvlkIjpm4boh6rlrprkuYkgJm5ic3AnLmJvbGQoKS5mb250Y29sb3IoJyM3NTc1NzUnKSArIChkaXNhYmxlQ3VzdG9tID8gJ+KdjCcgOiAn4q2VJykuc21hbGwoKSxcXG4gICAgdXJsOiAkKFsoZGlzYWJsZUN1c3RvbSA/ICflkK/nlKgnIDogJ+emgeeUqCcpICsgJ+WQiOmbhuiHquWumuS5iScsICfmuIXpmaToh6rlrprkuYnmlbDmja4nXSwgMSkuc2VsZWN0KCgpID0+IHtcXG4gICAgICAgIGlmIChpbnB1dCA9PSAn5riF6Zmk6Ieq5a6a5LmJ5pWw5o2uJykge1xcbiAgICAgICAgICAgIGRlbGV0ZUZpbGUoJ2N1c3RvbURhdGEnKVxcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PSAn5ZCv55So5ZCI6ZuG6Ieq5a6a5LmJJykge1xcbiAgICAgICAgICAgIHNhdmVGaWxlKCdkaXNhYmxlQ3VzdG9tJywgJycpXFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHNhdmVGaWxlKCdkaXNhYmxlQ3VzdG9tJywgJ1QnKVxcbiAgICAgICAgICAgIGlucHV0ICs9ICdcXFxcbuWwj+eoi+W6j+WQr+eUqC/npoHnlKjjgIHph43mlrDmjpLluo/nrYnmk43kvZzlnYfkuI3kvJrkvZPnjrDlnKjpppbpobXlsI/nqIvluo/liJfooajkuK0nXFxuICAgICAgICB9XFxuICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgIHJldHVybiAndG9hc3Q6Ly/lt7InICsgaW5wdXRcXG4gICAgfSksXFxuICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxuICAgIGV4dHJhOiB7IGxpbmVWaXNpYmxlOiBmYWxzZSB9XFxufSk7XFxuKGRpc2FibGVDdXN0b20gPyBbJ+WvvOWFpea1t+mYlCddIDogWyflkK/nlKgv56aB55SoJywgJ+mHjeaWsOaOkuW6jycsICfmm7TmlLnlm77moIcnLCAn5a+85YWl5rW36ZiUJ10pLmZvckVhY2goKHYpID0+IHtcXG4gICAgZWwucHVzaCh7XFxuICAgICAgICB0aXRsZTogdiA9PSBlZGl0TW9kZSA/ICfigJzigJzigJ3igJ0nICsgdi5ib2xkKCkuZm9udGNvbG9yKCcjMTJiNjY4JykgOiB2LFxcbiAgICAgICAgdXJsOiB2ID09IGVkaXRNb2RlID8gJ2hpa2VyOi8vZW1wdHknIDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgodikgPT4ge1xcbiAgICAgICAgICAgIHB1dE15VmFyKCdlZGl0TW9kZScsIHYpXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxuICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgfSwgdiksXFxuICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxuICAgIH0pXFxufSk7XFxuaWYgKGVkaXRNb2RlID09ICflr7zlhaXmtbfpmJQnKSBlbC5wdXNoKHtcXG4gICAgdGl0bGU6ICflhajpg6jlr7zlhaUnLFxcbiAgICB1cmw6ICfmtbfpmJTop4bnlYzvv6Vob21lX3J1bGVfdXJs77+lJyArICh1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly8nKSB8fCB1cmwuc3RhcnRzV2l0aCgnZmlsZTovLycpID8gdXJsIDogJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJyksXFxuICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxuICAgIGV4dHJhOiB7IGxpbmVWaXNpYmxlOiBmYWxzZSB9XFxufSk7XFxuKGRpc2FibGVDdXN0b20gPyBkYXRhIDogSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpKS5mb3JFYWNoKCh2LCBpKSA9PiB7XFxuICAgIGxldCBkID0geyB0aXRsZTogdi50aXRsZSwgaW1nOiBkYXRhW2ldLmljb24gfVxcbiAgICBzd2l0Y2ggKGVkaXRNb2RlKSB7XFxuICAgICAgICBjYXNlICflkK/nlKgv56aB55SoJzpcXG4gICAgICAgICAgICBkLnRpdGxlID0gKHYudmlzaWJsZSA/ICfwn5+iICAnIDogJ/CflLQgICcpICsgZC50aXRsZVxcbiAgICAgICAgICAgIGQudXJsID0gJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoaSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJylcXG4gICAgICAgICAgICAgICAgcnVsZXNbaV0udmlzaWJsZSA9ICFydWxlc1tpXS52aXNpYmxlXFxuICAgICAgICAgICAgICAgIHNhdmVGaWxlKCdjdXN0b21EYXRhJywgSlNPTi5zdHJpbmdpZnkocnVsZXMpKVxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgICAgIH0sIGkpXFxuICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgIGNhc2UgJ+mHjeaWsOaOkuW6jyc6XFxuICAgICAgICAgICAgbGV0IHNvcnRGbGFnID0gcGFyc2VJbnQoZ2V0TXlWYXIoJ3NvcnRGbGFnJywgJy0xJykpXFxuICAgICAgICAgICAgZC50aXRsZSA9IChzb3J0RmxhZyA9PSBpID8gJ/CflIMgICcgOiAnJykgKyBkLnRpdGxlXFxuICAgICAgICAgICAgaWYgKHNvcnRGbGFnID09IC0xKVxcbiAgICAgICAgICAgICAgICBkLnVybCA9ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGkpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKCdzb3J0RmxhZycsIGkudG9TdHJpbmcoKSlcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+mAieaLqeimgeenu+WKqOWIsOeahOS9jee9ridcXG4gICAgICAgICAgICAgICAgfSwgaSlcXG4gICAgICAgICAgICBlbHNlXFxuICAgICAgICAgICAgICAgIGQudXJsID0gJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgob2xkSW5kZXgsIG5ld0luZGV4KSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJylcXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzLnNwbGljZShuZXdJbmRleCwgMCwgcnVsZXMuc3BsaWNlKG9sZEluZGV4LCAxKVswXSlcXG4gICAgICAgICAgICAgICAgICAgIHNhdmVGaWxlKCdjdXN0b21EYXRhJywgSlNPTi5zdHJpbmdpZnkocnVsZXMpKVxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoJ3NvcnRGbGFnJywgJy0xJylcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgICAgICAgICB9LCBzb3J0RmxhZywgaSlcXG4gICAgICAgICAgICBicmVha1xcbiAgICAgICAgY2FzZSAn5pu05pS55Zu+5qCHJzpcXG4gICAgICAgICAgICBkLnVybCA9ICQodi5pY29uIHx8ICcnLCAn6L6T5YWl5paw5Zu+5qCH5Zyw5Z2A5oiW6aKc6Imy5Luj56CB77yaJykuaW5wdXQoKGkpID0+IHtcXG4gICAgICAgICAgICAgICAgbGV0IHJ1bGVzID0gSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpXFxuICAgICAgICAgICAgICAgIGlmIChpbnB1dClcXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzW2ldLmljb24gPSBpbnB1dFxcbiAgICAgICAgICAgICAgICBlbHNlXFxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcnVsZXNbaV0uaWNvblxcbiAgICAgICAgICAgICAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KHJ1bGVzKSlcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgICAgICAgICB9LCBpKVxcbiAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICBjYXNlICflr7zlhaXmtbfpmJQnOlxcbiAgICAgICAgICAgIGQudXJsID0gJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoaSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2RhdGFMb2FkP3J1bGU9JyArIGdldE15VmFyKCdteUNvbGxlY3Rpb24nKSwgdHJ1ZSlcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdydWxlOi8vJyArIGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShkYXRhW2ldKSlcXG4gICAgICAgICAgICB9LCBpKVxcbiAgICAgICAgICAgIGJyZWFrXFxuICAgIH1cXG4gICAgZWwucHVzaChkKVxcbn0pXFxuc2V0UmVzdWx0KGVsKVxcblwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi6aG16Z2i6L295YWlXCIsXCJwYXRoXCI6XCJmcmFtZUxvYWRcIixcInJ1bGVcIjpcImpzOlxcbmNvbnN0IFFJTkdfVElUTEUgPSBnZXRNeVZhcignbXlDb2xsZWN0aW9uJylcXG52YXIgbXlDb2xsX2VsID0gW11cXG5ldmFsKEpTT04ucGFyc2UoZmV0Y2goJ2hpa2VyOi8vcGFnZS9oaWphY2tFbnY/cnVsZT0nICsgUUlOR19USVRMRSkpLnJ1bGUpXFxuXFxuaWYgKCFpc0luZGV4KSB7XFxuICAgIGlmIChwYWdlVGl0bGUpIHNldFBhZ2VUaXRsZShwYWdlVGl0bGUpXFxuICAgIHNldExhc3RDaGFwdGVyUnVsZShvcmlSVUxFLmxhc3RfY2hhcHRlcl9ydWxlKVxcbiAgICBNWV9QQVJBTVMgPSBNWV9SVUxFLnBhcmFtc1xcbn0gZWxzZSBpZiAoTVlfUEFHRSA9PSAxKSB7XFxuICAgIHRhYkhlYWRlci5sb2FkKG15Q29sbF9lbClcXG4gICAgaWYgKFJVTEUuc2VhcmNoX3VybCkgbXlDb2xsX2VsLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLmkJzntKJcXFwiLFxcbiAgICAgICAgZGVzYzogXFxcIui/meaYr+i9u+WQiOmbhueahOaQnOe0ouWTpn5+XFxcIixcXG4gICAgICAgIHVybDogJ1xcXCJoaWtlcjovL3NlYXJjaD9zPVxcXCIraW5wdXQnLFxcbiAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICBydWxlczogJC50b1N0cmluZygoUUlOR19USVRMRSwgdGl0bGUpID0+IHtcXG4gICAgICAgICAgICAgICAgbGV0IHJ1bGVzID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZGF0YUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRSlcXG4gICAgICAgICAgICAgICAgcnVsZXMgPSBbcnVsZXMuZmluZCgodikgPT4gdi50aXRsZSA9PSB0aXRsZSldXFxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShydWxlcylcXG4gICAgICAgICAgICB9LCBRSU5HX1RJVExFLCBSVUxFLnRpdGxlKSxcXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGdldE15VmFyKCdzZWFyY2hLZXknLCAnJyksXFxuICAgICAgICAgICAgb25DaGFuZ2U6IFxcXCJwdXRNeVZhcignc2VhcmNoS2V5JyxpbnB1dClcXFwiXFxuICAgICAgICB9LFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJpbnB1dFxcXCIsXFxuICAgIH0pXFxufVxcbi8vIOato+aWh+ino+aekFxcbnZhciB7XFxuICAgIHBhcmFtSGFuZGxlLFxcbiAgICBydW5QcmVSdWxlLFxcbiAgICBnZW5FeFVybCxcXG4gICAgaGlqYWNrTGF6eVJ1bGVcXG59ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZnVuY1Rvb2xzP3J1bGU9JyArIFFJTkdfVElUTEUpXFxucnVuUHJlUnVsZShvcmlSVUxFLnByZVJ1bGUpXFxuaWYgKE1ZX1JVTEUuZmluZF9ydWxlLnN0YXJ0c1dpdGgoJ2pzOicpKSB7XFxuICAgIGxldCB7IGhpamFja0VsIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9mdW5jVG9vbHM/cnVsZT0nICsgUUlOR19USVRMRSlcXG4gICAgc2V0UmVzdWx0ID0gZnVuY3Rpb24ocGFyYW0wLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zKSB7XFxuICAgICAgICBwYXJhbTEgPSBDQUxMQkFDS19LRVlcXG4gICAgICAgIHBhcmFtMiA9IE1ZX1JVTEVcXG4gICAgICAgIHBhcmFtMyA9IE1ZX1RZUEVcXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtMC5kYXRhKSkgcGFyYW0wID0gcGFyYW0wLmRhdGFcXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG15Q29sbF9lbCwgcGFyYW0wLm1hcChoaWphY2tFbCkpXFxuICAgICAgICBtZXRob2Rfc2V0UmVzdWx0Lmludm9rZShqYXZhQ29udGV4dCwgbXlDb2xsX2VsLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zKVxcbiAgICB9XFxuICAgIHNldEhvbWVSZXN1bHQgPSBzZXRSZXN1bHRcXG4gICAgc2V0U2VhcmNoUmVzdWx0ID0gc2V0UmVzdWx0XFxuXFxuICAgIGV2YWwoTVlfUlVMRS5maW5kX3J1bGUuc2xpY2UoMykpXFxufSBlbHNlIHtcXG4gICAgbGV0IHsgcnVuQ29kZSB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZnVuY1Rvb2xzP3J1bGU9JyArIFFJTkdfVElUTEUpLFxcbiAgICAgICAgW18sIGZpbmRSdWxlLCBkZXRhaWxGaW5kUnVsZV0gPSBNWV9SVUxFLmZpbmRfcnVsZS5tYXRjaCgvXihbXFxcXHNcXFxcU10qPykoPzo9PT4oW1xcXFxzXFxcXFNdKikpPyQvKVxcbiAgICBmaW5kUnVsZSA9IGZpbmRSdWxlLnNwbGl0KCc7JylcXG4gICAgcGFyc2VEb21Gb3JBcnJheShnZXRSZXNDb2RlKCksIGZpbmRSdWxlLnNoaWZ0KCkpLmZvckVhY2goKGRhdGEpID0+IHtcXG4gICAgICAgIGxldCBbdGl0bGUsIGltZywgZGVzYywgdXJsXSA9IGZpbmRSdWxlLm1hcCgodiwgaSkgPT4ge1xcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgPT0gJyonKSByZXR1cm4gJydcXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgdiA9IChpID09IDEgfHwgaSA9PSAzKSA/XFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VEb20oZGF0YSwgdikgOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRG9tRm9ySHRtbChkYXRhLCB2KVxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT0gMykgdiA9IHJ1bkNvZGUodilcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2XFxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgcmV0dXJuICcnIH1cXG4gICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICByZXMgPSB7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSwgdXJsOiB1cmwsXFxuICAgICAgICAgICAgICAgIGRlc2M6IGRlc2MsIGltZzogaW1nLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogTVlfUlVMRS5jb2xfdHlwZVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIGlmIChyZXMudXJsKSB7XFxuICAgICAgICAgICAgaWYgKHJlcy51cmwuaW5jbHVkZXMoJ0BsYXp5UnVsZT0nKSkge1xcbiAgICAgICAgICAgICAgICBsZXQgcmVJbmRleCA9IHJlcy51cmwuaW5kZXhPZignLmpzOicpXFxuICAgICAgICAgICAgICAgIGlmIChyZUluZGV4ID49IDApIHJlcy51cmwgPSByZXMudXJsLnNsaWNlKDAsIHJlSW5kZXgpICsgJy5qczonICsgaGlqYWNrTGF6eVJ1bGUgKyAnOycgKyByZXMudXJsLnNsaWNlKHJlSW5kZXggKyA0KVxcbiAgICAgICAgICAgIH0gZWxzZSAgaWYgKGRldGFpbEZpbmRSdWxlKSB7XFxuICAgICAgICAgICAgICAgIHJlcy5leHRyYSA9IHtcXG4gICAgICAgICAgICAgICAgICAgIHVybDogZ2VuRXhVcmwodXJsKSxcXG4gICAgICAgICAgICAgICAgICAgIFJVTEU6IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKGdlbk15UnVsZSgpLCB7IGRldGFpbF9maW5kX3J1bGU6IGRldGFpbEZpbmRSdWxlIH0pKSksXFxuICAgICAgICAgICAgICAgICAgICBwYWdlVGl0bGU6IGlzSW5kZXggJiYgdGl0bGVcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXMudXJsID0gJ2hpa2VyOi8vcGFnZS9mcmFtZUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRVxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTVlfUlVMRS5kZXRhaWxfZmluZF9ydWxlKSB7XFxuICAgICAgICAgICAgICAgIHJlcy5leHRyYSA9IHtcXG4gICAgICAgICAgICAgICAgICAgIHVybDogZ2VuRXhVcmwodXJsKSxcXG4gICAgICAgICAgICAgICAgICAgIFJVTEU6IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShnZW5NeVJ1bGUoKSkpLFxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVRpdGxlOiBpc0luZGV4ICYmIHRpdGxlXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcmVzLnVybCA9ICdoaWtlcjovL3BhZ2UvZnJhbWVMb2FkP3J1bGU9JyArIFFJTkdfVElUTEVcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBteUNvbGxfZWwucHVzaChyZXMpXFxuICAgIH0pXFxuICAgIHNldFJlc3VsdChteUNvbGxfZWwpXFxufVxcblwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi5pWw5o2u6L295YWlXCIsXCJwYXRoXCI6XCJkYXRhTG9hZFwiLFwicnVsZVwiOlwibGV0IHNob3dBbGwgPSAkLmltcG9ydFBhcmFtLFxcbiAgICB1cmwgPSBnZXRNeVZhcigncmVtb3RlVXJsJyksXFxuICAgIGRhdGEgPSBbXVxcbmlmICh1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly8nKSB8fCB1cmwuc3RhcnRzV2l0aCgnZmlsZTovLycpKSB7XFxuICAgIC8vIOWmguaenOS4uuacrOWcsOaWh+S7tuWImeS4jei/m+ihjOe8k+WtmFxcbiAgICB0cnkge1xcbiAgICAgICAgbGV0IG9yaURhdGEgPSBmZXRjaCh1cmwpXFxuICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vcGFnZS8nKSlcXG4gICAgICAgICAgICBvcmlEYXRhID0gSlNPTi5wYXJzZShvcmlEYXRhKS5ydWxlXFxuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShvcmlEYXRhKVxcbiAgICB9IGNhdGNoIChlKSB7fVxcbn0gZWxzZSB7XFxuICAgIC8vIOiOt+WPlui/nOeoi+aVsOaNru+8jOajgOafpemXtOmalOm7mOiupOS4gOWkqVxcbiAgICBsZXQgaW50ZXJ2YWwgPSBwYXJzZUludChyZWFkRmlsZSgndXBkYXRlSW50ZXJ2YWwnKSB8fCAnMScpLFxcbiAgICAgICAgb2xkRGF0YSA9IGZldGNoKCdoaWtlcjovL2ZpbGVzL2xpYnMvJyArIG1kNSh1cmwpICsgJy5qcycpLFxcbiAgICAgICAgcmVtb3RlRGF0YSA9IFtdXFxuICAgIGlmIChpbnRlcnZhbCA9PSAwKSBpbnRlcnZhbCA9IC0xXFxuICAgIHRyeSB7IHJlbW90ZURhdGEgPSBKU09OLnBhcnNlKGZldGNoQ2FjaGUodXJsLCAyNCAqIGludGVydmFsLCB7IHRpbWVvdXQ6IDUwMDAwIH0pKSB9IGNhdGNoIChlKSB7fVxcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVtb3RlRGF0YSkpIHJlbW90ZURhdGEgPSBbXVxcbiAgICBpZiAocmVtb3RlRGF0YS5sZW5ndGggPCAzKSB7XFxuICAgICAgICBsb2coJ+acquiOt+WPluWIsOaVsOaNricpXFxuICAgICAgICBpZiAob2xkRGF0YSkgd3JpdGVGaWxlKCdoaWtlcjovL2ZpbGVzL2xpYnMvJyArIG1kNSh1cmwpICsgJy5qcycsIG9sZERhdGEpXFxuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShvbGREYXRhIHx8ICdbXScpXFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBsb2coJ+W3suiOt+WPluWIsOaVsOaNricpXFxuICAgICAgICBkYXRhID0gcmVtb3RlRGF0YVxcbiAgICB9XFxufVxcbmRhdGEgPSBkYXRhLmZpbHRlcigodikgPT4gdi50aXRsZSAhPSBnZXRNeVZhcignbXlDb2xsZWN0aW9uJykgJiYgISh2LmF1dGhvciB8fCAnJykuaW5jbHVkZXMoJ+i9u+WQiOmbhueUn+aIkOWZqCcpKVxcbmlmIChyZWFkRmlsZSgnZGlzYWJsZUN1c3RvbScpKSAkLmV4cG9ydHMgPSBkYXRhXFxuZWxzZSB7IC8vIOWGmeWFpeiHquWumuS5ieaVsOaNrlxcbiAgICBsZXQgY3VzdG9tRGF0YSA9IEpTT04ucGFyc2UocmVhZEZpbGUoJ2N1c3RvbURhdGEnKSB8fCAnW10nKSxcXG4gICAgICAgIHJld3JpdGVEYXRhID0gW11cXG4gICAgY3VzdG9tRGF0YSA9IGN1c3RvbURhdGEucmVkdWNlKChzZWxmLCB2KSA9PiB7XFxuICAgICAgICBsZXQgaW5kZXggPSBkYXRhLmZpbmRJbmRleCgodnYpID0+IHYudGl0bGUgPT0gdnYudGl0bGUpXFxuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xcbiAgICAgICAgICAgIHNlbGYucHVzaCh2KVxcbiAgICAgICAgICAgIGxldCBydWxlID0gZGF0YS5zcGxpY2UoaW5kZXgsIDEpWzBdXFxuICAgICAgICAgICAgaWYgKHNob3dBbGwgfHwgdi52aXNpYmxlKVxcbiAgICAgICAgICAgICAgICByZXdyaXRlRGF0YS5wdXNoKE9iamVjdC5hc3NpZ24ocnVsZSwgdikpXFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gc2VsZlxcbiAgICB9LCBbXSlcXG4gICAgZGF0YS5mb3JFYWNoKCh2KSA9PiBjdXN0b21EYXRhLnB1c2goeyB0aXRsZTogdi50aXRsZSwgdmlzaWJsZTogdHJ1ZSB9KSlcXG4gICAgc2F2ZUZpbGUoJ2N1c3RvbURhdGEnLCBKU09OLnN0cmluZ2lmeShjdXN0b21EYXRhKSlcXG4gICAgJC5leHBvcnRzID0gcmV3cml0ZURhdGEuY29uY2F0KGRhdGEpXFxufVxcblwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi546v5aKD5Yqr5oyBXCIsXCJwYXRoXCI6XCJoaWphY2tFbnZcIixcInJ1bGVcIjpcInZhciB7IFJVTEUsIGlzSW5kZXgsIHBhZ2VUaXRsZSB9ID0gTVlfUEFSQU1TXFxuUlVMRSA9IEpTT04ucGFyc2UoYmFzZTY0RGVjb2RlKFJVTEUpKVxcbnZhciBvcmlSVUxFID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZGF0YUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRSkuZmluZCgodikgPT4gdi50aXRsZSA9PSBSVUxFLnRpdGxlKVxcbmlmIChpc0luZGV4KSB7XFxuICAgIFJVTEUgPSBvcmlSVUxFXFxuICAgIHZhciB7IHRhYkhlYWRlciwgZnlBbGwgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL0NsYXNzVGFiP3J1bGU9JyArIFFJTkdfVElUTEUsIE9iamVjdC5hc3NpZ24oeyBRSU5HX1RJVExFOiBRSU5HX1RJVExFIH0sIFJVTEUpKVxcbiAgICAvLyDlpITnkIZNWV9SVUxFXFxuICAgIE1ZX1JVTEUuY2xhc3NfdXJsID0gdGFiSGVhZGVyLmdldENsYXNzKGZ5QWxsID8gJ2Z5QWxsJyA6ICdmeWNsYXNzJykudXJsXFxuICAgIE1ZX1JVTEUuYXJlYV91cmwgPSBmeUFsbCA/IE1ZX1JVTEUuY2xhc3NfdXJsIDogdGFiSGVhZGVyLmdldENsYXNzKCdmeWFyZWEnKS51cmxcXG4gICAgTVlfUlVMRS55ZWFyX3VybCA9IGZ5QWxsID8gTVlfUlVMRS5jbGFzc191cmwgOiB0YWJIZWFkZXIuZ2V0Q2xhc3MoJ2Z5eWVhcicpLnVybFxcbiAgICBNWV9SVUxFLnNvcnRfdXJsID0gZnlBbGwgPyBNWV9SVUxFLmNsYXNzX3VybCA6IHRhYkhlYWRlci5nZXRDbGFzcygnZnlzb3J0JykudXJsXFxuICAgIE1ZX1JVTEUudXJsID0gUlVMRS51cmxcXG4gICAgTVlfUlVMRS5jb2xfdHlwZSA9IFJVTEUuY29sX3R5cGVcXG4gICAgTVlfUlVMRS5kZXRhaWxfY29sX3R5cGUgPSBSVUxFLmRldGFpbF9jb2xfdHlwZVxcbiAgICBNWV9SVUxFLmZpbmRfcnVsZSA9IFJVTEUuZmluZF9ydWxlXFxuICAgIE1ZX1JVTEUuZGV0YWlsX2ZpbmRfcnVsZSA9IFJVTEUuZGV0YWlsX2ZpbmRfcnVsZVxcbiAgICBNWV9SVUxFLnBhcmFtcyA9IHt9XFxufSBlbHNlIHtcXG4gICAgUlVMRS5wYWdlcyA9IG9yaVJVTEUucGFnZXNcXG4gICAgLy8g5aSE55CGTVlfUlVMRVxcbiAgICBNWV9SVUxFLnVybCA9IE1ZX1BBUkFNUy51cmxcXG4gICAgTVlfUlVMRS5jb2xfdHlwZSA9IFJVTEUuZGV0YWlsX2NvbF90eXBlXFxuICAgIE1ZX1JVTEUuZmluZF9ydWxlID0gUlVMRS5kZXRhaWxfZmluZF9ydWxlXFxuICAgIE1ZX1JVTEUucGFyYW1zID0gUlVMRS5wYXJhbXNcXG59XFxuTVlfUlVMRS5wYWdlcyA9IFJVTEUucGFnZXNcXG5NWV9SVUxFLnBhZ2VMaXN0ID0gSlNPTi5wYXJzZShNWV9SVUxFLnBhZ2VzIHx8ICdbXScpXFxuTVlfUlVMRS50aXRsZSA9IFJVTEUudGl0bGVcXG5NWV9SVUxFLnVhID0gUlVMRS51YVxcbi8vIOi9veWFpeWHveaVsOW3peWFt1xcbnZhciB7IGdlbk15UnVsZSB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZnVuY1Rvb2xzP3J1bGU9JyArIFFJTkdfVElUTEUsIHtcXG4gICAgUUlOR19USVRMRTogUUlOR19USVRMRSxcXG4gICAgTVlfUlVMRTogTVlfUlVMRSxcXG4gICAgaXNJbmRleDogaXNJbmRleFxcbn0pXFxuLy8g6Ziy5q2icmVxdWlyZeWkmuasoei/kOihjFxcbmNvbnN0IG15Q29sbF9yZXF1aXJlZCA9IHt9XFxucmVxdWlyZSA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00KSB7XFxuICAgIGlmIChteUNvbGxfcmVxdWlyZWRbcGFyYW0wXSkgcmV0dXJuXFxuICAgIG15Q29sbF9yZXF1aXJlZFtwYXJhbTBdID0gdHJ1ZVxcbiAgICBwYXJhbTIgPSBwYXJhbTIgIT0gbnVsbCA/IHBhcmFtMiA6IDBcXG4gICAgcGFyYW0zID0gTVlfVElDS0VUXFxuICAgIHBhcmFtNCA9IGV2YWxcXG4gICAgcmV0dXJuIG1ldGhvZF9yZXF1aXJlLmludm9rZShqYXZhQ29udGV4dCwgcGFyYW0wLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zLCBwYXJhbTQpXFxufVxcbnJlcXVpcmVDYWNoZSA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00LCBwYXJhbTUpIHtcXG4gICAgaWYgKG15Q29sbF9yZXF1aXJlZFtwYXJhbTBdKSByZXR1cm5cXG4gICAgbXlDb2xsX3JlcXVpcmVkW3BhcmFtMF0gPSB0cnVlXFxuICAgIHBhcmFtMyA9IHBhcmFtMyAhPSBudWxsID8gcGFyYW0zIDogMFxcbiAgICBwYXJhbTQgPSBNWV9USUNLRVRcXG4gICAgcGFyYW01ID0gZXZhbFxcbiAgICByZXR1cm4gbWV0aG9kX3JlcXVpcmVDYWNoZS5pbnZva2UoamF2YUNvbnRleHQsIHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00LCBwYXJhbTUpXFxufVxcbnJjID0gcmVxdWlyZUNhY2hlXFxuLy8g5pyA5paw56ug6IqC6KeE5YiZ546v5aKD5Yqr5oyBXFxuc2V0TGFzdENoYXB0ZXJSdWxlID0gZnVuY3Rpb24ocGFyYW0wKSB7XFxuICAgIGlmIChwYXJhbTAuc3RhcnRzV2l0aChcXFwianM6XFxcIikpIHtcXG4gICAgICAgIHBhcmFtMCA9ICdqczonICsgJC50b1N0cmluZygoUUlOR19USVRMRSwgTVlfUEFSQU1TKSA9PiB7XFxuICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL3BhZ2UvaGlqYWNrRW52P3J1bGU9JyArIFFJTkdfVElUTEUpKS5ydWxlKVxcbiAgICAgICAgICAgIHZhciB7IHJ1blByZVJ1bGUgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKVxcbiAgICAgICAgICAgIHJ1blByZVJ1bGUob3JpUlVMRS5wcmVSdWxlKVxcbiAgICAgICAgfSwgUUlOR19USVRMRSwgeyB1cmw6IE1ZX1JVTEUudXJsLCBSVUxFOiBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoZ2VuTXlSdWxlKCkpKSwgaXNJbmRleDogaXNJbmRleCB9KSArICc7JyArIHBhcmFtMC5zbGljZSgzKVxcbiAgICB9XFxuICAgIG1ldGhvZF9zZXRMYXN0Q2hhcHRlclJ1bGUuaW52b2tlKGphdmFDb250ZXh0LCBwYXJhbTApXFxufVxcbi8vIOWKqOaAgeaWsOWinuWHveaVsOWKq+aMgVxcbmFkZEl0ZW1BZnRlciA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xKSB7XFxuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtMSkpIHBhcmFtMSA9IHBhcmFtMS5tYXAoaGlqYWNrRWwpXFxuICAgIGVsc2UgcGFyYW0xID0gaGlqYWNrRWwocGFyYW0xKVxcbiAgICBtZXRob2RfYWRkSXRlbUFmdGVyLmludm9rZShqYXZhQ29udGV4dCwgcGFyYW0wLCBwYXJhbTEpXFxufVxcbmFkZEl0ZW1CZWZvcmUgPSBmdW5jdGlvbihwYXJhbTAsIHBhcmFtMSkge1xcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbTEpKSBwYXJhbTEgPSBwYXJhbTEubWFwKGhpamFja0VsKVxcbiAgICBlbHNlIHBhcmFtMSA9IGhpamFja0VsKHBhcmFtMSlcXG4gICAgbWV0aG9kX2FkZEl0ZW1CZWZvcmUuaW52b2tlKGphdmFDb250ZXh0LCBwYXJhbTAsIHBhcmFtMSlcXG59XFxuXCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLlh73mlbDlt6XlhbdcIixcInBhdGhcIjpcImZ1bmNUb29sc1wiLFwicnVsZVwiOlwibGV0IHsgUUlOR19USVRMRSwgTVlfUlVMRSwgaXNJbmRleCB9ID0gJC5pbXBvcnRQYXJhbVxcbmlmICghTVlfUlVMRSkgTVlfUlVMRSA9IHt9XFxuXFxuZnVuY3Rpb24gcnVuQ29kZShydWxlKSB7XFxuICAgIHRyeSB7XFxuICAgICAgICBsZXQgW2lucHV0LCBjb2RlXSA9IHJ1bGUuc3BsaXQoJy5qczonKVxcbiAgICAgICAgcmV0dXJuIGNvZGUgPyBldmFsKGNvZGUpIDogcnVsZVxcbiAgICB9IGNhdGNoIChlKSB7IHJldHVybiBydWxlIH1cXG59XFxuLy8g6aaW6aG16ZO+5o6l5pu/5o2i5YiG57G7XFxuZnVuY3Rpb24gaW5kZXhVcmwocGFyYW0pIHtcXG4gICAgTVlfUlVMRSA9IEpTT04ucGFyc2UoYmFzZTY0RGVjb2RlKE1ZX1JVTEUpKVxcbiAgICBsZXQgcGFnZU51bSA9IHBhcnNlSW50KHBhcmFtLnNwbGl0KCcjIyMnKVsxXSksXFxuICAgICAgICB1cmwgPSBNWV9SVUxFLnVybCxcXG4gICAgICAgIHsgZnlBbGwsIHRhYkhlYWRlciB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvQ2xhc3NUYWI/cnVsZT0nICsgUUlOR19USVRMRSwgT2JqZWN0LmFzc2lnbih7IFFJTkdfVElUTEU6IFFJTkdfVElUTEUgfSwgTVlfUlVMRSkpXFxuXFxuICAgIHVybCA9IHRhYkhlYWRlci5zZXRVcmwoZnlBbGwgPyB1cmwucmVwbGFjZSgvZnlBbGwvZywgJyQke2Z5QWxsfScpIDogdXJsLnJlcGxhY2UoL2Z5KGNsYXNzfGFyZWF8eWVhcnxzb3J0KS9nLCAnJCR7ZnkkMX0nKSlcXG4gICAgdXJsID0gdXJsLnJlcGxhY2UoL2Z5cGFnZSg/OkAoLT9cXFxcZCspQCk/KD86XFxcXCooXFxcXGQrKUApPy9nLCAoXywgc3RhcnQsIHNwYWNlKSA9PiBwYXJzZUludChzdGFydCB8fCAwKSArIDEgKyAocGFnZU51bSAtIDEpICogcGFyc2VJbnQoc3BhY2UgfHwgMSkpXFxuICAgIHVybCA9IC9eKFtcXFxcc1xcXFxTXSo/KSg/OlxcXFxbZmlyc3RQYWdlPShbXFxcXHNcXFxcU10qPylcXFxcXSk/KD86KFxcXFwuanM6W1xcXFxzXFxcXFNdKj8pKT8kLy5leGVjKHVybClcXG4gICAgaWYgKHBhZ2VOdW0gPT0gMSAmJiB1cmxbMl0pIHVybFsxXSA9IHVybFsyXVxcbiAgICBpZiAodXJsWzNdICYmICF1cmxbMV0uaW5jbHVkZXMoJy5qczonKSkgdXJsWzFdICs9IHVybFszXVxcbiAgICByZXR1cm4gcnVuQ29kZSh1cmxbMV0pXFxufVxcblxcbmZ1bmN0aW9uIHBhcmFtSGFuZGxlKHVybFBhcmFtLCB1YSwgdXJsVG1wKSB7XFxuICAgIGxldCBjaGFyc2V0LCBwYXJhbVRtcFxcbiAgICB0cnkgeyAvLyDpk77mjqXnmoTnvJbnoIHjgIFVQeWSjFJlZmVyZXLlupTor6XmmK/pppblhYjnu6fmib/pppbpobXpk77mjqVcXG4gICAgICAgIFssICwgY2hhcnNldCwgcGFyYW1UbXBdID0gdXJsVG1wLnNwbGl0KCc7JylcXG4gICAgICAgIHBhcmFtVG1wID0gcGFyYW1UbXAubWF0Y2goL157KC4qKX0kLylbMV0uc3BsaXQoJyYmJylcXG4gICAgfSBjYXRjaCAoZSkgeyBwYXJhbVRtcCA9IFtdIH1cXG4gICAgbGV0IFVzZXJBZ2VudCA9IHBhcmFtVG1wLmZpbmQoKHYpID0+IHYuc3RhcnRzV2l0aCgnVXNlci1BZ2VudEAnKSksXFxuICAgICAgICBSZWZlcmVyID0gcGFyYW1UbXAuZmluZCgodikgPT4gdi5zdGFydHNXaXRoKCdSZWZlcmVyQCcpKVxcbiAgICB1cmxQYXJhbVswXSA9IHVybFBhcmFtWzBdIHx8ICdHRVQnXFxuICAgIHVybFBhcmFtWzFdID0gdXJsUGFyYW1bMV0gfHwgY2hhcnNldCB8fCAnVVRGLTgnXFxuICAgIHRyeSB7XFxuICAgICAgICB1cmxQYXJhbVsyXSA9IHVybFBhcmFtWzJdLm1hdGNoKC9eeyguKil9JC8pWzFdLnNwbGl0KCcmJicpXFxuICAgIH0gY2F0Y2ggKGUpIHsgdXJsUGFyYW1bMl0gPSBbXSB9XFxuICAgIC8vIOa3u+WKoOWFqOWxgFVB5ZKM5LiK57qnUmVmZXJlclxcbiAgICBpZiAoIXVybFBhcmFtWzJdLnNvbWUoKHYpID0+IHYuc3RhcnRzV2l0aCgnVXNlci1BZ2VudEAnKSkpIHtcXG4gICAgICAgIGlmIChVc2VyQWdlbnQpIHVybFBhcmFtWzJdLnB1c2goVXNlckFnZW50KVxcbiAgICAgICAgZWxzZSBpZiAodWEgPT0gJ3BjJylcXG4gICAgICAgICAgICB1cmxQYXJhbVsyXS5wdXNoKCdVc2VyLUFnZW50QCcgKyBQQ19VQS5yZXBsYWNlKC87L2csICfvvJvvvJsnKS5yZXBsYWNlKC9cXFxcPy8sICfvvJ/vvJ8nKSlcXG4gICAgICAgIGVsc2UgaWYgKHVhID09ICdtb2JpbGUnKVxcbiAgICAgICAgICAgIHVybFBhcmFtWzJdLnB1c2goJ1VzZXItQWdlbnRAJyArIE1PQklMRV9VQS5yZXBsYWNlKC87L2csICfvvJvvvJsnKS5yZXBsYWNlKC9cXFxcPy8sICfvvJ/vvJ8nKSlcXG4gICAgfVxcbiAgICBpZiAoUmVmZXJlciAmJiAhdXJsUGFyYW1bMl0uc29tZSgodikgPT4gdi5zdGFydHNXaXRoKCdSZWZlcmVyQCcpKSlcXG4gICAgICAgIHVybFBhcmFtWzJdLnB1c2goUmVmZXJlcilcXG4gICAgdXJsUGFyYW1bMl0gPSAneycgKyB1cmxQYXJhbVsyXS5qb2luKCcmJicpICsgJ30nXFxuICAgIHJldHVybiB1cmxQYXJhbS5qb2luKCc7JylcXG59XFxuLy8g6aKE5aSE55CG5bm25Yid5aeL5YyWY29uZmlnXFxuZnVuY3Rpb24gcnVuUHJlUnVsZShydWxlKSB7XFxuICAgIGlmICgodHlwZW9mIE1ZX1BBR0UgIT0gJ3VuZGVmaW5lZCcgJiYgIE1ZX1BBR0UgPT0gMSkgJiZcXG4gICAgICAgICAoaXNJbmRleCB8fCAhZ2V0TXlWYXIoJyRwcmVSdWxlXycgKyBNWV9SVUxFLnRpdGxlKSkpIHtcXG4gICAgICAgIGV2YWwocnVsZSlcXG4gICAgICAgIHB1dE15VmFyKCckcHJlUnVsZV8nICsgTVlfUlVMRS50aXRsZSwgJ1QnKVxcbiAgICB9XFxuICAgIGxldCBfY2ZnID0gZ2V0TXlWYXIoJ2luaXRDb25maWcnLCAne30nKVxcbiAgICBpZiAoX2NmZyAmJiBfY2ZnLmxlbmd0aCA+IDApIHtcXG4gICAgICAgIGNvbmZpZyA9IEpTT04ucGFyc2UoX2NmZylcXG4gICAgfVxcbn1cXG4vLyDmraPmlofop6PmnpDpgJrnlKjlj5jph49cXG5mdW5jdGlvbiBnZW5NeVJ1bGUoKSB7XFxuICAgIGxldCBSVUxFID0gT2JqZWN0LmFzc2lnbih7fSwgTVlfUlVMRSlcXG4gICAgZGVsZXRlIFJVTEUubGFzdF9jaGFwdGVyX3J1bGVcXG4gICAgZGVsZXRlIFJVTEUucHJlUnVsZVxcbiAgICBkZWxldGUgUlVMRS5wYWdlTGlzdFxcbiAgICBkZWxldGUgUlVMRS5wYWdlc1xcbiAgICByZXR1cm4gUlVMRVxcbn1cXG5cXG5mdW5jdGlvbiBnZW5FeFVybCh1cmwpIHtcXG4gICAgdXJsID0gdXJsLnNwbGl0KCc7JylcXG4gICAgcmV0dXJuIHVybC5zaGlmdCgpICsgJzsnICsgcGFyYW1IYW5kbGUodXJsLCBNWV9SVUxFLnVhLCBNWV9SVUxFLnVybClcXG59XFxuXFxuaGlqYWNrTGF6eVJ1bGUgPSAkLnRvU3RyaW5nKChRSU5HX1RJVExFLCBNWV9QQVJBTVMpID0+IHtcXG4gICAgaWYgKCFNWV9SVUxFKSBNWV9SVUxFID0ge31cXG4gICAgZXZhbChKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL3BhZ2UvaGlqYWNrRW52P3J1bGU9JyArIFFJTkdfVElUTEUpKS5ydWxlKVxcbiAgICB2YXIge1xcbiAgICAgICAgcGFyYW1IYW5kbGUsXFxuICAgICAgICBnZW5FeFVybCxcXG4gICAgICAgIGhpamFja0xhenlSdWxlLFxcbiAgICAgICAgaGlqYWNrRWxcXG4gICAgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKVxcbn0sIFFJTkdfVElUTEUsIHsgdXJsOiBNWV9SVUxFLnVybCwgUlVMRTogYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KGdlbk15UnVsZSgpKSksIGlzSW5kZXg6IGlzSW5kZXggfSlcXG5cXG5mdW5jdGlvbiBoaWphY2tFbChlbCkge1xcbiAgICBpZighZWwgfHwgdHlwZW9mIGVsICE9ICdvYmplY3QnKSByZXR1cm5cXG4gICAgaWYgKCFlbC5leHRyYSkgZWwuZXh0cmEgPSB7fVxcbiAgICBlbC5jb2xfdHlwZSA9IGVsLmNvbF90eXBlIHx8IE1ZX1JVTEUuY29sX3R5cGVcXG4gICAgbGV0IE5PV19SVUxFID0gT2JqZWN0LmFzc2lnbihnZW5NeVJ1bGUoKSwgeyBwYXJhbXM6IGVsLmV4dHJhIH0pXFxuXFxuICAgIGlmICh0eXBlb2YgZWwudXJsICE9ICdzdHJpbmcnIHx8XFxuICAgICAgICBbJ3g1X3dlYnZpZXdfc2luZ2xlJywgJ2lucHV0J10uZmluZCgodikgPT4gZWwuY29sX3R5cGUgPT0gdikgfHxcXG4gICAgICAgIFsn5rW36ZiU6KeG55WMJywgJ2phdmFzY3JpcHQ6J10uZmluZCgodikgPT4gZWwudXJsLnN0YXJ0c1dpdGgodikpIHx8XFxuICAgICAgICBbJ3J1bGUnLCAncGljcycsICd0b2FzdCcsICdjb3B5JywgJ2VkaXRGaWxlJywgJ3g1JywgJ3g1V2ViVmlldycsICd4NVBsYXknLCAnd2ViJywgJ3g1UnVsZScsICd3ZWJSdWxlJyxcXG4gICAgICAgICAgICAnZG93bmxvYWQnLCAnc2hhcmUnLCAnZmlsZVNlbGVjdCcsICd2aWRlbyddLmZpbmQoKHYpID0+IGVsLnVybC5zdGFydHNXaXRoKHYgKyAnOi8vJykpKSB7XFxuICAgICAgICByZXR1cm4gZWxcXG4gICAgfSBlbHNlIGlmIChlbC51cmwuc3RhcnRzV2l0aCgnaW5wdXQ6Ly8nKSkge1xcbiAgICAgICAgbGV0IHBhcmEgPSBKU09OLnBhcnNlKGVsLnVybC5zbGljZSg4KSlcXG4gICAgICAgIGlmIChwYXJhLmpzKSBwYXJhLmpzID0gaGlqYWNrTGF6eVJ1bGUgKyAnOycgKyBwYXJhLmpzXFxuICAgICAgICBlbC51cmwgPSAnaW5wdXQ6Ly8nICsgSlNPTi5zdHJpbmdpZnkocGFyYSlcXG4gICAgICAgIHJldHVybiBlbFxcbiAgICB9IGVsc2UgaWYgKGVsLnVybC5zdGFydHNXaXRoKCdjb25maXJtOi8vJykpIHtcXG4gICAgICAgIGxldCByZUluZGV4ID0gZWwudXJsLmluZGV4T2YoJy5qczonKVxcbiAgICAgICAgaWYgKHJlSW5kZXggPj0gMCkgZWwudXJsID0gZWwudXJsLnNsaWNlKDAsIHJlSW5kZXgpICsgJy5qczonICsgaGlqYWNrTGF6eVJ1bGUgKyAnOycgKyBlbC51cmwuc2xpY2UocmVJbmRleCArIDQpXFxuICAgICAgICByZXR1cm4gZWxcXG4gICAgfSBlbHNlIGlmIChlbC51cmwuc3RhcnRzV2l0aCgnc2VsZWN0Oi8vJykpIHtcXG4gICAgICAgIGxldCBwYXJhID0gSlNPTi5wYXJzZShlbC51cmwuc2xpY2UoOSkpXFxuICAgICAgICBpZiAocGFyYS5qcykgcGFyYS5qcyA9IGhpamFja0xhenlSdWxlICsgJzsnICsgcGFyYS5qc1xcbiAgICAgICAgZWwudXJsID0gJ3NlbGVjdDovLycgKyBKU09OLnN0cmluZ2lmeShwYXJhKVxcbiAgICAgICAgcmV0dXJuIGVsXFxuICAgIH0gZWxzZSBpZiAoZWwudXJsLmluY2x1ZGVzKCdAcnVsZT0nKSkge1xcbiAgICAgICAgbGV0IFtfLCB1cmwsIHJ1bGVdID0gZWwudXJsLm1hdGNoKC9eKFtcXFxcc1xcXFxTXSo/KUBydWxlPShbXFxcXHNcXFxcU10qKSQvKVxcbiAgICAgICAgZWwudXJsID0gdXJsXFxuICAgICAgICBOT1dfUlVMRS5kZXRhaWxfZmluZF9ydWxlID0gcnVsZVxcbiAgICAgICAgTk9XX1JVTEUuZGV0YWlsX2NvbF90eXBlID0gTVlfUlVMRS5jb2xfdHlwZVxcbiAgICB9IGVsc2UgaWYgKGVsLnVybC5zdGFydHNXaXRoKCdoaWtlcjovL3BhZ2UvJykpIHtcXG4gICAgICAgIGlmIChlbC51cmwuaW5jbHVkZXMoJ3J1bGU9JykgfHwgZWwuZXh0cmEucnVsZSlcXG4gICAgICAgICAgICByZXR1cm4gZWxcXG4gICAgICAgIGxldCBbXywgcGF0aCwgZmxhZywgcGFyYW1zXSA9IGVsLnVybC5tYXRjaCgvXmhpa2VyOlxcXFwvXFxcXC9wYWdlXFxcXC8oLis/KSgjLio/KT8oPzpcXFxcPyguKikpPyQvKSxcXG4gICAgICAgICAgICBzdWJQYWdlID0gTVlfUlVMRS5wYWdlTGlzdC5maW5kKCh2KSA9PiB2LnBhdGggPT0gcGF0aCksXFxuICAgICAgICAgICAgc3ViVXJsID0gKHBhcmFtcyB8fCAnJykuc3BsaXQoJyYnKS5maW5kKCh2KSA9PiB2LnN0YXJ0c1dpdGgoJ3VybD0nKSlcXG4gICAgICAgIGVsLnVybCA9IChzdWJVcmwgPyBzdWJVcmwuc2xpY2UoNCkucmVwbGFjZSgv77yf77yfL2csICc/JykucmVwbGFjZSgv77yG77yGL2csICcmJykgOiAoZWwuZXh0cmEgfHwge30pLnVybCkgfHwgJ2hpa2VyOi8vZW1wdHknICsgZmxhZyArICc/JyArIChwYXJhbXMgfHwgJycpXFxuICAgICAgICBOT1dfUlVMRS5kZXRhaWxfZmluZF9ydWxlID0gc3ViUGFnZS5ydWxlXFxuICAgICAgICBOT1dfUlVMRS5kZXRhaWxfY29sX3R5cGUgPSBzdWJQYWdlLmNvbF90eXBlXFxuICAgIH0gZWxzZSBpZiAoZWwudXJsLmluY2x1ZGVzKCdAbGF6eVJ1bGU9JykpIHtcXG4gICAgICAgIGxldCByZUluZGV4ID0gZWwudXJsLmluZGV4T2YoJy5qczonKVxcbiAgICAgICAgaWYgKHJlSW5kZXggPj0gMCkgZWwudXJsID0gZWwudXJsLnNsaWNlKDAsIHJlSW5kZXgpICsgJy5qczonICsgaGlqYWNrTGF6eVJ1bGUgKyAnOycgKyBlbC51cmwuc2xpY2UocmVJbmRleCArIDQpXFxuICAgICAgICByZXR1cm4gZWxcXG4gICAgfSBlbHNlIGlmIChpc0luZGV4KSB7XFxuICAgICAgICBpZiAoIU1ZX1JVTEUuZGV0YWlsX2ZpbmRfcnVsZSB8fCAvaGlrZXI6XFxcXC9cXFxcLyg/IWVtcHR5LiskKS8udGVzdChlbC51cmwpKSByZXR1cm4gZWxcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBlbFxcbiAgICB9XFxuICAgIGVsLmV4dHJhID0gT2JqZWN0LmFzc2lnbih7fSwgZWwuZXh0cmEsIHtcXG4gICAgICAgIHVybDogZ2VuRXhVcmwoZWwudXJsKSxcXG4gICAgICAgIFJVTEU6IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShOT1dfUlVMRSkpLFxcbiAgICAgICAgcGFnZVRpdGxlOiBpc0luZGV4ICYmIGVsLnRpdGxlXFxuICAgIH0pXFxuICAgIGVsLnVybCA9ICdoaWtlcjovL3BhZ2UvZnJhbWVMb2FkP3J1bGU9JyArIFFJTkdfVElUTEVcXG4gICAgcmV0dXJuIGVsXFxufVxcbiQuZXhwb3J0cyA9IHtcXG4gICAgcnVuQ29kZTogcnVuQ29kZSxcXG4gICAgaW5kZXhVcmw6IGluZGV4VXJsLFxcbiAgICBwYXJhbUhhbmRsZTogcGFyYW1IYW5kbGUsXFxuICAgIHJ1blByZVJ1bGU6IHJ1blByZVJ1bGUsXFxuICAgIGdlbk15UnVsZTogZ2VuTXlSdWxlLFxcbiAgICBnZW5FeFVybDogZ2VuRXhVcmwsXFxuICAgIGhpamFja0xhenlSdWxlOiBoaWphY2tMYXp5UnVsZSxcXG4gICAgaGlqYWNrRWw6IGhpamFja0VsXFxufVxcblwifV0sXCJwYXJhbXNcIjpcIntcXFwiUlVMRVxcXCI6XFxcImV5SjBhWFJzWlNJNkl1aUFnZWVadmVhVmhlUzZpeUo5XFxcIixcXFwiaXNJbmRleFxcXCI6dHJ1ZSxcXFwidXJsXFxcIjpcXFwiaGlrZXI6Ly9lbXB0eS8jbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjIyMjZnlwYWdlLmpzOmxldCB7IHJ1bkNvZGUsIGluZGV4VXJsIH0gPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvZnVuY1Rvb2xz77yf77yfcnVsZT3lkKzlkIjpm4ZcXFxcXFxcIiwge1xcXFxcXFwiTVlfUlVMRVxcXFxcXFwiOlxcXFxcXFwiZXlKMGFYUnNaU0k2SXVpQWdlZVp2ZWFWaGVTNml5SXNJblZ5YkNJNkltaHBhMlZ5T2k4dlpXMXdkSGtqSTJoMGRIQnpPaTh2WVhCckxXeGlMV3B6YjI0dVptOWtaWGhwYmk1amIyMGpJMlo1Y0dGblpTSXNJbU5zWVhOelgyNWhiV1VpT2lJaUxDSmpiR0Z6YzE5MWNtd2lPaUlpTENKaGNtVmhYMjVoYldVaU9pSWlMQ0poY21WaFgzVnliQ0k2SWlJc0lubGxZWEpmYm1GdFpTSTZJaUlzSW5sbFlYSmZkWEpzSWpvaUlpd2ljMjl5ZEY5dVlXMWxJam9pSWl3aWMyOXlkRjkxY213aU9pSWlmUT09XFxcXFxcXCIsXFxcXFxcXCJRSU5HX1RJVExFXFxcXFxcXCI6XFxcXFxcXCLlkKzlkIjpm4ZcXFxcXFxcIn0p77yb77ybaW5kZXhVcmwoaW5wdXQpO0dFVDtVVEYtODt7VXNlci1BZ2VudEBNb3ppbGxhLzUuMCAoTGludXjvvJvvvJsgQW5kcm9pZCAxNO+8m++8myBTTS1BNzM2QiBCdWlsZC9VUDFBLjIzMTAwNS4wMDfvvJvvvJsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS8xMjYuMC42NDc4LjEzNCBNb2JpbGUgU2FmYXJpLzUzNy4zNn1cXFwifVwiLFwic2F2ZWRcIjpmYWxzZSxcInRpdGxlXCI6XCLlkKzlkIjpm4ZcIixcInZlcnNpb25cIjowLFwidXJsXCI6XCJoaWtlcjovL2VtcHR5LyNub0hpc3RvcnkjI25vUmVjb3JkSGlzdG9yeSMjIyNmeXBhZ2UuanM6bGV0IHsgcnVuQ29kZSwgaW5kZXhVcmwgfSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL2Z1bmNUb29sc++8n++8n3J1bGU95ZCs5ZCI6ZuGXFxcIiwge1xcXCJNWV9SVUxFXFxcIjpcXFwiZXlKMGFYUnNaU0k2SXVpQWdlZVp2ZWFWaGVTNml5SXNJblZ5YkNJNkltaHBhMlZ5T2k4dlpXMXdkSGtqSTJoMGRIQnpPaTh2WVhCckxXeGlMV3B6YjI0dVptOWtaWGhwYmk1amIyMGpJMlo1Y0dGblpTSXNJbU5zWVhOelgyNWhiV1VpT2lJaUxDSmpiR0Z6YzE5MWNtd2lPaUlpTENKaGNtVmhYMjVoYldVaU9pSWlMQ0poY21WaFgzVnliQ0k2SWlJc0lubGxZWEpmYm1GdFpTSTZJaUlzSW5sbFlYSmZkWEpzSWpvaUlpd2ljMjl5ZEY5dVlXMWxJam9pSWl3aWMyOXlkRjkxY213aU9pSWlmUT09XFxcIixcXFwiUUlOR19USVRMRVxcXCI6XFxcIuWQrOWQiOmbhlxcXCJ9Ke+8m++8m2luZGV4VXJsKGlucHV0KTtHRVQ7VVRGLTg7e1VzZXItQWdlbnRATW96aWxsYS81LjAgKExpbnV477yb77ybIEFuZHJvaWQgMTTvvJvvvJsgU00tQTczNkIgQnVpbGQvVVAxQS4yMzEwMDUuMDA377yb77ybIHd2KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzQuMCBDaHJvbWUvMTI2LjAuNjQ3OC4xMzQgTW9iaWxlIFNhZmFyaS81MzcuMzZ9XCIsXCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwiZmluZF9ydWxlXCI6XCJqczpcXG5jb25zdCBRSU5HX1RJVExFID0gZ2V0TXlWYXIoJ215Q29sbGVjdGlvbicpXFxudmFyIG15Q29sbF9lbCA9IFtdXFxuZXZhbChKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL3BhZ2UvaGlqYWNrRW52P3J1bGU9JyArIFFJTkdfVElUTEUpKS5ydWxlKVxcblxcbmlmICghaXNJbmRleCkge1xcbiAgICBpZiAocGFnZVRpdGxlKSBzZXRQYWdlVGl0bGUocGFnZVRpdGxlKVxcbiAgICBzZXRMYXN0Q2hhcHRlclJ1bGUob3JpUlVMRS5sYXN0X2NoYXB0ZXJfcnVsZSlcXG4gICAgTVlfUEFSQU1TID0gTVlfUlVMRS5wYXJhbXNcXG59IGVsc2UgaWYgKE1ZX1BBR0UgPT0gMSkge1xcbiAgICB0YWJIZWFkZXIubG9hZChteUNvbGxfZWwpXFxuICAgIGlmIChSVUxFLnNlYXJjaF91cmwpIG15Q29sbF9lbC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi5pCc57SiXFxcIixcXG4gICAgICAgIGRlc2M6IFxcXCLov5nmmK/ovbvlkIjpm4bnmoTmkJzntKLlk6Z+flxcXCIsXFxuICAgICAgICB1cmw6ICdcXFwiaGlrZXI6Ly9zZWFyY2g/cz1cXFwiK2lucHV0JyxcXG4gICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgcnVsZXM6ICQudG9TdHJpbmcoKFFJTkdfVElUTEUsIHRpdGxlKSA9PiB7XFxuICAgICAgICAgICAgICAgIGxldCBydWxlcyA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2RhdGFMb2FkP3J1bGU9JyArIFFJTkdfVElUTEUpXFxuICAgICAgICAgICAgICAgIHJ1bGVzID0gW3J1bGVzLmZpbmQoKHYpID0+IHYudGl0bGUgPT0gdGl0bGUpXVxcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocnVsZXMpXFxuICAgICAgICAgICAgfSwgUUlOR19USVRMRSwgUlVMRS50aXRsZSksXFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXRNeVZhcignc2VhcmNoS2V5JywgJycpLFxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBcXFwicHV0TXlWYXIoJ3NlYXJjaEtleScsaW5wdXQpXFxcIlxcbiAgICAgICAgfSxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwiaW5wdXRcXFwiLFxcbiAgICB9KVxcbn1cXG4vLyDmraPmlofop6PmnpBcXG52YXIge1xcbiAgICBwYXJhbUhhbmRsZSxcXG4gICAgcnVuUHJlUnVsZSxcXG4gICAgZ2VuRXhVcmwsXFxuICAgIGhpamFja0xhenlSdWxlXFxufSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKVxcbnJ1blByZVJ1bGUob3JpUlVMRS5wcmVSdWxlKVxcbmlmIChNWV9SVUxFLmZpbmRfcnVsZS5zdGFydHNXaXRoKCdqczonKSkge1xcbiAgICBsZXQgeyBoaWphY2tFbCB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZnVuY1Rvb2xzP3J1bGU9JyArIFFJTkdfVElUTEUpXFxuICAgIHNldFJlc3VsdCA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMykge1xcbiAgICAgICAgcGFyYW0xID0gQ0FMTEJBQ0tfS0VZXFxuICAgICAgICBwYXJhbTIgPSBNWV9SVUxFXFxuICAgICAgICBwYXJhbTMgPSBNWV9UWVBFXFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbTAuZGF0YSkpIHBhcmFtMCA9IHBhcmFtMC5kYXRhXFxuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShteUNvbGxfZWwsIHBhcmFtMC5tYXAoaGlqYWNrRWwpKVxcbiAgICAgICAgbWV0aG9kX3NldFJlc3VsdC5pbnZva2UoamF2YUNvbnRleHQsIG15Q29sbF9lbCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMylcXG4gICAgfVxcbiAgICBzZXRIb21lUmVzdWx0ID0gc2V0UmVzdWx0XFxuICAgIHNldFNlYXJjaFJlc3VsdCA9IHNldFJlc3VsdFxcblxcbiAgICBldmFsKE1ZX1JVTEUuZmluZF9ydWxlLnNsaWNlKDMpKVxcbn0gZWxzZSB7XFxuICAgIGxldCB7IHJ1bkNvZGUgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKSxcXG4gICAgICAgIFtfLCBmaW5kUnVsZSwgZGV0YWlsRmluZFJ1bGVdID0gTVlfUlVMRS5maW5kX3J1bGUubWF0Y2goL14oW1xcXFxzXFxcXFNdKj8pKD86PT0+KFtcXFxcc1xcXFxTXSopKT8kLylcXG4gICAgZmluZFJ1bGUgPSBmaW5kUnVsZS5zcGxpdCgnOycpXFxuICAgIHBhcnNlRG9tRm9yQXJyYXkoZ2V0UmVzQ29kZSgpLCBmaW5kUnVsZS5zaGlmdCgpKS5mb3JFYWNoKChkYXRhKSA9PiB7XFxuICAgICAgICBsZXQgW3RpdGxlLCBpbWcsIGRlc2MsIHVybF0gPSBmaW5kUnVsZS5tYXAoKHYsIGkpID0+IHtcXG4gICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgIGlmICh2ID09ICcqJykgcmV0dXJuICcnXFxuICAgICAgICAgICAgICAgICAgICBlbHNlIHYgPSAoaSA9PSAxIHx8IGkgPT0gMykgP1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRG9tKGRhdGEsIHYpIDpcXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZURvbUZvckh0bWwoZGF0YSwgdilcXG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9IDMpIHYgPSBydW5Db2RlKHYpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdlxcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7IHJldHVybiAnJyB9XFxuICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgcmVzID0ge1xcbiAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsIHVybDogdXJsLFxcbiAgICAgICAgICAgICAgICBkZXNjOiBkZXNjLCBpbWc6IGltZyxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IE1ZX1JVTEUuY29sX3R5cGVcXG4gICAgICAgICAgICB9XFxuICAgICAgICBpZiAocmVzLnVybCkge1xcbiAgICAgICAgICAgIGlmIChyZXMudXJsLmluY2x1ZGVzKCdAbGF6eVJ1bGU9JykpIHtcXG4gICAgICAgICAgICAgICAgbGV0IHJlSW5kZXggPSByZXMudXJsLmluZGV4T2YoJy5qczonKVxcbiAgICAgICAgICAgICAgICBpZiAocmVJbmRleCA+PSAwKSByZXMudXJsID0gcmVzLnVybC5zbGljZSgwLCByZUluZGV4KSArICcuanM6JyArIGhpamFja0xhenlSdWxlICsgJzsnICsgcmVzLnVybC5zbGljZShyZUluZGV4ICsgNClcXG4gICAgICAgICAgICB9IGVsc2UgIGlmIChkZXRhaWxGaW5kUnVsZSkge1xcbiAgICAgICAgICAgICAgICByZXMuZXh0cmEgPSB7XFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGdlbkV4VXJsKHVybCksXFxuICAgICAgICAgICAgICAgICAgICBSVUxFOiBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmFzc2lnbihnZW5NeVJ1bGUoKSwgeyBkZXRhaWxfZmluZF9ydWxlOiBkZXRhaWxGaW5kUnVsZSB9KSkpLFxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVRpdGxlOiBpc0luZGV4ICYmIHRpdGxlXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcmVzLnVybCA9ICdoaWtlcjovL3BhZ2UvZnJhbWVMb2FkP3J1bGU9JyArIFFJTkdfVElUTEVcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKE1ZX1JVTEUuZGV0YWlsX2ZpbmRfcnVsZSkge1xcbiAgICAgICAgICAgICAgICByZXMuZXh0cmEgPSB7XFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGdlbkV4VXJsKHVybCksXFxuICAgICAgICAgICAgICAgICAgICBSVUxFOiBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoZ2VuTXlSdWxlKCkpKSxcXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTogaXNJbmRleCAmJiB0aXRsZVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJlcy51cmwgPSAnaGlrZXI6Ly9wYWdlL2ZyYW1lTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgbXlDb2xsX2VsLnB1c2gocmVzKVxcbiAgICB9KVxcbiAgICBzZXRSZXN1bHQobXlDb2xsX2VsKVxcbn1cXG5cIixcImdyb3VwXCI6XCLikaDovbvlkIjpm4ZcIixcInVhXCI6XCJtb2JpbGVcIixcInByZVJ1bGVcIjpcInB1dE15VmFyKCdteUNvbGxlY3Rpb24nLCBNWV9SVUxFLnRpdGxlKVxcbnB1dE15VmFyKCdyZW1vdGVVcmwnLCAnaHR0cHM6Ly9naHByb3h5LmNvbS9odHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20veGl4aWZyZWUvSGlrZXIvbWFpbi90aW5nLmpzb24nKVwiLFwicGFnZXNcIjpcIlt7XFxcImNvbF90eXBlXFxcIjpcXFwidGV4dF8xXFxcIixcXFwibmFtZVxcXCI6XFxcIkNsYXNzVGFiXFxcIixcXFwicGF0aFxcXCI6XFxcIkNsYXNzVGFiXFxcIixcXFwicnVsZVxcXCI6XFxcInZhciB7XFxcXG4gICAgUUlOR19USVRMRSwgdGl0bGUsIHVybCxcXFxcbiAgICBjbGFzc19uYW1lLCBjbGFzc191cmwsXFxcXG4gICAgYXJlYV9uYW1lLCBhcmVhX3VybCxcXFxcbiAgICB5ZWFyX25hbWUsIHllYXJfdXJsLFxcXFxuICAgIHNvcnRfbmFtZSwgc29ydF91cmxcXFxcbn0gPSAkLmltcG9ydFBhcmFtXFxcXG5jb25zdCBDbGFzc1RhYiA9IGZ1bmN0aW9uKGNsYXNzQXJyYXksIHBhcmFtcykge1xcXFxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgcGFyYW1zKVxcXFxuICAgIHRoaXMuYXJyID0gY2xhc3NBcnJheS5tYXAodiA9PiB0aGlzLmluaXQodikpXFxcXG4gICAgdGhpcy5zaWduID0gJyQnICsgUUlOR19USVRMRSArICdfJyArICh0aGlzLm5hbWUgfHwgJycpICsgJ18nXFxcXG4gICAgdGhpcy5jb2xvciA9IHRoaXMuY29sb3IgfHwgJyMxMmI2NjgnXFxcXG4gICAgdGhpcy5ib3VuZGFyeSA9IHRoaXMuYm91bmRhcnkgfHwgJ2JsYW5rX2Jsb2NrJ1xcXFxufVxcXFxuQ2xhc3NUYWIucHJvdG90eXBlID0ge1xcXFxuICAgIGNvbnN0cnVjdG9yOiBDbGFzc1RhYixcXFxcbiAgICBsb2FkKGVsKSB7XFxcXG4gICAgICAgIGxldCBmb2xkZWQgPSB0aGlzLmZvbGQgJiYgZ2V0VmFyKCckZm9sZF8nICsgdGhpcy5zaWduLCAnJylcXFxcbiAgICAgICAgaWYgKHRoaXMuYXJyLmxlbmd0aCA+IDEgJiYgdGhpcy5mb2xkKSBlbC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdJyArIChmb2xkZWQgPyAn4pa2JyA6ICfilrwnKS5mb250Y29sb3IoJyMwNDllZmYnKSxcXFxcbiAgICAgICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoc2lnbiwgZm9sZGVkKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgcHV0VmFyKCckZm9sZF8nICsgc2lnbiwgZm9sZGVkID8gJycgOiAnVCcpXFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICAgICAgfSwgdGhpcy5zaWduLCBmb2xkZWQpLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcXFxuICAgICAgICB9KVxcXFxuICAgICAgICBsZXQgYXJyID0gZm9sZGVkID8gW3RoaXMuYXJyWzBdXSA6IHRoaXMuYXJyXFxcXG4gICAgICAgIGFyci5mb3JFYWNoKCh2KSA9PiB7XFxcXG4gICAgICAgICAgICBsZXQgeyBpZCwgY2xhc3NfbmFtZSwgY2xhc3NfdXJsIH0gPSB2LFxcXFxuICAgICAgICAgICAgc2VsZWN0ZWQgPSBKU09OLnN0cmluZ2lmeSh0aGlzLmdldENsYXNzKGlkKSlcXFxcbiAgICAgICAgICAgIGNsYXNzX25hbWUuZm9yRWFjaCgobmFtZSwgaSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGxldCB1cmwgPSBjbGFzc191cmxbaV0sXFxcXG4gICAgICAgICAgICAgICAgICAgIG5vdyA9IEpTT04uc3RyaW5naWZ5KHsgbmFtZTogbmFtZSwgdXJsOiB1cmwgfSlcXFxcbiAgICAgICAgICAgICAgICBlbC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHNlbGVjdGVkID09IG5vdyA/ICfigJzigJzigJ3igJ0nICsgbmFtZS5mb250Y29sb3IodGhpcy5jb2xvcikuYm9sZCgpIDogbmFtZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBzZWxlY3RlZCA9PSBub3cgPyAnaGlrZXI6Ly9lbXB0eScgOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChzaWduLCBpZCwgbm93KSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXRWYXIoc2lnbiArIGlkLCBub3cpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5zaWduLCBpZCwgbm93KSxcXFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcXFxuICAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgZWwucHVzaCh7IGNvbF90eXBlOiB0aGlzLmJvdW5kYXJ5IH0pXFxcXG4gICAgICAgIH0pXFxcXG4gICAgfSxcXFxcbiAgICBpbml0KGNsYXNzT2JqZWN0KSB7XFxcXG4gICAgICAgIGlmICh0eXBlb2YgY2xhc3NPYmplY3QuY2xhc3NfbmFtZSA9PSAnc3RyaW5nJylcXFxcbiAgICAgICAgICAgIGNsYXNzT2JqZWN0LmNsYXNzX25hbWUgPSBjbGFzc09iamVjdC5jbGFzc19uYW1lLnNwbGl0KCcmJylcXFxcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFzc09iamVjdC5jbGFzc191cmwgPT0gJ3N0cmluZycpXFxcXG4gICAgICAgICAgICBjbGFzc09iamVjdC5jbGFzc191cmwgPSBjbGFzc09iamVjdC5jbGFzc191cmwuc3BsaXQoJyYnKS5tYXAoKHYpID0+IHYudHJpbSgpKVxcXFxuICAgICAgICByZXR1cm4gY2xhc3NPYmplY3RcXFxcbiAgICB9LFxcXFxuICAgIHB1c2goY2xhc3NPYmplY3QpIHtcXFxcbiAgICAgICAgdGhpcy5hcnIucHVzaCh0aGlzLmluaXQoY2xhc3NPYmplY3QpKVxcXFxuICAgIH0sXFxcXG4gICAgZ2V0Q2xhc3MoaWQpIHtcXFxcbiAgICAgICAgbGV0IGRlZmF1bHRDbGFzcyA9IHRoaXMuYXJyLmZpbmQoaXRlbSA9PiBpdGVtLmlkID09IGlkKVxcXFxuICAgICAgICBkZWZhdWx0Q2xhc3MgPSBKU09OLnN0cmluZ2lmeShkZWZhdWx0Q2xhc3MgPyB7XFxcXG4gICAgICAgICAgICBuYW1lOiBkZWZhdWx0Q2xhc3MuY2xhc3NfbmFtZVswXSxcXFxcbiAgICAgICAgICAgIHVybDogZGVmYXVsdENsYXNzLmNsYXNzX3VybFswXVxcXFxuICAgICAgICB9IDogeyBuYW1lOiAgJ2Nhbm5vdCBmaW5kIGlkOiAnICsgaWQgKyAnIGluIGNsYXNzVGFiOiAnICsgdGhpcy5zaWduLCB1cmw6ICcnfSlcXFxcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZ2V0VmFyKHRoaXMuc2lnbiArIGlkLCBkZWZhdWx0Q2xhc3MpKVxcXFxuICAgIH0sXFxcXG4gICAgc2V0VXJsKHVybCkge1xcXFxuICAgICAgICByZXR1cm4gdXJsLnJlcGxhY2UoL1xcXFxcXFxcJFxcXFxcXFxceyhbXn1dKilcXFxcXFxcXH0vZywgKF8sIGlkKSA9PiB0aGlzLmdldENsYXNzKGlkKS51cmwpXFxcXG4gICAgfVxcXFxufVxcXFxuLy8g55Sf5oiQ5aS06YOo5YiG57G7XFxcXG5sZXQgZnlBbGwgPSB1cmwuaW5jbHVkZXMoJ2Z5QWxsJyksXFxcXG4gICAgdGFiSGVhZGVyID0gW11cXFxcbmlmIChjbGFzc19uYW1lKSB0YWJIZWFkZXIucHVzaCh7XFxcXG4gICAgaWQ6IGZ5QWxsID8gJ2Z5QWxsJyA6ICdmeWNsYXNzJyxcXFxcbiAgICBjbGFzc19uYW1lOiBjbGFzc19uYW1lLFxcXFxuICAgIGNsYXNzX3VybDogY2xhc3NfdXJsXFxcXG59KVxcXFxuaWYgKGFyZWFfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcXFxuICAgIGlkOiBmeUFsbCA/ICdmeUFsbCcgOiAnZnlhcmVhJyxcXFxcbiAgICBjbGFzc19uYW1lOiBhcmVhX25hbWUsXFxcXG4gICAgY2xhc3NfdXJsOiBhcmVhX3VybFxcXFxufSlcXFxcbmlmICh5ZWFyX25hbWUpIHRhYkhlYWRlci5wdXNoKHtcXFxcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5eWVhcicsXFxcXG4gICAgY2xhc3NfbmFtZTogeWVhcl9uYW1lLFxcXFxuICAgIGNsYXNzX3VybDogeWVhcl91cmxcXFxcbn0pXFxcXG5pZiAoc29ydF9uYW1lKSB0YWJIZWFkZXIucHVzaCh7XFxcXG4gICAgaWQ6IGZ5QWxsID8gJ2Z5QWxsJyA6ICdmeXNvcnQnLFxcXFxuICAgIGNsYXNzX25hbWU6IHNvcnRfbmFtZSxcXFxcbiAgICBjbGFzc191cmw6IHNvcnRfdXJsXFxcXG59KVxcXFxuJC5leHBvcnRzID0ge1xcXFxuICAgIGZ5QWxsOiBmeUFsbCxcXFxcbiAgICB0YWJIZWFkZXI6IG5ldyBDbGFzc1RhYih0YWJIZWFkZXIsIHsgbmFtZTogdGl0bGUsIGZvbGQ6IHJlYWRGaWxlKCd0YWJGb2xkJyksIH0pXFxcXG59XFxcXG5cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwiaWNvbl8yX3JvdW5kXFxcIixcXFwibmFtZVxcXCI6XFxcIuiuvue9rlxcXCIsXFxcInBhdGhcXFwiOlxcXCJDb25maWdcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5hZGRMaXN0ZW5lcignb25DbG9zZScsICdjbGVhck15VmFyKFxcXFxcXFwic29ydEZsYWdcXFxcXFxcIik7cmVmcmVzaFBhZ2UoKScpXFxcXG5zZXRQYWdlVGl0bGUoJ+KamSDovbvlkIjpm4borr7nva4g4pqZJylcXFxcbmNvbnN0IFFJTkdfVElUTEUgPSBnZXRNeVZhcignbXlDb2xsZWN0aW9uJyksXFxcXG4gICAgdXJsID0gZ2V0TXlWYXIoJ3JlbW90ZVVybCcpXFxcXG5sZXQgZGF0YSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2RhdGFMb2FkP3J1bGU9JyArIFFJTkdfVElUTEUsIHRydWUpLFxcXFxuICAgIGVsID0gW3tcXFxcbiAgICAgICAgdGl0bGU6ICc8Yj4g5riF6Zmk57yT5a2Y77yM56uL5Y2z5pu05pawIDxzbWFsbD4g77yI5Z+65LqO6L+c56iL5LuT5bqT77yM5LiN6KaB6aKR57mB54K55Ye777yJJyxcXFxcbiAgICAgICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCh1cmwpID0+IHtcXFxcbiAgICAgICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly8nKSB8fCB1cmwuc3RhcnRzV2l0aCgnZmlsZTovLycpKVxcXFxuICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/ku5PlupPkuLrmnKzlnLDmlofku7bvvIzkuI3kvJrov5vooYznvJPlrZjvvIzmnKzlip/og73kuZ/ml6DmlYgnXFxcXG4gICAgICAgICAgICBkZWxldGVDYWNoZSh1cmwpXFxcXG4gICAgICAgICAgICBiYWNrKGZhbHNlKVxcXFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+W3suabtOaWsCdcXFxcbiAgICAgICAgfSwgdXJsKSxcXFxcbiAgICAgICAgaW1nOiAnaGlrZXI6Ly9pbWFnZXMvaWNvbjQnLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ2F2YXRhcidcXFxcbiAgICB9XSxcXFxcbiAgICB1cGRhdGVJbnRlcnZhbCA9IHJlYWRGaWxlKCd1cGRhdGVJbnRlcnZhbCcpIHx8ICcxJyxcXFxcbiAgICBuZXdXaW5kb3cgPSByZWFkRmlsZSgnbmV3V2luZG93JyksXFxcXG4gICAgdGFiRm9sZCA9IHJlYWRGaWxlKCd0YWJGb2xkJyksXFxcXG4gICAgZGlzYWJsZUN1c3RvbSA9IHJlYWRGaWxlKCdkaXNhYmxlQ3VzdG9tJyksXFxcXG4gICAgZWRpdE1vZGUgPSBkaXNhYmxlQ3VzdG9tID8gJ+WvvOWFpea1t+mYlCcgOiBnZXRNeVZhcignZWRpdE1vZGUnLCAn5ZCv55SoL+emgeeUqCcpXFxcXG5cXFxcbmVsLnB1c2goe1xcXFxuICAgIHRpdGxlOiAnICDwn5KhIOabtOaWsOmikeeOhzogJyArICh1cGRhdGVJbnRlcnZhbCA9PSAwID8gJ+aJi+WKqCcgOiB1cGRhdGVJbnRlcnZhbCArICflpKknKSArICcgICcsXFxcXG4gICAgdXJsOiAkKHVwZGF0ZUludGVydmFsLCAn6L6T5YWl5pu05paw6Ze06ZqU77yI5aSp77yJ77yM5Li6MOWImeaJi+WKqOabtOaWsFxcXFxcXFxcbuacrOWcsOaWh+S7tumTvuaOpeaXoOaViCcpLmlucHV0KCgpID0+IHtcXFxcbiAgICAgICAgaW5wdXQgPSBwYXJzZUludChpbnB1dClcXFxcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihpbnB1dCkpIGlucHV0ID0gMVxcXFxuICAgICAgICBlbHNlIGlmIChpbnB1dCA8IDEpIGlucHV0ID0gMFxcXFxuICAgICAgICBzYXZlRmlsZSgndXBkYXRlSW50ZXJ2YWwnLCBpbnB1dC50b1N0cmluZygpKVxcXFxuICAgICAgICByZWZyZXNoUGFnZSgpXFxcXG4gICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICB9KSxcXFxcbiAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxcXG59LCB7XFxcXG4gICAgdGl0bGU6ICcgIPCflqUg54us56uL6aaW6aG1OiAnICsgKG5ld1dpbmRvdyA/ICfmmK8nIDogJ+WQpicpICsgJyAgJyxcXFxcbiAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKG5ld1dpbmRvdykgPT4ge1xcXFxuICAgICAgICBzYXZlRmlsZSgnbmV3V2luZG93JywgbmV3V2luZG93ID8gJycgOiAnVCcpXFxcXG4gICAgICAgIHJlZnJlc2hQYWdlKClcXFxcbiAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgIH0sIG5ld1dpbmRvdyksXFxcXG4gICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcXFxufSwge1xcXFxuICAgIHRpdGxlOiAnICDwn5KgIOWIhuexu+aKmOWPoDogJyArICh0YWJGb2xkID8gJ+aYrycgOiAn5ZCmJykgKyAnICAnLFxcXFxuICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgodGFiRm9sZCkgPT4ge1xcXFxuICAgICAgICBzYXZlRmlsZSgndGFiRm9sZCcsIHRhYkZvbGQgPyAnJyA6ICdUJylcXFxcbiAgICAgICAgcmVmcmVzaFBhZ2UoKVxcXFxuICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgfSwgdGFiRm9sZCksXFxcXG4gICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcXFxufSwge1xcXFxuICAgIHRpdGxlOiAnICDwn5K8IOWkh+S7veaBouWkjSAgJyxcXFxcbiAgICB1cmw6ICQoWyflpIfku70nLCAn5oGi5aSNJ10sIDEpLnNlbGVjdCgoUUlOR19USVRMRSwgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSkgPT4ge1xcXFxuICAgICAgICBsZXQgdXJsID0gZ2V0TXlWYXIoJ3JlbW90ZVVybCcpXFxcXG4gICAgICAgIGlmICghdXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vJykgJiYgIXVybC5zdGFydHNXaXRoKCdmaWxlOi8vJykpXFxcXG4gICAgICAgICAgICB1cmwgPSAnaGlrZXI6Ly9maWxlcy9saWJzLycgKyBtZDUodXJsKSArICcuanMnXFxcXG4gICAgICAgIGVsc2UgaWYgKHVybC5zdGFydHNXaXRoKCdoaWtlcjovL3BhZ2UvJykpIHVybCA9ICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICBpZiAoaW5wdXQgPT0gJ+Wkh+S7vScpIHJldHVybiAkKCdoaWtlcjovL2ZpbGVzL3RtcC8nICsgUUlOR19USVRMRSArICdfYmFja3VwLmpzb24nLCAn6L6T5YWl5aSH5Lu96Lev5b6EJylcXFxcbiAgICAgICAgICAgIC5pbnB1dCgodXJsLCB1cGRhdGVJbnRlcnZhbCwgbmV3V2luZG93LCB0YWJGb2xkLCBkaXNhYmxlQ3VzdG9tKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHJ1bGVzID0gcmVxdWVzdCh1cmwpLFxcXFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21EYXRhID0gcmVhZEZpbGUoJ2N1c3RvbURhdGEnKVxcXFxuICAgICAgICAgICAgICAgIHdyaXRlRmlsZShpbnB1dCwgSlNPTi5zdHJpbmdpZnkoe1xcXFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVJbnRlcnZhbDogdXBkYXRlSW50ZXJ2YWwsXFxcXG4gICAgICAgICAgICAgICAgICAgIG5ld1dpbmRvdzogbmV3V2luZG93LFxcXFxuICAgICAgICAgICAgICAgICAgICB0YWJGb2xkOiB0YWJGb2xkLFxcXFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlQ3VzdG9tOiBkaXNhYmxlQ3VzdG9tLFxcXFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21EYXRhOiBjdXN0b21EYXRhLFxcXFxuICAgICAgICAgICAgICAgICAgICBydWxlczogcnVsZXNcXFxcbiAgICAgICAgICAgICAgICB9KSlcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bey5aSH5Lu977yM5rOo5oSP6Iul5LuT5bqT5Li65a2Q6aG16Z2i5YiZ5LiN5aSH5Lu9J1xcXFxuICAgICAgICAgICAgfSwgdXJsLCB1cGRhdGVJbnRlcnZhbCwgbmV3V2luZG93LCB0YWJGb2xkLCBkaXNhYmxlQ3VzdG9tKVxcXFxuICAgICAgICBlbHNlIHJldHVybiAkKCdoaWtlcjovL2ZpbGVzL3RtcC8nICsgUUlOR19USVRMRSArICdfYmFja3VwLmpzb24nLCAn6L6T5YWl5aSH5Lu96Lev5b6EJykuaW5wdXQoKHVybCkgPT4ge1xcXFxuICAgICAgICAgICAgbGV0IHsgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSwgY3VzdG9tRGF0YSwgcnVsZXMgfSA9IEpTT04ucGFyc2UocmVxdWVzdChpbnB1dCkpXFxcXG4gICAgICAgICAgICBzYXZlRmlsZSgndXBkYXRlSW50ZXJ2YWwnLCB1cGRhdGVJbnRlcnZhbClcXFxcbiAgICAgICAgICAgIHNhdmVGaWxlKCduZXdXaW5kb3cnLCBuZXdXaW5kb3cpXFxcXG4gICAgICAgICAgICBzYXZlRmlsZSgndGFiRm9sZCcsIHRhYkZvbGQpXFxcXG4gICAgICAgICAgICBzYXZlRmlsZSgnZGlzYWJsZUN1c3RvbScsIGRpc2FibGVDdXN0b20pXFxcXG4gICAgICAgICAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIGN1c3RvbURhdGEpXFxcXG4gICAgICAgICAgICBpZiAocnVsZXMpIHdyaXRlRmlsZSh1cmwsIHJ1bGVzKVxcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcXFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+W3suaBouWkje+8jOWmguaenOS4jeaDs+WQjOatpei/nOeoi+S7k+W6k++8jOWPr+S7peiuvue9ruabtOaWsOmikeeOh+S4uuaJi+WKqCdcXFxcbiAgICAgICAgfSwgdXJsKVxcXFxuICAgIH0sIFFJTkdfVElUTEUsIHVwZGF0ZUludGVydmFsLCBuZXdXaW5kb3csIHRhYkZvbGQsIGRpc2FibGVDdXN0b20pLFxcXFxuICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXFxcbn0sIHtcXFxcbiAgICB0aXRsZTogJ+KAnOKAnOKAneKAnTxmb250IGNvbG9yPVxcXFxcXFwiIzY2NjY2NlxcXFxcXFwiPjxzbWFsbD7nibnliKvpuKPosKLvvIzlsI/nqIvluo/mj5DkvpvogIXvvJpcXFxcXFxcXG4nICtcXFxcbiAgICAgICAgZGF0YS5yZWR1Y2UoKHNlbGYsIHYpID0+IHYuYXV0aG9yID8gc2VsZi5jb25jYXQodi5hdXRob3Iuc3BsaXQoJyYnKSkgOiBzZWxmLCBbXSlcXFxcbiAgICAgICAgLmZpbHRlcigodiwgaSwgYXJyKSA9PiB2ICYmIGFyci5pbmRleE9mKHYpID09IGkpLmpvaW4oJ+OAgScpLFxcXFxuICAgIHVybDogJ2hpa2VyOi8vZW1wdHknLFxcXFxuICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMSdcXFxcbn0pXFxcXG5cXFxcbmVsLnB1c2goeyBjb2xfdHlwZTogJ2xpbmUnIH0sIHtcXFxcbiAgICB0aXRsZTogJ+KAnOKAnOKAneKAnScgKyAn8J+TnScuc21hbGwoKSArICcmbmJzcCDovbvlkIjpm4boh6rlrprkuYkgJm5ic3AnLmJvbGQoKS5mb250Y29sb3IoJyM3NTc1NzUnKSArIChkaXNhYmxlQ3VzdG9tID8gJ+KdjCcgOiAn4q2VJykuc21hbGwoKSxcXFxcbiAgICB1cmw6ICQoWyhkaXNhYmxlQ3VzdG9tID8gJ+WQr+eUqCcgOiAn56aB55SoJykgKyAn5ZCI6ZuG6Ieq5a6a5LmJJywgJ+a4hemZpOiHquWumuS5ieaVsOaNriddLCAxKS5zZWxlY3QoKCkgPT4ge1xcXFxuICAgICAgICBpZiAoaW5wdXQgPT0gJ+a4hemZpOiHquWumuS5ieaVsOaNricpIHtcXFxcbiAgICAgICAgICAgIGRlbGV0ZUZpbGUoJ2N1c3RvbURhdGEnKVxcXFxuICAgICAgICB9IGVsc2UgaWYgKGlucHV0ID09ICflkK/nlKjlkIjpm4boh6rlrprkuYknKSB7XFxcXG4gICAgICAgICAgICBzYXZlRmlsZSgnZGlzYWJsZUN1c3RvbScsICcnKVxcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ2Rpc2FibGVDdXN0b20nLCAnVCcpXFxcXG4gICAgICAgICAgICBpbnB1dCArPSAnXFxcXFxcXFxu5bCP56iL5bqP5ZCv55SoL+emgeeUqOOAgemHjeaWsOaOkuW6j+etieaTjeS9nOWdh+S4jeS8muS9k+eOsOWcqOmmlumhteWwj+eoi+W6j+WIl+ihqOS4rSdcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXFxcbiAgICAgICAgcmV0dXJuICd0b2FzdDovL+W3sicgKyBpbnB1dFxcXFxuICAgIH0pLFxcXFxuICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxcXG4gICAgZXh0cmE6IHsgbGluZVZpc2libGU6IGZhbHNlIH1cXFxcbn0pO1xcXFxuKGRpc2FibGVDdXN0b20gPyBbJ+WvvOWFpea1t+mYlCddIDogWyflkK/nlKgv56aB55SoJywgJ+mHjeaWsOaOkuW6jycsICfmm7TmlLnlm77moIcnLCAn5a+85YWl5rW36ZiUJ10pLmZvckVhY2goKHYpID0+IHtcXFxcbiAgICBlbC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IHYgPT0gZWRpdE1vZGUgPyAn4oCc4oCc4oCd4oCdJyArIHYuYm9sZCgpLmZvbnRjb2xvcignIzEyYjY2OCcpIDogdixcXFxcbiAgICAgICAgdXJsOiB2ID09IGVkaXRNb2RlID8gJ2hpa2VyOi8vZW1wdHknIDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgodikgPT4ge1xcXFxuICAgICAgICAgICAgcHV0TXlWYXIoJ2VkaXRNb2RlJywgdilcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcXFxuICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICB9LCB2KSxcXFxcbiAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcXFxuICAgIH0pXFxcXG59KTtcXFxcbmlmIChlZGl0TW9kZSA9PSAn5a+85YWl5rW36ZiUJykgZWwucHVzaCh7XFxcXG4gICAgdGl0bGU6ICflhajpg6jlr7zlhaUnLFxcXFxuICAgIHVybDogJ+a1t+mYlOinhueVjO+/pWhvbWVfcnVsZV91cmzvv6UnICsgKHVybC5zdGFydHNXaXRoKCdoaWtlcjovLycpIHx8IHVybC5zdGFydHNXaXRoKCdmaWxlOi8vJykgPyB1cmwgOiAnaGlrZXI6Ly9maWxlcy9saWJzLycgKyBtZDUodXJsKSArICcuanMnKSxcXFxcbiAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnLFxcXFxuICAgIGV4dHJhOiB7IGxpbmVWaXNpYmxlOiBmYWxzZSB9XFxcXG59KTtcXFxcbihkaXNhYmxlQ3VzdG9tID8gZGF0YSA6IEpTT04ucGFyc2UocmVhZEZpbGUoJ2N1c3RvbURhdGEnKSB8fCAnW10nKSkuZm9yRWFjaCgodiwgaSkgPT4ge1xcXFxuICAgIGxldCBkID0geyB0aXRsZTogdi50aXRsZSwgaW1nOiBkYXRhW2ldLmljb24gfVxcXFxuICAgIHN3aXRjaCAoZWRpdE1vZGUpIHtcXFxcbiAgICAgICAgY2FzZSAn5ZCv55SoL+emgeeUqCc6XFxcXG4gICAgICAgICAgICBkLnRpdGxlID0gKHYudmlzaWJsZSA/ICfwn5+iICAnIDogJ/CflLQgICcpICsgZC50aXRsZVxcXFxuICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChpKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHJ1bGVzID0gSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpXFxcXG4gICAgICAgICAgICAgICAgcnVsZXNbaV0udmlzaWJsZSA9ICFydWxlc1tpXS52aXNpYmxlXFxcXG4gICAgICAgICAgICAgICAgc2F2ZUZpbGUoJ2N1c3RvbURhdGEnLCBKU09OLnN0cmluZ2lmeShydWxlcykpXFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICAgICAgfSwgaSlcXFxcbiAgICAgICAgICAgIGJyZWFrXFxcXG4gICAgICAgIGNhc2UgJ+mHjeaWsOaOkuW6jyc6XFxcXG4gICAgICAgICAgICBsZXQgc29ydEZsYWcgPSBwYXJzZUludChnZXRNeVZhcignc29ydEZsYWcnLCAnLTEnKSlcXFxcbiAgICAgICAgICAgIGQudGl0bGUgPSAoc29ydEZsYWcgPT0gaSA/ICfwn5SDICAnIDogJycpICsgZC50aXRsZVxcXFxuICAgICAgICAgICAgaWYgKHNvcnRGbGFnID09IC0xKVxcXFxuICAgICAgICAgICAgICAgIGQudXJsID0gJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoaSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcignc29ydEZsYWcnLCBpLnRvU3RyaW5nKCkpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v6YCJ5oup6KaB56e75Yqo5Yiw55qE5L2N572uJ1xcXFxuICAgICAgICAgICAgICAgIH0sIGkpXFxcXG4gICAgICAgICAgICBlbHNlXFxcXG4gICAgICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChvbGRJbmRleCwgbmV3SW5kZXgpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJ1bGVzID0gSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzLnNwbGljZShuZXdJbmRleCwgMCwgcnVsZXMuc3BsaWNlKG9sZEluZGV4LCAxKVswXSlcXFxcbiAgICAgICAgICAgICAgICAgICAgc2F2ZUZpbGUoJ2N1c3RvbURhdGEnLCBKU09OLnN0cmluZ2lmeShydWxlcykpXFxcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKCdzb3J0RmxhZycsICctMScpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgICAgICAgICAgfSwgc29ydEZsYWcsIGkpXFxcXG4gICAgICAgICAgICBicmVha1xcXFxuICAgICAgICBjYXNlICfmm7TmlLnlm77moIcnOlxcXFxuICAgICAgICAgICAgZC51cmwgPSAkKHYuaWNvbiB8fCAnJywgJ+i+k+WFpeaWsOWbvuagh+WcsOWdgOaIluminOiJsuS7o+egge+8micpLmlucHV0KChpKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHJ1bGVzID0gSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpXFxcXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0KVxcXFxuICAgICAgICAgICAgICAgICAgICBydWxlc1tpXS5pY29uID0gaW5wdXRcXFxcbiAgICAgICAgICAgICAgICBlbHNlXFxcXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBydWxlc1tpXS5pY29uXFxcXG4gICAgICAgICAgICAgICAgc2F2ZUZpbGUoJ2N1c3RvbURhdGEnLCBKU09OLnN0cmluZ2lmeShydWxlcykpXFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICAgICAgfSwgaSlcXFxcbiAgICAgICAgICAgIGJyZWFrXFxcXG4gICAgICAgIGNhc2UgJ+WvvOWFpea1t+mYlCc6XFxcXG4gICAgICAgICAgICBkLnVybCA9ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGkpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2RhdGFMb2FkP3J1bGU9JyArIGdldE15VmFyKCdteUNvbGxlY3Rpb24nKSwgdHJ1ZSlcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3J1bGU6Ly8nICsgYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KGRhdGFbaV0pKVxcXFxuICAgICAgICAgICAgfSwgaSlcXFxcbiAgICAgICAgICAgIGJyZWFrXFxcXG4gICAgfVxcXFxuICAgIGVsLnB1c2goZClcXFxcbn0pXFxcXG5zZXRSZXN1bHQoZWwpXFxcXG5cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLpobXpnaLovb3lhaVcXFwiLFxcXCJwYXRoXFxcIjpcXFwiZnJhbWVMb2FkXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuY29uc3QgUUlOR19USVRMRSA9IGdldE15VmFyKCdteUNvbGxlY3Rpb24nKVxcXFxudmFyIG15Q29sbF9lbCA9IFtdXFxcXG5ldmFsKEpTT04ucGFyc2UoZmV0Y2goJ2hpa2VyOi8vcGFnZS9oaWphY2tFbnY/cnVsZT0nICsgUUlOR19USVRMRSkpLnJ1bGUpXFxcXG5cXFxcbmlmICghaXNJbmRleCkge1xcXFxuICAgIGlmIChwYWdlVGl0bGUpIHNldFBhZ2VUaXRsZShwYWdlVGl0bGUpXFxcXG4gICAgc2V0TGFzdENoYXB0ZXJSdWxlKG9yaVJVTEUubGFzdF9jaGFwdGVyX3J1bGUpXFxcXG4gICAgTVlfUEFSQU1TID0gTVlfUlVMRS5wYXJhbXNcXFxcbn0gZWxzZSBpZiAoTVlfUEFHRSA9PSAxKSB7XFxcXG4gICAgdGFiSGVhZGVyLmxvYWQobXlDb2xsX2VsKVxcXFxuICAgIGlmIChSVUxFLnNlYXJjaF91cmwpIG15Q29sbF9lbC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi5pCc57SiXFxcXFxcXCIsXFxcXG4gICAgICAgIGRlc2M6IFxcXFxcXFwi6L+Z5piv6L275ZCI6ZuG55qE5pCc57Si5ZOmfn5cXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiAnXFxcXFxcXCJoaWtlcjovL3NlYXJjaD9zPVxcXFxcXFwiK2lucHV0JyxcXFxcbiAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgIHJ1bGVzOiAkLnRvU3RyaW5nKChRSU5HX1RJVExFLCB0aXRsZSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGxldCBydWxlcyA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2RhdGFMb2FkP3J1bGU9JyArIFFJTkdfVElUTEUpXFxcXG4gICAgICAgICAgICAgICAgcnVsZXMgPSBbcnVsZXMuZmluZCgodikgPT4gdi50aXRsZSA9PSB0aXRsZSldXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJ1bGVzKVxcXFxuICAgICAgICAgICAgfSwgUUlOR19USVRMRSwgUlVMRS50aXRsZSksXFxcXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGdldE15VmFyKCdzZWFyY2hLZXknLCAnJyksXFxcXG4gICAgICAgICAgICBvbkNoYW5nZTogXFxcXFxcXCJwdXRNeVZhcignc2VhcmNoS2V5JyxpbnB1dClcXFxcXFxcIlxcXFxuICAgICAgICB9LFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJpbnB1dFxcXFxcXFwiLFxcXFxuICAgIH0pXFxcXG59XFxcXG4vLyDmraPmlofop6PmnpBcXFxcbnZhciB7XFxcXG4gICAgcGFyYW1IYW5kbGUsXFxcXG4gICAgcnVuUHJlUnVsZSxcXFxcbiAgICBnZW5FeFVybCxcXFxcbiAgICBoaWphY2tMYXp5UnVsZVxcXFxufSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKVxcXFxucnVuUHJlUnVsZShvcmlSVUxFLnByZVJ1bGUpXFxcXG5pZiAoTVlfUlVMRS5maW5kX3J1bGUuc3RhcnRzV2l0aCgnanM6JykpIHtcXFxcbiAgICBsZXQgeyBoaWphY2tFbCB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZnVuY1Rvb2xzP3J1bGU9JyArIFFJTkdfVElUTEUpXFxcXG4gICAgc2V0UmVzdWx0ID0gZnVuY3Rpb24ocGFyYW0wLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zKSB7XFxcXG4gICAgICAgIHBhcmFtMSA9IENBTExCQUNLX0tFWVxcXFxuICAgICAgICBwYXJhbTIgPSBNWV9SVUxFXFxcXG4gICAgICAgIHBhcmFtMyA9IE1ZX1RZUEVcXFxcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW0wLmRhdGEpKSBwYXJhbTAgPSBwYXJhbTAuZGF0YVxcXFxuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShteUNvbGxfZWwsIHBhcmFtMC5tYXAoaGlqYWNrRWwpKVxcXFxuICAgICAgICBtZXRob2Rfc2V0UmVzdWx0Lmludm9rZShqYXZhQ29udGV4dCwgbXlDb2xsX2VsLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zKVxcXFxuICAgIH1cXFxcbiAgICBzZXRIb21lUmVzdWx0ID0gc2V0UmVzdWx0XFxcXG4gICAgc2V0U2VhcmNoUmVzdWx0ID0gc2V0UmVzdWx0XFxcXG5cXFxcbiAgICBldmFsKE1ZX1JVTEUuZmluZF9ydWxlLnNsaWNlKDMpKVxcXFxufSBlbHNlIHtcXFxcbiAgICBsZXQgeyBydW5Db2RlIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9mdW5jVG9vbHM/cnVsZT0nICsgUUlOR19USVRMRSksXFxcXG4gICAgICAgIFtfLCBmaW5kUnVsZSwgZGV0YWlsRmluZFJ1bGVdID0gTVlfUlVMRS5maW5kX3J1bGUubWF0Y2goL14oW1xcXFxcXFxcc1xcXFxcXFxcU10qPykoPzo9PT4oW1xcXFxcXFxcc1xcXFxcXFxcU10qKSk/JC8pXFxcXG4gICAgZmluZFJ1bGUgPSBmaW5kUnVsZS5zcGxpdCgnOycpXFxcXG4gICAgcGFyc2VEb21Gb3JBcnJheShnZXRSZXNDb2RlKCksIGZpbmRSdWxlLnNoaWZ0KCkpLmZvckVhY2goKGRhdGEpID0+IHtcXFxcbiAgICAgICAgbGV0IFt0aXRsZSwgaW1nLCBkZXNjLCB1cmxdID0gZmluZFJ1bGUubWFwKCh2LCBpKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgPT0gJyonKSByZXR1cm4gJydcXFxcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB2ID0gKGkgPT0gMSB8fCBpID09IDMpID9cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRG9tKGRhdGEsIHYpIDpcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRG9tRm9ySHRtbChkYXRhLCB2KVxcXFxuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPSAzKSB2ID0gcnVuQ29kZSh2KVxcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdlxcXFxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgcmV0dXJuICcnIH1cXFxcbiAgICAgICAgICAgIH0pLFxcXFxuICAgICAgICAgICAgcmVzID0ge1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSwgdXJsOiB1cmwsXFxcXG4gICAgICAgICAgICAgICAgZGVzYzogZGVzYywgaW1nOiBpbWcsXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IE1ZX1JVTEUuY29sX3R5cGVcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgaWYgKHJlcy51cmwpIHtcXFxcbiAgICAgICAgICAgIGlmIChyZXMudXJsLmluY2x1ZGVzKCdAbGF6eVJ1bGU9JykpIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgcmVJbmRleCA9IHJlcy51cmwuaW5kZXhPZignLmpzOicpXFxcXG4gICAgICAgICAgICAgICAgaWYgKHJlSW5kZXggPj0gMCkgcmVzLnVybCA9IHJlcy51cmwuc2xpY2UoMCwgcmVJbmRleCkgKyAnLmpzOicgKyBoaWphY2tMYXp5UnVsZSArICc7JyArIHJlcy51cmwuc2xpY2UocmVJbmRleCArIDQpXFxcXG4gICAgICAgICAgICB9IGVsc2UgIGlmIChkZXRhaWxGaW5kUnVsZSkge1xcXFxuICAgICAgICAgICAgICAgIHJlcy5leHRyYSA9IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBnZW5FeFVybCh1cmwpLFxcXFxuICAgICAgICAgICAgICAgICAgICBSVUxFOiBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmFzc2lnbihnZW5NeVJ1bGUoKSwgeyBkZXRhaWxfZmluZF9ydWxlOiBkZXRhaWxGaW5kUnVsZSB9KSkpLFxcXFxuICAgICAgICAgICAgICAgICAgICBwYWdlVGl0bGU6IGlzSW5kZXggJiYgdGl0bGVcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgcmVzLnVybCA9ICdoaWtlcjovL3BhZ2UvZnJhbWVMb2FkP3J1bGU9JyArIFFJTkdfVElUTEVcXFxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTVlfUlVMRS5kZXRhaWxfZmluZF9ydWxlKSB7XFxcXG4gICAgICAgICAgICAgICAgcmVzLmV4dHJhID0ge1xcXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGdlbkV4VXJsKHVybCksXFxcXG4gICAgICAgICAgICAgICAgICAgIFJVTEU6IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShnZW5NeVJ1bGUoKSkpLFxcXFxuICAgICAgICAgICAgICAgICAgICBwYWdlVGl0bGU6IGlzSW5kZXggJiYgdGl0bGVcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgcmVzLnVybCA9ICdoaWtlcjovL3BhZ2UvZnJhbWVMb2FkP3J1bGU9JyArIFFJTkdfVElUTEVcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBteUNvbGxfZWwucHVzaChyZXMpXFxcXG4gICAgfSlcXFxcbiAgICBzZXRSZXN1bHQobXlDb2xsX2VsKVxcXFxufVxcXFxuXFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5pWw5o2u6L295YWlXFxcIixcXFwicGF0aFxcXCI6XFxcImRhdGFMb2FkXFxcIixcXFwicnVsZVxcXCI6XFxcImxldCBzaG93QWxsID0gJC5pbXBvcnRQYXJhbSxcXFxcbiAgICB1cmwgPSBnZXRNeVZhcigncmVtb3RlVXJsJyksXFxcXG4gICAgZGF0YSA9IFtdXFxcXG5pZiAodXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vJykgfHwgdXJsLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSkge1xcXFxuICAgIC8vIOWmguaenOS4uuacrOWcsOaWh+S7tuWImeS4jei/m+ihjOe8k+WtmFxcXFxuICAgIHRyeSB7XFxcXG4gICAgICAgIGxldCBvcmlEYXRhID0gZmV0Y2godXJsKVxcXFxuICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vcGFnZS8nKSlcXFxcbiAgICAgICAgICAgIG9yaURhdGEgPSBKU09OLnBhcnNlKG9yaURhdGEpLnJ1bGVcXFxcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2Uob3JpRGF0YSlcXFxcbiAgICB9IGNhdGNoIChlKSB7fVxcXFxufSBlbHNlIHtcXFxcbiAgICAvLyDojrflj5bov5znqIvmlbDmja7vvIzmo4Dmn6Xpl7TpmpTpu5jorqTkuIDlpKlcXFxcbiAgICBsZXQgaW50ZXJ2YWwgPSBwYXJzZUludChyZWFkRmlsZSgndXBkYXRlSW50ZXJ2YWwnKSB8fCAnMScpLFxcXFxuICAgICAgICBvbGREYXRhID0gZmV0Y2goJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJyksXFxcXG4gICAgICAgIHJlbW90ZURhdGEgPSBbXVxcXFxuICAgIGlmIChpbnRlcnZhbCA9PSAwKSBpbnRlcnZhbCA9IC0xXFxcXG4gICAgdHJ5IHsgcmVtb3RlRGF0YSA9IEpTT04ucGFyc2UoZmV0Y2hDYWNoZSh1cmwsIDI0ICogaW50ZXJ2YWwsIHsgdGltZW91dDogNTAwMDAgfSkpIH0gY2F0Y2ggKGUpIHt9XFxcXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJlbW90ZURhdGEpKSByZW1vdGVEYXRhID0gW11cXFxcbiAgICBpZiAocmVtb3RlRGF0YS5sZW5ndGggPCAzKSB7XFxcXG4gICAgICAgIGxvZygn5pyq6I635Y+W5Yiw5pWw5o2uJylcXFxcbiAgICAgICAgaWYgKG9sZERhdGEpIHdyaXRlRmlsZSgnaGlrZXI6Ly9maWxlcy9saWJzLycgKyBtZDUodXJsKSArICcuanMnLCBvbGREYXRhKVxcXFxuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShvbGREYXRhIHx8ICdbXScpXFxcXG4gICAgfSBlbHNlIHtcXFxcbiAgICAgICAgbG9nKCflt7Lojrflj5bliLDmlbDmja4nKVxcXFxuICAgICAgICBkYXRhID0gcmVtb3RlRGF0YVxcXFxuICAgIH1cXFxcbn1cXFxcbmRhdGEgPSBkYXRhLmZpbHRlcigodikgPT4gdi50aXRsZSAhPSBnZXRNeVZhcignbXlDb2xsZWN0aW9uJykgJiYgISh2LmF1dGhvciB8fCAnJykuaW5jbHVkZXMoJ+i9u+WQiOmbhueUn+aIkOWZqCcpKVxcXFxuaWYgKHJlYWRGaWxlKCdkaXNhYmxlQ3VzdG9tJykpICQuZXhwb3J0cyA9IGRhdGFcXFxcbmVsc2UgeyAvLyDlhpnlhaXoh6rlrprkuYnmlbDmja5cXFxcbiAgICBsZXQgY3VzdG9tRGF0YSA9IEpTT04ucGFyc2UocmVhZEZpbGUoJ2N1c3RvbURhdGEnKSB8fCAnW10nKSxcXFxcbiAgICAgICAgcmV3cml0ZURhdGEgPSBbXVxcXFxuICAgIGN1c3RvbURhdGEgPSBjdXN0b21EYXRhLnJlZHVjZSgoc2VsZiwgdikgPT4ge1xcXFxuICAgICAgICBsZXQgaW5kZXggPSBkYXRhLmZpbmRJbmRleCgodnYpID0+IHYudGl0bGUgPT0gdnYudGl0bGUpXFxcXG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XFxcXG4gICAgICAgICAgICBzZWxmLnB1c2godilcXFxcbiAgICAgICAgICAgIGxldCBydWxlID0gZGF0YS5zcGxpY2UoaW5kZXgsIDEpWzBdXFxcXG4gICAgICAgICAgICBpZiAoc2hvd0FsbCB8fCB2LnZpc2libGUpXFxcXG4gICAgICAgICAgICAgICAgcmV3cml0ZURhdGEucHVzaChPYmplY3QuYXNzaWduKHJ1bGUsIHYpKVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiBzZWxmXFxcXG4gICAgfSwgW10pXFxcXG4gICAgZGF0YS5mb3JFYWNoKCh2KSA9PiBjdXN0b21EYXRhLnB1c2goeyB0aXRsZTogdi50aXRsZSwgdmlzaWJsZTogdHJ1ZSB9KSlcXFxcbiAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KGN1c3RvbURhdGEpKVxcXFxuICAgICQuZXhwb3J0cyA9IHJld3JpdGVEYXRhLmNvbmNhdChkYXRhKVxcXFxufVxcXFxuXFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi546v5aKD5Yqr5oyBXFxcIixcXFwicGF0aFxcXCI6XFxcImhpamFja0VudlxcXCIsXFxcInJ1bGVcXFwiOlxcXCJ2YXIgeyBSVUxFLCBpc0luZGV4LCBwYWdlVGl0bGUgfSA9IE1ZX1BBUkFNU1xcXFxuUlVMRSA9IEpTT04ucGFyc2UoYmFzZTY0RGVjb2RlKFJVTEUpKVxcXFxudmFyIG9yaVJVTEUgPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9kYXRhTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFKS5maW5kKCh2KSA9PiB2LnRpdGxlID09IFJVTEUudGl0bGUpXFxcXG5pZiAoaXNJbmRleCkge1xcXFxuICAgIFJVTEUgPSBvcmlSVUxFXFxcXG4gICAgdmFyIHsgdGFiSGVhZGVyLCBmeUFsbCB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvQ2xhc3NUYWI/cnVsZT0nICsgUUlOR19USVRMRSwgT2JqZWN0LmFzc2lnbih7IFFJTkdfVElUTEU6IFFJTkdfVElUTEUgfSwgUlVMRSkpXFxcXG4gICAgLy8g5aSE55CGTVlfUlVMRVxcXFxuICAgIE1ZX1JVTEUuY2xhc3NfdXJsID0gdGFiSGVhZGVyLmdldENsYXNzKGZ5QWxsID8gJ2Z5QWxsJyA6ICdmeWNsYXNzJykudXJsXFxcXG4gICAgTVlfUlVMRS5hcmVhX3VybCA9IGZ5QWxsID8gTVlfUlVMRS5jbGFzc191cmwgOiB0YWJIZWFkZXIuZ2V0Q2xhc3MoJ2Z5YXJlYScpLnVybFxcXFxuICAgIE1ZX1JVTEUueWVhcl91cmwgPSBmeUFsbCA/IE1ZX1JVTEUuY2xhc3NfdXJsIDogdGFiSGVhZGVyLmdldENsYXNzKCdmeXllYXInKS51cmxcXFxcbiAgICBNWV9SVUxFLnNvcnRfdXJsID0gZnlBbGwgPyBNWV9SVUxFLmNsYXNzX3VybCA6IHRhYkhlYWRlci5nZXRDbGFzcygnZnlzb3J0JykudXJsXFxcXG4gICAgTVlfUlVMRS51cmwgPSBSVUxFLnVybFxcXFxuICAgIE1ZX1JVTEUuY29sX3R5cGUgPSBSVUxFLmNvbF90eXBlXFxcXG4gICAgTVlfUlVMRS5kZXRhaWxfY29sX3R5cGUgPSBSVUxFLmRldGFpbF9jb2xfdHlwZVxcXFxuICAgIE1ZX1JVTEUuZmluZF9ydWxlID0gUlVMRS5maW5kX3J1bGVcXFxcbiAgICBNWV9SVUxFLmRldGFpbF9maW5kX3J1bGUgPSBSVUxFLmRldGFpbF9maW5kX3J1bGVcXFxcbiAgICBNWV9SVUxFLnBhcmFtcyA9IHt9XFxcXG59IGVsc2Uge1xcXFxuICAgIFJVTEUucGFnZXMgPSBvcmlSVUxFLnBhZ2VzXFxcXG4gICAgLy8g5aSE55CGTVlfUlVMRVxcXFxuICAgIE1ZX1JVTEUudXJsID0gTVlfUEFSQU1TLnVybFxcXFxuICAgIE1ZX1JVTEUuY29sX3R5cGUgPSBSVUxFLmRldGFpbF9jb2xfdHlwZVxcXFxuICAgIE1ZX1JVTEUuZmluZF9ydWxlID0gUlVMRS5kZXRhaWxfZmluZF9ydWxlXFxcXG4gICAgTVlfUlVMRS5wYXJhbXMgPSBSVUxFLnBhcmFtc1xcXFxufVxcXFxuTVlfUlVMRS5wYWdlcyA9IFJVTEUucGFnZXNcXFxcbk1ZX1JVTEUucGFnZUxpc3QgPSBKU09OLnBhcnNlKE1ZX1JVTEUucGFnZXMgfHwgJ1tdJylcXFxcbk1ZX1JVTEUudGl0bGUgPSBSVUxFLnRpdGxlXFxcXG5NWV9SVUxFLnVhID0gUlVMRS51YVxcXFxuLy8g6L295YWl5Ye95pWw5bel5YW3XFxcXG52YXIgeyBnZW5NeVJ1bGUgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFLCB7XFxcXG4gICAgUUlOR19USVRMRTogUUlOR19USVRMRSxcXFxcbiAgICBNWV9SVUxFOiBNWV9SVUxFLFxcXFxuICAgIGlzSW5kZXg6IGlzSW5kZXhcXFxcbn0pXFxcXG4vLyDpmLLmraJyZXF1aXJl5aSa5qyh6L+Q6KGMXFxcXG5jb25zdCBteUNvbGxfcmVxdWlyZWQgPSB7fVxcXFxucmVxdWlyZSA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00KSB7XFxcXG4gICAgaWYgKG15Q29sbF9yZXF1aXJlZFtwYXJhbTBdKSByZXR1cm5cXFxcbiAgICBteUNvbGxfcmVxdWlyZWRbcGFyYW0wXSA9IHRydWVcXFxcbiAgICBwYXJhbTIgPSBwYXJhbTIgIT0gbnVsbCA/IHBhcmFtMiA6IDBcXFxcbiAgICBwYXJhbTMgPSBNWV9USUNLRVRcXFxcbiAgICBwYXJhbTQgPSBldmFsXFxcXG4gICAgcmV0dXJuIG1ldGhvZF9yZXF1aXJlLmludm9rZShqYXZhQ29udGV4dCwgcGFyYW0wLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zLCBwYXJhbTQpXFxcXG59XFxcXG5yZXF1aXJlQ2FjaGUgPSBmdW5jdGlvbihwYXJhbTAsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMsIHBhcmFtNCwgcGFyYW01KSB7XFxcXG4gICAgaWYgKG15Q29sbF9yZXF1aXJlZFtwYXJhbTBdKSByZXR1cm5cXFxcbiAgICBteUNvbGxfcmVxdWlyZWRbcGFyYW0wXSA9IHRydWVcXFxcbiAgICBwYXJhbTMgPSBwYXJhbTMgIT0gbnVsbCA/IHBhcmFtMyA6IDBcXFxcbiAgICBwYXJhbTQgPSBNWV9USUNLRVRcXFxcbiAgICBwYXJhbTUgPSBldmFsXFxcXG4gICAgcmV0dXJuIG1ldGhvZF9yZXF1aXJlQ2FjaGUuaW52b2tlKGphdmFDb250ZXh0LCBwYXJhbTAsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMsIHBhcmFtNCwgcGFyYW01KVxcXFxufVxcXFxucmMgPSByZXF1aXJlQ2FjaGVcXFxcbi8vIOacgOaWsOeroOiKguinhOWImeeOr+Wig+WKq+aMgVxcXFxuc2V0TGFzdENoYXB0ZXJSdWxlID0gZnVuY3Rpb24ocGFyYW0wKSB7XFxcXG4gICAgaWYgKHBhcmFtMC5zdGFydHNXaXRoKFxcXFxcXFwianM6XFxcXFxcXCIpKSB7XFxcXG4gICAgICAgIHBhcmFtMCA9ICdqczonICsgJC50b1N0cmluZygoUUlOR19USVRMRSwgTVlfUEFSQU1TKSA9PiB7XFxcXG4gICAgICAgICAgICBldmFsKEpTT04ucGFyc2UoZmV0Y2goJ2hpa2VyOi8vcGFnZS9oaWphY2tFbnY/cnVsZT0nICsgUUlOR19USVRMRSkpLnJ1bGUpXFxcXG4gICAgICAgICAgICB2YXIgeyBydW5QcmVSdWxlIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9mdW5jVG9vbHM/cnVsZT0nICsgUUlOR19USVRMRSlcXFxcbiAgICAgICAgICAgIHJ1blByZVJ1bGUob3JpUlVMRS5wcmVSdWxlKVxcXFxuICAgICAgICB9LCBRSU5HX1RJVExFLCB7IHVybDogTVlfUlVMRS51cmwsIFJVTEU6IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShnZW5NeVJ1bGUoKSkpLCBpc0luZGV4OiBpc0luZGV4IH0pICsgJzsnICsgcGFyYW0wLnNsaWNlKDMpXFxcXG4gICAgfVxcXFxuICAgIG1ldGhvZF9zZXRMYXN0Q2hhcHRlclJ1bGUuaW52b2tlKGphdmFDb250ZXh0LCBwYXJhbTApXFxcXG59XFxcXG4vLyDliqjmgIHmlrDlop7lh73mlbDliqvmjIFcXFxcbmFkZEl0ZW1BZnRlciA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xKSB7XFxcXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW0xKSkgcGFyYW0xID0gcGFyYW0xLm1hcChoaWphY2tFbClcXFxcbiAgICBlbHNlIHBhcmFtMSA9IGhpamFja0VsKHBhcmFtMSlcXFxcbiAgICBtZXRob2RfYWRkSXRlbUFmdGVyLmludm9rZShqYXZhQ29udGV4dCwgcGFyYW0wLCBwYXJhbTEpXFxcXG59XFxcXG5hZGRJdGVtQmVmb3JlID0gZnVuY3Rpb24ocGFyYW0wLCBwYXJhbTEpIHtcXFxcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbTEpKSBwYXJhbTEgPSBwYXJhbTEubWFwKGhpamFja0VsKVxcXFxuICAgIGVsc2UgcGFyYW0xID0gaGlqYWNrRWwocGFyYW0xKVxcXFxuICAgIG1ldGhvZF9hZGRJdGVtQmVmb3JlLmludm9rZShqYXZhQ29udGV4dCwgcGFyYW0wLCBwYXJhbTEpXFxcXG59XFxcXG5cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLlh73mlbDlt6XlhbdcXFwiLFxcXCJwYXRoXFxcIjpcXFwiZnVuY1Rvb2xzXFxcIixcXFwicnVsZVxcXCI6XFxcImxldCB7IFFJTkdfVElUTEUsIE1ZX1JVTEUsIGlzSW5kZXggfSA9ICQuaW1wb3J0UGFyYW1cXFxcbmlmICghTVlfUlVMRSkgTVlfUlVMRSA9IHt9XFxcXG5cXFxcbmZ1bmN0aW9uIHJ1bkNvZGUocnVsZSkge1xcXFxuICAgIHRyeSB7XFxcXG4gICAgICAgIGxldCBbaW5wdXQsIGNvZGVdID0gcnVsZS5zcGxpdCgnLmpzOicpXFxcXG4gICAgICAgIHJldHVybiBjb2RlID8gZXZhbChjb2RlKSA6IHJ1bGVcXFxcbiAgICB9IGNhdGNoIChlKSB7IHJldHVybiBydWxlIH1cXFxcbn1cXFxcbi8vIOmmlumhtemTvuaOpeabv+aNouWIhuexu1xcXFxuZnVuY3Rpb24gaW5kZXhVcmwocGFyYW0pIHtcXFxcbiAgICBNWV9SVUxFID0gSlNPTi5wYXJzZShiYXNlNjREZWNvZGUoTVlfUlVMRSkpXFxcXG4gICAgbGV0IHBhZ2VOdW0gPSBwYXJzZUludChwYXJhbS5zcGxpdCgnIyMjJylbMV0pLFxcXFxuICAgICAgICB1cmwgPSBNWV9SVUxFLnVybCxcXFxcbiAgICAgICAgeyBmeUFsbCwgdGFiSGVhZGVyIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9DbGFzc1RhYj9ydWxlPScgKyBRSU5HX1RJVExFLCBPYmplY3QuYXNzaWduKHsgUUlOR19USVRMRTogUUlOR19USVRMRSB9LCBNWV9SVUxFKSlcXFxcblxcXFxuICAgIHVybCA9IHRhYkhlYWRlci5zZXRVcmwoZnlBbGwgPyB1cmwucmVwbGFjZSgvZnlBbGwvZywgJyQke2Z5QWxsfScpIDogdXJsLnJlcGxhY2UoL2Z5KGNsYXNzfGFyZWF8eWVhcnxzb3J0KS9nLCAnJCR7ZnkkMX0nKSlcXFxcbiAgICB1cmwgPSB1cmwucmVwbGFjZSgvZnlwYWdlKD86QCgtP1xcXFxcXFxcZCspQCk/KD86XFxcXFxcXFwqKFxcXFxcXFxcZCspQCk/L2csIChfLCBzdGFydCwgc3BhY2UpID0+IHBhcnNlSW50KHN0YXJ0IHx8IDApICsgMSArIChwYWdlTnVtIC0gMSkgKiBwYXJzZUludChzcGFjZSB8fCAxKSlcXFxcbiAgICB1cmwgPSAvXihbXFxcXFxcXFxzXFxcXFxcXFxTXSo/KSg/OlxcXFxcXFxcW2ZpcnN0UGFnZT0oW1xcXFxcXFxcc1xcXFxcXFxcU10qPylcXFxcXFxcXF0pPyg/OihcXFxcXFxcXC5qczpbXFxcXFxcXFxzXFxcXFxcXFxTXSo/KSk/JC8uZXhlYyh1cmwpXFxcXG4gICAgaWYgKHBhZ2VOdW0gPT0gMSAmJiB1cmxbMl0pIHVybFsxXSA9IHVybFsyXVxcXFxuICAgIGlmICh1cmxbM10gJiYgIXVybFsxXS5pbmNsdWRlcygnLmpzOicpKSB1cmxbMV0gKz0gdXJsWzNdXFxcXG4gICAgcmV0dXJuIHJ1bkNvZGUodXJsWzFdKVxcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBwYXJhbUhhbmRsZSh1cmxQYXJhbSwgdWEsIHVybFRtcCkge1xcXFxuICAgIGxldCBjaGFyc2V0LCBwYXJhbVRtcFxcXFxuICAgIHRyeSB7IC8vIOmTvuaOpeeahOe8lueggeOAgVVB5ZKMUmVmZXJlcuW6lOivpeaYr+mmluWFiOe7p+aJv+mmlumhtemTvuaOpVxcXFxuICAgICAgICBbLCAsIGNoYXJzZXQsIHBhcmFtVG1wXSA9IHVybFRtcC5zcGxpdCgnOycpXFxcXG4gICAgICAgIHBhcmFtVG1wID0gcGFyYW1UbXAubWF0Y2goL157KC4qKX0kLylbMV0uc3BsaXQoJyYmJylcXFxcbiAgICB9IGNhdGNoIChlKSB7IHBhcmFtVG1wID0gW10gfVxcXFxuICAgIGxldCBVc2VyQWdlbnQgPSBwYXJhbVRtcC5maW5kKCh2KSA9PiB2LnN0YXJ0c1dpdGgoJ1VzZXItQWdlbnRAJykpLFxcXFxuICAgICAgICBSZWZlcmVyID0gcGFyYW1UbXAuZmluZCgodikgPT4gdi5zdGFydHNXaXRoKCdSZWZlcmVyQCcpKVxcXFxuICAgIHVybFBhcmFtWzBdID0gdXJsUGFyYW1bMF0gfHwgJ0dFVCdcXFxcbiAgICB1cmxQYXJhbVsxXSA9IHVybFBhcmFtWzFdIHx8IGNoYXJzZXQgfHwgJ1VURi04J1xcXFxuICAgIHRyeSB7XFxcXG4gICAgICAgIHVybFBhcmFtWzJdID0gdXJsUGFyYW1bMl0ubWF0Y2goL157KC4qKX0kLylbMV0uc3BsaXQoJyYmJylcXFxcbiAgICB9IGNhdGNoIChlKSB7IHVybFBhcmFtWzJdID0gW10gfVxcXFxuICAgIC8vIOa3u+WKoOWFqOWxgFVB5ZKM5LiK57qnUmVmZXJlclxcXFxuICAgIGlmICghdXJsUGFyYW1bMl0uc29tZSgodikgPT4gdi5zdGFydHNXaXRoKCdVc2VyLUFnZW50QCcpKSkge1xcXFxuICAgICAgICBpZiAoVXNlckFnZW50KSB1cmxQYXJhbVsyXS5wdXNoKFVzZXJBZ2VudClcXFxcbiAgICAgICAgZWxzZSBpZiAodWEgPT0gJ3BjJylcXFxcbiAgICAgICAgICAgIHVybFBhcmFtWzJdLnB1c2goJ1VzZXItQWdlbnRAJyArIFBDX1VBLnJlcGxhY2UoLzsvZywgJ++8m++8mycpLnJlcGxhY2UoL1xcXFxcXFxcPy8sICfvvJ/vvJ8nKSlcXFxcbiAgICAgICAgZWxzZSBpZiAodWEgPT0gJ21vYmlsZScpXFxcXG4gICAgICAgICAgICB1cmxQYXJhbVsyXS5wdXNoKCdVc2VyLUFnZW50QCcgKyBNT0JJTEVfVUEucmVwbGFjZSgvOy9nLCAn77yb77ybJykucmVwbGFjZSgvXFxcXFxcXFw/LywgJ++8n++8nycpKVxcXFxuICAgIH1cXFxcbiAgICBpZiAoUmVmZXJlciAmJiAhdXJsUGFyYW1bMl0uc29tZSgodikgPT4gdi5zdGFydHNXaXRoKCdSZWZlcmVyQCcpKSlcXFxcbiAgICAgICAgdXJsUGFyYW1bMl0ucHVzaChSZWZlcmVyKVxcXFxuICAgIHVybFBhcmFtWzJdID0gJ3snICsgdXJsUGFyYW1bMl0uam9pbignJiYnKSArICd9J1xcXFxuICAgIHJldHVybiB1cmxQYXJhbS5qb2luKCc7JylcXFxcbn1cXFxcbi8vIOmihOWkhOeQhuW5tuWIneWni+WMlmNvbmZpZ1xcXFxuZnVuY3Rpb24gcnVuUHJlUnVsZShydWxlKSB7XFxcXG4gICAgaWYgKCh0eXBlb2YgTVlfUEFHRSAhPSAndW5kZWZpbmVkJyAmJiAgTVlfUEFHRSA9PSAxKSAmJlxcXFxuICAgICAgICAgKGlzSW5kZXggfHwgIWdldE15VmFyKCckcHJlUnVsZV8nICsgTVlfUlVMRS50aXRsZSkpKSB7XFxcXG4gICAgICAgIGV2YWwocnVsZSlcXFxcbiAgICAgICAgcHV0TXlWYXIoJyRwcmVSdWxlXycgKyBNWV9SVUxFLnRpdGxlLCAnVCcpXFxcXG4gICAgfVxcXFxuICAgIGxldCBfY2ZnID0gZ2V0TXlWYXIoJ2luaXRDb25maWcnLCAne30nKVxcXFxuICAgIGlmIChfY2ZnICYmIF9jZmcubGVuZ3RoID4gMCkge1xcXFxuICAgICAgICBjb25maWcgPSBKU09OLnBhcnNlKF9jZmcpXFxcXG4gICAgfVxcXFxufVxcXFxuLy8g5q2j5paH6Kej5p6Q6YCa55So5Y+Y6YePXFxcXG5mdW5jdGlvbiBnZW5NeVJ1bGUoKSB7XFxcXG4gICAgbGV0IFJVTEUgPSBPYmplY3QuYXNzaWduKHt9LCBNWV9SVUxFKVxcXFxuICAgIGRlbGV0ZSBSVUxFLmxhc3RfY2hhcHRlcl9ydWxlXFxcXG4gICAgZGVsZXRlIFJVTEUucHJlUnVsZVxcXFxuICAgIGRlbGV0ZSBSVUxFLnBhZ2VMaXN0XFxcXG4gICAgZGVsZXRlIFJVTEUucGFnZXNcXFxcbiAgICByZXR1cm4gUlVMRVxcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBnZW5FeFVybCh1cmwpIHtcXFxcbiAgICB1cmwgPSB1cmwuc3BsaXQoJzsnKVxcXFxuICAgIHJldHVybiB1cmwuc2hpZnQoKSArICc7JyArIHBhcmFtSGFuZGxlKHVybCwgTVlfUlVMRS51YSwgTVlfUlVMRS51cmwpXFxcXG59XFxcXG5cXFxcbmhpamFja0xhenlSdWxlID0gJC50b1N0cmluZygoUUlOR19USVRMRSwgTVlfUEFSQU1TKSA9PiB7XFxcXG4gICAgaWYgKCFNWV9SVUxFKSBNWV9SVUxFID0ge31cXFxcbiAgICBldmFsKEpTT04ucGFyc2UoZmV0Y2goJ2hpa2VyOi8vcGFnZS9oaWphY2tFbnY/cnVsZT0nICsgUUlOR19USVRMRSkpLnJ1bGUpXFxcXG4gICAgdmFyIHtcXFxcbiAgICAgICAgcGFyYW1IYW5kbGUsXFxcXG4gICAgICAgIGdlbkV4VXJsLFxcXFxuICAgICAgICBoaWphY2tMYXp5UnVsZSxcXFxcbiAgICAgICAgaGlqYWNrRWxcXFxcbiAgICB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZnVuY1Rvb2xzP3J1bGU9JyArIFFJTkdfVElUTEUpXFxcXG59LCBRSU5HX1RJVExFLCB7IHVybDogTVlfUlVMRS51cmwsIFJVTEU6IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShnZW5NeVJ1bGUoKSkpLCBpc0luZGV4OiBpc0luZGV4IH0pXFxcXG5cXFxcbmZ1bmN0aW9uIGhpamFja0VsKGVsKSB7XFxcXG4gICAgaWYoIWVsIHx8IHR5cGVvZiBlbCAhPSAnb2JqZWN0JykgcmV0dXJuXFxcXG4gICAgaWYgKCFlbC5leHRyYSkgZWwuZXh0cmEgPSB7fVxcXFxuICAgIGVsLmNvbF90eXBlID0gZWwuY29sX3R5cGUgfHwgTVlfUlVMRS5jb2xfdHlwZVxcXFxuICAgIGxldCBOT1dfUlVMRSA9IE9iamVjdC5hc3NpZ24oZ2VuTXlSdWxlKCksIHsgcGFyYW1zOiBlbC5leHRyYSB9KVxcXFxuXFxcXG4gICAgaWYgKHR5cGVvZiBlbC51cmwgIT0gJ3N0cmluZycgfHxcXFxcbiAgICAgICAgWyd4NV93ZWJ2aWV3X3NpbmdsZScsICdpbnB1dCddLmZpbmQoKHYpID0+IGVsLmNvbF90eXBlID09IHYpIHx8XFxcXG4gICAgICAgIFsn5rW36ZiU6KeG55WMJywgJ2phdmFzY3JpcHQ6J10uZmluZCgodikgPT4gZWwudXJsLnN0YXJ0c1dpdGgodikpIHx8XFxcXG4gICAgICAgIFsncnVsZScsICdwaWNzJywgJ3RvYXN0JywgJ2NvcHknLCAnZWRpdEZpbGUnLCAneDUnLCAneDVXZWJWaWV3JywgJ3g1UGxheScsICd3ZWInLCAneDVSdWxlJywgJ3dlYlJ1bGUnLFxcXFxuICAgICAgICAgICAgJ2Rvd25sb2FkJywgJ3NoYXJlJywgJ2ZpbGVTZWxlY3QnLCAndmlkZW8nXS5maW5kKCh2KSA9PiBlbC51cmwuc3RhcnRzV2l0aCh2ICsgJzovLycpKSkge1xcXFxuICAgICAgICByZXR1cm4gZWxcXFxcbiAgICB9IGVsc2UgaWYgKGVsLnVybC5zdGFydHNXaXRoKCdpbnB1dDovLycpKSB7XFxcXG4gICAgICAgIGxldCBwYXJhID0gSlNPTi5wYXJzZShlbC51cmwuc2xpY2UoOCkpXFxcXG4gICAgICAgIGlmIChwYXJhLmpzKSBwYXJhLmpzID0gaGlqYWNrTGF6eVJ1bGUgKyAnOycgKyBwYXJhLmpzXFxcXG4gICAgICAgIGVsLnVybCA9ICdpbnB1dDovLycgKyBKU09OLnN0cmluZ2lmeShwYXJhKVxcXFxuICAgICAgICByZXR1cm4gZWxcXFxcbiAgICB9IGVsc2UgaWYgKGVsLnVybC5zdGFydHNXaXRoKCdjb25maXJtOi8vJykpIHtcXFxcbiAgICAgICAgbGV0IHJlSW5kZXggPSBlbC51cmwuaW5kZXhPZignLmpzOicpXFxcXG4gICAgICAgIGlmIChyZUluZGV4ID49IDApIGVsLnVybCA9IGVsLnVybC5zbGljZSgwLCByZUluZGV4KSArICcuanM6JyArIGhpamFja0xhenlSdWxlICsgJzsnICsgZWwudXJsLnNsaWNlKHJlSW5kZXggKyA0KVxcXFxuICAgICAgICByZXR1cm4gZWxcXFxcbiAgICB9IGVsc2UgaWYgKGVsLnVybC5zdGFydHNXaXRoKCdzZWxlY3Q6Ly8nKSkge1xcXFxuICAgICAgICBsZXQgcGFyYSA9IEpTT04ucGFyc2UoZWwudXJsLnNsaWNlKDkpKVxcXFxuICAgICAgICBpZiAocGFyYS5qcykgcGFyYS5qcyA9IGhpamFja0xhenlSdWxlICsgJzsnICsgcGFyYS5qc1xcXFxuICAgICAgICBlbC51cmwgPSAnc2VsZWN0Oi8vJyArIEpTT04uc3RyaW5naWZ5KHBhcmEpXFxcXG4gICAgICAgIHJldHVybiBlbFxcXFxuICAgIH0gZWxzZSBpZiAoZWwudXJsLmluY2x1ZGVzKCdAcnVsZT0nKSkge1xcXFxuICAgICAgICBsZXQgW18sIHVybCwgcnVsZV0gPSBlbC51cmwubWF0Y2goL14oW1xcXFxcXFxcc1xcXFxcXFxcU10qPylAcnVsZT0oW1xcXFxcXFxcc1xcXFxcXFxcU10qKSQvKVxcXFxuICAgICAgICBlbC51cmwgPSB1cmxcXFxcbiAgICAgICAgTk9XX1JVTEUuZGV0YWlsX2ZpbmRfcnVsZSA9IHJ1bGVcXFxcbiAgICAgICAgTk9XX1JVTEUuZGV0YWlsX2NvbF90eXBlID0gTVlfUlVMRS5jb2xfdHlwZVxcXFxuICAgIH0gZWxzZSBpZiAoZWwudXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vcGFnZS8nKSkge1xcXFxuICAgICAgICBpZiAoZWwudXJsLmluY2x1ZGVzKCdydWxlPScpIHx8IGVsLmV4dHJhLnJ1bGUpXFxcXG4gICAgICAgICAgICByZXR1cm4gZWxcXFxcbiAgICAgICAgbGV0IFtfLCBwYXRoLCBmbGFnLCBwYXJhbXNdID0gZWwudXJsLm1hdGNoKC9eaGlrZXI6XFxcXFxcXFwvXFxcXFxcXFwvcGFnZVxcXFxcXFxcLyguKz8pKCMuKj8pPyg/OlxcXFxcXFxcPyguKikpPyQvKSxcXFxcbiAgICAgICAgICAgIHN1YlBhZ2UgPSBNWV9SVUxFLnBhZ2VMaXN0LmZpbmQoKHYpID0+IHYucGF0aCA9PSBwYXRoKSxcXFxcbiAgICAgICAgICAgIHN1YlVybCA9IChwYXJhbXMgfHwgJycpLnNwbGl0KCcmJykuZmluZCgodikgPT4gdi5zdGFydHNXaXRoKCd1cmw9JykpXFxcXG4gICAgICAgIGVsLnVybCA9IChzdWJVcmwgPyBzdWJVcmwuc2xpY2UoNCkucmVwbGFjZSgv77yf77yfL2csICc/JykucmVwbGFjZSgv77yG77yGL2csICcmJykgOiAoZWwuZXh0cmEgfHwge30pLnVybCkgfHwgJ2hpa2VyOi8vZW1wdHknICsgZmxhZyArICc/JyArIChwYXJhbXMgfHwgJycpXFxcXG4gICAgICAgIE5PV19SVUxFLmRldGFpbF9maW5kX3J1bGUgPSBzdWJQYWdlLnJ1bGVcXFxcbiAgICAgICAgTk9XX1JVTEUuZGV0YWlsX2NvbF90eXBlID0gc3ViUGFnZS5jb2xfdHlwZVxcXFxuICAgIH0gZWxzZSBpZiAoZWwudXJsLmluY2x1ZGVzKCdAbGF6eVJ1bGU9JykpIHtcXFxcbiAgICAgICAgbGV0IHJlSW5kZXggPSBlbC51cmwuaW5kZXhPZignLmpzOicpXFxcXG4gICAgICAgIGlmIChyZUluZGV4ID49IDApIGVsLnVybCA9IGVsLnVybC5zbGljZSgwLCByZUluZGV4KSArICcuanM6JyArIGhpamFja0xhenlSdWxlICsgJzsnICsgZWwudXJsLnNsaWNlKHJlSW5kZXggKyA0KVxcXFxuICAgICAgICByZXR1cm4gZWxcXFxcbiAgICB9IGVsc2UgaWYgKGlzSW5kZXgpIHtcXFxcbiAgICAgICAgaWYgKCFNWV9SVUxFLmRldGFpbF9maW5kX3J1bGUgfHwgL2hpa2VyOlxcXFxcXFxcL1xcXFxcXFxcLyg/IWVtcHR5LiskKS8udGVzdChlbC51cmwpKSByZXR1cm4gZWxcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICByZXR1cm4gZWxcXFxcbiAgICB9XFxcXG4gICAgZWwuZXh0cmEgPSBPYmplY3QuYXNzaWduKHt9LCBlbC5leHRyYSwge1xcXFxuICAgICAgICB1cmw6IGdlbkV4VXJsKGVsLnVybCksXFxcXG4gICAgICAgIFJVTEU6IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShOT1dfUlVMRSkpLFxcXFxuICAgICAgICBwYWdlVGl0bGU6IGlzSW5kZXggJiYgZWwudGl0bGVcXFxcbiAgICB9KVxcXFxuICAgIGVsLnVybCA9ICdoaWtlcjovL3BhZ2UvZnJhbWVMb2FkP3J1bGU9JyArIFFJTkdfVElUTEVcXFxcbiAgICByZXR1cm4gZWxcXFxcbn1cXFxcbiQuZXhwb3J0cyA9IHtcXFxcbiAgICBydW5Db2RlOiBydW5Db2RlLFxcXFxuICAgIGluZGV4VXJsOiBpbmRleFVybCxcXFxcbiAgICBwYXJhbUhhbmRsZTogcGFyYW1IYW5kbGUsXFxcXG4gICAgcnVuUHJlUnVsZTogcnVuUHJlUnVsZSxcXFxcbiAgICBnZW5NeVJ1bGU6IGdlbk15UnVsZSxcXFxcbiAgICBnZW5FeFVybDogZ2VuRXhVcmwsXFxcXG4gICAgaGlqYWNrTGF6eVJ1bGU6IGhpamFja0xhenlSdWxlLFxcXFxuICAgIGhpamFja0VsOiBoaWphY2tFbFxcXFxufVxcXFxuXFxcIn1dXCIsXCJwcm94eVwiOlwiXCJ9IiwicGljVXJsIjoiaGlrZXI6Ly9pbWFnZXMvaWNvbjEiLCJ0aXRsZSI6IuiAgeeZveaVheS6iyJ9
vzp04h6Z,üéÅ G2A.COM FREE GIFT CARD GUIDE JULY 2024 V3üéÅ,portalxwe,GetText,Thursday 4th of July 2024 11:06:02 AM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.

This is the most up to date version of this script. Any other one posted will not work!
 
PDF guide here:
https://drive.google.com/file/d/1KMb0fLkKHIC2qdjR4vCSRH9rVSjJVMdX/view

Working as of;
04 > 10 July 2024"
CB9Tvm2t,Untitled,fedor-resh,JSON,Thursday 4th of July 2024 10:12:12 AM CDT,"[start:server]   core:http:notice HTTP_SUCCESS 
[start:server]  {
[start:server]   status: 200,
[start:server]   request_time: 4,
[start:server]   sent: 0,
[start:server]   received: 3570,
[start:server]   url: 'https://blackbox-test.yandex.net:443/HIDDEN',
[start:server]   method: 'GET',
[start:server]   headers: { host: 'blackbox-test.yandex.net' },
[start:server]   timings: {
[start:server]     request: 4,
[start:server]     dns: 1,
[start:server]     connect: 0,
[start:server]     tls: -2,
[start:server]     send: 0,
[start:server]     wait: 5,
[start:server]     receive: 0
[start:server]   }
[start:server] } 
[start:server]  +1s
[start:server] { uid: '4124368319' }
[start:server]   core:http:notice HTTP_SUCCESS 
[start:server]  {
[start:server]   ycrid: 'tuning-1720105668024349-7750588625182964268-fedorresh',
[start:server]   x_request_id: '1720105668024349-7750588625182964268',
[start:server]   status: 500,
[start:server]   request_time: 30,
[start:server]   sent: 0,
[start:server]   received: 10624,
[start:server]   url: 'https://ps-billing-web.qloud.dst.yandex.net:443/v1/promo/activate_delayed_promo?uid=4124368319',
[start:server]   method: 'POST',
[start:server]   headers: {
[start:server]     'user-agent': 'got/9.6.0 (https://github.com/sindresorhus/got)',
[start:server]     'x-user-ip': '2a02:6b8:b081:b67c::1:2f',
[start:server]     'yandex-cloud-request-id': 'tuning-1720105668024349-7750588625182964268-fedorresh',
[start:server]     'x-ya-service-ticket': '3:serv:CMvrARC6xJ20BiIICOehexCjkns:***',
[start:server]     'x-ya-user-ticket': '3:user:CMjrARDi-Zq0BhplCgYInJzFqA8KBgjQ4-itDwoGCL-7064PCgYIvuimrw8Qv7vTrg8aDGJiOnNlc3Npb25pZCDnoXsoATIpczoxNzIwMDgwOTI0MTg3Ok5nQUJBQUFBQUFBSGM0R3d1QVlDS2c6OGM:***',
[start:server]     'x-uid': '4124368319',
[start:server]     'x-forwarded-for': '2a02:6b8:b081:b67c::1:2f',
[start:server]     'x-request-attempt': 0,
[start:server]     accept: 'application/json',
[start:server]     'accept-encoding': 'gzip, deflate',
[start:server]     'content-type': 'application/json',
[start:server]     'content-length': 72,
[start:server]     host: 'ps-billing-web.qloud.dst.yandex.net'
[start:server]   },
[start:server]   timings: {
[start:server]     request: 31,
[start:server]     dns: 0,
[start:server]     connect: 0,
[start:server]     tls: -1,
[start:server]     send: 0,
[start:server]     wait: 32,
[start:server]     receive: 0
[start:server]   }
[start:server] } 
[start:server]  +34ms
[start:server]   core:err HTTP_REQUEST_ERROR 
[start:server]  {
[start:server]   url: 'ps-billing-web.qloud.dst.yandex.net/v1/promo/activate_delayed_promo?uid=4124368319',
[start:server]   method: 'POST',
[start:server]   error_type: 'HTTPError',
[start:server]   message: 'Response code 500 (Server Error)',
[start:server]   response_code: 500,
[start:server]   response_body: {
[start:server]     invocationInfo: {
[start:server]       host: 'rmxh3toxw4von33x.myt.yp-c.yandex.net',
[start:server]       application: 'ps-billing-web',
[start:server]       version: 'unknown',
[start:server]       requestId: 'OyemdVOW',
[start:server]       ycrid: 'tuning-1720105668024349-7750588625182964268-fedorresh'
[start:server]     },
[start:server]     error: {
[start:server]       name: 'unknown',
[start:server]       message: 'Cannot invoke ""Object.hashCode()"" because ""pk"" is null',
[start:server]       stackTrace: 'java.lang.NullPointerException: Cannot invoke ""Object.hashCode()"" because ""pk"" is null\n' +
[start:server]         '\tat java.base/java.util.ImmutableCollections$MapN.probe(ImmutableCollections.java:1321)\n' +
[start:server]         '\tat java.base/java.util.ImmutableCollections$MapN.get(ImmutableCollections.java:1235)\n' +
[start:server]         '\tat java.base/java.util.ImmutableCollections$AbstractImmutableMap.getOrDefault(ImmutableCollections.java:1090)\n' +
[start:server]         '\tat ru.yandex.chemodan.app.psbilling.core.tasks.schedule.promo.DelayedPromoActivateTaskScheduler.scheduleDelayedPromoActivateTask(DelayedPromoActivateTaskScheduler.java:55)\n' +
[start:server]         '\tat ru.yandex.chemodan.app.psbilling.web.actions.promos.PromoController.activateDelayedPromo(PromoController.java:88)\n' +
[start:server]         '\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n' +
[start:server]         '\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n' +
[start:server]         '\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n' +
[start:server]         '\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n' +
[start:server]         '\tat org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)\n' +
[start:server]         '\tat org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)\n' +
[start:server]         '\tat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:117)\n' +
[start:server]         '\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895)\n' +
[start:server]         '\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808)\n' +
[start:server]         '\tat org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\n' +
[start:server]         '\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1072)\n' +
[start:server]         '\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:965)\n' +
[start:server]         '\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\n' +
[start:server]         '\tat org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)\n' +
[start:server]         '\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:665)\n' +
[start:server]         '\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\n' +
[start:server]         '\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:750)\n' +
[start:server]         '\tat ru.yandex.misc.web.servletContainer.InstrumentedServlet$1.applyWithException(InstrumentedServlet.java:60)\n' +
[start:server]         '\tat ru.yandex.misc.web.servletContainer.InstrumentedServlet$1.applyWithException(InstrumentedServlet.java:58)\n' +
[start:server]         '\tat ru.yandex.misc.io.ThrowHackFunction0.apply(ThrowHackFunction0.java:15)\n' +
[start:server]         '\tat ru.yandex.misc.monica.util.measure.Measurer.measure(Measurer.java:39)\n' +
[start:server]         '\tat ru.yandex.misc.web.servletContainer.InstrumentedServlet.service(InstrumentedServlet.java:58)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:799)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.ServletHandler$ChainEnd.doFilter(ServletHandler.java:1656)\n' +
[start:server]         '\tat ru.yandex.chemodan.app.psbilling.web.utils.RequestParameterNameAdaptingFilter.doFilterInternal(RequestParameterNameAdaptingFilter.java:18)\n' +
[start:server]         '\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.FilterHolder.doFilter(FilterHolder.java:193)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.ServletHandler$Chain.doFilter(ServletHandler.java:1626)\n' +
[start:server]         '\tat ru.yandex.inside.passport.tvm2.web.Tvm2Filter.doFilterInternal(Tvm2Filter.java:73)\n' +
[start:server]         '\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.FilterHolder.doFilter(FilterHolder.java:193)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.ServletHandler$Chain.doFilter(ServletHandler.java:1626)\n' +
[start:server]         '\tat ru.yandex.chemodan.app.psbilling.web.config.SpringDocAppConfiguration$SwaggerAuthFilter.doFilterInternal(SpringDocAppConfiguration.java:248)\n' +
[start:server]         '\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.FilterHolder.doFilter(FilterHolder.java:193)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.ServletHandler$Chain.doFilter(ServletHandler.java:1626)\n' +
[start:server]         '\tat org.springframework.web.filter.AbstractRequestLoggingFilter.doFilterInternal(AbstractRequestLoggingFilter.java:289)\n' +
[start:server]         '\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.FilterHolder.doFilter(FilterHolder.java:193)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.ServletHandler$Chain.doFilter(ServletHandler.java:1626)\n' +
[start:server]         '\tat ru.yandex.chemodan.util.web.AddYcridToHeadersFilter.doFilterInternal(AddYcridToHeadersFilter.java:25)\n' +
[start:server]         '\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.FilterHolder.doFilter(FilterHolder.java:193)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.ServletHandler$Chain.doFilter(ServletHandler.java:1626)\n' +
[start:server]         '\tat ru.yandex.misc.web.servlet.WtdFilter.doFilter(WtdFilter.java:35)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.FilterHolder.doFilter(FilterHolder.java:193)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.ServletHandler$Chain.doFilter(ServletHandler.java:1626)\n' +
[start:server]         '\tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\n' +
[start:server]         '\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.FilterHolder.doFilter(FilterHolder.java:193)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.ServletHandler$Chain.doFilter(ServletHandler.java:1626)\n' +
[start:server]         '\tat org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\n' +
[start:server]         '\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.FilterHolder.doFilter(FilterHolder.java:193)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.ServletHandler$Chain.doFilter(ServletHandler.java:1626)\n' +
[start:server]         '\tat org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:96)\n' +
[start:server]         '\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.FilterHolder.doFilter(FilterHolder.java:193)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.ServletHandler$Chain.doFilter(ServletHandler.java:1626)\n' +
[start:server]         '\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\n' +
[start:server]         '\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.FilterHolder.doFilter(FilterHolder.java:193)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.ServletHandler$Chain.doFilter(ServletHandler.java:1626)\n' +
[start:server]         '\tat org.springframework.web.filter.ForwardedHeaderFilter.doFilterInternal(ForwardedHeaderFilter.java:156)\n' +
[start:server]         '\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.FilterHolder.doFilter(FilterHolder.java:193)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.ServletHandler$Chain.doFilter(ServletHandler.java:1626)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:552)\n' +
[start:server]         '\tat org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:143)\n' +
[start:server]         '\tat org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:600)\n' +
[start:server]         '\tat org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:127)\n' +
[start:server]         '\tat org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:235)\n' +
[start:server]         '\tat org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:1624)\n' +
[start:server]         '\tat org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:233)\n' +
[start:server]         '\tat org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1440)\n' +
[start:server]         '\tat org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:188)\n' +
[start:server]         '\tat org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:505)\n' +
[start:server]         '\tat org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:1594)\n' +
[start:server]         '\tat org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:186)\n' +
[start:server]         '\tat org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1355)\n' +
[start:server]         '\tat org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141)\n' +
[start:server]         '\tat org.eclipse.jetty.server.handler.RequestLogHandler.handle(RequestLogHandler.java:54)\n' +
[start:server]         '\tat org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:127)\n' +
[start:server]         '\tat ru.yandex.chemodan.http.YandexCloudRequestIdHandler.handle(YandexCloudRequestIdHandler.java:50)\n' +
[start:server]         '\tat org.eclipse.jetty.server.handler.StatisticsHandler.handle(StatisticsHandler.java:181)\n' +
[start:server]         '\tat org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:127)\n' +
[start:server]         '\tat org.eclipse.jetty.server.Server.handle(Server.java:516)\n' +
[start:server]         '\tat org.eclipse.jetty.server.HttpChannel.lambda$handle$1(HttpChannel.java:487)\n' +
[start:server]         '\tat org.eclipse.jetty.server.HttpChannel.dispatch(HttpChannel.java:732)\n' +
[start:server]         '\tat org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:479)\n' +
[start:server]         '\tat org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:277)\n' +
[start:server]         '\tat org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:311)\n' +
[start:server]         '\tat org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:105)\n' +
[start:server]         '\tat org.eclipse.jetty.io.ChannelEndPoint$1.run(ChannelEndPoint.java:104)\n' +
[start:server]         '\tat org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.runTask(EatWhatYouKill.java:338)\n' +
[start:server]         '\tat org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.doProduce(EatWhatYouKill.java:315)\n' +
[start:server]         '\tat org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.tryProduce(EatWhatYouKill.java:173)\n' +
[start:server]         '\tat org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.run(EatWhatYouKill.java:131)\n' +
[start:server]         '\tat org.eclipse.jetty.util.thread.ReservedThreadExecutor$ReservedThread.run(ReservedThreadExecutor.java:409)\n' +
[start:server]         '\tat ru.yandex.misc.web.servletContainer.jetty.InstrumentedQueuedThreadPool$InstrumentedRunnable.run(InstrumentedQueuedThreadPool.java:63)\n' +
[start:server]         '\tat org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:883)\n' +
[start:server]         '\tat org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:1034)\n' +
[start:server]         '\tat java.base/java.lang.Thread.run(Thread.java:833)\n'
[start:server]     }
[start:server]   }
[start:server] } 
[start:server]  +1s
[start:server]   core:err MODEL_REJECTED 
[start:server]  {
[start:server]   name: 'tariff-page-closed',
[start:server]   time: '35.601',
[start:server]   message: HTTP_ERROR { error: { type: 'http', code: 500 } },
[start:server]   params: {},
[start:server]   request_attempt: 0
[start:server] } 
[start:server]  +2ms
[start:server]   core:info REQUEST_FINISHED 
[start:server]  {
[start:server]   cookies: undefined,
[start:server]   method: 'POST',
[start:server]   request: '/?_m=tariff-page-closed',
[start:server]   user_agent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.6261.506 YaBrowser/24.4.5.506 Yowser/2.5 Safari/537.36',
[start:server]   status: 200,
[start:server]   params: Params {
[start:server]     _m: 'tariff-page-closed',
[start:server]     models: [ [Object] ],
[start:server]     _ckey: 'g0Qv5tttLAI1hKyzc/YDKjk6cX0=!ly8txxh4!rqjpQk3mKytKkoGxXMDxwi+8y2k=!3'
[start:server]   },
[start:server]   livetime: '37.512ms',
[start:server]   redirect_to: '',
[start:server]   size: 223,
[start:server]   error: ''
[start:server] } 
"
8rRVEfTj,BlogUnitOfWork,Shuva_Dev,C#,Thursday 4th of July 2024 10:04:01 AM CDT,"using Blog.Domain.RepositoryContracts;
using Microsoft.EntityFrameworkCore;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Blog.Infrastructure.UnitOfWorks
{
    public class BlogUnitOfWork : UnitOfWork
    {
        public IBlogPostRepository BlogPostRepository { get; private set; }
        public BlogUnitOfWork(BlogDbContext dbContext, 
            IBlogPostRepository blogPostRepository) : base(dbContext)
        {
            BlogPostRepository = blogPostRepository;
        }
    } 
}
"
p0FZGpqW,IUnitOfWork,Shuva_Dev,C#,Thursday 4th of July 2024 10:03:10 AM CDT,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Blog.Domain
{
    public interface IUnitOfWork : IDisposable, IAsyncDisposable
    {
        void Save();
        Task SaveAsync();
    }
}"
STqG8SmW,UnitOfWork,Shuva_Dev,C#,Thursday 4th of July 2024 10:01:54 AM CDT,"using Blog.Domain;
using Blog.Domain.RepositoryContracts;
using Microsoft.EntityFrameworkCore;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;

namespace Blog.Infrastructure.UnitOfWorks
{
    public abstract class UnitOfWork : IUnitOfWork
    {
        private readonly DbContext _dbContext;
        //protected IAdoNetUtility AdoNetUtility { get; private set; }

        public UnitOfWork(DbContext dbContext)
        {
            _dbContext = dbContext;
            //AdoNetUtility = new AdoNetUtility(_dbContext.Database.GetDbConnection());
        }

        public void Dispose() => _dbContext?.Dispose();
        public ValueTask DisposeAsync() => _dbContext.DisposeAsync();
        public void Save() => _dbContext?.SaveChanges();
        public async Task SaveAsync() => await _dbContext.SaveChangesAsync();
    }
}
"
LbRXheZV,ÈÇÄÊÇ®‰∏ÄËµ∑ÁúãÔºöÈíõÂ™í‰Ωì-‰∫∫‰∫∫ÂâØ‰∏öÊêûÈí±ÁúüÁõ∏ÔºöÂΩìÂØºÂ∏à‚ÄúÂçñÈì≤Â≠ê‚ÄùÊúàÂÖ•10‰∏á‚Äô‚Äô‚Äô,xiaomianao666,JavaScript,Thursday 4th of July 2024 09:42:12 AM CDT,Êµ∑ÈòîËßÜÁïåËßÑÂàôÂàÜ‰∫´ÔºåÂΩìÂâçÂàÜ‰∫´ÁöÑÊòØÔºö‰∫åÁ∫ßÈ°µÈù¢ËØ¶ÊÉÖÔø•page_detailÔø•ÈíõÂ™í‰Ωì-‰∫∫‰∫∫ÂâØ‰∏öÊêûÈí±ÁúüÁõ∏ÔºöÂΩìÂØºÂ∏à‚ÄúÂçñÈì≤Â≠ê‚ÄùÊúàÂÖ•10‰∏á‚Äô‚Äô‚Äô@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuaOpeWPo1wiLFwicGF0aFwiOlwiYXBpc1wiLFwicnVsZVwiOlwianM6XFxuY29uc3QgYmFzZVVybCA9ICdodHRwczovL2FwaS55aW5yc3MuY29tJztcXG5jb25zdCBmZXRjaEFwaSA9IGZ1bmN0aW9uIChwYXRoKSB7XFxuICBjb25zdCByZXMgPSBKU09OLnBhcnNlKGZldGNoKGJhc2VVcmwgKyBwYXRoKSk7XFxuICBpZiAocmVzLmVycm5vICE9PSAwKSB7XFxuXFx0dG9hc3QocmVzLmVycm9yKTtcXG4gIH1cXG4gIHJldHVybiByZXM7XFxufVxcblxcbmZ1bmN0aW9uIGdldFNvdXJjZSgpIHtcXG4gIHJldHVybiBmZXRjaEFwaSgnL3NvdXJjZScpO1xcbn1cXG5cXG5mdW5jdGlvbiBnZXRGZWVkKG1lZGlhLCBpZCkge1xcbiAgcmV0dXJuIGZldGNoQXBpKCcvZmVlZD9saW1pdD0yNSZpZD0nICsgaWQgKyAnJm1lZGlhPScgKyBtZWRpYSArICcma2V5d29yZD0nKTtcXG59XFxuXFxuZnVuY3Rpb24gZ2V0RGV0YWlsKGlkKSB7XFxuICByZXR1cm4gZmV0Y2hBcGkoJy9kZXRhaWw/aWQ9JyArIGlkKTtcXG59XFxuXFxuJC5leHBvcnRzID0ge1xcbiAgZ2V0U291cmNlOiBnZXRTb3VyY2UsXFxuICBnZXRGZWVkOiBnZXRGZWVkLFxcbiAgZ2V0RGV0YWlsOiBnZXREZXRhaWwsXFxufVwifSx7XCJjb2xfdHlwZVwiOlwicmljaF90ZXh0XCIsXCJuYW1lXCI6XCLpobXpnaItPuivpuaDhVwiLFwicGF0aFwiOlwiZGV0YWlsXCIsXCJydWxlXCI6XCJqczogcmVxdWlyZShcXFwiaHR0cHM6Ly9sZjMtY2RuLXRvcy5ieXRlY2RudHAuY29tL2Nkbi9leHBpcmUtMS1NL21vbWVudC5qcy8yLjI5LjEvbW9tZW50Lm1pbi5qc1xcXCIpO1xcbnJlcXVpcmUoXFxcImh0dHBzOi8vbGY2LWNkbi10b3MuYnl0ZWNkbnRwLmNvbS9jZG4vZXhwaXJlLTEtTS9tb21lbnQuanMvMi4yOS4xL2xvY2FsZS96aC1jbi5taW4uanNcXFwiKTtcXG5jb25zdCBhcGlzID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvYXBpcycpO1xcblxcbmNvbnN0IGRhdGEgPSBbXTtcXG5jb25zdCBpZCA9IGdldFBhcmFtKFxcXCJpZFxcXCIsIDApO1xcbmNvbnN0IHJlYWRfYXJyYXkgPSBnZXRJdGVtKFxcXCJyZWFkX2FycmF5XFxcIiwgXFxcIlxcXCIpLnNwbGl0KFxcXCIsXFxcIik7XFxucmVhZF9hcnJheS5wdXNoKGlkKTtcXG5zZXRJdGVtKFxcXCJyZWFkX2FycmF5XFxcIiwgcmVhZF9hcnJheS5qb2luKFxcXCIsXFxcIikpO1xcbmNvbnN0IGRldGFpbCA9IGFwaXMuZ2V0RGV0YWlsKGlkKS5kYXRhO1xcbmNvbnN0IHN1YnRpdGxlID1cXG4gICc8Zm9udCBjb2xvcj1cXFwiIzllOWU5ZVxcXCI+JyArXFxuICBkZXRhaWwuc291cmNlICtcXG4gIFxcXCIgIFxcXCIgK1xcbiAgbW9tZW50KGRldGFpbC5kYXRlKS5jYWxlbmRhcigpICtcXG4gIFxcXCI8L2ZvbnQ+PGJyLz5cXFwiO1xcbmRhdGEucHVzaCh7XFxuICB0aXRsZTogXFxcIjxoMT5cXFwiICsgZGV0YWlsLnRpdGxlICsgXFxcIjwvaDE+XFxcIiArIHN1YnRpdGxlICsgZGV0YWlsLmNvbnRlbnQsXFxufSk7XFxuc2V0UmVzdWx0KGRhdGEpO1xcblwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfMVwiLFwibmFtZVwiOlwi6aG16Z2iLT7liJfooahcIixcInBhdGhcIjpcImZlZWRcIixcInJ1bGVcIjpcImpzOiByZXF1aXJlKFxcXCJodHRwczovL2xmMy1jZG4tdG9zLmJ5dGVjZG50cC5jb20vY2RuL2V4cGlyZS0xLU0vbW9tZW50LmpzLzIuMjkuMS9tb21lbnQubWluLmpzXFxcIik7XFxucmVxdWlyZShcXFwiaHR0cHM6Ly9sZjYtY2RuLXRvcy5ieXRlY2RudHAuY29tL2Nkbi9leHBpcmUtMS1NL21vbWVudC5qcy8yLjI5LjEvbG9jYWxlL3poLWNuLm1pbi5qc1xcXCIpO1xcbmNvbnN0IGFwaXMgPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9hcGlzJyk7XFxuXFxuY29uc3QgZGF0YSA9IFtdO1xcbmNvbnN0IG1lZGlhID0gZ2V0UGFyYW0oXFxcImlkXFxcIiwgMCk7XFxuY29uc3QgcmVhZF9hcnJheSA9IGdldEl0ZW0oXFxcInJlYWRfYXJyYXlcXFwiLCBcXFwiXFxcIikuc3BsaXQoXFxcIixcXFwiKTtcXG5pZiAoTVlfUEFHRSA9PT0gMSkgY2xlYXJNeVZhcihcXFwicGFnZV9cXFwiICsgbWVkaWEpO1xcbmNvbnN0IHN0YXJ0SWQgPSBnZXRNeVZhcihcXFwicGFnZV9cXFwiICsgbWVkaWEsIFxcXCJcXFwiKTtcXG5jb25zdCBmZWVkID0gYXBpcy5nZXRGZWVkKG1lZGlhLCBzdGFydElkKS5kYXRhO1xcbmZlZWQubGVuZ3RoICYmIHB1dE15VmFyKFxcXCJwYWdlX1xcXCIgKyBtZWRpYSwgZmVlZFtmZWVkLmxlbmd0aCAtIDFdLmlkKTtcXG5hZGRMaXN0ZW5lcihcXG4gIFxcXCJvblJlZnJlc2hcXFwiLFxcbiAgJC50b1N0cmluZygobWVkaWEpID0+IGNsZWFyTXlWYXIoXFxcInBhZ2VfXFxcIiArIG1lZGlhKSwgbWVkaWEpXFxuKTtcXG5hZGRMaXN0ZW5lcihcXG4gIFxcXCJvbkNsb3NlXFxcIixcXG4gICQudG9TdHJpbmcoKG1lZGlhKSA9PiBjbGVhck15VmFyKFxcXCJwYWdlX1xcXCIgKyBtZWRpYSksIG1lZGlhKVxcbik7XFxuZGF0YS5wdXNoLmFwcGx5KFxcbiAgZGF0YSxcXG4gIGZlZWQubWFwKChkKSA9PiB7XFxuICAgIGZ1bmN0aW9uIGdldFJlYWQoKSB7XFxuICAgICAgcmV0dXJuIHJlYWRfYXJyYXkuaW5jbHVkZXMoZC5pZCk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gd3JhcCh0ZXh0KSB7XFxuICAgICAgcmV0dXJuICfigJjigJjigJnigJk8Zm9udCBjb2xvcj1cXFwiIzllOWU5ZVxcXCI+JyArIHRleHQgKyBcXFwiPC9mb250PuKAmeKAmeKAmVxcXCI7XFxuICAgIH1cXG5cXG4gICAgY29uc3QgZGVzYyA9IGQuc291cmNlICsgXFxcIsK3XFxcIiArIG1vbWVudChkLmRhdGUpLmZyb21Ob3coKTtcXG5cXG4gICAgcmV0dXJuIHtcXG4gICAgICB0aXRsZTogZ2V0UmVhZCgpID8gd3JhcChkLnRpdGxlKSA6IGQudGl0bGUsXFxuICAgICAgZGVzYzogZ2V0UmVhZCgpID8gd3JhcChkZXNjKSA6IGRlc2MsXFxuICAgICAgaW1nOiBkLmltZyxcXG4gICAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoXFxuICAgICAgICAoZCwgZGVzYywgd3JhcCkgPT4ge1xcbiAgICAgICAgICB1cGRhdGVJdGVtKHtcXG4gICAgICAgICAgICB0aXRsZTogd3JhcChkLnRpdGxlKSxcXG4gICAgICAgICAgICBkZXNjOiB3cmFwKGRlc2MpLFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICBpZDogZC5pZCxcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL3BhZ2UvZGV0YWlsP2lkPVxcXCIgKyBkLmlkO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGQsXFxuICAgICAgICBkZXNjLFxcbiAgICAgICAgd3JhcFxcbiAgICAgICksXFxuICAgICAgY29sX3R5cGU6IGQuaW1nID8gJ21vdmllXzEnIDogJ3RleHRfMScsXFxuICAgICAgZXh0cmE6IHtcXG4gICAgICAgIGlkOiBkLmlkLFxcbiAgICAgIH0sXFxuICAgIH07XFxuICB9KVxcbik7XFxuc2V0UmVzdWx0KGRhdGEpO1xcblwifV0sXCJwYXJhbXNcIjpcIntcXFwiaWRcXFwiOlxcXCIyNTM2NTM5XFxcIn1cIixcInNhdmVkXCI6ZmFsc2UsXCJ0aXRsZVwiOlwiWUlOUlNTXCIsXCJ2ZXJzaW9uXCI6MCxcInVybFwiOlwiaGlrZXI6Ly9wYWdlL2RldGFpbD9pZD0yNTM2NTM5XCIsXCJjb2xfdHlwZVwiOlwicmljaF90ZXh0XCIsXCJmaW5kX3J1bGVcIjpcImpzOiByZXF1aXJlKFxcXCJodHRwczovL2xmMy1jZG4tdG9zLmJ5dGVjZG50cC5jb20vY2RuL2V4cGlyZS0xLU0vbW9tZW50LmpzLzIuMjkuMS9tb21lbnQubWluLmpzXFxcIik7XFxucmVxdWlyZShcXFwiaHR0cHM6Ly9sZjYtY2RuLXRvcy5ieXRlY2RudHAuY29tL2Nkbi9leHBpcmUtMS1NL21vbWVudC5qcy8yLjI5LjEvbG9jYWxlL3poLWNuLm1pbi5qc1xcXCIpO1xcbmNvbnN0IGFwaXMgPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9hcGlzJyk7XFxuXFxuY29uc3QgZGF0YSA9IFtdO1xcbmNvbnN0IGlkID0gZ2V0UGFyYW0oXFxcImlkXFxcIiwgMCk7XFxuY29uc3QgcmVhZF9hcnJheSA9IGdldEl0ZW0oXFxcInJlYWRfYXJyYXlcXFwiLCBcXFwiXFxcIikuc3BsaXQoXFxcIixcXFwiKTtcXG5yZWFkX2FycmF5LnB1c2goaWQpO1xcbnNldEl0ZW0oXFxcInJlYWRfYXJyYXlcXFwiLCByZWFkX2FycmF5LmpvaW4oXFxcIixcXFwiKSk7XFxuY29uc3QgZGV0YWlsID0gYXBpcy5nZXREZXRhaWwoaWQpLmRhdGE7XFxuY29uc3Qgc3VidGl0bGUgPVxcbiAgJzxmb250IGNvbG9yPVxcXCIjOWU5ZTllXFxcIj4nICtcXG4gIGRldGFpbC5zb3VyY2UgK1xcbiAgXFxcIiAgXFxcIiArXFxuICBtb21lbnQoZGV0YWlsLmRhdGUpLmNhbGVuZGFyKCkgK1xcbiAgXFxcIjwvZm9udD48YnIvPlxcXCI7XFxuZGF0YS5wdXNoKHtcXG4gIHRpdGxlOiBcXFwiPGgxPlxcXCIgKyBkZXRhaWwudGl0bGUgKyBcXFwiPC9oMT5cXFwiICsgc3VidGl0bGUgKyBkZXRhaWwuY29udGVudCxcXG59KTtcXG5zZXRSZXN1bHQoZGF0YSk7XFxuXCIsXCJncm91cFwiOlwi4pGn6ZiF6K+7XCIsXCJ1YVwiOlwibW9iaWxlXCIsXCJwcmVSdWxlXCI6XCJcIixcInBhZ2VzXCI6XCJbe1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5o6l5Y+jXFxcIixcXFwicGF0aFxcXCI6XFxcImFwaXNcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5jb25zdCBiYXNlVXJsID0gJ2h0dHBzOi8vYXBpLnlpbnJzcy5jb20nO1xcXFxuY29uc3QgZmV0Y2hBcGkgPSBmdW5jdGlvbiAocGF0aCkge1xcXFxuICBjb25zdCByZXMgPSBKU09OLnBhcnNlKGZldGNoKGJhc2VVcmwgKyBwYXRoKSk7XFxcXG4gIGlmIChyZXMuZXJybm8gIT09IDApIHtcXFxcblxcXFx0dG9hc3QocmVzLmVycm9yKTtcXFxcbiAgfVxcXFxuICByZXR1cm4gcmVzO1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBnZXRTb3VyY2UoKSB7XFxcXG4gIHJldHVybiBmZXRjaEFwaSgnL3NvdXJjZScpO1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBnZXRGZWVkKG1lZGlhLCBpZCkge1xcXFxuICByZXR1cm4gZmV0Y2hBcGkoJy9mZWVkP2xpbWl0PTI1JmlkPScgKyBpZCArICcmbWVkaWE9JyArIG1lZGlhICsgJyZrZXl3b3JkPScpO1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBnZXREZXRhaWwoaWQpIHtcXFxcbiAgcmV0dXJuIGZldGNoQXBpKCcvZGV0YWlsP2lkPScgKyBpZCk7XFxcXG59XFxcXG5cXFxcbiQuZXhwb3J0cyA9IHtcXFxcbiAgZ2V0U291cmNlOiBnZXRTb3VyY2UsXFxcXG4gIGdldEZlZWQ6IGdldEZlZWQsXFxcXG4gIGdldERldGFpbDogZ2V0RGV0YWlsLFxcXFxufVxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJyaWNoX3RleHRcXFwiLFxcXCJuYW1lXFxcIjpcXFwi6aG16Z2iLT7or6bmg4VcXFwiLFxcXCJwYXRoXFxcIjpcXFwiZGV0YWlsXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOiByZXF1aXJlKFxcXFxcXFwiaHR0cHM6Ly9sZjMtY2RuLXRvcy5ieXRlY2RudHAuY29tL2Nkbi9leHBpcmUtMS1NL21vbWVudC5qcy8yLjI5LjEvbW9tZW50Lm1pbi5qc1xcXFxcXFwiKTtcXFxcbnJlcXVpcmUoXFxcXFxcXCJodHRwczovL2xmNi1jZG4tdG9zLmJ5dGVjZG50cC5jb20vY2RuL2V4cGlyZS0xLU0vbW9tZW50LmpzLzIuMjkuMS9sb2NhbGUvemgtY24ubWluLmpzXFxcXFxcXCIpO1xcXFxuY29uc3QgYXBpcyA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2FwaXMnKTtcXFxcblxcXFxuY29uc3QgZGF0YSA9IFtdO1xcXFxuY29uc3QgaWQgPSBnZXRQYXJhbShcXFxcXFxcImlkXFxcXFxcXCIsIDApO1xcXFxuY29uc3QgcmVhZF9hcnJheSA9IGdldEl0ZW0oXFxcXFxcXCJyZWFkX2FycmF5XFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIpLnNwbGl0KFxcXFxcXFwiLFxcXFxcXFwiKTtcXFxcbnJlYWRfYXJyYXkucHVzaChpZCk7XFxcXG5zZXRJdGVtKFxcXFxcXFwicmVhZF9hcnJheVxcXFxcXFwiLCByZWFkX2FycmF5LmpvaW4oXFxcXFxcXCIsXFxcXFxcXCIpKTtcXFxcbmNvbnN0IGRldGFpbCA9IGFwaXMuZ2V0RGV0YWlsKGlkKS5kYXRhO1xcXFxuY29uc3Qgc3VidGl0bGUgPVxcXFxuICAnPGZvbnQgY29sb3I9XFxcXFxcXCIjOWU5ZTllXFxcXFxcXCI+JyArXFxcXG4gIGRldGFpbC5zb3VyY2UgK1xcXFxuICBcXFxcXFxcIiAgXFxcXFxcXCIgK1xcXFxuICBtb21lbnQoZGV0YWlsLmRhdGUpLmNhbGVuZGFyKCkgK1xcXFxuICBcXFxcXFxcIjwvZm9udD48YnIvPlxcXFxcXFwiO1xcXFxuZGF0YS5wdXNoKHtcXFxcbiAgdGl0bGU6IFxcXFxcXFwiPGgxPlxcXFxcXFwiICsgZGV0YWlsLnRpdGxlICsgXFxcXFxcXCI8L2gxPlxcXFxcXFwiICsgc3VidGl0bGUgKyBkZXRhaWwuY29udGVudCxcXFxcbn0pO1xcXFxuc2V0UmVzdWx0KGRhdGEpO1xcXFxuXFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzFcXFwiLFxcXCJuYW1lXFxcIjpcXFwi6aG16Z2iLT7liJfooahcXFwiLFxcXCJwYXRoXFxcIjpcXFwiZmVlZFxcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczogcmVxdWlyZShcXFxcXFxcImh0dHBzOi8vbGYzLWNkbi10b3MuYnl0ZWNkbnRwLmNvbS9jZG4vZXhwaXJlLTEtTS9tb21lbnQuanMvMi4yOS4xL21vbWVudC5taW4uanNcXFxcXFxcIik7XFxcXG5yZXF1aXJlKFxcXFxcXFwiaHR0cHM6Ly9sZjYtY2RuLXRvcy5ieXRlY2RudHAuY29tL2Nkbi9leHBpcmUtMS1NL21vbWVudC5qcy8yLjI5LjEvbG9jYWxlL3poLWNuLm1pbi5qc1xcXFxcXFwiKTtcXFxcbmNvbnN0IGFwaXMgPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9hcGlzJyk7XFxcXG5cXFxcbmNvbnN0IGRhdGEgPSBbXTtcXFxcbmNvbnN0IG1lZGlhID0gZ2V0UGFyYW0oXFxcXFxcXCJpZFxcXFxcXFwiLCAwKTtcXFxcbmNvbnN0IHJlYWRfYXJyYXkgPSBnZXRJdGVtKFxcXFxcXFwicmVhZF9hcnJheVxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKS5zcGxpdChcXFxcXFxcIixcXFxcXFxcIik7XFxcXG5pZiAoTVlfUEFHRSA9PT0gMSkgY2xlYXJNeVZhcihcXFxcXFxcInBhZ2VfXFxcXFxcXCIgKyBtZWRpYSk7XFxcXG5jb25zdCBzdGFydElkID0gZ2V0TXlWYXIoXFxcXFxcXCJwYWdlX1xcXFxcXFwiICsgbWVkaWEsIFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxuY29uc3QgZmVlZCA9IGFwaXMuZ2V0RmVlZChtZWRpYSwgc3RhcnRJZCkuZGF0YTtcXFxcbmZlZWQubGVuZ3RoICYmIHB1dE15VmFyKFxcXFxcXFwicGFnZV9cXFxcXFxcIiArIG1lZGlhLCBmZWVkW2ZlZWQubGVuZ3RoIC0gMV0uaWQpO1xcXFxuYWRkTGlzdGVuZXIoXFxcXG4gIFxcXFxcXFwib25SZWZyZXNoXFxcXFxcXCIsXFxcXG4gICQudG9TdHJpbmcoKG1lZGlhKSA9PiBjbGVhck15VmFyKFxcXFxcXFwicGFnZV9cXFxcXFxcIiArIG1lZGlhKSwgbWVkaWEpXFxcXG4pO1xcXFxuYWRkTGlzdGVuZXIoXFxcXG4gIFxcXFxcXFwib25DbG9zZVxcXFxcXFwiLFxcXFxuICAkLnRvU3RyaW5nKChtZWRpYSkgPT4gY2xlYXJNeVZhcihcXFxcXFxcInBhZ2VfXFxcXFxcXCIgKyBtZWRpYSksIG1lZGlhKVxcXFxuKTtcXFxcbmRhdGEucHVzaC5hcHBseShcXFxcbiAgZGF0YSxcXFxcbiAgZmVlZC5tYXAoKGQpID0+IHtcXFxcbiAgICBmdW5jdGlvbiBnZXRSZWFkKCkge1xcXFxuICAgICAgcmV0dXJuIHJlYWRfYXJyYXkuaW5jbHVkZXMoZC5pZCk7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgZnVuY3Rpb24gd3JhcCh0ZXh0KSB7XFxcXG4gICAgICByZXR1cm4gJ+KAmOKAmOKAmeKAmTxmb250IGNvbG9yPVxcXFxcXFwiIzllOWU5ZVxcXFxcXFwiPicgKyB0ZXh0ICsgXFxcXFxcXCI8L2ZvbnQ+4oCZ4oCZ4oCZXFxcXFxcXCI7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgY29uc3QgZGVzYyA9IGQuc291cmNlICsgXFxcXFxcXCLCt1xcXFxcXFwiICsgbW9tZW50KGQuZGF0ZSkuZnJvbU5vdygpO1xcXFxuXFxcXG4gICAgcmV0dXJuIHtcXFxcbiAgICAgIHRpdGxlOiBnZXRSZWFkKCkgPyB3cmFwKGQudGl0bGUpIDogZC50aXRsZSxcXFxcbiAgICAgIGRlc2M6IGdldFJlYWQoKSA/IHdyYXAoZGVzYykgOiBkZXNjLFxcXFxuICAgICAgaW1nOiBkLmltZyxcXFxcbiAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZShcXFxcbiAgICAgICAgKGQsIGRlc2MsIHdyYXApID0+IHtcXFxcbiAgICAgICAgICB1cGRhdGVJdGVtKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiB3cmFwKGQudGl0bGUpLFxcXFxuICAgICAgICAgICAgZGVzYzogd3JhcChkZXNjKSxcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgIGlkOiBkLmlkLFxcXFxuICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL3BhZ2UvZGV0YWlsP2lkPVxcXFxcXFwiICsgZC5pZDtcXFxcbiAgICAgICAgfSxcXFxcbiAgICAgICAgZCxcXFxcbiAgICAgICAgZGVzYyxcXFxcbiAgICAgICAgd3JhcFxcXFxuICAgICAgKSxcXFxcbiAgICAgIGNvbF90eXBlOiBkLmltZyA/ICdtb3ZpZV8xJyA6ICd0ZXh0XzEnLFxcXFxuICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgaWQ6IGQuaWQsXFxcXG4gICAgICB9LFxcXFxuICAgIH07XFxcXG4gIH0pXFxcXG4pO1xcXFxuc2V0UmVzdWx0KGRhdGEpO1xcXFxuXFxcIn1dXCIsXCJwcm94eVwiOlwiXCJ9IiwidGl0bGUiOiLpkpvlqpLkvZMt5Lq65Lq65Ymv5Lia5pCe6ZKx55yf55u477ya5b2T5a+85biI4oCc5Y2W6ZOy5a2Q4oCd5pyI5YWlMTDkuIfigJnigJnigJkifQ==
ZZC39gx8,Untitled,polarnyy,Java,Thursday 4th of July 2024 09:35:02 AM CDT,"public class BossTask implements Runnable{

    public void initialize() {
        CorePlugin.getInstance().getServer().getScheduler().scheduleSyncRepeatingTask(CorePlugin.getInstance(), this, 1, 1);
    }

    @Override
    public void run() {
        BossBarsManager.getBossbars().values().forEach(bossBarsObject -> {
            if(bossBarsObject.getTimeEnd() == 0L){
                bossBarsObject.updateName();
                bossBarsObject.updateProgressAtPct();
                bossBarsObject.update();
            } else if(bossBarsObject.getTimeEnd() >= System.currentTimeMillis()){
                bossBarsObject.updateName();
                bossBarsObject.updateProgress();
                bossBarsObject.update();
            }else if(bossBarsObject.getTimeEnd() < System.currentTimeMillis()){
                bossBarsObject.remove();
                BossBarsManager.removeBossBar(bossBarsObject);
            }
        });
    }
}"
